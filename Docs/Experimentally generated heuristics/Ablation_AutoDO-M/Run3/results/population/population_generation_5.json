[
     {
          "name": "enhanced_amortized_cost_dispatch",
          "algorithm": "1. Classify units into forced-on (due to min up-time or shutdown constraints), forced-off (due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline). 2. Precompute amortized cost metrics for free units: (operating cost at min power for free online; startup cost amortized over min up-time plus operating cost at min power for free offline). 3. Form initial commitment set: forced-on units + free units sorted by amortized cost. 4. While total ramp-constrained max capacity < current load: add next cheapest free unit. 5. While total ramp-constrained min capacity > load: remove most expensive free unit (if feasible). 6. For committed units: calculate feasible power bounds considering ramp constraints. 7. Dispatch load using lambda iteration with residual adjustment for exact matching. 8. Set non-committed units to off with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints and state\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost metrics for free units\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        cost_metric[i] = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_metric[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n    \n    # Create sorted free unit list (by cost metric ascending)\n    free_units = free_online + free_offline\n    free_units_sorted = sorted(free_units, key=lambda i: cost_metric[i])\n    \n    # Initialize committed set with forced-on units\n    committed_set = set(forced_on)\n    \n    # Calculate initial capacity bounds\n    total_min = 0.0\n    total_max = 0.0\n    \n    def get_feasible_bounds(i, committed=False):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Was offline, only if committed (being started)\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        return min_p, max_p\n    \n    for i in committed_set:\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Add free units until total_max >= current_load\n    for i in free_units_sorted:\n        if total_max >= current_load:\n            break\n        if i in committed_set:\n            continue\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        committed_set.add(i)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Remove expensive free units if total_min > current_load\n    free_committed = [i for i in committed_set if i not in forced_on]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    changed = True\n    while changed and free_committed_sorted:\n        changed = False\n        for i in free_committed_sorted:\n            candidate_set = committed_set - {i}\n            # Recalculate bounds for candidate set\n            new_min = 0.0\n            new_max = 0.0\n            for j in candidate_set:\n                min_p_j, max_p_j = get_feasible_bounds(j, j in candidate_set)\n                new_min += min_p_j\n                new_max += max_p_j\n            if new_min <= current_load <= new_max:\n                committed_set = candidate_set\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n        # Update free_committed list after removal\n        free_committed = [i for i in committed_set if i not in forced_on]\n        free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    # Update commitment status\n    for i in committed_set:\n        u[i] = 1\n    \n    # Precompute bounds for dispatch\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    for i in committed_set:\n        min_b, max_b = get_feasible_bounds(i, True)\n        min_bounds[i] = min_b\n        max_bounds[i] = max_b\n    \n    # Collect indices and coefficients for committed units\n    committed_indices = list(committed_set)\n    b_arr = np.array([units_info[i]['b_i'] for i in committed_indices])\n    c_arr = np.array([units_info[i]['c_i'] for i in committed_indices])\n    min_p_arr = min_bounds[committed_indices]\n    max_p_arr = max_bounds[committed_indices]\n    \n    # Initialize power for committed units\n    p_committed = np.zeros(len(committed_indices))\n    \n    # Lambda iteration for dispatch\n    if len(committed_indices) > 0:\n        lo_mc = 1e-6\n        hi_mc = 1e8\n        tol = 1e-3\n        max_iter = 100\n        \n        for _ in range(max_iter):\n            lam = (lo_mc + hi_mc) / 2\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:  # Linear cost\n                    if lam > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:  # Quadratic cost\n                    p_unclipped = (lam - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            \n            total_proposed = np.sum(p_proposed)\n            \n            if abs(total_proposed - current_load) < tol:\n                p_committed = p_proposed\n                break\n            \n            if total_proposed < current_load:\n                lo_mc = lam\n            else:\n                hi_mc = lam\n        else:\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:\n                    if lo_mc > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:\n                    p_unclipped = (lo_mc - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            p_committed = p_proposed\n        \n        # Residual adjustment for exact match\n        total_gen = np.sum(p_committed)\n        residual = current_load - total_gen\n        if abs(residual) > 1e-3:\n            # Positive residual: increase under-max units by marginal cost\n            if residual > 0:\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] < max_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    headroom = max_p_arr[unit_idx] - p_committed[unit_idx]\n                    if headroom < residual:\n                        p_committed[unit_idx] += headroom\n                        residual -= headroom\n                    else:\n                        p_committed[unit_idx] += residual\n                        residual = 0\n                        break\n            # Negative residual: decrease above-min units by marginal cost (reverse)\n            else:\n                residual = abs(residual)\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] > min_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)[::-1]\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    footroom = p_committed[unit_idx] - min_p_arr[unit_idx]\n                    if footroom < residual:\n                        p_committed[unit_idx] -= footroom\n                        residual -= footroom\n                    else:\n                        p_committed[unit_idx] -= residual\n                        residual = 0\n                        break\n        \n        # Assign power values to committed units\n        for idx, unit_idx in enumerate(committed_indices):\n            p[unit_idx] = p_committed[idx]\n    \n    # Set non-committed units to off and output zero\n    for i in range(n_units):\n        if i not in committed_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0050588692,
          "gap_price_rate": 0.0088502454,
          "fitness": 0.0069545573
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "commit_units_by_amortized_cost",
          "algorithm": "1. Classify units into forced-on (must remain on due to min up-time/shutdown constraints), forced-off (min downtime), free online (currently on but adjustable), and free offline (currently off but available).\n2. Calculate cost rates for free units:\n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate list sorted by cost rates: forced-on first, then free units by ascending cost.\n4. Build committed set by adding candidates until total max capacity \u2265 load:\n   - Free online: min/max = max(p_min_i, p_i_0-p_down_i) to min(p_max_i, p_i_0+p_up_i)\n   - Free offline: min/max = p_min_i to min(p_max_i, p_start_i)\n5. Set non-committed units to u_i=0, p_i=0.\n6. Perform constrained economic dispatch for committed units:\n   - Determine feasible power bounds considering ramp constraints\n   - Use lambda iteration to find optimal dispatch minimizing cost\n   - Adjust outputs to exactly match load\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef commit_units_by_amortized_cost(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Currently online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Currently offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost rates for free units\n    cost_rates = {}\n    for i in free_online:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        cost_rates[i] = (unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    for i in free_offline:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_rates[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    # Form sorted candidate list\n    candidate_list = forced_on[:]\n    candidate_list.extend(sorted(free_online + free_offline, key=lambda i: cost_rates.get(i, 0)))\n    \n    # Build committed set\n    committed = set()\n    total_min = 0.0\n    total_max = 0.0\n    unit_bounds = {}\n    \n    for i in forced_on:  # Add forced-on units\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    for i in candidate_list:  # Add candidates until sufficient capacity\n        if i in forced_on:\n            continue  # Already added\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[i]\n        if i in free_online:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    # Set non-committed units to offline\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            u[i] = 1\n    \n    # Handle extreme load cases\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = unit_bounds[i][0]\n        return np.array([u, p])\n    \n    if current_load >= total_max:\n        for i in committed:\n            p[i] = unit_bounds[i][1]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_bounds = np.array([unit_bounds[i][0] for i in range(n_units) if i in committed])\n    high_bounds = np.array([unit_bounds[i][1] for i in range(n_units) if i in committed])\n    b = np.array([units_info[i]['b_i'] for i in range(n_units) if i in committed])\n    c = np.array([units_info[i]['c_i'] for i in range(n_units) if i in committed])\n    \n    lambda_low = min(b + 2 * c * low_bounds)\n    lambda_high = max(b + 2 * c * high_bounds)\n    tolerance = 1e-5\n    max_iter = 100\n    iter_count = 0\n    n_committed = len(low_bounds)\n    p_dispatch = np.copy(low_bounds)\n    \n    while iter_count < max_iter:\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        total_power = 0.0\n        \n        # Calculate optimal unconstrained dispatch\n        for i in range(n_committed):\n            p_opt = (lambda_mid - b[i]) / (2 * c[i])\n            p_dispatch[i] = np.clip(p_opt, low_bounds[i], high_bounds[i])\n        \n        total_power = np.sum(p_dispatch)\n        \n        # Check convergence\n        if abs(total_power - current_load) <= tolerance:\n            break\n            \n        # Adjust lambda\n        if total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        iter_count += 1\n    \n    # Assign dispatched values to committed units\n    dispatch_idx = 0\n    for i in range(n_units):\n        if i in committed:\n            p[i] = p_dispatch[dispatch_idx]\n            dispatch_idx += 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055425116,
          "gap_price_rate": 0.0089835115,
          "fitness": 0.0072630116
     },
     {
          "name": "enhanced_amortized_commitment_dispatch",
          "algorithm": "**  \n1. Classify units into forced-on (must remain on due to minimum up-time or shutdown ramp constraints), forced-off (must remain off due to minimum down-time), free online (adjustable units currently online), and free offline (adjustable units currently offline).  \n2. Calculate amortized cost metrics for free units:  \n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i  \n   - Free offline: (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i  \n3. Build candidate list: forced-on first, then free units sorted by ascending cost metric.  \n4. Form committed set:  \n   - Initialize with forced-on units.  \n   - Add free units in cost order until total max capacity \u2265 load.  \n   - If total min capacity > load, remove expensive free units (descending cost) while maintaining max capacity \u2265 load.  \n5. Calculate feasible power bounds for committed units:  \n   - Previously online: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)  \n   - Newly started: min = p_min_i, max = min(p_max_i, p_start_i)  \n6. Dispatch load:  \n   - If load \u2264 total min, set all outputs to min.  \n   - If load \u2265 total max, set all outputs to max.  \n   - Else, use lambda iteration (bisection) to find optimal dispatch within bounds.  \n7. Set non-committed units to off state (u_i = 0, p_i = 0).  \n8. Return schedules as a 2D NumPy array.  \n\n**",
          "code": "import numpy as np\n\ndef enhanced_amortized_commitment_dispatch(units_info, load):\n    load_current = load[0]\n    n_units = len(units_info)\n    u_output = [0] * n_units\n    p_output = [0.0] * n_units\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    candidate_list = []\n    for i in free_online:\n        unit = units_info[i]\n        a, b, c, p_min = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i']\n        cost_metric = (a + b * p_min + c * p_min**2) / p_min\n        candidate_list.append((i, cost_metric))\n    \n    for i in free_offline:\n        unit = units_info[i]\n        a, b, c, p_min, s, t_up = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i'], unit['s_i'], unit['t_on_min_i']\n        cost_metric = (s / t_up + a + b * p_min + c * p_min**2) / p_min\n        candidate_list.append((i, cost_metric))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed_set = set(forced_on)\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in forced_on:\n        unit = units_info[i]\n        p_min, p_max, p_i0, p_down, p_up = unit['p_min_i'], unit['p_max_i'], unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n        min_i = max(p_min, p_i0 - p_down)\n        max_i = min(p_max, p_i0 + p_up)\n        total_min += min_i\n        total_max += max_i\n    \n    free_committed = []\n    for i, _ in candidate_list:\n        if total_max >= load_current:\n            break\n        unit = units_info[i]\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        if i in free_online:\n            p_i0, p_down, p_up = unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n            min_i = max(p_min, p_i0 - p_down)\n            max_i = min(p_max, p_i0 + p_up)\n        else:\n            min_i = p_min\n            max_i = min(p_max, unit['p_start_i'])\n        \n        committed_set.add(i)\n        free_committed.append(i)\n        total_min += min_i\n        total_max += max_i\n    \n    if total_min > load_current and free_committed:\n        free_cost_map = {idx: cm for idx, cm in candidate_list}\n        free_committed.sort(key=lambda i: free_cost_map[i], reverse=True)\n        \n        for i in free_committed[:]:\n            if total_min <= load_current:\n                break\n            unit = units_info[i]\n            p_min, p_max = unit['p_min_i'], unit['p_max_i']\n            if i in free_online:\n                p_i0, p_down, p_up = unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n                min_i = max(p_min, p_i0 - p_down)\n                max_i = min(p_max, p_i0 + p_up)\n            else:\n                min_i = p_min\n                max_i = min(p_max, unit['p_start_i'])\n            \n            if (total_max - max_i) >= load_current:\n                committed_set.remove(i)\n                free_committed.remove(i)\n                total_min -= min_i\n                total_max -= max_i\n                if total_min <= load_current:\n                    break\n    \n    dispatch_data = []\n    for i in committed_set:\n        u_output[i] = 1\n        unit = units_info[i]\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        if i in forced_on or i in free_online:\n            p_i0, p_down, p_up = unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n            min_i = max(p_min, p_i0 - p_down)\n            max_i = min(p_max, p_i0 + p_up)\n        else:\n            min_i = p_min\n            max_i = min(p_max, unit['p_start_i'])\n        dispatch_data.append((i, min_i, max_i, unit['b_i'], unit['c_i']))\n    \n    if dispatch_data:\n        total_min_dispatch = sum(min_i for _, min_i, _, _, _ in dispatch_data)\n        total_max_dispatch = sum(max_i for _, _, max_i, _, _ in dispatch_data)\n        \n        if load_current <= total_min_dispatch:\n            for i, min_i, _, _, _ in dispatch_data:\n                p_output[i] = min_i\n        elif load_current >= total_max_dispatch:\n            for i, _, max_i, _, _ in dispatch_data:\n                p_output[i] = max_i\n        else:\n            low = 0\n            high = 0\n            for _, min_i, max_i, b_i, c_i in dispatch_data:\n                if c_i == 0:\n                    low_i = high_i = b_i\n                else:\n                    low_i = b_i + 2 * c_i * min_i\n                    high_i = b_i + 2 * c_i * max_i\n                if low_i < low: low = low_i\n                if high_i > high: high = high_i\n            \n            tolerance = 1e-5\n            max_iter = 1000\n            for _ in range(max_iter):\n                mid = (low + high) / 2\n                total_p = 0.0\n                for _, min_i, max_i, b_i, c_i in dispatch_data:\n                    if c_i == 0:\n                        p_i = min_i if mid < b_i else max_i\n                    else:\n                        p_i = (mid - b_i) / (2 * c_i)\n                        p_i = max(min_i, min(p_i, max_i))\n                    total_p += p_i\n                if abs(total_p - load_current) < tolerance:\n                    break\n                if total_p < load_current:\n                    low = mid\n                else:\n                    high = mid\n            \n            for i, min_i, max_i, b_i, c_i in dispatch_data:\n                if c_i == 0:\n                    p_i = min_i if mid < b_i else max_i\n                else:\n                    p_i = (mid - b_i) / (2 * c_i)\n                    p_i = max(min_i, min(p_i, max_i))\n                p_output[i] = p_i\n    \n    schedules = np.array([u_output, p_output], dtype=float)\n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.0055425116,
          "gap_price_rate": 0.008983512,
          "fitness": 0.0072630118
     },
     {
          "name": "combined_priority_amortized_heuristic",
          "algorithm": "1. Classify units into forced-on (must run due to min up-time or shutdown ramp constraints), forced-off (min down-time constraint), free online (adjustable but currently on), and free offline (adjustable but currently off).\n2. Calculate cost metrics for free units:\n   - Free online: (a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n3. Create candidate list: forced-on + free online + free offline, sorted by cost metric.\n4. Build committed set by adding candidates in cost-ascending order until max capacity meets load.\n5. If total min capacity exceeds load, remove expensive free units (descending cost order) while maintaining feasibility and max capacity constraint.\n6. Calculate power bounds for committed units:\n   - Previously online: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   - Newly started: min = p_min_i, max = min(p_max_i, p_start_i)\n7. Dispatch load using lambda iteration within power bounds:\n   - Handle boundary cases: set all to min/max when load outside feasible range\n   - Bisection search for optimal lambda (marginal cost)\n8. Return schedules (commitment states and power outputs) as NumPy array.\n\n",
          "code": "import numpy as np\n\ndef combined_priority_amortized_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    states = np.zeros(n_units)\n    powers = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > p_shut:\n                forced_on.append((i, unit))\n            else:\n                free_online.append((i, unit))\n        else:\n            if t_i_0 < 0 and -t_i_0 < t_off_min:\n                forced_off.append((i, unit))\n            else:\n                free_offline.append((i, unit))\n    \n    # Calculate cost metrics\n    cost_metrics = []\n    for idx, unit in free_online:\n        a, b, c, p_min = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i']\n        metric = (a + b * p_min + c * p_min**2) / p_min\n        cost_metrics.append((idx, unit, metric, 'online'))\n    \n    for idx, unit in free_offline:\n        a, b, c, s, p_min, t_on_min = unit['a_i'], unit['b_i'], unit['c_i'], unit['s_i'], unit['p_min_i'], unit['t_on_min_i']\n        metric = (s / max(1, t_on_min) + a + b * p_min + c * p_min**2) / p_min\n        cost_metrics.append((idx, unit, metric, 'offline'))\n    \n    cost_metrics.sort(key=lambda x: x[2])\n    \n    committed_set = [fu for fu in forced_on]\n    max_capacity = 0.0\n    min_capacity = 0.0\n    \n    for idx, unit in forced_on:\n        p_i_0 = unit['p_i_0']\n        max_cap = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        min_cap = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n        max_capacity += max_cap\n        min_capacity += min_cap\n    \n    candidates_to_add = []\n    for cm in cost_metrics:\n        idx, unit, metric, utype = cm\n        if utype == 'online':\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n            min_cap = unit['p_min_i']\n        candidates_to_add.append((idx, unit, min_cap, max_cap, metric))\n        if max_capacity >= current_load:\n            break\n        max_capacity += max_cap\n        min_capacity += min_cap\n        committed_set.append((idx, unit))\n    \n    if min_capacity > current_load:\n        candidates_to_remove = sorted(\n            [(idx, unit, min_cap, max_cap, metric) for (idx, unit, min_cap, max_cap, metric) in candidates_to_add],\n            key=lambda x: x[4], reverse=True\n        )\n        for cand in candidates_to_remove:\n            idx, unit, min_cap, max_cap, _ = cand\n            if min_capacity - min_cap <= current_load and max_capacity - max_cap >= current_load:\n                min_capacity -= min_cap\n                max_capacity -= max_cap\n                committed_set = [c for c in committed_set if c[0] != idx]\n                if min_capacity <= current_load:\n                    break\n    \n    # Calculate power bounds for dispatch\n    units_dispatch = []\n    bounds = []\n    for idx, unit in committed_set:\n        if unit['u_i_0'] == 1:\n            p_i_0 = unit['p_i_0']\n            p_min = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        units_dispatch.append(unit)\n        bounds.append((p_min, p_max))\n    \n    # Handle boundary cases\n    total_min = sum(p_min for p_min, _ in bounds)\n    total_max = sum(p_max for _, p_max in bounds)\n    \n    dispatch_powers = []\n    if current_load <= total_min:\n        dispatch_powers = [p_min for p_min, _ in bounds]\n    elif current_load >= total_max:\n        dispatch_powers = [p_max for _, p_max in bounds]\n    else:\n        lo = min(u['b_i'] + 2*u['c_i']*b[0] for u, b in zip(units_dispatch, bounds))\n        hi = max(u['b_i'] + 2*u['c_i']*b[1] for u, b in zip(units_dispatch, bounds))\n        tol = 1e-5\n        while hi - lo > tol:\n            lam = (lo + hi) / 2\n            total_power = 0\n            for i, (unit, (p_min, p_max)) in enumerate(zip(units_dispatch, bounds)):\n                b_i, c_i = unit['b_i'], unit['c_i']\n                p_i = (lam - b_i) / (2 * c_i)\n                p_i = max(p_min, min(p_i, p_max))\n                total_power += p_i\n            if total_power < current_load:\n                lo = lam\n            else:\n                hi = lam\n        lam_final = (lo + hi) / 2\n        for i, (unit, (p_min, p_max)) in enumerate(zip(units_dispatch, bounds)):\n            b_i, c_i = unit['b_i'], unit['c_i']\n            p_i = (lam_final - b_i) / (2 * c_i)\n            p_i = max(p_min, min(p_i, p_max))\n            dispatch_powers.append(p_i)\n    \n    # Prepare output arrays\n    for i, (idx, unit) in enumerate(committed_set):\n        states[idx] = 1\n        powers[idx] = dispatch_powers[i]\n    \n    for idx, _ in forced_off:\n        states[idx] = 0\n        powers[idx] = 0\n    \n    # Handle units not included in any set\n    handled_indices = {idx for idx, _ in committed_set} | {idx for idx, _ in forced_off}\n    for i in range(n_units):\n        if i not in handled_indices:\n            states[i] = 0\n            powers[i] = 0\n\n    return np.array([states, powers])",
          "from": "crossover",
          "gap_power_rate": 0.0055427484,
          "gap_price_rate": 0.0089835035,
          "fitness": 0.0072631259
     },
     {
          "name": "refined_priority_amortized_dispatch",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_priority_amortized_dispatch(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    # Initialize output arrays\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units, dtype=float)\n    \n    # Identify forced-on and forced-off units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check forced-on constraints\n        if u_i0 == 1 and ((t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i'])):\n            forced_on.append(idx)\n        # Check forced-off constraints\n        elif u_i0 == 0 and (-t_i0 < unit['t_off_min_i']):\n            forced_off.append(idx)\n        # Classify free units\n        elif u_i0 == 1:\n            free_online.append(idx)\n        else:\n            free_offline.append(idx)\n    \n    # Calculate cost metrics for free units\n    cost_metrics = []\n    for idx in free_online + free_offline:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min ** 2\n        \n        if idx in free_online:\n            cost_per_mw = base_cost / p_min\n        else:  # Free offline\n            amortized_startup = unit['s_i'] / unit['t_on_min_i']\n            cost_per_mw = (amortized_startup + base_cost) / p_min\n        cost_metrics.append(cost_per_mw)\n    \n    # Sort free units by cost metrics (ascending)\n    free_sorted = sorted(zip(free_online + free_offline, cost_metrics), key=lambda x: x[1])\n    candidate_list = forced_on + [idx for idx, _ in free_sorted]\n    \n    # Build committed set with ramp-constrained bounds\n    committed = set(forced_on)\n    total_min = 0.0\n    total_max = 0.0\n    bounds = {}\n    \n    # Compute bounds for forced-on units\n    for idx in forced_on:\n        unit = units_info[idx]\n        p_i0 = unit['p_i_0']\n        low_bound = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n        high_bound = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        bounds[idx] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    # Add free units until load can be met\n    for idx, _ in free_sorted:\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[idx]\n        if idx in free_online:\n            # Previously online units\n            p_i0 = unit['p_i_0']\n            low_bound = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            # New startups\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            \n        bounds[idx] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n        committed.add(idx)\n    \n    # Remove expensive units if overcommitted on min capacity\n    if total_min > current_load:\n        # Identify removable free units (non-forced)\n        free_in_committed = [idx for idx in committed if idx in (free_online + free_offline)]\n        # Sort by descending cost (most expensive first)\n        free_in_committed.sort(key=lambda i: cost_metrics[i], reverse=True)\n        \n        for idx in free_in_committed:\n            if idx not in bounds:\n                continue\n            low_bound, high_bound = bounds[idx]\n            # Check removal feasibility\n            new_total_min = total_min - low_bound\n            # Only remove if min capacity still meets load after removal\n            if new_total_min >= current_load:\n                continue\n            total_min = new_total_min\n            total_max -= high_bound\n            committed.remove(idx)\n            del bounds[idx]\n            if total_min <= current_load:\n                break\n    \n    # Handle edge cases\n    if current_load <= total_min:\n        # Distribute at minimum outputs\n        for idx in committed:\n            u[idx] = 1\n            p[idx] = bounds[idx][0]\n    elif current_load >= total_max:\n        # Distribute at maximum outputs\n        for idx in committed:\n            u[idx] = 1\n            p[idx] = bounds[idx][1]\n    else:\n        # Lambda iteration for economic dispatch\n        low_lambda = 0.0\n        high_lambda = 0.0\n        \n        # Initialize lambda bounds based on marginal costs\n        for idx in committed:\n            low_bound, high_bound = bounds[idx]\n            unit = units_info[idx]\n            # Derivative of cost function: 2 * c_i * p + b_i\n            marginal_low = 2 * unit['c_i'] * low_bound + unit['b_i']\n            marginal_high = 2 * unit['c_i'] * high_bound + unit['b_i']\n            low_lambda = min(low_lambda, marginal_low)\n            high_lambda = max(high_lambda, marginal_high)\n        \n        # Bisection settings\n        tol = 1e-4\n        max_iters = 100\n        iter_count = 0\n        \n        while iter_count < max_iters and abs(high_lambda - low_lambda) > tol:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0.0\n            # Calculate total output at current lambda\n            for idx in committed:\n                low_bound, high_bound = bounds[idx]\n                unit = units_info[idx]\n                if unit['c_i'] > tol:\n                    # Calculate unconstrained output\n                    p_uncon = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_clamped = np.clip(p_uncon, low_bound, high_bound)\n                else:\n                    # Linear cost function\n                    p_clamped = low_bound if mid_lambda < unit['b_i'] else high_bound\n                total_power += p_clamped\n            \n            # Update lambda bounds\n            if total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            iter_count += 1\n        \n        # Assign final outputs\n        for idx in committed:\n            low_bound, high_bound = bounds[idx]\n            unit = units_info[idx]\n            u[idx] = 1\n            if unit['c_i'] > tol:\n                p_uncon = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p[idx] = np.clip(p_uncon, low_bound, high_bound)\n            else:\n                p[idx] = low_bound if mid_lambda < unit['b_i'] else high_bound\n    \n    # Set non-committed units to off\n    for idx in range(num_units):\n        if idx not in committed:\n            u[idx] = 0\n            p[idx] = 0.0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055461455,
          "gap_price_rate": 0.0089833154,
          "fitness": 0.0072647305
     },
     {
          "name": "combined_priority_dispatch",
          "algorithm": "1. Determine forced commitment states: must-on units (cannot be turned off due to minimum up-time or shutdown ramp constraints), must-off units (cannot be started due to minimum down-time), and free units.\n2. Initialize on_set with must-on units and free units currently online.\n3. Calculate total min and max output capacity of current on_set, considering ramp constraints and startup limits.\n4. If max capacity < current load, activate free offline units sorted by ascending amortized startup cost until max capacity meets/exceeds load.\n5. If min capacity > current load, deactivate non-essential free units sorted by descending operating cost at min power until min capacity <= load.\n6. Compute feasible power bounds for all committed units considering ramp constraints and startup/shutdown limits.\n7. Perform economic dispatch for committed units:\n   - If load below total min, set all outputs to min.\n   - If load above total max, set all outputs to max.\n   - Otherwise, use lambda iteration for optimal dispatch within bounds.\n8. Return schedule as a 2D array (commitment states, power outputs).\n\n",
          "code": "import numpy as np\n\ndef combined_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u_i = [0] * n\n    p_i = [0.0] * n\n    muston = [False] * n\n    mustoff = [False] * n\n    on_set = set()\n\n    # Determine forced states\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                muston[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                mustoff[i] = True\n\n    # Initialize on_set with must-on and free currently online units\n    for i in range(n):\n        if muston[i] or (not muston[i] and not mustoff[i] and units_info[i]['u_i_0'] == 1):\n            on_set.add(i)\n            u_i[i] = 1\n\n    # Calculate initial power bounds\n    def compute_bounds(i):\n        if units_info[i]['u_i_0'] == 1:\n            min_bound = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_bound = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            min_bound = units_info[i]['p_min_i']\n            max_bound = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        return min_bound, max_bound\n\n    # Turn on candidates if needed (Step 4)\n    free_off = [i for i in range(n) if not muston[i] and not mustoff[i] and units_info[i]['u_i_0'] == 0]\n    amortized_cost = [(i, (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / max(1, unit['p_min_i'])) \n                      for i, unit in enumerate(units_info) if i in free_off]\n    amortized_cost.sort(key=lambda x: x[1])\n    \n    total_min = 0\n    total_max = 0\n    for i in on_set:\n        min_b, max_b = compute_bounds(i)\n        total_min += min_b\n        total_max += max_b\n    \n    for i, _ in amortized_cost:\n        if total_max < current_load and i in free_off:\n            min_b, max_b = compute_bounds(i)\n            on_set.add(i)\n            u_i[i] = 1\n            total_min += min_b\n            total_max += max_b\n\n    # Turn off non-essential if needed (Step 5)\n    non_essential = [i for i in on_set if not muston[i] and units_info[i]['u_i_0'] == 1]\n    op_cost = [(i, units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n               units_info[i]['c_i']*units_info[i]['p_min_i']**2) \n              for i in non_essential]\n    op_cost.sort(key=lambda x: x[1], reverse=True)\n    \n    for i, _ in op_cost:\n        min_b, max_b = compute_bounds(i)\n        if total_min - min_b > current_load: \n            continue\n        if total_max - max_b >= current_load:\n            on_set.remove(i)\n            u_i[i] = 0\n            total_min -= min_b\n            total_max -= max_b\n\n    # Compute final bounds for dispatch\n    lo_arr = []\n    hi_arr = []\n    b_arr = []\n    c_arr = []\n    indices = []\n    for i in on_set:\n        min_b, max_b = compute_bounds(i)\n        lo_arr.append(min_b)\n        hi_arr.append(max_b)\n        b_arr.append(units_info[i]['b_i'])\n        c_arr.append(units_info[i]['c_i'])\n        indices.append(i)\n    total_min = sum(lo_arr)\n    total_max = sum(hi_arr)\n    n_on = len(indices)\n\n    # Dispatch power for committed units\n    if n_on > 0:\n        if current_load <= total_min:\n            for idx, i in enumerate(indices):\n                p_i[i] = lo_arr[idx]\n        elif current_load >= total_max:\n            for idx, i in enumerate(indices):\n                p_i[i] = hi_arr[idx]\n        else:\n            lambda_min = min(2 * c_arr[j] * lo_arr[j] + b_arr[j] for j in range(n_on))\n            lambda_max = max(2 * c_arr[j] * hi_arr[j] + b_arr[j] for j in range(n_on))\n            tol = 1e-5\n            iter_max = 100\n            for _ in range(iter_max):\n                lambda_mid = (lambda_min + lambda_max) / 2.0\n                total_p = 0.0\n                for j in range(n_on):\n                    if abs(c_arr[j]) < 1e-7:\n                        p_val = hi_arr[j] if b_arr[j] < lambda_mid else lo_arr[j]\n                    else:\n                        p_val = (lambda_mid - b_arr[j]) / (2 * c_arr[j])\n                        p_val = max(lo_arr[j], min(hi_arr[j], p_val))\n                    total_p += p_val\n                if abs(total_p - current_load) < tol:\n                    break\n                if total_p < current_load:\n                    lambda_min = lambda_mid\n                else:\n                    lambda_max = lambda_mid\n            for j, idx_unit in enumerate(indices):\n                if abs(c_arr[j]) < 1e-7:\n                    p_i[idx_unit] = hi_arr[j] if b_arr[j] < lambda_mid else lo_arr[j]\n                else:\n                    p_val = (lambda_mid - b_arr[j]) / (2 * c_arr[j])\n                    p_i[idx_unit] = max(lo_arr[j], min(hi_arr[j], p_val))\n\n    # Format output\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_i[i]\n        schedules[1, i] = p_i[i]\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091472115,
          "fitness": 0.0072878746
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Preprocess units to determine forced commitment states based on minimum up/down times, shutdown ramp limits, and previous state.\n2. Compute available capacity from initially committed units.\n3. Turn on additional candidate units (not forced off) based on two-period average incremental cost until available capacity meets or exceeds current load.\n4. Turn off non-essential candidate units (those not forced on) based on highest operating cost to minimize total cost.\n5. Perform economic dispatch using bisection method to allocate load to committed units, respecting ramp limits and power bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    \n    forced_committed = []\n    candidate_off = []\n    candidate_on = []\n    \n    # Step 1: Determine forced commitment and candidate units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_committed.append(idx)\n            else:\n                candidate_off.append(idx)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                continue\n            else:\n                candidate_on.append(idx)\n    \n    # Helper function to get available capacity\n    def get_available_capacity(unit_indices):\n        total = 0.0\n        for idx in unit_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total += min(unit['p_max_i'], unit['p_start_i'])\n        return total\n    \n    # Initially committed units (forced on and candidate_off)\n    committed_units = forced_committed + candidate_off\n    total_available = get_available_capacity(committed_units)\n    \n    # Step 2: Turn on candidate units if needed\n    candidate_on_info = []\n    for idx in candidate_on:\n        unit = units_info[idx]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        \n        cost_current = s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        cost_next = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        total_cost = cost_current + cost_next\n        power_two_periods = 2 * p_min_i\n        aic_per_mw = total_cost / power_two_periods\n        \n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidate_on_info.append((idx, aic_per_mw, avail))\n    \n    candidate_on_info.sort(key=lambda x: x[1])\n    \n    for idx, _, avail in candidate_on_info:\n        if total_available >= current_load:\n            break\n        total_available += avail\n        committed_units.append(idx)\n    \n    # Step 3: Turn off non-essential candidate_off units\n    candidate_off_info = []\n    for idx in candidate_off:\n        if idx not in committed_units:\n            continue\n        unit = units_info[idx]\n        min_power = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_off_info.append((idx, cost, avail))\n    \n    candidate_off_info.sort(key=lambda x: x[1], reverse=True)\n    \n    new_committed = list(committed_units)\n    total_available_new = total_available\n    for idx, _, avail in candidate_off_info:\n        if (total_available_new - avail) >= current_load:\n            total_available_new -= avail\n            new_committed.remove(idx)\n    committed_units = new_committed\n    \n    # Prepare schedules array\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    for idx in committed_units:\n        schedules[0, idx] = 1\n    \n    # Step 4: Economic Dispatch\n    unit_bounds = []\n    for idx in committed_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        unit_bounds.append((idx, low_bound, high_bound))\n    \n    low_total = sum(low for _, low, _ in unit_bounds)\n    high_total = sum(high for _, _, high in unit_bounds)\n    \n    # If load not feasible, use bounds\n    if current_load < low_total or current_load > high_total:\n        for idx, low, high in unit_bounds:\n            if current_load < low_total:\n                schedules[1, idx] = low\n            else:\n                schedules[1, idx] = high\n        return schedules\n    \n    # Dispatch parameters\n    dispatch_list = []\n    min_ic = float('inf')\n    max_ic = -float('inf')\n    \n    for idx, low, high in unit_bounds:\n        unit = units_info[idx]\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        ic_low = b_i + 2 * c_i * low\n        ic_high = b_i + 2 * c_i * high\n        min_ic = min(min_ic, ic_low)\n        max_ic = max(max_ic, ic_high)\n        dispatch_list.append((idx, b_i, c_i, low, high))\n    \n    # Lambda iteration\n    lambda_low = min_ic\n    lambda_high = max_ic\n    p_values = [low for _, _, _, low, _ in dispatch_list]\n    \n    if abs(high_total - low_total) > 1e-6:\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_power = 0.0\n            new_p_values = []\n            for idx, b_i, c_i, low, high in dispatch_list:\n                if c_i == 0:\n                    if lambda_mid < b_i:\n                        p_i = low\n                    else:\n                        p_i = high\n                else:\n                    p_i = (lambda_mid - b_i) / (2 * c_i)\n                    p_i = max(low, min(high, p_i))\n                new_p_values.append(p_i)\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                p_values = new_p_values\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            p_values = new_p_values\n    \n    # Assign dispatch results\n    for (idx, _, _, _, _), power in zip(dispatch_list, p_values):\n        schedules[1, idx] = power\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054685553,
          "gap_price_rate": 0.0092084548,
          "fitness": 0.0073385051
     },
     {
          "name": "enhanced_priority_dispatch",
          "algorithm": "1. Identify must-on units: units that must remain on due to minimum up-time constraint or previous output exceeding shutdown capacity.\n2. Identify must-off units: units that must remain off due to minimum down-time constraint.\n3. Initialize committed set with must-on units and free units previously online. Calculate min/max capacity considering ramp limits.\n4. If max capacity < current load, start additional free offline units sorted by adjusted cost per MW (including startup cost amortized over min output) until max capacity meets/exceeds load.\n5. If min capacity > current load, deactivate non-essential committed units sorted by descending operating cost at min output until min capacity \u2264 load.\n6. For each committed unit, compute power bounds considering:\n   - Previous units: ramp constraints from previous output\n   - Newly started units: startup ramp limits\n7. Perform economic dispatch:\n   a. If load \u2264 total min, set all outputs to min.\n   b. If load \u2265 total max, set all outputs to max.\n   c. Else, use lambda iteration with linear handling to distribute load optimally.\n8. Set non-committed units to off (u_i=0, p_i=0).\n9. Return schedules as 2D numpy array.\n\n",
          "code": "import numpy as np\n\ndef enhanced_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    \n    # Determine forced commitment states\n    must_on = []\n    must_off = []\n    free_units = list(range(n_units))\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n                free_units.remove(i)\n            else:\n                must_off.append(i)\n                free_units.remove(i)\n        else:  # Was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n                free_units.remove(i)\n    \n    # Initialize committed set\n    on_set = set(must_on)\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            on_set.add(i)\n    \n    # Calculate current capacity limits\n    def calculate_capacity(on_set):\n        total_min = 0.0\n        total_max = 0.0\n        min_i_vals = []\n        max_i_vals = []\n        \n        for i in on_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            min_i_vals.append(min_i)\n            max_i_vals.append(max_i)\n            total_min += min_i\n            total_max += max_i\n        return total_min, total_max, min_i_vals, max_i_vals\n    \n    total_min, total_max, min_i_vals, max_i_vals = calculate_capacity(on_set)\n    \n    # Add units if capacity insufficient\n    if total_max < current_load:\n        candidates = [i for i in free_units if i not in on_set]\n        amortized_cost = []\n        for i in candidates:\n            unit = units_info[i]\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            amortized_cost.append((cost_per_mw, i))\n        amortized_cost.sort(key=lambda x: x[0])\n        \n        for _, i in amortized_cost:\n            if total_max >= current_load:\n                break\n            on_set.add(i)\n            new_min, new_max, _, _ = calculate_capacity([i])\n            total_min += new_min\n            total_max += new_max\n    \n    # Remove units if overcommitted\n    if total_min > current_load:\n        non_essential = [i for i in on_set if i not in must_on]\n        operating_cost = []\n        for i in non_essential:\n            unit = units_info[i]\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            operating_cost.append((cost_per_mw, i))\n        operating_cost.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in operating_cost:\n            if total_min <= current_load:\n                break\n            on_set.remove(i)\n            prev_min, prev_max, _, _ = calculate_capacity([i])\n            total_min -= prev_min\n            total_max -= prev_max\n    \n    # Compute dispatch bounds\n    bounds = []\n    for i in on_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((min_bound, max_bound))\n    \n    # Economic dispatch\n    if current_load <= total_min:\n        outputs = [min_bound for min_bound, _ in bounds]\n    elif current_load >= total_max:\n        outputs = [max_bound for _, max_bound in bounds]\n    else:\n        # Lambda iteration setup\n        low = min(2*units_info[i]['c_i']*bounds[idx][0] + units_info[i]['b_i'] \n                 for idx, i in enumerate(on_set) if units_info[i]['c_i'] > 0 or units_info[i]['b_i'])\n        high = max(2*units_info[i]['c_i']*bounds[idx][1] + units_info[i]['b_i'] \n                  for idx, i in enumerate(on_set) if units_info[i]['c_i'] > 0 or units_info[i]['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        lamb = (low + high) / 2\n        \n        for _ in range(max_iter):\n            total_p = 0.0\n            for idx, i in enumerate(on_set):\n                unit = units_info[i]\n                min_bound, max_bound = bounds[idx]\n                if unit['c_i'] == 0:\n                    p_i = max_bound if lamb >= unit['b_i'] else min_bound\n                else:\n                    p_i = (lamb - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_bound, min(max_bound, p_i))\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n            lamb = (low + high) / 2\n        \n        # Calculate final outputs\n        outputs = []\n        for idx, i in enumerate(on_set):\n            unit = units_info[i]\n            min_bound, max_bound = bounds[idx]\n            if unit['c_i'] == 0:\n                p_i = max_bound if lamb >= unit['b_i'] else min_bound\n            else:\n                p_i = (lamb - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(min_bound, min(max_bound, p_i))\n            outputs.append(p_i)\n    \n    # Build output arrays\n    for j, i in enumerate(on_set):\n        u_arr[i] = 1\n        p_arr[i] = outputs[j]\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0063269571,
          "gap_price_rate": 0.0083953792,
          "fitness": 0.0073611682
     },
     {
          "name": "hybrid_amortized_marginal_heuristic",
          "algorithm": "1. Enforce constraints to determine forced commitment states based on min up/down times and shutdown ramp limits.\n2. Calculate cost metrics for free units:\n   - For free online units: marginal cost at ramp-constrained minimum output.\n   - For free offline units: amortized cost (startup cost/min-up-time + operating cost at min output) per MW.\n3. Build candidate commitment set:\n   - Start with forced-on units\n   - Add free online units sorted by marginal cost\n   - Add free offline units sorted by amortized cost until total ramp-constrained max capacity >= current load\n   - Remove most expensive free units if total min output exceeds load while maintaining capacity >= load\n4. Compute feasible power bounds for committed units considering ramp constraints and startup limits.\n5. Perform economic dispatch using lambda iteration within power bounds with residual adjustment.\n6. Set non-committed units to off state with zero output.\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef hybrid_amortized_marginal_heuristic(units_info, load):\n    num_units = len(units_info)\n    current_load = load[0]  # We only use current load for this time step\n    \n    # Initialize arrays\n    u_out = np.zeros(num_units)\n    p_out = np.zeros(num_units)\n    min_bounds = np.zeros(num_units)\n    max_bounds = np.zeros(num_units)\n    \n    # Step 1: Determine forced commitment states\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        u_i_prev, t_i_0, p_i_prev = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_prev == 1:  # Unit was online\n            # Check if unit must remain online\n            if (t_i_0 < t_on_min_i) or (p_i_prev > p_shut_i):\n                forced_on.append(i)\n                min_bounds[i] = max(p_min_i, p_i_prev - unit['p_down_i'])\n                max_bounds[i] = min(p_max_i, p_i_prev + unit['p_up_i'])\n            else:\n                min_bounds[i] = max(p_min_i, p_i_prev - unit['p_down_i'])\n                max_bounds[i] = min(p_max_i, p_i_prev + unit['p_up_i'])\n        else:  # Unit was offline\n            # Check if unit must remain offline\n            if abs(t_i_0) < t_off_min_i:\n                forced_off.append(i)\n            min_bounds[i] = 0\n            max_bounds[i] = 0\n    \n    # Step 2: Classify free units and calculate cost metrics\n    free_online = []\n    free_offline = []\n    cost_metrics = np.full(num_units, np.inf)  # Use inf for non-free units\n    \n    for i, unit in enumerate(units_info):\n        if i in forced_on or i in forced_off:\n            continue  # Skip forced units\n            \n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min_i = unit['p_min_i']\n        s_i = unit['s_i']\n        t_on_min_i = unit['t_on_min_i']\n        u_i_prev, p_i_prev = unit['u_i_0'], unit['p_i_0']\n        \n        if u_i_prev == 1:  # Free online\n            feasible_min = max(p_min_i, p_i_prev - unit['p_down_i'])\n            # Marginal cost at feasible min\n            cost_metrics[i] = 2 * c_i * feasible_min + b_i\n            free_online.append(i)\n            min_bounds[i] = feasible_min\n            max_bounds[i] = min(unit['p_max_i'], p_i_prev + unit['p_up_i'])\n        else:  # Free offline\n            # Amortized cost per MW at min output\n            amortized_cost = s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * (p_min_i**2)\n            cost_metrics[i] = amortized_cost / p_min_i\n            free_offline.append(i)\n            min_bounds[i] = p_min_i\n            max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3: Build candidate commitment set\n    committed_set = set(forced_on)\n    total_min = sum(min_bounds[i] for i in committed_set)\n    total_max = sum(max_bounds[i] for i in committed_set)\n    \n    # Create candidate list sorted by cost metrics (ascending)\n    candidate_list = sorted(range(num_units), \n                           key=lambda i: cost_metrics[i] if i not in forced_on else -np.inf)\n    \n    # Add free units until max capacity meets load\n    for i in candidate_list:\n        if i in forced_on or i in forced_off:\n            continue\n        if total_max < current_load:\n            committed_set.add(i)\n            total_min += min_bounds[i]\n            total_max += max_bounds[i]\n    \n    # Create removal candidate list (free units only, descending cost)\n    removal_candidates = sorted([i for i in committed_set if i not in forced_on], \n                               key=lambda i: cost_metrics[i], reverse=True)\n    \n    # Remove expensive units if min capacity exceeds load\n    for i in removal_candidates:\n        if total_min > current_load and (total_max - max_bounds[i]) >= current_load:\n            committed_set.remove(i)\n            total_min -= min_bounds[i]\n            total_max -= max_bounds[i]\n    \n    # Step 4: Set commitment states and compute final bounds\n    for i in committed_set:\n        u_out[i] = 1\n    for i in set(range(num_units)) - committed_set:\n        u_out[i] = 0\n        p_out[i] = 0\n        min_bounds[i] = 0\n        max_bounds[i] = 0\n    \n    # Step 5: Economic dispatch for committed units\n    comm_indices = [i for i in committed_set]\n    if not comm_indices:\n        return np.array([u_out, p_out])\n    \n    # Extract bounds and cost parameters for committed units\n    comm_min_bounds = min_bounds[comm_indices]\n    comm_max_bounds = max_bounds[comm_indices]\n    comm_a = np.array([units_info[i]['a_i'] for i in comm_indices])\n    comm_b = np.array([units_info[i]['b_i'] for i in comm_indices])\n    comm_c = np.array([units_info[i]['c_i'] for i in comm_indices])\n    \n    # Lambda iteration initialization\n    current_gen = comm_min_bounds.copy()\n    lambda_low = np.min(comm_min_bounds * 2 * comm_c + comm_b)\n    lambda_high = np.max(comm_max_bounds * 2 * comm_c + comm_b) + 1000\n    \n    # Bisection for lambda\n    for _ in range(100):\n        lam = (lambda_low + lambda_high) / 2\n        for j in range(len(comm_indices)):\n            if comm_c[j] > 1e-6:\n                p_optimal = (lam - comm_b[j]) / (2 * comm_c[j])\n                current_gen[j] = min(comm_max_bounds[j], max(comm_min_bounds[j], p_optimal))\n            else:  # Linear cost\n                current_gen[j] = comm_max_bounds[j] if lam > comm_b[j] else comm_min_bounds[j]\n        \n        total_gen = np.sum(current_gen)\n        if abs(total_gen - current_load) < 0.1:\n            break\n        elif total_gen < current_load:\n            lambda_low = lam\n        else:\n            lambda_high = lam\n    \n    # Residual adjustment\n    residual = current_load - np.sum(current_gen)\n    while abs(residual) > 0.1:\n        if residual > 0:  # Need more generation\n            idx = None\n            min_mc = np.inf\n            for j in range(len(comm_indices)):\n                if current_gen[j] < comm_max_bounds[j] - 0.1:\n                    mc = 2 * comm_c[j] * current_gen[j] + comm_b[j]\n                    if mc < min_mc:\n                        min_mc = mc\n                        idx = j\n            if idx is None:\n                break\n            delta = min(residual, comm_max_bounds[idx] - current_gen[idx])\n            current_gen[idx] += delta\n            residual -= delta\n            \n        else:  # Need less generation\n            idx = None\n            max_mc = -np.inf\n            for j in range(len(comm_indices)):\n                if current_gen[j] > comm_min_bounds[j] + 0.1:\n                    mc = 2 * comm_c[j] * current_gen[j] + comm_b[j]\n                    if mc > max_mc:\n                        max_mc = mc\n                        idx = j\n            if idx is None:\n                break\n            delta = min(-residual, current_gen[idx] - comm_min_bounds[idx])\n            current_gen[idx] -= delta\n            residual += delta\n    \n    # Set output for committed units\n    for idx, val in enumerate(comm_indices):\n        p_out[val] = max(comm_min_bounds[idx], min(comm_max_bounds[idx], current_gen[idx]))\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0055550302,
          "gap_price_rate": 0.0095828498,
          "fitness": 0.00756894
     }
]