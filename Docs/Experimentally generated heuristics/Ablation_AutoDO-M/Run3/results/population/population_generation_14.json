[
     {
          "name": "refined_amortized_with_forecast",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp), forced-off (violating min down-time), free online (adjustable online), free offline (adjustable offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization over min up-time if next load >= current load (indicating sustained need), else full amortization.\n3. Precompute cost metrics: operating cost at min power for free online; amortized startup cost plus operating cost for free offline.\n4. Build initial commitment set: forced-on units then free units in ascending cost order until ramp-constrained max capacity >= current load.\n5. Refine committed set: sort free units by cost descending and iteratively remove while maintaining max capacity >= load and reducing min capacity \u2264 load.\n6. For committed units, calculate bounds: previously online consider ramp limits; newly started consider startup ramp limits.\n7. Dispatch in three stages:\n   a) Boundary handling: set outputs to min or max if load out of bounds.\n   b) Bisection for lambda iteration with analytical derivative for quadratic units.\n   c) Discrete settings and residual adjustment for linear units.\n\n",
          "code": "import numpy as np\n\ndef refined_amortized_with_forecast(units_info, load):\n    L_current, L_next = load[0], load[1]\n    num_units = len(units_info)\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < t_up_min or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -t0 < t_down_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        t_min_up = unit['t_on_min_i']\n        if L_next >= L_current:\n            amortized_startup = s / (2 * t_min_up)\n        else:\n            amortized_startup = s / t_min_up\n        cost_metric[i] = (amortized_startup + a + b * p_min + c * p_min**2) / p_min\n\n    committed_set = set(forced_on)\n    free_sorted = sorted(free_online + free_offline, key=lambda i: cost_metric.get(i, float('inf')))\n    total_max = 0.0\n    for i in committed_set:\n        unit = units_info[i]\n        total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for i in free_sorted:\n        if total_max >= L_current:\n            break\n        unit = units_info[i]\n        max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if i in free_online else min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_cap\n        committed_set.add(i)\n    \n    total_min = 0.0\n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_cap\n        bounds[i] = (min_cap, max_cap)\n    \n    free_committed = [i for i in committed_set if i in free_online or i in free_offline]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric.get(i, 0), reverse=True)\n    for i in free_committed_sorted:\n        min_cap, max_cap = bounds[i]\n        new_total_min = total_min - min_cap\n        new_total_max = total_max - max_cap\n        if new_total_min <= L_current and new_total_max >= L_current:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (min_cap, max_cap)\n    \n    total_min = sum(bounds[i][0] for i in committed_set)\n    total_max = sum(bounds[i][1] for i in committed_set)\n    \n    quadratic_units = []\n    linear_units = []\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['c_i'] > 0:\n            quadratic_units.append(i)\n        else:\n            linear_units.append(i)\n    \n    if L_current <= total_min:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][0]\n    elif L_current >= total_max:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][1]\n    else:\n        p_vals = {}\n        residual = L_current\n        for i in linear_units:\n            unit = units_info[i]\n            _, max_cap = bounds[i]\n            if unit['b_i'] <= unit['a_i'] / max_cap + unit['b_i']:\n                p_vals[i] = max_cap\n            else:\n                p_vals[i] = bounds[i][0]\n            residual -= p_vals[i]\n        \n        if quadratic_units:\n            low, high = 0, 0\n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                low = min(low, unit['b_i'] + 2 * unit['c_i'] * min_cap)\n                high = max(high, unit['b_i'] + 2 * unit['c_i'] * max_cap)\n            \n            tol = 1e-3\n            max_iter = 100\n            for _ in range(max_iter):\n                mid = (low + high) / 2\n                total_power = residual\n                for i in quadratic_units:\n                    unit = units_info[i]\n                    min_cap, max_cap = bounds[i]\n                    p = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                    total_power += p\n                if abs(total_power) < tol:\n                    break\n                if total_power < 0:\n                    high = mid\n                else:\n                    low = mid\n            \n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                p_vals[i] = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                residual -= p_vals[i]\n        \n        if abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = bounds[i][1] - current_p\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) + adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n            else:\n                residual = abs(residual)\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = current_p - bounds[i][0]\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: -x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) - adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n        \n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = p_vals.get(i, bounds[i][0])\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0031320448,
          "gap_price_rate": 0.0067061217,
          "fitness": 0.0049190833
     },
     {
          "name": "adaptive_amortized_hybrid_dispatch",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp), forced-off (violating min down-time), free online (adjustable and online), free offline (adjustable and offline)\n2. Compute adaptive startup cost amortization: full amortization over min uptime if next load \u2265 current load, half amortization otherwise\n3. Precompute bounds: ramp-constrained for online units, startup-constrained for offline units\n4. Calculate incremental cost rates incorporating amortized startup costs\n5. Build commitment set: forced-on units first, then add free units by ascending cost rate until ramp-constrained max capacity >= load\n6. Refine commitment: remove expensive free units only if (a) min capacity \u2264 load \u2264 max capacity maintained and (b) forecasted load decreases\n7. Calculate dispatch bounds considering ramp and startup constraints\n8. Dispatch via Newton-bisection: use analytical derivatives for quadratic convergence with fallback to priority adjustment\n9. Apply greedy residual adjustment using marginal cost prioritization\n10. Set non-committed units to offline state\n\n",
          "code": "import numpy as np\n\ndef adaptive_amortized_hybrid_dispatch(units_info, load):\n    current_load, next_load = load\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    \n    # Step 1: Classify units\n    for unit in units_info:\n        u_i_0, t_i_0, p_i_0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > p_shut_i:\n                forced_on.append(unit)\n            else:\n                free_online.append(unit)\n        else:\n            if abs(t_i_0) < t_off_min:\n                forced_off.append(unit)\n            else:\n                free_offline.append(unit)\n    \n    # Step 2: Adaptive startup cost amortization\n    for unit in free_offline:\n        amort_factor = 1.0 if next_load >= current_load else 0.5\n        unit['amortized_startup'] = unit['s_i'] * amort_factor / unit['t_on_min_i']\n    \n    # Step 3: Precompute bounds and cost rates\n    for unit in forced_on + free_online:\n        p_i_0, p_min, p_max = unit['p_i_0'], unit['p_min_i'], unit['p_max_i']\n        p_down, p_up = unit['p_down_i'], unit['p_up_i']\n        unit['min_bound'] = max(p_min, p_i_0 - p_down)\n        unit['max_bound'] = min(p_max, p_i_0 + p_up)\n        min_cost = unit['a_i'] + unit['b_i'] * unit['min_bound'] + unit['c_i'] * unit['min_bound']**2\n        unit['cost_rate'] = min_cost / unit['min_bound'] if unit['min_bound'] > 0 else float('inf')\n    \n    for unit in free_offline:\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        unit['min_bound'] = p_min\n        unit['max_bound'] = min(p_max, unit['p_start_i'])\n        min_cost = unit['amortized_startup'] + unit['a_i'] + unit['b_i'] * unit['min_bound'] + unit['c_i'] * unit['min_bound']**2\n        unit['cost_rate'] = min_cost / unit['min_bound'] if unit['min_bound'] > 0 else float('inf')\n    \n    # Initialize commitment set\n    committed = forced_on.copy()\n    total_min = sum(unit['min_bound'] for unit in committed)\n    total_max = sum(unit['max_bound'] for unit in committed)\n    \n    # Steps 4-5: Build and refine commitment set\n    free_units = sorted(free_online + free_offline, key=lambda x: x['cost_rate'])\n    \n    for unit in free_units:\n        if total_max < current_load:\n            committed.append(unit)\n            total_min += unit['min_bound']\n            total_max += unit['max_bound']\n    \n    committed_free = [u for u in committed if u not in forced_on]\n    committed_free_sorted = sorted(committed_free, key=lambda x: x['cost_rate'], reverse=True)\n    \n    for unit in committed_free_sorted:\n        new_min = total_min - unit['min_bound']\n        new_max = total_max - unit['max_bound']\n        if new_min <= current_load <= new_max and next_load < current_load:\n            committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # Update dispatch bounds\n    for unit in committed:\n        if unit in forced_on or unit in free_online:\n            p_i_0 = unit['p_i_0']\n            unit['min_bound'] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            unit['max_bound'] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        else:\n            unit['min_bound'] = unit['p_min_i']\n            unit['max_bound'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 6: Initialize power outputs\n    total_min = sum(unit['min_bound'] for unit in committed)\n    total_max = sum(unit['max_bound'] for unit in committed)\n    \n    # Boundary cases\n    if current_load <= total_min:\n        for unit in committed:\n            unit['p_i'] = unit['min_bound']\n    elif current_load >= total_max:\n        for unit in committed:\n            unit['p_i'] = unit['max_bound']\n    else:\n        # Steps 7-8: Newton-bisection dispatch\n        lam_low, lam_high = -1000000, 1000000\n        tol = 0.001\n        \n        def get_total_power(lam):\n            total = 0.0\n            for u in committed:\n                if u['c_i'] > 0:\n                    p = (lam - u['b_i']) / (2 * u['c_i'])\n                    p_clamped = max(u['min_bound'], min(u['max_bound'], p))\n                    u['temp_p'] = p_clamped\n                    total += p_clamped\n                else:\n                    p_clamped = u['max_bound'] if u['b_i'] < lam else u['min_bound']\n                    u['temp_p'] = p_clamped\n                    total += p_clamped\n            return total\n        \n        # Newton-bisection iteration\n        lam_mid = (lam_low + lam_high) / 2\n        prev_diff = float('inf')\n        for _ in range(100):  # Enhanced convergence handling\n            P_mid = get_total_power(lam_mid)\n            diff = P_mid - current_load\n            if abs(diff) < tol:\n                break\n                \n            # Analytical derivative for Newton step\n            derivative = 0\n            for u in committed:\n                if u['c_i'] > 0:\n                    if u['min_bound'] < u['temp_p'] < u['max_bound']:\n                        derivative += 1 / (2 * u['c_i'])\n            \n            if derivative > 0:\n                newton_step = diff / derivative\n                lam_new = lam_mid - newton_step\n                P_new = get_total_power(lam_new)\n                if abs(P_new - current_load) < abs(diff):\n                    lam_mid = lam_new\n                    if abs(newton_step) > tol:  # Check significant progress\n                        continue\n            \n            # Fallback to bisection\n            if diff > 0:\n                lam_high = lam_mid\n            else:\n                lam_low = lam_mid\n            lam_mid = (lam_low + lam_high) / 2\n            if abs(prev_diff) <= abs(diff):  # Convergence safeguard\n                break\n            prev_diff = diff\n        \n        # Apply lambda solution\n        get_total_power(lam_mid)\n        for u in committed:\n            u['p_i'] = u['temp_p']\n        \n        # Step 9: Greedy residual adjustment\n        total_power = sum(u['p_i'] for u in committed)\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            if residual > 0:\n                adj_units = [u for u in committed if u['p_i'] < u['max_bound']]\n                adj_units.sort(key=lambda u: u['b_i'] + 2*u['c_i']*u['p_i'])\n            else:\n                adj_units = [u for u in committed if u['p_i'] > u['min_bound']]\n                adj_units.sort(key=lambda u: u['b_i'] + 2*u['c_i']*u['p_i'], reverse=True)\n            \n            for u in adj_units:\n                if abs(residual) < tol:\n                    break\n                margin = (u['max_bound'] - u['p_i']) if residual > 0 else (u['p_i'] - u['min_bound'])\n                adj = min(abs(residual), margin) * (1 if residual > 0 else -1)\n                u['p_i'] += adj\n                residual -= adj\n    \n    # Step 10: Set non-committed units\n    for unit in units_info:\n        if unit in committed:\n            unit['u_i'] = 1\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0031320448,
          "gap_price_rate": 0.0068940044,
          "fitness": 0.0050130246
     },
     {
          "name": "hybrid_amortized_adaptive_dispatch",
          "algorithm": "**  \n1. **Classify Units:** Categorize units into forced-on (must remain online due to min up-time/shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), free offline (adjustable and currently offline) using constraints.  \n2. **Amortize Startup Costs:** Adjust startup costs for free offline units: half amortization over min up-time if next load \u2265 current load, else full amortization.  \n3. **Precompute Bounds & Cost Rates:**  \n   - Compute ramp-constrained bounds for online units: `[max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]`  \n   - Compute startup-constrained bounds for offline units: `[p_min_i, min(p_max_i, p_start_i)]`  \n   - Calculate cost rates: `(a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i` (free online) or with amortized startup costs (free offline).  \n4. **Build Commitment Set:**  \n   - Start with forced-on units.  \n   - Add free units (sorted by cost rate ascending) until total max capacity \u2265 load.  \n5. **Refine Commitment Set:**  \n   - Remove expensive free units (sorted by cost rate descending) only if removal maintains `min_capacity \u2264 load \u2264 max_capacity`.  \n6. **Economic Dispatch:**  \n   - **Boundary Cases:** Set all outputs to min if `load \u2264 total_min`; set all outputs to max if `load \u2265 total_max`.  \n   - **Lambda Iteration:** Use Newton-accelerated bisection with clamping to solve quadratic cost functions, ensuring `\u2211p_i = load` within bounds.  \n   - **Residual Adjustment:** Greedily adjust residual load prioritizing units with highest sensitivity.  \n7. **Output:** Set non-committed units to `u_i=0, p_i=0`; return `schedules` as a 2D array.  \n\n**",
          "code": "import numpy as np\n\ndef hybrid_amortized_adaptive_dispatch(units_info, load):\n    num_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Initialize arrays for commitment and dispatch\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n    \n    # Precompute bounds and cost rates for all units\n    bounds_min = [0.0] * num_units\n    bounds_max = [0.0] * num_units\n    cost_rates = [float('inf')] * num_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds_min[i] = lb\n        bounds_max[i] = ub\n    \n    # Classify units and compute cost rates\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Compute cost rates for free units\n    for i in free_online:\n        unit = units_info[i]\n        cost_val = unit['a_i'] + unit['b_i'] * bounds_min[i] + unit['c_i'] * (bounds_min[i] ** 2)\n        cost_rates[i] = cost_val / bounds_min[i]\n    \n    for i in free_offline:\n        unit = units_info[i]\n        amort_factor = 2.0 * unit['t_on_min_i'] if next_load >= current_load else unit['t_on_min_i']\n        amort_startup = unit['s_i'] / amort_factor\n        cost_val = unit['a_i'] + unit['b_i'] * bounds_min[i] + unit['c_i'] * (bounds_min[i] ** 2) + amort_startup\n        cost_rates[i] = cost_val / bounds_min[i]\n    \n    # Build initial commitment set\n    candidate_set = forced_on.copy()\n    total_min = sum(bounds_min[i] for i in forced_on)\n    total_max = sum(bounds_max[i] for i in forced_on)\n    committed_free = []\n    \n    free_all = free_online + free_offline\n    free_all_sorted = sorted(free_all, key=lambda i: cost_rates[i])\n    \n    for i in free_all_sorted:\n        if total_max < current_load:\n            candidate_set.append(i)\n            committed_free.append(i)\n            total_min += bounds_min[i]\n            total_max += bounds_max[i]\n        else:\n            break\n    \n    # Refine commitment set (remove expensive units if possible)\n    committed_free_sorted = sorted(committed_free, key=lambda i: cost_rates[i], reverse=True)\n    for i in committed_free_sorted:\n        new_min = total_min - bounds_min[i]\n        new_max = total_max - bounds_max[i]\n        if new_max >= current_load and new_min <= current_load:\n            candidate_set.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Set u_i=1 for committed units\n    for i in candidate_set:\n        u_out[i] = 1\n    \n    # Economic dispatch\n    if current_load <= total_min:\n        for i in candidate_set:\n            p_out[i] = bounds_min[i]\n    elif current_load >= total_max:\n        for i in candidate_set:\n            p_out[i] = bounds_max[i]\n    else:\n        # Lambda iteration for dispatch\n        low_indices = []\n        high_indices = []\n        mid_indices = candidate_set.copy()\n        p_vals = {i: bounds_min[i] for i in candidate_set}\n        \n        max_iter = 100\n        tolerance = 1e-6\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            # Reset sets each iteration\n            low_indices = []\n            high_indices = []\n            new_mid = []\n            \n            # Compute total power and categorize units\n            total_power = 0.0\n            for i in mid_indices:\n                total_power += p_vals[i]\n            \n            residual = current_load - total_power\n            if abs(residual) < tolerance:\n                break\n            \n            # Compute lambda\n            denom = 0.0\n            numer = 0.0\n            for i in mid_indices:\n                c_i = units_info[i]['c_i']\n                if c_i > tolerance:\n                    denom += 1.0 / (2.0 * c_i)\n                    numer += units_info[i]['b_i'] / (2.0 * c_i)\n            if denom > tolerance:\n                lambda_val = (residual + numer) / denom\n            else:\n                lambda_val = numer / denom if abs(numer) > tolerance else 0.0\n            \n            # Update mid_indices with new lambda\n            for i in mid_indices:\n                unit = units_info[i]\n                c_i = unit['c_i']\n                b_i = unit['b_i']\n                if c_i < tolerance:  # Linear cost\n                    # Placeholder: use bound if linear cost (shouldn't happen for quadratic)\n                    continue\n                p_uncon = (lambda_val - b_i) / (2.0 * c_i)\n                if p_uncon < bounds_min[i]:\n                    p_vals[i] = bounds_min[i]\n                    low_indices.append(i)\n                elif p_uncon > bounds_max[i]:\n                    p_vals[i] = bounds_max[i]\n                    high_indices.append(i)\n                else:\n                    p_vals[i] = p_uncon\n                    new_mid.append(i)\n            mid_indices = new_mid\n            iter_count += 1\n        \n        # Residual adjustment if needed\n        total_power = sum(p_vals.get(i, 0.0) for i in candidate_set)\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            marginal_costs = {}\n            for i in candidate_set:\n                if u_out[i] == 1 and bounds_min[i] <= p_vals[i] <= bounds_max[i]:\n                    marginal_costs[i] = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_vals[i]\n            if residual > 0:  # Increase generation\n                candidates = [i for i in candidate_set if p_vals[i] < bounds_max[i] - tolerance]\n                if candidates:\n                    sorted_candidates = sorted(candidates, key=lambda i: marginal_costs.get(i, float('inf')))\n                    for i in sorted_candidates:\n                        room = bounds_max[i] - p_vals[i]\n                        if room > tolerance:\n                            delta = min(room, residual)\n                            p_vals[i] += delta\n                            residual -= delta\n                        if residual < tolerance:\n                            break\n            else:  # Decrease generation\n                residual_abs = abs(residual)\n                candidates = [i for i in candidate_set if p_vals[i] > bounds_min[i] + tolerance]\n                if candidates:\n                    sorted_candidates = sorted(candidates, key=lambda i: marginal_costs.get(i, -float('inf')), reverse=True)\n                    for i in sorted_candidates:\n                        room = p_vals[i] - bounds_min[i]\n                        if room > tolerance:\n                            delta = min(room, residual_abs)\n                            p_vals[i] -= delta\n                            residual_abs -= delta\n                        if residual_abs < tolerance:\n                            break\n        \n        for i in candidate_set:\n            p_out[i] = p_vals[i]\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0044279251,
          "gap_price_rate": 0.0070158192,
          "fitness": 0.0057218721
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to minimum up-time or shutdown ramp constraints), forced-off (must remain offline due to minimum down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Precompute cost metrics for free units:\n   - Free online: cost rate = (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: cost rate = (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate commitment set starting with forced-on units, then add free units sorted by ascending cost rate until total ramp-constrained max capacity \u2265 current load. Precompute ramp-constrained min/max for each unit during classification.\n4. Refine commitment by removing expensive free units:\n   - Sort committed free units by cost rate descending\n   - Iteratively remove the most expensive unit if removal maintains max capacity \u2265 load and reduces min capacity below or equal to load\n5. Calculate dispatch bounds for committed units considering startup/shutdown ramps and online ramp constraints:\n   - Previously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Newly started units: [p_min_i, min(p_max_i, p_start_i)]\n6. Perform economic dispatch using optimized lambda iteration:\n   - Handle boundary cases where load \u2264 total min or \u2265 total max\n   - Use bisection with analytical derivative for faster convergence\n   - Distribute residual with priority-based greedy adjustment to ensure exact load matching\n7. Set non-committed units to offline state (u_i=0, p_i=0).\n8. Return commitment states and power outputs as a 2D NumPy array.\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = [0] * n_units\n    p_schedule = [0] * n_units\n    \n    # Data structures to store processed unit information\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    processed_units = [None] * n_units\n    \n    # Classify units and precompute parameters\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        forced_on_flag = False\n        forced_off_flag = False\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on_flag = True\n                forced_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:  # Currently offline\n            if -t0 < unit['t_off_min_i']:\n                forced_off_flag = True\n                forced_off.append(idx)\n            else:\n                free_offline.append(idx)\n                \n        # Precompute ramp-constrained boundaries\n        if u0 == 1:  # Online units\n            min_p = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline units\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate amortized cost rate for free units\n        if not (forced_on_flag or forced_off_flag):\n            operating_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if u0 == 1:  # Free online\n                cost_rate = operating_cost_min / unit['p_min_i']\n            else:  # Free offline\n                startup_amortized = unit['s_i'] / unit['t_on_min_i']\n                cost_rate = (operating_cost_min + startup_amortized) / unit['p_min_i']\n        else:\n            cost_rate = float('inf') if forced_off_flag else -float('inf')\n        \n        processed_units[idx] = {\n            'idx': idx,\n            'u0': u0,\n            'forced_on': forced_on_flag,\n            'forced_off': forced_off_flag,\n            'min_bound': min_p,\n            'max_bound': max_p,\n            'cost_rate': cost_rate,\n            'b': unit['b_i'],\n            'c': unit['c_i']\n        }\n    \n    # Initialize commitment set with forced-on units\n    committed_set = set(forced_on)\n    total_min = sum(processed_units[idx]['min_bound'] for idx in forced_on)\n    total_max = sum(processed_units[idx]['max_bound'] for idx in forced_on)\n    \n    # Candidate free units sorted by cost rate (ascending)\n    free_candidates = free_online + free_offline\n    free_candidates.sort(key=lambda idx: processed_units[idx]['cost_rate'])\n    \n    # Add free units until capacity meets or exceeds load\n    for idx in free_candidates:\n        if total_max < current_load:\n            committed_set.add(idx)\n            total_min += processed_units[idx]['min_bound']\n            total_max += processed_units[idx]['max_bound']\n        else:\n            break\n    \n    # Remove expensive free units if min capacity exceeds load\n    free_in_commit = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_in_commit.sort(key=lambda idx: processed_units[idx]['cost_rate'], reverse=True)\n    removed = True\n    while removed and total_min > current_load:\n        removed = False\n        for idx in free_in_commit:\n            unit = processed_units[idx]\n            new_min = total_min - unit['min_bound']\n            new_max = total_max - unit['max_bound']\n            if new_max >= current_load:\n                committed_set.remove(idx)\n                total_min = new_min\n                total_max = new_max\n                free_in_commit.remove(idx)\n                removed = True\n                break\n    \n    # Prepare dispatch units with valid bounds\n    dispatch_units = []\n    for idx in committed_set:\n        unit = processed_units[idx]\n        min_bound = unit['min_bound']\n        max_bound = unit['max_bound']\n        \n        # Ensure bounds are valid\n        if min_bound > max_bound:\n            min_bound = max_bound = (min_bound + max_bound) / 2\n            \n        dispatch_units.append({\n            'min': min_bound,\n            'max': max_bound,\n            'b': unit['b'],\n            'c': unit['c'],\n            'idx': idx\n        })\n    \n    # Calculate total dispatch bounds\n    total_min_dispatch = sum(unit['min'] for unit in dispatch_units)\n    total_max_dispatch = sum(unit['max'] for unit in dispatch_units)\n    \n    # Handle boundary cases\n    if current_load <= total_min_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['min']\n    elif current_load >= total_max_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['max']\n    else:\n        # Lambda iteration (bisection) with derivative for speed\n        low_lambda = 0\n        high_lambda = 1e6\n        tolerance = 1e-5\n        iterations = 0\n        \n        while iterations < 100 and (high_lambda - low_lambda) > tolerance:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            derivative_sum = 0\n            \n            for unit in dispatch_units:\n                c = unit['c']\n                if c == 0:  # Linear cost function\n                    p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n                else:\n                    p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                    p = max(unit['min'], min(unit['max'], p_unclamped))\n                \n                unit['p_temp'] = p\n                total_power += p\n                \n                if unit['min'] < p < unit['max']:\n                    derivative_sum += 1 / (2 * c)\n            \n            if derivative_sum == 0:  # All units at bounds\n                if total_power < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            else:\n                lambda_derivative = derivative_sum\n                error = total_power - current_load\n                mid_lambda -= error / lambda_derivative\n                \n                if total_power > current_load:\n                    high_lambda = mid_lambda\n                else:\n                    low_lambda = mid_lambda\n            \n            iterations += 1\n        \n        # Final power calculation\n        total_power = 0\n        for unit in dispatch_units:\n            c = unit['c']\n            if c == 0:\n                p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n            else:\n                p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                p = max(unit['min'], min(unit['max'], p_unclamped))\n            unit['p_temp'] = p\n            total_power += p\n        \n        # Adjust for residual with greedy method\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            if residual > 0:\n                candidates = [u for u in dispatch_units if u['p_temp'] < u['max']]\n                candidates.sort(key=lambda u: u['b'] + 2 * u['c'] * u['p_temp'])\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['max'] - unit['p_temp']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] += adjust\n                    residual -= adjust\n            else:\n                residual = abs(residual)\n                candidates = [u for u in dispatch_units if u['p_temp'] > u['min']]\n                candidates.sort(key=lambda u: -(u['b'] + 2 * u['c'] * u['p_temp']))\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['p_temp'] - unit['min']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] -= adjust\n                    residual -= adjust\n        \n        # Assign final dispatch values\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['p_temp']\n    \n    # Set commitment states\n    for idx in committed_set:\n        u_schedule[idx] = 1\n    \n    return np.array([u_schedule, p_schedule])",
          "from": "mutation",
          "gap_power_rate": 0.0033675075,
          "gap_price_rate": 0.0081376386,
          "fitness": 0.0057525731
     },
     {
          "name": "hybrid_amortized_bisection_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown ramp constraints), forced-off (must remain offline due to min down-time), free online (adjustable and online), and free offline (adjustable and offline).\n2. Adjust startup cost amortization for free offline units: use half amortization over min up-time if next load \u2265 current load, else full amortization.\n3. Precompute cost metrics: cost per MW at min power with amortized startup for free offline units and operating cost only for free online units.\n4. Build initial commitment: forced-on units first, add free units by ascending cost until ramp/startup-constrained max capacity \u2265 current load.\n5. Refine commitment: remove expensive free units (descending cost order) if removal maintains max capacity \u2265 load and min capacity \u2264 load.\n6. Calculate dispatch bounds considering startup/ramp limits for newly started units and ramp constraints for existing online units.\n7. Dispatch:\n   a) Handle boundary cases (total min/max)\n   b) Hybrid dispatch: Newton-accelerated bisection for quadratic cost units with linear units clamped to bounds\n   c) Priority-based greedy adjustment using marginal costs for residual load\n8. Set non-committed units to offline state (u_i=0, p_i=0).\n9. Return schedules as 2D NumPy array.\n\n",
          "code": "import numpy as np\n\ndef hybrid_amortized_bisection_dispatch(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    num_units = len(units_info)\n    \n    # Initialize variables\n    u_i = np.zeros(num_units)\n    p_i = np.zeros(num_units)\n    lb = np.zeros(num_units)  # Lower bounds for dispatch\n    ub = np.zeros(num_units)  # Upper bounds for dispatch\n    committed = np.zeros(num_units, dtype=bool)  # Commitment status\n    \n    # Step 1: Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Previously offline\n            if abs(t_i0) < t_off_min_i:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Forced-on units are committed\n    for i in forced_on:\n        committed[i] = True\n    \n    # Step 2: Amortize startup costs for free offline units\n    amortized_costs = np.zeros(num_units)\n    for i in free_offline:\n        unit = units_info[i]\n        if forecast_load >= current_load:\n            amortized_costs[i] = unit['s_i'] / (2 * unit['t_on_min_i'])\n        else:\n            amortized_costs[i] = unit['s_i'] / unit['t_on_min_i']\n    \n    # Step 3: Precompute cost metrics\n    cost_metrics = np.zeros(num_units)\n    for i in free_online:\n        unit = units_info[i]\n        min_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i'] ** 2)\n        cost_metrics[i] = min_cost / unit['p_min_i']\n    \n    for i in free_offline:\n        unit = units_info[i]\n        min_cost = (amortized_costs[i] + unit['a_i'] + \n                    unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i'] ** 2)\n        cost_metrics[i] = min_cost / unit['p_min_i']\n    \n    # Helper functions to get bounds\n    def get_max_capacity(i, starting=False):\n        unit = units_info[i]\n        if starting:\n            return min(unit['p_max_i'], unit['p_start_i'])\n        elif unit['u_i_0'] == 1:\n            return min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return unit['p_max_i']\n    \n    def get_min_capacity(i, starting=False):\n        unit = units_info[i]\n        if starting:\n            return unit['p_min_i']\n        elif unit['u_i_0'] == 1:\n            return max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        return unit['p_min_i']\n    \n    # Step 4: Build initial commitment\n    candidate_units = free_online + free_offline\n    candidate_units.sort(key=lambda i: cost_metrics[i])\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    # Add forced-on capacities\n    for i in forced_on:\n        is_new = (units_info[i]['u_i_0'] == 0)\n        total_min += get_min_capacity(i, is_new)\n        total_max += get_max_capacity(i, is_new)\n    \n    # Add free units until max capacity covers load\n    for i in candidate_units:\n        if total_max >= current_load:\n            break\n        is_new = (units_info[i]['u_i_0'] == 0)\n        committed[i] = True\n        total_min += get_min_capacity(i, is_new)\n        total_max += get_max_capacity(i, is_new)\n    \n    # Step 5: Refine commitment\n    free_committed = [i for i in candidate_units if committed[i]]\n    free_committed.sort(key=lambda i: cost_metrics[i], reverse=True)\n    \n    for i in free_committed:\n        is_new = (units_info[i]['u_i_0'] == 0)\n        new_min = total_min - get_min_capacity(i, is_new)\n        new_max = total_max - get_max_capacity(i, is_new)\n        if new_max >= current_load and new_min <= current_load:\n            committed[i] = False\n            total_min = new_min\n            total_max = new_max\n    \n    # Step 6: Calculate dispatch bounds\n    for i in range(num_units):\n        if committed[i]:\n            is_new = (units_info[i]['u_i_0'] == 0)\n            lb[i] = get_min_capacity(i, is_new)\n            ub[i] = get_max_capacity(i, is_new)\n    \n    # Step 7: Dispatch\n    committed_indices = [i for i in range(num_units) if committed[i]]\n    committed_units = [units_info[i] for i in committed_indices]\n    dispatch_lb = [lb[i] for i in committed_indices]\n    dispatch_ub = [ub[i] for i in committed_indices]\n    \n    # a) Boundary handling\n    if current_load <= total_min:\n        for i in committed_indices:\n            p_i[i] = lb[i]\n    elif current_load >= total_max:\n        for i in committed_indices:\n            p_i[i] = ub[i]\n    else:\n        # Initialize outputs to lower bounds\n        for i in committed_indices:\n            p_i[i] = lb[i]\n        \n        # b) Hybrid dispatch\n        # Split into quadratic and linear units\n        quadratic_indices = [i for i in committed_indices if units_info[i]['c_i'] > 0]\n        linear_indices = [i for i in committed_indices if units_info[i]['c_i'] == 0]\n        \n        # Process quadratic units with Newton-accelerated bisection\n        if quadratic_indices:\n            # Lambda bounds\n            low_lambda = 0\n            high_lambda = 0\n            for i in quadratic_indices:\n                unit = units_info[i]\n                low_lambda = min(low_lambda, unit['b_i'] + 2 * unit['c_i'] * lb[i])\n                high_lambda = max(high_lambda, unit['b_i'] + 2 * unit['c_i'] * ub[i])\n            \n            newton_tol = 1e-6\n            bisect_tol = 1e-3\n            max_iter = 100\n            current_lambda = (low_lambda + high_lambda) / 2\n            \n            for _ in range(max_iter):\n                power_sum = 0\n                derivative_sum = 0\n                \n                for i in quadratic_indices:\n                    unit = units_info[i]\n                    denom = 2 * unit['c_i']\n                    p_uncon = (current_lambda - unit['b_i']) / denom\n                    p_clamped = min(ub[i], max(lb[i], p_uncon))\n                    power_sum += p_clamped\n                    \n                    # Derivative part for Newton\n                    if lb[i] < p_uncon < ub[i]:\n                        derivative_sum += 1 / denom\n                \n                # Newton step with bisection\n                f_val = power_sum - (current_load - sum(p_i[j] for j in linear_indices))\n                if abs(f_val) < newton_tol:\n                    break\n                \n                if derivative_sum != 0:\n                    newton_step = f_val / derivative_sum\n                    next_lambda = current_lambda - newton_step\n                    \n                    # Ensure next_lambda stays within bounds\n                    if low_lambda <= next_lambda <= high_lambda:\n                        current_lambda = next_lambda\n                    else:\n                        # Fallback to bisection\n                        if f_val > 0:\n                            high_lambda = current_lambda\n                        else:\n                            low_lambda = current_lambda\n                        current_lambda = (low_lambda + high_lambda) / 2\n                else:\n                    # Pure bisection\n                    if f_val > 0:\n                        high_lambda = current_lambda\n                    else:\n                        low_lambda = current_lambda\n                    current_lambda = (low_lambda + high_lambda) / 2\n                \n                if (high_lambda - low_lambda) < bisect_tol:\n                    break\n            \n            # Set quadratic unit outputs\n            for i in quadratic_indices:\n                unit = units_info[i]\n                denom = 2 * unit['c_i']\n                p_uncon = (current_lambda - unit['b_i']) / denom\n                p_i[i] = min(ub[i], max(lb[i], p_uncon))\n        \n        # Process linear units (clamped to bounds)\n        for i in linear_indices:\n            unit = units_info[i]\n            # Clamped to bounds (lambda comparison not needed)\n            p_i[i] = lb[i]  # Default to lower bound\n        \n        # c) Residual adjustment\n        current_sum = sum(p_i)\n        residual = current_load - current_sum\n        \n        if abs(residual) > 1e-3:\n            # Prioritize by marginal cost\n            marginal_costs = []\n            for i in committed_indices:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    mc = unit['b_i'] + 2 * unit['c_i'] * p_i[i]\n                else:\n                    mc = unit['b_i']  # Linear unit\n                marginal_costs.append((i, mc))\n            \n            # Sort by marginal cost\n            marginal_costs.sort(key=lambda x: x[1])\n            \n            # Adjust upward\n            if residual > 0:\n                for i, mc in marginal_costs:\n                    available = ub[i] - p_i[i]\n                    if available > 1e-3:\n                        adjust = min(residual, available)\n                        p_i[i] += adjust\n                        residual -= adjust\n                    if residual <= 1e-3:\n                        break\n            # Adjust downward\n            else:\n                for i, mc in reversed(marginal_costs):\n                    available = p_i[i] - lb[i]\n                    if available > 1e-3:\n                        adjust = min(-residual, available)\n                        p_i[i] -= adjust\n                        residual += adjust\n                    if -residual <= 1e-3:\n                        break\n    \n    # Step 8: Set non-committed units\n    for i in range(num_units):\n        if not committed[i]:\n            u_i[i] = 0\n            p_i[i] = 0\n        else:\n            u_i[i] = 1\n    \n    # Step 9: Return schedules\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0044206551,
          "gap_price_rate": 0.0082039283,
          "fitness": 0.0063122917
     },
     {
          "name": "hybrid_amortized_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable online), and free offline (adjustable offline).\n2. Adjust startup cost amortization for free offline units based on forecasted load: half amortization over min up-time if next load \u2265 current load (sustained need), else full amortization.\n3. Precompute cost metrics per MW at min power: free online (operating cost only), free offline (amortized startup + operating cost).\n4. Build initial commitment set: start with forced-on units, add free units by ascending cost until total ramp/startup-constrained max capacity meets current load.\n5. Refine commitment set: remove most expensive free units (descending cost) if total max capacity still meets load AND total min capacity becomes \u2264 load.\n6. Calculate feasible dispatch bounds for committed units: previously online units respect ramp limits; newly started units respect startup ramp limits.\n7. Dispatch via three-stage method: \n   a) Boundary handling - set outputs to min/max if load outside bounds\n   b) Lambda iteration with bisection using analytical derivatives for quadratic costs\n   c) Marginal cost-based greedy adjustment to eliminate residual mismatch\n8. Set non-committed units to offline state (u_i=0, p_i=0).\n9. Return schedule as 2D array with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_amortized_priority_dispatch(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    # Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Precompute cost metrics with forecast-based amortization\n    cost_rates = np.ones(n_units) * np.inf\n    for i in free_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_rates[i] = cost / p_min\n    \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        amortization = unit['t_on_min_i']\n        if next_load >= current_load:\n            amortization *= 2  # Half amortization\n        startup_cost = unit['s_i'] / amortization\n        cost = startup_cost + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_rates[i] = cost / p_min\n    \n    # Form initial commitment set\n    committed = set(forced_on)\n    total_max = 0.0\n    for i in committed:\n        unit = units_info[i]\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max += ub\n    \n    free_units = sorted(free_online + free_offline, key=lambda i: cost_rates[i])\n    for i in free_units:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if i in free_online:\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += ub\n        committed.add(i)\n    \n    # Refine commitment set\n    committed_free = [i for i in committed if i in free_online or i in free_offline]\n    committed_free_sorted = sorted(committed_free, key=lambda i: cost_rates[i], reverse=True)\n    lb_dict = {}\n    ub_dict = {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(lb_dict[i] for i in committed)\n    total_max = sum(ub_dict[i] for i in committed)\n    for i in committed_free_sorted:\n        new_total_min = total_min - lb_dict[i]\n        new_total_max = total_max - ub_dict[i]\n        if new_total_max >= current_load and new_total_min <= current_load:\n            committed.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    # Calculate dispatch bounds\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lb_dict[i] = lb\n        ub_dict[i] = ub\n    \n    # Economic dispatch\n    p_alloc = {}\n    if total_min >= current_load:\n        for i in committed:\n            p_alloc[i] = lb_dict[i]\n    elif total_max <= current_load:\n        for i in committed:\n            p_alloc[i] = ub_dict[i]\n    else:\n        # Lambda iteration with bisection\n        lambda_low = min(unit['b_i'] + 2 * unit['c_i'] * lb_dict[i] for i in committed)\n        lambda_high = max(unit['b_i'] + 2 * unit['c_i'] * ub_dict[i] for i in committed)\n        tol = 1e-5\n        n_iter = 100\n        for _ in range(n_iter):\n            lam = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i in committed:\n                unit = units_info[i]\n                p_star = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_star, lb_dict[i], ub_dict[i])\n                p_alloc[i] = p_i\n                total_p += p_i\n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                lambda_low = lam\n            else:\n                lambda_high = lam\n        \n        # Greedy residual adjustment\n        residual = current_load - total_p\n        while abs(residual) > tol:\n            if residual > 0:\n                candidates = [i for i in committed if p_alloc[i] < ub_dict[i] - tol]\n                if not candidates:\n                    break\n                i_min = min(candidates, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                max_inc = min(residual, ub_dict[i_min] - p_alloc[i_min])\n                p_alloc[i_min] += max_inc\n                residual -= max_inc\n            else:\n                candidates = [i for i in committed if p_alloc[i] > lb_dict[i] + tol]\n                if not candidates:\n                    break\n                i_max = max(candidates, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                max_dec = min(-residual, p_alloc[i_max] - lb_dict[i_max])\n                p_alloc[i_max] -= max_dec\n                residual += max_dec\n    \n    # Prepare output\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    for i in range(n_units):\n        if i in committed:\n            u_out[i] = 1\n            p_out[i] = p_alloc.get(i, 0.0)\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0032375616,
          "gap_price_rate": 0.0094420278,
          "fitness": 0.0063397947
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Classify units into forced-on (must run due to min uptime/shutdown ramp constraints), forced-off (min downtime unmet), free online (adjustable/online), free offline (adjustable/offline)  \n2. Compute refined startup cost amortization for free offline units:  \n   - If forecasted load \u2265 current load: amortize over min uptime  \n   - Else: amortize over a shorter period (min(ceil(min uptime/2), 1)) to adapt to declining load  \n3. Precompute cost-per-MW at midpoint of feasible range considering:  \n   - Free online: operating cost only at midpoint of ramp-constrained range  \n   - Free offline: amortized startup cost + operating cost at midpoint of startup-constrained range  \n4. Build committed set:  \n   - Start with forced-on units  \n   - Add free units (online first, then offline) sorted by cost-per-MW until max capacity covers current load  \n5. Refine commitment:  \n   - Remove expensive free units (descending cost) only if:  \n     - Total min capacity > current load  \n     - Forecasted load decreases  \n     - Removal maintains sufficient max capacity  \n6. For committed units, compute power bounds considering:  \n   - Previously online: ramp limits  \n   - Newly started: startup ramp limits  \n7. Dispatch load in 3 phases:  \n   a) Set all to min/max if load outside total bounds  \n   b) Use Newton-accelerated bisection for fast lambda convergence  \n   c) Cost-prioritized greedy adjustment to exactly match load while respecting unit constraints  \n8. Set non-committed units to off  \n\n",
          "code": "import numpy as np\nimport math\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Deep copy to avoid mutation\n    units = [dict(unit) for unit in units_info]\n    n_units = len(units)\n    \n    # Initialize schedule\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units, dtype=float)\n    \n    # Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Currently offline\n            if t0 < 0 and abs(t0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Precompute cost metrics and bounds\n    costs = []\n    min_outputs = []\n    max_outputs = []\n    types = []\n    indices = []\n    \n    # Helper to calculate operating cost\n    def operating_cost(unit, p):\n        return unit['a_i'] + unit['b_i'] * p + unit['c_i'] * p**2\n    \n    # Process free online units\n    for i in free_online:\n        unit = units[i]\n        p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p_mid = (p_low + p_high) / 2.0\n        cost_per_mw = operating_cost(unit, p_mid) / p_mid\n        costs.append(cost_per_mw)\n        min_outputs.append(p_low)\n        max_outputs.append(p_high)\n        types.append('online')\n        indices.append(i)\n    \n    # Process free offline units with refined amortization\n    for i in free_offline:\n        unit = units[i]\n        # Calculate amortization factor\n        if next_load >= current_load:\n            amort_factor = unit['t_on_min_i']\n        else:\n            amort_factor = min(max(1, math.ceil(unit['t_on_min_i'] / 2)), unit['t_on_min_i'])\n        \n        startup_amortized = unit['s_i'] / amort_factor\n        p_low = unit['p_min_i']\n        p_high = min(unit['p_max_i'], unit['p_start_i'])\n        p_mid = (p_low + p_high) / 2.0\n        total_cost = startup_amortized + operating_cost(unit, p_mid)\n        cost_per_mw = total_cost / p_mid\n        costs.append(cost_per_mw)\n        min_outputs.append(p_low)\n        max_outputs.append(p_high)\n        types.append('offline')\n        indices.append(i)\n    \n    # Combine and sort free units by cost (online first when tied)\n    sorted_free = sorted(zip(costs, min_outputs, max_outputs, types, indices), \n                         key=lambda x: (x[0], 0 if x[3]=='online' else 1))\n    \n    # Build commitment set\n    committed_set = set(forced_on)\n    total_min = 0.0\n    total_max = 0.0\n    unit_min_max = {}\n    \n    # Add forced-on units\n    for i in forced_on:\n        unit = units[i]\n        p_min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += p_min_val\n        total_max += p_max_val\n        unit_min_max[i] = (p_min_val, p_max_val)\n    \n    # Add free units until coverage\n    for cost, p_min_val, p_max_val, typ, i in sorted_free:\n        if total_max >= current_load:\n            break\n        committed_set.add(i)\n        total_min += p_min_val\n        total_max += p_max_val\n        unit_min_max[i] = (p_min_val, p_max_val)\n    \n    # Refinement: remove expensive units if forecasted load decreases\n    if next_load < current_load and total_min > current_load:\n        # Sort by cost descending\n        committed_free = [i for i in committed_set if i in indices]\n        sorted_refine = sorted(committed_free, \n                              key=lambda i: (costs[indices.index(i)], 1 if types[indices.index(i)]=='online' else 0), \n                              reverse=True)\n        \n        for i in sorted_refine:\n            p_min_val, p_max_val = unit_min_max[i]\n            if total_min - p_min_val <= current_load and total_max - p_max_val >= current_load:\n                committed_set.remove(i)\n                total_min -= p_min_val\n                total_max -= p_max_val\n            if total_min <= current_load:\n                break\n    \n    # Recompute bounds for committed units\n    bounds = {}\n    for i in committed_set:\n        unit = units[i]\n        if unit['u_i_0'] == 1:  # Previously online\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Newly started\n            p_low = unit['p_min_i']\n            p_high = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (p_low, p_high)\n    \n    # Dispatch\n    dispatch_units = [i for i in committed_set]\n    n_committed = len(dispatch_units)\n    if n_committed == 0:\n        return np.array([u_arr, p_arr])\n    \n    # Get total min/max\n    total_min = sum(bounds[i][0] for i in dispatch_units)\n    total_max = sum(bounds[i][1] for i in dispatch_units)\n    \n    # Phase 1: Boundary cases\n    if current_load <= total_min:\n        for i in dispatch_units:\n            u_arr[i] = 1\n            p_arr[i] = bounds[i][0]\n        return np.array([u_arr, p_arr])\n    elif current_load >= total_max:\n        for i in dispatch_units:\n            u_arr[i] = 1\n            p_arr[i] = bounds[i][1]\n        return np.array([u_arr, p_arr])\n    \n    # Phase 2: Lambda iteration with Newton-accelerated bisection\n    # Initialize Lambdas and outputs\n    lambd_low = min(unit['b_i'] for unit in units)  # Theoretical min\n    lambd_high = max(unit['b_i'] + 2*unit['c_i']*bounds[i][1] for i, unit in enumerate(units) if i in dispatch_units)\n    lambd = (lambd_low + lambd_high) / 2.0\n    converged = False\n    iterations = 0\n    max_iter = 100\n    tol = 1e-4\n    \n    # Temporary storage for dispatch calculations\n    p_temp = {i: bounds[i][0] for i in dispatch_units}  # Start at lower bounds\n    \n    while not converged and iterations < max_iter:\n        total_power = 0.0\n        # Calculate outputs and derivatives\n        for i in dispatch_units:\n            unit = units[i]\n            p_low, p_high = bounds[i]\n            # Unconstrained output for quadratic cost\n            if unit['c_i'] > 0:\n                p_uncon = (lambd - unit['b_i']) / (2 * unit['c_i'])\n                p_clamped = min(p_high, max(p_low, p_uncon))\n            else:  # Linear cost\n                if lambd >= unit['b_i']:\n                    p_clamped = p_high\n                else:\n                    p_clamped = p_low\n            p_temp[i] = p_clamped\n            total_power += p_clamped\n        \n        # Check convergence\n        mismatch = total_power - current_load\n        if abs(mismatch) < tol:\n            converged = True\n            p_arr = [p_temp.get(i, 0.0) for i in range(n_units)]\n            break\n        \n        # Derivative of total_power w.r.t lambda\n        derivative = 0.0\n        for i in dispatch_units:\n            unit = units[i]\n            if unit['c_i'] > 0 and bounds[i][0] < p_temp[i] < bounds[i][1]:\n                derivative += 1.0 / (2 * unit['c_i'])\n        \n        # Newton step with bisection safeguard\n        if abs(derivative) > 1e-10:\n            newton_step = -mismatch / derivative\n            lambd_new = lambd + newton_step\n            # Apply bisection if Newton step goes out of bounds\n            if lambd_new < lambd_low or lambd_new > lambd_high:\n                if mismatch > 0:\n                    lambd_high = lambd\n                else:\n                    lambd_low = lambd\n                lambd = (lambd_low + lambd_high) / 2.0\n            else:\n                lambd = lambd_new\n        else:\n            # Pure bisection if no derivatives found\n            if mismatch > 0:\n                lambd_high = lambd\n            else:\n                lambd_low = lambd\n            lambd = (lambd_low + lambd_high) / 2.0\n        \n        iterations += 1\n    \n    # Assign lambda iteration results\n    for i in dispatch_units:\n        u_arr[i] = 1\n        p_arr[i] = p_temp[i]\n    \n    # Phase 3: Greedy adjustment for exact match\n    total_power = sum(p_arr)\n    residual = current_load - total_power\n    \n    # Create list of dispatchable units for adjustment\n    adj_units = []\n    for i in dispatch_units:\n        unit = units[i]\n        p_low, p_high = bounds[i]\n        # Incremental cost = b + 2c*p\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_arr[i]\n        # Capacity available\n        up_cap = max(0.0, p_high - p_arr[i])\n        down_cap = max(0.0, p_arr[i] - p_low)\n        adj_units.append((i, inc_cost, up_cap, down_cap))\n    \n    # Adjust while residual exists\n    tolerance = 1e-6\n    max_adjust = 100\n    adjust_iter = 0\n    \n    while abs(residual) > tolerance and adjust_iter < max_adjust:\n        adjust_iter += 1\n        if residual > 0:  # Need more power\n            # Find unit with lowest incremental cost and capacity\n            candidates = [(i, cost, cap) for i, cost, cap, down in adj_units if cap > 0]\n            if not candidates:\n                break\n            i, min_cost, min_cap = min(candidates, key=lambda x: x[1])\n            delta = min(residual, min_cap)\n            if delta > 0:\n                p_arr[i] += delta\n                residual -= delta\n                # Update adjustment capacities\n                for idx, adj in enumerate(adj_units):\n                    if adj[0] == i:\n                        adj_units[idx] = (i, adj[1], adj[2] - delta, adj[3])\n        else:  # Need less power\n            # Find unit with highest incremental cost and reduction capacity\n            candidates = [(i, cost, down) for i, cost, cap, down in adj_units if down > 0]\n            if not candidates:\n                break\n            i, max_cost, max_down = max(candidates, key=lambda x: x[1])\n            delta = min(-residual, max_down)\n            if delta > 0:\n                p_arr[i] -= delta\n                residual += delta\n                # Update adjustment capacities\n                for idx, adj in enumerate(adj_units):\n                    if adj[0] == i:\n                        adj_units[idx] = (i, adj[1], adj[2], adj[3] - delta)\n    \n    # Final update: set commitment status\n    for i in committed_set:\n        u_arr[i] = 1\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0042654838,
          "gap_price_rate": 0.0085184531,
          "fitness": 0.0063919685
     },
     {
          "name": "refined_amortized_dispatch_with_bisection",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown ramp constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).  \n2. For free offline units, adjust startup cost amortization: half amortization over min up-time if next load \u2265 current load, else full amortization.  \n3. Precompute cost metrics for free units: cost per MW at min power. Build commitment set starting with forced-on units, add free units by ascending cost until max capacity \u2265 load.  \n4. Refine commitment: remove expensive free units (descending cost) while min capacity > load and removal maintains max capacity \u2265 load.  \n5. Calculate feasible bounds: ramp-constrained bounds for previously online units; startup-constrained bounds for newly started units.  \n6. Dispatch via:  \n   a) Set outputs to min/max if load \u2264 total min / \u2265 total max  \n   b) Use bisection with analytical derivatives for lambda iteration  \n   c) Greedy residual adjustment with marginal cost prioritization  \n7. Set non-committed units offline (u_i=0, p_i=0).  \n8. Return schedules as 2D array of commitment states and power outputs.  \n\n",
          "code": "import numpy as np  \n\ndef refined_amortized_dispatch_with_bisection(units_info, load):  \n    n_units = len(units_info)  \n    current_load = load[0]  \n    categories = [''] * n_units  \n    committed = [False] * n_units  \n    free_indices = []  \n    cost_metric = [0.0] * n_units  \n    \n    # Step 1: Classify units  \n    forced_on_indices = []  \n    forced_off_indices = []  \n    free_online_indices = []  \n    free_offline_indices = []  \n    \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        t_on_min_i = unit['t_on_min_i']  \n        t_off_min_i = unit['t_off_min_i']  \n        p_shut_i = unit['p_shut_i']  \n          \n        if u_i0 == 1:  \n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:  \n                categories[i] = 'forced-on'  \n                committed[i] = True  \n                forced_on_indices.append(i)  \n            else:  \n                categories[i] = 'free-online'  \n                free_online_indices.append(i)  \n        else:  \n            if t_i0 < 0 and abs(t_i0) < t_off_min_i:  \n                categories[i] = 'forced-off'  \n                committed[i] = False  \n                forced_off_indices.append(i)  \n            else:  \n                categories[i] = 'free-offline'  \n                free_offline_indices.append(i)  \n    \n    free_indices = free_online_indices + free_offline_indices  \n    \n    # Step 2: Precompute cost metrics  \n    for i in free_indices:  \n        unit = units_info[i]  \n        a_i = unit['a_i']  \n        b_i = unit['b_i']  \n        c_i = unit['c_i']  \n        p_min_i = unit['p_min_i']  \n        cost_min = a_i + b_i * p_min_i + c_i * p_min_i ** 2  \n          \n        if i in free_offline_indices:  \n            s_i = unit['s_i']  \n            t_on_min_i = unit['t_on_min_i']  \n            if load[1] >= current_load:  \n                amortized = s_i / (2 * t_on_min_i)  \n            else:  \n                amortized = s_i / t_on_min_i  \n            cost_min += amortized  \n        cost_metric[i] = cost_min / p_min_i  \n    \n    # Step 3 & 4: Build and refine commitment set  \n    total_min = 0.0  \n    total_max = 0.0  \n    bounds_dict = {}  \n    \n    def compute_bounds(i):  \n        unit = units_info[i]  \n        if unit['u_i_0'] == 1:  # Previously online  \n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  # Newly started  \n            lb = unit['p_min_i']  \n            ub = min(unit['p_max_i'], unit['p_start_i'])  \n        return lb, ub  \n    \n    # Forced-on units  \n    for i in forced_on_indices:  \n        lb, ub = compute_bounds(i)  \n        bounds_dict[i] = (lb, ub)  \n        total_min += lb  \n        total_max += ub  \n    \n    # Add free units in cost-ascending order  \n    candidate_free = sorted(free_indices, key=lambda i: cost_metric[i])  \n    temp_min = total_min  \n    temp_max = total_max  \n    \n    for i in candidate_free:  \n        lb, ub = compute_bounds(i)  \n        if temp_max < current_load:  \n            committed[i] = True  \n            bounds_dict[i] = (lb, ub)  \n            temp_min += lb  \n            temp_max += ub  \n        else:  \n            break  \n    \n    # Refine: remove expensive free units  \n    removed = True  \n    while removed and temp_min > current_load:  \n        removed = False  \n        expensive_free = sorted(  \n            [i for i in candidate_free if committed[i]],  \n            key=lambda i: cost_metric[i],  \n            reverse=True  \n        )  \n        for i in expensive_free:  \n            lb, ub = bounds_dict[i]  \n            if temp_max - ub >= current_load:  \n                committed[i] = False  \n                del bounds_dict[i]  \n                temp_min -= lb  \n                temp_max -= ub  \n                removed = True  \n                break  \n    \n    committed_indices = [i for i in range(n_units) if committed[i]]  \n    if not committed_indices:  \n        schedules = np.zeros((2, n_units))  \n        return schedules  \n    \n    # Recompute total min/max for dispatch bounds  \n    total_min = 0.0  \n    total_max = 0.0  \n    lb_arr = []  \n    ub_arr = []  \n    a_arr = []  \n    b_arr = []  \n    c_arr = []  \n    unit_index_map = []  \n    \n    for i in committed_indices:  \n        lb, ub = compute_bounds(i)  \n        bounds_dict[i] = (lb, ub)  \n        total_min += lb  \n        total_max += ub  \n        lb_arr.append(lb)  \n        ub_arr.append(ub)  \n        a_arr.append(units_info[i]['a_i'])  \n        b_arr.append(units_info[i]['b_i'])  \n        c_arr.append(units_info[i]['c_i'])  \n        unit_index_map.append(i)  \n    \n    lb_arr = np.array(lb_arr)  \n    ub_arr = np.array(ub_arr)  \n    a_arr = np.array(a_arr)  \n    b_arr = np.array(b_arr)  \n    c_arr = np.array(c_arr)  \n    n_committed = len(committed_indices)  \n    p_arr = np.zeros(n_committed)  \n    \n    # Step 6: Dispatch  \n    if current_load <= total_min:  \n        p_arr = lb_arr.copy()  \n    elif current_load >= total_max:  \n        p_arr = ub_arr.copy()  \n    else:  \n        # Lambda iteration (bisection)  \n        TOL = 0.1  \n        MAX_ITER = 100  \n        lo = np.min(b_arr + 2 * c_arr * lb_arr)  \n        hi = np.max(b_arr + 2 * c_arr * ub_arr)  \n        iter_count = 0  \n        \n        while iter_count < MAX_ITER and hi - lo > TOL:  \n            lam = (lo + hi) / 2.0  \n            p_arr = np.minimum(  \n                ub_arr,  \n                np.maximum(  \n                    lb_arr,  \n                    (lam - b_arr) / (2 * c_arr)  \n                )  \n            )  \n            total_power = np.sum(p_arr)  \n            if total_power < current_load:  \n                lo = lam  \n            else:  \n                hi = lam  \n            iter_count += 1  \n        \n        # Greedy residual adjustment  \n        residual = current_load - np.sum(p_arr)  \n        while abs(residual) > TOL:  \n            if residual > 0:  # Underproduction  \n                candidates = []  \n                for j in range(n_committed):  \n                    if p_arr[j] < ub_arr[j]:  \n                        marginal_cost = b_arr[j] + 2 * c_arr[j] * p_arr[j]  \n                        headroom = ub_arr[j] - p_arr[j]  \n                        candidates.append((j, marginal_cost, headroom))  \n                if not candidates:  \n                    break  \n                candidates.sort(key=lambda x: x[1])  \n                idx, mc, hr = candidates[0]  \n                inc = min(residual, hr)  \n                p_arr[idx] += inc  \n                residual -= inc  \n            else:  # Overproduction  \n                candidates = []  \n                for j in range(n_committed):  \n                    if p_arr[j] > lb_arr[j]:  \n                        marginal_cost = b_arr[j] + 2 * c_arr[j] * p_arr[j]  \n                        headroom = p_arr[j] - lb_arr[j]  \n                        candidates.append((j, marginal_cost, headroom))  \n                if not candidates:  \n                    break  \n                candidates.sort(key=lambda x: x[1], reverse=True)  \n                idx, mc, hr = candidates[0]  \n                dec = min(abs(residual), hr)  \n                p_arr[idx] -= dec  \n                residual += dec  \n    \n    # Prepare output  \n    schedules = np.zeros((2, n_units))  \n    for j, i in enumerate(committed_indices):  \n        schedules[0, i] = 1  \n        schedules[1, i] = p_arr[j]  \n    \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0049878631,
          "gap_price_rate": 0.0083818325,
          "fitness": 0.0066848478
     },
     {
          "name": "enhanced_hybrid_amortized_dispatch",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_hybrid_amortized_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    if n_units == 0:\n        return schedules\n    \n    current_load, next_load = load\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    bounds = {}\n    cost_rates = {}\n    amortized_startup = {}\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u0, t0, p0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        t_off_min, t_on_min = unit['t_off_min_i'], unit['t_on_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < t_on_min) or (p0 > p_shut):\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n            low = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            high = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Previously offline\n            if abs(t0) < t_off_min:  # Note: t0 negative offline\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (low, high)\n    \n    # Step 2: Dynamic startup amortization\n    for i in free_offline:\n        s_i = units_info[i]['s_i']\n        t_on_min = units_info[i]['t_on_min_i']\n        amortized_startup[i] = s_i / (2 * t_on_min) if next_load >= current_load else s_i / t_on_min\n    \n    # Step 3: Compute cost rates\n    for i in free_online + free_offline:\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        p_min = bounds[i][0]\n        base_cost = a + b * p_min + c * p_min**2\n        if i in free_offline:\n            base_cost += amortized_startup[i]\n        cost_rates[i] = base_cost / p_min\n    \n    # Step 4: Initialize commitment set\n    committed = set(forced_on)\n    total_min_committed = sum(bounds[i][0] for i in committed)\n    total_max_committed = sum(bounds[i][1] for i in committed)\n    \n    free_candidates = free_online + free_offline\n    free_candidates.sort(key=lambda i: cost_rates[i])\n    \n    for i in free_candidates:\n        if total_max_committed >= current_load:\n            break\n        committed.add(i)\n        total_min_committed += bounds[i][0]\n        total_max_committed += bounds[i][1]\n    \n    # Step 5: Refine commitment set\n    free_in_committed = [i for i in committed if i in free_online or i in free_offline]\n    free_in_committed.sort(key=lambda i: cost_rates[i], reverse=True)\n    \n    for i in free_in_committed:\n        new_min = total_min_committed - bounds[i][0]\n        new_max = total_max_committed - bounds[i][1]\n        if (new_max >= current_load) and (new_min <= current_load) and (next_load < current_load):\n            committed.remove(i)\n            total_min_committed = new_min\n            total_max_committed = new_max\n    \n    # Step 6: Economic dispatch\n    dispatch_output = {}\n    if committed:\n        # Boundary cases\n        if current_load <= total_min_committed:\n            for i in committed:\n                dispatch_output[i] = bounds[i][0]\n        elif current_load >= total_max_committed:\n            for i in committed:\n                dispatch_output[i] = bounds[i][1]\n        else:\n            # Prepare units for lambda iteration\n            quad_units = []\n            lin_units = []\n            for i in committed:\n                unit = units_info[i]\n                low, high = bounds[i]\n                if unit['c_i'] > 0:  # Quadratic unit\n                    quad_units.append({\n                        'low': low, 'high': high, 'b': unit['b_i'], \n                        'c': unit['c_i'], 'idx': i\n                    })\n                else:  # Linear unit\n                    lin_units.append({\n                        'low': low, 'high': high, 'b': unit['b_i'], \n                        'idx': i\n                    })\n            \n            # Lambda iteration for quadratic units\n            lambda_low = 0.0\n            lambda_high = 1e5\n            tol = 1e-4\n            max_iter = 100\n            for _ in range(max_iter):\n                lam = (lambda_low + lambda_high) / 2\n                total_power = 0.0\n                for unit in quad_units:\n                    p = (lam - unit['b']) / (2 * unit['c'])\n                    p = max(unit['low'], min(unit['high'], p))\n                    total_power += p\n                if abs(total_power + sum(u['low'] for u in lin_units) - current_load) < tol:\n                    break\n                if total_power + sum(u['low'] for u in lin_units) < current_load:\n                    lambda_low = lam\n                else:\n                    lambda_high = lam\n            \n            # Assign quadratic outputs\n            for unit in quad_units:\n                p = (lam - unit['b']) / (2 * unit['c'])\n                p = max(unit['low'], min(unit['high'], p))\n                dispatch_output[unit['idx']] = p\n                current_load -= p\n            \n            # Handle linear units with greedy residual adjustment\n            lin_units.sort(key=lambda u: u['b'])  # Sort by linear coeff (marginal cost)\n            total_lin_output = 0\n            for unit in lin_units:\n                # Prioritize units with lower b_i\n                p_possible = unit['high'] - unit['low']\n                if current_load - total_lin_output >= p_possible:\n                    dispatch_output[unit['idx']] = unit['high']\n                    total_lin_output += p_possible\n                else:\n                    dispatch_output[unit['idx']] = unit['low'] + (current_load - total_lin_output)\n                    total_lin_output = current_load\n                    break\n    \n    # Step 7: Set schedules\n    for i in range(n_units):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_output.get(i, 0.0)\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.005031166,
          "gap_price_rate": 0.0084250207,
          "fitness": 0.0067280934
     },
     {
          "name": "enhanced_amortized_cost_dispatch_forecast",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization (s_i / (2 * t_on_min_i)) if next period's load is greater than current load, else full amortization (s_i / t_on_min_i).\n3. Build candidate commitment set starting with forced-on units, then add free units sorted by ascending cost metric (operating cost at min power for free online; amortized startup cost plus operating cost at min power for free offline).\n4. Refine commitment set:\n   a. While total ramp-constrained max capacity < current load: add next cheapest free unit\n   b. While total ramp-constrained min capacity > load: remove most expensive free unit if removal maintains max capacity \u2265 load\n5. Calculate feasible power bounds for committed units:\n   a. Previously online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   b. Newly started: [p_min_i, min(p_max_i, p_start_i)]\n6. Dispatch load using multi-stage method:\n   a. Boundary cases: set all outputs to min if load \u2264 total min; set all to max if load \u2265 total max\n   b. Use Newton-bisection hybrid for lambda iteration\n   c. Adjust residuals using cost-prioritized greedy method respecting ramp constraints\n7. Set non-committed units to offline (u_i=0, p_i=0).\n8. Return schedules as 2D NumPy array.\n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch_forecast(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n\n    # Initialize arrays\n    u_i = np.zeros(n_units, dtype=int)\n    p_i = np.zeros(n_units)\n    cost_rates = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units and calculate cost rates\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        min_up = unit['t_on_min_i']\n        \n        # Forced status checks\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                \n        # Cost rate calculation\n        base_cost = a + b * p_min + c * p_min ** 2\n        if u_i0 == 1:  # Free online\n            cost_rates[i] = base_cost / p_min\n        else:          # Free offline\n            if next_load > current_load:\n                amortized_startup = s / (2 * max(1, min_up))\n            else:\n                amortized_startup = s / max(1, min_up)\n            cost_rates[i] = (base_cost + amortized_startup) / p_min\n\n    # Initialize commitment set\n    committed = set(forced_on)\n    candidates = sorted(free_online + free_offline, key=lambda i: cost_rates[i])\n    \n    # Calculate total capacity\n    def total_capacity(com_set):\n        total_min, total_max = 0, 0\n        for i in com_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1 or i in committed:  # Online or committed\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Offline unit to start\n                min_out = unit['p_min_i']\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_out\n            total_max += max_out\n        return total_min, total_max\n\n    # Add units until capacity meets demand\n    total_min, total_max = total_capacity(committed)\n    for i in candidates:\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        new_min = total_min + min_out\n        new_max = total_max + max_out\n        if new_max < current_load:\n            committed.add(i)\n            total_min, total_max = new_min, new_max\n        else:\n            break\n    \n    # Refine set if min capacity exceeds load\n    free_committed = sorted([i for i in committed if i not in forced_on], key=lambda i: cost_rates[i], reverse=True)\n    for i in free_committed:\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        test_min, test_max = total_capacity(committed - {i})\n        if test_min <= current_load and test_max >= current_load and total_min - min_out <= current_load:\n            committed.remove(i)\n            total_min, total_max = test_min, test_max\n    \n    # Power bounds for committed units\n    min_limits = np.zeros(n_units)\n    max_limits = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Newly started\n            min_limits[i] = unit['p_min_i']\n            max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Handle boundary conditions\n    def set_to_bounds(bound_type):\n        dispatch = np.zeros(n_units)\n        for i in committed:\n            dispatch[i] = min_limits[i] if bound_type == 'min' else max_limits[i]\n        return dispatch\n\n    if current_load <= total_min:\n        p_i = set_to_bounds('min')\n    elif current_load >= total_max:\n        p_i = set_to_bounds('max')\n    else:\n        # Newton-bisection hybrid for lambda iteration\n        a_arr = np.array([units_info[i]['a_i'] for i in committed])\n        b_arr = np.array([units_info[i]['b_i'] for i in committed])\n        c_arr = np.array([units_info[i]['c_i'] for i in committed])\n        min_arr = np.array([min_limits[i] for i in committed])\n        max_arr = np.array([max_limits[i] for i in committed])\n        \n        lamb_low = np.min(b_arr + 2 * c_arr * min_arr)\n        lamb_high = np.max(b_arr + 2 * c_arr * max_arr)\n        \n        def calc_total_p(lamb):\n            p_unclip = (lamb - b_arr) / (2 * c_arr + 1e-10)\n            p_clip = np.clip(p_unclip, min_arr, max_arr)\n            return p_clip, np.sum(p_clip)\n        \n        for _ in range(50):\n            lamb = (lamb_low + lamb_high) / 2\n            p_candidate, total_p = calc_total_p(lamb)\n            if abs(total_p - current_load) < 1e-3:\n                break\n            if total_p < current_load:\n                lamb_low = lamb\n            else:\n                lamb_high = lamb\n                \n        # Residual adjustment\n        _, total_p = calc_total_p(lamb)\n        residual = current_load - total_p\n        \n        if abs(residual) > 1e-3:\n            headroom_arr = max_arr - p_candidate\n            residual_sign = np.sign(residual)\n            \n            # Cost-prioritized adjustment\n            marg_costs = b_arr + 2 * c_arr * p_candidate\n            priority = np.argsort(marg_costs * residual_sign)\n            \n            for idx in priority:\n                adj_needed = min(abs(residual), headroom_arr[idx]) * residual_sign\n                p_candidate[idx] += adj_needed\n                residual -= adj_needed\n                if abs(residual) < 1e-3:\n                    break\n                    \n        # Map back to units\n        for ptr, i in enumerate(committed):\n            p_i[i] = max(min_limits[i], min(max_limits[i], p_candidate[ptr]))\n    \n    # Set commitment states\n    for i in range(n_units):\n        u_i[i] = 1 if i in committed else 0\n        if i not in committed:\n            p_i[i] = 0\n\n    return np.vstack([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.0064305425,
          "gap_price_rate": 0.007208568,
          "fitness": 0.0068195553
     }
]