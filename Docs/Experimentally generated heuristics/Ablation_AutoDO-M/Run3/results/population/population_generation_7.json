[
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to minimum up-time or shutdown ramp constraints), forced-off (must remain offline due to minimum down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Precompute cost metrics for free units:\n   - Free online: cost rate = (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: cost rate = (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate commitment set starting with forced-on units, then add free units sorted by ascending cost rate until total ramp-constrained max capacity \u2265 current load. Precompute ramp-constrained min/max for each unit during classification.\n4. Refine commitment by removing expensive free units:\n   - Sort committed free units by cost rate descending\n   - Iteratively remove the most expensive unit if removal maintains max capacity \u2265 load and reduces min capacity below or equal to load\n5. Calculate dispatch bounds for committed units considering startup/shutdown ramps and online ramp constraints:\n   - Previously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Newly started units: [p_min_i, min(p_max_i, p_start_i)]\n6. Perform economic dispatch using optimized lambda iteration:\n   - Handle boundary cases where load \u2264 total min or \u2265 total max\n   - Use bisection with analytical derivative for faster convergence\n   - Distribute residual with priority-based greedy adjustment to ensure exact load matching\n7. Set non-committed units to offline state (u_i=0, p_i=0).\n8. Return commitment states and power outputs as a 2D NumPy array.\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = [0] * n_units\n    p_schedule = [0] * n_units\n    \n    # Data structures to store processed unit information\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    processed_units = [None] * n_units\n    \n    # Classify units and precompute parameters\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        forced_on_flag = False\n        forced_off_flag = False\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on_flag = True\n                forced_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:  # Currently offline\n            if -t0 < unit['t_off_min_i']:\n                forced_off_flag = True\n                forced_off.append(idx)\n            else:\n                free_offline.append(idx)\n                \n        # Precompute ramp-constrained boundaries\n        if u0 == 1:  # Online units\n            min_p = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline units\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate amortized cost rate for free units\n        if not (forced_on_flag or forced_off_flag):\n            operating_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if u0 == 1:  # Free online\n                cost_rate = operating_cost_min / unit['p_min_i']\n            else:  # Free offline\n                startup_amortized = unit['s_i'] / unit['t_on_min_i']\n                cost_rate = (operating_cost_min + startup_amortized) / unit['p_min_i']\n        else:\n            cost_rate = float('inf') if forced_off_flag else -float('inf')\n        \n        processed_units[idx] = {\n            'idx': idx,\n            'u0': u0,\n            'forced_on': forced_on_flag,\n            'forced_off': forced_off_flag,\n            'min_bound': min_p,\n            'max_bound': max_p,\n            'cost_rate': cost_rate,\n            'b': unit['b_i'],\n            'c': unit['c_i']\n        }\n    \n    # Initialize commitment set with forced-on units\n    committed_set = set(forced_on)\n    total_min = sum(processed_units[idx]['min_bound'] for idx in forced_on)\n    total_max = sum(processed_units[idx]['max_bound'] for idx in forced_on)\n    \n    # Candidate free units sorted by cost rate (ascending)\n    free_candidates = free_online + free_offline\n    free_candidates.sort(key=lambda idx: processed_units[idx]['cost_rate'])\n    \n    # Add free units until capacity meets or exceeds load\n    for idx in free_candidates:\n        if total_max < current_load:\n            committed_set.add(idx)\n            total_min += processed_units[idx]['min_bound']\n            total_max += processed_units[idx]['max_bound']\n        else:\n            break\n    \n    # Remove expensive free units if min capacity exceeds load\n    free_in_commit = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_in_commit.sort(key=lambda idx: processed_units[idx]['cost_rate'], reverse=True)\n    removed = True\n    while removed and total_min > current_load:\n        removed = False\n        for idx in free_in_commit:\n            unit = processed_units[idx]\n            new_min = total_min - unit['min_bound']\n            new_max = total_max - unit['max_bound']\n            if new_max >= current_load:\n                committed_set.remove(idx)\n                total_min = new_min\n                total_max = new_max\n                free_in_commit.remove(idx)\n                removed = True\n                break\n    \n    # Prepare dispatch units with valid bounds\n    dispatch_units = []\n    for idx in committed_set:\n        unit = processed_units[idx]\n        min_bound = unit['min_bound']\n        max_bound = unit['max_bound']\n        \n        # Ensure bounds are valid\n        if min_bound > max_bound:\n            min_bound = max_bound = (min_bound + max_bound) / 2\n            \n        dispatch_units.append({\n            'min': min_bound,\n            'max': max_bound,\n            'b': unit['b'],\n            'c': unit['c'],\n            'idx': idx\n        })\n    \n    # Calculate total dispatch bounds\n    total_min_dispatch = sum(unit['min'] for unit in dispatch_units)\n    total_max_dispatch = sum(unit['max'] for unit in dispatch_units)\n    \n    # Handle boundary cases\n    if current_load <= total_min_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['min']\n    elif current_load >= total_max_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['max']\n    else:\n        # Lambda iteration (bisection) with derivative for speed\n        low_lambda = 0\n        high_lambda = 1e6\n        tolerance = 1e-5\n        iterations = 0\n        \n        while iterations < 100 and (high_lambda - low_lambda) > tolerance:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            derivative_sum = 0\n            \n            for unit in dispatch_units:\n                c = unit['c']\n                if c == 0:  # Linear cost function\n                    p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n                else:\n                    p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                    p = max(unit['min'], min(unit['max'], p_unclamped))\n                \n                unit['p_temp'] = p\n                total_power += p\n                \n                if unit['min'] < p < unit['max']:\n                    derivative_sum += 1 / (2 * c)\n            \n            if derivative_sum == 0:  # All units at bounds\n                if total_power < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            else:\n                lambda_derivative = derivative_sum\n                error = total_power - current_load\n                mid_lambda -= error / lambda_derivative\n                \n                if total_power > current_load:\n                    high_lambda = mid_lambda\n                else:\n                    low_lambda = mid_lambda\n            \n            iterations += 1\n        \n        # Final power calculation\n        total_power = 0\n        for unit in dispatch_units:\n            c = unit['c']\n            if c == 0:\n                p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n            else:\n                p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                p = max(unit['min'], min(unit['max'], p_unclamped))\n            unit['p_temp'] = p\n            total_power += p\n        \n        # Adjust for residual with greedy method\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            if residual > 0:\n                candidates = [u for u in dispatch_units if u['p_temp'] < u['max']]\n                candidates.sort(key=lambda u: u['b'] + 2 * u['c'] * u['p_temp'])\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['max'] - unit['p_temp']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] += adjust\n                    residual -= adjust\n            else:\n                residual = abs(residual)\n                candidates = [u for u in dispatch_units if u['p_temp'] > u['min']]\n                candidates.sort(key=lambda u: -(u['b'] + 2 * u['c'] * u['p_temp']))\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['p_temp'] - unit['min']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] -= adjust\n                    residual -= adjust\n        \n        # Assign final dispatch values\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['p_temp']\n    \n    # Set commitment states\n    for idx in committed_set:\n        u_schedule[idx] = 1\n    \n    return np.array([u_schedule, p_schedule])",
          "from": "mutation",
          "gap_power_rate": 0.0033675075,
          "gap_price_rate": 0.0081376386,
          "fitness": 0.0057525731
     },
     {
          "name": "refined_priority_amortized_dispatch_v1",
          "algorithm": "1. Classify units into must-run (forced-on), must-off (forced-off), free-online (adjustable/online), and free-offline (adjustable/offline) using min up/down times and shutdown constraints.\n2. For free-offline units, adjust startup cost amortization based on forecasted load: use half amortization if next load exceeds current load (indicating sustained need), else full amortization.\n3. Combine must-run units with free units sorted by amortized cost metric: (operating cost at min power) for free-online; (amortized startup cost + operating cost) for free-offline.\n4. Build commitment by adding free units in cost-ascending order until max capacity (considering ramp limits) meets current load.\n5. Remove expensive free units (descending cost order) if min capacity exceeds load while maintaining sufficient max capacity and feasible min capacity.\n6. Compute feasible power bounds considering ramp limits for online units and startup limits for new units.\n7. Dispatch load: set min/max outputs when load is outside total capacity bounds; use lambda iteration (bisection) for optimal dispatch within bounds.\n8. Set non-committed units to off state.\n\n",
          "code": "import numpy as np\n\ndef refined_priority_amortized_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    u_i_final = np.zeros(n_units)\n    p_i_final = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    cost_metric = [0] * n_units\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Compute cost metric with forecast-based amortization\n    for i in free_online:\n        a, b, c, p_min = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['p_min_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n    \n    for i in free_offline:\n        a, b, c, s, p_min = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i'], units_info[i]['p_min_i']\n        amort_factor = 0.5 if forecast_load > current_load else 1.0\n        adjusted_startup = s * amort_factor\n        cost_metric[i] = (adjusted_startup + a + b * p_min + c * p_min**2) / p_min\n    \n    # Build candidate list (must-run + sorted free units)\n    free_indices = free_online + free_offline\n    free_indices.sort(key=lambda i: cost_metric[i])\n    candidate_list = must_run + free_indices\n    \n    # Commit units by ascending cost until max capacity >= load\n    committed = set(must_run)\n    total_min = total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for i in must_run:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Add free units until load is satisfied\n    for i in free_indices:\n        if total_max >= current_load:\n            break\n        if i in free_online:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Remove non-essential units if over-committed (min capacity > load)\n    free_in_commit = [i for i in committed if i not in must_run]\n    free_in_commit.sort(key=lambda i: cost_metric[i], reverse=True)\n    for i in free_in_commit[:]:\n        unit = units_info[i]\n        if i in free_online:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        if (total_min - min_p) <= current_load and (total_max - max_p) >= current_load:\n            committed.remove(i)\n            total_min -= min_p\n            total_max -= max_p\n    \n    # Calculate bounds for committed units\n    min_bounds, max_bounds, b_coeffs, c_coeffs = [], [], [], []\n    for i in committed:\n        unit = units_info[i]\n        if i in free_online or i in must_run:\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds.append(min_b)\n        max_bounds.append(max_b)\n        b_coeffs.append(unit['b_i'])\n        c_coeffs.append(unit['c_i'])\n    \n    # Dispatch load to committed units\n    if current_load <= total_min:\n        outputs = min_bounds\n    elif current_load >= total_max:\n        outputs = max_bounds\n    else:\n        outputs = list(min_bounds)\n        remain = current_load - sum(outputs)\n        max_up = [max_bounds[j] - min_bounds[j] for j in range(len(committed))]\n        \n        # Bisection (lambda iteration) setup\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        lb = min(b_coeffs)  # Lower bound of lambda\n        ub = max(b_coeffs) + 2 * max(c_coeffs) * max(max_bounds)  # Upper bound of lambda\n        \n        while abs(remain) > tol and iter_count < max_iter:\n            lambda_val = (lb + ub) / 2\n            sum_p = 0\n            for j in range(len(committed)):\n                if c_coeffs[j] > 0:\n                    p = (lambda_val - b_coeffs[j]) / (2 * c_coeffs[j])\n                    p = max(min_bounds[j], min(p, max_bounds[j]))\n                    sum_p += p\n                else:\n                    # Linear cost (special case)\n                    p = max_bounds[j] if lambda_val > b_coeffs[j] else min_bounds[j]\n                    sum_p += p\n            if sum_p < current_load:\n                lb = lambda_val\n            else:\n                ub = lambda_val\n            remain = current_load - sum_p\n            iter_count += 1\n        \n        # Final output calculation\n        outputs = []\n        for j in range(len(committed)):\n            if c_coeffs[j] > 0:\n                p = (lambda_val - b_coeffs[j]) / (2 * c_coeffs[j])\n                outputs.append(max(min_bounds[j], min(p, max_bounds[j])))\n            else:\n                outputs.append(max_bounds[j] if lambda_val > b_coeffs[j] else min_bounds[j])\n    \n    # Prepare final schedules\n    committed_list = list(committed)\n    for idx, unit_idx in enumerate(committed_list):\n        u_i_final[unit_idx] = 1\n        p_i_final[unit_idx] = outputs[idx]\n    \n    schedules = np.array([u_i_final, p_i_final])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0050003774,
          "gap_price_rate": 0.0086673209,
          "fitness": 0.0068338492
     },
     {
          "name": "enhanced_amortized_cost_dispatch",
          "algorithm": "1. Classify units into forced-on (due to min up-time or shutdown constraints), forced-off (due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline). 2. Precompute amortized cost metrics for free units: (operating cost at min power for free online; startup cost amortized over min up-time plus operating cost at min power for free offline). 3. Form initial commitment set: forced-on units + free units sorted by amortized cost. 4. While total ramp-constrained max capacity < current load: add next cheapest free unit. 5. While total ramp-constrained min capacity > load: remove most expensive free unit (if feasible). 6. For committed units: calculate feasible power bounds considering ramp constraints. 7. Dispatch load using lambda iteration with residual adjustment for exact matching. 8. Set non-committed units to off with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints and state\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost metrics for free units\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        cost_metric[i] = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_metric[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n    \n    # Create sorted free unit list (by cost metric ascending)\n    free_units = free_online + free_offline\n    free_units_sorted = sorted(free_units, key=lambda i: cost_metric[i])\n    \n    # Initialize committed set with forced-on units\n    committed_set = set(forced_on)\n    \n    # Calculate initial capacity bounds\n    total_min = 0.0\n    total_max = 0.0\n    \n    def get_feasible_bounds(i, committed=False):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Was offline, only if committed (being started)\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        return min_p, max_p\n    \n    for i in committed_set:\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Add free units until total_max >= current_load\n    for i in free_units_sorted:\n        if total_max >= current_load:\n            break\n        if i in committed_set:\n            continue\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        committed_set.add(i)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Remove expensive free units if total_min > current_load\n    free_committed = [i for i in committed_set if i not in forced_on]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    changed = True\n    while changed and free_committed_sorted:\n        changed = False\n        for i in free_committed_sorted:\n            candidate_set = committed_set - {i}\n            # Recalculate bounds for candidate set\n            new_min = 0.0\n            new_max = 0.0\n            for j in candidate_set:\n                min_p_j, max_p_j = get_feasible_bounds(j, j in candidate_set)\n                new_min += min_p_j\n                new_max += max_p_j\n            if new_min <= current_load <= new_max:\n                committed_set = candidate_set\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n        # Update free_committed list after removal\n        free_committed = [i for i in committed_set if i not in forced_on]\n        free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    # Update commitment status\n    for i in committed_set:\n        u[i] = 1\n    \n    # Precompute bounds for dispatch\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    for i in committed_set:\n        min_b, max_b = get_feasible_bounds(i, True)\n        min_bounds[i] = min_b\n        max_bounds[i] = max_b\n    \n    # Collect indices and coefficients for committed units\n    committed_indices = list(committed_set)\n    b_arr = np.array([units_info[i]['b_i'] for i in committed_indices])\n    c_arr = np.array([units_info[i]['c_i'] for i in committed_indices])\n    min_p_arr = min_bounds[committed_indices]\n    max_p_arr = max_bounds[committed_indices]\n    \n    # Initialize power for committed units\n    p_committed = np.zeros(len(committed_indices))\n    \n    # Lambda iteration for dispatch\n    if len(committed_indices) > 0:\n        lo_mc = 1e-6\n        hi_mc = 1e8\n        tol = 1e-3\n        max_iter = 100\n        \n        for _ in range(max_iter):\n            lam = (lo_mc + hi_mc) / 2\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:  # Linear cost\n                    if lam > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:  # Quadratic cost\n                    p_unclipped = (lam - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            \n            total_proposed = np.sum(p_proposed)\n            \n            if abs(total_proposed - current_load) < tol:\n                p_committed = p_proposed\n                break\n            \n            if total_proposed < current_load:\n                lo_mc = lam\n            else:\n                hi_mc = lam\n        else:\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:\n                    if lo_mc > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:\n                    p_unclipped = (lo_mc - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            p_committed = p_proposed\n        \n        # Residual adjustment for exact match\n        total_gen = np.sum(p_committed)\n        residual = current_load - total_gen\n        if abs(residual) > 1e-3:\n            # Positive residual: increase under-max units by marginal cost\n            if residual > 0:\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] < max_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    headroom = max_p_arr[unit_idx] - p_committed[unit_idx]\n                    if headroom < residual:\n                        p_committed[unit_idx] += headroom\n                        residual -= headroom\n                    else:\n                        p_committed[unit_idx] += residual\n                        residual = 0\n                        break\n            # Negative residual: decrease above-min units by marginal cost (reverse)\n            else:\n                residual = abs(residual)\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] > min_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)[::-1]\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    footroom = p_committed[unit_idx] - min_p_arr[unit_idx]\n                    if footroom < residual:\n                        p_committed[unit_idx] -= footroom\n                        residual -= footroom\n                    else:\n                        p_committed[unit_idx] -= residual\n                        residual = 0\n                        break\n        \n        # Assign power values to committed units\n        for idx, unit_idx in enumerate(committed_indices):\n            p[unit_idx] = p_committed[idx]\n    \n    # Set non-committed units to off and output zero\n    for i in range(n_units):\n        if i not in committed_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0050588692,
          "gap_price_rate": 0.0088502454,
          "fitness": 0.0069545573
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "combined_enhanced_priority_amortized_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain online due to min uptime or shutdown constraints), forced-off (must remain offline due to min downtime), free online (currently online and adjustable), and free offline (currently offline but available).  \n2. Calculate amortized cost metrics for free units:  \n   - Free online: (a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i  \n   - Free offline: (s_i/t_on_min_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i  \n3. Build initial commitment set with forced-on units and free online units. Calculate total min/max capacity considering ramp constraints.  \n4. If total max capacity < current load, activate free offline units sorted by amortized cost until max capacity meets load.  \n5. If total min capacity > current load, remove expensive non-essential free units (sorted by descending operating cost) while maintaining min capacity \u2264 load.  \n6. Calculate feasible power bounds for committed units:  \n   - Previously online: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i)  \n   - Newly started: p_min_i to min(p_max_i, p_start_i)  \n7. Dispatch load using accelerated lambda iteration:  \n   a. Handle boundary cases (all min/max) if load outside feasible range  \n   b. Use Newton-accelerated bisection to find optimal dispatch  \n   c. Apply residual adjustment respecting ramp constraints  \n8. Set non-committed units to off state (u_i=0, p_i=0).  \n9. Return schedules as 2D NumPy array.  \n\n",
          "code": "import numpy as np\n\ndef combined_enhanced_priority_amortized_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=np.float64)\n    p = np.zeros(n_units, dtype=np.float64)\n    \n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_up_time = unit['t_on_min_i']\n            time_on = unit['t_i_0']\n            shutdown_cap = unit['p_shut_i']\n            prev_output = unit['p_i_0']\n            \n            if time_on < min_up_time or prev_output > shutdown_cap:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            min_down_time = unit['t_off_min_i']\n            time_off = -unit['t_i_0']\n            \n            if time_off < min_down_time:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Precompute amortized costs for free units\n    amortized_costs = np.zeros(n_units)\n    for i in free_online:\n        a = units_info[i]['a_i']\n        b = units_info[i]['b_i']\n        c = units_info[i]['c_i']\n        p_min = units_info[i]['p_min_i']\n        amortized_costs[i] = (a + b*p_min + c*p_min**2) / p_min\n    \n    for i in free_offline:\n        a = units_info[i]['a_i']\n        b = units_info[i]['b_i']\n        c = units_info[i]['c_i']\n        s = units_info[i]['s_i']\n        t_up_min = units_info[i]['t_on_min_i']\n        p_min = units_info[i]['p_min_i']\n        amortized_costs[i] = (s/t_up_min + a + b*p_min + c*p_min**2) / p_min\n    \n    # Build initial commitment set\n    committed = set(forced_on)\n    total_min, total_max = 0.0, 0.0\n    \n    # Calculate bounds for forced-on units\n    for i in forced_on:\n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        p_prev = units_info[i]['p_i_0']\n        ramp_down = units_info[i]['p_down_i']\n        ramp_up = units_info[i]['p_up_i']\n        \n        lb = max(p_min, p_prev - ramp_down)\n        ub = min(p_max, p_prev + ramp_up)\n        \n        total_min += lb\n        total_max += ub\n    \n    # Add free online units\n    for i in sorted(free_online, key=lambda i: amortized_costs[i]):\n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        p_prev = units_info[i]['p_i_0']\n        ramp_down = units_info[i]['p_down_i']\n        ramp_up = units_info[i]['p_up_i']\n        \n        lb = max(p_min, p_prev - ramp_down)\n        ub = min(p_max, p_prev + ramp_up)\n        \n        if total_max < current_load:\n            committed.add(i)\n            total_min += lb\n            total_max += ub\n    \n    # Add free offline units if needed\n    for i in sorted(free_offline, key=lambda i: amortized_costs[i]):\n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        start_limit = units_info[i]['p_start_i']\n        ub = min(p_max, start_limit)\n        \n        if total_max < current_load:\n            committed.add(i)\n            total_min += p_min\n            total_max += ub\n    \n    # Remove expensive units if overcommitted\n    if total_min > current_load:\n        removable = [i for i in committed if i not in forced_on]\n        for i in sorted(removable, key=lambda i: -amortized_costs[i]):\n            p_min = units_info[i]['p_min_i']\n            p_prev = units_info[i]['p_i_0']\n            \n            if units_info[i]['u_i_0'] == 1:\n                ramp_down = units_info[i]['p_down_i']\n                lb = max(p_min, p_prev - ramp_down)\n            else:\n                lb = p_min\n            \n            if total_min - lb <= current_load:\n                break\n            committed.remove(i)\n            total_min -= lb\n            total_max -= units_info[i]['p_max_i']\n    \n    # Calculate dispatch bounds\n    lb_values = np.zeros(n_units)\n    ub_values = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if i not in committed:\n            lb_values[i] = ub_values[i] = 0.0\n            continue\n            \n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        p_prev = units_info[i]['p_i_0']\n        \n        if units_info[i]['u_i_0'] == 1:\n            ramp_down = units_info[i]['p_down_i']\n            ramp_up = units_info[i]['p_up_i']\n            lb_values[i] = max(p_min, p_prev - ramp_down)\n            ub_values[i] = min(p_max, p_prev + ramp_up)\n        else:\n            start_limit = units_info[i]['p_start_i']\n            lb_values[i] = p_min\n            ub_values[i] = min(p_max, start_limit)\n    \n    # Handle boundary cases\n    comm_idx = np.array(list(committed), dtype=int)\n    comm_min = lb_values[comm_idx].sum()\n    comm_max = ub_values[comm_idx].sum()\n    \n    if current_load <= comm_min:\n        for i in committed:\n            p[i] = lb_values[i]\n            u[i] = 1\n        return np.vstack((u, p))\n    \n    if current_load >= comm_max:\n        for i in committed:\n            p[i] = ub_values[i]\n            u[i] = 1\n        return np.vstack((u, p))\n    \n    # Lambda iteration with Newton acceleration\n    a_arr = np.array([units_info[i]['a_i'] for i in comm_idx])\n    b_arr = np.array([units_info[i]['b_i'] for i in comm_idx])\n    c_arr = np.array([units_info[i]['c_i'] for i in comm_idx])\n    lb_comm = lb_values[comm_idx]\n    ub_comm = ub_values[comm_idx]\n    n_comm = len(comm_idx)\n    \n    # Newton-accelerated bisection\n    lam_low = (b_arr + 2*c_arr*lb_comm).min()\n    lam_high = (b_arr + 2*c_arr*ub_comm).max()\n    lam = (lam_low + lam_high) / 2\n    \n    f_val = np.inf\n    iteration = 0\n    max_iter = 50\n    \n    while abs(f_val) > 1e-5 and iteration < max_iter:\n        p_vals = np.clip((lam - b_arr) / (2 * c_arr), lb_comm, ub_comm)\n        f_val = p_vals.sum() - current_load\n        \n        # Derivative of power sum w.r.t lambda (inverse of second derivative)\n        df_dlam = np.sum(1/(2*c_arr))\n        lam -= f_val / df_dlam\n        lam = np.clip(lam, lam_low, lam_high)\n        iteration += 1\n    \n    # Set optimal dispatch values\n    for idx, i in enumerate(comm_idx):\n        p[i] = np.clip((lam - b_arr[idx]) / (2*c_arr[idx]), lb_comm[idx], ub_comm[idx])\n        u[i] = 1\n    \n    # Residual adjustment\n    total_p = p.sum()\n    residual = current_load - total_p\n    \n    if abs(residual) > 1e-3:\n        if residual > 0:\n            candidates = [i for i in comm_idx if p[i] < ub_values[i]]\n            costs = [b_arr[i] + 2*c_arr[i]*p[i] for i in range(n_comm)]\n            sorted_idx = np.argsort(costs)\n            \n            for j in sorted_idx:\n                idx = comm_idx[j]\n                if p[idx] < ub_values[idx]:\n                    delta = min(residual, ub_values[idx] - p[idx])\n                    p[idx] += delta\n                    residual -= delta\n                if residual <= 0:\n                    break\n        else:\n            residual = abs(residual)\n            candidates = [i for i in comm_idx if p[i] > lb_values[i]]\n            costs = [b_arr[i] + 2*c_arr[i]*p[i] for i in range(n_comm)]\n            sorted_idx = np.argsort(costs)[::-1]\n            \n            for j in sorted_idx:\n                idx = comm_idx[j]\n                if p[idx] > lb_values[idx]:\n                    delta = min(residual, p[idx] - lb_values[idx])\n                    p[idx] -= delta\n                    residual -= delta\n                if residual <= 0:\n                    break\n    \n    return np.vstack((u, p))",
          "from": "crossover",
          "gap_power_rate": 0.0050841815,
          "gap_price_rate": 0.0092566934,
          "fitness": 0.0071704375
     },
     {
          "name": "enhanced_amortized_cost_projection_dispatch",
          "algorithm": "1. Classify units into forced-on (minimum up-time/shutdown ramp constraints), forced-off (minimum down-time), free online (adjustable currently on), free offline (adjustable currently off).\n2. Calculate cost metrics for free units: linear projection of cost per MW considering ramp constraints and startup amortization.\n3. Form candidate commitment set: forced-on first, then free units sorted by projected cost.\n4. Build committed set by adding units until max capacity exceeds load. If min capacity exceeds load, remove most expensive non-essential units while maintaining capacity feasibility.\n5. Compute precise power bounds for committed units considering ramp constraints and startup/shutdown limits.\n6. Perform three-stage dispatch: \n   a) Set outputs to feasible bounds when load is outside total range\n   b) Use lambda iteration with Newton acceleration for quick convergence\n   c) Apply load-balanced residual adjustment respecting ramp rates\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_projection_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    cost_metric = {}\n    power_bounds = {}\n    \n    # Classify units and calculate cost metrics\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            must_stay_on = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n            if must_stay_on:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n                # Projected operating point considering ramp constraints\n                projected_p = max(unit['p_min_i'], min(unit['p_i_0'] + unit['p_up_i'], unit['p_max_i']))\n                cost_metric[i] = (unit['a_i'] + unit['b_i'] * projected_p + unit['c_i'] * projected_p**2) / projected_p\n        else:  # Was offline\n            must_stay_off = -unit['t_i_0'] < unit['t_off_min_i']\n            if must_stay_off:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                # Amortized startup cost with ramp-constrained projection\n                amortized_startup = unit['s_i'] / unit['t_on_min_i']\n                projected_p = min(unit['p_max_i'], unit['p_start_i'])\n                operating_cost = unit['a_i'] + unit['b_i'] * projected_p + unit['c_i'] * projected_p**2\n                cost_metric[i] = (amortized_startup + operating_cost) / projected_p\n\n    # Build candidate list (forced-on included regardless of cost)\n    candidate_list = forced_on.copy()\n    candidate_list.extend(sorted(free_online, key=lambda i: cost_metric[i]))\n    candidate_list.extend(sorted(free_offline, key=lambda i: cost_metric[i]))\n    \n    # Form initial commitment set\n    committed = set()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Forced-on units must be committed\n    for i in forced_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Start forced unit (should be rare)\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        power_bounds[i] = (lb, ub)\n        committed.add(i)\n        total_min += lb\n        total_max += ub\n\n    # Add free units until capacity meets load\n    for i in candidate_list:\n        if i in committed:\n            continue\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        if total_max < current_load:\n            power_bounds[i] = (lb, ub)\n            committed.add(i)\n            total_min += lb\n            total_max += ub\n    \n    # Remove expensive units if min capacity exceeds load\n    removal_candidates = sorted([i for i in committed if i not in forced_on], \n                              key=lambda i: cost_metric[i], reverse=True)\n    \n    for i in removal_candidates:\n        if total_min <= current_load:\n            break\n        lb, ub = power_bounds[i]\n        if total_max - ub >= current_load:\n            committed.remove(i)\n            total_min -= lb\n            total_max -= ub\n            del power_bounds[i]\n    \n    # Calculate final power bounds for dispatch\n    lb_arr = []\n    ub_arr = []\n    committed_list = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        # Update bounds to reflect any ramp changes\n        power_bounds[i] = (lb, ub)\n        lb_arr.append(lb)\n        ub_arr.append(ub)\n        committed_list.append(i)\n    \n    # Initialize outputs\n    p_outputs = np.zeros(n_units)\n    u_outputs = np.zeros(n_units)\n    \n    # Handle boundary cases\n    if current_load <= total_min:\n        for i in committed:\n            p_outputs[i] = power_bounds[i][0]\n            u_outputs[i] = 1\n        return np.array([u_outputs, p_outputs])\n        \n    if current_load >= total_max:\n        for i in committed:\n            p_outputs[i] = power_bounds[i][1]\n            u_outputs[i] = 1\n        return np.array([u_outputs, p_outputs])\n    \n    # Dispatch using accelerated lambda iteration\n    n_committed = len(committed_list)\n    p_current = np.array([(lb_arr[i] + ub_arr[i])/2 for i in range(n_committed)])\n    total_gen = sum(p_current)\n    lambda_val = 0.0\n    iteration = 0\n    max_iter = 50\n    \n    while abs(total_gen - current_load) > 1e-5 and iteration < max_iter:\n        derivative = 0.0\n        dp_dlambda = 0.0\n        total_gen = 0.0\n        \n        # Calculate total generation and derivative\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            lb, ub = power_bounds[i]\n            marginal = b + 2*c*p_current[idx]\n            derivative += marginal\n            if c == 0:  # Linear cost\n                dp_dlambda += 0.0\n            else:\n                # Derivative of generation w.r.t. lambda\n                if lb < (lambda_val - b)/(2*c) < ub:\n                    dp_dlambda += 1/(2*c)\n            total_gen += p_current[idx]\n        \n        # Newton step adjustment with projection\n        if dp_dlambda > 1e-10: \n            lambda_step = (current_load - total_gen) / dp_dlambda\n            lambda_val += lambda_step\n        else:  # Bisection fallback\n            lambda_val = derivative / n_committed\n        \n        # Update generation based on new lambda\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            b, c = unit['b_i'], unit['c_i']\n            lb, ub = power_bounds[i]\n            if c == 0:  # Linear cost\n                p_current[idx] = ub if lambda_val > b else lb\n            else:\n                opt_p = (lambda_val - b) / (2*c)\n                p_current[idx] = max(lb, min(ub, opt_p))\n        \n        iteration += 1\n        total_gen = sum(p_current)\n    \n    # Final residual adjustment\n    residual = current_load - total_gen\n    if abs(residual) > 1e-5:\n        headrooms = []\n        for idx, i in enumerate(committed_list):\n            lb, ub = power_bounds[i]\n            if residual > 0:  # Under-generation\n                headroom = ub - p_current[idx]\n            else:  # Over-generation\n                headroom = p_current[idx] - lb\n            headrooms.append(headroom)\n        \n        total_headroom = sum(headrooms)\n        if total_headroom > 1e-5:\n            adjustments = residual * np.array(headrooms) / total_headroom\n            for idx in range(n_committed):\n                p_current[idx] += adjustments[idx]\n    \n    # Update outputs\n    for idx, i in enumerate(committed_list):\n        p_outputs[i] = max(power_bounds[i][0], min(power_bounds[i][1], p_current[idx]))\n        u_outputs[i] = 1\n    \n    return np.array([u_outputs, p_outputs])",
          "from": "mutation",
          "gap_power_rate": 0.0050339678,
          "gap_price_rate": 0.0094502514,
          "fitness": 0.0072421096
     },
     {
          "name": "commit_units_by_amortized_cost",
          "algorithm": "1. Classify units into forced-on (must remain on due to min up-time/shutdown constraints), forced-off (min downtime), free online (currently on but adjustable), and free offline (currently off but available).\n2. Calculate cost rates for free units:\n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate list sorted by cost rates: forced-on first, then free units by ascending cost.\n4. Build committed set by adding candidates until total max capacity \u2265 load:\n   - Free online: min/max = max(p_min_i, p_i_0-p_down_i) to min(p_max_i, p_i_0+p_up_i)\n   - Free offline: min/max = p_min_i to min(p_max_i, p_start_i)\n5. Set non-committed units to u_i=0, p_i=0.\n6. Perform constrained economic dispatch for committed units:\n   - Determine feasible power bounds considering ramp constraints\n   - Use lambda iteration to find optimal dispatch minimizing cost\n   - Adjust outputs to exactly match load\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef commit_units_by_amortized_cost(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Currently online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Currently offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost rates for free units\n    cost_rates = {}\n    for i in free_online:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        cost_rates[i] = (unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    for i in free_offline:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_rates[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    # Form sorted candidate list\n    candidate_list = forced_on[:]\n    candidate_list.extend(sorted(free_online + free_offline, key=lambda i: cost_rates.get(i, 0)))\n    \n    # Build committed set\n    committed = set()\n    total_min = 0.0\n    total_max = 0.0\n    unit_bounds = {}\n    \n    for i in forced_on:  # Add forced-on units\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    for i in candidate_list:  # Add candidates until sufficient capacity\n        if i in forced_on:\n            continue  # Already added\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[i]\n        if i in free_online:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    # Set non-committed units to offline\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            u[i] = 1\n    \n    # Handle extreme load cases\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = unit_bounds[i][0]\n        return np.array([u, p])\n    \n    if current_load >= total_max:\n        for i in committed:\n            p[i] = unit_bounds[i][1]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_bounds = np.array([unit_bounds[i][0] for i in range(n_units) if i in committed])\n    high_bounds = np.array([unit_bounds[i][1] for i in range(n_units) if i in committed])\n    b = np.array([units_info[i]['b_i'] for i in range(n_units) if i in committed])\n    c = np.array([units_info[i]['c_i'] for i in range(n_units) if i in committed])\n    \n    lambda_low = min(b + 2 * c * low_bounds)\n    lambda_high = max(b + 2 * c * high_bounds)\n    tolerance = 1e-5\n    max_iter = 100\n    iter_count = 0\n    n_committed = len(low_bounds)\n    p_dispatch = np.copy(low_bounds)\n    \n    while iter_count < max_iter:\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        total_power = 0.0\n        \n        # Calculate optimal unconstrained dispatch\n        for i in range(n_committed):\n            p_opt = (lambda_mid - b[i]) / (2 * c[i])\n            p_dispatch[i] = np.clip(p_opt, low_bounds[i], high_bounds[i])\n        \n        total_power = np.sum(p_dispatch)\n        \n        # Check convergence\n        if abs(total_power - current_load) <= tolerance:\n            break\n            \n        # Adjust lambda\n        if total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        iter_count += 1\n    \n    # Assign dispatched values to committed units\n    dispatch_idx = 0\n    for i in range(n_units):\n        if i in committed:\n            p[i] = p_dispatch[dispatch_idx]\n            dispatch_idx += 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055425116,
          "gap_price_rate": 0.0089835115,
          "fitness": 0.0072630116
     },
     {
          "name": "enhanced_amortized_commitment_dispatch",
          "algorithm": "**  \n1. Classify units into forced-on (must remain on due to minimum up-time or shutdown ramp constraints), forced-off (must remain off due to minimum down-time), free online (adjustable units currently online), and free offline (adjustable units currently offline).  \n2. Calculate amortized cost metrics for free units:  \n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i  \n   - Free offline: (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i  \n3. Build candidate list: forced-on first, then free units sorted by ascending cost metric.  \n4. Form committed set:  \n   - Initialize with forced-on units.  \n   - Add free units in cost order until total max capacity \u2265 load.  \n   - If total min capacity > load, remove expensive free units (descending cost) while maintaining max capacity \u2265 load.  \n5. Calculate feasible power bounds for committed units:  \n   - Previously online: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)  \n   - Newly started: min = p_min_i, max = min(p_max_i, p_start_i)  \n6. Dispatch load:  \n   - If load \u2264 total min, set all outputs to min.  \n   - If load \u2265 total max, set all outputs to max.  \n   - Else, use lambda iteration (bisection) to find optimal dispatch within bounds.  \n7. Set non-committed units to off state (u_i = 0, p_i = 0).  \n8. Return schedules as a 2D NumPy array.  \n\n**",
          "code": "import numpy as np\n\ndef enhanced_amortized_commitment_dispatch(units_info, load):\n    load_current = load[0]\n    n_units = len(units_info)\n    u_output = [0] * n_units\n    p_output = [0.0] * n_units\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    candidate_list = []\n    for i in free_online:\n        unit = units_info[i]\n        a, b, c, p_min = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i']\n        cost_metric = (a + b * p_min + c * p_min**2) / p_min\n        candidate_list.append((i, cost_metric))\n    \n    for i in free_offline:\n        unit = units_info[i]\n        a, b, c, p_min, s, t_up = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i'], unit['s_i'], unit['t_on_min_i']\n        cost_metric = (s / t_up + a + b * p_min + c * p_min**2) / p_min\n        candidate_list.append((i, cost_metric))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed_set = set(forced_on)\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in forced_on:\n        unit = units_info[i]\n        p_min, p_max, p_i0, p_down, p_up = unit['p_min_i'], unit['p_max_i'], unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n        min_i = max(p_min, p_i0 - p_down)\n        max_i = min(p_max, p_i0 + p_up)\n        total_min += min_i\n        total_max += max_i\n    \n    free_committed = []\n    for i, _ in candidate_list:\n        if total_max >= load_current:\n            break\n        unit = units_info[i]\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        if i in free_online:\n            p_i0, p_down, p_up = unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n            min_i = max(p_min, p_i0 - p_down)\n            max_i = min(p_max, p_i0 + p_up)\n        else:\n            min_i = p_min\n            max_i = min(p_max, unit['p_start_i'])\n        \n        committed_set.add(i)\n        free_committed.append(i)\n        total_min += min_i\n        total_max += max_i\n    \n    if total_min > load_current and free_committed:\n        free_cost_map = {idx: cm for idx, cm in candidate_list}\n        free_committed.sort(key=lambda i: free_cost_map[i], reverse=True)\n        \n        for i in free_committed[:]:\n            if total_min <= load_current:\n                break\n            unit = units_info[i]\n            p_min, p_max = unit['p_min_i'], unit['p_max_i']\n            if i in free_online:\n                p_i0, p_down, p_up = unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n                min_i = max(p_min, p_i0 - p_down)\n                max_i = min(p_max, p_i0 + p_up)\n            else:\n                min_i = p_min\n                max_i = min(p_max, unit['p_start_i'])\n            \n            if (total_max - max_i) >= load_current:\n                committed_set.remove(i)\n                free_committed.remove(i)\n                total_min -= min_i\n                total_max -= max_i\n                if total_min <= load_current:\n                    break\n    \n    dispatch_data = []\n    for i in committed_set:\n        u_output[i] = 1\n        unit = units_info[i]\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        if i in forced_on or i in free_online:\n            p_i0, p_down, p_up = unit['p_i_0'], unit['p_down_i'], unit['p_up_i']\n            min_i = max(p_min, p_i0 - p_down)\n            max_i = min(p_max, p_i0 + p_up)\n        else:\n            min_i = p_min\n            max_i = min(p_max, unit['p_start_i'])\n        dispatch_data.append((i, min_i, max_i, unit['b_i'], unit['c_i']))\n    \n    if dispatch_data:\n        total_min_dispatch = sum(min_i for _, min_i, _, _, _ in dispatch_data)\n        total_max_dispatch = sum(max_i for _, _, max_i, _, _ in dispatch_data)\n        \n        if load_current <= total_min_dispatch:\n            for i, min_i, _, _, _ in dispatch_data:\n                p_output[i] = min_i\n        elif load_current >= total_max_dispatch:\n            for i, _, max_i, _, _ in dispatch_data:\n                p_output[i] = max_i\n        else:\n            low = 0\n            high = 0\n            for _, min_i, max_i, b_i, c_i in dispatch_data:\n                if c_i == 0:\n                    low_i = high_i = b_i\n                else:\n                    low_i = b_i + 2 * c_i * min_i\n                    high_i = b_i + 2 * c_i * max_i\n                if low_i < low: low = low_i\n                if high_i > high: high = high_i\n            \n            tolerance = 1e-5\n            max_iter = 1000\n            for _ in range(max_iter):\n                mid = (low + high) / 2\n                total_p = 0.0\n                for _, min_i, max_i, b_i, c_i in dispatch_data:\n                    if c_i == 0:\n                        p_i = min_i if mid < b_i else max_i\n                    else:\n                        p_i = (mid - b_i) / (2 * c_i)\n                        p_i = max(min_i, min(p_i, max_i))\n                    total_p += p_i\n                if abs(total_p - load_current) < tolerance:\n                    break\n                if total_p < load_current:\n                    low = mid\n                else:\n                    high = mid\n            \n            for i, min_i, max_i, b_i, c_i in dispatch_data:\n                if c_i == 0:\n                    p_i = min_i if mid < b_i else max_i\n                else:\n                    p_i = (mid - b_i) / (2 * c_i)\n                    p_i = max(min_i, min(p_i, max_i))\n                p_output[i] = p_i\n    \n    schedules = np.array([u_output, p_output], dtype=float)\n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.0055425116,
          "gap_price_rate": 0.008983512,
          "fitness": 0.0072630118
     },
     {
          "name": "enhanced_combined_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min up-time/shutdown constraint active), forced-off (min down-time constraint active), free online (adjustable and currently on), and free offline (adjustable and currently off).\n2. Calculate cost metrics for free units:\n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate list: forced-on + free units sorted by cost metric (free online first when costs equal).\n4. Build committed set by adding units in cost-ascending order until max capacity \u2265 load (considering ramp/startup constraints).\n5. Refine committed set:\n   - Calculate total min/max capacity\n   - While total_min > load and removal won't violate max capacity \u2265 load, remove most expensive free unit\n   - Prioritize free online units in removal to reduce commitment volatility\n6. Set power bounds for committed units:\n   - Previously online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Newly started: [p_min_i, min(p_max_i, p_start_i)]\n7. Dispatch load across committed units:\n   - If load \u2264 total_min: set all to min outputs\n   - Else if load \u2265 total_max: set all to max outputs\n   - Else: use bisection method for lambda iteration to find optimal dispatch\n   - Handle linear cost cases (c_i=0) during dispatch\n8. Set non-committed units to off (u_i=0, p_i=0)\n9. Return schedules as 2D NumPy array\n\n",
          "code": "import numpy as np\n\ndef enhanced_combined_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    cost_metric = [0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if t_i0 > -t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Step 2: Compute cost metrics\n    for i in free_online + free_offline:\n        unit = units_info[i]\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min = unit['p_min_i']\n        s = unit['s_i']\n        t_on_min = unit['t_on_min_i']\n        \n        base_cost = a + b * p_min + c * p_min ** 2\n        if i in free_offline:\n            cost_metric[i] = (s / t_on_min + base_cost) / p_min\n        else:\n            cost_metric[i] = base_cost / p_min\n    \n    # Build candidate list (free online before free offline when costs equal)\n    candidate_list = free_online + free_offline\n    candidate_list.sort(key=lambda i: (cost_metric[i], i not in free_online))\n    \n    # Initialize committed set\n    committed = set(forced_on)\n    total_min, total_max = 0.0, 0.0\n    \n    # Calculate initial capacity for forced-on units\n    for i in forced_on:\n        unit = units_info[i]\n        ramp_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += ramp_min\n        total_max += ramp_max\n    \n    # Precalculate min/max for candidates\n    candidate_capacity = {}\n    for i in candidate_list:\n        unit = units_info[i]\n        if i in free_online:\n            ramp_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ramp_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ramp_min = unit['p_min_i']\n            ramp_max = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_capacity[i] = (ramp_min, ramp_max)\n    \n    # Step 4: Build committed set\n    for i in candidate_list:\n        if total_max < current_load:\n            ramp_min, ramp_max = candidate_capacity[i]\n            committed.add(i)\n            total_min += ramp_min\n            total_max += ramp_max\n    \n    # Step 5: Refine committed set\n    free_in_commit = [i for i in committed if i in free_online or i in free_offline]\n    # Prefer removing free_online units first when costs are equal\n    free_in_commit.sort(key=lambda i: (-cost_metric[i], i in free_online))\n    \n    for i in free_in_commit:\n        if total_min > current_load:\n            ramp_min, ramp_max = candidate_capacity[i]\n            new_min = total_min - ramp_min\n            new_max = total_max - ramp_max\n            if new_max >= current_load:\n                committed.remove(i)\n                total_min, total_max = new_min, new_max\n    \n    # Initialize schedules\n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    low_bounds, high_bounds = [], []\n    cost_coeffs = []\n    comm_indices = []\n    \n    # Prepare data for dispatch\n    for i in committed:\n        u_schedule[i] = 1\n        unit = units_info[i]\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        cost_coeffs.append((a, b, c))\n        comm_indices.append(i)\n        \n        if unit['u_i_0'] == 1:  # Was online\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Newly started\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        \n        low_bounds.append(low)\n        high_bounds.append(high)\n    \n    # Step 7: Dispatch\n    if comm_indices:\n        total_low = sum(low_bounds)\n        total_high = sum(high_bounds)\n        \n        if current_load <= total_low:\n            for idx, i in enumerate(comm_indices):\n                p_schedule[i] = low_bounds[idx]\n        elif current_load >= total_high:\n            for idx, i in enumerate(comm_indices):\n                p_schedule[i] = high_bounds[idx]\n        else:\n            # Lambda iteration using bisection\n            mc_min = min(b + 2 * c * low for (_, b, c), low in zip(cost_coeffs, low_bounds))\n            mc_max = max(b + 2 * c * high for (_, b, c), high in zip(cost_coeffs, high_bounds))\n            lam_low, lam_high = mc_min, mc_max\n            tol = 1e-5\n            max_iter = 1000\n            iter_count = 0\n            \n            while iter_count < max_iter and abs(lam_high - lam_low) > tol:\n                lam_mid = (lam_low + lam_high) / 2\n                total_power = 0.0\n                \n                for idx, (_, b, c) in enumerate(cost_coeffs):\n                    low = low_bounds[idx]\n                    high = high_bounds[idx]\n                    \n                    if c == 0:  # Linear cost case\n                        p_i = high if lam_mid > b else low\n                    else:\n                        p_opt = (lam_mid - b) / (2 * c)\n                        p_i = max(low, min(high, p_opt))\n                    \n                    total_power += p_i\n                \n                if total_power < current_load:\n                    lam_low = lam_mid\n                else:\n                    lam_high = lam_mid\n                \n                iter_count += 1\n            \n            # Assign final outputs\n            for idx, (_, b, c) in enumerate(cost_coeffs):\n                low = low_bounds[idx]\n                high = high_bounds[idx]\n                i = comm_indices[idx]\n                \n                if c == 0:\n                    p_schedule[i] = high if lam_low > b else low\n                else:\n                    p_opt = (lam_low - b) / (2 * c)\n                    p_schedule[i] = max(low, min(high, p_opt))\n    \n    return np.array([u_schedule, p_schedule], dtype=np.float64)",
          "from": "crossover",
          "gap_power_rate": 0.0055428586,
          "gap_price_rate": 0.0089832655,
          "fitness": 0.0072630621
     },
     {
          "name": "combined_amortized_dispatch",
          "algorithm": "1. Classify units into forced-on (min up-time/shutdown constraints), forced-off (min down-time), free online (adjustable and online), and free offline (adjustable and offline).  \n2. Calculate cost metrics for free units: (operating cost at min power for free online; startup cost amortized over min up-time plus operating cost at min power for free offline).  \n3. Build initial commitment set: forced-on units + free units sorted by cost metric.  \n4. While total ramp-constrained max capacity < current load: add next cheapest free unit.  \n5. While total ramp-constrained min capacity > load: remove most expensive free unit while maintaining max capacity \u2265 load.  \n6. For committed units: calculate feasible power bounds considering ramp limits (previously online: min = max(p_min, prev - ramp_down), max = min(p_max, prev + ramp_up); newly started: min = p_min, max = min(p_max, p_start)).  \n7. Dispatch using lambda iteration:  \n   a) If load \u2264 total min, set outputs to min.  \n   b) If load \u2265 total max, set outputs to max.  \n   c) Else: optimize via bisection on incremental cost, then residual adjustment.  \n8. Set non-committed units to off (u_i=0, p_i=0).  \n\n",
          "code": "import numpy as np  \n\ndef combined_amortized_dispatch(units_info, load):  \n    n_units = len(units_info)  \n    u_out = np.zeros(n_units, dtype=int)  \n    p_out = np.zeros(n_units)  \n    cost_metric = np.zeros(n_units)  \n    current_load = load[0]  \n      \n    forced_on = []  \n    forced_off = []  \n    free_online = []  \n    free_offline = []  \n      \n    # Step 1: Classify units  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):  \n                forced_on.append(i)  \n            else:  \n                free_online.append(i)  \n        else:  \n            if abs(unit['t_i_0']) < unit['t_off_min_i']:  \n                forced_off.append(i)  \n            else:  \n                free_offline.append(i)  \n      \n    # Step 2: Precompute cost metrics  \n    for i in free_online:  \n        unit = units_info[i]  \n        op_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2  \n        cost_metric[i] = op_cost / unit['p_min_i']  \n          \n    for i in free_offline:  \n        unit = units_info[i]  \n        startup_amortized = unit['s_i'] / unit['t_on_min_i']  \n        op_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2  \n        cost_metric[i] = (startup_amortized + op_cost) / unit['p_min_i']  \n      \n    # Step 3 & 4: Build initial commitment  \n    candidate_list = forced_on.copy()  \n    candidate_list += sorted(free_online + free_offline, key=lambda i: cost_metric[i])  \n    committed_set = set(forced_on)  \n      \n    total_max = 0.0  \n    for i in forced_on:  \n        unit = units_info[i]  \n        max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        total_max += max_p_i  \n          \n    for i in candidate_list[len(forced_on):]:  \n        if total_max >= current_load:  \n            break  \n        unit = units_info[i]  \n        if i in free_online:  \n            max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  \n            max_p_i = min(unit['p_max_i'], unit['p_start_i'])  \n        total_max += max_p_i  \n        committed_set.add(i)  \n      \n    # Step 5: Removal of expensive units  \n    min_ps_committed = {}  \n    max_ps_committed = {}  \n    total_min = 0.0  \n    for i in committed_set:  \n        unit = units_info[i]  \n        if i in free_online or i in forced_on:  \n            min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        else:  \n            min_p_i = unit['p_min_i']  \n        min_ps_committed[i] = min_p_i  \n        total_min += min_p_i  \n          \n    free_in_committed = sorted(  \n        [i for i in committed_set if i in free_online or i in free_offline],  \n        key=lambda i: cost_metric[i],  \n        reverse=True  \n    )  \n      \n    if total_min > current_load:  \n        for i in free_in_committed:  \n            candidate_set = committed_set - {i}  \n            candidate_total_min = total_min - min_ps_committed[i]  \n            candidate_total_max = total_max  \n            unit = units_info[i]  \n              \n            if i in free_online:  \n                candidate_total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n            else:  \n                candidate_total_max -= min(unit['p_max_i'], unit['p_start_i'])  \n                  \n            if candidate_total_min <= current_load and candidate_total_max >= current_load:  \n                committed_set = candidate_set  \n                total_min = candidate_total_min  \n                total_max = candidate_total_max  \n                if total_min <= current_load:  \n                    break  \n      \n    # Step 6: Set states and compute bounds  \n    min_ps, max_ps = {}, {}  \n    for i in committed_set:  \n        u_out[i] = 1  \n        unit = units_info[i]  \n        if unit['u_i_0'] == 1:  \n            min_ps[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            max_ps[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  \n            min_ps[i] = unit['p_min_i']  \n            max_ps[i] = min(unit['p_max_i'], unit['p_start_i'])  \n      \n    # Step 7: Dispatch  \n    total_min = sum(min_ps.values())  \n    total_max = sum(max_ps.values())  \n      \n    if current_load <= total_min:  \n        for i in committed_set:  \n            p_out[i] = min_ps[i]  \n    elif current_load >= total_max:  \n        for i in committed_set:  \n            p_out[i] = max_ps[i]  \n    else:  \n        indices = list(committed_set)  \n        b_vals = [units_info[i]['b_i'] for i in indices]  \n        c_vals = [units_info[i]['c_i'] for i in indices]  \n        min_vals = [min_ps[i] for i in indices]  \n        max_vals = [max_ps[i] for i in indices]  \n          \n        lambda_low = 0  \n        lambda_high = 1e6  \n        tolerance = 1e-3  \n          \n        for _ in range(100):  \n            lambda_mid = (lambda_low + lambda_high) / 2  \n            total_p = 0  \n            for idx, i in enumerate(indices):  \n                p_clamp = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx]) if c_vals[idx] > 0 else 0  \n                p_i = np.clip(p_clamp, min_vals[idx], max_vals[idx])  \n                total_p += p_i  \n              \n            if total_p < current_load:  \n                lambda_low = lambda_mid  \n            else:  \n                lambda_high = lambda_mid  \n              \n            if abs(total_p - current_load) < tolerance:  \n                break  \n          \n        # Set power outputs from lambda iteration  \n        for idx, i in enumerate(indices):  \n            p_clamp = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx]) if c_vals[idx] > 0 else 0  \n            p_out[i] = np.clip(p_clamp, min_vals[idx], max_vals[idx])  \n          \n        # Residual adjustment  \n        residual = current_load - np.sum(p_out[i] for i in committed_set)  \n        if abs(residual) > 1e-3:  \n            if residual > 0:  \n                candidates = []  \n                for i in committed_set:  \n                    if p_out[i] < max_ps[i]:  \n                        ic = b_vals[idx] + 2 * c_vals[idx] * p_out[i]  \n                        candidates.append((ic, i))  \n                candidates.sort()  \n            else:  \n                candidates = []  \n                for i in committed_set:  \n                    if p_out[i] > min_ps[i]:  \n                        ic = b_vals[idx] + 2 * c_vals[idx] * p_out[i]  \n                        candidates.append((ic, i))  \n                candidates.sort(reverse=True)  \n              \n            residual_remaining = abs(residual)  \n            for _, i in candidates:  \n                if residual_remaining <= 0:  \n                    break  \n                max_increase = max_ps[i] - p_out[i]  \n                max_decrease = p_out[i] - min_ps[i]  \n                delta = min(residual_remaining, max_increase if residual>0 else max_decrease)  \n                p_out[i] += delta if residual>0 else -delta  \n                residual_remaining -= delta  \n      \n    # Return schedule  \n    return np.array([u_out, p_out])  ",
          "from": "crossover",
          "gap_power_rate": 0.0055426359,
          "gap_price_rate": 0.0089835216,
          "fitness": 0.0072630788
     }
]