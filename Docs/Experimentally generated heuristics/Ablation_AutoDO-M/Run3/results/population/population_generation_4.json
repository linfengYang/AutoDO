[
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "commit_units_by_amortized_cost",
          "algorithm": "1. Classify units into forced-on (must remain on due to min up-time/shutdown constraints), forced-off (min downtime), free online (currently on but adjustable), and free offline (currently off but available).\n2. Calculate cost rates for free units:\n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate list sorted by cost rates: forced-on first, then free units by ascending cost.\n4. Build committed set by adding candidates until total max capacity \u2265 load:\n   - Free online: min/max = max(p_min_i, p_i_0-p_down_i) to min(p_max_i, p_i_0+p_up_i)\n   - Free offline: min/max = p_min_i to min(p_max_i, p_start_i)\n5. Set non-committed units to u_i=0, p_i=0.\n6. Perform constrained economic dispatch for committed units:\n   - Determine feasible power bounds considering ramp constraints\n   - Use lambda iteration to find optimal dispatch minimizing cost\n   - Adjust outputs to exactly match load\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef commit_units_by_amortized_cost(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Currently online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Currently offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost rates for free units\n    cost_rates = {}\n    for i in free_online:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        cost_rates[i] = (unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    for i in free_offline:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_rates[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    # Form sorted candidate list\n    candidate_list = forced_on[:]\n    candidate_list.extend(sorted(free_online + free_offline, key=lambda i: cost_rates.get(i, 0)))\n    \n    # Build committed set\n    committed = set()\n    total_min = 0.0\n    total_max = 0.0\n    unit_bounds = {}\n    \n    for i in forced_on:  # Add forced-on units\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    for i in candidate_list:  # Add candidates until sufficient capacity\n        if i in forced_on:\n            continue  # Already added\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[i]\n        if i in free_online:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    # Set non-committed units to offline\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            u[i] = 1\n    \n    # Handle extreme load cases\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = unit_bounds[i][0]\n        return np.array([u, p])\n    \n    if current_load >= total_max:\n        for i in committed:\n            p[i] = unit_bounds[i][1]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_bounds = np.array([unit_bounds[i][0] for i in range(n_units) if i in committed])\n    high_bounds = np.array([unit_bounds[i][1] for i in range(n_units) if i in committed])\n    b = np.array([units_info[i]['b_i'] for i in range(n_units) if i in committed])\n    c = np.array([units_info[i]['c_i'] for i in range(n_units) if i in committed])\n    \n    lambda_low = min(b + 2 * c * low_bounds)\n    lambda_high = max(b + 2 * c * high_bounds)\n    tolerance = 1e-5\n    max_iter = 100\n    iter_count = 0\n    n_committed = len(low_bounds)\n    p_dispatch = np.copy(low_bounds)\n    \n    while iter_count < max_iter:\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        total_power = 0.0\n        \n        # Calculate optimal unconstrained dispatch\n        for i in range(n_committed):\n            p_opt = (lambda_mid - b[i]) / (2 * c[i])\n            p_dispatch[i] = np.clip(p_opt, low_bounds[i], high_bounds[i])\n        \n        total_power = np.sum(p_dispatch)\n        \n        # Check convergence\n        if abs(total_power - current_load) <= tolerance:\n            break\n            \n        # Adjust lambda\n        if total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        iter_count += 1\n    \n    # Assign dispatched values to committed units\n    dispatch_idx = 0\n    for i in range(n_units):\n        if i in committed:\n            p[i] = p_dispatch[dispatch_idx]\n            dispatch_idx += 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055425116,
          "gap_price_rate": 0.0089835115,
          "fitness": 0.0072630116
     },
     {
          "name": "combined_priority_amortized_heuristic",
          "algorithm": "1. Classify units into forced-on (must run due to min up-time or shutdown ramp constraints), forced-off (min down-time constraint), free online (adjustable but currently on), and free offline (adjustable but currently off).\n2. Calculate cost metrics for free units:\n   - Free online: (a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n3. Create candidate list: forced-on + free online + free offline, sorted by cost metric.\n4. Build committed set by adding candidates in cost-ascending order until max capacity meets load.\n5. If total min capacity exceeds load, remove expensive free units (descending cost order) while maintaining feasibility and max capacity constraint.\n6. Calculate power bounds for committed units:\n   - Previously online: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   - Newly started: min = p_min_i, max = min(p_max_i, p_start_i)\n7. Dispatch load using lambda iteration within power bounds:\n   - Handle boundary cases: set all to min/max when load outside feasible range\n   - Bisection search for optimal lambda (marginal cost)\n8. Return schedules (commitment states and power outputs) as NumPy array.\n\n",
          "code": "import numpy as np\n\ndef combined_priority_amortized_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    states = np.zeros(n_units)\n    powers = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > p_shut:\n                forced_on.append((i, unit))\n            else:\n                free_online.append((i, unit))\n        else:\n            if t_i_0 < 0 and -t_i_0 < t_off_min:\n                forced_off.append((i, unit))\n            else:\n                free_offline.append((i, unit))\n    \n    # Calculate cost metrics\n    cost_metrics = []\n    for idx, unit in free_online:\n        a, b, c, p_min = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i']\n        metric = (a + b * p_min + c * p_min**2) / p_min\n        cost_metrics.append((idx, unit, metric, 'online'))\n    \n    for idx, unit in free_offline:\n        a, b, c, s, p_min, t_on_min = unit['a_i'], unit['b_i'], unit['c_i'], unit['s_i'], unit['p_min_i'], unit['t_on_min_i']\n        metric = (s / max(1, t_on_min) + a + b * p_min + c * p_min**2) / p_min\n        cost_metrics.append((idx, unit, metric, 'offline'))\n    \n    cost_metrics.sort(key=lambda x: x[2])\n    \n    committed_set = [fu for fu in forced_on]\n    max_capacity = 0.0\n    min_capacity = 0.0\n    \n    for idx, unit in forced_on:\n        p_i_0 = unit['p_i_0']\n        max_cap = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        min_cap = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n        max_capacity += max_cap\n        min_capacity += min_cap\n    \n    candidates_to_add = []\n    for cm in cost_metrics:\n        idx, unit, metric, utype = cm\n        if utype == 'online':\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n            min_cap = unit['p_min_i']\n        candidates_to_add.append((idx, unit, min_cap, max_cap, metric))\n        if max_capacity >= current_load:\n            break\n        max_capacity += max_cap\n        min_capacity += min_cap\n        committed_set.append((idx, unit))\n    \n    if min_capacity > current_load:\n        candidates_to_remove = sorted(\n            [(idx, unit, min_cap, max_cap, metric) for (idx, unit, min_cap, max_cap, metric) in candidates_to_add],\n            key=lambda x: x[4], reverse=True\n        )\n        for cand in candidates_to_remove:\n            idx, unit, min_cap, max_cap, _ = cand\n            if min_capacity - min_cap <= current_load and max_capacity - max_cap >= current_load:\n                min_capacity -= min_cap\n                max_capacity -= max_cap\n                committed_set = [c for c in committed_set if c[0] != idx]\n                if min_capacity <= current_load:\n                    break\n    \n    # Calculate power bounds for dispatch\n    units_dispatch = []\n    bounds = []\n    for idx, unit in committed_set:\n        if unit['u_i_0'] == 1:\n            p_i_0 = unit['p_i_0']\n            p_min = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        units_dispatch.append(unit)\n        bounds.append((p_min, p_max))\n    \n    # Handle boundary cases\n    total_min = sum(p_min for p_min, _ in bounds)\n    total_max = sum(p_max for _, p_max in bounds)\n    \n    dispatch_powers = []\n    if current_load <= total_min:\n        dispatch_powers = [p_min for p_min, _ in bounds]\n    elif current_load >= total_max:\n        dispatch_powers = [p_max for _, p_max in bounds]\n    else:\n        lo = min(u['b_i'] + 2*u['c_i']*b[0] for u, b in zip(units_dispatch, bounds))\n        hi = max(u['b_i'] + 2*u['c_i']*b[1] for u, b in zip(units_dispatch, bounds))\n        tol = 1e-5\n        while hi - lo > tol:\n            lam = (lo + hi) / 2\n            total_power = 0\n            for i, (unit, (p_min, p_max)) in enumerate(zip(units_dispatch, bounds)):\n                b_i, c_i = unit['b_i'], unit['c_i']\n                p_i = (lam - b_i) / (2 * c_i)\n                p_i = max(p_min, min(p_i, p_max))\n                total_power += p_i\n            if total_power < current_load:\n                lo = lam\n            else:\n                hi = lam\n        lam_final = (lo + hi) / 2\n        for i, (unit, (p_min, p_max)) in enumerate(zip(units_dispatch, bounds)):\n            b_i, c_i = unit['b_i'], unit['c_i']\n            p_i = (lam_final - b_i) / (2 * c_i)\n            p_i = max(p_min, min(p_i, p_max))\n            dispatch_powers.append(p_i)\n    \n    # Prepare output arrays\n    for i, (idx, unit) in enumerate(committed_set):\n        states[idx] = 1\n        powers[idx] = dispatch_powers[i]\n    \n    for idx, _ in forced_off:\n        states[idx] = 0\n        powers[idx] = 0\n    \n    # Handle units not included in any set\n    handled_indices = {idx for idx, _ in committed_set} | {idx for idx, _ in forced_off}\n    for i in range(n_units):\n        if i not in handled_indices:\n            states[i] = 0\n            powers[i] = 0\n\n    return np.array([states, powers])",
          "from": "crossover",
          "gap_power_rate": 0.0055427484,
          "gap_price_rate": 0.0089835035,
          "fitness": 0.0072631259
     },
     {
          "name": "combined_priority_dispatch",
          "algorithm": "1. Determine forced commitment states: must-on units (cannot be turned off due to minimum up-time or shutdown ramp constraints), must-off units (cannot be started due to minimum down-time), and free units.\n2. Initialize on_set with must-on units and free units currently online.\n3. Calculate total min and max output capacity of current on_set, considering ramp constraints and startup limits.\n4. If max capacity < current load, activate free offline units sorted by ascending amortized startup cost until max capacity meets/exceeds load.\n5. If min capacity > current load, deactivate non-essential free units sorted by descending operating cost at min power until min capacity <= load.\n6. Compute feasible power bounds for all committed units considering ramp constraints and startup/shutdown limits.\n7. Perform economic dispatch for committed units:\n   - If load below total min, set all outputs to min.\n   - If load above total max, set all outputs to max.\n   - Otherwise, use lambda iteration for optimal dispatch within bounds.\n8. Return schedule as a 2D array (commitment states, power outputs).\n\n",
          "code": "import numpy as np\n\ndef combined_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u_i = [0] * n\n    p_i = [0.0] * n\n    muston = [False] * n\n    mustoff = [False] * n\n    on_set = set()\n\n    # Determine forced states\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                muston[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                mustoff[i] = True\n\n    # Initialize on_set with must-on and free currently online units\n    for i in range(n):\n        if muston[i] or (not muston[i] and not mustoff[i] and units_info[i]['u_i_0'] == 1):\n            on_set.add(i)\n            u_i[i] = 1\n\n    # Calculate initial power bounds\n    def compute_bounds(i):\n        if units_info[i]['u_i_0'] == 1:\n            min_bound = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_bound = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            min_bound = units_info[i]['p_min_i']\n            max_bound = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        return min_bound, max_bound\n\n    # Turn on candidates if needed (Step 4)\n    free_off = [i for i in range(n) if not muston[i] and not mustoff[i] and units_info[i]['u_i_0'] == 0]\n    amortized_cost = [(i, (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / max(1, unit['p_min_i'])) \n                      for i, unit in enumerate(units_info) if i in free_off]\n    amortized_cost.sort(key=lambda x: x[1])\n    \n    total_min = 0\n    total_max = 0\n    for i in on_set:\n        min_b, max_b = compute_bounds(i)\n        total_min += min_b\n        total_max += max_b\n    \n    for i, _ in amortized_cost:\n        if total_max < current_load and i in free_off:\n            min_b, max_b = compute_bounds(i)\n            on_set.add(i)\n            u_i[i] = 1\n            total_min += min_b\n            total_max += max_b\n\n    # Turn off non-essential if needed (Step 5)\n    non_essential = [i for i in on_set if not muston[i] and units_info[i]['u_i_0'] == 1]\n    op_cost = [(i, units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n               units_info[i]['c_i']*units_info[i]['p_min_i']**2) \n              for i in non_essential]\n    op_cost.sort(key=lambda x: x[1], reverse=True)\n    \n    for i, _ in op_cost:\n        min_b, max_b = compute_bounds(i)\n        if total_min - min_b > current_load: \n            continue\n        if total_max - max_b >= current_load:\n            on_set.remove(i)\n            u_i[i] = 0\n            total_min -= min_b\n            total_max -= max_b\n\n    # Compute final bounds for dispatch\n    lo_arr = []\n    hi_arr = []\n    b_arr = []\n    c_arr = []\n    indices = []\n    for i in on_set:\n        min_b, max_b = compute_bounds(i)\n        lo_arr.append(min_b)\n        hi_arr.append(max_b)\n        b_arr.append(units_info[i]['b_i'])\n        c_arr.append(units_info[i]['c_i'])\n        indices.append(i)\n    total_min = sum(lo_arr)\n    total_max = sum(hi_arr)\n    n_on = len(indices)\n\n    # Dispatch power for committed units\n    if n_on > 0:\n        if current_load <= total_min:\n            for idx, i in enumerate(indices):\n                p_i[i] = lo_arr[idx]\n        elif current_load >= total_max:\n            for idx, i in enumerate(indices):\n                p_i[i] = hi_arr[idx]\n        else:\n            lambda_min = min(2 * c_arr[j] * lo_arr[j] + b_arr[j] for j in range(n_on))\n            lambda_max = max(2 * c_arr[j] * hi_arr[j] + b_arr[j] for j in range(n_on))\n            tol = 1e-5\n            iter_max = 100\n            for _ in range(iter_max):\n                lambda_mid = (lambda_min + lambda_max) / 2.0\n                total_p = 0.0\n                for j in range(n_on):\n                    if abs(c_arr[j]) < 1e-7:\n                        p_val = hi_arr[j] if b_arr[j] < lambda_mid else lo_arr[j]\n                    else:\n                        p_val = (lambda_mid - b_arr[j]) / (2 * c_arr[j])\n                        p_val = max(lo_arr[j], min(hi_arr[j], p_val))\n                    total_p += p_val\n                if abs(total_p - current_load) < tol:\n                    break\n                if total_p < current_load:\n                    lambda_min = lambda_mid\n                else:\n                    lambda_max = lambda_mid\n            for j, idx_unit in enumerate(indices):\n                if abs(c_arr[j]) < 1e-7:\n                    p_i[idx_unit] = hi_arr[j] if b_arr[j] < lambda_mid else lo_arr[j]\n                else:\n                    p_val = (lambda_mid - b_arr[j]) / (2 * c_arr[j])\n                    p_i[idx_unit] = max(lo_arr[j], min(hi_arr[j], p_val))\n\n    # Format output\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_i[i]\n        schedules[1, i] = p_i[i]\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091472115,
          "fitness": 0.0072878746
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Preprocess units to determine forced commitment states based on minimum up/down times, shutdown ramp limits, and previous state.\n2. Compute available capacity from initially committed units.\n3. Turn on additional candidate units (not forced off) based on two-period average incremental cost until available capacity meets or exceeds current load.\n4. Turn off non-essential candidate units (those not forced on) based on highest operating cost to minimize total cost.\n5. Perform economic dispatch using bisection method to allocate load to committed units, respecting ramp limits and power bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    \n    forced_committed = []\n    candidate_off = []\n    candidate_on = []\n    \n    # Step 1: Determine forced commitment and candidate units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_committed.append(idx)\n            else:\n                candidate_off.append(idx)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                continue\n            else:\n                candidate_on.append(idx)\n    \n    # Helper function to get available capacity\n    def get_available_capacity(unit_indices):\n        total = 0.0\n        for idx in unit_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total += min(unit['p_max_i'], unit['p_start_i'])\n        return total\n    \n    # Initially committed units (forced on and candidate_off)\n    committed_units = forced_committed + candidate_off\n    total_available = get_available_capacity(committed_units)\n    \n    # Step 2: Turn on candidate units if needed\n    candidate_on_info = []\n    for idx in candidate_on:\n        unit = units_info[idx]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        \n        cost_current = s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        cost_next = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        total_cost = cost_current + cost_next\n        power_two_periods = 2 * p_min_i\n        aic_per_mw = total_cost / power_two_periods\n        \n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidate_on_info.append((idx, aic_per_mw, avail))\n    \n    candidate_on_info.sort(key=lambda x: x[1])\n    \n    for idx, _, avail in candidate_on_info:\n        if total_available >= current_load:\n            break\n        total_available += avail\n        committed_units.append(idx)\n    \n    # Step 3: Turn off non-essential candidate_off units\n    candidate_off_info = []\n    for idx in candidate_off:\n        if idx not in committed_units:\n            continue\n        unit = units_info[idx]\n        min_power = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_off_info.append((idx, cost, avail))\n    \n    candidate_off_info.sort(key=lambda x: x[1], reverse=True)\n    \n    new_committed = list(committed_units)\n    total_available_new = total_available\n    for idx, _, avail in candidate_off_info:\n        if (total_available_new - avail) >= current_load:\n            total_available_new -= avail\n            new_committed.remove(idx)\n    committed_units = new_committed\n    \n    # Prepare schedules array\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    for idx in committed_units:\n        schedules[0, idx] = 1\n    \n    # Step 4: Economic Dispatch\n    unit_bounds = []\n    for idx in committed_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        unit_bounds.append((idx, low_bound, high_bound))\n    \n    low_total = sum(low for _, low, _ in unit_bounds)\n    high_total = sum(high for _, _, high in unit_bounds)\n    \n    # If load not feasible, use bounds\n    if current_load < low_total or current_load > high_total:\n        for idx, low, high in unit_bounds:\n            if current_load < low_total:\n                schedules[1, idx] = low\n            else:\n                schedules[1, idx] = high\n        return schedules\n    \n    # Dispatch parameters\n    dispatch_list = []\n    min_ic = float('inf')\n    max_ic = -float('inf')\n    \n    for idx, low, high in unit_bounds:\n        unit = units_info[idx]\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        ic_low = b_i + 2 * c_i * low\n        ic_high = b_i + 2 * c_i * high\n        min_ic = min(min_ic, ic_low)\n        max_ic = max(max_ic, ic_high)\n        dispatch_list.append((idx, b_i, c_i, low, high))\n    \n    # Lambda iteration\n    lambda_low = min_ic\n    lambda_high = max_ic\n    p_values = [low for _, _, _, low, _ in dispatch_list]\n    \n    if abs(high_total - low_total) > 1e-6:\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_power = 0.0\n            new_p_values = []\n            for idx, b_i, c_i, low, high in dispatch_list:\n                if c_i == 0:\n                    if lambda_mid < b_i:\n                        p_i = low\n                    else:\n                        p_i = high\n                else:\n                    p_i = (lambda_mid - b_i) / (2 * c_i)\n                    p_i = max(low, min(high, p_i))\n                new_p_values.append(p_i)\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                p_values = new_p_values\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            p_values = new_p_values\n    \n    # Assign dispatch results\n    for (idx, _, _, _, _), power in zip(dispatch_list, p_values):\n        schedules[1, idx] = power\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054685553,
          "gap_price_rate": 0.0092084548,
          "fitness": 0.0073385051
     },
     {
          "name": "enhanced_priority_dispatch",
          "algorithm": "1. Identify must-on units: units that must remain on due to minimum up-time constraint or previous output exceeding shutdown capacity.\n2. Identify must-off units: units that must remain off due to minimum down-time constraint.\n3. Initialize committed set with must-on units and free units previously online. Calculate min/max capacity considering ramp limits.\n4. If max capacity < current load, start additional free offline units sorted by adjusted cost per MW (including startup cost amortized over min output) until max capacity meets/exceeds load.\n5. If min capacity > current load, deactivate non-essential committed units sorted by descending operating cost at min output until min capacity \u2264 load.\n6. For each committed unit, compute power bounds considering:\n   - Previous units: ramp constraints from previous output\n   - Newly started units: startup ramp limits\n7. Perform economic dispatch:\n   a. If load \u2264 total min, set all outputs to min.\n   b. If load \u2265 total max, set all outputs to max.\n   c. Else, use lambda iteration with linear handling to distribute load optimally.\n8. Set non-committed units to off (u_i=0, p_i=0).\n9. Return schedules as 2D numpy array.\n\n",
          "code": "import numpy as np\n\ndef enhanced_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    \n    # Determine forced commitment states\n    must_on = []\n    must_off = []\n    free_units = list(range(n_units))\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n                free_units.remove(i)\n            else:\n                must_off.append(i)\n                free_units.remove(i)\n        else:  # Was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n                free_units.remove(i)\n    \n    # Initialize committed set\n    on_set = set(must_on)\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            on_set.add(i)\n    \n    # Calculate current capacity limits\n    def calculate_capacity(on_set):\n        total_min = 0.0\n        total_max = 0.0\n        min_i_vals = []\n        max_i_vals = []\n        \n        for i in on_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            min_i_vals.append(min_i)\n            max_i_vals.append(max_i)\n            total_min += min_i\n            total_max += max_i\n        return total_min, total_max, min_i_vals, max_i_vals\n    \n    total_min, total_max, min_i_vals, max_i_vals = calculate_capacity(on_set)\n    \n    # Add units if capacity insufficient\n    if total_max < current_load:\n        candidates = [i for i in free_units if i not in on_set]\n        amortized_cost = []\n        for i in candidates:\n            unit = units_info[i]\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            amortized_cost.append((cost_per_mw, i))\n        amortized_cost.sort(key=lambda x: x[0])\n        \n        for _, i in amortized_cost:\n            if total_max >= current_load:\n                break\n            on_set.add(i)\n            new_min, new_max, _, _ = calculate_capacity([i])\n            total_min += new_min\n            total_max += new_max\n    \n    # Remove units if overcommitted\n    if total_min > current_load:\n        non_essential = [i for i in on_set if i not in must_on]\n        operating_cost = []\n        for i in non_essential:\n            unit = units_info[i]\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            operating_cost.append((cost_per_mw, i))\n        operating_cost.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in operating_cost:\n            if total_min <= current_load:\n                break\n            on_set.remove(i)\n            prev_min, prev_max, _, _ = calculate_capacity([i])\n            total_min -= prev_min\n            total_max -= prev_max\n    \n    # Compute dispatch bounds\n    bounds = []\n    for i in on_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((min_bound, max_bound))\n    \n    # Economic dispatch\n    if current_load <= total_min:\n        outputs = [min_bound for min_bound, _ in bounds]\n    elif current_load >= total_max:\n        outputs = [max_bound for _, max_bound in bounds]\n    else:\n        # Lambda iteration setup\n        low = min(2*units_info[i]['c_i']*bounds[idx][0] + units_info[i]['b_i'] \n                 for idx, i in enumerate(on_set) if units_info[i]['c_i'] > 0 or units_info[i]['b_i'])\n        high = max(2*units_info[i]['c_i']*bounds[idx][1] + units_info[i]['b_i'] \n                  for idx, i in enumerate(on_set) if units_info[i]['c_i'] > 0 or units_info[i]['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        lamb = (low + high) / 2\n        \n        for _ in range(max_iter):\n            total_p = 0.0\n            for idx, i in enumerate(on_set):\n                unit = units_info[i]\n                min_bound, max_bound = bounds[idx]\n                if unit['c_i'] == 0:\n                    p_i = max_bound if lamb >= unit['b_i'] else min_bound\n                else:\n                    p_i = (lamb - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_bound, min(max_bound, p_i))\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n            lamb = (low + high) / 2\n        \n        # Calculate final outputs\n        outputs = []\n        for idx, i in enumerate(on_set):\n            unit = units_info[i]\n            min_bound, max_bound = bounds[idx]\n            if unit['c_i'] == 0:\n                p_i = max_bound if lamb >= unit['b_i'] else min_bound\n            else:\n                p_i = (lamb - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(min_bound, min(max_bound, p_i))\n            outputs.append(p_i)\n    \n    # Build output arrays\n    for j, i in enumerate(on_set):\n        u_arr[i] = 1\n        p_arr[i] = outputs[j]\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0063269571,
          "gap_price_rate": 0.0083953792,
          "fitness": 0.0073611682
     },
     {
          "name": "enhanced_amortized_cost_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain on due to min up-time or shutdown constraints), forced-off (must remain off due to min down-time), free online (adjustable units currently on), and free offline (adjustable units currently off)  \n2. For free units, calculate amortized cost metrics: operating cost at min output for free online; startup cost amortized over min up-time plus operating cost at min output for free offline  \n3. Sort free units by cost metrics in ascending order  \n4. Build committed set:  \n   - Start with forced-on units  \n   - Add free online units in cost order  \n   - Add free offline units in cost order until total max capacity \u2265 load  \n   - If total min output > load, remove most expensive free units (descending cost order) while maintaining total max capacity \u2265 load  \n5. Calculate feasible power bounds for committed units considering ramp constraints and startup/shutdown limits  \n6. Perform economic dispatch:  \n   - Use lambda iteration with bounds to find optimal generation levels  \n   - Adjust outputs to exactly match load using residual distribution  \n   - Clamp generation levels if outside bounds  \n7. Set non-committed units to off (u_i=0, p_i=0)  \n8. Return commitment states and power outputs  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_amortized_cost_dispatch(units_info, load):  \n    current_load = load[0]  \n    num_units = len(units_info)  \n    \n    # Initialize arrays for schedules  \n    u_schedule = np.zeros(num_units)  \n    p_schedule = np.zeros(num_units)  \n    \n    # Classify units and calculate cost metrics  \n    forced_on = []  \n    forced_off = []  \n    free_online = []  \n    free_offline = []  \n    \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):  \n                forced_on.append(i)  \n            else:  \n                free_online.append(i)  \n        else:  \n            if -unit['t_i_0'] < unit['t_off_min_i']:  \n                forced_off.append(i)  \n            else:  \n                free_offline.append(i)  \n    \n    # Calculate cost metrics  \n    def calc_cost_metric(i):  \n        unit = units_info[i]  \n        base_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)  \n        if i in free_online:  \n            return base_cost / unit['p_min_i']  \n        else:  # free_offline  \n            return (unit['s_i'] / unit['t_on_min_i'] + base_cost) / unit['p_min_i']  \n    \n    # Sort free units by cost metric  \n    free_online.sort(key=lambda i: calc_cost_metric(i))  \n    free_offline.sort(key=lambda i: calc_cost_metric(i))  \n    candidate_list = free_online + free_offline  \n    \n    # Initialize committed set and power bounds  \n    committed_set = set(forced_on)  \n    bounds = {}  \n    total_min = 0.0  \n    total_max = 0.0  \n    \n    # Calculate bounds for forced-on units  \n    for i in forced_on:  \n        unit = units_info[i]  \n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        bounds[i] = (min_p, max_p)  \n        total_min += min_p  \n        total_max += max_p  \n    \n    # Add candidates until max capacity meets load  \n    for i in candidate_list:  \n        unit = units_info[i]  \n        if i in free_online:  \n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  # free_offline  \n            min_p = unit['p_min_i']  \n            max_p = min(unit['p_max_i'], unit['p_start_i'])  \n        \n        if total_max < current_load:  \n            committed_set.add(i)  \n            bounds[i] = (min_p, max_p)  \n            total_min += min_p  \n            total_max += max_p  \n    \n    # Remove expensive units if min output exceeds load  \n    free_in_commit = [i for i in committed_set if i not in forced_on]  \n    free_with_cost = [(i, calc_cost_metric(i)) for i in free_in_commit]  \n    free_with_cost.sort(key=lambda x: x[1], reverse=True)  # Descending cost  \n    \n    changed = True  \n    while changed and total_min > current_load and free_with_cost:  \n        changed = False  \n        for idx, (i, _) in enumerate(free_with_cost):  \n            min_p_i, max_p_i = bounds[i]  \n            new_min = total_min - min_p_i  \n            new_max = total_max - max_p_i  \n            if new_max >= current_load:  \n                committed_set.remove(i)  \n                del bounds[i]  \n                total_min = new_min  \n                total_max = new_max  \n                del free_with_cost[idx]  \n                changed = True  \n                break  \n    \n    # Calculate bounds for all committed units  \n    total_min = sum(bounds[i][0] for i in committed_set)  \n    total_max = sum(bounds[i][1] for i in committed_set)  \n    \n    # Economic dispatch  \n    dispatch = {}  \n    tol = 1e-3  \n    \n    if committed_set:  \n        if abs(total_min - total_max) < tol:  \n            for i in committed_set:  \n                dispatch[i] = bounds[i][0]  \n        elif current_load <= total_min:  \n            for i in committed_set:  \n                dispatch[i] = bounds[i][0]  \n        elif current_load >= total_max:  \n            for i in committed_set:  \n                dispatch[i] = bounds[i][1]  \n        else:  \n            # Lambda iteration  \n            lambda_low = 0  \n            lambda_high = max(2*units_info[i]['c_i']*bounds[i][1] + units_info[i]['b_i']  \n                            for i in committed_set) * 2  \n            n_iter = 100  \n            \n            for _ in range(n_iter):  \n                lambda_mid = (lambda_low + lambda_high) / 2  \n                total_gen = 0.0  \n                for i in committed_set:  \n                    unit = units_info[i]  \n                    min_p, max_p = bounds[i]  \n                    p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])  \n                    p_val = max(min_p, min(max_p, p_val))  \n                    total_gen += p_val  \n                \n                if abs(total_gen - current_load) < tol:  \n                    break  \n                elif total_gen < current_load:  \n                    lambda_low = lambda_mid  \n                else:  \n                    lambda_high = lambda_mid  \n            \n            # Calculate generation with final lambda  \n            total_gen = 0.0  \n            for i in committed_set:  \n                unit = units_info[i]  \n                min_p, max_p = bounds[i]  \n                p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])  \n                p_val = max(min_p, min(max_p, p_val))  \n                dispatch[i] = p_val  \n                total_gen += p_val  \n            \n            # Residual distribution if needed  \n            residual = current_load - total_gen  \n            if abs(residual) > tol:  \n                units_adj = []  \n                for i in committed_set:  \n                    min_p, max_p = bounds[i]  \n                    if residual > 0 and dispatch[i] < max_p:  \n                        units_adj.append(i)  \n                    elif residual < 0 and dispatch[i] > min_p:  \n                        units_adj.append(i)  \n                \n                if units_adj:  \n                    # Weight by available ramp  \n                    ramp_cap = []  \n                    for i in units_adj:  \n                        min_p, max_p = bounds[i]  \n                        if residual > 0:  \n                            ramp_cap.append(max_p - dispatch[i])  \n                        else:  \n                            ramp_cap.append(dispatch[i] - min_p)  \n                    \n                    total_ramp = sum(ramp_cap)  \n                    for idx, i in enumerate(units_adj):  \n                        adj_val = residual * ramp_cap[idx] / total_ramp  \n                        dispatch[i] += adj_val  \n                        min_p, max_p = bounds[i]  \n                        dispatch[i] = max(min_p, min(max_p, dispatch[i]))  \n    \n    # Build schedules  \n    for i in range(num_units):  \n        if i in committed_set:  \n            u_schedule[i] = 1  \n            p_schedule[i] = dispatch.get(i, 0.0)  \n        else:  \n            u_schedule[i] = 0  \n            p_schedule[i] = 0.0  \n    \n    return np.array([u_schedule, p_schedule])  ",
          "from": "crossover",
          "gap_power_rate": 0.0055426455,
          "gap_price_rate": 0.0096148659,
          "fitness": 0.0075787557
     },
     {
          "name": "hybrid_enhanced_amortized_dispatch",
          "algorithm": "1. Classify units into forced-on (violating min up-time/shutdown constraints), forced-off (violating min down-time), free online (adjustable and currently online), free offline (adjustable and currently offline)\n2. Calculate amortized cost metrics for free units: \n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Build candidate list: forced-on units first, then free units sorted by ascending amortized cost\n4. Calculate ramp-constrained bounds:\n   - For previously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - For new startups: [p_min_i, min(p_max_i, p_start_i)]\n5. Form committed set by adding candidates in cost order until ramp-constrained max capacity \u2265 load\n6. Remove most expensive free units if ramp-constrained min capacity > load\n7. Perform lambda iteration for economic dispatch:\n   a. Set lambda bounds based on marginal costs at power limits\n   b. Bisect to match generation with load\n   c. Clamp outputs within feasible bounds\n8. Set uncommitted units to off state with zero output\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_amortized_dispatch(units_info, load):\n    # Extract current load\n    current_load = load[0]\n    n_units = len(units_info)\n    # Initialize outputs\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    # If no load needed, return all units off\n    if current_load <= 1e-8:\n        return np.vstack([u_out, p_out])\n    \n    # Classify units and calculate amortized costs\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    index_map = []\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    \n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        \n        # Check forced status\n        if u_i_0 == 1:  # Currently online\n            min_up_time_violation = (t_i_0 < unit['t_on_min_i'])\n            shutdown_constraint = (unit['p_i_0'] > unit['p_shut_i'])\n            if min_up_time_violation or shutdown_constraint:\n                forced_on.append(idx)\n                min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                free_online.append(idx)\n        else:  # Currently offline\n            min_down_time_violation = (-t_i_0 < unit['t_off_min_i'])\n            if min_down_time_violation:\n                forced_off.append(idx)\n                min_bounds[idx] = 0\n                max_bounds[idx] = 0\n            else:\n                free_offline.append(idx)\n                min_bounds[idx] = unit['p_min_i']\n                max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate cost metrics for free units\n    free_costs = []\n    for idx in free_online:\n        unit = units_info[idx]\n        min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n        free_costs.append(min_cost / unit['p_min_i'])\n    \n    for idx in free_offline:\n        unit = units_info[idx]\n        startup_cost = unit['s_i'] / max(1, unit['t_on_min_i'])  # Amortize startup cost\n        min_cost = (startup_cost + unit['a_i'] + unit['b_i']*unit['p_min_i'] \n                    + unit['c_i']*unit['p_min_i']**2)\n        free_costs.append(min_cost / unit['p_min_i'])\n    \n    # Combine free units and sort by cost\n    free_all = free_online + free_offline\n    if free_costs:\n        free_sorted = [x for _, x in sorted(zip(free_costs, free_all))]\n    else:\n        free_sorted = []\n    \n    # Build candidate list (forced-on first, then free units by cost)\n    candidates = forced_on + free_sorted\n    committed = set(forced_on)\n    \n    # Calculate current capacity\n    total_min = sum(min_bounds[i] for i in committed)\n    total_max = sum(max_bounds[i] for i in committed)\n    \n    # Add free units until capacity meets load\n    for idx in free_sorted:\n        if total_max >= current_load:\n            break\n        if idx not in committed:\n            committed.add(idx)\n            total_min += min_bounds[idx]\n            total_max += max_bounds[idx]\n    \n    # Remove expensive units if over-committed\n    expensive_removal = sorted(\n        [i for i in committed if i not in forced_on],\n        key=lambda x: free_costs[free_all.index(x)] if x in free_all else 0,\n        reverse=True\n    )\n    \n    for idx in expensive_removal:\n        if total_min > current_load:\n            committed.remove(idx)\n            total_min -= min_bounds[idx]\n            total_max -= max_bounds[idx]\n        else:\n            break\n    \n    # Calculate final bounds for committed units\n    comm_indices = list(committed)\n    comm_min_bounds = np.zeros(len(comm_indices))\n    comm_max_bounds = np.zeros(len(comm_indices))\n    a_coeffs = []\n    b_coeffs = []\n    c_coeffs = []\n    \n    for j, idx in enumerate(comm_indices):\n        unit = units_info[idx]\n        # Adjust bounds based on online state\n        if unit['u_i_0'] == 1:  # Was online\n            comm_min_bounds[j] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            comm_max_bounds[j] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # New startup\n            comm_min_bounds[j] = unit['p_min_i']\n            comm_max_bounds[j] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        a_coeffs.append(unit['a_i'])\n        b_coeffs.append(unit['b_i'])\n        c_coeffs.append(unit['c_i'])\n    \n    comm_min_bounds = np.maximum(comm_min_bounds, np.array([units_info[idx]['p_min_i'] for idx in comm_indices]))\n    comm_max_bounds = np.minimum(comm_max_bounds, np.array([units_info[idx]['p_max_i'] for idx in comm_indices]))\n    \n    # Handle edge capacity cases\n    if total_min > current_load:\n        # Distribute proportional to min bounds\n        p_values = comm_min_bounds\n    elif total_max < current_load:\n        # Distribute proportional to max bounds\n        p_values = comm_max_bounds\n    else:\n        # Lambda iteration economic dispatch\n        p_values = lambda_iteration_dispatch(\n            current_load, comm_min_bounds, comm_max_bounds, \n            np.array(b_coeffs), np.array(c_coeffs)\n        )\n    \n    # Update outputs\n    for j, idx in enumerate(comm_indices):\n        u_out[idx] = 1\n        p_out[idx] = p_values[j]\n    \n    return np.vstack([u_out, p_out])\n\ndef lambda_iteration_dispatch(load, p_min, p_max, b, c, tol=0.01, max_iter=100):\n    \"\"\"Economic dispatch using lambda iteration\"\"\"\n    # Handle edge cases\n    if abs(np.sum(p_min) - load) < tol:\n        return p_min\n    if abs(np.sum(p_max) - load) < tol:\n        return p_max\n    \n    n_units = len(b)\n    # Initialize lambda bounds\n    lo = np.min((b + 2*c*p_min)[c > 0] if np.any(c > 0) else b.min())\n    hi = np.max((b + 2*c*p_max)[c > 0] if np.any(c > 0) else b.max())\n    \n    # Adjust for negative coefficients\n    if np.any(c <= 0):\n        lo = np.min(b + 2*c*p_min)\n        hi = np.max(b + 2*c*p_max)\n    \n    # Bisection loop\n    for _ in range(max_iter):\n        lam = (lo + hi) / 2\n        # Calculate desired outputs\n        with np.errstate(divide='ignore', invalid='ignore'):\n            p_desired = (lam - b) / (2 * c)\n        \n        # Handle negative/invalid coefficients\n        p_desired[c <= 0] = np.where(\n            lam > b[c <= 0], \n            p_max[c <= 0], \n            p_min[c <= 0]\n        )\n        \n        # Clamp to bounds\n        p_set = np.clip(p_desired, p_min, p_max)\n        total_gen = np.sum(p_set)\n        \n        # Convergence check\n        if abs(total_gen - load) < tol:\n            return p_set\n        \n        # Update lambda bounds\n        if total_gen < load:\n            lo = lam\n        else:\n            hi = lam\n    \n    # Fallback to proportional allocation\n    gap = load - np.sum(p_min)\n    headroom = p_max - p_min\n    if gap > 0 and np.sum(headroom) > 0:\n        allocations = headroom * gap / np.sum(headroom)\n        return p_min + allocations\n    return np.clip((p_min + p_max)/2, p_min, p_max)",
          "from": "crossover",
          "gap_power_rate": 0.0061246113,
          "gap_price_rate": 0.0137548521,
          "fitness": 0.0099397317
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run units that cannot be turned off due to min-up time, shutdown ramp limits, or ramp-down constraints.\n2. Identify must-off units that cannot be turned on due to min-down time constraints.\n3. Sort eligible candidate units by average cost per MW (includes startup cost for off units, excludes for on units).\n4. Commit must-run units and add candidate units in cost-ascending order until capacity meets current load.\n5. For committed units, calculate dispatch bounds based on operational constraints (ramps, startup capacities).\n6. Perform economic dispatch using lambda iteration to allocate load to units within bounds.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    must_run = set()\n    # Identify must-run units\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.add(id(unit))\n            elif unit['p_i_0'] > unit['p_shut_i'] or unit['p_i_0'] > unit['p_down_i']:\n                must_run.add(id(unit))\n    \n    # Helper to check must-off units\n    def is_must_off(unit):\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            return True\n        return False\n    \n    # Build candidate units list\n    candidate_units = []\n    for unit in units_info:\n        uid = id(unit)\n        if uid in must_run:\n            continue\n        if is_must_off(unit):\n            continue\n        candidate_units.append(unit)\n    \n    # Calculate average cost for commitment priority\n    def avg_cost(unit):\n        if unit['u_i_0'] == 1:  # On unit: only fuel cost\n            return (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        else:  # Off unit: fuel cost + startup\n            return (unit['s_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n    \n    # Sort by average cost\n    candidate_units_sorted = sorted(candidate_units, key=avg_cost)\n    \n    # Build final commitment set\n    committed_units = set(must_run)\n    total_capacity = 0.0\n    # Add must-run capacity\n    for unit in units_info:\n        if id(unit) in must_run:\n            if unit['u_i_0'] == 1:\n                total_capacity += unit['p_max_i']\n            else:  # Starting unit has constrained capacity\n                total_capacity += min(unit['p_max_i'], unit['p_start_i'])\n    # Add candidate units until load met\n    for unit in candidate_units_sorted:\n        if total_capacity >= load[0]:\n            break\n        if unit['u_i_0'] == 1:  # Already on\n            added_capacity = unit['p_max_i']\n        else:  # Starting unit\n            added_capacity = min(unit['p_max_i'], unit['p_start_i'])\n        committed_units.add(id(unit))\n        total_capacity += added_capacity\n    \n    # Prepare for economic dispatch\n    committed_list = []\n    bounds = []\n    cost_params = []\n    for unit in units_info:\n        if id(unit) in committed_units:\n            # Calculate dispatch bounds\n            if unit['u_i_0'] == 1:  # Was on\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Was off (starting)\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            committed_list.append(unit)\n            bounds.append((lb, ub))\n            cost_params.append((unit['b_i'], unit['c_i']))\n    \n    if not committed_list:  # No units committed\n        schedules = np.zeros((2, len(units_info)))\n        return schedules\n    \n    # Lambda iteration for economic dispatch\n    low_lam = -10000.0\n    high_lam = 10000.0\n    tol = 0.01\n    n_iters = 100\n    for _ in range(n_iters):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0.0\n        for (b, c), (lb, ub) in zip(cost_params, bounds):\n            # Calculate unconstrained dispatch\n            if c == 0:\n                p = ub if mid_lam >= b else lb\n            else:\n                p = (mid_lam - b) / (2 * c)\n            p = max(lb, min(ub, p))\n            total_power += p\n        \n        if abs(total_power - load[0]) < tol:\n            break\n        if total_power < load[0]:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Calculate final dispatch values\n    dispatch = []\n    for (b, c), (lb, ub) in zip(cost_params, bounds):\n        if c == 0:\n            p = ub if mid_lam >= b else lb\n        else:\n            p = (mid_lam - b) / (2 * c)\n        p = max(lb, min(ub, p))\n        dispatch.append(p)\n    \n    # Map back to original units\n    schedule_u = []\n    schedule_p = []\n    idx = 0\n    for unit in units_info:\n        if id(unit) in committed_units:\n            schedule_u.append(1)\n            schedule_p.append(dispatch[idx])\n            idx += 1\n        else:\n            schedule_u.append(0)\n            schedule_p.append(0.0)\n    \n    schedules = np.array([schedule_u, schedule_p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0089824653,
          "gap_price_rate": 0.011717359,
          "fitness": 0.0103499122
     },
     {
          "name": "dynamic_priority_heuristic",
          "algorithm": "1. Enforce minimum up/down times and shutdown ramp constraints\n2. Calculate priority index for non-forced units: \n   - Active units: marginal cost at p_min_i\n   - Inactive units: marginal cost + amortized startup cost\n3. Commit units by priority order until total capacity \u2265 load\n4. Initialize outputs at feasible minimums considering ramping constraints\n5. Perform economic dispatch:\n   - Increase output for lowest marginal cost units with headroom\n   - Decrease output for highest marginal cost units with footroom\n   - Iterate until load is met within tolerance\n\n",
          "code": "import numpy as np\n\ndef dynamic_priority_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    # Enforce constraints\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on[idx] = True\n        else:\n            if abs(t_i0) < t_off_min:\n                forced_off[idx] = True\n    \n    u = [0] * n_units\n    p = [0] * n_units\n    \n    # Commit forced units\n    for idx in range(n_units):\n        if forced_on[idx]:\n            u[idx] = 1\n        if forced_off[idx]:\n            u[idx] = 0\n    \n    # Priority calculation\n    eligible_units = []\n    for idx in range(n_units):\n        if forced_on[idx] or forced_off[idx]:\n            continue\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            priority = (unit['b_i'] + 2 * unit['c_i'] * p_min) / p_min\n        else:\n            amortized_startup = unit['s_i'] / (unit['t_on_min_i'] * p_min)\n            priority = (unit['b_i'] + 2 * unit['c_i'] * p_min) / p_min + amortized_startup\n        eligible_units.append((priority, idx))\n    \n    eligible_units.sort(key=lambda x: x[0])\n    \n    # Commit by priority\n    total_max = 0\n    for idx in range(n_units):\n        if u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total_max += min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    for priority, idx in eligible_units:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_max += min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    # Initialize outputs\n    total_power = 0\n    for idx in range(n_units):\n        if u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p[idx] = lb\n            else:\n                p[idx] = unit['p_min_i']\n            total_power += p[idx]\n    \n    # Economic dispatch\n    tolerance = 0.1\n    while abs(total_power - current_load) > tolerance:\n        if total_power < current_load:  # Need more power\n            min_mc = float('inf')\n            candidate = -1\n            max_inc = 0\n            for idx in range(n_units):\n                if u[idx] == 0:\n                    continue\n                unit = units_info[idx]\n                mc = 2 * unit['c_i'] * p[idx] + unit['b_i']\n                # Compute headroom\n                if unit['u_i_0'] == 1:\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n                headroom = ub - p[idx]\n                if headroom > tolerance and mc < min_mc:\n                    min_mc = mc\n                    candidate = idx\n                    max_inc = headroom\n            if candidate == -1:\n                break\n            inc = min(max_inc, current_load - total_power)\n            p[candidate] += inc\n            total_power += inc\n        \n        else:  # Need less power\n            max_mc = -float('inf')\n            candidate = -1\n            max_dec = 0\n            for idx in range(n_units):\n                if u[idx] == 0 or units_info[idx]['u_i_0'] == 0:\n                    continue\n                unit = units_info[idx]\n                mc = 2 * unit['c_i'] * p[idx] + unit['b_i']\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                footroom = p[idx] - lb\n                if footroom > tolerance and mc > max_mc:\n                    max_mc = mc\n                    candidate = idx\n                    max_dec = footroom\n            if candidate == -1:\n                break\n            dec = min(max_dec, total_power - current_load)\n            p[candidate] -= dec\n            total_power -= dec\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0055517872,
          "gap_price_rate": 0.0215854404,
          "fitness": 0.0135686138
     }
]