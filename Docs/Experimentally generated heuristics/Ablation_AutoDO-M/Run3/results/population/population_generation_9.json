[
     {
          "name": "refined_amortized_with_forecast",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp), forced-off (violating min down-time), free online (adjustable online), free offline (adjustable offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization over min up-time if next load >= current load (indicating sustained need), else full amortization.\n3. Precompute cost metrics: operating cost at min power for free online; amortized startup cost plus operating cost for free offline.\n4. Build initial commitment set: forced-on units then free units in ascending cost order until ramp-constrained max capacity >= current load.\n5. Refine committed set: sort free units by cost descending and iteratively remove while maintaining max capacity >= load and reducing min capacity \u2264 load.\n6. For committed units, calculate bounds: previously online consider ramp limits; newly started consider startup ramp limits.\n7. Dispatch in three stages:\n   a) Boundary handling: set outputs to min or max if load out of bounds.\n   b) Bisection for lambda iteration with analytical derivative for quadratic units.\n   c) Discrete settings and residual adjustment for linear units.\n\n",
          "code": "import numpy as np\n\ndef refined_amortized_with_forecast(units_info, load):\n    L_current, L_next = load[0], load[1]\n    num_units = len(units_info)\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < t_up_min or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -t0 < t_down_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        t_min_up = unit['t_on_min_i']\n        if L_next >= L_current:\n            amortized_startup = s / (2 * t_min_up)\n        else:\n            amortized_startup = s / t_min_up\n        cost_metric[i] = (amortized_startup + a + b * p_min + c * p_min**2) / p_min\n\n    committed_set = set(forced_on)\n    free_sorted = sorted(free_online + free_offline, key=lambda i: cost_metric.get(i, float('inf')))\n    total_max = 0.0\n    for i in committed_set:\n        unit = units_info[i]\n        total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for i in free_sorted:\n        if total_max >= L_current:\n            break\n        unit = units_info[i]\n        max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if i in free_online else min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_cap\n        committed_set.add(i)\n    \n    total_min = 0.0\n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_cap\n        bounds[i] = (min_cap, max_cap)\n    \n    free_committed = [i for i in committed_set if i in free_online or i in free_offline]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric.get(i, 0), reverse=True)\n    for i in free_committed_sorted:\n        min_cap, max_cap = bounds[i]\n        new_total_min = total_min - min_cap\n        new_total_max = total_max - max_cap\n        if new_total_min <= L_current and new_total_max >= L_current:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (min_cap, max_cap)\n    \n    total_min = sum(bounds[i][0] for i in committed_set)\n    total_max = sum(bounds[i][1] for i in committed_set)\n    \n    quadratic_units = []\n    linear_units = []\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['c_i'] > 0:\n            quadratic_units.append(i)\n        else:\n            linear_units.append(i)\n    \n    if L_current <= total_min:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][0]\n    elif L_current >= total_max:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][1]\n    else:\n        p_vals = {}\n        residual = L_current\n        for i in linear_units:\n            unit = units_info[i]\n            _, max_cap = bounds[i]\n            if unit['b_i'] <= unit['a_i'] / max_cap + unit['b_i']:\n                p_vals[i] = max_cap\n            else:\n                p_vals[i] = bounds[i][0]\n            residual -= p_vals[i]\n        \n        if quadratic_units:\n            low, high = 0, 0\n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                low = min(low, unit['b_i'] + 2 * unit['c_i'] * min_cap)\n                high = max(high, unit['b_i'] + 2 * unit['c_i'] * max_cap)\n            \n            tol = 1e-3\n            max_iter = 100\n            for _ in range(max_iter):\n                mid = (low + high) / 2\n                total_power = residual\n                for i in quadratic_units:\n                    unit = units_info[i]\n                    min_cap, max_cap = bounds[i]\n                    p = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                    total_power += p\n                if abs(total_power) < tol:\n                    break\n                if total_power < 0:\n                    high = mid\n                else:\n                    low = mid\n            \n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                p_vals[i] = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                residual -= p_vals[i]\n        \n        if abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = bounds[i][1] - current_p\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) + adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n            else:\n                residual = abs(residual)\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = current_p - bounds[i][0]\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: -x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) - adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n        \n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = p_vals.get(i, bounds[i][0])\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0031320448,
          "gap_price_rate": 0.0067061217,
          "fitness": 0.0049190833
     },
     {
          "name": "hybrid_amortized_adaptive_dispatch",
          "algorithm": "**  \n1. **Classify Units:** Categorize units into forced-on (must remain online due to min up-time/shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), free offline (adjustable and currently offline) using constraints.  \n2. **Amortize Startup Costs:** Adjust startup costs for free offline units: half amortization over min up-time if next load \u2265 current load, else full amortization.  \n3. **Precompute Bounds & Cost Rates:**  \n   - Compute ramp-constrained bounds for online units: `[max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]`  \n   - Compute startup-constrained bounds for offline units: `[p_min_i, min(p_max_i, p_start_i)]`  \n   - Calculate cost rates: `(a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i` (free online) or with amortized startup costs (free offline).  \n4. **Build Commitment Set:**  \n   - Start with forced-on units.  \n   - Add free units (sorted by cost rate ascending) until total max capacity \u2265 load.  \n5. **Refine Commitment Set:**  \n   - Remove expensive free units (sorted by cost rate descending) only if removal maintains `min_capacity \u2264 load \u2264 max_capacity`.  \n6. **Economic Dispatch:**  \n   - **Boundary Cases:** Set all outputs to min if `load \u2264 total_min`; set all outputs to max if `load \u2265 total_max`.  \n   - **Lambda Iteration:** Use Newton-accelerated bisection with clamping to solve quadratic cost functions, ensuring `\u2211p_i = load` within bounds.  \n   - **Residual Adjustment:** Greedily adjust residual load prioritizing units with highest sensitivity.  \n7. **Output:** Set non-committed units to `u_i=0, p_i=0`; return `schedules` as a 2D array.  \n\n**",
          "code": "import numpy as np\n\ndef hybrid_amortized_adaptive_dispatch(units_info, load):\n    num_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Initialize arrays for commitment and dispatch\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n    \n    # Precompute bounds and cost rates for all units\n    bounds_min = [0.0] * num_units\n    bounds_max = [0.0] * num_units\n    cost_rates = [float('inf')] * num_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds_min[i] = lb\n        bounds_max[i] = ub\n    \n    # Classify units and compute cost rates\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Compute cost rates for free units\n    for i in free_online:\n        unit = units_info[i]\n        cost_val = unit['a_i'] + unit['b_i'] * bounds_min[i] + unit['c_i'] * (bounds_min[i] ** 2)\n        cost_rates[i] = cost_val / bounds_min[i]\n    \n    for i in free_offline:\n        unit = units_info[i]\n        amort_factor = 2.0 * unit['t_on_min_i'] if next_load >= current_load else unit['t_on_min_i']\n        amort_startup = unit['s_i'] / amort_factor\n        cost_val = unit['a_i'] + unit['b_i'] * bounds_min[i] + unit['c_i'] * (bounds_min[i] ** 2) + amort_startup\n        cost_rates[i] = cost_val / bounds_min[i]\n    \n    # Build initial commitment set\n    candidate_set = forced_on.copy()\n    total_min = sum(bounds_min[i] for i in forced_on)\n    total_max = sum(bounds_max[i] for i in forced_on)\n    committed_free = []\n    \n    free_all = free_online + free_offline\n    free_all_sorted = sorted(free_all, key=lambda i: cost_rates[i])\n    \n    for i in free_all_sorted:\n        if total_max < current_load:\n            candidate_set.append(i)\n            committed_free.append(i)\n            total_min += bounds_min[i]\n            total_max += bounds_max[i]\n        else:\n            break\n    \n    # Refine commitment set (remove expensive units if possible)\n    committed_free_sorted = sorted(committed_free, key=lambda i: cost_rates[i], reverse=True)\n    for i in committed_free_sorted:\n        new_min = total_min - bounds_min[i]\n        new_max = total_max - bounds_max[i]\n        if new_max >= current_load and new_min <= current_load:\n            candidate_set.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Set u_i=1 for committed units\n    for i in candidate_set:\n        u_out[i] = 1\n    \n    # Economic dispatch\n    if current_load <= total_min:\n        for i in candidate_set:\n            p_out[i] = bounds_min[i]\n    elif current_load >= total_max:\n        for i in candidate_set:\n            p_out[i] = bounds_max[i]\n    else:\n        # Lambda iteration for dispatch\n        low_indices = []\n        high_indices = []\n        mid_indices = candidate_set.copy()\n        p_vals = {i: bounds_min[i] for i in candidate_set}\n        \n        max_iter = 100\n        tolerance = 1e-6\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            # Reset sets each iteration\n            low_indices = []\n            high_indices = []\n            new_mid = []\n            \n            # Compute total power and categorize units\n            total_power = 0.0\n            for i in mid_indices:\n                total_power += p_vals[i]\n            \n            residual = current_load - total_power\n            if abs(residual) < tolerance:\n                break\n            \n            # Compute lambda\n            denom = 0.0\n            numer = 0.0\n            for i in mid_indices:\n                c_i = units_info[i]['c_i']\n                if c_i > tolerance:\n                    denom += 1.0 / (2.0 * c_i)\n                    numer += units_info[i]['b_i'] / (2.0 * c_i)\n            if denom > tolerance:\n                lambda_val = (residual + numer) / denom\n            else:\n                lambda_val = numer / denom if abs(numer) > tolerance else 0.0\n            \n            # Update mid_indices with new lambda\n            for i in mid_indices:\n                unit = units_info[i]\n                c_i = unit['c_i']\n                b_i = unit['b_i']\n                if c_i < tolerance:  # Linear cost\n                    # Placeholder: use bound if linear cost (shouldn't happen for quadratic)\n                    continue\n                p_uncon = (lambda_val - b_i) / (2.0 * c_i)\n                if p_uncon < bounds_min[i]:\n                    p_vals[i] = bounds_min[i]\n                    low_indices.append(i)\n                elif p_uncon > bounds_max[i]:\n                    p_vals[i] = bounds_max[i]\n                    high_indices.append(i)\n                else:\n                    p_vals[i] = p_uncon\n                    new_mid.append(i)\n            mid_indices = new_mid\n            iter_count += 1\n        \n        # Residual adjustment if needed\n        total_power = sum(p_vals.get(i, 0.0) for i in candidate_set)\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            marginal_costs = {}\n            for i in candidate_set:\n                if u_out[i] == 1 and bounds_min[i] <= p_vals[i] <= bounds_max[i]:\n                    marginal_costs[i] = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_vals[i]\n            if residual > 0:  # Increase generation\n                candidates = [i for i in candidate_set if p_vals[i] < bounds_max[i] - tolerance]\n                if candidates:\n                    sorted_candidates = sorted(candidates, key=lambda i: marginal_costs.get(i, float('inf')))\n                    for i in sorted_candidates:\n                        room = bounds_max[i] - p_vals[i]\n                        if room > tolerance:\n                            delta = min(room, residual)\n                            p_vals[i] += delta\n                            residual -= delta\n                        if residual < tolerance:\n                            break\n            else:  # Decrease generation\n                residual_abs = abs(residual)\n                candidates = [i for i in candidate_set if p_vals[i] > bounds_min[i] + tolerance]\n                if candidates:\n                    sorted_candidates = sorted(candidates, key=lambda i: marginal_costs.get(i, -float('inf')), reverse=True)\n                    for i in sorted_candidates:\n                        room = p_vals[i] - bounds_min[i]\n                        if room > tolerance:\n                            delta = min(room, residual_abs)\n                            p_vals[i] -= delta\n                            residual_abs -= delta\n                        if residual_abs < tolerance:\n                            break\n        \n        for i in candidate_set:\n            p_out[i] = p_vals[i]\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0044279251,
          "gap_price_rate": 0.0070158192,
          "fitness": 0.0057218721
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to minimum up-time or shutdown ramp constraints), forced-off (must remain offline due to minimum down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Precompute cost metrics for free units:\n   - Free online: cost rate = (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: cost rate = (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate commitment set starting with forced-on units, then add free units sorted by ascending cost rate until total ramp-constrained max capacity \u2265 current load. Precompute ramp-constrained min/max for each unit during classification.\n4. Refine commitment by removing expensive free units:\n   - Sort committed free units by cost rate descending\n   - Iteratively remove the most expensive unit if removal maintains max capacity \u2265 load and reduces min capacity below or equal to load\n5. Calculate dispatch bounds for committed units considering startup/shutdown ramps and online ramp constraints:\n   - Previously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Newly started units: [p_min_i, min(p_max_i, p_start_i)]\n6. Perform economic dispatch using optimized lambda iteration:\n   - Handle boundary cases where load \u2264 total min or \u2265 total max\n   - Use bisection with analytical derivative for faster convergence\n   - Distribute residual with priority-based greedy adjustment to ensure exact load matching\n7. Set non-committed units to offline state (u_i=0, p_i=0).\n8. Return commitment states and power outputs as a 2D NumPy array.\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = [0] * n_units\n    p_schedule = [0] * n_units\n    \n    # Data structures to store processed unit information\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    processed_units = [None] * n_units\n    \n    # Classify units and precompute parameters\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        forced_on_flag = False\n        forced_off_flag = False\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on_flag = True\n                forced_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:  # Currently offline\n            if -t0 < unit['t_off_min_i']:\n                forced_off_flag = True\n                forced_off.append(idx)\n            else:\n                free_offline.append(idx)\n                \n        # Precompute ramp-constrained boundaries\n        if u0 == 1:  # Online units\n            min_p = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline units\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate amortized cost rate for free units\n        if not (forced_on_flag or forced_off_flag):\n            operating_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if u0 == 1:  # Free online\n                cost_rate = operating_cost_min / unit['p_min_i']\n            else:  # Free offline\n                startup_amortized = unit['s_i'] / unit['t_on_min_i']\n                cost_rate = (operating_cost_min + startup_amortized) / unit['p_min_i']\n        else:\n            cost_rate = float('inf') if forced_off_flag else -float('inf')\n        \n        processed_units[idx] = {\n            'idx': idx,\n            'u0': u0,\n            'forced_on': forced_on_flag,\n            'forced_off': forced_off_flag,\n            'min_bound': min_p,\n            'max_bound': max_p,\n            'cost_rate': cost_rate,\n            'b': unit['b_i'],\n            'c': unit['c_i']\n        }\n    \n    # Initialize commitment set with forced-on units\n    committed_set = set(forced_on)\n    total_min = sum(processed_units[idx]['min_bound'] for idx in forced_on)\n    total_max = sum(processed_units[idx]['max_bound'] for idx in forced_on)\n    \n    # Candidate free units sorted by cost rate (ascending)\n    free_candidates = free_online + free_offline\n    free_candidates.sort(key=lambda idx: processed_units[idx]['cost_rate'])\n    \n    # Add free units until capacity meets or exceeds load\n    for idx in free_candidates:\n        if total_max < current_load:\n            committed_set.add(idx)\n            total_min += processed_units[idx]['min_bound']\n            total_max += processed_units[idx]['max_bound']\n        else:\n            break\n    \n    # Remove expensive free units if min capacity exceeds load\n    free_in_commit = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_in_commit.sort(key=lambda idx: processed_units[idx]['cost_rate'], reverse=True)\n    removed = True\n    while removed and total_min > current_load:\n        removed = False\n        for idx in free_in_commit:\n            unit = processed_units[idx]\n            new_min = total_min - unit['min_bound']\n            new_max = total_max - unit['max_bound']\n            if new_max >= current_load:\n                committed_set.remove(idx)\n                total_min = new_min\n                total_max = new_max\n                free_in_commit.remove(idx)\n                removed = True\n                break\n    \n    # Prepare dispatch units with valid bounds\n    dispatch_units = []\n    for idx in committed_set:\n        unit = processed_units[idx]\n        min_bound = unit['min_bound']\n        max_bound = unit['max_bound']\n        \n        # Ensure bounds are valid\n        if min_bound > max_bound:\n            min_bound = max_bound = (min_bound + max_bound) / 2\n            \n        dispatch_units.append({\n            'min': min_bound,\n            'max': max_bound,\n            'b': unit['b'],\n            'c': unit['c'],\n            'idx': idx\n        })\n    \n    # Calculate total dispatch bounds\n    total_min_dispatch = sum(unit['min'] for unit in dispatch_units)\n    total_max_dispatch = sum(unit['max'] for unit in dispatch_units)\n    \n    # Handle boundary cases\n    if current_load <= total_min_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['min']\n    elif current_load >= total_max_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['max']\n    else:\n        # Lambda iteration (bisection) with derivative for speed\n        low_lambda = 0\n        high_lambda = 1e6\n        tolerance = 1e-5\n        iterations = 0\n        \n        while iterations < 100 and (high_lambda - low_lambda) > tolerance:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            derivative_sum = 0\n            \n            for unit in dispatch_units:\n                c = unit['c']\n                if c == 0:  # Linear cost function\n                    p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n                else:\n                    p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                    p = max(unit['min'], min(unit['max'], p_unclamped))\n                \n                unit['p_temp'] = p\n                total_power += p\n                \n                if unit['min'] < p < unit['max']:\n                    derivative_sum += 1 / (2 * c)\n            \n            if derivative_sum == 0:  # All units at bounds\n                if total_power < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            else:\n                lambda_derivative = derivative_sum\n                error = total_power - current_load\n                mid_lambda -= error / lambda_derivative\n                \n                if total_power > current_load:\n                    high_lambda = mid_lambda\n                else:\n                    low_lambda = mid_lambda\n            \n            iterations += 1\n        \n        # Final power calculation\n        total_power = 0\n        for unit in dispatch_units:\n            c = unit['c']\n            if c == 0:\n                p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n            else:\n                p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                p = max(unit['min'], min(unit['max'], p_unclamped))\n            unit['p_temp'] = p\n            total_power += p\n        \n        # Adjust for residual with greedy method\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            if residual > 0:\n                candidates = [u for u in dispatch_units if u['p_temp'] < u['max']]\n                candidates.sort(key=lambda u: u['b'] + 2 * u['c'] * u['p_temp'])\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['max'] - unit['p_temp']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] += adjust\n                    residual -= adjust\n            else:\n                residual = abs(residual)\n                candidates = [u for u in dispatch_units if u['p_temp'] > u['min']]\n                candidates.sort(key=lambda u: -(u['b'] + 2 * u['c'] * u['p_temp']))\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['p_temp'] - unit['min']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] -= adjust\n                    residual -= adjust\n        \n        # Assign final dispatch values\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['p_temp']\n    \n    # Set commitment states\n    for idx in committed_set:\n        u_schedule[idx] = 1\n    \n    return np.array([u_schedule, p_schedule])",
          "from": "mutation",
          "gap_power_rate": 0.0033675075,
          "gap_price_rate": 0.0081376386,
          "fitness": 0.0057525731
     },
     {
          "name": "hybrid_amortized_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable online), and free offline (adjustable offline).\n2. Adjust startup cost amortization for free offline units based on forecasted load: half amortization over min up-time if next load \u2265 current load (sustained need), else full amortization.\n3. Precompute cost metrics per MW at min power: free online (operating cost only), free offline (amortized startup + operating cost).\n4. Build initial commitment set: start with forced-on units, add free units by ascending cost until total ramp/startup-constrained max capacity meets current load.\n5. Refine commitment set: remove most expensive free units (descending cost) if total max capacity still meets load AND total min capacity becomes \u2264 load.\n6. Calculate feasible dispatch bounds for committed units: previously online units respect ramp limits; newly started units respect startup ramp limits.\n7. Dispatch via three-stage method: \n   a) Boundary handling - set outputs to min/max if load outside bounds\n   b) Lambda iteration with bisection using analytical derivatives for quadratic costs\n   c) Marginal cost-based greedy adjustment to eliminate residual mismatch\n8. Set non-committed units to offline state (u_i=0, p_i=0).\n9. Return schedule as 2D array with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_amortized_priority_dispatch(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    # Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Precompute cost metrics with forecast-based amortization\n    cost_rates = np.ones(n_units) * np.inf\n    for i in free_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_rates[i] = cost / p_min\n    \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        amortization = unit['t_on_min_i']\n        if next_load >= current_load:\n            amortization *= 2  # Half amortization\n        startup_cost = unit['s_i'] / amortization\n        cost = startup_cost + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_rates[i] = cost / p_min\n    \n    # Form initial commitment set\n    committed = set(forced_on)\n    total_max = 0.0\n    for i in committed:\n        unit = units_info[i]\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max += ub\n    \n    free_units = sorted(free_online + free_offline, key=lambda i: cost_rates[i])\n    for i in free_units:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if i in free_online:\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += ub\n        committed.add(i)\n    \n    # Refine commitment set\n    committed_free = [i for i in committed if i in free_online or i in free_offline]\n    committed_free_sorted = sorted(committed_free, key=lambda i: cost_rates[i], reverse=True)\n    lb_dict = {}\n    ub_dict = {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(lb_dict[i] for i in committed)\n    total_max = sum(ub_dict[i] for i in committed)\n    for i in committed_free_sorted:\n        new_total_min = total_min - lb_dict[i]\n        new_total_max = total_max - ub_dict[i]\n        if new_total_max >= current_load and new_total_min <= current_load:\n            committed.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    # Calculate dispatch bounds\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lb_dict[i] = lb\n        ub_dict[i] = ub\n    \n    # Economic dispatch\n    p_alloc = {}\n    if total_min >= current_load:\n        for i in committed:\n            p_alloc[i] = lb_dict[i]\n    elif total_max <= current_load:\n        for i in committed:\n            p_alloc[i] = ub_dict[i]\n    else:\n        # Lambda iteration with bisection\n        lambda_low = min(unit['b_i'] + 2 * unit['c_i'] * lb_dict[i] for i in committed)\n        lambda_high = max(unit['b_i'] + 2 * unit['c_i'] * ub_dict[i] for i in committed)\n        tol = 1e-5\n        n_iter = 100\n        for _ in range(n_iter):\n            lam = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i in committed:\n                unit = units_info[i]\n                p_star = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_star, lb_dict[i], ub_dict[i])\n                p_alloc[i] = p_i\n                total_p += p_i\n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                lambda_low = lam\n            else:\n                lambda_high = lam\n        \n        # Greedy residual adjustment\n        residual = current_load - total_p\n        while abs(residual) > tol:\n            if residual > 0:\n                candidates = [i for i in committed if p_alloc[i] < ub_dict[i] - tol]\n                if not candidates:\n                    break\n                i_min = min(candidates, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                max_inc = min(residual, ub_dict[i_min] - p_alloc[i_min])\n                p_alloc[i_min] += max_inc\n                residual -= max_inc\n            else:\n                candidates = [i for i in committed if p_alloc[i] > lb_dict[i] + tol]\n                if not candidates:\n                    break\n                i_max = max(candidates, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                max_dec = min(-residual, p_alloc[i_max] - lb_dict[i_max])\n                p_alloc[i_max] -= max_dec\n                residual += max_dec\n    \n    # Prepare output\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    for i in range(n_units):\n        if i in committed:\n            u_out[i] = 1\n            p_out[i] = p_alloc.get(i, 0.0)\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0032375616,
          "gap_price_rate": 0.0094420278,
          "fitness": 0.0063397947
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Classify units into forced-on (must run due to min uptime/shutdown ramp constraints), forced-off (min downtime unmet), free online (adjustable/online), free offline (adjustable/offline)  \n2. Compute refined startup cost amortization for free offline units:  \n   - If forecasted load \u2265 current load: amortize over min uptime  \n   - Else: amortize over a shorter period (min(ceil(min uptime/2), 1)) to adapt to declining load  \n3. Precompute cost-per-MW at midpoint of feasible range considering:  \n   - Free online: operating cost only at midpoint of ramp-constrained range  \n   - Free offline: amortized startup cost + operating cost at midpoint of startup-constrained range  \n4. Build committed set:  \n   - Start with forced-on units  \n   - Add free units (online first, then offline) sorted by cost-per-MW until max capacity covers current load  \n5. Refine commitment:  \n   - Remove expensive free units (descending cost) only if:  \n     - Total min capacity > current load  \n     - Forecasted load decreases  \n     - Removal maintains sufficient max capacity  \n6. For committed units, compute power bounds considering:  \n   - Previously online: ramp limits  \n   - Newly started: startup ramp limits  \n7. Dispatch load in 3 phases:  \n   a) Set all to min/max if load outside total bounds  \n   b) Use Newton-accelerated bisection for fast lambda convergence  \n   c) Cost-prioritized greedy adjustment to exactly match load while respecting unit constraints  \n8. Set non-committed units to off  \n\n",
          "code": "import numpy as np\nimport math\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Deep copy to avoid mutation\n    units = [dict(unit) for unit in units_info]\n    n_units = len(units)\n    \n    # Initialize schedule\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units, dtype=float)\n    \n    # Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Currently offline\n            if t0 < 0 and abs(t0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Precompute cost metrics and bounds\n    costs = []\n    min_outputs = []\n    max_outputs = []\n    types = []\n    indices = []\n    \n    # Helper to calculate operating cost\n    def operating_cost(unit, p):\n        return unit['a_i'] + unit['b_i'] * p + unit['c_i'] * p**2\n    \n    # Process free online units\n    for i in free_online:\n        unit = units[i]\n        p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p_mid = (p_low + p_high) / 2.0\n        cost_per_mw = operating_cost(unit, p_mid) / p_mid\n        costs.append(cost_per_mw)\n        min_outputs.append(p_low)\n        max_outputs.append(p_high)\n        types.append('online')\n        indices.append(i)\n    \n    # Process free offline units with refined amortization\n    for i in free_offline:\n        unit = units[i]\n        # Calculate amortization factor\n        if next_load >= current_load:\n            amort_factor = unit['t_on_min_i']\n        else:\n            amort_factor = min(max(1, math.ceil(unit['t_on_min_i'] / 2)), unit['t_on_min_i'])\n        \n        startup_amortized = unit['s_i'] / amort_factor\n        p_low = unit['p_min_i']\n        p_high = min(unit['p_max_i'], unit['p_start_i'])\n        p_mid = (p_low + p_high) / 2.0\n        total_cost = startup_amortized + operating_cost(unit, p_mid)\n        cost_per_mw = total_cost / p_mid\n        costs.append(cost_per_mw)\n        min_outputs.append(p_low)\n        max_outputs.append(p_high)\n        types.append('offline')\n        indices.append(i)\n    \n    # Combine and sort free units by cost (online first when tied)\n    sorted_free = sorted(zip(costs, min_outputs, max_outputs, types, indices), \n                         key=lambda x: (x[0], 0 if x[3]=='online' else 1))\n    \n    # Build commitment set\n    committed_set = set(forced_on)\n    total_min = 0.0\n    total_max = 0.0\n    unit_min_max = {}\n    \n    # Add forced-on units\n    for i in forced_on:\n        unit = units[i]\n        p_min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += p_min_val\n        total_max += p_max_val\n        unit_min_max[i] = (p_min_val, p_max_val)\n    \n    # Add free units until coverage\n    for cost, p_min_val, p_max_val, typ, i in sorted_free:\n        if total_max >= current_load:\n            break\n        committed_set.add(i)\n        total_min += p_min_val\n        total_max += p_max_val\n        unit_min_max[i] = (p_min_val, p_max_val)\n    \n    # Refinement: remove expensive units if forecasted load decreases\n    if next_load < current_load and total_min > current_load:\n        # Sort by cost descending\n        committed_free = [i for i in committed_set if i in indices]\n        sorted_refine = sorted(committed_free, \n                              key=lambda i: (costs[indices.index(i)], 1 if types[indices.index(i)]=='online' else 0), \n                              reverse=True)\n        \n        for i in sorted_refine:\n            p_min_val, p_max_val = unit_min_max[i]\n            if total_min - p_min_val <= current_load and total_max - p_max_val >= current_load:\n                committed_set.remove(i)\n                total_min -= p_min_val\n                total_max -= p_max_val\n            if total_min <= current_load:\n                break\n    \n    # Recompute bounds for committed units\n    bounds = {}\n    for i in committed_set:\n        unit = units[i]\n        if unit['u_i_0'] == 1:  # Previously online\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Newly started\n            p_low = unit['p_min_i']\n            p_high = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (p_low, p_high)\n    \n    # Dispatch\n    dispatch_units = [i for i in committed_set]\n    n_committed = len(dispatch_units)\n    if n_committed == 0:\n        return np.array([u_arr, p_arr])\n    \n    # Get total min/max\n    total_min = sum(bounds[i][0] for i in dispatch_units)\n    total_max = sum(bounds[i][1] for i in dispatch_units)\n    \n    # Phase 1: Boundary cases\n    if current_load <= total_min:\n        for i in dispatch_units:\n            u_arr[i] = 1\n            p_arr[i] = bounds[i][0]\n        return np.array([u_arr, p_arr])\n    elif current_load >= total_max:\n        for i in dispatch_units:\n            u_arr[i] = 1\n            p_arr[i] = bounds[i][1]\n        return np.array([u_arr, p_arr])\n    \n    # Phase 2: Lambda iteration with Newton-accelerated bisection\n    # Initialize Lambdas and outputs\n    lambd_low = min(unit['b_i'] for unit in units)  # Theoretical min\n    lambd_high = max(unit['b_i'] + 2*unit['c_i']*bounds[i][1] for i, unit in enumerate(units) if i in dispatch_units)\n    lambd = (lambd_low + lambd_high) / 2.0\n    converged = False\n    iterations = 0\n    max_iter = 100\n    tol = 1e-4\n    \n    # Temporary storage for dispatch calculations\n    p_temp = {i: bounds[i][0] for i in dispatch_units}  # Start at lower bounds\n    \n    while not converged and iterations < max_iter:\n        total_power = 0.0\n        # Calculate outputs and derivatives\n        for i in dispatch_units:\n            unit = units[i]\n            p_low, p_high = bounds[i]\n            # Unconstrained output for quadratic cost\n            if unit['c_i'] > 0:\n                p_uncon = (lambd - unit['b_i']) / (2 * unit['c_i'])\n                p_clamped = min(p_high, max(p_low, p_uncon))\n            else:  # Linear cost\n                if lambd >= unit['b_i']:\n                    p_clamped = p_high\n                else:\n                    p_clamped = p_low\n            p_temp[i] = p_clamped\n            total_power += p_clamped\n        \n        # Check convergence\n        mismatch = total_power - current_load\n        if abs(mismatch) < tol:\n            converged = True\n            p_arr = [p_temp.get(i, 0.0) for i in range(n_units)]\n            break\n        \n        # Derivative of total_power w.r.t lambda\n        derivative = 0.0\n        for i in dispatch_units:\n            unit = units[i]\n            if unit['c_i'] > 0 and bounds[i][0] < p_temp[i] < bounds[i][1]:\n                derivative += 1.0 / (2 * unit['c_i'])\n        \n        # Newton step with bisection safeguard\n        if abs(derivative) > 1e-10:\n            newton_step = -mismatch / derivative\n            lambd_new = lambd + newton_step\n            # Apply bisection if Newton step goes out of bounds\n            if lambd_new < lambd_low or lambd_new > lambd_high:\n                if mismatch > 0:\n                    lambd_high = lambd\n                else:\n                    lambd_low = lambd\n                lambd = (lambd_low + lambd_high) / 2.0\n            else:\n                lambd = lambd_new\n        else:\n            # Pure bisection if no derivatives found\n            if mismatch > 0:\n                lambd_high = lambd\n            else:\n                lambd_low = lambd\n            lambd = (lambd_low + lambd_high) / 2.0\n        \n        iterations += 1\n    \n    # Assign lambda iteration results\n    for i in dispatch_units:\n        u_arr[i] = 1\n        p_arr[i] = p_temp[i]\n    \n    # Phase 3: Greedy adjustment for exact match\n    total_power = sum(p_arr)\n    residual = current_load - total_power\n    \n    # Create list of dispatchable units for adjustment\n    adj_units = []\n    for i in dispatch_units:\n        unit = units[i]\n        p_low, p_high = bounds[i]\n        # Incremental cost = b + 2c*p\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_arr[i]\n        # Capacity available\n        up_cap = max(0.0, p_high - p_arr[i])\n        down_cap = max(0.0, p_arr[i] - p_low)\n        adj_units.append((i, inc_cost, up_cap, down_cap))\n    \n    # Adjust while residual exists\n    tolerance = 1e-6\n    max_adjust = 100\n    adjust_iter = 0\n    \n    while abs(residual) > tolerance and adjust_iter < max_adjust:\n        adjust_iter += 1\n        if residual > 0:  # Need more power\n            # Find unit with lowest incremental cost and capacity\n            candidates = [(i, cost, cap) for i, cost, cap, down in adj_units if cap > 0]\n            if not candidates:\n                break\n            i, min_cost, min_cap = min(candidates, key=lambda x: x[1])\n            delta = min(residual, min_cap)\n            if delta > 0:\n                p_arr[i] += delta\n                residual -= delta\n                # Update adjustment capacities\n                for idx, adj in enumerate(adj_units):\n                    if adj[0] == i:\n                        adj_units[idx] = (i, adj[1], adj[2] - delta, adj[3])\n        else:  # Need less power\n            # Find unit with highest incremental cost and reduction capacity\n            candidates = [(i, cost, down) for i, cost, cap, down in adj_units if down > 0]\n            if not candidates:\n                break\n            i, max_cost, max_down = max(candidates, key=lambda x: x[1])\n            delta = min(-residual, max_down)\n            if delta > 0:\n                p_arr[i] -= delta\n                residual += delta\n                # Update adjustment capacities\n                for idx, adj in enumerate(adj_units):\n                    if adj[0] == i:\n                        adj_units[idx] = (i, adj[1], adj[2], adj[3] - delta)\n    \n    # Final update: set commitment status\n    for i in committed_set:\n        u_arr[i] = 1\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0042654838,
          "gap_price_rate": 0.0085184531,
          "fitness": 0.0063919685
     },
     {
          "name": "enhanced_amortized_cost_dispatch_forecast",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization (s_i / (2 * t_on_min_i)) if next period's load is greater than current load, else full amortization (s_i / t_on_min_i).\n3. Build candidate commitment set starting with forced-on units, then add free units sorted by ascending cost metric (operating cost at min power for free online; amortized startup cost plus operating cost at min power for free offline).\n4. Refine commitment set:\n   a. While total ramp-constrained max capacity < current load: add next cheapest free unit\n   b. While total ramp-constrained min capacity > load: remove most expensive free unit if removal maintains max capacity \u2265 load\n5. Calculate feasible power bounds for committed units:\n   a. Previously online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   b. Newly started: [p_min_i, min(p_max_i, p_start_i)]\n6. Dispatch load using multi-stage method:\n   a. Boundary cases: set all outputs to min if load \u2264 total min; set all to max if load \u2265 total max\n   b. Use Newton-bisection hybrid for lambda iteration\n   c. Adjust residuals using cost-prioritized greedy method respecting ramp constraints\n7. Set non-committed units to offline (u_i=0, p_i=0).\n8. Return schedules as 2D NumPy array.\n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch_forecast(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n\n    # Initialize arrays\n    u_i = np.zeros(n_units, dtype=int)\n    p_i = np.zeros(n_units)\n    cost_rates = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units and calculate cost rates\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        min_up = unit['t_on_min_i']\n        \n        # Forced status checks\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                \n        # Cost rate calculation\n        base_cost = a + b * p_min + c * p_min ** 2\n        if u_i0 == 1:  # Free online\n            cost_rates[i] = base_cost / p_min\n        else:          # Free offline\n            if next_load > current_load:\n                amortized_startup = s / (2 * max(1, min_up))\n            else:\n                amortized_startup = s / max(1, min_up)\n            cost_rates[i] = (base_cost + amortized_startup) / p_min\n\n    # Initialize commitment set\n    committed = set(forced_on)\n    candidates = sorted(free_online + free_offline, key=lambda i: cost_rates[i])\n    \n    # Calculate total capacity\n    def total_capacity(com_set):\n        total_min, total_max = 0, 0\n        for i in com_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1 or i in committed:  # Online or committed\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Offline unit to start\n                min_out = unit['p_min_i']\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_out\n            total_max += max_out\n        return total_min, total_max\n\n    # Add units until capacity meets demand\n    total_min, total_max = total_capacity(committed)\n    for i in candidates:\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        new_min = total_min + min_out\n        new_max = total_max + max_out\n        if new_max < current_load:\n            committed.add(i)\n            total_min, total_max = new_min, new_max\n        else:\n            break\n    \n    # Refine set if min capacity exceeds load\n    free_committed = sorted([i for i in committed if i not in forced_on], key=lambda i: cost_rates[i], reverse=True)\n    for i in free_committed:\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        test_min, test_max = total_capacity(committed - {i})\n        if test_min <= current_load and test_max >= current_load and total_min - min_out <= current_load:\n            committed.remove(i)\n            total_min, total_max = test_min, test_max\n    \n    # Power bounds for committed units\n    min_limits = np.zeros(n_units)\n    max_limits = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Newly started\n            min_limits[i] = unit['p_min_i']\n            max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Handle boundary conditions\n    def set_to_bounds(bound_type):\n        dispatch = np.zeros(n_units)\n        for i in committed:\n            dispatch[i] = min_limits[i] if bound_type == 'min' else max_limits[i]\n        return dispatch\n\n    if current_load <= total_min:\n        p_i = set_to_bounds('min')\n    elif current_load >= total_max:\n        p_i = set_to_bounds('max')\n    else:\n        # Newton-bisection hybrid for lambda iteration\n        a_arr = np.array([units_info[i]['a_i'] for i in committed])\n        b_arr = np.array([units_info[i]['b_i'] for i in committed])\n        c_arr = np.array([units_info[i]['c_i'] for i in committed])\n        min_arr = np.array([min_limits[i] for i in committed])\n        max_arr = np.array([max_limits[i] for i in committed])\n        \n        lamb_low = np.min(b_arr + 2 * c_arr * min_arr)\n        lamb_high = np.max(b_arr + 2 * c_arr * max_arr)\n        \n        def calc_total_p(lamb):\n            p_unclip = (lamb - b_arr) / (2 * c_arr + 1e-10)\n            p_clip = np.clip(p_unclip, min_arr, max_arr)\n            return p_clip, np.sum(p_clip)\n        \n        for _ in range(50):\n            lamb = (lamb_low + lamb_high) / 2\n            p_candidate, total_p = calc_total_p(lamb)\n            if abs(total_p - current_load) < 1e-3:\n                break\n            if total_p < current_load:\n                lamb_low = lamb\n            else:\n                lamb_high = lamb\n                \n        # Residual adjustment\n        _, total_p = calc_total_p(lamb)\n        residual = current_load - total_p\n        \n        if abs(residual) > 1e-3:\n            headroom_arr = max_arr - p_candidate\n            residual_sign = np.sign(residual)\n            \n            # Cost-prioritized adjustment\n            marg_costs = b_arr + 2 * c_arr * p_candidate\n            priority = np.argsort(marg_costs * residual_sign)\n            \n            for idx in priority:\n                adj_needed = min(abs(residual), headroom_arr[idx]) * residual_sign\n                p_candidate[idx] += adj_needed\n                residual -= adj_needed\n                if abs(residual) < 1e-3:\n                    break\n                    \n        # Map back to units\n        for ptr, i in enumerate(committed):\n            p_i[i] = max(min_limits[i], min(max_limits[i], p_candidate[ptr]))\n    \n    # Set commitment states\n    for i in range(n_units):\n        u_i[i] = 1 if i in committed else 0\n        if i not in committed:\n            p_i[i] = 0\n\n    return np.vstack([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.0064305425,
          "gap_price_rate": 0.007208568,
          "fitness": 0.0068195553
     },
     {
          "name": "refined_priority_amortized_dispatch_v1",
          "algorithm": "1. Classify units into must-run (forced-on), must-off (forced-off), free-online (adjustable/online), and free-offline (adjustable/offline) using min up/down times and shutdown constraints.\n2. For free-offline units, adjust startup cost amortization based on forecasted load: use half amortization if next load exceeds current load (indicating sustained need), else full amortization.\n3. Combine must-run units with free units sorted by amortized cost metric: (operating cost at min power) for free-online; (amortized startup cost + operating cost) for free-offline.\n4. Build commitment by adding free units in cost-ascending order until max capacity (considering ramp limits) meets current load.\n5. Remove expensive free units (descending cost order) if min capacity exceeds load while maintaining sufficient max capacity and feasible min capacity.\n6. Compute feasible power bounds considering ramp limits for online units and startup limits for new units.\n7. Dispatch load: set min/max outputs when load is outside total capacity bounds; use lambda iteration (bisection) for optimal dispatch within bounds.\n8. Set non-committed units to off state.\n\n",
          "code": "import numpy as np\n\ndef refined_priority_amortized_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    u_i_final = np.zeros(n_units)\n    p_i_final = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    cost_metric = [0] * n_units\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Compute cost metric with forecast-based amortization\n    for i in free_online:\n        a, b, c, p_min = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['p_min_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n    \n    for i in free_offline:\n        a, b, c, s, p_min = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i'], units_info[i]['p_min_i']\n        amort_factor = 0.5 if forecast_load > current_load else 1.0\n        adjusted_startup = s * amort_factor\n        cost_metric[i] = (adjusted_startup + a + b * p_min + c * p_min**2) / p_min\n    \n    # Build candidate list (must-run + sorted free units)\n    free_indices = free_online + free_offline\n    free_indices.sort(key=lambda i: cost_metric[i])\n    candidate_list = must_run + free_indices\n    \n    # Commit units by ascending cost until max capacity >= load\n    committed = set(must_run)\n    total_min = total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for i in must_run:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Add free units until load is satisfied\n    for i in free_indices:\n        if total_max >= current_load:\n            break\n        if i in free_online:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Remove non-essential units if over-committed (min capacity > load)\n    free_in_commit = [i for i in committed if i not in must_run]\n    free_in_commit.sort(key=lambda i: cost_metric[i], reverse=True)\n    for i in free_in_commit[:]:\n        unit = units_info[i]\n        if i in free_online:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        if (total_min - min_p) <= current_load and (total_max - max_p) >= current_load:\n            committed.remove(i)\n            total_min -= min_p\n            total_max -= max_p\n    \n    # Calculate bounds for committed units\n    min_bounds, max_bounds, b_coeffs, c_coeffs = [], [], [], []\n    for i in committed:\n        unit = units_info[i]\n        if i in free_online or i in must_run:\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds.append(min_b)\n        max_bounds.append(max_b)\n        b_coeffs.append(unit['b_i'])\n        c_coeffs.append(unit['c_i'])\n    \n    # Dispatch load to committed units\n    if current_load <= total_min:\n        outputs = min_bounds\n    elif current_load >= total_max:\n        outputs = max_bounds\n    else:\n        outputs = list(min_bounds)\n        remain = current_load - sum(outputs)\n        max_up = [max_bounds[j] - min_bounds[j] for j in range(len(committed))]\n        \n        # Bisection (lambda iteration) setup\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        lb = min(b_coeffs)  # Lower bound of lambda\n        ub = max(b_coeffs) + 2 * max(c_coeffs) * max(max_bounds)  # Upper bound of lambda\n        \n        while abs(remain) > tol and iter_count < max_iter:\n            lambda_val = (lb + ub) / 2\n            sum_p = 0\n            for j in range(len(committed)):\n                if c_coeffs[j] > 0:\n                    p = (lambda_val - b_coeffs[j]) / (2 * c_coeffs[j])\n                    p = max(min_bounds[j], min(p, max_bounds[j]))\n                    sum_p += p\n                else:\n                    # Linear cost (special case)\n                    p = max_bounds[j] if lambda_val > b_coeffs[j] else min_bounds[j]\n                    sum_p += p\n            if sum_p < current_load:\n                lb = lambda_val\n            else:\n                ub = lambda_val\n            remain = current_load - sum_p\n            iter_count += 1\n        \n        # Final output calculation\n        outputs = []\n        for j in range(len(committed)):\n            if c_coeffs[j] > 0:\n                p = (lambda_val - b_coeffs[j]) / (2 * c_coeffs[j])\n                outputs.append(max(min_bounds[j], min(p, max_bounds[j])))\n            else:\n                outputs.append(max_bounds[j] if lambda_val > b_coeffs[j] else min_bounds[j])\n    \n    # Prepare final schedules\n    committed_list = list(committed)\n    for idx, unit_idx in enumerate(committed_list):\n        u_i_final[unit_idx] = 1\n        p_i_final[unit_idx] = outputs[idx]\n    \n    schedules = np.array([u_i_final, p_i_final])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0050003774,
          "gap_price_rate": 0.0086673209,
          "fitness": 0.0068338492
     },
     {
          "name": "adaptive_amortized_dispatch_with_residual",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Calculate cost metrics for free units with forecast-based amortization: free online uses operating cost at min power; free offline amortizes startup cost over min up-time if next period's load is higher, otherwise over 1 period.\n3. Form candidate list sorted primarily by cost metric at min power and secondarily by cost at 50% capacity.\n4. Build committed set starting with forced-on units, then add free units by ascending cost until total max capacity (considering ramp/startup constraints) meets current load.\n5. Refine committed set: remove most expensive free units if min capacity exceeds load and next period's load is lower, while maintaining capacity adequacy.\n6. For committed units, calculate feasible power bounds considering ramp constraints (previously online) or startup limits (newly started).\n7. Dispatch load in three cases:\n   a) If load \u2264 total min, set all outputs to min bounds\n   b) If load \u2265 total max, set all outputs to max bounds\n   c) Else: solve via bisection for lambda, clamp outputs to bounds, then use greedy residual adjustment to exactly match load\n8. Set non-committed units to offline state with zero output.\n\n",
          "code": "import numpy as np\n\ndef adaptive_amortized_dispatch_with_residual(units_info, load):\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n    n_units = len(units_info)\n    \n    # Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    unit_cost_metric = [0] * n_units\n    secondary_metric = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            forced_on.append(i)\n        elif unit['u_i_0'] == 0 and (-unit['t_i_0'] < unit['t_off_min_i']):\n            forced_off.append(i)\n        else:\n            # Calculate cost metric\n            op_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if unit['u_i_0'] == 1:  # free online\n                unit_cost_metric[i] = op_cost_min / unit['p_min_i']\n                p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n                secondary_metric[i] = (unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * (p_mid ** 2)) / p_mid\n                free_online.append(i)\n            else:  # free offline\n                amort_period = unit['t_on_min_i'] if next_load >= current_load else 1\n                amort_cost = unit['s_i'] / amort_period\n                unit_cost_metric[i] = (op_cost_min + amort_cost) / unit['p_min_i']\n                p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n                secondary_metric[i] = (unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * (p_mid ** 2) + amort_cost) / p_mid\n                free_offline.append(i)\n    \n    # Combine free units and sort by metrics\n    free_units = free_online + free_offline\n    free_units.sort(key=lambda i: (unit_cost_metric[i], secondary_metric[i]))\n    \n    # Initialize committed set\n    committed_set = set(forced_on)\n    total_min_cap = 0.0\n    total_max_cap = 0.0\n    \n    # Calculate forced-on unit bounds and capacity\n    bounds_min = [0] * n_units\n    bounds_max = [0] * n_units\n    for i in committed_set:\n        u = units_info[i]\n        bounds_min[i] = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n        bounds_max[i] = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n        total_min_cap += bounds_min[i]\n        total_max_cap += bounds_max[i]\n    \n    # Add free units until sufficient capacity\n    for i in free_units:\n        if total_max_cap >= current_load:\n            break\n        u = units_info[i]\n        if u['u_i_0'] == 1:  # free online\n            min_bound = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n            max_bound = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n        else:  # free offline\n            min_bound = u['p_min_i']\n            max_bound = min(u['p_max_i'], u['p_start_i'])\n        \n        # Temporarily add unit\n        committed_set.add(i)\n        bounds_min[i] = min_bound\n        bounds_max[i] = max_bound\n        total_min_cap += min_bound\n        total_max_cap += max_bound\n    \n    # Refine by removing expensive free units if possible\n    removable = sorted((i for i in committed_set if i not in forced_on), \n                       key=lambda i: unit_cost_metric[i], reverse=True)\n    for i in removable:\n        if (total_min_cap - bounds_min[i] <= current_load and \n            total_max_cap - bounds_max[i] >= current_load and \n            next_load < current_load):\n            committed_set.remove(i)\n            total_min_cap -= bounds_min[i]\n            total_max_cap -= bounds_max[i]\n    \n    # Dispatch preparation\n    dispatch_min = [bounds_min[i] for i in committed_set]\n    dispatch_max = [bounds_max[i] for i in committed_set]\n    b_list = [units_info[i]['b_i'] for i in committed_set]\n    c_list = [max(units_info[i]['c_i'], 1e-10) for i in committed_set]  # Handle c_i=0\n    \n    # Case 1: load <= total min\n    if current_load <= total_min_cap:\n        p_outputs = [bounds_min[i] for i in range(n_units)]\n    # Case 2: load >= total max\n    elif current_load >= total_max_cap:\n        p_outputs = [bounds_max[i] for i in range(n_units)]\n    # Case 3: Economic dispatch\n    else:\n        # Initialize dispatch array with min outputs\n        p_current = dispatch_min.copy()\n        residual = current_load - total_min_cap\n        \n        # Bisection setup\n        lb = min([b_list[i] + 2 * c_list[i] * dispatch_min[i] for i in range(len(committed_set))])\n        ub = max([b_list[i] + 2 * c_list[i] * dispatch_max[i] for i in range(len(committed_set))])\n        total_power = total_min_cap\n        epsilon = 0.1  # MW tolerance\n        max_iter = 1000\n        iter_count = 0\n        \n        # Bisection for lambda\n        while iter_count < max_iter and ub - lb > 1e-9:\n            lam = (lb + ub) / 2\n            total_power = 0\n            for i in range(len(committed_set)):\n                unconstrained = (lam - b_list[i]) / (2 * c_list[i])\n                p_current[i] = max(dispatch_min[i], min(dispatch_max[i], unconstrained))\n                total_power += p_current[i]\n            \n            if abs(total_power - current_load) < epsilon:\n                break\n            if total_power < current_load:\n                lb = lam\n            else:\n                ub = lam\n            iter_count += 1\n        \n        # Greedy residual adjustment\n        residual = current_load - total_power\n        while abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = []\n                for i in range(len(committed_set)):\n                    if p_current[i] < dispatch_max[i] - 1e-5:\n                        ic = b_list[i] + 2 * c_list[i] * p_current[i]\n                        room = dispatch_max[i] - p_current[i]\n                        candidates.append((ic, i, room))\n                if not candidates:\n                    break\n                ic, idx, room = min(candidates, key=lambda x: x[0])\n                delta = min(room, residual)\n                p_current[idx] += delta\n                residual -= delta\n            else:\n                candidates = []\n                for i in range(len(committed_set)):\n                    if p_current[i] > dispatch_min[i] + 1e-5:\n                        ic = b_list[i] + 2 * c_list[i] * p_current[i]\n                        room = p_current[i] - dispatch_min[i]\n                        candidates.append((ic, i, room))\n                if not candidates:\n                    break\n                ic, idx, room = max(candidates, key=lambda x: x[0])\n                delta = min(room, -residual)\n                p_current[idx] -= delta\n                residual += delta\n        \n        # Assign outputs for committed units\n        p_outputs = [0] * n_units\n        committed_list = list(committed_set)\n        for idx, i in enumerate(committed_list):\n            p_outputs[i] = p_current[idx]\n    \n    # Set outputs for all units\n    u_outputs = [1 if i in committed_set else 0 for i in range(n_units)]\n    for i in range(n_units):\n        if u_outputs[i] == 0:\n            p_outputs[i] = 0\n    \n    # Format result\n    schedules = np.array([u_outputs, p_outputs])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0049898532,
          "gap_price_rate": 0.0087014794,
          "fitness": 0.0068456663
     },
     {
          "name": "combined_amortized_with_refined_forecast",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization (s_i/(2\u00b7t_on_min_i)) if next period's load \u2265 current load, else full amortization (s_i/t_on_min_i).\n3. Compute cost rates (amortized startup cost + production cost at min output) / min output for free offline units, and production cost at min output / min output for free online units.\n4. Build candidate commitment set: start with forced-on units. Add free online/offline units in ascending cost rate order until ramp-constrained max capacity \u2265 current load.\n5. Refine commitment: sort added free units by cost rate descending. Iteratively remove units if removal maintains capacity adequacy (min capacity \u2264 load \u2264 max capacity).\n6. Calculate feasible bounds: [max(p_min_i, p_i_0-p_down_i), min(p_max_i, p_i_0+p_up_i)] for previously online units; [p_min_i, min(p_max_i, p_start_i)] for newly started units.\n7. Dispatch via three-stage method:\n   a) Boundary: set all outputs to min if load \u2264 total min; max if load \u2265 total max\n   b) Lambda iteration using bisection to set optimal dispatch with analytical derivatives\n   c) Greedy residual adjustment using marginal cost prioritization to exactly match load\n8. Set non-committed units to off state (u_i=0, p_i=0).\n9. Return schedules as 2D array: first row is commitment states u_i, second row is power outputs p_i.\n\n",
          "code": "import numpy as np\n\ndef combined_amortized_with_refined_forecast(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_online_indices = []\n    free_offline_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on_indices.append(i)\n            else:\n                free_online_indices.append(i)\n        else:\n            offline_time = -unit['t_i_0']\n            if offline_time < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                free_offline_indices.append(i)\n    \n    bounds_min = np.zeros(n_units)\n    bounds_max = np.zeros(n_units)\n    for i in forced_on_indices:\n        unit = units_info[i]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds_min[i] = min_bound\n        bounds_max[i] = max_bound\n    \n    committed_indices = forced_on_indices.copy()\n    total_min = np.sum(bounds_min[committed_indices])\n    total_max = np.sum(bounds_max[committed_indices])\n    \n    cost_rates = []\n    for i in free_online_indices:\n        unit = units_info[i]\n        prod_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n        cost_rate = prod_cost / unit['p_min_i']\n        cost_rates.append((cost_rate, i, 'online'))\n    \n    for i in free_offline_indices:\n        unit = units_info[i]\n        startup_cost = unit['s_i'] / (2 * unit['t_on_min_i']) if next_load >= current_load else unit['s_i'] / unit['t_on_min_i']\n        prod_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n        cost_rate = (startup_cost + prod_cost) / unit['p_min_i']\n        cost_rates.append((cost_rate, i, 'offline'))\n    \n    cost_rates.sort(key=lambda x: x[0])\n    \n    for rate, i, unit_type in cost_rates:\n        if total_max < current_load:\n            unit = units_info[i]\n            if unit_type == 'online':\n                min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_b = unit['p_min_i']\n                max_b = min(unit['p_max_i'], unit['p_start_i'])\n            bounds_min[i] = min_b\n            bounds_max[i] = max_b\n            committed_indices.append(i)\n            total_min += min_b\n            total_max += max_b\n        else:\n            break\n    \n    free_added = [i for i in committed_indices if i in free_online_indices or i in free_offline_indices]\n    free_rates = []\n    for i in free_added:\n        unit = units_info[i]\n        if i in free_online_indices:\n            prod_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n            rate = prod_cost / unit['p_min_i']\n        else:\n            startup_cost = unit['s_i'] / (2 * unit['t_on_min_i']) if next_load >= current_load else unit['s_i'] / unit['t_on_min_i']\n            prod_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n            rate = (startup_cost + prod_cost) / unit['p_min_i']\n        free_rates.append((rate, i))\n    \n    free_rates.sort(key=lambda x: x[0], reverse=True)\n    \n    for rate, i in free_rates:\n        trial_min = total_min - bounds_min[i]\n        trial_max = total_max - bounds_max[i]\n        if trial_min <= current_load <= trial_max:\n            committed_indices.remove(i)\n            total_min = trial_min\n            total_max = trial_max\n    \n    u_out[committed_indices] = 1\n    min_bounds = [bounds_min[i] for i in committed_indices]\n    max_bounds = [bounds_max[i] for i in committed_indices]\n    \n    if current_load <= total_min:\n        for idx, i in enumerate(committed_indices):\n            p_out[i] = min_bounds[idx]\n    elif current_load >= total_max:\n        for idx, i in enumerate(committed_indices):\n            p_out[i] = max_bounds[idx]\n    else:\n        low = 0.0\n        high = 1e6\n        tol = 1e-3\n        max_iter = 50\n        mid = 0\n        unit_list = [units_info[i] for i in committed_indices]\n        n_committed = len(committed_indices)\n        \n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_p = 0.0\n            for idx in range(n_committed):\n                unit = unit_list[idx]\n                min_b = min_bounds[idx]\n                max_b = max_bounds[idx]\n                if unit['c_i'] > 0:\n                    p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(min_b, min(max_b, p_val))\n                    total_p += p_val\n                else:\n                    p_val = max_b if mid > unit['b_i'] else min_b\n                    total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                break\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        p_temp = np.zeros(len(committed_indices))\n        total_p = 0\n        for idx in range(n_committed):\n            unit = unit_list[idx]\n            min_b = min_bounds[idx]\n            max_b = max_bounds[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_b, min(max_b, p_val))\n            else:\n                p_val = max_b if mid > unit['b_i'] else min_b\n            p_temp[idx] = p_val\n            total_p += p_val\n        \n        residual = current_load - total_p\n        if abs(residual) > tol:\n            marginal_costs = []\n            for idx in range(n_committed):\n                unit = unit_list[idx]\n                current_p = p_temp[idx]\n                if unit['c_i'] > 0:\n                    mc = 2 * unit['c_i'] * current_p + unit['b_i']\n                else:\n                    mc = unit['b_i']\n                room = max_bounds[idx] - current_p if residual > 0 else current_p - min_bounds[idx]\n                if room > tol:\n                    marginal_costs.append((mc, idx))\n            \n            if residual > 0:\n                marginal_costs.sort(key=lambda x: x[0])\n                for mc, idx in marginal_costs:\n                    delta = min(residual, max_bounds[idx] - p_temp[idx])\n                    p_temp[idx] += delta\n                    residual -= delta\n                    if abs(residual) < tol:\n                        break\n            else:\n                marginal_costs.sort(key=lambda x: -x[0])\n                residual_abs = abs(residual)\n                for mc, idx in marginal_costs:\n                    delta = min(residual_abs, p_temp[idx] - min_bounds[idx])\n                    p_temp[idx] -= delta\n                    residual_abs -= delta\n                    if abs(residual_abs) < tol:\n                        residual = 0\n                        break\n        \n        for idx, i in enumerate(committed_indices):\n            p_out[i] = p_temp[idx]\n    \n    schedules = np.vstack((u_out, p_out))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0050588865,
          "gap_price_rate": 0.0087370322,
          "fitness": 0.0068979593
     }
]