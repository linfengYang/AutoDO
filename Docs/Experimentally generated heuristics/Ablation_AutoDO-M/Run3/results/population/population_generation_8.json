[
     {
          "name": "refined_amortized_with_forecast",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp), forced-off (violating min down-time), free online (adjustable online), free offline (adjustable offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization over min up-time if next load >= current load (indicating sustained need), else full amortization.\n3. Precompute cost metrics: operating cost at min power for free online; amortized startup cost plus operating cost for free offline.\n4. Build initial commitment set: forced-on units then free units in ascending cost order until ramp-constrained max capacity >= current load.\n5. Refine committed set: sort free units by cost descending and iteratively remove while maintaining max capacity >= load and reducing min capacity \u2264 load.\n6. For committed units, calculate bounds: previously online consider ramp limits; newly started consider startup ramp limits.\n7. Dispatch in three stages:\n   a) Boundary handling: set outputs to min or max if load out of bounds.\n   b) Bisection for lambda iteration with analytical derivative for quadratic units.\n   c) Discrete settings and residual adjustment for linear units.\n\n",
          "code": "import numpy as np\n\ndef refined_amortized_with_forecast(units_info, load):\n    L_current, L_next = load[0], load[1]\n    num_units = len(units_info)\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < t_up_min or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -t0 < t_down_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        t_min_up = unit['t_on_min_i']\n        if L_next >= L_current:\n            amortized_startup = s / (2 * t_min_up)\n        else:\n            amortized_startup = s / t_min_up\n        cost_metric[i] = (amortized_startup + a + b * p_min + c * p_min**2) / p_min\n\n    committed_set = set(forced_on)\n    free_sorted = sorted(free_online + free_offline, key=lambda i: cost_metric.get(i, float('inf')))\n    total_max = 0.0\n    for i in committed_set:\n        unit = units_info[i]\n        total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for i in free_sorted:\n        if total_max >= L_current:\n            break\n        unit = units_info[i]\n        max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if i in free_online else min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_cap\n        committed_set.add(i)\n    \n    total_min = 0.0\n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_cap\n        bounds[i] = (min_cap, max_cap)\n    \n    free_committed = [i for i in committed_set if i in free_online or i in free_offline]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric.get(i, 0), reverse=True)\n    for i in free_committed_sorted:\n        min_cap, max_cap = bounds[i]\n        new_total_min = total_min - min_cap\n        new_total_max = total_max - max_cap\n        if new_total_min <= L_current and new_total_max >= L_current:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (min_cap, max_cap)\n    \n    total_min = sum(bounds[i][0] for i in committed_set)\n    total_max = sum(bounds[i][1] for i in committed_set)\n    \n    quadratic_units = []\n    linear_units = []\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['c_i'] > 0:\n            quadratic_units.append(i)\n        else:\n            linear_units.append(i)\n    \n    if L_current <= total_min:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][0]\n    elif L_current >= total_max:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][1]\n    else:\n        p_vals = {}\n        residual = L_current\n        for i in linear_units:\n            unit = units_info[i]\n            _, max_cap = bounds[i]\n            if unit['b_i'] <= unit['a_i'] / max_cap + unit['b_i']:\n                p_vals[i] = max_cap\n            else:\n                p_vals[i] = bounds[i][0]\n            residual -= p_vals[i]\n        \n        if quadratic_units:\n            low, high = 0, 0\n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                low = min(low, unit['b_i'] + 2 * unit['c_i'] * min_cap)\n                high = max(high, unit['b_i'] + 2 * unit['c_i'] * max_cap)\n            \n            tol = 1e-3\n            max_iter = 100\n            for _ in range(max_iter):\n                mid = (low + high) / 2\n                total_power = residual\n                for i in quadratic_units:\n                    unit = units_info[i]\n                    min_cap, max_cap = bounds[i]\n                    p = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                    total_power += p\n                if abs(total_power) < tol:\n                    break\n                if total_power < 0:\n                    high = mid\n                else:\n                    low = mid\n            \n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                p_vals[i] = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                residual -= p_vals[i]\n        \n        if abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = bounds[i][1] - current_p\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) + adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n            else:\n                residual = abs(residual)\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = current_p - bounds[i][0]\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: -x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) - adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n        \n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = p_vals.get(i, bounds[i][0])\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0031320448,
          "gap_price_rate": 0.0067061217,
          "fitness": 0.0049190833
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to minimum up-time or shutdown ramp constraints), forced-off (must remain offline due to minimum down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Precompute cost metrics for free units:\n   - Free online: cost rate = (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: cost rate = (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate commitment set starting with forced-on units, then add free units sorted by ascending cost rate until total ramp-constrained max capacity \u2265 current load. Precompute ramp-constrained min/max for each unit during classification.\n4. Refine commitment by removing expensive free units:\n   - Sort committed free units by cost rate descending\n   - Iteratively remove the most expensive unit if removal maintains max capacity \u2265 load and reduces min capacity below or equal to load\n5. Calculate dispatch bounds for committed units considering startup/shutdown ramps and online ramp constraints:\n   - Previously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Newly started units: [p_min_i, min(p_max_i, p_start_i)]\n6. Perform economic dispatch using optimized lambda iteration:\n   - Handle boundary cases where load \u2264 total min or \u2265 total max\n   - Use bisection with analytical derivative for faster convergence\n   - Distribute residual with priority-based greedy adjustment to ensure exact load matching\n7. Set non-committed units to offline state (u_i=0, p_i=0).\n8. Return commitment states and power outputs as a 2D NumPy array.\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = [0] * n_units\n    p_schedule = [0] * n_units\n    \n    # Data structures to store processed unit information\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    processed_units = [None] * n_units\n    \n    # Classify units and precompute parameters\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        forced_on_flag = False\n        forced_off_flag = False\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on_flag = True\n                forced_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:  # Currently offline\n            if -t0 < unit['t_off_min_i']:\n                forced_off_flag = True\n                forced_off.append(idx)\n            else:\n                free_offline.append(idx)\n                \n        # Precompute ramp-constrained boundaries\n        if u0 == 1:  # Online units\n            min_p = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline units\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate amortized cost rate for free units\n        if not (forced_on_flag or forced_off_flag):\n            operating_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if u0 == 1:  # Free online\n                cost_rate = operating_cost_min / unit['p_min_i']\n            else:  # Free offline\n                startup_amortized = unit['s_i'] / unit['t_on_min_i']\n                cost_rate = (operating_cost_min + startup_amortized) / unit['p_min_i']\n        else:\n            cost_rate = float('inf') if forced_off_flag else -float('inf')\n        \n        processed_units[idx] = {\n            'idx': idx,\n            'u0': u0,\n            'forced_on': forced_on_flag,\n            'forced_off': forced_off_flag,\n            'min_bound': min_p,\n            'max_bound': max_p,\n            'cost_rate': cost_rate,\n            'b': unit['b_i'],\n            'c': unit['c_i']\n        }\n    \n    # Initialize commitment set with forced-on units\n    committed_set = set(forced_on)\n    total_min = sum(processed_units[idx]['min_bound'] for idx in forced_on)\n    total_max = sum(processed_units[idx]['max_bound'] for idx in forced_on)\n    \n    # Candidate free units sorted by cost rate (ascending)\n    free_candidates = free_online + free_offline\n    free_candidates.sort(key=lambda idx: processed_units[idx]['cost_rate'])\n    \n    # Add free units until capacity meets or exceeds load\n    for idx in free_candidates:\n        if total_max < current_load:\n            committed_set.add(idx)\n            total_min += processed_units[idx]['min_bound']\n            total_max += processed_units[idx]['max_bound']\n        else:\n            break\n    \n    # Remove expensive free units if min capacity exceeds load\n    free_in_commit = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_in_commit.sort(key=lambda idx: processed_units[idx]['cost_rate'], reverse=True)\n    removed = True\n    while removed and total_min > current_load:\n        removed = False\n        for idx in free_in_commit:\n            unit = processed_units[idx]\n            new_min = total_min - unit['min_bound']\n            new_max = total_max - unit['max_bound']\n            if new_max >= current_load:\n                committed_set.remove(idx)\n                total_min = new_min\n                total_max = new_max\n                free_in_commit.remove(idx)\n                removed = True\n                break\n    \n    # Prepare dispatch units with valid bounds\n    dispatch_units = []\n    for idx in committed_set:\n        unit = processed_units[idx]\n        min_bound = unit['min_bound']\n        max_bound = unit['max_bound']\n        \n        # Ensure bounds are valid\n        if min_bound > max_bound:\n            min_bound = max_bound = (min_bound + max_bound) / 2\n            \n        dispatch_units.append({\n            'min': min_bound,\n            'max': max_bound,\n            'b': unit['b'],\n            'c': unit['c'],\n            'idx': idx\n        })\n    \n    # Calculate total dispatch bounds\n    total_min_dispatch = sum(unit['min'] for unit in dispatch_units)\n    total_max_dispatch = sum(unit['max'] for unit in dispatch_units)\n    \n    # Handle boundary cases\n    if current_load <= total_min_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['min']\n    elif current_load >= total_max_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['max']\n    else:\n        # Lambda iteration (bisection) with derivative for speed\n        low_lambda = 0\n        high_lambda = 1e6\n        tolerance = 1e-5\n        iterations = 0\n        \n        while iterations < 100 and (high_lambda - low_lambda) > tolerance:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            derivative_sum = 0\n            \n            for unit in dispatch_units:\n                c = unit['c']\n                if c == 0:  # Linear cost function\n                    p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n                else:\n                    p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                    p = max(unit['min'], min(unit['max'], p_unclamped))\n                \n                unit['p_temp'] = p\n                total_power += p\n                \n                if unit['min'] < p < unit['max']:\n                    derivative_sum += 1 / (2 * c)\n            \n            if derivative_sum == 0:  # All units at bounds\n                if total_power < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            else:\n                lambda_derivative = derivative_sum\n                error = total_power - current_load\n                mid_lambda -= error / lambda_derivative\n                \n                if total_power > current_load:\n                    high_lambda = mid_lambda\n                else:\n                    low_lambda = mid_lambda\n            \n            iterations += 1\n        \n        # Final power calculation\n        total_power = 0\n        for unit in dispatch_units:\n            c = unit['c']\n            if c == 0:\n                p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n            else:\n                p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                p = max(unit['min'], min(unit['max'], p_unclamped))\n            unit['p_temp'] = p\n            total_power += p\n        \n        # Adjust for residual with greedy method\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            if residual > 0:\n                candidates = [u for u in dispatch_units if u['p_temp'] < u['max']]\n                candidates.sort(key=lambda u: u['b'] + 2 * u['c'] * u['p_temp'])\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['max'] - unit['p_temp']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] += adjust\n                    residual -= adjust\n            else:\n                residual = abs(residual)\n                candidates = [u for u in dispatch_units if u['p_temp'] > u['min']]\n                candidates.sort(key=lambda u: -(u['b'] + 2 * u['c'] * u['p_temp']))\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['p_temp'] - unit['min']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] -= adjust\n                    residual -= adjust\n        \n        # Assign final dispatch values\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['p_temp']\n    \n    # Set commitment states\n    for idx in committed_set:\n        u_schedule[idx] = 1\n    \n    return np.array([u_schedule, p_schedule])",
          "from": "mutation",
          "gap_power_rate": 0.0033675075,
          "gap_price_rate": 0.0081376386,
          "fitness": 0.0057525731
     },
     {
          "name": "enhanced_amortized_cost_dispatch_forecast",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization (s_i / (2 * t_on_min_i)) if next period's load is greater than current load, else full amortization (s_i / t_on_min_i).\n3. Build candidate commitment set starting with forced-on units, then add free units sorted by ascending cost metric (operating cost at min power for free online; amortized startup cost plus operating cost at min power for free offline).\n4. Refine commitment set:\n   a. While total ramp-constrained max capacity < current load: add next cheapest free unit\n   b. While total ramp-constrained min capacity > load: remove most expensive free unit if removal maintains max capacity \u2265 load\n5. Calculate feasible power bounds for committed units:\n   a. Previously online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   b. Newly started: [p_min_i, min(p_max_i, p_start_i)]\n6. Dispatch load using multi-stage method:\n   a. Boundary cases: set all outputs to min if load \u2264 total min; set all to max if load \u2265 total max\n   b. Use Newton-bisection hybrid for lambda iteration\n   c. Adjust residuals using cost-prioritized greedy method respecting ramp constraints\n7. Set non-committed units to offline (u_i=0, p_i=0).\n8. Return schedules as 2D NumPy array.\n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch_forecast(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n\n    # Initialize arrays\n    u_i = np.zeros(n_units, dtype=int)\n    p_i = np.zeros(n_units)\n    cost_rates = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units and calculate cost rates\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        min_up = unit['t_on_min_i']\n        \n        # Forced status checks\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                \n        # Cost rate calculation\n        base_cost = a + b * p_min + c * p_min ** 2\n        if u_i0 == 1:  # Free online\n            cost_rates[i] = base_cost / p_min\n        else:          # Free offline\n            if next_load > current_load:\n                amortized_startup = s / (2 * max(1, min_up))\n            else:\n                amortized_startup = s / max(1, min_up)\n            cost_rates[i] = (base_cost + amortized_startup) / p_min\n\n    # Initialize commitment set\n    committed = set(forced_on)\n    candidates = sorted(free_online + free_offline, key=lambda i: cost_rates[i])\n    \n    # Calculate total capacity\n    def total_capacity(com_set):\n        total_min, total_max = 0, 0\n        for i in com_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1 or i in committed:  # Online or committed\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Offline unit to start\n                min_out = unit['p_min_i']\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_out\n            total_max += max_out\n        return total_min, total_max\n\n    # Add units until capacity meets demand\n    total_min, total_max = total_capacity(committed)\n    for i in candidates:\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        new_min = total_min + min_out\n        new_max = total_max + max_out\n        if new_max < current_load:\n            committed.add(i)\n            total_min, total_max = new_min, new_max\n        else:\n            break\n    \n    # Refine set if min capacity exceeds load\n    free_committed = sorted([i for i in committed if i not in forced_on], key=lambda i: cost_rates[i], reverse=True)\n    for i in free_committed:\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        test_min, test_max = total_capacity(committed - {i})\n        if test_min <= current_load and test_max >= current_load and total_min - min_out <= current_load:\n            committed.remove(i)\n            total_min, total_max = test_min, test_max\n    \n    # Power bounds for committed units\n    min_limits = np.zeros(n_units)\n    max_limits = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Newly started\n            min_limits[i] = unit['p_min_i']\n            max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Handle boundary conditions\n    def set_to_bounds(bound_type):\n        dispatch = np.zeros(n_units)\n        for i in committed:\n            dispatch[i] = min_limits[i] if bound_type == 'min' else max_limits[i]\n        return dispatch\n\n    if current_load <= total_min:\n        p_i = set_to_bounds('min')\n    elif current_load >= total_max:\n        p_i = set_to_bounds('max')\n    else:\n        # Newton-bisection hybrid for lambda iteration\n        a_arr = np.array([units_info[i]['a_i'] for i in committed])\n        b_arr = np.array([units_info[i]['b_i'] for i in committed])\n        c_arr = np.array([units_info[i]['c_i'] for i in committed])\n        min_arr = np.array([min_limits[i] for i in committed])\n        max_arr = np.array([max_limits[i] for i in committed])\n        \n        lamb_low = np.min(b_arr + 2 * c_arr * min_arr)\n        lamb_high = np.max(b_arr + 2 * c_arr * max_arr)\n        \n        def calc_total_p(lamb):\n            p_unclip = (lamb - b_arr) / (2 * c_arr + 1e-10)\n            p_clip = np.clip(p_unclip, min_arr, max_arr)\n            return p_clip, np.sum(p_clip)\n        \n        for _ in range(50):\n            lamb = (lamb_low + lamb_high) / 2\n            p_candidate, total_p = calc_total_p(lamb)\n            if abs(total_p - current_load) < 1e-3:\n                break\n            if total_p < current_load:\n                lamb_low = lamb\n            else:\n                lamb_high = lamb\n                \n        # Residual adjustment\n        _, total_p = calc_total_p(lamb)\n        residual = current_load - total_p\n        \n        if abs(residual) > 1e-3:\n            headroom_arr = max_arr - p_candidate\n            residual_sign = np.sign(residual)\n            \n            # Cost-prioritized adjustment\n            marg_costs = b_arr + 2 * c_arr * p_candidate\n            priority = np.argsort(marg_costs * residual_sign)\n            \n            for idx in priority:\n                adj_needed = min(abs(residual), headroom_arr[idx]) * residual_sign\n                p_candidate[idx] += adj_needed\n                residual -= adj_needed\n                if abs(residual) < 1e-3:\n                    break\n                    \n        # Map back to units\n        for ptr, i in enumerate(committed):\n            p_i[i] = max(min_limits[i], min(max_limits[i], p_candidate[ptr]))\n    \n    # Set commitment states\n    for i in range(n_units):\n        u_i[i] = 1 if i in committed else 0\n        if i not in committed:\n            p_i[i] = 0\n\n    return np.vstack([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.0064305425,
          "gap_price_rate": 0.007208568,
          "fitness": 0.0068195553
     },
     {
          "name": "refined_priority_amortized_dispatch_v1",
          "algorithm": "1. Classify units into must-run (forced-on), must-off (forced-off), free-online (adjustable/online), and free-offline (adjustable/offline) using min up/down times and shutdown constraints.\n2. For free-offline units, adjust startup cost amortization based on forecasted load: use half amortization if next load exceeds current load (indicating sustained need), else full amortization.\n3. Combine must-run units with free units sorted by amortized cost metric: (operating cost at min power) for free-online; (amortized startup cost + operating cost) for free-offline.\n4. Build commitment by adding free units in cost-ascending order until max capacity (considering ramp limits) meets current load.\n5. Remove expensive free units (descending cost order) if min capacity exceeds load while maintaining sufficient max capacity and feasible min capacity.\n6. Compute feasible power bounds considering ramp limits for online units and startup limits for new units.\n7. Dispatch load: set min/max outputs when load is outside total capacity bounds; use lambda iteration (bisection) for optimal dispatch within bounds.\n8. Set non-committed units to off state.\n\n",
          "code": "import numpy as np\n\ndef refined_priority_amortized_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    u_i_final = np.zeros(n_units)\n    p_i_final = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    cost_metric = [0] * n_units\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Compute cost metric with forecast-based amortization\n    for i in free_online:\n        a, b, c, p_min = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['p_min_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n    \n    for i in free_offline:\n        a, b, c, s, p_min = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i'], units_info[i]['p_min_i']\n        amort_factor = 0.5 if forecast_load > current_load else 1.0\n        adjusted_startup = s * amort_factor\n        cost_metric[i] = (adjusted_startup + a + b * p_min + c * p_min**2) / p_min\n    \n    # Build candidate list (must-run + sorted free units)\n    free_indices = free_online + free_offline\n    free_indices.sort(key=lambda i: cost_metric[i])\n    candidate_list = must_run + free_indices\n    \n    # Commit units by ascending cost until max capacity >= load\n    committed = set(must_run)\n    total_min = total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for i in must_run:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Add free units until load is satisfied\n    for i in free_indices:\n        if total_max >= current_load:\n            break\n        if i in free_online:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Remove non-essential units if over-committed (min capacity > load)\n    free_in_commit = [i for i in committed if i not in must_run]\n    free_in_commit.sort(key=lambda i: cost_metric[i], reverse=True)\n    for i in free_in_commit[:]:\n        unit = units_info[i]\n        if i in free_online:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        if (total_min - min_p) <= current_load and (total_max - max_p) >= current_load:\n            committed.remove(i)\n            total_min -= min_p\n            total_max -= max_p\n    \n    # Calculate bounds for committed units\n    min_bounds, max_bounds, b_coeffs, c_coeffs = [], [], [], []\n    for i in committed:\n        unit = units_info[i]\n        if i in free_online or i in must_run:\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds.append(min_b)\n        max_bounds.append(max_b)\n        b_coeffs.append(unit['b_i'])\n        c_coeffs.append(unit['c_i'])\n    \n    # Dispatch load to committed units\n    if current_load <= total_min:\n        outputs = min_bounds\n    elif current_load >= total_max:\n        outputs = max_bounds\n    else:\n        outputs = list(min_bounds)\n        remain = current_load - sum(outputs)\n        max_up = [max_bounds[j] - min_bounds[j] for j in range(len(committed))]\n        \n        # Bisection (lambda iteration) setup\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        lb = min(b_coeffs)  # Lower bound of lambda\n        ub = max(b_coeffs) + 2 * max(c_coeffs) * max(max_bounds)  # Upper bound of lambda\n        \n        while abs(remain) > tol and iter_count < max_iter:\n            lambda_val = (lb + ub) / 2\n            sum_p = 0\n            for j in range(len(committed)):\n                if c_coeffs[j] > 0:\n                    p = (lambda_val - b_coeffs[j]) / (2 * c_coeffs[j])\n                    p = max(min_bounds[j], min(p, max_bounds[j]))\n                    sum_p += p\n                else:\n                    # Linear cost (special case)\n                    p = max_bounds[j] if lambda_val > b_coeffs[j] else min_bounds[j]\n                    sum_p += p\n            if sum_p < current_load:\n                lb = lambda_val\n            else:\n                ub = lambda_val\n            remain = current_load - sum_p\n            iter_count += 1\n        \n        # Final output calculation\n        outputs = []\n        for j in range(len(committed)):\n            if c_coeffs[j] > 0:\n                p = (lambda_val - b_coeffs[j]) / (2 * c_coeffs[j])\n                outputs.append(max(min_bounds[j], min(p, max_bounds[j])))\n            else:\n                outputs.append(max_bounds[j] if lambda_val > b_coeffs[j] else min_bounds[j])\n    \n    # Prepare final schedules\n    committed_list = list(committed)\n    for idx, unit_idx in enumerate(committed_list):\n        u_i_final[unit_idx] = 1\n        p_i_final[unit_idx] = outputs[idx]\n    \n    schedules = np.array([u_i_final, p_i_final])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0050003774,
          "gap_price_rate": 0.0086673209,
          "fitness": 0.0068338492
     },
     {
          "name": "adaptive_amortized_dispatch_with_residual",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Calculate cost metrics for free units with forecast-based amortization: free online uses operating cost at min power; free offline amortizes startup cost over min up-time if next period's load is higher, otherwise over 1 period.\n3. Form candidate list sorted primarily by cost metric at min power and secondarily by cost at 50% capacity.\n4. Build committed set starting with forced-on units, then add free units by ascending cost until total max capacity (considering ramp/startup constraints) meets current load.\n5. Refine committed set: remove most expensive free units if min capacity exceeds load and next period's load is lower, while maintaining capacity adequacy.\n6. For committed units, calculate feasible power bounds considering ramp constraints (previously online) or startup limits (newly started).\n7. Dispatch load in three cases:\n   a) If load \u2264 total min, set all outputs to min bounds\n   b) If load \u2265 total max, set all outputs to max bounds\n   c) Else: solve via bisection for lambda, clamp outputs to bounds, then use greedy residual adjustment to exactly match load\n8. Set non-committed units to offline state with zero output.\n\n",
          "code": "import numpy as np\n\ndef adaptive_amortized_dispatch_with_residual(units_info, load):\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n    n_units = len(units_info)\n    \n    # Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    unit_cost_metric = [0] * n_units\n    secondary_metric = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            forced_on.append(i)\n        elif unit['u_i_0'] == 0 and (-unit['t_i_0'] < unit['t_off_min_i']):\n            forced_off.append(i)\n        else:\n            # Calculate cost metric\n            op_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if unit['u_i_0'] == 1:  # free online\n                unit_cost_metric[i] = op_cost_min / unit['p_min_i']\n                p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n                secondary_metric[i] = (unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * (p_mid ** 2)) / p_mid\n                free_online.append(i)\n            else:  # free offline\n                amort_period = unit['t_on_min_i'] if next_load >= current_load else 1\n                amort_cost = unit['s_i'] / amort_period\n                unit_cost_metric[i] = (op_cost_min + amort_cost) / unit['p_min_i']\n                p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n                secondary_metric[i] = (unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * (p_mid ** 2) + amort_cost) / p_mid\n                free_offline.append(i)\n    \n    # Combine free units and sort by metrics\n    free_units = free_online + free_offline\n    free_units.sort(key=lambda i: (unit_cost_metric[i], secondary_metric[i]))\n    \n    # Initialize committed set\n    committed_set = set(forced_on)\n    total_min_cap = 0.0\n    total_max_cap = 0.0\n    \n    # Calculate forced-on unit bounds and capacity\n    bounds_min = [0] * n_units\n    bounds_max = [0] * n_units\n    for i in committed_set:\n        u = units_info[i]\n        bounds_min[i] = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n        bounds_max[i] = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n        total_min_cap += bounds_min[i]\n        total_max_cap += bounds_max[i]\n    \n    # Add free units until sufficient capacity\n    for i in free_units:\n        if total_max_cap >= current_load:\n            break\n        u = units_info[i]\n        if u['u_i_0'] == 1:  # free online\n            min_bound = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n            max_bound = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n        else:  # free offline\n            min_bound = u['p_min_i']\n            max_bound = min(u['p_max_i'], u['p_start_i'])\n        \n        # Temporarily add unit\n        committed_set.add(i)\n        bounds_min[i] = min_bound\n        bounds_max[i] = max_bound\n        total_min_cap += min_bound\n        total_max_cap += max_bound\n    \n    # Refine by removing expensive free units if possible\n    removable = sorted((i for i in committed_set if i not in forced_on), \n                       key=lambda i: unit_cost_metric[i], reverse=True)\n    for i in removable:\n        if (total_min_cap - bounds_min[i] <= current_load and \n            total_max_cap - bounds_max[i] >= current_load and \n            next_load < current_load):\n            committed_set.remove(i)\n            total_min_cap -= bounds_min[i]\n            total_max_cap -= bounds_max[i]\n    \n    # Dispatch preparation\n    dispatch_min = [bounds_min[i] for i in committed_set]\n    dispatch_max = [bounds_max[i] for i in committed_set]\n    b_list = [units_info[i]['b_i'] for i in committed_set]\n    c_list = [max(units_info[i]['c_i'], 1e-10) for i in committed_set]  # Handle c_i=0\n    \n    # Case 1: load <= total min\n    if current_load <= total_min_cap:\n        p_outputs = [bounds_min[i] for i in range(n_units)]\n    # Case 2: load >= total max\n    elif current_load >= total_max_cap:\n        p_outputs = [bounds_max[i] for i in range(n_units)]\n    # Case 3: Economic dispatch\n    else:\n        # Initialize dispatch array with min outputs\n        p_current = dispatch_min.copy()\n        residual = current_load - total_min_cap\n        \n        # Bisection setup\n        lb = min([b_list[i] + 2 * c_list[i] * dispatch_min[i] for i in range(len(committed_set))])\n        ub = max([b_list[i] + 2 * c_list[i] * dispatch_max[i] for i in range(len(committed_set))])\n        total_power = total_min_cap\n        epsilon = 0.1  # MW tolerance\n        max_iter = 1000\n        iter_count = 0\n        \n        # Bisection for lambda\n        while iter_count < max_iter and ub - lb > 1e-9:\n            lam = (lb + ub) / 2\n            total_power = 0\n            for i in range(len(committed_set)):\n                unconstrained = (lam - b_list[i]) / (2 * c_list[i])\n                p_current[i] = max(dispatch_min[i], min(dispatch_max[i], unconstrained))\n                total_power += p_current[i]\n            \n            if abs(total_power - current_load) < epsilon:\n                break\n            if total_power < current_load:\n                lb = lam\n            else:\n                ub = lam\n            iter_count += 1\n        \n        # Greedy residual adjustment\n        residual = current_load - total_power\n        while abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = []\n                for i in range(len(committed_set)):\n                    if p_current[i] < dispatch_max[i] - 1e-5:\n                        ic = b_list[i] + 2 * c_list[i] * p_current[i]\n                        room = dispatch_max[i] - p_current[i]\n                        candidates.append((ic, i, room))\n                if not candidates:\n                    break\n                ic, idx, room = min(candidates, key=lambda x: x[0])\n                delta = min(room, residual)\n                p_current[idx] += delta\n                residual -= delta\n            else:\n                candidates = []\n                for i in range(len(committed_set)):\n                    if p_current[i] > dispatch_min[i] + 1e-5:\n                        ic = b_list[i] + 2 * c_list[i] * p_current[i]\n                        room = p_current[i] - dispatch_min[i]\n                        candidates.append((ic, i, room))\n                if not candidates:\n                    break\n                ic, idx, room = max(candidates, key=lambda x: x[0])\n                delta = min(room, -residual)\n                p_current[idx] -= delta\n                residual += delta\n        \n        # Assign outputs for committed units\n        p_outputs = [0] * n_units\n        committed_list = list(committed_set)\n        for idx, i in enumerate(committed_list):\n            p_outputs[i] = p_current[idx]\n    \n    # Set outputs for all units\n    u_outputs = [1 if i in committed_set else 0 for i in range(n_units)]\n    for i in range(n_units):\n        if u_outputs[i] == 0:\n            p_outputs[i] = 0\n    \n    # Format result\n    schedules = np.array([u_outputs, p_outputs])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0049898532,
          "gap_price_rate": 0.0087014794,
          "fitness": 0.0068456663
     },
     {
          "name": "enhanced_amortized_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (due to min up-time/shutdown constraints), forced-off (min downtime), free online (adjustable currently online), free offline (adjustable currently offline).\n2. Adjust startup cost amortization for free offline units based on forecasted load: use half amortization if next load exceeds current, else full.\n3. Calculate cost rates: (a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i for free online; (adjusted_startup_cost + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i for free offline.\n4. Precompute power bounds: ramp-constrained [max(p_min,p_prev-p_down), min(p_max,p_prev+p_up)] for online units; [p_min, min(p_max,p_start)] for offline.\n5. Build candidate commitment set: forced-on first, then free units sorted by cost rate ascending. Add until total max bound \u2265 load.\n6. Refine by removing expensive free units (descending cost rate) only if removal maintains min_bound \u2264 load \u2264 max_bound.\n7. Dispatch: set outputs to min/max if load outside total bounds; else use lambda iteration with Newton-bisection for initial dispatch, followed by marginal-cost-based residual adjustment for exact matching.\n8. Set non-committed units to off (u=0,p=0).\n9. Return schedules as 2D array: [u_i] first row, [p_i] second row.\n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Classify units and precompute bounds\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    min_bound, max_bound = [0]*len(units_info), [0]*len(units_info)\n    cost_rate = np.zeros(len(units_info))\n    \n    for i, unit in enumerate(units_info):\n        u0, t0, p0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        \n        if u0 == 1:  # currently online\n            min_bound[i] = max(p_min, p0 - unit['p_down_i'])\n            max_bound[i] = min(p_max, p0 + unit['p_up_i'])\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n                cost_rate[i] = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        else:  # currently offline\n            min_bound[i] = p_min\n            max_bound[i] = min(p_max, unit['p_start_i'])\n            if abs(t0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                # Adjust startup cost based on forecast\n                t_on_min = unit['t_on_min_i']\n                amortization_factor = 2.0 if forecast_load > current_load else 1.0\n                amortized_sc = unit['s_i'] / (t_on_min * amortization_factor)\n                base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n                cost_rate[i] = (amortized_sc + base_cost) / p_min\n    \n    # Build initial commitment\n    committed = forced_on.copy()\n    total_min = sum(min_bound[i] for i in forced_on)\n    total_max = sum(max_bound[i] for i in forced_on)\n    \n    free_all = sorted(free_online + free_offline, key=lambda i: cost_rate[i])\n    for i in free_all:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n        else:\n            break\n    \n    # Refine commitment by removing expensive free units\n    free_in_commit = [i for i in committed if i in free_all]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: cost_rate[i], reverse=True)\n    \n    for i in free_in_commit_sorted:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load <= new_max:\n            committed.remove(i)\n            total_min, total_max = new_min, new_max\n    \n    # Initialize output arrays\n    u_arr = np.zeros(len(units_info))\n    p_arr = np.zeros(len(units_info))\n    for i in committed:\n        u_arr[i] = 1\n    \n    # Boundary dispatch\n    if current_load <= total_min:\n        for i in committed:\n            p_arr[i] = min_bound[i]\n        return np.array([u_arr, p_arr])\n    elif current_load >= total_max:\n        for i in committed:\n            p_arr[i] = max_bound[i]\n        return np.array([u_arr, p_arr])\n    \n    # Lambda iteration for economic dispatch\n    n = len(committed)\n    b_arr = np.zeros(n)\n    c_arr = np.zeros(n)\n    min_disp = np.zeros(n)\n    max_disp = np.zeros(n)\n    \n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        min_disp[idx] = min_bound[i]\n        max_disp[idx] = max_bound[i]\n        b_arr[idx] = unit['b_i']\n        c_arr[idx] = unit['c_i']\n    \n    lam_low = np.min(b_arr + 2*c_arr*min_disp)\n    lam_high = np.max(b_arr + 2*c_arr*max_disp) * 2\n    tol, max_iter = 1e-4, 100\n    p_disp = np.zeros(n)\n    \n    for _ in range(max_iter):\n        lam_mid = (lam_low + lam_high) / 2\n        total_p = 0\n        for j in range(n):\n            if c_arr[j] > 0:\n                p_j = (lam_mid - b_arr[j]) / (2 * c_arr[j])\n                p_j = max(min_disp[j], min(max_disp[j], p_j))\n            else:\n                p_j = min_disp[j] if lam_mid < b_arr[j] else max_disp[j]\n            p_disp[j] = p_j\n            total_p += p_j\n        \n        if abs(total_p - current_load) < tol:\n            break\n        elif total_p < current_load:\n            lam_low = lam_mid\n        else:\n            lam_high = lam_mid\n    \n    # Residual adjustment using marginal cost\n    residual = current_load - total_p\n    if abs(residual) > tol:\n        marginal_costs = []\n        for j in range(n):\n            if c_arr[j] > 0:\n                marginal_cost = b_arr[j] + 2*c_arr[j]*p_disp[j]\n            else:\n                marginal_cost = b_arr[j]\n            marginal_costs.append(marginal_cost)\n        \n        indices = np.argsort(marginal_costs, kind='mergesort')\n        if residual < 0:\n            indices = np.flip(indices)\n        \n        for idx in indices:\n            if abs(residual) < tol:\n                break\n            headroom = (max_disp[idx] - p_disp[idx]) if residual > 0 else (p_disp[idx] - min_disp[idx])\n            if headroom > tol:\n                adjust = min(abs(residual), headroom)\n                p_disp[idx] += adjust if residual > 0 else -adjust\n                residual += -adjust if residual > 0 else adjust\n    \n    # Assign dispatch values to output\n    for idx, i in enumerate(committed):\n        p_arr[i] = p_disp[idx]\n    \n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.0050587776,
          "gap_price_rate": 0.0087370272,
          "fitness": 0.0068979024
     },
     {
          "name": "enhanced_amortized_commitment_with_forecast",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_amortized_commitment_with_forecast(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    cost_rate = np.zeros(n_units)\n    \n    # Classification and bounds setup\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Was online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n            min_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Was offline\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(i)\n                min_bound[i] = 0\n                max_bound[i] = 0\n            else:\n                free_offline.append(i)\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Amortization factor based on forecast\n    factor = 2 if next_load > current_load else 1\n    \n    # Cost rate calculation\n    for i in free_online:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        p_min = unit['p_min_i']\n        base_cost = a + b * p_min + c * (p_min ** 2)\n        cost_rate[i] = base_cost / p_min\n    \n    for i in free_offline:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        t_on_min = unit['t_on_min_i']\n        p_min = unit['p_min_i']\n        amortized_startup = s / (t_on_min * factor)\n        base_cost = amortized_startup + a + b * p_min + c * (p_min ** 2)\n        cost_rate[i] = base_cost / p_min\n    \n    # Build candidate set\n    candidate_set = forced_on.copy()\n    total_min = sum(min_bound[i] for i in candidate_set)\n    total_max = sum(max_bound[i] for i in candidate_set)\n    \n    free_units = free_online + free_offline\n    free_units_sorted = sorted(free_units, key=lambda i: cost_rate[i])\n    \n    added_free = []\n    for i in free_units_sorted:\n        if total_max >= current_load:\n            break\n        candidate_set.append(i)\n        added_free.append(i)\n        total_min += min_bound[i]\n        total_max += max_bound[i]\n    \n    # Refine candidate set\n    added_free.sort(key=lambda i: cost_rate[i], reverse=True)\n    remove_list = []\n    for i in added_free:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load and new_max >= current_load:\n            remove_list.append(i)\n            total_min = new_min\n            total_max = new_max\n    candidate_set = [i for i in candidate_set if i not in remove_list]\n    \n    # Compute final bounds for dispatch\n    total_min = sum(min_bound[i] for i in candidate_set)\n    total_max = sum(max_bound[i] for i in candidate_set)\n    \n    # Initialize outputs\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    for i in candidate_set:\n        u_out[i] = 1\n    \n    # Dispatch\n    if current_load <= total_min:\n        for i in candidate_set:\n            p_out[i] = min_bound[i]\n    elif current_load >= total_max:\n        for i in candidate_set:\n            p_out[i] = max_bound[i]\n    else:\n        # Lambda iteration setup\n        min_bounds = [min_bound[i] for i in candidate_set]\n        max_bounds = [max_bound[i] for i in candidate_set]\n        bs = [units_info[i]['b_i'] for i in candidate_set]\n        cs = [units_info[i]['c_i'] for i in candidate_set]\n        \n        # Lambda bounds\n        lambda_min = min(b + 2 * c * lb for (b, c, lb) in zip(bs, cs, min_bounds) if c > 0)\n        lambda_max = max(b + 2 * c * ub for (b, c, ub) in zip(bs, cs, max_bounds) if c > 0)\n        \n        # Handle linear units\n        if len(bs) > 0:\n            lambda_min = min(lambda_min, min(bs))\n            lambda_max = max(lambda_max, max(bs))\n        \n        # Bisection\n        p_committed = min_bounds.copy()\n        tol = 0.01\n        for _ in range(100):\n            lam = (lambda_min + lambda_max) / 2\n            total_p = 0\n            for j in range(len(candidate_set)):\n                b, c, lb, ub = bs[j], cs[j], min_bounds[j], max_bounds[j]\n                if c > 0:\n                    p_unclamped = (lam - b) / (2 * c)\n                    p_temp = max(lb, min(ub, p_unclamped))\n                else:\n                    p_temp = ub if lam > b else lb\n                p_committed[j] = p_temp\n                total_p += p_temp\n                \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                lambda_min = lam\n            else:\n                lambda_max = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        abs_residual = abs(residual)\n        while abs_residual > tol:\n            candidates = []\n            for j in range(len(candidate_set)):\n                if residual > 0 and p_committed[j] < max_bounds[j]:\n                    candidates.append(j)\n                elif residual < 0 and p_committed[j] > min_bounds[j]:\n                    candidates.append(j)\n                    \n            if not candidates:\n                break\n                \n            marginal_costs = []\n            for j in candidates:\n                b, c, p = bs[j], cs[j], p_committed[j]\n                mc = b + 2 * c * p if c > 0 else b\n                marginal_costs.append(mc)\n                \n            if residual > 0:\n                idx = np.argmin(marginal_costs)\n                unit_idx = candidates[idx]\n                max_increase = max_bounds[unit_idx] - p_committed[unit_idx]\n                adjust = min(residual, max_increase)\n                p_committed[unit_idx] += adjust\n                residual -= adjust\n            else:\n                idx = np.argmax(marginal_costs)\n                unit_idx = candidates[idx]\n                max_decrease = p_committed[unit_idx] - min_bounds[unit_idx]\n                adjust = min(-residual, max_decrease)\n                p_committed[unit_idx] -= adjust\n                residual += adjust\n            abs_residual = abs(residual)\n        \n        # Assign dispatched values\n        for idx, unit_index in enumerate(candidate_set):\n            p_out[unit_index] = p_committed[idx]\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0050602193,
          "gap_price_rate": 0.0087367773,
          "fitness": 0.0068984983
     },
     {
          "name": "enhanced_amortized_cost_dispatch",
          "algorithm": "1. Classify units into forced-on (due to min up-time or shutdown constraints), forced-off (due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline). 2. Precompute amortized cost metrics for free units: (operating cost at min power for free online; startup cost amortized over min up-time plus operating cost at min power for free offline). 3. Form initial commitment set: forced-on units + free units sorted by amortized cost. 4. While total ramp-constrained max capacity < current load: add next cheapest free unit. 5. While total ramp-constrained min capacity > load: remove most expensive free unit (if feasible). 6. For committed units: calculate feasible power bounds considering ramp constraints. 7. Dispatch load using lambda iteration with residual adjustment for exact matching. 8. Set non-committed units to off with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints and state\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost metrics for free units\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        cost_metric[i] = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_metric[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n    \n    # Create sorted free unit list (by cost metric ascending)\n    free_units = free_online + free_offline\n    free_units_sorted = sorted(free_units, key=lambda i: cost_metric[i])\n    \n    # Initialize committed set with forced-on units\n    committed_set = set(forced_on)\n    \n    # Calculate initial capacity bounds\n    total_min = 0.0\n    total_max = 0.0\n    \n    def get_feasible_bounds(i, committed=False):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Was offline, only if committed (being started)\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        return min_p, max_p\n    \n    for i in committed_set:\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Add free units until total_max >= current_load\n    for i in free_units_sorted:\n        if total_max >= current_load:\n            break\n        if i in committed_set:\n            continue\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        committed_set.add(i)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Remove expensive free units if total_min > current_load\n    free_committed = [i for i in committed_set if i not in forced_on]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    changed = True\n    while changed and free_committed_sorted:\n        changed = False\n        for i in free_committed_sorted:\n            candidate_set = committed_set - {i}\n            # Recalculate bounds for candidate set\n            new_min = 0.0\n            new_max = 0.0\n            for j in candidate_set:\n                min_p_j, max_p_j = get_feasible_bounds(j, j in candidate_set)\n                new_min += min_p_j\n                new_max += max_p_j\n            if new_min <= current_load <= new_max:\n                committed_set = candidate_set\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n        # Update free_committed list after removal\n        free_committed = [i for i in committed_set if i not in forced_on]\n        free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    # Update commitment status\n    for i in committed_set:\n        u[i] = 1\n    \n    # Precompute bounds for dispatch\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    for i in committed_set:\n        min_b, max_b = get_feasible_bounds(i, True)\n        min_bounds[i] = min_b\n        max_bounds[i] = max_b\n    \n    # Collect indices and coefficients for committed units\n    committed_indices = list(committed_set)\n    b_arr = np.array([units_info[i]['b_i'] for i in committed_indices])\n    c_arr = np.array([units_info[i]['c_i'] for i in committed_indices])\n    min_p_arr = min_bounds[committed_indices]\n    max_p_arr = max_bounds[committed_indices]\n    \n    # Initialize power for committed units\n    p_committed = np.zeros(len(committed_indices))\n    \n    # Lambda iteration for dispatch\n    if len(committed_indices) > 0:\n        lo_mc = 1e-6\n        hi_mc = 1e8\n        tol = 1e-3\n        max_iter = 100\n        \n        for _ in range(max_iter):\n            lam = (lo_mc + hi_mc) / 2\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:  # Linear cost\n                    if lam > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:  # Quadratic cost\n                    p_unclipped = (lam - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            \n            total_proposed = np.sum(p_proposed)\n            \n            if abs(total_proposed - current_load) < tol:\n                p_committed = p_proposed\n                break\n            \n            if total_proposed < current_load:\n                lo_mc = lam\n            else:\n                hi_mc = lam\n        else:\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:\n                    if lo_mc > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:\n                    p_unclipped = (lo_mc - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            p_committed = p_proposed\n        \n        # Residual adjustment for exact match\n        total_gen = np.sum(p_committed)\n        residual = current_load - total_gen\n        if abs(residual) > 1e-3:\n            # Positive residual: increase under-max units by marginal cost\n            if residual > 0:\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] < max_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    headroom = max_p_arr[unit_idx] - p_committed[unit_idx]\n                    if headroom < residual:\n                        p_committed[unit_idx] += headroom\n                        residual -= headroom\n                    else:\n                        p_committed[unit_idx] += residual\n                        residual = 0\n                        break\n            # Negative residual: decrease above-min units by marginal cost (reverse)\n            else:\n                residual = abs(residual)\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] > min_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)[::-1]\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    footroom = p_committed[unit_idx] - min_p_arr[unit_idx]\n                    if footroom < residual:\n                        p_committed[unit_idx] -= footroom\n                        residual -= footroom\n                    else:\n                        p_committed[unit_idx] -= residual\n                        residual = 0\n                        break\n        \n        # Assign power values to committed units\n        for idx, unit_idx in enumerate(committed_indices):\n            p[unit_idx] = p_committed[idx]\n    \n    # Set non-committed units to off and output zero\n    for i in range(n_units):\n        if i not in committed_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0050588692,
          "gap_price_rate": 0.0088502454,
          "fitness": 0.0069545573
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "combined_enhanced_priority_amortized_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain online due to min uptime or shutdown constraints), forced-off (must remain offline due to min downtime), free online (currently online and adjustable), and free offline (currently offline but available).  \n2. Calculate amortized cost metrics for free units:  \n   - Free online: (a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i  \n   - Free offline: (s_i/t_on_min_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i  \n3. Build initial commitment set with forced-on units and free online units. Calculate total min/max capacity considering ramp constraints.  \n4. If total max capacity < current load, activate free offline units sorted by amortized cost until max capacity meets load.  \n5. If total min capacity > current load, remove expensive non-essential free units (sorted by descending operating cost) while maintaining min capacity \u2264 load.  \n6. Calculate feasible power bounds for committed units:  \n   - Previously online: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i)  \n   - Newly started: p_min_i to min(p_max_i, p_start_i)  \n7. Dispatch load using accelerated lambda iteration:  \n   a. Handle boundary cases (all min/max) if load outside feasible range  \n   b. Use Newton-accelerated bisection to find optimal dispatch  \n   c. Apply residual adjustment respecting ramp constraints  \n8. Set non-committed units to off state (u_i=0, p_i=0).  \n9. Return schedules as 2D NumPy array.  \n\n",
          "code": "import numpy as np\n\ndef combined_enhanced_priority_amortized_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=np.float64)\n    p = np.zeros(n_units, dtype=np.float64)\n    \n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_up_time = unit['t_on_min_i']\n            time_on = unit['t_i_0']\n            shutdown_cap = unit['p_shut_i']\n            prev_output = unit['p_i_0']\n            \n            if time_on < min_up_time or prev_output > shutdown_cap:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            min_down_time = unit['t_off_min_i']\n            time_off = -unit['t_i_0']\n            \n            if time_off < min_down_time:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Precompute amortized costs for free units\n    amortized_costs = np.zeros(n_units)\n    for i in free_online:\n        a = units_info[i]['a_i']\n        b = units_info[i]['b_i']\n        c = units_info[i]['c_i']\n        p_min = units_info[i]['p_min_i']\n        amortized_costs[i] = (a + b*p_min + c*p_min**2) / p_min\n    \n    for i in free_offline:\n        a = units_info[i]['a_i']\n        b = units_info[i]['b_i']\n        c = units_info[i]['c_i']\n        s = units_info[i]['s_i']\n        t_up_min = units_info[i]['t_on_min_i']\n        p_min = units_info[i]['p_min_i']\n        amortized_costs[i] = (s/t_up_min + a + b*p_min + c*p_min**2) / p_min\n    \n    # Build initial commitment set\n    committed = set(forced_on)\n    total_min, total_max = 0.0, 0.0\n    \n    # Calculate bounds for forced-on units\n    for i in forced_on:\n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        p_prev = units_info[i]['p_i_0']\n        ramp_down = units_info[i]['p_down_i']\n        ramp_up = units_info[i]['p_up_i']\n        \n        lb = max(p_min, p_prev - ramp_down)\n        ub = min(p_max, p_prev + ramp_up)\n        \n        total_min += lb\n        total_max += ub\n    \n    # Add free online units\n    for i in sorted(free_online, key=lambda i: amortized_costs[i]):\n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        p_prev = units_info[i]['p_i_0']\n        ramp_down = units_info[i]['p_down_i']\n        ramp_up = units_info[i]['p_up_i']\n        \n        lb = max(p_min, p_prev - ramp_down)\n        ub = min(p_max, p_prev + ramp_up)\n        \n        if total_max < current_load:\n            committed.add(i)\n            total_min += lb\n            total_max += ub\n    \n    # Add free offline units if needed\n    for i in sorted(free_offline, key=lambda i: amortized_costs[i]):\n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        start_limit = units_info[i]['p_start_i']\n        ub = min(p_max, start_limit)\n        \n        if total_max < current_load:\n            committed.add(i)\n            total_min += p_min\n            total_max += ub\n    \n    # Remove expensive units if overcommitted\n    if total_min > current_load:\n        removable = [i for i in committed if i not in forced_on]\n        for i in sorted(removable, key=lambda i: -amortized_costs[i]):\n            p_min = units_info[i]['p_min_i']\n            p_prev = units_info[i]['p_i_0']\n            \n            if units_info[i]['u_i_0'] == 1:\n                ramp_down = units_info[i]['p_down_i']\n                lb = max(p_min, p_prev - ramp_down)\n            else:\n                lb = p_min\n            \n            if total_min - lb <= current_load:\n                break\n            committed.remove(i)\n            total_min -= lb\n            total_max -= units_info[i]['p_max_i']\n    \n    # Calculate dispatch bounds\n    lb_values = np.zeros(n_units)\n    ub_values = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if i not in committed:\n            lb_values[i] = ub_values[i] = 0.0\n            continue\n            \n        p_min = units_info[i]['p_min_i']\n        p_max = units_info[i]['p_max_i']\n        p_prev = units_info[i]['p_i_0']\n        \n        if units_info[i]['u_i_0'] == 1:\n            ramp_down = units_info[i]['p_down_i']\n            ramp_up = units_info[i]['p_up_i']\n            lb_values[i] = max(p_min, p_prev - ramp_down)\n            ub_values[i] = min(p_max, p_prev + ramp_up)\n        else:\n            start_limit = units_info[i]['p_start_i']\n            lb_values[i] = p_min\n            ub_values[i] = min(p_max, start_limit)\n    \n    # Handle boundary cases\n    comm_idx = np.array(list(committed), dtype=int)\n    comm_min = lb_values[comm_idx].sum()\n    comm_max = ub_values[comm_idx].sum()\n    \n    if current_load <= comm_min:\n        for i in committed:\n            p[i] = lb_values[i]\n            u[i] = 1\n        return np.vstack((u, p))\n    \n    if current_load >= comm_max:\n        for i in committed:\n            p[i] = ub_values[i]\n            u[i] = 1\n        return np.vstack((u, p))\n    \n    # Lambda iteration with Newton acceleration\n    a_arr = np.array([units_info[i]['a_i'] for i in comm_idx])\n    b_arr = np.array([units_info[i]['b_i'] for i in comm_idx])\n    c_arr = np.array([units_info[i]['c_i'] for i in comm_idx])\n    lb_comm = lb_values[comm_idx]\n    ub_comm = ub_values[comm_idx]\n    n_comm = len(comm_idx)\n    \n    # Newton-accelerated bisection\n    lam_low = (b_arr + 2*c_arr*lb_comm).min()\n    lam_high = (b_arr + 2*c_arr*ub_comm).max()\n    lam = (lam_low + lam_high) / 2\n    \n    f_val = np.inf\n    iteration = 0\n    max_iter = 50\n    \n    while abs(f_val) > 1e-5 and iteration < max_iter:\n        p_vals = np.clip((lam - b_arr) / (2 * c_arr), lb_comm, ub_comm)\n        f_val = p_vals.sum() - current_load\n        \n        # Derivative of power sum w.r.t lambda (inverse of second derivative)\n        df_dlam = np.sum(1/(2*c_arr))\n        lam -= f_val / df_dlam\n        lam = np.clip(lam, lam_low, lam_high)\n        iteration += 1\n    \n    # Set optimal dispatch values\n    for idx, i in enumerate(comm_idx):\n        p[i] = np.clip((lam - b_arr[idx]) / (2*c_arr[idx]), lb_comm[idx], ub_comm[idx])\n        u[i] = 1\n    \n    # Residual adjustment\n    total_p = p.sum()\n    residual = current_load - total_p\n    \n    if abs(residual) > 1e-3:\n        if residual > 0:\n            candidates = [i for i in comm_idx if p[i] < ub_values[i]]\n            costs = [b_arr[i] + 2*c_arr[i]*p[i] for i in range(n_comm)]\n            sorted_idx = np.argsort(costs)\n            \n            for j in sorted_idx:\n                idx = comm_idx[j]\n                if p[idx] < ub_values[idx]:\n                    delta = min(residual, ub_values[idx] - p[idx])\n                    p[idx] += delta\n                    residual -= delta\n                if residual <= 0:\n                    break\n        else:\n            residual = abs(residual)\n            candidates = [i for i in comm_idx if p[i] > lb_values[i]]\n            costs = [b_arr[i] + 2*c_arr[i]*p[i] for i in range(n_comm)]\n            sorted_idx = np.argsort(costs)[::-1]\n            \n            for j in sorted_idx:\n                idx = comm_idx[j]\n                if p[idx] > lb_values[idx]:\n                    delta = min(residual, p[idx] - lb_values[idx])\n                    p[idx] -= delta\n                    residual -= delta\n                if residual <= 0:\n                    break\n    \n    return np.vstack((u, p))",
          "from": "crossover",
          "gap_power_rate": 0.0050841815,
          "gap_price_rate": 0.0092566934,
          "fitness": 0.0071704375
     }
]