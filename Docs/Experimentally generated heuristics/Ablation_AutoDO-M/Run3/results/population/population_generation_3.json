[
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "commit_units_by_amortized_cost",
          "algorithm": "1. Classify units into forced-on (must remain on due to min up-time/shutdown constraints), forced-off (min downtime), free online (currently on but adjustable), and free offline (currently off but available).\n2. Calculate cost rates for free units:\n   - Free online: (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: (s_i/t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate list sorted by cost rates: forced-on first, then free units by ascending cost.\n4. Build committed set by adding candidates until total max capacity \u2265 load:\n   - Free online: min/max = max(p_min_i, p_i_0-p_down_i) to min(p_max_i, p_i_0+p_up_i)\n   - Free offline: min/max = p_min_i to min(p_max_i, p_start_i)\n5. Set non-committed units to u_i=0, p_i=0.\n6. Perform constrained economic dispatch for committed units:\n   - Determine feasible power bounds considering ramp constraints\n   - Use lambda iteration to find optimal dispatch minimizing cost\n   - Adjust outputs to exactly match load\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef commit_units_by_amortized_cost(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Currently online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Currently offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost rates for free units\n    cost_rates = {}\n    for i in free_online:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        cost_rates[i] = (unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    for i in free_offline:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_rates[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n    \n    # Form sorted candidate list\n    candidate_list = forced_on[:]\n    candidate_list.extend(sorted(free_online + free_offline, key=lambda i: cost_rates.get(i, 0)))\n    \n    # Build committed set\n    committed = set()\n    total_min = 0.0\n    total_max = 0.0\n    unit_bounds = {}\n    \n    for i in forced_on:  # Add forced-on units\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    for i in candidate_list:  # Add candidates until sufficient capacity\n        if i in forced_on:\n            continue  # Already added\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[i]\n        if i in free_online:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free_offline\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit_bounds[i] = (p_min, p_max)\n        total_min += p_min\n        total_max += p_max\n        committed.add(i)\n    \n    # Set non-committed units to offline\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            u[i] = 1\n    \n    # Handle extreme load cases\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = unit_bounds[i][0]\n        return np.array([u, p])\n    \n    if current_load >= total_max:\n        for i in committed:\n            p[i] = unit_bounds[i][1]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_bounds = np.array([unit_bounds[i][0] for i in range(n_units) if i in committed])\n    high_bounds = np.array([unit_bounds[i][1] for i in range(n_units) if i in committed])\n    b = np.array([units_info[i]['b_i'] for i in range(n_units) if i in committed])\n    c = np.array([units_info[i]['c_i'] for i in range(n_units) if i in committed])\n    \n    lambda_low = min(b + 2 * c * low_bounds)\n    lambda_high = max(b + 2 * c * high_bounds)\n    tolerance = 1e-5\n    max_iter = 100\n    iter_count = 0\n    n_committed = len(low_bounds)\n    p_dispatch = np.copy(low_bounds)\n    \n    while iter_count < max_iter:\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        total_power = 0.0\n        \n        # Calculate optimal unconstrained dispatch\n        for i in range(n_committed):\n            p_opt = (lambda_mid - b[i]) / (2 * c[i])\n            p_dispatch[i] = np.clip(p_opt, low_bounds[i], high_bounds[i])\n        \n        total_power = np.sum(p_dispatch)\n        \n        # Check convergence\n        if abs(total_power - current_load) <= tolerance:\n            break\n            \n        # Adjust lambda\n        if total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        iter_count += 1\n    \n    # Assign dispatched values to committed units\n    dispatch_idx = 0\n    for i in range(n_units):\n        if i in committed:\n            p[i] = p_dispatch[dispatch_idx]\n            dispatch_idx += 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055425116,
          "gap_price_rate": 0.0089835115,
          "fitness": 0.0072630116
     },
     {
          "name": "combined_priority_dispatch",
          "algorithm": "1. Determine forced commitment states: must-on units (cannot be turned off due to minimum up-time or shutdown ramp constraints), must-off units (cannot be started due to minimum down-time), and free units.\n2. Initialize on_set with must-on units and free units currently online.\n3. Calculate total min and max output capacity of current on_set, considering ramp constraints and startup limits.\n4. If max capacity < current load, activate free offline units sorted by ascending amortized startup cost until max capacity meets/exceeds load.\n5. If min capacity > current load, deactivate non-essential free units sorted by descending operating cost at min power until min capacity <= load.\n6. Compute feasible power bounds for all committed units considering ramp constraints and startup/shutdown limits.\n7. Perform economic dispatch for committed units:\n   - If load below total min, set all outputs to min.\n   - If load above total max, set all outputs to max.\n   - Otherwise, use lambda iteration for optimal dispatch within bounds.\n8. Return schedule as a 2D array (commitment states, power outputs).\n\n",
          "code": "import numpy as np\n\ndef combined_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u_i = [0] * n\n    p_i = [0.0] * n\n    muston = [False] * n\n    mustoff = [False] * n\n    on_set = set()\n\n    # Determine forced states\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                muston[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                mustoff[i] = True\n\n    # Initialize on_set with must-on and free currently online units\n    for i in range(n):\n        if muston[i] or (not muston[i] and not mustoff[i] and units_info[i]['u_i_0'] == 1):\n            on_set.add(i)\n            u_i[i] = 1\n\n    # Calculate initial power bounds\n    def compute_bounds(i):\n        if units_info[i]['u_i_0'] == 1:\n            min_bound = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_bound = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            min_bound = units_info[i]['p_min_i']\n            max_bound = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        return min_bound, max_bound\n\n    # Turn on candidates if needed (Step 4)\n    free_off = [i for i in range(n) if not muston[i] and not mustoff[i] and units_info[i]['u_i_0'] == 0]\n    amortized_cost = [(i, (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / max(1, unit['p_min_i'])) \n                      for i, unit in enumerate(units_info) if i in free_off]\n    amortized_cost.sort(key=lambda x: x[1])\n    \n    total_min = 0\n    total_max = 0\n    for i in on_set:\n        min_b, max_b = compute_bounds(i)\n        total_min += min_b\n        total_max += max_b\n    \n    for i, _ in amortized_cost:\n        if total_max < current_load and i in free_off:\n            min_b, max_b = compute_bounds(i)\n            on_set.add(i)\n            u_i[i] = 1\n            total_min += min_b\n            total_max += max_b\n\n    # Turn off non-essential if needed (Step 5)\n    non_essential = [i for i in on_set if not muston[i] and units_info[i]['u_i_0'] == 1]\n    op_cost = [(i, units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n               units_info[i]['c_i']*units_info[i]['p_min_i']**2) \n              for i in non_essential]\n    op_cost.sort(key=lambda x: x[1], reverse=True)\n    \n    for i, _ in op_cost:\n        min_b, max_b = compute_bounds(i)\n        if total_min - min_b > current_load: \n            continue\n        if total_max - max_b >= current_load:\n            on_set.remove(i)\n            u_i[i] = 0\n            total_min -= min_b\n            total_max -= max_b\n\n    # Compute final bounds for dispatch\n    lo_arr = []\n    hi_arr = []\n    b_arr = []\n    c_arr = []\n    indices = []\n    for i in on_set:\n        min_b, max_b = compute_bounds(i)\n        lo_arr.append(min_b)\n        hi_arr.append(max_b)\n        b_arr.append(units_info[i]['b_i'])\n        c_arr.append(units_info[i]['c_i'])\n        indices.append(i)\n    total_min = sum(lo_arr)\n    total_max = sum(hi_arr)\n    n_on = len(indices)\n\n    # Dispatch power for committed units\n    if n_on > 0:\n        if current_load <= total_min:\n            for idx, i in enumerate(indices):\n                p_i[i] = lo_arr[idx]\n        elif current_load >= total_max:\n            for idx, i in enumerate(indices):\n                p_i[i] = hi_arr[idx]\n        else:\n            lambda_min = min(2 * c_arr[j] * lo_arr[j] + b_arr[j] for j in range(n_on))\n            lambda_max = max(2 * c_arr[j] * hi_arr[j] + b_arr[j] for j in range(n_on))\n            tol = 1e-5\n            iter_max = 100\n            for _ in range(iter_max):\n                lambda_mid = (lambda_min + lambda_max) / 2.0\n                total_p = 0.0\n                for j in range(n_on):\n                    if abs(c_arr[j]) < 1e-7:\n                        p_val = hi_arr[j] if b_arr[j] < lambda_mid else lo_arr[j]\n                    else:\n                        p_val = (lambda_mid - b_arr[j]) / (2 * c_arr[j])\n                        p_val = max(lo_arr[j], min(hi_arr[j], p_val))\n                    total_p += p_val\n                if abs(total_p - current_load) < tol:\n                    break\n                if total_p < current_load:\n                    lambda_min = lambda_mid\n                else:\n                    lambda_max = lambda_mid\n            for j, idx_unit in enumerate(indices):\n                if abs(c_arr[j]) < 1e-7:\n                    p_i[idx_unit] = hi_arr[j] if b_arr[j] < lambda_mid else lo_arr[j]\n                else:\n                    p_val = (lambda_mid - b_arr[j]) / (2 * c_arr[j])\n                    p_i[idx_unit] = max(lo_arr[j], min(hi_arr[j], p_val))\n\n    # Format output\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_i[i]\n        schedules[1, i] = p_i[i]\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091472115,
          "fitness": 0.0072878746
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Preprocess units to determine forced commitment states based on minimum up/down times, shutdown ramp limits, and previous state.\n2. Compute available capacity from initially committed units.\n3. Turn on additional candidate units (not forced off) based on two-period average incremental cost until available capacity meets or exceeds current load.\n4. Turn off non-essential candidate units (those not forced on) based on highest operating cost to minimize total cost.\n5. Perform economic dispatch using bisection method to allocate load to committed units, respecting ramp limits and power bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    \n    forced_committed = []\n    candidate_off = []\n    candidate_on = []\n    \n    # Step 1: Determine forced commitment and candidate units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_committed.append(idx)\n            else:\n                candidate_off.append(idx)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                continue\n            else:\n                candidate_on.append(idx)\n    \n    # Helper function to get available capacity\n    def get_available_capacity(unit_indices):\n        total = 0.0\n        for idx in unit_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total += min(unit['p_max_i'], unit['p_start_i'])\n        return total\n    \n    # Initially committed units (forced on and candidate_off)\n    committed_units = forced_committed + candidate_off\n    total_available = get_available_capacity(committed_units)\n    \n    # Step 2: Turn on candidate units if needed\n    candidate_on_info = []\n    for idx in candidate_on:\n        unit = units_info[idx]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        \n        cost_current = s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        cost_next = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        total_cost = cost_current + cost_next\n        power_two_periods = 2 * p_min_i\n        aic_per_mw = total_cost / power_two_periods\n        \n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidate_on_info.append((idx, aic_per_mw, avail))\n    \n    candidate_on_info.sort(key=lambda x: x[1])\n    \n    for idx, _, avail in candidate_on_info:\n        if total_available >= current_load:\n            break\n        total_available += avail\n        committed_units.append(idx)\n    \n    # Step 3: Turn off non-essential candidate_off units\n    candidate_off_info = []\n    for idx in candidate_off:\n        if idx not in committed_units:\n            continue\n        unit = units_info[idx]\n        min_power = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_off_info.append((idx, cost, avail))\n    \n    candidate_off_info.sort(key=lambda x: x[1], reverse=True)\n    \n    new_committed = list(committed_units)\n    total_available_new = total_available\n    for idx, _, avail in candidate_off_info:\n        if (total_available_new - avail) >= current_load:\n            total_available_new -= avail\n            new_committed.remove(idx)\n    committed_units = new_committed\n    \n    # Prepare schedules array\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    for idx in committed_units:\n        schedules[0, idx] = 1\n    \n    # Step 4: Economic Dispatch\n    unit_bounds = []\n    for idx in committed_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        unit_bounds.append((idx, low_bound, high_bound))\n    \n    low_total = sum(low for _, low, _ in unit_bounds)\n    high_total = sum(high for _, _, high in unit_bounds)\n    \n    # If load not feasible, use bounds\n    if current_load < low_total or current_load > high_total:\n        for idx, low, high in unit_bounds:\n            if current_load < low_total:\n                schedules[1, idx] = low\n            else:\n                schedules[1, idx] = high\n        return schedules\n    \n    # Dispatch parameters\n    dispatch_list = []\n    min_ic = float('inf')\n    max_ic = -float('inf')\n    \n    for idx, low, high in unit_bounds:\n        unit = units_info[idx]\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        ic_low = b_i + 2 * c_i * low\n        ic_high = b_i + 2 * c_i * high\n        min_ic = min(min_ic, ic_low)\n        max_ic = max(max_ic, ic_high)\n        dispatch_list.append((idx, b_i, c_i, low, high))\n    \n    # Lambda iteration\n    lambda_low = min_ic\n    lambda_high = max_ic\n    p_values = [low for _, _, _, low, _ in dispatch_list]\n    \n    if abs(high_total - low_total) > 1e-6:\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_power = 0.0\n            new_p_values = []\n            for idx, b_i, c_i, low, high in dispatch_list:\n                if c_i == 0:\n                    if lambda_mid < b_i:\n                        p_i = low\n                    else:\n                        p_i = high\n                else:\n                    p_i = (lambda_mid - b_i) / (2 * c_i)\n                    p_i = max(low, min(high, p_i))\n                new_p_values.append(p_i)\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                p_values = new_p_values\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            p_values = new_p_values\n    \n    # Assign dispatch results\n    for (idx, _, _, _, _), power in zip(dispatch_list, p_values):\n        schedules[1, idx] = power\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054685553,
          "gap_price_rate": 0.0092084548,
          "fitness": 0.0073385051
     },
     {
          "name": "enhanced_priority_dispatch",
          "algorithm": "1. Identify must-on units: units that must remain on due to minimum up-time constraint or previous output exceeding shutdown capacity.\n2. Identify must-off units: units that must remain off due to minimum down-time constraint.\n3. Initialize committed set with must-on units and free units previously online. Calculate min/max capacity considering ramp limits.\n4. If max capacity < current load, start additional free offline units sorted by adjusted cost per MW (including startup cost amortized over min output) until max capacity meets/exceeds load.\n5. If min capacity > current load, deactivate non-essential committed units sorted by descending operating cost at min output until min capacity \u2264 load.\n6. For each committed unit, compute power bounds considering:\n   - Previous units: ramp constraints from previous output\n   - Newly started units: startup ramp limits\n7. Perform economic dispatch:\n   a. If load \u2264 total min, set all outputs to min.\n   b. If load \u2265 total max, set all outputs to max.\n   c. Else, use lambda iteration with linear handling to distribute load optimally.\n8. Set non-committed units to off (u_i=0, p_i=0).\n9. Return schedules as 2D numpy array.\n\n",
          "code": "import numpy as np\n\ndef enhanced_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    \n    # Determine forced commitment states\n    must_on = []\n    must_off = []\n    free_units = list(range(n_units))\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n                free_units.remove(i)\n            else:\n                must_off.append(i)\n                free_units.remove(i)\n        else:  # Was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n                free_units.remove(i)\n    \n    # Initialize committed set\n    on_set = set(must_on)\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            on_set.add(i)\n    \n    # Calculate current capacity limits\n    def calculate_capacity(on_set):\n        total_min = 0.0\n        total_max = 0.0\n        min_i_vals = []\n        max_i_vals = []\n        \n        for i in on_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            min_i_vals.append(min_i)\n            max_i_vals.append(max_i)\n            total_min += min_i\n            total_max += max_i\n        return total_min, total_max, min_i_vals, max_i_vals\n    \n    total_min, total_max, min_i_vals, max_i_vals = calculate_capacity(on_set)\n    \n    # Add units if capacity insufficient\n    if total_max < current_load:\n        candidates = [i for i in free_units if i not in on_set]\n        amortized_cost = []\n        for i in candidates:\n            unit = units_info[i]\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            amortized_cost.append((cost_per_mw, i))\n        amortized_cost.sort(key=lambda x: x[0])\n        \n        for _, i in amortized_cost:\n            if total_max >= current_load:\n                break\n            on_set.add(i)\n            new_min, new_max, _, _ = calculate_capacity([i])\n            total_min += new_min\n            total_max += new_max\n    \n    # Remove units if overcommitted\n    if total_min > current_load:\n        non_essential = [i for i in on_set if i not in must_on]\n        operating_cost = []\n        for i in non_essential:\n            unit = units_info[i]\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                          unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            operating_cost.append((cost_per_mw, i))\n        operating_cost.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in operating_cost:\n            if total_min <= current_load:\n                break\n            on_set.remove(i)\n            prev_min, prev_max, _, _ = calculate_capacity([i])\n            total_min -= prev_min\n            total_max -= prev_max\n    \n    # Compute dispatch bounds\n    bounds = []\n    for i in on_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((min_bound, max_bound))\n    \n    # Economic dispatch\n    if current_load <= total_min:\n        outputs = [min_bound for min_bound, _ in bounds]\n    elif current_load >= total_max:\n        outputs = [max_bound for _, max_bound in bounds]\n    else:\n        # Lambda iteration setup\n        low = min(2*units_info[i]['c_i']*bounds[idx][0] + units_info[i]['b_i'] \n                 for idx, i in enumerate(on_set) if units_info[i]['c_i'] > 0 or units_info[i]['b_i'])\n        high = max(2*units_info[i]['c_i']*bounds[idx][1] + units_info[i]['b_i'] \n                  for idx, i in enumerate(on_set) if units_info[i]['c_i'] > 0 or units_info[i]['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        lamb = (low + high) / 2\n        \n        for _ in range(max_iter):\n            total_p = 0.0\n            for idx, i in enumerate(on_set):\n                unit = units_info[i]\n                min_bound, max_bound = bounds[idx]\n                if unit['c_i'] == 0:\n                    p_i = max_bound if lamb >= unit['b_i'] else min_bound\n                else:\n                    p_i = (lamb - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_bound, min(max_bound, p_i))\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n            lamb = (low + high) / 2\n        \n        # Calculate final outputs\n        outputs = []\n        for idx, i in enumerate(on_set):\n            unit = units_info[i]\n            min_bound, max_bound = bounds[idx]\n            if unit['c_i'] == 0:\n                p_i = max_bound if lamb >= unit['b_i'] else min_bound\n            else:\n                p_i = (lamb - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(min_bound, min(max_bound, p_i))\n            outputs.append(p_i)\n    \n    # Build output arrays\n    for j, i in enumerate(on_set):\n        u_arr[i] = 1\n        p_arr[i] = outputs[j]\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0063269571,
          "gap_price_rate": 0.0083953792,
          "fitness": 0.0073611682
     },
     {
          "name": "enhanced_amortized_cost_dispatch",
          "algorithm": "1. Classify units into forced-on (must remain on due to min up-time or shutdown constraints), forced-off (must remain off due to min down-time), free online (adjustable units currently on), and free offline (adjustable units currently off)  \n2. For free units, calculate amortized cost metrics: operating cost at min output for free online; startup cost amortized over min up-time plus operating cost at min output for free offline  \n3. Sort free units by cost metrics in ascending order  \n4. Build committed set:  \n   - Start with forced-on units  \n   - Add free online units in cost order  \n   - Add free offline units in cost order until total max capacity \u2265 load  \n   - If total min output > load, remove most expensive free units (descending cost order) while maintaining total max capacity \u2265 load  \n5. Calculate feasible power bounds for committed units considering ramp constraints and startup/shutdown limits  \n6. Perform economic dispatch:  \n   - Use lambda iteration with bounds to find optimal generation levels  \n   - Adjust outputs to exactly match load using residual distribution  \n   - Clamp generation levels if outside bounds  \n7. Set non-committed units to off (u_i=0, p_i=0)  \n8. Return commitment states and power outputs  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_amortized_cost_dispatch(units_info, load):  \n    current_load = load[0]  \n    num_units = len(units_info)  \n    \n    # Initialize arrays for schedules  \n    u_schedule = np.zeros(num_units)  \n    p_schedule = np.zeros(num_units)  \n    \n    # Classify units and calculate cost metrics  \n    forced_on = []  \n    forced_off = []  \n    free_online = []  \n    free_offline = []  \n    \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):  \n                forced_on.append(i)  \n            else:  \n                free_online.append(i)  \n        else:  \n            if -unit['t_i_0'] < unit['t_off_min_i']:  \n                forced_off.append(i)  \n            else:  \n                free_offline.append(i)  \n    \n    # Calculate cost metrics  \n    def calc_cost_metric(i):  \n        unit = units_info[i]  \n        base_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)  \n        if i in free_online:  \n            return base_cost / unit['p_min_i']  \n        else:  # free_offline  \n            return (unit['s_i'] / unit['t_on_min_i'] + base_cost) / unit['p_min_i']  \n    \n    # Sort free units by cost metric  \n    free_online.sort(key=lambda i: calc_cost_metric(i))  \n    free_offline.sort(key=lambda i: calc_cost_metric(i))  \n    candidate_list = free_online + free_offline  \n    \n    # Initialize committed set and power bounds  \n    committed_set = set(forced_on)  \n    bounds = {}  \n    total_min = 0.0  \n    total_max = 0.0  \n    \n    # Calculate bounds for forced-on units  \n    for i in forced_on:  \n        unit = units_info[i]  \n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        bounds[i] = (min_p, max_p)  \n        total_min += min_p  \n        total_max += max_p  \n    \n    # Add candidates until max capacity meets load  \n    for i in candidate_list:  \n        unit = units_info[i]  \n        if i in free_online:  \n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  # free_offline  \n            min_p = unit['p_min_i']  \n            max_p = min(unit['p_max_i'], unit['p_start_i'])  \n        \n        if total_max < current_load:  \n            committed_set.add(i)  \n            bounds[i] = (min_p, max_p)  \n            total_min += min_p  \n            total_max += max_p  \n    \n    # Remove expensive units if min output exceeds load  \n    free_in_commit = [i for i in committed_set if i not in forced_on]  \n    free_with_cost = [(i, calc_cost_metric(i)) for i in free_in_commit]  \n    free_with_cost.sort(key=lambda x: x[1], reverse=True)  # Descending cost  \n    \n    changed = True  \n    while changed and total_min > current_load and free_with_cost:  \n        changed = False  \n        for idx, (i, _) in enumerate(free_with_cost):  \n            min_p_i, max_p_i = bounds[i]  \n            new_min = total_min - min_p_i  \n            new_max = total_max - max_p_i  \n            if new_max >= current_load:  \n                committed_set.remove(i)  \n                del bounds[i]  \n                total_min = new_min  \n                total_max = new_max  \n                del free_with_cost[idx]  \n                changed = True  \n                break  \n    \n    # Calculate bounds for all committed units  \n    total_min = sum(bounds[i][0] for i in committed_set)  \n    total_max = sum(bounds[i][1] for i in committed_set)  \n    \n    # Economic dispatch  \n    dispatch = {}  \n    tol = 1e-3  \n    \n    if committed_set:  \n        if abs(total_min - total_max) < tol:  \n            for i in committed_set:  \n                dispatch[i] = bounds[i][0]  \n        elif current_load <= total_min:  \n            for i in committed_set:  \n                dispatch[i] = bounds[i][0]  \n        elif current_load >= total_max:  \n            for i in committed_set:  \n                dispatch[i] = bounds[i][1]  \n        else:  \n            # Lambda iteration  \n            lambda_low = 0  \n            lambda_high = max(2*units_info[i]['c_i']*bounds[i][1] + units_info[i]['b_i']  \n                            for i in committed_set) * 2  \n            n_iter = 100  \n            \n            for _ in range(n_iter):  \n                lambda_mid = (lambda_low + lambda_high) / 2  \n                total_gen = 0.0  \n                for i in committed_set:  \n                    unit = units_info[i]  \n                    min_p, max_p = bounds[i]  \n                    p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])  \n                    p_val = max(min_p, min(max_p, p_val))  \n                    total_gen += p_val  \n                \n                if abs(total_gen - current_load) < tol:  \n                    break  \n                elif total_gen < current_load:  \n                    lambda_low = lambda_mid  \n                else:  \n                    lambda_high = lambda_mid  \n            \n            # Calculate generation with final lambda  \n            total_gen = 0.0  \n            for i in committed_set:  \n                unit = units_info[i]  \n                min_p, max_p = bounds[i]  \n                p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])  \n                p_val = max(min_p, min(max_p, p_val))  \n                dispatch[i] = p_val  \n                total_gen += p_val  \n            \n            # Residual distribution if needed  \n            residual = current_load - total_gen  \n            if abs(residual) > tol:  \n                units_adj = []  \n                for i in committed_set:  \n                    min_p, max_p = bounds[i]  \n                    if residual > 0 and dispatch[i] < max_p:  \n                        units_adj.append(i)  \n                    elif residual < 0 and dispatch[i] > min_p:  \n                        units_adj.append(i)  \n                \n                if units_adj:  \n                    # Weight by available ramp  \n                    ramp_cap = []  \n                    for i in units_adj:  \n                        min_p, max_p = bounds[i]  \n                        if residual > 0:  \n                            ramp_cap.append(max_p - dispatch[i])  \n                        else:  \n                            ramp_cap.append(dispatch[i] - min_p)  \n                    \n                    total_ramp = sum(ramp_cap)  \n                    for idx, i in enumerate(units_adj):  \n                        adj_val = residual * ramp_cap[idx] / total_ramp  \n                        dispatch[i] += adj_val  \n                        min_p, max_p = bounds[i]  \n                        dispatch[i] = max(min_p, min(max_p, dispatch[i]))  \n    \n    # Build schedules  \n    for i in range(num_units):  \n        if i in committed_set:  \n            u_schedule[i] = 1  \n            p_schedule[i] = dispatch.get(i, 0.0)  \n        else:  \n            u_schedule[i] = 0  \n            p_schedule[i] = 0.0  \n    \n    return np.array([u_schedule, p_schedule])  ",
          "from": "crossover",
          "gap_power_rate": 0.0055426455,
          "gap_price_rate": 0.0096148659,
          "fitness": 0.0075787557
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run units that cannot be turned off due to min-up time, shutdown ramp limits, or ramp-down constraints.\n2. Identify must-off units that cannot be turned on due to min-down time constraints.\n3. Sort eligible candidate units by average cost per MW (includes startup cost for off units, excludes for on units).\n4. Commit must-run units and add candidate units in cost-ascending order until capacity meets current load.\n5. For committed units, calculate dispatch bounds based on operational constraints (ramps, startup capacities).\n6. Perform economic dispatch using lambda iteration to allocate load to units within bounds.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    must_run = set()\n    # Identify must-run units\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.add(id(unit))\n            elif unit['p_i_0'] > unit['p_shut_i'] or unit['p_i_0'] > unit['p_down_i']:\n                must_run.add(id(unit))\n    \n    # Helper to check must-off units\n    def is_must_off(unit):\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            return True\n        return False\n    \n    # Build candidate units list\n    candidate_units = []\n    for unit in units_info:\n        uid = id(unit)\n        if uid in must_run:\n            continue\n        if is_must_off(unit):\n            continue\n        candidate_units.append(unit)\n    \n    # Calculate average cost for commitment priority\n    def avg_cost(unit):\n        if unit['u_i_0'] == 1:  # On unit: only fuel cost\n            return (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        else:  # Off unit: fuel cost + startup\n            return (unit['s_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n    \n    # Sort by average cost\n    candidate_units_sorted = sorted(candidate_units, key=avg_cost)\n    \n    # Build final commitment set\n    committed_units = set(must_run)\n    total_capacity = 0.0\n    # Add must-run capacity\n    for unit in units_info:\n        if id(unit) in must_run:\n            if unit['u_i_0'] == 1:\n                total_capacity += unit['p_max_i']\n            else:  # Starting unit has constrained capacity\n                total_capacity += min(unit['p_max_i'], unit['p_start_i'])\n    # Add candidate units until load met\n    for unit in candidate_units_sorted:\n        if total_capacity >= load[0]:\n            break\n        if unit['u_i_0'] == 1:  # Already on\n            added_capacity = unit['p_max_i']\n        else:  # Starting unit\n            added_capacity = min(unit['p_max_i'], unit['p_start_i'])\n        committed_units.add(id(unit))\n        total_capacity += added_capacity\n    \n    # Prepare for economic dispatch\n    committed_list = []\n    bounds = []\n    cost_params = []\n    for unit in units_info:\n        if id(unit) in committed_units:\n            # Calculate dispatch bounds\n            if unit['u_i_0'] == 1:  # Was on\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Was off (starting)\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            committed_list.append(unit)\n            bounds.append((lb, ub))\n            cost_params.append((unit['b_i'], unit['c_i']))\n    \n    if not committed_list:  # No units committed\n        schedules = np.zeros((2, len(units_info)))\n        return schedules\n    \n    # Lambda iteration for economic dispatch\n    low_lam = -10000.0\n    high_lam = 10000.0\n    tol = 0.01\n    n_iters = 100\n    for _ in range(n_iters):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0.0\n        for (b, c), (lb, ub) in zip(cost_params, bounds):\n            # Calculate unconstrained dispatch\n            if c == 0:\n                p = ub if mid_lam >= b else lb\n            else:\n                p = (mid_lam - b) / (2 * c)\n            p = max(lb, min(ub, p))\n            total_power += p\n        \n        if abs(total_power - load[0]) < tol:\n            break\n        if total_power < load[0]:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Calculate final dispatch values\n    dispatch = []\n    for (b, c), (lb, ub) in zip(cost_params, bounds):\n        if c == 0:\n            p = ub if mid_lam >= b else lb\n        else:\n            p = (mid_lam - b) / (2 * c)\n        p = max(lb, min(ub, p))\n        dispatch.append(p)\n    \n    # Map back to original units\n    schedule_u = []\n    schedule_p = []\n    idx = 0\n    for unit in units_info:\n        if id(unit) in committed_units:\n            schedule_u.append(1)\n            schedule_p.append(dispatch[idx])\n            idx += 1\n        else:\n            schedule_u.append(0)\n            schedule_p.append(0.0)\n    \n    schedules = np.array([schedule_u, schedule_p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0089824653,
          "gap_price_rate": 0.011717359,
          "fitness": 0.0103499122
     },
     {
          "name": "dynamic_priority_heuristic",
          "algorithm": "1. Enforce minimum up/down times and shutdown ramp constraints\n2. Calculate priority index for non-forced units: \n   - Active units: marginal cost at p_min_i\n   - Inactive units: marginal cost + amortized startup cost\n3. Commit units by priority order until total capacity \u2265 load\n4. Initialize outputs at feasible minimums considering ramping constraints\n5. Perform economic dispatch:\n   - Increase output for lowest marginal cost units with headroom\n   - Decrease output for highest marginal cost units with footroom\n   - Iterate until load is met within tolerance\n\n",
          "code": "import numpy as np\n\ndef dynamic_priority_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    # Enforce constraints\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on[idx] = True\n        else:\n            if abs(t_i0) < t_off_min:\n                forced_off[idx] = True\n    \n    u = [0] * n_units\n    p = [0] * n_units\n    \n    # Commit forced units\n    for idx in range(n_units):\n        if forced_on[idx]:\n            u[idx] = 1\n        if forced_off[idx]:\n            u[idx] = 0\n    \n    # Priority calculation\n    eligible_units = []\n    for idx in range(n_units):\n        if forced_on[idx] or forced_off[idx]:\n            continue\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            priority = (unit['b_i'] + 2 * unit['c_i'] * p_min) / p_min\n        else:\n            amortized_startup = unit['s_i'] / (unit['t_on_min_i'] * p_min)\n            priority = (unit['b_i'] + 2 * unit['c_i'] * p_min) / p_min + amortized_startup\n        eligible_units.append((priority, idx))\n    \n    eligible_units.sort(key=lambda x: x[0])\n    \n    # Commit by priority\n    total_max = 0\n    for idx in range(n_units):\n        if u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total_max += min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    for priority, idx in eligible_units:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_max += min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    # Initialize outputs\n    total_power = 0\n    for idx in range(n_units):\n        if u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p[idx] = lb\n            else:\n                p[idx] = unit['p_min_i']\n            total_power += p[idx]\n    \n    # Economic dispatch\n    tolerance = 0.1\n    while abs(total_power - current_load) > tolerance:\n        if total_power < current_load:  # Need more power\n            min_mc = float('inf')\n            candidate = -1\n            max_inc = 0\n            for idx in range(n_units):\n                if u[idx] == 0:\n                    continue\n                unit = units_info[idx]\n                mc = 2 * unit['c_i'] * p[idx] + unit['b_i']\n                # Compute headroom\n                if unit['u_i_0'] == 1:\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n                headroom = ub - p[idx]\n                if headroom > tolerance and mc < min_mc:\n                    min_mc = mc\n                    candidate = idx\n                    max_inc = headroom\n            if candidate == -1:\n                break\n            inc = min(max_inc, current_load - total_power)\n            p[candidate] += inc\n            total_power += inc\n        \n        else:  # Need less power\n            max_mc = -float('inf')\n            candidate = -1\n            max_dec = 0\n            for idx in range(n_units):\n                if u[idx] == 0 or units_info[idx]['u_i_0'] == 0:\n                    continue\n                unit = units_info[idx]\n                mc = 2 * unit['c_i'] * p[idx] + unit['b_i']\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                footroom = p[idx] - lb\n                if footroom > tolerance and mc > max_mc:\n                    max_mc = mc\n                    candidate = idx\n                    max_dec = footroom\n            if candidate == -1:\n                break\n            dec = min(max_dec, total_power - current_load)\n            p[candidate] -= dec\n            total_power -= dec\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0055517872,
          "gap_price_rate": 0.0215854404,
          "fitness": 0.0135686138
     },
     {
          "name": "commit_units_priority_amortized",
          "algorithm": "1. Identify forced online units (must be on due to min up-time or shutdown ramp constraints)\n2. Identify forced offline units (due to min down-time)\n3. Classify remaining flexible units as online or offline\n4. Calculate power bounds for online units considering ramp constraints\n5. Start flexible offline units by priority if needed\n6. Economic dispatch among online units to meet load\n7. Set offline units to u_i=0, p_i=0\n\n",
          "code": "import numpy as np\n\ndef commit_units_priority_amortized(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]  # Used in amortization calculation\n    \n    # Initialize output arrays\n    u_i = np.zeros(n_units, dtype=int)\n    p_i = np.zeros(n_units)\n    \n    # Initialize lists for classification\n    forced_on = []\n    forced_off = []\n    flexible_online = []\n    flexible_offline = []\n    online_indices = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n                online_indices.append(i)\n            else:\n                flexible_online.append(i)\n                online_indices.append(i)\n        else:  # Unit was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Prepare online units list and their bounds\n    online_units = forced_on + flexible_online\n    lower_bounds = []\n    upper_bounds = []\n    for i in online_units:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    # Calculate total min/max generation\n    total_min = sum(lower_bounds)\n    total_max = sum(upper_bounds)\n    \n    # Start additional units if needed\n    started_units = []\n    if total_max < current_load and flexible_offline:\n        # Sort flexible offline by amortized cost\n        amortized_costs = []\n        for i in flexible_offline:\n            unit = units_info[i]\n            periods = min(unit['t_on_min_i'], 2)\n            cost = (unit['s_i'] / periods + unit['a_i'] + \n                    unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            amortized_costs.append(cost)\n        \n        sorted_units = [i for _, i in sorted(zip(amortized_costs, flexible_offline))]\n        \n        for i in sorted_units:\n            if total_max >= current_load:\n                break\n            unit = units_info[i]\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            \n            online_units.append(i)\n            online_indices.append(i)\n            started_units.append(i)\n            \n            lower_bounds.append(unit['p_min_i'])\n            upper_bounds.append(ub)\n            \n            total_min += unit['p_min_i']\n            total_max += ub\n    \n    # Economic dispatch for online units\n    allocation = np.array(lower_bounds.copy())\n    residual = current_load - total_min\n    \n    # Case 1: Overproduction\n    if residual < 0:\n        allocation = np.array(lower_bounds)\n    # Case 2: Underproduction\n    elif current_load > total_max:\n        allocation = np.array(upper_bounds)\n    # Case 3: Dispatch needed\n    else:\n        # Sort by marginal cost\n        marginal_costs = []\n        for i, idx in enumerate(online_units):\n            unit = units_info[idx]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * allocation[i])\n        \n        sorted_idx = np.argsort(marginal_costs)\n        headroom = np.array(upper_bounds) - allocation\n        \n        for idx in sorted_idx:\n            if residual <= 0:\n                break\n            if headroom[idx] > residual:\n                allocation[idx] += residual\n                residual = 0\n            else:\n                allocation[idx] += headroom[idx]\n                residual -= headroom[idx]\n    \n    # Assign outputs\n    for i, idx in enumerate(online_units):\n        u_i[idx] = 1\n        p_i[idx] = allocation[i]\n    \n    # Create output array\n    schedules = np.vstack((u_i, p_i))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0342821913,
          "fitness": 0.0172059349
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify units that must remain off (down-time constraints) and others that are initially on.\n2. For units that are initially on:\n   - Compute min and max power outputs considering ramp constraints.\n   - Perform economic dispatch to meet as much current load as possible:\n     - If load <= total minimum output, set outputs to minimums.\n     - Else, distribute load by increasing output in order of incremental cost (2*c_i*p_i + b_i).\n     - Calculate gap (unmet load) after dispatch.\n3. For eligible candidate units (off but not must-off):\n   - Sort by cost metric: (s_i + 2*a_i + 2*b_i*p_min_i + 2*c_i*p_min_i**2) / (2*p_min_i)\n   - Turn on units in sorted order to cover gap, setting output as high as possible without exceeding gap.\n4. Set output for must-off units to 0.\n5. Return unit commitments and power outputs as numpy array.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    # Extract unit info into lists for easy access\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    \n    # Step 1: Identify must-off units\n    must_off = []\n    for i in range(num_units):\n        if u_i_0[i] == 0:\n            if t_i_0[i] < 0 and -t_i_0[i] < t_off_min_i[i]:\n                must_off.append(True)\n            else:\n                must_off.append(False)\n        else:\n            must_off.append(False)\n    \n    # Initialize outputs\n    u_i = [1 if u_i_0[i]==1 else 0 for i in range(num_units)]\n    p_i = [0.0] * num_units\n    \n    # Dispatch units that were initially on\n    on_units = [i for i in range(num_units) if u_i_0[i]==1]\n    min_power = []\n    max_power = []\n    for idx in on_units:\n        min_output = max(p_min_i[idx], p_i_0[idx] - p_down_i[idx])\n        max_output = min(p_max_i[idx], p_i_0[idx] + p_up_i[idx])\n        min_power.append(min_output)\n        max_power.append(max_output)\n    \n    total_min_on = sum(min_power) if min_power else 0\n    total_max_on = sum(max_power) if max_power else 0\n    \n    # Dispatch on_units\n    if total_min_on > current_load:  # Overproduction\n        gap = 0\n        for i, idx in enumerate(on_units):\n            p_i[idx] = min_power[i]\n    else:\n        # Set target for on units\n        target = min(current_load, total_max_on)\n        if total_min_on < target:\n            # Need to distribute the load increase\n            incremental_cost = []\n            for i, idx in enumerate(on_units):\n                ic = 2 * c_i[idx] * min_power[i] + b_i[idx]\n                incremental_cost.append((ic, i))\n            incremental_cost.sort(key=lambda x: x[0])\n            \n            current_total = total_min_on\n            temp_p = min_power.copy()  # temporary dispatch values\n            for _, i in incremental_cost:\n                allocatable = min(max_power[i] - min_power[i], target - current_total)\n                if allocatable > 0:\n                    temp_p[i] += allocatable\n                    current_total += allocatable\n                if current_total >= target:\n                    break\n            # Assign temp_p to p_i\n            for i, idx in enumerate(on_units):\n                p_i[idx] = temp_p[i]\n        else:\n            for i, idx in enumerate(on_units):\n                p_i[idx] = min_power[i]\n        gap = max(0, current_load - target)\n    \n    # Candidate units: off, not must-off\n    candidate_set = [i for i in range(num_units) if u_i_0[i]==0 and not must_off[i]]\n    metric = []\n    for idx in candidate_set:\n        # Metric: (startup + cost for two periods at p_min) / (2 * p_min)\n        if p_min_i[idx] > 0:\n            startup = units_info[idx]['s_i']\n            cost_t = a_i[idx] + b_i[idx]*p_min_i[idx] + c_i[idx]*(p_min_i[idx]**2)\n            cost_t1 = a_i[idx] + b_i[idx]*p_min_i[idx] + c_i[idx]*(p_min_i[idx]**2)\n            metric_i = (startup + cost_t + cost_t1) / (2 * p_min_i[idx])\n            metric.append((metric_i, idx))\n        else:\n            metric.append((float('inf'), idx))\n    metric.sort(key=lambda x: x[0])\n    \n    # Cover gap with candidate units\n    for metric_val, idx in metric:\n        if gap <= 0:\n            break\n        min_output = p_min_i[idx]\n        max_output = min(p_max_i[idx], p_start_i[idx])\n        if max_output < min_output:  # Infeasible unit\n            continue\n        if gap >= max_output:\n            u_i[idx] = 1\n            p_i[idx] = max_output\n            gap -= max_output\n        elif gap >= min_output:\n            u_i[idx] = 1\n            p_i[idx] = gap\n            gap = 0\n    \n    # Build output array\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.000641108,
          "gap_price_rate": 0.0338750615,
          "fitness": 0.0172580847
     }
]