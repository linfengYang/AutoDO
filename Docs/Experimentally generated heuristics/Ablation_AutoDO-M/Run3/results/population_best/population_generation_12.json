{
     "name": "refined_amortized_with_forecast",
     "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp), forced-off (violating min down-time), free online (adjustable online), free offline (adjustable offline).\n2. For free offline units, adjust startup cost amortization based on forecasted load: use half amortization over min up-time if next load >= current load (indicating sustained need), else full amortization.\n3. Precompute cost metrics: operating cost at min power for free online; amortized startup cost plus operating cost for free offline.\n4. Build initial commitment set: forced-on units then free units in ascending cost order until ramp-constrained max capacity >= current load.\n5. Refine committed set: sort free units by cost descending and iteratively remove while maintaining max capacity >= load and reducing min capacity \u2264 load.\n6. For committed units, calculate bounds: previously online consider ramp limits; newly started consider startup ramp limits.\n7. Dispatch in three stages:\n   a) Boundary handling: set outputs to min or max if load out of bounds.\n   b) Bisection for lambda iteration with analytical derivative for quadratic units.\n   c) Discrete settings and residual adjustment for linear units.\n\n",
     "code": "import numpy as np\n\ndef refined_amortized_with_forecast(units_info, load):\n    L_current, L_next = load[0], load[1]\n    num_units = len(units_info)\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < t_up_min or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -t0 < t_down_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        cost_metric[i] = (a + b * p_min + c * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        t_min_up = unit['t_on_min_i']\n        if L_next >= L_current:\n            amortized_startup = s / (2 * t_min_up)\n        else:\n            amortized_startup = s / t_min_up\n        cost_metric[i] = (amortized_startup + a + b * p_min + c * p_min**2) / p_min\n\n    committed_set = set(forced_on)\n    free_sorted = sorted(free_online + free_offline, key=lambda i: cost_metric.get(i, float('inf')))\n    total_max = 0.0\n    for i in committed_set:\n        unit = units_info[i]\n        total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for i in free_sorted:\n        if total_max >= L_current:\n            break\n        unit = units_info[i]\n        max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if i in free_online else min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_cap\n        committed_set.add(i)\n    \n    total_min = 0.0\n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_cap\n        bounds[i] = (min_cap, max_cap)\n    \n    free_committed = [i for i in committed_set if i in free_online or i in free_offline]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric.get(i, 0), reverse=True)\n    for i in free_committed_sorted:\n        min_cap, max_cap = bounds[i]\n        new_total_min = total_min - min_cap\n        new_total_max = total_max - max_cap\n        if new_total_min <= L_current and new_total_max >= L_current:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    bounds = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if i in free_offline:\n            min_cap = unit['p_min_i']\n            max_cap = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_cap = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (min_cap, max_cap)\n    \n    total_min = sum(bounds[i][0] for i in committed_set)\n    total_max = sum(bounds[i][1] for i in committed_set)\n    \n    quadratic_units = []\n    linear_units = []\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['c_i'] > 0:\n            quadratic_units.append(i)\n        else:\n            linear_units.append(i)\n    \n    if L_current <= total_min:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][0]\n    elif L_current >= total_max:\n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = bounds[i][1]\n    else:\n        p_vals = {}\n        residual = L_current\n        for i in linear_units:\n            unit = units_info[i]\n            _, max_cap = bounds[i]\n            if unit['b_i'] <= unit['a_i'] / max_cap + unit['b_i']:\n                p_vals[i] = max_cap\n            else:\n                p_vals[i] = bounds[i][0]\n            residual -= p_vals[i]\n        \n        if quadratic_units:\n            low, high = 0, 0\n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                low = min(low, unit['b_i'] + 2 * unit['c_i'] * min_cap)\n                high = max(high, unit['b_i'] + 2 * unit['c_i'] * max_cap)\n            \n            tol = 1e-3\n            max_iter = 100\n            for _ in range(max_iter):\n                mid = (low + high) / 2\n                total_power = residual\n                for i in quadratic_units:\n                    unit = units_info[i]\n                    min_cap, max_cap = bounds[i]\n                    p = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                    total_power += p\n                if abs(total_power) < tol:\n                    break\n                if total_power < 0:\n                    high = mid\n                else:\n                    low = mid\n            \n            for i in quadratic_units:\n                unit = units_info[i]\n                min_cap, max_cap = bounds[i]\n                p_vals[i] = max(min_cap, min(max_cap, (mid - unit['b_i']) / (2 * unit['c_i'])))\n                residual -= p_vals[i]\n        \n        if abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = bounds[i][1] - current_p\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) + adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n            else:\n                residual = abs(residual)\n                candidates = []\n                for i in committed_set:\n                    unit = units_info[i]\n                    current_p = p_vals.get(i, 0)\n                    cap_avail = current_p - bounds[i][0]\n                    if cap_avail > 1e-5:\n                        if unit['c_i'] > 0:\n                            marginal = unit['b_i'] + 2 * unit['c_i'] * current_p\n                        else:\n                            marginal = unit['b_i']\n                        candidates.append((i, marginal, cap_avail))\n                candidates.sort(key=lambda x: -x[1])\n                for i, marginal, cap_avail in candidates:\n                    adjust = min(residual, cap_avail)\n                    p_vals[i] = p_vals.get(i, 0) - adjust\n                    residual -= adjust\n                    if residual < 1e-5:\n                        break\n        \n        for i in committed_set:\n            u_out[i] = 1\n            p_out[i] = p_vals.get(i, bounds[i][0])\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0031320448,
     "gap_price_rate": 0.0067061217,
     "fitness": 0.0049190833
}