{
     "name": "rolling_unit_commitment",
     "algorithm": "1. Classify units into forced-on (must remain online due to minimum up-time or shutdown ramp constraints), forced-off (must remain offline due to minimum down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline).\n2. Precompute cost metrics for free units:\n   - Free online: cost rate = (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n   - Free offline: cost rate = (s_i / t_on_min_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i\n3. Form candidate commitment set starting with forced-on units, then add free units sorted by ascending cost rate until total ramp-constrained max capacity \u2265 current load. Precompute ramp-constrained min/max for each unit during classification.\n4. Refine commitment by removing expensive free units:\n   - Sort committed free units by cost rate descending\n   - Iteratively remove the most expensive unit if removal maintains max capacity \u2265 load and reduces min capacity below or equal to load\n5. Calculate dispatch bounds for committed units considering startup/shutdown ramps and online ramp constraints:\n   - Previously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Newly started units: [p_min_i, min(p_max_i, p_start_i)]\n6. Perform economic dispatch using optimized lambda iteration:\n   - Handle boundary cases where load \u2264 total min or \u2265 total max\n   - Use bisection with analytical derivative for faster convergence\n   - Distribute residual with priority-based greedy adjustment to ensure exact load matching\n7. Set non-committed units to offline state (u_i=0, p_i=0).\n8. Return commitment states and power outputs as a 2D NumPy array.\n",
     "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = [0] * n_units\n    p_schedule = [0] * n_units\n    \n    # Data structures to store processed unit information\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    processed_units = [None] * n_units\n    \n    # Classify units and precompute parameters\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        forced_on_flag = False\n        forced_off_flag = False\n        \n        if u0 == 1:  # Currently online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on_flag = True\n                forced_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:  # Currently offline\n            if -t0 < unit['t_off_min_i']:\n                forced_off_flag = True\n                forced_off.append(idx)\n            else:\n                free_offline.append(idx)\n                \n        # Precompute ramp-constrained boundaries\n        if u0 == 1:  # Online units\n            min_p = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline units\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate amortized cost rate for free units\n        if not (forced_on_flag or forced_off_flag):\n            operating_cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            if u0 == 1:  # Free online\n                cost_rate = operating_cost_min / unit['p_min_i']\n            else:  # Free offline\n                startup_amortized = unit['s_i'] / unit['t_on_min_i']\n                cost_rate = (operating_cost_min + startup_amortized) / unit['p_min_i']\n        else:\n            cost_rate = float('inf') if forced_off_flag else -float('inf')\n        \n        processed_units[idx] = {\n            'idx': idx,\n            'u0': u0,\n            'forced_on': forced_on_flag,\n            'forced_off': forced_off_flag,\n            'min_bound': min_p,\n            'max_bound': max_p,\n            'cost_rate': cost_rate,\n            'b': unit['b_i'],\n            'c': unit['c_i']\n        }\n    \n    # Initialize commitment set with forced-on units\n    committed_set = set(forced_on)\n    total_min = sum(processed_units[idx]['min_bound'] for idx in forced_on)\n    total_max = sum(processed_units[idx]['max_bound'] for idx in forced_on)\n    \n    # Candidate free units sorted by cost rate (ascending)\n    free_candidates = free_online + free_offline\n    free_candidates.sort(key=lambda idx: processed_units[idx]['cost_rate'])\n    \n    # Add free units until capacity meets or exceeds load\n    for idx in free_candidates:\n        if total_max < current_load:\n            committed_set.add(idx)\n            total_min += processed_units[idx]['min_bound']\n            total_max += processed_units[idx]['max_bound']\n        else:\n            break\n    \n    # Remove expensive free units if min capacity exceeds load\n    free_in_commit = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_in_commit.sort(key=lambda idx: processed_units[idx]['cost_rate'], reverse=True)\n    removed = True\n    while removed and total_min > current_load:\n        removed = False\n        for idx in free_in_commit:\n            unit = processed_units[idx]\n            new_min = total_min - unit['min_bound']\n            new_max = total_max - unit['max_bound']\n            if new_max >= current_load:\n                committed_set.remove(idx)\n                total_min = new_min\n                total_max = new_max\n                free_in_commit.remove(idx)\n                removed = True\n                break\n    \n    # Prepare dispatch units with valid bounds\n    dispatch_units = []\n    for idx in committed_set:\n        unit = processed_units[idx]\n        min_bound = unit['min_bound']\n        max_bound = unit['max_bound']\n        \n        # Ensure bounds are valid\n        if min_bound > max_bound:\n            min_bound = max_bound = (min_bound + max_bound) / 2\n            \n        dispatch_units.append({\n            'min': min_bound,\n            'max': max_bound,\n            'b': unit['b'],\n            'c': unit['c'],\n            'idx': idx\n        })\n    \n    # Calculate total dispatch bounds\n    total_min_dispatch = sum(unit['min'] for unit in dispatch_units)\n    total_max_dispatch = sum(unit['max'] for unit in dispatch_units)\n    \n    # Handle boundary cases\n    if current_load <= total_min_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['min']\n    elif current_load >= total_max_dispatch:\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['max']\n    else:\n        # Lambda iteration (bisection) with derivative for speed\n        low_lambda = 0\n        high_lambda = 1e6\n        tolerance = 1e-5\n        iterations = 0\n        \n        while iterations < 100 and (high_lambda - low_lambda) > tolerance:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            derivative_sum = 0\n            \n            for unit in dispatch_units:\n                c = unit['c']\n                if c == 0:  # Linear cost function\n                    p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n                else:\n                    p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                    p = max(unit['min'], min(unit['max'], p_unclamped))\n                \n                unit['p_temp'] = p\n                total_power += p\n                \n                if unit['min'] < p < unit['max']:\n                    derivative_sum += 1 / (2 * c)\n            \n            if derivative_sum == 0:  # All units at bounds\n                if total_power < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            else:\n                lambda_derivative = derivative_sum\n                error = total_power - current_load\n                mid_lambda -= error / lambda_derivative\n                \n                if total_power > current_load:\n                    high_lambda = mid_lambda\n                else:\n                    low_lambda = mid_lambda\n            \n            iterations += 1\n        \n        # Final power calculation\n        total_power = 0\n        for unit in dispatch_units:\n            c = unit['c']\n            if c == 0:\n                p = unit['max'] if mid_lambda > unit['b'] else unit['min']\n            else:\n                p_unclamped = (mid_lambda - unit['b']) / (2 * c)\n                p = max(unit['min'], min(unit['max'], p_unclamped))\n            unit['p_temp'] = p\n            total_power += p\n        \n        # Adjust for residual with greedy method\n        residual = current_load - total_power\n        if abs(residual) > tolerance:\n            if residual > 0:\n                candidates = [u for u in dispatch_units if u['p_temp'] < u['max']]\n                candidates.sort(key=lambda u: u['b'] + 2 * u['c'] * u['p_temp'])\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['max'] - unit['p_temp']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] += adjust\n                    residual -= adjust\n            else:\n                residual = abs(residual)\n                candidates = [u for u in dispatch_units if u['p_temp'] > u['min']]\n                candidates.sort(key=lambda u: -(u['b'] + 2 * u['c'] * u['p_temp']))\n                for unit in candidates:\n                    if residual <= 0:\n                        break\n                    avail = unit['p_temp'] - unit['min']\n                    adjust = min(avail, residual)\n                    unit['p_temp'] -= adjust\n                    residual -= adjust\n        \n        # Assign final dispatch values\n        for unit in dispatch_units:\n            p_schedule[unit['idx']] = unit['p_temp']\n    \n    # Set commitment states\n    for idx in committed_set:\n        u_schedule[idx] = 1\n    \n    return np.array([u_schedule, p_schedule])",
     "from": "mutation",
     "gap_power_rate": 0.0033675075,
     "gap_price_rate": 0.0081376386,
     "fitness": 0.0057525731
}