{
     "name": "enhanced_amortized_cost_dispatch",
     "algorithm": "1. Classify units into forced-on (due to min up-time or shutdown constraints), forced-off (due to min down-time), free online (adjustable and currently online), and free offline (adjustable and currently offline). 2. Precompute amortized cost metrics for free units: (operating cost at min power for free online; startup cost amortized over min up-time plus operating cost at min power for free offline). 3. Form initial commitment set: forced-on units + free units sorted by amortized cost. 4. While total ramp-constrained max capacity < current load: add next cheapest free unit. 5. While total ramp-constrained min capacity > load: remove most expensive free unit (if feasible). 6. For committed units: calculate feasible power bounds considering ramp constraints. 7. Dispatch load using lambda iteration with residual adjustment for exact matching. 8. Set non-committed units to off with zero output.\n",
     "code": "import numpy as np\n\ndef enhanced_amortized_cost_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units based on constraints and state\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Calculate cost metrics for free units\n    cost_metric = {}\n    for i in free_online:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        cost_metric[i] = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = max(1e-5, unit['p_min_i'])\n        amortized_startup = unit['s_i'] / max(1, unit['t_on_min_i'])\n        cost_metric[i] = (amortized_startup + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n    \n    # Create sorted free unit list (by cost metric ascending)\n    free_units = free_online + free_offline\n    free_units_sorted = sorted(free_units, key=lambda i: cost_metric[i])\n    \n    # Initialize committed set with forced-on units\n    committed_set = set(forced_on)\n    \n    # Calculate initial capacity bounds\n    total_min = 0.0\n    total_max = 0.0\n    \n    def get_feasible_bounds(i, committed=False):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Was offline, only if committed (being started)\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        return min_p, max_p\n    \n    for i in committed_set:\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Add free units until total_max >= current_load\n    for i in free_units_sorted:\n        if total_max >= current_load:\n            break\n        if i in committed_set:\n            continue\n        min_p_i, max_p_i = get_feasible_bounds(i, True)\n        committed_set.add(i)\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    # Remove expensive free units if total_min > current_load\n    free_committed = [i for i in committed_set if i not in forced_on]\n    free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    changed = True\n    while changed and free_committed_sorted:\n        changed = False\n        for i in free_committed_sorted:\n            candidate_set = committed_set - {i}\n            # Recalculate bounds for candidate set\n            new_min = 0.0\n            new_max = 0.0\n            for j in candidate_set:\n                min_p_j, max_p_j = get_feasible_bounds(j, j in candidate_set)\n                new_min += min_p_j\n                new_max += max_p_j\n            if new_min <= current_load <= new_max:\n                committed_set = candidate_set\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n        # Update free_committed list after removal\n        free_committed = [i for i in committed_set if i not in forced_on]\n        free_committed_sorted = sorted(free_committed, key=lambda i: cost_metric[i], reverse=True)\n    \n    # Update commitment status\n    for i in committed_set:\n        u[i] = 1\n    \n    # Precompute bounds for dispatch\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    for i in committed_set:\n        min_b, max_b = get_feasible_bounds(i, True)\n        min_bounds[i] = min_b\n        max_bounds[i] = max_b\n    \n    # Collect indices and coefficients for committed units\n    committed_indices = list(committed_set)\n    b_arr = np.array([units_info[i]['b_i'] for i in committed_indices])\n    c_arr = np.array([units_info[i]['c_i'] for i in committed_indices])\n    min_p_arr = min_bounds[committed_indices]\n    max_p_arr = max_bounds[committed_indices]\n    \n    # Initialize power for committed units\n    p_committed = np.zeros(len(committed_indices))\n    \n    # Lambda iteration for dispatch\n    if len(committed_indices) > 0:\n        lo_mc = 1e-6\n        hi_mc = 1e8\n        tol = 1e-3\n        max_iter = 100\n        \n        for _ in range(max_iter):\n            lam = (lo_mc + hi_mc) / 2\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:  # Linear cost\n                    if lam > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:  # Quadratic cost\n                    p_unclipped = (lam - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            \n            total_proposed = np.sum(p_proposed)\n            \n            if abs(total_proposed - current_load) < tol:\n                p_committed = p_proposed\n                break\n            \n            if total_proposed < current_load:\n                lo_mc = lam\n            else:\n                hi_mc = lam\n        else:\n            p_proposed = np.zeros_like(p_committed)\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                if c_arr[idx] == 0:\n                    if lo_mc > b_arr[idx]:\n                        p_proposed[idx] = max_p_arr[idx]\n                    else:\n                        p_proposed[idx] = min_p_arr[idx]\n                else:\n                    p_unclipped = (lo_mc - b_arr[idx]) / (2 * c_arr[idx])\n                    p_proposed[idx] = np.clip(p_unclipped, min_p_arr[idx], max_p_arr[idx])\n            p_committed = p_proposed\n        \n        # Residual adjustment for exact match\n        total_gen = np.sum(p_committed)\n        residual = current_load - total_gen\n        if abs(residual) > 1e-3:\n            # Positive residual: increase under-max units by marginal cost\n            if residual > 0:\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] < max_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    headroom = max_p_arr[unit_idx] - p_committed[unit_idx]\n                    if headroom < residual:\n                        p_committed[unit_idx] += headroom\n                        residual -= headroom\n                    else:\n                        p_committed[unit_idx] += residual\n                        residual = 0\n                        break\n            # Negative residual: decrease above-min units by marginal cost (reverse)\n            else:\n                residual = abs(residual)\n                adjustable = [idx for idx, i in enumerate(committed_indices) if p_committed[idx] > min_p_arr[idx]]\n                marginal_costs = [b_arr[idx] + 2 * c_arr[idx] * p_committed[idx] for idx in adjustable]\n                order = np.argsort(marginal_costs)[::-1]\n                for idx in order:\n                    unit_idx = adjustable[idx]\n                    footroom = p_committed[unit_idx] - min_p_arr[unit_idx]\n                    if footroom < residual:\n                        p_committed[unit_idx] -= footroom\n                        residual -= footroom\n                    else:\n                        p_committed[unit_idx] -= residual\n                        residual = 0\n                        break\n        \n        # Assign power values to committed units\n        for idx, unit_idx in enumerate(committed_indices):\n            p[unit_idx] = p_committed[idx]\n    \n    # Set non-committed units to off and output zero\n    for i in range(n_units):\n        if i not in committed_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.vstack((u, p))\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0050588692,
     "gap_price_rate": 0.0088502454,
     "fitness": 0.0069545573
}