{
     "name": "enhanced_rolling_commitment_hybrid",
     "algorithm": "1. Identify must-run units (currently online violating min-up time or exceeding shutdown ramp) and must-off units (currently offline violating min-down time). 2. Compute feasible output ranges for each unit based on commitment status, ramp limits, and startup/shutdown constraints. 3. Calculate amortized cost per MW at minimum output for flexible units, including startup costs for offline units. 4. Initialize commitment set with must-run units and add flexible units in ascending amortized cost order until capacity meets forecasted load. 5. Decommit flexible units in descending cost order while maintaining feasibility (total min \u2264 load \u2264 total max). 6. Dispatch load by: (a) Setting committed units to min output if total min \u2265 load (b) Setting to max output if total max \u2264 load (c) Performing incremental cost dispatch with ramp constraints for residual load otherwise.  \n\n",
     "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_hybrid(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run_indices = []\n    must_off_indices = []\n    flexible_indices = []\n    min_outputs = {}\n    max_outputs = {}\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                flexible_indices.append(i)\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n                min_outputs[i] = 0\n                max_outputs[i] = 0\n            else:\n                flexible_indices.append(i)\n                min_outputs[i] = unit['p_min_i']\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    flexible_avgs = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * (min_outputs[i] ** 2) + unit['s_i']\n        else:\n            total_cost = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * (min_outputs[i] ** 2)\n        if min_outputs[i] > 0:\n            avg_cost = total_cost / min_outputs[i]\n        else:\n            avg_cost = 1e12\n        flexible_avgs.append((avg_cost, i, min_outputs[i], max_outputs[i]))\n    \n    flexible_avgs_sorted = sorted(flexible_avgs, key=lambda x: x[0])\n    committed_set = set(must_run_indices)\n    total_min = sum(min_outputs[i] for i in must_run_indices)\n    total_max = sum(max_outputs[i] for i in must_run_indices)\n    added_flexible = []\n    \n    for item in flexible_avgs_sorted:\n        if total_max < current_load:\n            _, i, min_i, max_i = item\n            committed_set.add(i)\n            added_flexible.append(item)\n            total_min += min_i\n            total_max += max_i\n            if total_max >= current_load:\n                break\n        else:\n            break\n    \n    added_flexible_sorted_desc = sorted(added_flexible, key=lambda x: x[0], reverse=True)\n    for item in added_flexible_sorted_desc:\n        avg_cost, i, min_i, max_i = item\n        new_total_min = total_min - min_i\n        new_total_max = total_max - max_i\n        if new_total_min <= current_load and new_total_max >= current_load:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    current_outputs = {}\n    for i in committed_set:\n        current_outputs[i] = min_outputs[i]\n    \n    if abs(total_min - current_load) < 1e-6:\n        pass\n    elif abs(total_max - current_load) < 1e-6:\n        for i in committed_set:\n            current_outputs[i] = max_outputs[i]\n    else:\n        residual = current_load - total_min\n        heap = []\n        for i in committed_set:\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            inc_cost = b + 2 * c * current_outputs[i]\n            heapq.heappush(heap, (inc_cost, i, current_outputs[i], max_outputs[i]))\n        \n        while residual > 1e-6 and heap:\n            inc_cost, i, cur_p, max_p = heapq.heappop(heap)\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            available = max_p - cur_p\n            if available > 0:\n                delta = min(available, residual)\n                new_p = cur_p + delta\n                residual -= delta\n                current_outputs[i] = new_p\n                if new_p < max_p:\n                    new_inc_cost = b + 2 * c * new_p\n                    heapq.heappush(heap, (new_inc_cost, i, new_p, max_p))\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in committed_set:\n            schedules[0, i] = 1\n            schedules[1, i] = current_outputs[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.0061982268,
     "gap_price_rate": 0.0081920316,
     "fitness": 0.0071951292
}