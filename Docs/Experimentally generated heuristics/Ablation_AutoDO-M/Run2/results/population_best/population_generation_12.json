{
     "name": "enhanced_rolling_commitment",
     "algorithm": "1. Identify must-run units (currently online that violate minimum up-time or exceed shutdown ramp limit) and must-off units (currently offline that violate minimum down-time).\n2. Compute feasible output ranges for all units based on commitment status and physical constraints (ramp rates, startup/shutdown limits).\n3. Calculate cost per MW at minimum output for all flexible units (non must-run/must-off), including amortized startup cost for offline units.\n4. Build commitment set by:\n   - Starting with must-run units\n   - Adding flexible units in ascending cost/MW order until total maximum capacity meets load\n5. Decommit expensive flexible units while maintaining feasibility (total min \u2264 load \u2264 total max)\n6. Dispatch load by:\n   - Setting all committed units to minimum output if total minimum \u2265 load\n   - Setting to maximum output if total maximum \u2264 load\n   - Performing incremental cost-based economic dispatch for residual load otherwise\n7. Set uncommitted units to off with zero output\n\n",
     "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    unit_list = [unit.copy() for unit in units_info]\n    \n    # Initialize unit tracking\n    for i, unit in enumerate(unit_list):\n        unit['must_run'] = False\n        unit['must_off'] = False\n        unit['committed'] = False\n        unit['min_feas'] = 0.0\n        unit['max_feas'] = 0.0\n        unit['cost_per_MW'] = float('inf')\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in unit_list:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run units\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                unit['must_run'] = True\n                unit['min_feas'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                unit['max_feas'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        # Must-off units\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                unit['must_off'] = True\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Compute cost/MW for flexible units\n    for unit in flexible:\n        u_i0 = unit['u_i_0']\n        \n        # Previously online units\n        if u_i0 == 1:\n            unit['min_feas'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feas'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * unit['min_feas'] + unit['c_i'] * unit['min_feas'] ** 2\n            if unit['min_feas'] > 0:\n                unit['cost_per_MW'] = cost / unit['min_feas']\n        \n        # Offline units that can be started\n        else:\n            unit['min_feas'] = unit['p_min_i']\n            unit['max_feas'] = min(unit['p_max_i'], unit['p_start_i'])\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['min_feas'] + unit['c_i'] * unit['min_feas'] ** 2\n            if unit['min_feas'] > 0:\n                unit['cost_per_MW'] = cost / unit['min_feas']\n    \n    # Build initial commitment set\n    committed = must_run.copy()\n    total_min = sum(unit['min_feas'] for unit in must_run)\n    total_max = sum(unit['max_feas'] for unit in must_run)\n    flexible.sort(key=lambda x: x['cost_per_MW'])\n    \n    # Add flexible units until load can be met\n    for unit in flexible:\n        if total_max < current_load:\n            committed.append(unit)\n            total_min += unit['min_feas']\n            total_max += unit['max_feas']\n    \n    # Decommit expensive units while maintaining feasibility\n    flexible_committed = [u for u in committed if u in flexible]\n    flexible_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    \n    removed = True\n    while removed and flexible_committed:\n        removed = False\n        for i, unit in enumerate(flexible_committed):\n            new_min = total_min - unit['min_feas']\n            new_max = total_max - unit['max_feas']\n            if new_max >= current_load and new_min <= current_load:\n                total_min = new_min\n                total_max = new_max\n                committed.remove(unit)\n                flexible_committed.pop(i)\n                removed = True\n                break\n    \n    # Set commitment status\n    for unit in committed:\n        unit['committed'] = True\n    \n    # Dispatch load to committed units\n    if total_min >= current_load:\n        for unit in committed:\n            unit['p_i'] = unit['min_feas']\n    elif total_max <= current_load:\n        for unit in committed:\n            unit['p_i'] = unit['max_feas']\n    else:\n        # Allocate minimum power\n        for unit in committed:\n            unit['p_i'] = unit['min_feas']\n        residual = current_load - total_min\n        \n        # Allocate residual load by incremental cost\n        committed.sort(key=lambda x: 2*x['c_i']*x['min_feas'] + x['b_i'])\n        for unit in committed:\n            alloc = min(residual, unit['max_feas'] - unit['p_i'])\n            unit['p_i'] += alloc\n            residual -= alloc\n            if residual <= 0:\n                break\n    \n    # Generate output\n    for i, unit in enumerate(unit_list):\n        schedules[0, i] = 1 if unit['committed'] else 0\n        schedules[1, i] = unit['p_i']\n            \n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.005982537,
     "gap_price_rate": 0.0086275961,
     "fitness": 0.0073050665
}