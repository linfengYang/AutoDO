[
     {
          "name": "rolling_commitment_v1",
          "algorithm": "**  \n1. Identify must-run units if currently online but violating minimum up-time or previous output exceeds shutdown ramp limit.  \n2. Identify must-off units if currently offline but violating minimum down-time.  \n3. For must-run units, compute feasible min/max outputs considering ramp and startup constraints.  \n4. For remaining units, calculate cost/MW at minimum output (including startup cost for offline units) and sort ascending.  \n5. Add flexible units to commitment until total max feasible capacity meets load, updating cumulative min/max outputs.  \n6. If cumulative min output exceeds load, set all committed units to min output.  \n7. If cumulative max output is below load, set all committed units to max output.  \n8. Otherwise, perform economic dispatch:  \n   - Initialize each unit at min output  \n   - Allocate remaining load ascending by incremental cost at min output  \n   - Respect individual unit's max output and ramp constraints  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize vectors\n    min_on = np.zeros(n_units)\n    max_on = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    \n    # Step 1-3: Determine must-run/must-off and compute feasible ranges\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            min_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off.append(i)\n            min_on[i] = unit['p_min_i']\n            max_on[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize capacity\n    total_min = sum(min_on[i] for i in must_run)\n    total_max = sum(max_on[i] for i in must_run)\n    candidate_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    candidate_costs = []\n    \n    # Step 4: Calculate cost/MW for candidate units\n    for i in candidate_units:\n        unit = units_info[i]\n        min_p = min_on[i]\n        if unit['u_i_0'] == 1:  # Currently online\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        else:  # Currently offline (add startup cost)\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2 + unit['s_i']\n        candidate_costs.append((i, cost / min_p))\n    \n    # Sort candidates by cost/MW\n    candidate_costs.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    \n    # Step 5: Commit flexible units\n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        total_min += min_on[i]\n        total_max += max_on[i]\n        committed.append(i)\n    \n    # Step 6-8: Dispatch generation\n    u_vec = [0] * n_units\n    p_vec = [0] * n_units\n    \n    if total_min > current_load:  # Over-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n    elif total_max < current_load:  # Under-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = max_on[i]\n    else:  # Economic dispatch\n        # Initialize at min output\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n        deficit = current_load - total_min\n        \n        # Sort by incremental cost at min output\n        units_to_dispatch = []\n        for i in committed:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_on[i] + unit['b_i']\n            headroom = max_on[i] - min_on[i]\n            units_to_dispatch.append((inc_cost, i, headroom))\n        units_to_dispatch.sort(key=lambda x: x[0])\n        \n        # Allocate deficit\n        for inc_cost, i, headroom in units_to_dispatch:\n            if deficit <= 0:\n                break\n            allocate = min(headroom, deficit)\n            p_vec[i] += allocate\n            deficit -= allocate\n    \n    return np.array([u_vec, p_vec])",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "rolling_commitment_v2",
          "algorithm": "1. Identify must-run units if currently online and violating minimum up-time, shutdown ramp limit, or ramp-down constraint (previous output > ramp-down limit)\n2. Identify must-off units if currently offline and violating minimum down-time\n3. For must-run units, compute feasible outputs considering ramp constraints\n4. For remaining flexible units, calculate cost per MW at minimum output including startup cost for offline units\n5. Sort flexible units by ascending cost per MW\n6. Commit flexible units in cost order until total maximum capacity covers current load\n7. If total minimum output exceeds current load, set committed units to minimum outputs\n8. If total maximum output is below current load, set committed units to maximum outputs\n9. Otherwise perform economic dispatch starting at minimum outputs and allocating residual load by ascending incremental cost\n10. Ensure uncommitted units remain off with zero output\n",
          "code": "import numpy as np\n\ndef rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    \n    # Identify must-run and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']) or (unit['p_i_0'] > unit['p_down_i']):\n                must_run[i] = True\n        if unit['u_i_0'] == 0:\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run units\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    flexible_indices = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    flexible_list = []\n    \n    # Prepare flexible units for commitment\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2) / min_i\n        else:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2) / min_i\n        flexible_list.append((i, cost_per_mw, min_i, max_i))\n    \n    flexible_list.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    committed_flexible = []\n    for (i, cost_per_mw, min_i, max_i) in flexible_list:\n        if total_max < load[0]:\n            u[i] = 1\n            committed_flexible.append(i)\n            min_output[i] = min_i\n            max_output[i] = max_i\n            total_min += min_i\n            total_max += max_i\n        else:\n            break\n    \n    # Handle output levels\n    if total_min > load[0]:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n    elif total_max < load[0]:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = max_output[i]\n    else:\n        residual = load[0] - total_min\n        committed_indices = [i for i in range(n_units) if u[i] == 1]\n        dispatch_list = []\n        \n        for i in committed_indices:\n            inc_cost = 2 * units_info[i]['c_i'] * min_output[i] + units_info[i]['b_i']\n            headroom = max_output[i] - min_output[i]\n            dispatch_list.append((i, inc_cost, headroom))\n            p[i] = min_output[i]\n        \n        dispatch_list.sort(key=lambda x: x[1])\n        \n        for (i, inc_cost, headroom) in dispatch_list:\n            if residual <= 0:\n                break\n            alloc = min(headroom, residual)\n            p[i] += alloc\n            residual -= alloc\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0005091712,
          "gap_price_rate": 0.0232513196,
          "fitness": 0.0118802454
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints.  \n2. Initialize commitment states for flexible units to their previous state.  \n3. Adjust flexible unit commitments:  \n   - If current minimum output exceeds load, turn off flexible units with highest production costs.  \n   - If current maximum output falls short of load, turn on flexible units using amortized startup costs over min up-time.  \n4. Perform constrained economic dispatch:  \n   - Set initial output to lower bounds.  \n   - Distribute remaining load by increasing output of units with smallest incremental cost, respecting upper bounds.  \n5. Ensure units turned off have zero output.  \n\n",
          "code": "import numpy as np  \n\ndef rolling_commitment_heuristic(units_info, load):  \n    n = len(units_info)  \n    u = [0] * n  \n    p = [0.0] * n  \n    lb_list = [0.0] * n  \n    ub_list = [0.0] * n  \n    must_run = [False] * n  \n    must_off = [False] * n  \n    current_load = load[0]  \n      \n    # Identify must-run and must-off units  \n    for i, unit in enumerate(units_info):  \n        u_prev = unit['u_i_0']  \n        t_prev = unit['t_i_0']  \n        p_prev = unit['p_i_0']  \n        if u_prev == 1:  \n            if (t_prev < unit['t_on_min_i']) or (p_prev > unit['p_shut_i']):  \n                must_run[i] = True  \n        else:  \n            if -t_prev < unit['t_off_min_i']:  \n                must_off[i] = True  \n      \n    # Initialize commitment states  \n    for i in range(n):  \n        if must_run[i]:  \n            u[i] = 1  \n        elif must_off[i]:  \n            u[i] = 0  \n        else:  \n            u[i] = units_info[i]['u_i_0']  \n      \n    # Compute initial total min and max  \n    total_min, total_max = 0.0, 0.0  \n    for i, unit in enumerate(units_info):  \n        if u[i] == 1:  \n            if u[i] == 1 and unit['u_i_0'] == 1:  \n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n            elif u[i] == 1 and unit['u_i_0'] == 0:  \n                lb = unit['p_min_i']  \n                ub = min(unit['p_max_i'], unit['p_start_i'])  \n            else:  \n                lb, ub = 0.0, 0.0  \n            lb_list[i] = lb  \n            ub_list[i] = ub  \n            total_min += lb  \n            total_max += ub  \n        else:  \n            lb_list[i] = 0.0  \n            ub_list[i] = 0.0  \n      \n    # Adjust for over-commitment  \n    if total_min > current_load:  \n        candidate_off = []  \n        for i in range(n):  \n            if not must_run[i] and not must_off[i] and u[i] == 1:  \n                unit = units_info[i]  \n                a_i = unit['a_i']  \n                b_i = unit['b_i']  \n                c_i = unit['c_i']  \n                p_max_i = unit['p_max_i']  \n                if p_max_i > 0:  \n                    avg_cost = (a_i + b_i * p_max_i + c_i * p_max_i**2) / p_max_i  \n                else:  \n                    avg_cost = float('inf')  \n                candidate_off.append((i, avg_cost))  \n        candidate_off.sort(key=lambda x: x[1], reverse=True)  \n        for i, _ in candidate_off:  \n            if total_min <= current_load:  \n                break  \n            u[i] = 0  \n            total_min -= lb_list[i]  \n            total_max -= ub_list[i]  \n            lb_list[i] = 0.0  \n            ub_list[i] = 0.0  \n      \n    # Adjust for under-commitment  \n    if total_max < current_load:  \n        candidate_on = []  \n        for i in range(n):  \n            if not must_off[i] and u[i] == 0:  \n                unit = units_info[i]  \n                a_i = unit['a_i']  \n                b_i = unit['b_i']  \n                c_i = unit['c_i']  \n                s_i = unit['s_i']  \n                p_max_i = unit['p_max_i']  \n                p_start_i = unit['p_start_i']  \n                t_on_min_i = unit['t_on_min_i']  \n                curr_max = min(p_max_i, p_start_i)  \n                if t_on_min_i > 1:  \n                    min_out = unit['p_min_i']  \n                    total_energy = curr_max + (t_on_min_i - 1) * min_out  \n                    total_cost = s_i + a_i * t_on_min_i + b_i * (curr_max + (t_on_min_i - 1) * min_out) + c_i * (curr_max**2 + (t_on_min_i - 1) * min_out**2)  \n                    amort_cost = total_cost / total_energy if total_energy > 0 else float('inf')  \n                else:  \n                    total_cost = s_i + a_i + b_i * curr_max + c_i * curr_max**2  \n                    amort_cost = total_cost / curr_max if curr_max > 0 else float('inf')  \n                candidate_on.append((i, amort_cost))  \n        candidate_on.sort(key=lambda x: x[1])  \n        for i, cost_val in candidate_on:  \n            if total_max >= current_load:  \n                break  \n            u[i] = 1  \n            unit = units_info[i]  \n            lb_i = unit['p_min_i']  \n            ub_i = min(unit['p_max_i'], unit['p_start_i'])  \n            lb_list[i] = lb_i  \n            ub_list[i] = ub_i  \n            total_min += lb_i  \n            total_max += ub_i  \n      \n    # Set initial dispatch to lower bounds  \n    p = lb_list[:]  \n    total_assigned = sum(p)  \n    remaining = current_load - total_assigned  \n      \n    # Economic dispatch: incremental cost allocation  \n    if remaining > 1e-5:  \n        available_units = [i for i in range(n) if u[i] == 1 and p[i] < ub_list[i]]  \n        while available_units and remaining > 1e-5:  \n            costs = []  \n            for i in available_units:  \n                b = units_info[i]['b_i']  \n                c = units_info[i]['c_i']  \n                costs.append((2 * c * p[i] + b, i))  \n            min_cost, min_idx = min(costs, key=lambda x: x[0])  \n            headroom = ub_list[min_idx] - p[min_idx]  \n            delta = min(remaining, headroom)  \n            p[min_idx] += delta  \n            remaining -= delta  \n            if abs(p[min_idx] - ub_list[min_idx]) < 1e-5:  \n                available_units.remove(min_idx)  \n      \n    # Ensure turned-off units have zero output  \n    for i in range(n):  \n        if u[i] == 0:  \n            p[i] = 0.0  \n              \n    return np.array([u, p])  ",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "refined_rolling_uc_heuristic",
          "algorithm": "**  \n1. Classify units as must-run (violate downtime/shutdown ramp), must-off (violate downtime), or flexible. Initialize commitment states accordingly.  \n2. Compute feasible output ranges considering ramp constraints for committed units.  \n3. Handle over-generation: Turn off highest-cost flexible units if total minimum output exceeds load, ensuring sufficient capacity remains.  \n4. Handle under-commitment: Turn on flexible units by cheapest average cost (including startup) until total maximum output covers load.  \n5. Perform economic dispatch:  \n   - Set outputs to minimum feasible levels  \n   - Distribute remaining load by increasing outputs of units with lowest incremental cost, respecting ramp constraints.  \n6. Return commitment states and power outputs.  \n\n**",
          "code": "import numpy as np\n\ndef refined_rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    states = np.zeros(n_units, dtype=int)\n    outputs = np.zeros(n_units)\n    flexible_indices = []\n    \n    # Step 1: Classify units and initialize states\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                states[i] = 1  # Must-run\n            else:\n                flexible_indices.append(i)\n                states[i] = 1  # Initially keep online\n        else:  # Unit was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                states[i] = 0  # Must-off\n            else:\n                flexible_indices.append(i)\n                states[i] = 0  # Initially keep offline\n    \n    # Helper function to calculate min/max output for unit i\n    def get_output_limits(i):\n        unit = units_info[i]\n        if states[i] == 0:\n            return 0, 0\n        if unit['u_i_0'] == 0:  # Starting now\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Was online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return min_out, max_out\n    \n    # Step 2: Compute total feasible range\n    min_outputs, max_outputs = [], []\n    for i in range(n_units):\n        min_out, max_out = get_output_limits(i)\n        min_outputs.append(min_out)\n        max_outputs.append(max_out)\n    total_min = sum(min_outputs)\n    total_max = sum(max_outputs)\n    \n    # Step 3: Handle over-generation\n    if total_min > current_load:\n        # Find flexible online units with highest cost at min output\n        online_flex = [i for i in flexible_indices if states[i] == 1]\n        cost_at_min = [\n            unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i]**2 \n            for i, unit in zip(online_flex, [units_info[i] for i in online_flex])\n        ]\n        sorted_by_cost = sorted(zip(online_flex, cost_at_min), key=lambda x: x[1], reverse=True)\n        \n        # Turn off expensive units until feasible\n        for idx, _ in sorted_by_cost:\n            if total_min <= current_load and total_max >= current_load:\n                break\n            # Check if turning off this unit maintains feasibility\n            new_min = total_min - min_outputs[idx]\n            new_max = total_max - max_outputs[idx]\n            if new_max >= current_load:\n                states[idx] = 0\n                min_outputs[idx] = max_outputs[idx] = 0\n                total_min, total_max = new_min, new_max\n                flexible_indices.remove(idx)\n    \n    # Step 4: Handle under-commitment\n    if total_max < current_load:\n        # Find flexible offline units with cheapest average cost at min output\n        offline_flex = [i for i in flexible_indices if states[i] == 0]\n        avg_cost = [\n            (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n            for unit in [units_info[i] for i in offline_flex]\n        ]\n        sorted_by_avg_cost = sorted(zip(offline_flex, avg_cost), key=lambda x: x[1])\n        \n        # Turn on cheapest units until feasible\n        for idx, _ in sorted_by_avg_cost:\n            if total_max >= current_load:\n                break\n            states[idx] = 1\n            min_out, max_out = get_output_limits(idx)\n            min_outputs[idx] = min_out\n            max_outputs[idx] = max_out\n            total_min += min_out\n            total_max += max_out\n    \n    # Step 5: Economic dispatch\n    # Initialize outputs at minimum levels\n    for i in range(n_units):\n        outputs[i] = min_outputs[i] if states[i] == 1 else 0\n    remaining = current_load - total_min\n    \n    # Distribute remaining load by increasing cheapest units\n    while remaining > 0:\n        available = []\n        for i in range(n_units):\n            if states[i] == 1 and outputs[i] < max_outputs[i]:\n                marginal_cost = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                headroom = max_outputs[i] - outputs[i]\n                available.append((i, marginal_cost, headroom))\n        \n        if not available:\n            break\n        \n        # Find unit with smallest marginal cost\n        idx = min(available, key=lambda x: x[1])[0]\n        max_increase = max_outputs[idx] - outputs[idx]\n        allocation = min(remaining, max_increase)\n        outputs[idx] += allocation\n        remaining -= allocation\n    \n    return np.vstack((states, outputs))",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     }
]