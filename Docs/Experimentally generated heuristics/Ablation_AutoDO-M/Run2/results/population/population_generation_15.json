[
     {
          "name": "enhanced_rolling_commitment_hybrid",
          "algorithm": "1. Identify must-run units (currently online violating min-up time or exceeding shutdown ramp) and must-off units (currently offline violating min-down time). 2. Compute feasible output ranges for each unit based on commitment status, ramp limits, and startup/shutdown constraints. 3. Calculate amortized cost per MW at minimum output for flexible units, including startup costs for offline units. 4. Initialize commitment set with must-run units and add flexible units in ascending amortized cost order until capacity meets forecasted load. 5. Decommit flexible units in descending cost order while maintaining feasibility (total min \u2264 load \u2264 total max). 6. Dispatch load by: (a) Setting committed units to min output if total min \u2265 load (b) Setting to max output if total max \u2264 load (c) Performing incremental cost dispatch with ramp constraints for residual load otherwise.  \n\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_hybrid(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run_indices = []\n    must_off_indices = []\n    flexible_indices = []\n    min_outputs = {}\n    max_outputs = {}\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                flexible_indices.append(i)\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n                min_outputs[i] = 0\n                max_outputs[i] = 0\n            else:\n                flexible_indices.append(i)\n                min_outputs[i] = unit['p_min_i']\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    flexible_avgs = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * (min_outputs[i] ** 2) + unit['s_i']\n        else:\n            total_cost = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * (min_outputs[i] ** 2)\n        if min_outputs[i] > 0:\n            avg_cost = total_cost / min_outputs[i]\n        else:\n            avg_cost = 1e12\n        flexible_avgs.append((avg_cost, i, min_outputs[i], max_outputs[i]))\n    \n    flexible_avgs_sorted = sorted(flexible_avgs, key=lambda x: x[0])\n    committed_set = set(must_run_indices)\n    total_min = sum(min_outputs[i] for i in must_run_indices)\n    total_max = sum(max_outputs[i] for i in must_run_indices)\n    added_flexible = []\n    \n    for item in flexible_avgs_sorted:\n        if total_max < current_load:\n            _, i, min_i, max_i = item\n            committed_set.add(i)\n            added_flexible.append(item)\n            total_min += min_i\n            total_max += max_i\n            if total_max >= current_load:\n                break\n        else:\n            break\n    \n    added_flexible_sorted_desc = sorted(added_flexible, key=lambda x: x[0], reverse=True)\n    for item in added_flexible_sorted_desc:\n        avg_cost, i, min_i, max_i = item\n        new_total_min = total_min - min_i\n        new_total_max = total_max - max_i\n        if new_total_min <= current_load and new_total_max >= current_load:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    current_outputs = {}\n    for i in committed_set:\n        current_outputs[i] = min_outputs[i]\n    \n    if abs(total_min - current_load) < 1e-6:\n        pass\n    elif abs(total_max - current_load) < 1e-6:\n        for i in committed_set:\n            current_outputs[i] = max_outputs[i]\n    else:\n        residual = current_load - total_min\n        heap = []\n        for i in committed_set:\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            inc_cost = b + 2 * c * current_outputs[i]\n            heapq.heappush(heap, (inc_cost, i, current_outputs[i], max_outputs[i]))\n        \n        while residual > 1e-6 and heap:\n            inc_cost, i, cur_p, max_p = heapq.heappop(heap)\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            available = max_p - cur_p\n            if available > 0:\n                delta = min(available, residual)\n                new_p = cur_p + delta\n                residual -= delta\n                current_outputs[i] = new_p\n                if new_p < max_p:\n                    new_inc_cost = b + 2 * c * new_p\n                    heapq.heappush(heap, (new_inc_cost, i, new_p, max_p))\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in committed_set:\n            schedules[0, i] = 1\n            schedules[1, i] = current_outputs[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0061982268,
          "gap_price_rate": 0.0081920316,
          "fitness": 0.0071951292
     },
     {
          "name": "enhanced_rolling_commitment_hybrid_v2",
          "algorithm": "1. Identify must-run units (online violating min-up time or exceeding shutdown ramp) and must-off units (offline violating min-down time or startup limit violations). \n2. Compute feasible output ranges for each unit considering ramp constraints and physical limits.\n3. Calculate amortized cost per MW for flexible units, spreading startup costs over min-up time for offline units.\n4. Build initial commitment: must-run units + flexible units in ascending amortized cost order until total max output meets current load.\n5. Decommit expensive flexible units in descending cost order while maintaining feasibility (total min \u2264 load \u2264 total max).\n6. Dispatch: Set all committed units to min outputs. Distribute residual load in ascending order of incremental costs at min-output while respecting unit limits.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_hybrid_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    min_out = np.zeros(n_units)\n    max_out = np.zeros(n_units)\n    \n    # Precompute constraints and classify units\n    for i, unit in enumerate(units_info):\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        u0, t0, p0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        pmin, pmax = unit['p_min_i'], unit['p_max_i']\n        pup, pdown = unit['p_up_i'], unit['p_down_i']\n        pstart = unit['p_start_i']\n        min_up, min_down = unit['t_on_min_i'], unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        # Must-run: online and violating min-up or shutdown ramp\n        if u0 == 1:\n            if t0 < min_up or p0 > pshut:\n                must_run.append(i)\n                min_out[i] = max(pmin, p0 - pdown)\n                max_out[i] = min(pmax, p0 + pup)\n            else:\n                flexible.append(i)\n                min_out[i] = max(pmin, p0 - pdown)\n                max_out[i] = min(pmax, p0 + pup)\n        # Must-off: offline with min-down violation or invalid startup range\n        else:\n            if abs(t0) < min_down or pstart < pmin:\n                must_off.append(i)\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                flexible.append(i)\n                min_out[i] = pmin\n                max_out[i] = min(pmax, pstart)\n    \n    # Initialize committed units and totals\n    committed = set(must_run)\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    # Calculate amortized costs for flexible units\n    amortized_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        pmin = unit['p_min_i']\n        cost_per_mw = (unit['a_i'] + unit['b_i'] * pmin + unit['c_i'] * pmin**2) / pmin\n        if units_info[i]['u_i_0'] == 0:  # Include startup amortization\n            cost_per_mw += unit['s_i'] / (pmin * unit['t_on_min_i'])\n        amortized_costs.append((i, cost_per_mw))\n    \n    # Add flexible units in cost order\n    amortized_costs.sort(key=lambda x: x[1])\n    for i, _ in amortized_costs:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n    \n    # Remove expensive units while feasible\n    flexible_committed = [i for i in committed if i not in must_run]\n    flexible_committed_sorted = sorted(\n        [(i, amortized_costs[j][1]) for j, (i, _) in enumerate(amortized_costs) if i in flexible_committed],\n        key=lambda x: x[1], reverse=True\n    )\n    for i, _ in flexible_committed_sorted:\n        temp_min = total_min - min_out[i]\n        temp_max = total_max - max_out[i]\n        if temp_min <= current_load <= temp_max and temp_max >= current_load:\n            committed.remove(i)\n            total_min, total_max = temp_min, temp_max\n    \n    # Dispatch load to committed units\n    residual = current_load\n    for i in committed:\n        p[i] = min_out[i]\n        residual -= min_out[i]\n    \n    if residual > 0:\n        # Calculate incremental costs at min output\n        inc_costs = []\n        for i in committed:\n            pmin = units_info[i]['p_min_i']\n            inc_cost = 2 * units_info[i]['c_i'] * pmin + units_info[i]['b_i']\n            capacity = max_out[i] - p[i]\n            inc_costs.append((i, inc_cost, capacity))\n        \n        inc_costs.sort(key=lambda x: x[1])\n        for i, _, cap in inc_costs:\n            allocation = min(residual, cap)\n            p[i] += allocation\n            residual -= allocation\n            if residual <= 1e-6:\n                break\n    \n    # Set commitment states\n    for i in committed:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0053484711,
          "gap_price_rate": 0.0091124781,
          "fitness": 0.0072304746
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify must-run units (currently online that violate minimum up-time or exceed shutdown ramp limit) and must-off units (currently offline that violate minimum down-time).\n2. Compute feasible output ranges for all units based on commitment status and physical constraints (ramp rates, startup/shutdown limits).\n3. Calculate cost per MW at minimum output for all flexible units (non must-run/must-off), including amortized startup cost for offline units.\n4. Build commitment set by:\n   - Starting with must-run units\n   - Adding flexible units in ascending cost/MW order until total maximum capacity meets load\n5. Decommit expensive flexible units while maintaining feasibility (total min \u2264 load \u2264 total max)\n6. Dispatch load by:\n   - Setting all committed units to minimum output if total minimum \u2265 load\n   - Setting to maximum output if total maximum \u2264 load\n   - Performing incremental cost-based economic dispatch for residual load otherwise\n7. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    unit_list = [unit.copy() for unit in units_info]\n    \n    # Initialize unit tracking\n    for i, unit in enumerate(unit_list):\n        unit['must_run'] = False\n        unit['must_off'] = False\n        unit['committed'] = False\n        unit['min_feas'] = 0.0\n        unit['max_feas'] = 0.0\n        unit['cost_per_MW'] = float('inf')\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in unit_list:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run units\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                unit['must_run'] = True\n                unit['min_feas'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                unit['max_feas'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        # Must-off units\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                unit['must_off'] = True\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Compute cost/MW for flexible units\n    for unit in flexible:\n        u_i0 = unit['u_i_0']\n        \n        # Previously online units\n        if u_i0 == 1:\n            unit['min_feas'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feas'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * unit['min_feas'] + unit['c_i'] * unit['min_feas'] ** 2\n            if unit['min_feas'] > 0:\n                unit['cost_per_MW'] = cost / unit['min_feas']\n        \n        # Offline units that can be started\n        else:\n            unit['min_feas'] = unit['p_min_i']\n            unit['max_feas'] = min(unit['p_max_i'], unit['p_start_i'])\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['min_feas'] + unit['c_i'] * unit['min_feas'] ** 2\n            if unit['min_feas'] > 0:\n                unit['cost_per_MW'] = cost / unit['min_feas']\n    \n    # Build initial commitment set\n    committed = must_run.copy()\n    total_min = sum(unit['min_feas'] for unit in must_run)\n    total_max = sum(unit['max_feas'] for unit in must_run)\n    flexible.sort(key=lambda x: x['cost_per_MW'])\n    \n    # Add flexible units until load can be met\n    for unit in flexible:\n        if total_max < current_load:\n            committed.append(unit)\n            total_min += unit['min_feas']\n            total_max += unit['max_feas']\n    \n    # Decommit expensive units while maintaining feasibility\n    flexible_committed = [u for u in committed if u in flexible]\n    flexible_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    \n    removed = True\n    while removed and flexible_committed:\n        removed = False\n        for i, unit in enumerate(flexible_committed):\n            new_min = total_min - unit['min_feas']\n            new_max = total_max - unit['max_feas']\n            if new_max >= current_load and new_min <= current_load:\n                total_min = new_min\n                total_max = new_max\n                committed.remove(unit)\n                flexible_committed.pop(i)\n                removed = True\n                break\n    \n    # Set commitment status\n    for unit in committed:\n        unit['committed'] = True\n    \n    # Dispatch load to committed units\n    if total_min >= current_load:\n        for unit in committed:\n            unit['p_i'] = unit['min_feas']\n    elif total_max <= current_load:\n        for unit in committed:\n            unit['p_i'] = unit['max_feas']\n    else:\n        # Allocate minimum power\n        for unit in committed:\n            unit['p_i'] = unit['min_feas']\n        residual = current_load - total_min\n        \n        # Allocate residual load by incremental cost\n        committed.sort(key=lambda x: 2*x['c_i']*x['min_feas'] + x['b_i'])\n        for unit in committed:\n            alloc = min(residual, unit['max_feas'] - unit['p_i'])\n            unit['p_i'] += alloc\n            residual -= alloc\n            if residual <= 0:\n                break\n    \n    # Generate output\n    for i, unit in enumerate(unit_list):\n        schedules[0, i] = 1 if unit['committed'] else 0\n        schedules[1, i] = unit['p_i']\n            \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.005982537,
          "gap_price_rate": 0.0086275961,
          "fitness": 0.0073050665
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Identify must-run units (currently online and violating min-up time or shutdown ramp limits) and must-off units (currently offline and violating min-down time).  \n2. For each flexible unit, compute feasible output range considering ramp rates and startup/shutdown constraints.  \n3. Calculate two-period amortized cost per MW for flexible units, incorporating startup costs and projected next-period minimum operation.  \n4. Build initial commitment set by combining must-run units with flexible units sorted by ascending amortized cost until total capacity meets current load.  \n5. Decommit expensive flexible units in descending amortized cost order while maintaining feasibility (total min output \u2264 current load \u2264 total max output).  \n6. Dispatch load: set committed units to minimum outputs if feasible, maximum outputs if necessary, otherwise perform incremental cost dispatch for residual load.  \n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    next_forecast = load[1]  # Not directly used but available\n    \n    n_units = len(units_info)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    p_min_curr = np.zeros(n_units)\n    p_max_curr = np.zeros(n_units)\n    amortized_costs = np.zeros(n_units)\n    \n    # Identify must-run/must-off and compute current feasible ranges\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_run[i] = True\n            p_min_curr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_curr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off[i] = True\n            p_min_curr[i] = 0\n            p_max_curr[i] = 0\n            \n    # Compute amortized costs for flexible units\n    for i, unit in enumerate(units_info):\n        if must_run[i] or must_off[i]:\n            continue\n            \n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        s_i = unit['s_i']\n        u_i0 = unit['u_i_0']\n        \n        # Currently online (stay)\n        if u_i0 == 1:\n            p_min_curr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_curr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_curr = a_i + b_i * p_min_curr[i] + c_i * p_min_curr[i]**2\n            cost_next = a_i + b_i * unit['p_min_i'] + c_i * unit['p_min_i']**2\n            total_output = p_min_curr[i] + unit['p_min_i']\n            amortized_costs[i] = (cost_curr + cost_next) / total_output\n        \n        # Currently offline (start)\n        else:\n            p_min_curr[i] = unit['p_min_i']\n            p_max_curr[i] = min(unit['p_max_i'], unit['p_start_i'])\n            cost_curr = a_i + b_i * p_min_curr[i] + c_i * p_min_curr[i]**2\n            cost_next = a_i + b_i * unit['p_min_i'] + c_i * unit['p_min_i']**2\n            total_output = p_min_curr[i] + unit['p_min_i']\n            amortized_costs[i] = (s_i + cost_curr + cost_next) / total_output\n    \n    # Initial commitment: must-run units\n    committed = np.where(must_run)[0].tolist()\n    flex_indices = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    \n    # Add flexible units by ascending amortized cost\n    sorted_flex = sorted(flex_indices, key=lambda i: amortized_costs[i])\n    for i in sorted_flex:\n        committed.append(i)\n        total_max = sum(p_max_curr[j] for j in committed)\n        if total_max >= current_load:\n            break\n    \n    # Decommit expensive units while feasible\n    flex_in_commit = [i for i in committed if not must_run[i]]\n    sorted_decommit = sorted(flex_in_commit, key=lambda i: amortized_costs[i], reverse=True)\n    \n    for i in sorted_decommit:\n        temp_commit = [j for j in committed if j != i]\n        total_min = sum(p_min_curr[j] for j in temp_commit)\n        total_max = sum(p_max_curr[j] for j in temp_commit)\n        if total_min <= current_load <= total_max:\n            committed = temp_commit\n    \n    # Dispatch load\n    p_alloc = np.zeros(n_units)\n    total_min = sum(p_min_curr[j] for j in committed)\n    total_max = sum(p_max_curr[j] for j in committed)\n    \n    if current_load <= total_min:\n        for i in committed:\n            p_alloc[i] = p_min_curr[i]\n    elif current_load >= total_max:\n        for i in committed:\n            p_alloc[i] = p_max_curr[i]\n    else:\n        # Set all to minimum\n        for i in committed:\n            p_alloc[i] = p_min_curr[i]\n        \n        # Allocate residual\n        residual = current_load - total_min\n        units_to_dispatch = []\n        for i in committed:\n            room = p_max_curr[i] - p_min_curr[i]\n            if room > 1e-6:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min_curr[i]\n                units_to_dispatch.append((i, inc_cost, room))\n        \n        units_to_dispatch.sort(key=lambda x: x[1])\n        for i, inc_cost, room in units_to_dispatch:\n            if residual <= 0:\n                break\n            alloc = min(room, residual)\n            p_alloc[i] += alloc\n            residual -= alloc\n    \n    # Prepare output\n    u_out = np.zeros(n_units)\n    for i in committed:\n        u_out[i] = 1\n    \n    return np.vstack((u_out, p_alloc))",
          "from": "mutation",
          "gap_power_rate": 0.0060153633,
          "gap_price_rate": 0.0089728481,
          "fitness": 0.0074941057
     },
     {
          "name": "enhanced_rolling_commitment_v2",
          "algorithm": "1. Identify must-run units (online violating min-up or shutdown ramp) and must-off units (offline violating min-down). 2. Compute feasible outputs for each unit based on ramp rates and startup/shutdown constraints. 3. Calculate amortized startup cost per MW for flexible units. 4. Build initial commitment set: must-run units + flexible units sorted by min-output incremental cost (with amortized startup) until capacity covers load. 5. Decommit expensive flexible units in descending cost order while maintaining load coverage feasibility. 6. Dispatch load: minimum outputs if feasible; maximum outputs if necessary; otherwise incremental cost dispatch respecting unit limits.\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed = [False] * n_units\n    min_on = [0.0] * n_units\n    max_on = [0.0] * n_units\n    cost_per_mw = [0.0] * n_units\n    must_run = []\n    must_off = []\n    flexible = []\n\n    # Precompute must-run/must-off and feasible output ranges\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Currently online\n            min_on[i] = max(p_min, p_i0 - p_down)\n            max_on[i] = min(p_max, p_i0 + p_up)\n            if t_i0 < min_up or p_i0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Currently offline\n            min_on[i] = p_min\n            max_on[i] = min(p_max, p_start)\n            if abs(t_i0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n    # Build initial commitment set\n    committed_set = set(must_run)\n    total_min = sum(min_on[i] for i in committed_set)\n    total_max = sum(max_on[i] for i in committed_set)\n    \n    # Calculate cost/MW for flexible units\n    flex_candidates = []\n    for i in flexible:\n        unit = units_info[i]\n        a, b, c, s = unit['a_i'], unit['b_i'], unit['c_i'], unit['s_i']\n        base_cost = a + b * min_on[i] + c * min_on[i]**2\n        \n        if not unit['u_i_0']:  # Currently offline\n            amortized_startup = s / unit['t_on_min_i']\n            total_cost = base_cost + amortized_startup\n        else:\n            total_cost = base_cost\n            \n        cost_per_mw[i] = total_cost / min_on[i]\n        flex_candidates.append((cost_per_mw[i], i, min_on[i], max_on[i]))\n    \n    # Add flexible units by ascending cost/MW\n    flex_candidates.sort(key=lambda x: x[0])\n    added_flex = []\n    for cpmw, i, min_i, max_i in flex_candidates:\n        if total_max >= current_load:\n            break\n        committed_set.add(i)\n        added_flex.append(i)\n        total_min += min_i\n        total_max += max_i\n    \n    # Decommit expensive flexible units\n    decommit_candidates = sorted(\n        [(cost_per_mw[i], i, min_on[i], max_on[i]) for i in added_flex],\n        key=lambda x: x[0], reverse=True\n    )\n    decommitted = set()\n    temp_min, temp_max = total_min, total_max\n    for cpmw, i, min_i, max_i in decommit_candidates:\n        if temp_min - min_i <= current_load <= temp_max - max_i:\n            decommitted.add(i)\n            temp_min -= min_i\n            temp_max -= max_i\n    committed_set -= decommitted\n    total_min, total_max = temp_min, temp_max\n    \n    # Initialize outputs\n    outputs = [0.0] * n_units\n    states = [0] * n_units\n    \n    # Dispatch load to committed units\n    for i in committed_set:\n        states[i] = 1\n        outputs[i] = min_on[i]\n    \n    # Case 1: Minimum generation satisfies load\n    if total_min >= current_load:\n        for i in committed_set:\n            outputs[i] = min_on[i]\n    \n    # Case 2: Maximum generation needed\n    elif total_max <= current_load:\n        for i in committed_set:\n            outputs[i] = max_on[i]\n    \n    # Case 3: Economic dispatch needed\n    else:\n        residual = current_load - total_min\n        heap = []\n        for i in committed_set:\n            unit = units_info[i]\n            current_out = outputs[i]\n            inc_cost = 2 * unit['c_i'] * current_out + unit['b_i']\n            heapq.heappush(heap, (inc_cost, i, current_out, max_on[i]))\n        \n        while residual > 0 and heap:\n            inc_cost, i, current, max_i = heapq.heappop(heap)\n            unit = units_info[i]\n            alloc = min(residual, max_i - current)\n            new_out = current + alloc\n            residual -= alloc\n            outputs[i] = new_out\n            \n            if new_out < max_i:\n                new_inc = 2 * unit['c_i'] * new_out + unit['b_i']\n                heapq.heappush(heap, (new_inc, i, new_out, max_i))\n    \n    # Set uncommitted units\n    for i in must_off:\n        states[i] = 0\n        outputs[i] = 0.0\n    for i in set(range(n_units)) - committed_set - set(must_off):\n        states[i] = 0\n        outputs[i] = 0.0\n    \n    return np.array([states, outputs])",
          "from": "mutation",
          "gap_power_rate": 0.0060153633,
          "gap_price_rate": 0.0095387414,
          "fitness": 0.0077770523
     },
     {
          "name": "rolling_commitment_v1",
          "algorithm": "**  \n1. Identify must-run units if currently online but violating minimum up-time or previous output exceeds shutdown ramp limit.  \n2. Identify must-off units if currently offline but violating minimum down-time.  \n3. For must-run units, compute feasible min/max outputs considering ramp and startup constraints.  \n4. For remaining units, calculate cost/MW at minimum output (including startup cost for offline units) and sort ascending.  \n5. Add flexible units to commitment until total max feasible capacity meets load, updating cumulative min/max outputs.  \n6. If cumulative min output exceeds load, set all committed units to min output.  \n7. If cumulative max output is below load, set all committed units to max output.  \n8. Otherwise, perform economic dispatch:  \n   - Initialize each unit at min output  \n   - Allocate remaining load ascending by incremental cost at min output  \n   - Respect individual unit's max output and ramp constraints  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize vectors\n    min_on = np.zeros(n_units)\n    max_on = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    \n    # Step 1-3: Determine must-run/must-off and compute feasible ranges\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            min_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off.append(i)\n            min_on[i] = unit['p_min_i']\n            max_on[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize capacity\n    total_min = sum(min_on[i] for i in must_run)\n    total_max = sum(max_on[i] for i in must_run)\n    candidate_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    candidate_costs = []\n    \n    # Step 4: Calculate cost/MW for candidate units\n    for i in candidate_units:\n        unit = units_info[i]\n        min_p = min_on[i]\n        if unit['u_i_0'] == 1:  # Currently online\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        else:  # Currently offline (add startup cost)\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2 + unit['s_i']\n        candidate_costs.append((i, cost / min_p))\n    \n    # Sort candidates by cost/MW\n    candidate_costs.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    \n    # Step 5: Commit flexible units\n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        total_min += min_on[i]\n        total_max += max_on[i]\n        committed.append(i)\n    \n    # Step 6-8: Dispatch generation\n    u_vec = [0] * n_units\n    p_vec = [0] * n_units\n    \n    if total_min > current_load:  # Over-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n    elif total_max < current_load:  # Under-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = max_on[i]\n    else:  # Economic dispatch\n        # Initialize at min output\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n        deficit = current_load - total_min\n        \n        # Sort by incremental cost at min output\n        units_to_dispatch = []\n        for i in committed:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_on[i] + unit['b_i']\n            headroom = max_on[i] - min_on[i]\n            units_to_dispatch.append((inc_cost, i, headroom))\n        units_to_dispatch.sort(key=lambda x: x[0])\n        \n        # Allocate deficit\n        for inc_cost, i, headroom in units_to_dispatch:\n            if deficit <= 0:\n                break\n            allocate = min(headroom, deficit)\n            p_vec[i] += allocate\n            deficit -= allocate\n    \n    return np.array([u_vec, p_vec])",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "enhanced_amortized_commitment",
          "algorithm": null,
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_amortized_commitment(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    current_load = load[0]\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['feasible_min'] = min_output\n        unit['feasible_max'] = max_output\n    \n    for unit in flexible:\n        if unit['u_i_0'] == 1:\n            min_online = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_online = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_online = unit['p_min_i']\n            max_online = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        unit['feasible_min_online'] = min_online\n        unit['feasible_max_online'] = max_online\n    \n    for unit in must_off:\n        unit['feasible_min'] = 0\n        unit['feasible_max'] = 0\n    \n    for unit in flexible:\n        if unit['u_i_0'] == 1:\n            min_out = unit['feasible_min_online']\n            cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            cost_per_MW = cost / min_out\n        else:\n            min_out = unit['feasible_min_online']\n            T = unit['t_on_min_i']\n            cost_per_period = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            total_cost = unit['s_i'] + T * cost_per_period\n            total_MW = T * min_out\n            cost_per_MW = total_cost / total_MW\n        unit['cost_per_MW'] = cost_per_MW\n    \n    committed_set = list(must_run)\n    total_min = sum(unit['feasible_min'] for unit in must_run)\n    total_max = sum(unit['feasible_max'] for unit in must_run)\n    \n    flexible_sorted = sorted(flexible, key=lambda x: x['cost_per_MW'])\n    for unit in flexible_sorted:\n        if total_max >= current_load:\n            break\n        committed_set.append(unit)\n        total_min += unit['feasible_min_online']\n        total_max += unit['feasible_max_online']\n    \n    flexible_committed = [unit for unit in committed_set if unit in flexible]\n    flexible_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    removal_done = True\n    while removal_done and total_min > current_load:\n        removal_done = False\n        for i in range(len(flexible_committed)):\n            unit = flexible_committed[i]\n            new_min = total_min - unit['feasible_min_online']\n            new_max = total_max - unit['feasible_max_online']\n            if new_min <= current_load and new_max >= current_load:\n                total_min = new_min\n                total_max = new_max\n                committed_set.remove(unit)\n                flexible_committed.pop(i)\n                removal_done = True\n                break\n    \n    for unit in units:\n        if unit in committed_set:\n            unit['u_i'] = 1\n            if unit in must_run:\n                unit['p_i'] = unit['feasible_min']\n            else:\n                unit['p_i'] = unit['feasible_min_online']\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    residual = current_load - total_min\n    if residual > 0:\n        heap = []\n        for unit in committed_set:\n            if unit in must_run:\n                current_p = unit['feasible_min']\n                max_p = unit['feasible_max']\n            else:\n                current_p = unit['feasible_min_online']\n                max_p = unit['feasible_max_online']\n            ic = 2 * unit['c_i'] * current_p + unit['b_i']\n            heapq.heappush(heap, (ic, id(unit), unit, current_p, max_p))\n        \n        while residual > 0 and heap:\n            ic, _, unit, cur_p, max_p = heapq.heappop(heap)\n            available = max_p - cur_p\n            if available > 0:\n                add = min(residual, available)\n                unit['p_i'] += add\n                residual -= add\n                new_p = cur_p + add\n                if new_p < max_p and residual > 0:\n                    new_ic = 2 * unit['c_i'] * new_p + unit['b_i']\n                    heapq.heappush(heap, (new_ic, id(unit), unit, new_p, max_p))\n    \n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0061537333,
          "gap_price_rate": 0.0104739945,
          "fitness": 0.0083138639
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Identify must-run units (online violating min-up time or shutdown ramp limits) and must-off units (offline violating min-down time).\n2. Compute feasible output ranges for all units based on current status and constraints:\n   - For must-run/online units: min = max(p_min, p_0 - p_down), max = min(p_max, p_0 + p_up)\n   - For offline flexible units: min = p_min, max = min(p_max, p_start)\n   - Must-off units: min = max = 0\n3. Calculate cost per MW for flexible units:\n   - If offline: Amortize startup cost over two periods: cost_per_MW = (b_i + 2*c_i*min_i) + s_i/(min_i*2)\n   - If online: cost_per_MW = b_i + 2*c_i*min_i\n4. Build initial commitment:\n   - Start with must-run units\n   - Add flexible units sorted by ascending cost_per_MW until total max output >= current load\n5. Decommit expensive units:\n   - Sort flexible committed units by descending cost_per_MW\n   - Decommit if feasible: total_min and total_max still satisfy load after removal\n6. Dispatch load among committed units:\n   - If total_min >= load: allocate min outputs\n   - Else if total_max <= load: allocate max outputs\n   - Else perform economic dispatch via bisection method\n     - Set lambda bounds based on min/max incremental costs\n     - Iteratively adjust lambda until power matches load\n     - Allocate power: P_i = min(max_i, max(min_i, (lambda - b_i)/(2*c_i)))\n7. Set uncommitted units to 0 output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if i in must_off:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n        else:\n            if unit['u_i_0'] == 1:\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_outputs[i] = unit['p_min_i']\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    cost_per_MW = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if i in must_run or i in must_off:\n            continue\n        min_out = min_outputs[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        base_cost = b + 2 * c * min_out\n        if unit['u_i_0'] == 0:\n            base_cost += unit['s_i'] / (min_out * 2) if min_out > 0 else 0\n        cost_per_MW[i] = base_cost\n    \n    committed = set(must_run)\n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n    flexible_units = [i for i in range(n_units) \n                      if i not in must_run and i not in must_off]\n    sorted_flex = sorted(flexible_units, key=lambda i: cost_per_MW[i])\n    \n    for i in sorted_flex:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    flexible_committed = sorted([i for i in committed if i in flexible_units], \n                                key=lambda i: cost_per_MW[i], reverse=True)\n    for i in flexible_committed:\n        new_min = total_min - min_outputs[i]\n        new_max = total_max - max_outputs[i]\n        if new_min <= current_load <= new_max:\n            committed.discard(i)\n            total_min = new_min\n            total_max = new_max\n    \n    p_output = np.zeros(n_units)\n    if current_load <= total_min:\n        for i in committed:\n            p_output[i] = min_outputs[i]\n    elif current_load >= total_max:\n        for i in committed:\n            p_output[i] = max_outputs[i]\n    else:\n        low_bound = float('inf')\n        high_bound = 0\n        for i in committed:\n            c_i = units_info[i]['c_i']\n            b_i = units_info[i]['b_i']\n            min_i = min_outputs[i]\n            max_i = max_outputs[i]\n            if c_i > 0:\n                low_bound = min(low_bound, b_i + 2*c_i*min_i)\n                high_bound = max(high_bound, b_i + 2*c_i*max_i)\n            else:\n                inc_cost = b_i\n                low_bound = min(low_bound, inc_cost)\n                high_bound = max(high_bound, inc_cost)\n        \n        lambda_ = (low_bound + high_bound) / 2\n        for _ in range(100):\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                c_i = unit['c_i']\n                b_i = unit['b_i']\n                min_i = min_outputs[i]\n                max_i = max_outputs[i]\n                if c_i > 0:\n                    p_val = (lambda_ - b_i) / (2 * c_i)\n                    p_val = max(min_i, min(max_i, p_val))\n                else:\n                    p_val = max_i if lambda_ > b_i else min_i\n                p_output[i] = p_val\n                total_power += p_val\n            \n            if abs(total_power - current_load) < 1e-5:\n                break\n            if total_power < current_load:\n                low_bound = lambda_\n            else:\n                high_bound = lambda_\n            lambda_ = (low_bound + high_bound) / 2\n    \n    u_output = np.zeros(n_units)\n    for i in committed:\n        u_output[i] = 1\n    \n    return np.array([u_output, p_output])",
          "from": "mutation",
          "gap_power_rate": 0.0051044042,
          "gap_price_rate": 0.01153609,
          "fitness": 0.0083202471
     }
]