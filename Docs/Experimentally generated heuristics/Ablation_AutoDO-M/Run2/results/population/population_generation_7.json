[
     {
          "name": "rolling_commitment_v1",
          "algorithm": "**  \n1. Identify must-run units if currently online but violating minimum up-time or previous output exceeds shutdown ramp limit.  \n2. Identify must-off units if currently offline but violating minimum down-time.  \n3. For must-run units, compute feasible min/max outputs considering ramp and startup constraints.  \n4. For remaining units, calculate cost/MW at minimum output (including startup cost for offline units) and sort ascending.  \n5. Add flexible units to commitment until total max feasible capacity meets load, updating cumulative min/max outputs.  \n6. If cumulative min output exceeds load, set all committed units to min output.  \n7. If cumulative max output is below load, set all committed units to max output.  \n8. Otherwise, perform economic dispatch:  \n   - Initialize each unit at min output  \n   - Allocate remaining load ascending by incremental cost at min output  \n   - Respect individual unit's max output and ramp constraints  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize vectors\n    min_on = np.zeros(n_units)\n    max_on = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    \n    # Step 1-3: Determine must-run/must-off and compute feasible ranges\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            min_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off.append(i)\n            min_on[i] = unit['p_min_i']\n            max_on[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize capacity\n    total_min = sum(min_on[i] for i in must_run)\n    total_max = sum(max_on[i] for i in must_run)\n    candidate_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    candidate_costs = []\n    \n    # Step 4: Calculate cost/MW for candidate units\n    for i in candidate_units:\n        unit = units_info[i]\n        min_p = min_on[i]\n        if unit['u_i_0'] == 1:  # Currently online\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        else:  # Currently offline (add startup cost)\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2 + unit['s_i']\n        candidate_costs.append((i, cost / min_p))\n    \n    # Sort candidates by cost/MW\n    candidate_costs.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    \n    # Step 5: Commit flexible units\n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        total_min += min_on[i]\n        total_max += max_on[i]\n        committed.append(i)\n    \n    # Step 6-8: Dispatch generation\n    u_vec = [0] * n_units\n    p_vec = [0] * n_units\n    \n    if total_min > current_load:  # Over-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n    elif total_max < current_load:  # Under-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = max_on[i]\n    else:  # Economic dispatch\n        # Initialize at min output\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n        deficit = current_load - total_min\n        \n        # Sort by incremental cost at min output\n        units_to_dispatch = []\n        for i in committed:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_on[i] + unit['b_i']\n            headroom = max_on[i] - min_on[i]\n            units_to_dispatch.append((inc_cost, i, headroom))\n        units_to_dispatch.sort(key=lambda x: x[0])\n        \n        # Allocate deficit\n        for inc_cost, i, headroom in units_to_dispatch:\n            if deficit <= 0:\n                break\n            allocate = min(headroom, deficit)\n            p_vec[i] += allocate\n            deficit -= allocate\n    \n    return np.array([u_vec, p_vec])",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify must-run units (online violating min-up/shutdown ramp) and must-off units (offline violating min-down)\n2. Compute feasible output ranges for committed units considering ramp and startup/shutdown constraints\n3. Calculate amortized startup cost per MW for flexible offline units\n4. Sort flexible units by min-output incremental cost (amortized startup for offline units)\n5. Commit sorted flexible units until total max output \u2265 load\n6. Decommit most expensive flexible units until min output \u2264 load while maintaining max output \u2265 load\n7. Dispatch load:\n   - If min output \u2265 load: set committed units to min outputs\n   - Else if max output \u2264 load: set committed units to max outputs\n   - Else: set min outputs then distribute residual load ascending by min-output incremental cost\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    min_output = [0] * n_units\n    max_output = [0] * n_units\n    \n    # Identify must-run and must-off units\n    for i, unit in enumerate(units_info):\n        # Must-run condition\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        \n        # Must-off condition\n        if unit['u_i_0'] == 0:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Compute feasible ranges and set outputs\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run and must-off units\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n        elif must_off[i]:\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            min_output[i] = unit['p_min_i']\n            if unit['u_i_0'] == 0:\n                max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Prepare flexible units\n    flexible_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            min_val = min_output[i]\n            # Calculate amortized startup cost\n            if unit['u_i_0'] == 0:\n                cost = (unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * min_val**2 +\n                        unit['s_i'] / unit['t_on_min_i'])\n            else:\n                cost = unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * min_val**2\n            flexible_units.append((cost / min_val, i, min_val, max_output[i]))\n    \n    # Sort flexible units by cost per MW\n    flexible_units.sort(key=lambda x: x[0])\n    \n    # Commit flexible units until capacity requirement met\n    comm_flex = []\n    for cost_per_mw, i, min_val, max_val in flexible_units:\n        if total_max < current_load:\n            u[i] = 1\n            total_min += min_val\n            total_max += max_val\n            comm_flex.append((cost_per_mw, i, min_val, max_val))\n    \n    # Decommit most expensive units if possible\n    comm_flex.sort(key=lambda x: x[0], reverse=True)\n    for cost_per_mw, i, min_val, max_val in comm_flex[:]:\n        if total_min - min_val > current_load and total_max - max_val >= current_load:\n            u[i] = 0\n            total_min -= min_val\n            total_max -= max_val\n            comm_flex.remove((cost_per_mw, i, min_val, max_val))\n    \n    # Handle dispatch cases\n    if total_min >= current_load:\n        # Min output case\n        for i, unit in enumerate(units_info):\n            if u[i] == 1:\n                p[i] = min_output[i]\n    elif total_max <= current_load:\n        # Max output case\n        for i, unit in enumerate(units_info):\n            if u[i] == 1:\n                p[i] = max_output[i]\n    else:\n        # Economic dispatch\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n        residual = current_load - total_min\n        \n        # Calculate incremental costs\n        inc_costs = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * min_output[i]\n                inc_costs.append((inc_cost, i))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        # Distribute residual load\n        for inc_cost, idx in inc_costs:\n            avail = max_output[idx] - min_output[idx]\n            if residual <= 0:\n                break\n            if avail > 0:\n                add = min(avail, residual)\n                p[idx] += add\n                residual -= add\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0062166873,
          "gap_price_rate": 0.0105974149,
          "fitness": 0.0084070511
     },
     {
          "name": "rolling_commitment_v3",
          "algorithm": "1. Identify must-run and must-off units:  \n   - Must-run: Online units (u_i_0=1) violating min up-time (t_i_0 < t_on_min_i) or previous output exceeds shutdown ramp limit (p_i_0 > p_shut_i)  \n   - Must-off: Offline units (u_i_0=0) violating min down-time (|t_i_0| < t_off_min_i)  \n2. Initialize flexible units to their previous state (u_i = u_i_0)  \n3. Compute ramp-constrained min/max outputs for each unit based on current commitment  \n4. Adjust commitment:  \n   a. If total min output > load: Turn off flexible online units with highest operating cost per MW  \n   b. If total max output < load: Turn on flexible offline units with lowest amortized startup cost per MW  \n5. For committed units:  \n   a. Set output to ramp-constrained min  \n   b. Distribute residual load using priority queue based on incremental cost, respecting ramp limits  \n6. Set uncommitted units to zero output  \n\n",
          "code": "import heapq\nimport numpy as np\n\ndef rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n\n        if u_i_0 == 1:\n            if (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i):\n                must_run[i] = True\n                u[i] = 1\n            else:\n                must_run[i] = False\n            must_off[i] = False\n        else:\n            must_run[i] = False\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n                u[i] = 0\n            else:\n                must_off[i] = False\n                u[i] = u_i_0\n\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n\n    def compute_min_max(i, u_i):\n        unit = units_info[i]\n        if u_i == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0.0\n            max_out[i] = 0.0\n\n    for i in range(n_units):\n        compute_min_max(i, u[i])\n\n    total_min = sum(min_out)\n    total_max = sum(max_out)\n\n    if total_min > current_load:\n        candidate_off = []\n        for i in range(n_units):\n            if not must_run[i] and not must_off[i] and u[i] == 1:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    if unit['p_i_0'] <= unit['p_down_i']:\n                        cost = (unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2) / min_out[i]\n                        candidate_off.append((cost, i))\n        candidate_off.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in candidate_off:\n            prev_min = min_out[i]\n            prev_max = max_out[i]\n            u[i] = 0\n            compute_min_max(i, 0)\n            total_min -= prev_min\n            total_max -= prev_max\n            if total_min <= current_load:\n                break\n\n    elif total_max < current_load:\n        candidate_on = []\n        for i in range(n_units):\n            if not must_run[i] and not must_off[i] and u[i] == 0:\n                unit = units_info[i]\n                min_new = unit['p_min_i']\n                if min_new <= 0: continue\n                startup = unit['s_i'] / unit['t_on_min_i'] if unit['t_on_min_i'] > 0 else 0\n                operating_cost = unit['a_i'] + unit['b_i'] * min_new + unit['c_i'] * min_new**2\n                total_cost = startup + operating_cost\n                cost_per_mw = total_cost / min_new\n                max_new = min(unit['p_max_i'], unit['p_start_i'])\n                candidate_on.append((cost_per_mw, i, min_new, max_new))\n        candidate_on.sort(key=lambda x: x[0])\n        for cost_per_mw, i, min_new, max_new in candidate_on:\n            u[i] = 1\n            compute_min_max(i, 1)\n            total_min += min_new\n            total_max += max_new\n            if total_max >= current_load:\n                break\n\n    for i in range(n_units):\n        compute_min_max(i, u[i])\n        if u[i] == 0:\n            p[i] = 0.0\n        else:\n            p[i] = min_out[i]\n\n    residual = current_load - sum(min_out)\n    if residual > 0:\n        heap = []\n        for i in range(n_units):\n            if u[i] == 1 and min_out[i] < max_out[i]:\n                inc_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                heapq.heappush(heap, (inc_cost, i, min_out[i], max_out[i]))\n\n        while residual > 0 and heap:\n            inc_cost, i, current, max_val = heapq.heappop(heap)\n            available = min(residual, max_val - current)\n            p[i] += available\n            residual -= available\n            current += available\n            if current < max_val:\n                new_inc_cost = 2 * units_info[i]['c_i'] * current + units_info[i]['b_i']\n                heapq.heappush(heap, (new_inc_cost, i, current, max_val))\n\n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00613007,
          "gap_price_rate": 0.0113271693,
          "fitness": 0.0087286197
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "refined_rolling_commitment_v1",
          "algorithm": "1. Identify must-run units: units online with insufficient min-up time or previous output exceeding shutdown ramp limit.\n2. Identify must-off units: units offline with insufficient min-down time.\n3. Initialize flexible units to their previous commitment state.\n4. Compute feasible min/max outputs considering ramp and startup constraints:\n   - For units staying online: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - For units starting: [p_min, min(p_max, startup_limit, ramp_up)]\n5. Adjust commitment:\n   a. Turn off expensive flexible online units if total min output > load, while ensuring total max \u2265 load.\n   b. Turn on amortized-cheapest flexible offline units if total max < load.\n   c. After adding units, decommit most expensive units (both existing and new) if total min > load.\n6. Set committed units to min output and allocate residual load:\n   a. Distribute using priority queue based on incremental cost (2c_i\u00b7p_i + b_i).\n   b. Respect individual unit max outputs and ramp constraints.\n7. Set uncommitted units to off with zero output.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef refined_rolling_commitment_v1(units_info, load):\n    load_current = load[0]  # current load to satisfy\n    \n    # Extract unit attributes\n    n = len(units_info)\n    a_i = np.array([u['a_i'] for u in units_info])\n    b_i = np.array([u['b_i'] for u in units_info])\n    c_i = np.array([u['c_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_min_i = np.array([u['p_min_i'] for u in units_info])\n    p_max_i = np.array([u['p_max_i'] for u in units_info])\n    p_down_i = np.array([u['p_down_i'] for u in units_info])\n    p_up_i = np.array([u['p_up_i'] for u in units_info])\n    p_start_i = np.array([u['p_start_i'] for u in units_info])\n    p_shut_i = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min_i = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min_i = np.array([u['t_off_min_i'] for u in units_info])\n    s_i = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize arrays\n    u_arr = np.zeros(n)  # commitment state\n    p_arr = np.zeros(n)  # output power\n    min_p_arr = np.zeros(n)  # feasible min output\n    max_p_arr = np.zeros(n)  # feasible max output\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(n):\n        if u_i_0[i] == 1:\n            if (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i]):\n                must_run.append(i)\n        else:\n            if -t_i_0[i] < t_off_min_i[i]:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    committed = []\n    flexible_online = []\n    flexible_offline = []\n    \n    for i in range(n):\n        if i in must_run:\n            u_arr[i] = 1\n            committed.append(i)\n        elif i in must_off:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = u_i_0[i]\n            if u_i_0[i] == 1:\n                flexible_online.append(i)\n                committed.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Compute feasible min/max outputs for committed units\n    total_min = 0.0\n    total_max = 0.0\n    for i in range(n):\n        if u_arr[i] == 1:\n            if u_i_0[i] == 1:\n                min_p_arr[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                max_p_arr[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n            else:\n                min_p_arr[i] = p_min_i[i]\n                max_p_arr[i] = min(p_max_i[i], p_start_i[i], p_up_i[i])\n            total_min += min_p_arr[i]\n            total_max += max_p_arr[i]\n    \n    # Decommit expensive online units if over-generation\n    candidates_off = flexible_online.copy()\n    candidates_off.sort(key=lambda i: (a_i[i] + b_i[i]*min_p_arr[i] + c_i[i]*(min_p_arr[i]**2)) / min_p_arr[i], reverse=True)\n    \n    new_committed = committed.copy()\n    new_min = total_min\n    new_max = total_max\n    \n    for i in candidates_off:\n        if i not in new_committed: \n            continue\n        new_min_candidate = new_min - min_p_arr[i]\n        new_max_candidate = new_max - max_p_arr[i]\n        if new_max_candidate >= load_current:\n            new_committed.remove(i)\n            new_min = new_min_candidate\n            new_max = new_max_candidate\n        if new_min <= load_current:\n            break\n    \n    committed = new_committed\n    total_min = new_min\n    total_max = new_max\n    \n    # Update arrays after decommitment\n    for i in flexible_online:\n        if i not in committed:\n            u_arr[i] = 0\n            min_p_arr[i] = 0\n            max_p_arr[i] = 0\n    \n    # Commit additional units if under-capacity\n    if total_max < load_current:\n        candidates_on = flexible_offline.copy()\n        candidates_on.sort(key=lambda i: (a_i[i] + b_i[i]*p_min_i[i] + c_i[i]*(p_min_i[i]**2) + (s_i[i]/t_on_min_i[i])) / p_min_i[i])\n        \n        for i in candidates_on:\n            if total_max >= load_current:\n                break\n            startup_min = p_min_i[i]\n            startup_max = min(p_max_i[i], p_start_i[i], p_up_i[i])\n            committed.append(i)\n            u_arr[i] = 1\n            min_p_arr[i] = startup_min\n            max_p_arr[i] = startup_max\n            total_min += startup_min\n            total_max += startup_max\n    \n    # Post-addition decommitment if over-generation\n    if total_min > load_current:\n        candidates_off2 = [i for i in committed if i not in must_run]\n        candidates_off2.sort(key=lambda i: (a_i[i] + b_i[i]*min_p_arr[i] + c_i[i]*(min_p_arr[i]**2) + (s_i[i] if u_i_0[i]==0 else 0)) / min_p_arr[i], reverse=True)\n        \n        new_committed = committed.copy()\n        new_min = total_min\n        new_max = total_max\n        \n        for i in candidates_off2:\n            if i not in new_committed: \n                continue\n            new_min_candidate = new_min - min_p_arr[i]\n            new_max_candidate = new_max - max_p_arr[i]\n            if new_max_candidate >= load_current:\n                new_committed.remove(i)\n                new_min = new_min_candidate\n                new_max = new_max_candidate\n            if new_min <= load_current:\n                break\n        \n        committed = new_committed\n    \n    # Final commit state update\n    for i in range(n):\n        u_arr[i] = 1 if i in committed else 0\n        min_p_arr[i] = min_p_arr[i] if i in committed else 0\n        max_p_arr[i] = max_p_arr[i] if i in committed else 0\n    \n    # Initial dispatch at min output\n    for i in committed:\n        p_arr[i] = min_p_arr[i]\n    \n    residual = load_current - np.sum(p_arr)\n    \n    # Economic dispatch with incremental costs\n    if residual > 0:\n        heap = []\n        for i in committed:\n            headroom = max_p_arr[i] - min_p_arr[i]\n            if headroom > 0:\n                inc_cost = 2 * c_i[i] * p_arr[i] + b_i[i]\n                heapq.heappush(heap, (inc_cost, i, p_arr[i], headroom))\n        \n        while residual > 0 and heap:\n            inc_cost, i, current_p, headroom = heapq.heappop(heap)\n            delta = min(residual, headroom)\n            p_arr[i] += delta\n            residual -= delta\n            headroom -= delta\n            \n            if headroom > 0:\n                new_inc_cost = 2 * c_i[i] * p_arr[i] + b_i[i]\n                heapq.heappush(heap, (new_inc_cost, i, p_arr[i], headroom))\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0004313054,
          "gap_price_rate": 0.0191574847,
          "fitness": 0.009794395
     },
     {
          "name": "rolling_commitment_v2",
          "algorithm": "1. Identify must-run units if currently online and violating minimum up-time, shutdown ramp limit, or ramp-down constraint (previous output > ramp-down limit)\n2. Identify must-off units if currently offline and violating minimum down-time\n3. For must-run units, compute feasible outputs considering ramp constraints\n4. For remaining flexible units, calculate cost per MW at minimum output including startup cost for offline units\n5. Sort flexible units by ascending cost per MW\n6. Commit flexible units in cost order until total maximum capacity covers current load\n7. If total minimum output exceeds current load, set committed units to minimum outputs\n8. If total maximum output is below current load, set committed units to maximum outputs\n9. Otherwise perform economic dispatch starting at minimum outputs and allocating residual load by ascending incremental cost\n10. Ensure uncommitted units remain off with zero output\n",
          "code": "import numpy as np\n\ndef rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    \n    # Identify must-run and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']) or (unit['p_i_0'] > unit['p_down_i']):\n                must_run[i] = True\n        if unit['u_i_0'] == 0:\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run units\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    flexible_indices = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    flexible_list = []\n    \n    # Prepare flexible units for commitment\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2) / min_i\n        else:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2) / min_i\n        flexible_list.append((i, cost_per_mw, min_i, max_i))\n    \n    flexible_list.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    committed_flexible = []\n    for (i, cost_per_mw, min_i, max_i) in flexible_list:\n        if total_max < load[0]:\n            u[i] = 1\n            committed_flexible.append(i)\n            min_output[i] = min_i\n            max_output[i] = max_i\n            total_min += min_i\n            total_max += max_i\n        else:\n            break\n    \n    # Handle output levels\n    if total_min > load[0]:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n    elif total_max < load[0]:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = max_output[i]\n    else:\n        residual = load[0] - total_min\n        committed_indices = [i for i in range(n_units) if u[i] == 1]\n        dispatch_list = []\n        \n        for i in committed_indices:\n            inc_cost = 2 * units_info[i]['c_i'] * min_output[i] + units_info[i]['b_i']\n            headroom = max_output[i] - min_output[i]\n            dispatch_list.append((i, inc_cost, headroom))\n            p[i] = min_output[i]\n        \n        dispatch_list.sort(key=lambda x: x[1])\n        \n        for (i, inc_cost, headroom) in dispatch_list:\n            if residual <= 0:\n                break\n            alloc = min(headroom, residual)\n            p[i] += alloc\n            residual -= alloc\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0005091712,
          "gap_price_rate": 0.0232513196,
          "fitness": 0.0118802454
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints.  \n2. Initialize commitment states for flexible units to their previous state.  \n3. Adjust flexible unit commitments:  \n   - If current minimum output exceeds load, turn off flexible units with highest production costs.  \n   - If current maximum output falls short of load, turn on flexible units using amortized startup costs over min up-time.  \n4. Perform constrained economic dispatch:  \n   - Set initial output to lower bounds.  \n   - Distribute remaining load by increasing output of units with smallest incremental cost, respecting upper bounds.  \n5. Ensure units turned off have zero output.  \n\n",
          "code": "import numpy as np  \n\ndef rolling_commitment_heuristic(units_info, load):  \n    n = len(units_info)  \n    u = [0] * n  \n    p = [0.0] * n  \n    lb_list = [0.0] * n  \n    ub_list = [0.0] * n  \n    must_run = [False] * n  \n    must_off = [False] * n  \n    current_load = load[0]  \n      \n    # Identify must-run and must-off units  \n    for i, unit in enumerate(units_info):  \n        u_prev = unit['u_i_0']  \n        t_prev = unit['t_i_0']  \n        p_prev = unit['p_i_0']  \n        if u_prev == 1:  \n            if (t_prev < unit['t_on_min_i']) or (p_prev > unit['p_shut_i']):  \n                must_run[i] = True  \n        else:  \n            if -t_prev < unit['t_off_min_i']:  \n                must_off[i] = True  \n      \n    # Initialize commitment states  \n    for i in range(n):  \n        if must_run[i]:  \n            u[i] = 1  \n        elif must_off[i]:  \n            u[i] = 0  \n        else:  \n            u[i] = units_info[i]['u_i_0']  \n      \n    # Compute initial total min and max  \n    total_min, total_max = 0.0, 0.0  \n    for i, unit in enumerate(units_info):  \n        if u[i] == 1:  \n            if u[i] == 1 and unit['u_i_0'] == 1:  \n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n            elif u[i] == 1 and unit['u_i_0'] == 0:  \n                lb = unit['p_min_i']  \n                ub = min(unit['p_max_i'], unit['p_start_i'])  \n            else:  \n                lb, ub = 0.0, 0.0  \n            lb_list[i] = lb  \n            ub_list[i] = ub  \n            total_min += lb  \n            total_max += ub  \n        else:  \n            lb_list[i] = 0.0  \n            ub_list[i] = 0.0  \n      \n    # Adjust for over-commitment  \n    if total_min > current_load:  \n        candidate_off = []  \n        for i in range(n):  \n            if not must_run[i] and not must_off[i] and u[i] == 1:  \n                unit = units_info[i]  \n                a_i = unit['a_i']  \n                b_i = unit['b_i']  \n                c_i = unit['c_i']  \n                p_max_i = unit['p_max_i']  \n                if p_max_i > 0:  \n                    avg_cost = (a_i + b_i * p_max_i + c_i * p_max_i**2) / p_max_i  \n                else:  \n                    avg_cost = float('inf')  \n                candidate_off.append((i, avg_cost))  \n        candidate_off.sort(key=lambda x: x[1], reverse=True)  \n        for i, _ in candidate_off:  \n            if total_min <= current_load:  \n                break  \n            u[i] = 0  \n            total_min -= lb_list[i]  \n            total_max -= ub_list[i]  \n            lb_list[i] = 0.0  \n            ub_list[i] = 0.0  \n      \n    # Adjust for under-commitment  \n    if total_max < current_load:  \n        candidate_on = []  \n        for i in range(n):  \n            if not must_off[i] and u[i] == 0:  \n                unit = units_info[i]  \n                a_i = unit['a_i']  \n                b_i = unit['b_i']  \n                c_i = unit['c_i']  \n                s_i = unit['s_i']  \n                p_max_i = unit['p_max_i']  \n                p_start_i = unit['p_start_i']  \n                t_on_min_i = unit['t_on_min_i']  \n                curr_max = min(p_max_i, p_start_i)  \n                if t_on_min_i > 1:  \n                    min_out = unit['p_min_i']  \n                    total_energy = curr_max + (t_on_min_i - 1) * min_out  \n                    total_cost = s_i + a_i * t_on_min_i + b_i * (curr_max + (t_on_min_i - 1) * min_out) + c_i * (curr_max**2 + (t_on_min_i - 1) * min_out**2)  \n                    amort_cost = total_cost / total_energy if total_energy > 0 else float('inf')  \n                else:  \n                    total_cost = s_i + a_i + b_i * curr_max + c_i * curr_max**2  \n                    amort_cost = total_cost / curr_max if curr_max > 0 else float('inf')  \n                candidate_on.append((i, amort_cost))  \n        candidate_on.sort(key=lambda x: x[1])  \n        for i, cost_val in candidate_on:  \n            if total_max >= current_load:  \n                break  \n            u[i] = 1  \n            unit = units_info[i]  \n            lb_i = unit['p_min_i']  \n            ub_i = min(unit['p_max_i'], unit['p_start_i'])  \n            lb_list[i] = lb_i  \n            ub_list[i] = ub_i  \n            total_min += lb_i  \n            total_max += ub_i  \n      \n    # Set initial dispatch to lower bounds  \n    p = lb_list[:]  \n    total_assigned = sum(p)  \n    remaining = current_load - total_assigned  \n      \n    # Economic dispatch: incremental cost allocation  \n    if remaining > 1e-5:  \n        available_units = [i for i in range(n) if u[i] == 1 and p[i] < ub_list[i]]  \n        while available_units and remaining > 1e-5:  \n            costs = []  \n            for i in available_units:  \n                b = units_info[i]['b_i']  \n                c = units_info[i]['c_i']  \n                costs.append((2 * c * p[i] + b, i))  \n            min_cost, min_idx = min(costs, key=lambda x: x[0])  \n            headroom = ub_list[min_idx] - p[min_idx]  \n            delta = min(remaining, headroom)  \n            p[min_idx] += delta  \n            remaining -= delta  \n            if abs(p[min_idx] - ub_list[min_idx]) < 1e-5:  \n                available_units.remove(min_idx)  \n      \n    # Ensure turned-off units have zero output  \n    for i in range(n):  \n        if u[i] == 0:  \n            p[i] = 0.0  \n              \n    return np.array([u, p])  ",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "hybrid_rolling_commitment",
          "algorithm": "1. Identify must-run units (online and violating min-up time or shutdown ramp limit) and must-off units (offline and violating min-down time). Set must-run units to ON and must-off units to OFF.\n2. Initialize flexible units to their previous commitment state. Compute feasible min/max outputs for all units based on ramp constraints and startup/shutdown limits.\n3. Adjust flexible unit commitments iteratively:\n   a. Decommit expensive flexible units if over-committed (total min output > load) while ensuring remaining capacity meets load.\n   b. Commit cheapest flexible units if under-capacity (total max output < load).\n4. Dispatch load based on adjusted commitments:\n   a. Set outputs to min if over-committed (total min output > load).\n   b. Set outputs to max if under-capacity (total max output < load).\n   c. Perform economic dispatch within feasible ranges using incremental cost sorting for optimal allocation.\n5. Return schedule with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment(units_info, load):\n    current_load = load[0]\n\n    # Identify must-run and must-off units, initialize flexible units\n    for unit in units_info:\n        unit_id = unit.get('id')  # Ensure units have 'id'\n        if unit['u_i_0'] == 1:  # Was online\n            unit['must_run'] = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n            unit['must_off'] = False\n            unit['u_i'] = 1 if unit['must_run'] else unit['u_i_0']\n        else:  # Was offline\n            off_time = -unit['t_i_0']\n            unit['must_run'] = False\n            unit['must_off'] = off_time < unit['t_off_min_i']\n            unit['u_i'] = 0 if unit['must_off'] else unit['u_i_0']\n    \n    # Compute feasible output ranges\n    for unit in units_info:\n        if unit['u_i'] == 1:\n            if unit['u_i_0'] == 1:  # Remains online\n                unit['min_output'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                unit['max_output'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                unit['min_output'] = unit['p_min_i']\n                unit['max_output'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['min_output'] = 0\n            unit['max_output'] = 0\n\n    # Calculate total min and max outputs\n    total_min = sum(unit['min_output'] for unit in units_info if unit['u_i'] == 1)\n    total_max = sum(unit['max_output'] for unit in units_info if unit['u_i'] == 1)\n    \n    # Prepare flexible online/offline lists\n    flex_online = [unit for unit in units_info if unit['u_i'] == 1 and not unit['must_run'] and not unit['must_off']]\n    flex_offline = [unit for unit in units_info if unit['u_i'] == 0 and not unit['must_run'] and not unit['must_off']]\n    \n    # Commitment adjustment loop\n    changed = True\n    while changed:\n        changed = False\n        \n        # Over-committed: decommit expensive units\n        if total_min > current_load and flex_online:\n            for unit in flex_online:\n                cost = unit['a_i'] + unit['b_i'] * unit['min_output'] + unit['c_i'] * unit['min_output'] ** 2\n                unit['_cost'] = cost\n            flex_online.sort(key=lambda x: x['_cost'], reverse=True)\n            \n            for unit in list(flex_online):\n                new_min = total_min - unit['min_output']\n                new_max = total_max - unit['max_output']\n                if new_max >= current_load:\n                    unit['u_i'] = 0\n                    unit['min_output'] = 0\n                    unit['max_output'] = 0\n                    total_min = new_min\n                    total_max = new_max\n                    flex_online.remove(unit)\n                    changed = True\n                    break\n        \n        # Under-capacity: commit cheapest units\n        if not changed and total_max < current_load and flex_offline:\n            for unit in flex_offline:\n                min_out = unit['p_min_i']\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2 + unit['s_i']) / min_out\n                unit['_cost_per_mw'] = cost_per_mw\n            flex_offline.sort(key=lambda x: x['_cost_per_mw'])\n            \n            unit = flex_offline.pop(0)\n            unit['u_i'] = 1\n            unit['min_output'] = unit['p_min_i']\n            unit['max_output'] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += unit['min_output']\n            total_max += unit['max_output']\n            flex_online.append(unit)\n            changed = True\n    \n    # Dispatch load\n    if total_min > current_load:  # Over-committed\n        for unit in units_info:\n            unit['p_i'] = unit['min_output'] if unit['u_i'] == 1 else 0\n    elif total_max < current_load:  # Under-capacity\n        for unit in units_info:\n            unit['p_i'] = unit['max_output'] if unit['u_i'] == 1 else 0\n    else:  # Economic dispatch\n        residual = current_load - total_min\n        committed = [unit for unit in units_info if unit['u_i'] == 1]\n        for unit in committed:\n            unit['p_i'] = unit['min_output']\n            unit['inc_cost'] = unit['b_i'] + 2 * unit['c_i'] * unit['min_output']\n        committed.sort(key=lambda x: x['inc_cost'])\n        \n        for unit in committed:\n            available = unit['max_output'] - unit['p_i']\n            if available >= residual:\n                unit['p_i'] += residual\n                break\n            else:\n                unit['p_i'] = unit['max_output']\n                residual -= available\n    \n    # Build output array\n    schedules = np.zeros((2, len(units_info)))\n    for i, unit in enumerate(units_info):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     }
]