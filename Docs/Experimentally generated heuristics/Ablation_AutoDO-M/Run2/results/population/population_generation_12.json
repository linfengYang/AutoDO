[
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify must-run units (currently online that violate minimum up-time or exceed shutdown ramp limit) and must-off units (currently offline that violate minimum down-time).\n2. Compute feasible output ranges for all units based on commitment status and physical constraints (ramp rates, startup/shutdown limits).\n3. Calculate cost per MW at minimum output for all flexible units (non must-run/must-off), including amortized startup cost for offline units.\n4. Build commitment set by:\n   - Starting with must-run units\n   - Adding flexible units in ascending cost/MW order until total maximum capacity meets load\n5. Decommit expensive flexible units while maintaining feasibility (total min \u2264 load \u2264 total max)\n6. Dispatch load by:\n   - Setting all committed units to minimum output if total minimum \u2265 load\n   - Setting to maximum output if total maximum \u2264 load\n   - Performing incremental cost-based economic dispatch for residual load otherwise\n7. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    unit_list = [unit.copy() for unit in units_info]\n    \n    # Initialize unit tracking\n    for i, unit in enumerate(unit_list):\n        unit['must_run'] = False\n        unit['must_off'] = False\n        unit['committed'] = False\n        unit['min_feas'] = 0.0\n        unit['max_feas'] = 0.0\n        unit['cost_per_MW'] = float('inf')\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in unit_list:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run units\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                unit['must_run'] = True\n                unit['min_feas'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                unit['max_feas'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        # Must-off units\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                unit['must_off'] = True\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Compute cost/MW for flexible units\n    for unit in flexible:\n        u_i0 = unit['u_i_0']\n        \n        # Previously online units\n        if u_i0 == 1:\n            unit['min_feas'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feas'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * unit['min_feas'] + unit['c_i'] * unit['min_feas'] ** 2\n            if unit['min_feas'] > 0:\n                unit['cost_per_MW'] = cost / unit['min_feas']\n        \n        # Offline units that can be started\n        else:\n            unit['min_feas'] = unit['p_min_i']\n            unit['max_feas'] = min(unit['p_max_i'], unit['p_start_i'])\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['min_feas'] + unit['c_i'] * unit['min_feas'] ** 2\n            if unit['min_feas'] > 0:\n                unit['cost_per_MW'] = cost / unit['min_feas']\n    \n    # Build initial commitment set\n    committed = must_run.copy()\n    total_min = sum(unit['min_feas'] for unit in must_run)\n    total_max = sum(unit['max_feas'] for unit in must_run)\n    flexible.sort(key=lambda x: x['cost_per_MW'])\n    \n    # Add flexible units until load can be met\n    for unit in flexible:\n        if total_max < current_load:\n            committed.append(unit)\n            total_min += unit['min_feas']\n            total_max += unit['max_feas']\n    \n    # Decommit expensive units while maintaining feasibility\n    flexible_committed = [u for u in committed if u in flexible]\n    flexible_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    \n    removed = True\n    while removed and flexible_committed:\n        removed = False\n        for i, unit in enumerate(flexible_committed):\n            new_min = total_min - unit['min_feas']\n            new_max = total_max - unit['max_feas']\n            if new_max >= current_load and new_min <= current_load:\n                total_min = new_min\n                total_max = new_max\n                committed.remove(unit)\n                flexible_committed.pop(i)\n                removed = True\n                break\n    \n    # Set commitment status\n    for unit in committed:\n        unit['committed'] = True\n    \n    # Dispatch load to committed units\n    if total_min >= current_load:\n        for unit in committed:\n            unit['p_i'] = unit['min_feas']\n    elif total_max <= current_load:\n        for unit in committed:\n            unit['p_i'] = unit['max_feas']\n    else:\n        # Allocate minimum power\n        for unit in committed:\n            unit['p_i'] = unit['min_feas']\n        residual = current_load - total_min\n        \n        # Allocate residual load by incremental cost\n        committed.sort(key=lambda x: 2*x['c_i']*x['min_feas'] + x['b_i'])\n        for unit in committed:\n            alloc = min(residual, unit['max_feas'] - unit['p_i'])\n            unit['p_i'] += alloc\n            residual -= alloc\n            if residual <= 0:\n                break\n    \n    # Generate output\n    for i, unit in enumerate(unit_list):\n        schedules[0, i] = 1 if unit['committed'] else 0\n        schedules[1, i] = unit['p_i']\n            \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.005982537,
          "gap_price_rate": 0.0086275961,
          "fitness": 0.0073050665
     },
     {
          "name": "enhanced_rolling_commitment_v2",
          "algorithm": "1. Identify must-run units (online violating min-up or shutdown ramp) and must-off units (offline violating min-down). 2. Compute feasible outputs for each unit based on ramp rates and startup/shutdown constraints. 3. Calculate amortized startup cost per MW for flexible units. 4. Build initial commitment set: must-run units + flexible units sorted by min-output incremental cost (with amortized startup) until capacity covers load. 5. Decommit expensive flexible units in descending cost order while maintaining load coverage feasibility. 6. Dispatch load: minimum outputs if feasible; maximum outputs if necessary; otherwise incremental cost dispatch respecting unit limits.\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed = [False] * n_units\n    min_on = [0.0] * n_units\n    max_on = [0.0] * n_units\n    cost_per_mw = [0.0] * n_units\n    must_run = []\n    must_off = []\n    flexible = []\n\n    # Precompute must-run/must-off and feasible output ranges\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Currently online\n            min_on[i] = max(p_min, p_i0 - p_down)\n            max_on[i] = min(p_max, p_i0 + p_up)\n            if t_i0 < min_up or p_i0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Currently offline\n            min_on[i] = p_min\n            max_on[i] = min(p_max, p_start)\n            if abs(t_i0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n    # Build initial commitment set\n    committed_set = set(must_run)\n    total_min = sum(min_on[i] for i in committed_set)\n    total_max = sum(max_on[i] for i in committed_set)\n    \n    # Calculate cost/MW for flexible units\n    flex_candidates = []\n    for i in flexible:\n        unit = units_info[i]\n        a, b, c, s = unit['a_i'], unit['b_i'], unit['c_i'], unit['s_i']\n        base_cost = a + b * min_on[i] + c * min_on[i]**2\n        \n        if not unit['u_i_0']:  # Currently offline\n            amortized_startup = s / unit['t_on_min_i']\n            total_cost = base_cost + amortized_startup\n        else:\n            total_cost = base_cost\n            \n        cost_per_mw[i] = total_cost / min_on[i]\n        flex_candidates.append((cost_per_mw[i], i, min_on[i], max_on[i]))\n    \n    # Add flexible units by ascending cost/MW\n    flex_candidates.sort(key=lambda x: x[0])\n    added_flex = []\n    for cpmw, i, min_i, max_i in flex_candidates:\n        if total_max >= current_load:\n            break\n        committed_set.add(i)\n        added_flex.append(i)\n        total_min += min_i\n        total_max += max_i\n    \n    # Decommit expensive flexible units\n    decommit_candidates = sorted(\n        [(cost_per_mw[i], i, min_on[i], max_on[i]) for i in added_flex],\n        key=lambda x: x[0], reverse=True\n    )\n    decommitted = set()\n    temp_min, temp_max = total_min, total_max\n    for cpmw, i, min_i, max_i in decommit_candidates:\n        if temp_min - min_i <= current_load <= temp_max - max_i:\n            decommitted.add(i)\n            temp_min -= min_i\n            temp_max -= max_i\n    committed_set -= decommitted\n    total_min, total_max = temp_min, temp_max\n    \n    # Initialize outputs\n    outputs = [0.0] * n_units\n    states = [0] * n_units\n    \n    # Dispatch load to committed units\n    for i in committed_set:\n        states[i] = 1\n        outputs[i] = min_on[i]\n    \n    # Case 1: Minimum generation satisfies load\n    if total_min >= current_load:\n        for i in committed_set:\n            outputs[i] = min_on[i]\n    \n    # Case 2: Maximum generation needed\n    elif total_max <= current_load:\n        for i in committed_set:\n            outputs[i] = max_on[i]\n    \n    # Case 3: Economic dispatch needed\n    else:\n        residual = current_load - total_min\n        heap = []\n        for i in committed_set:\n            unit = units_info[i]\n            current_out = outputs[i]\n            inc_cost = 2 * unit['c_i'] * current_out + unit['b_i']\n            heapq.heappush(heap, (inc_cost, i, current_out, max_on[i]))\n        \n        while residual > 0 and heap:\n            inc_cost, i, current, max_i = heapq.heappop(heap)\n            unit = units_info[i]\n            alloc = min(residual, max_i - current)\n            new_out = current + alloc\n            residual -= alloc\n            outputs[i] = new_out\n            \n            if new_out < max_i:\n                new_inc = 2 * unit['c_i'] * new_out + unit['b_i']\n                heapq.heappush(heap, (new_inc, i, new_out, max_i))\n    \n    # Set uncommitted units\n    for i in must_off:\n        states[i] = 0\n        outputs[i] = 0.0\n    for i in set(range(n_units)) - committed_set - set(must_off):\n        states[i] = 0\n        outputs[i] = 0.0\n    \n    return np.array([states, outputs])",
          "from": "mutation",
          "gap_power_rate": 0.0060153633,
          "gap_price_rate": 0.0095387414,
          "fitness": 0.0077770523
     },
     {
          "name": "rolling_commitment_v1",
          "algorithm": "**  \n1. Identify must-run units if currently online but violating minimum up-time or previous output exceeds shutdown ramp limit.  \n2. Identify must-off units if currently offline but violating minimum down-time.  \n3. For must-run units, compute feasible min/max outputs considering ramp and startup constraints.  \n4. For remaining units, calculate cost/MW at minimum output (including startup cost for offline units) and sort ascending.  \n5. Add flexible units to commitment until total max feasible capacity meets load, updating cumulative min/max outputs.  \n6. If cumulative min output exceeds load, set all committed units to min output.  \n7. If cumulative max output is below load, set all committed units to max output.  \n8. Otherwise, perform economic dispatch:  \n   - Initialize each unit at min output  \n   - Allocate remaining load ascending by incremental cost at min output  \n   - Respect individual unit's max output and ramp constraints  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize vectors\n    min_on = np.zeros(n_units)\n    max_on = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    \n    # Step 1-3: Determine must-run/must-off and compute feasible ranges\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            min_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off.append(i)\n            min_on[i] = unit['p_min_i']\n            max_on[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize capacity\n    total_min = sum(min_on[i] for i in must_run)\n    total_max = sum(max_on[i] for i in must_run)\n    candidate_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    candidate_costs = []\n    \n    # Step 4: Calculate cost/MW for candidate units\n    for i in candidate_units:\n        unit = units_info[i]\n        min_p = min_on[i]\n        if unit['u_i_0'] == 1:  # Currently online\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        else:  # Currently offline (add startup cost)\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2 + unit['s_i']\n        candidate_costs.append((i, cost / min_p))\n    \n    # Sort candidates by cost/MW\n    candidate_costs.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    \n    # Step 5: Commit flexible units\n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        total_min += min_on[i]\n        total_max += max_on[i]\n        committed.append(i)\n    \n    # Step 6-8: Dispatch generation\n    u_vec = [0] * n_units\n    p_vec = [0] * n_units\n    \n    if total_min > current_load:  # Over-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n    elif total_max < current_load:  # Under-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = max_on[i]\n    else:  # Economic dispatch\n        # Initialize at min output\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n        deficit = current_load - total_min\n        \n        # Sort by incremental cost at min output\n        units_to_dispatch = []\n        for i in committed:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_on[i] + unit['b_i']\n            headroom = max_on[i] - min_on[i]\n            units_to_dispatch.append((inc_cost, i, headroom))\n        units_to_dispatch.sort(key=lambda x: x[0])\n        \n        # Allocate deficit\n        for inc_cost, i, headroom in units_to_dispatch:\n            if deficit <= 0:\n                break\n            allocate = min(headroom, deficit)\n            p_vec[i] += allocate\n            deficit -= allocate\n    \n    return np.array([u_vec, p_vec])",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify must-run units (online violating min-up/shutdown ramp) and must-off units (offline violating min-down)\n2. Compute feasible output ranges for committed units considering ramp and startup/shutdown constraints\n3. Calculate amortized startup cost per MW for flexible offline units\n4. Sort flexible units by min-output incremental cost (amortized startup for offline units)\n5. Commit sorted flexible units until total max output \u2265 load\n6. Decommit most expensive flexible units until min output \u2264 load while maintaining max output \u2265 load\n7. Dispatch load:\n   - If min output \u2265 load: set committed units to min outputs\n   - Else if max output \u2264 load: set committed units to max outputs\n   - Else: set min outputs then distribute residual load ascending by min-output incremental cost\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    min_output = [0] * n_units\n    max_output = [0] * n_units\n    \n    # Identify must-run and must-off units\n    for i, unit in enumerate(units_info):\n        # Must-run condition\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        \n        # Must-off condition\n        if unit['u_i_0'] == 0:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Compute feasible ranges and set outputs\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run and must-off units\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n        elif must_off[i]:\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            min_output[i] = unit['p_min_i']\n            if unit['u_i_0'] == 0:\n                max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Prepare flexible units\n    flexible_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            min_val = min_output[i]\n            # Calculate amortized startup cost\n            if unit['u_i_0'] == 0:\n                cost = (unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * min_val**2 +\n                        unit['s_i'] / unit['t_on_min_i'])\n            else:\n                cost = unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * min_val**2\n            flexible_units.append((cost / min_val, i, min_val, max_output[i]))\n    \n    # Sort flexible units by cost per MW\n    flexible_units.sort(key=lambda x: x[0])\n    \n    # Commit flexible units until capacity requirement met\n    comm_flex = []\n    for cost_per_mw, i, min_val, max_val in flexible_units:\n        if total_max < current_load:\n            u[i] = 1\n            total_min += min_val\n            total_max += max_val\n            comm_flex.append((cost_per_mw, i, min_val, max_val))\n    \n    # Decommit most expensive units if possible\n    comm_flex.sort(key=lambda x: x[0], reverse=True)\n    for cost_per_mw, i, min_val, max_val in comm_flex[:]:\n        if total_min - min_val > current_load and total_max - max_val >= current_load:\n            u[i] = 0\n            total_min -= min_val\n            total_max -= max_val\n            comm_flex.remove((cost_per_mw, i, min_val, max_val))\n    \n    # Handle dispatch cases\n    if total_min >= current_load:\n        # Min output case\n        for i, unit in enumerate(units_info):\n            if u[i] == 1:\n                p[i] = min_output[i]\n    elif total_max <= current_load:\n        # Max output case\n        for i, unit in enumerate(units_info):\n            if u[i] == 1:\n                p[i] = max_output[i]\n    else:\n        # Economic dispatch\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n        residual = current_load - total_min\n        \n        # Calculate incremental costs\n        inc_costs = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * min_output[i]\n                inc_costs.append((inc_cost, i))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        # Distribute residual load\n        for inc_cost, idx in inc_costs:\n            avail = max_output[idx] - min_output[idx]\n            if residual <= 0:\n                break\n            if avail > 0:\n                add = min(avail, residual)\n                p[idx] += add\n                residual -= add\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0062166873,
          "gap_price_rate": 0.0105974149,
          "fitness": 0.0084070511
     },
     {
          "name": "rolling_commitment_v3",
          "algorithm": "1. Identify must-run and must-off units:  \n   - Must-run: Online units (u_i_0=1) violating min up-time (t_i_0 < t_on_min_i) or previous output exceeds shutdown ramp limit (p_i_0 > p_shut_i)  \n   - Must-off: Offline units (u_i_0=0) violating min down-time (|t_i_0| < t_off_min_i)  \n2. Initialize flexible units to their previous state (u_i = u_i_0)  \n3. Compute ramp-constrained min/max outputs for each unit based on current commitment  \n4. Adjust commitment:  \n   a. If total min output > load: Turn off flexible online units with highest operating cost per MW  \n   b. If total max output < load: Turn on flexible offline units with lowest amortized startup cost per MW  \n5. For committed units:  \n   a. Set output to ramp-constrained min  \n   b. Distribute residual load using priority queue based on incremental cost, respecting ramp limits  \n6. Set uncommitted units to zero output  \n\n",
          "code": "import heapq\nimport numpy as np\n\ndef rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n\n        if u_i_0 == 1:\n            if (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i):\n                must_run[i] = True\n                u[i] = 1\n            else:\n                must_run[i] = False\n            must_off[i] = False\n        else:\n            must_run[i] = False\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n                u[i] = 0\n            else:\n                must_off[i] = False\n                u[i] = u_i_0\n\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n\n    def compute_min_max(i, u_i):\n        unit = units_info[i]\n        if u_i == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0.0\n            max_out[i] = 0.0\n\n    for i in range(n_units):\n        compute_min_max(i, u[i])\n\n    total_min = sum(min_out)\n    total_max = sum(max_out)\n\n    if total_min > current_load:\n        candidate_off = []\n        for i in range(n_units):\n            if not must_run[i] and not must_off[i] and u[i] == 1:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    if unit['p_i_0'] <= unit['p_down_i']:\n                        cost = (unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2) / min_out[i]\n                        candidate_off.append((cost, i))\n        candidate_off.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in candidate_off:\n            prev_min = min_out[i]\n            prev_max = max_out[i]\n            u[i] = 0\n            compute_min_max(i, 0)\n            total_min -= prev_min\n            total_max -= prev_max\n            if total_min <= current_load:\n                break\n\n    elif total_max < current_load:\n        candidate_on = []\n        for i in range(n_units):\n            if not must_run[i] and not must_off[i] and u[i] == 0:\n                unit = units_info[i]\n                min_new = unit['p_min_i']\n                if min_new <= 0: continue\n                startup = unit['s_i'] / unit['t_on_min_i'] if unit['t_on_min_i'] > 0 else 0\n                operating_cost = unit['a_i'] + unit['b_i'] * min_new + unit['c_i'] * min_new**2\n                total_cost = startup + operating_cost\n                cost_per_mw = total_cost / min_new\n                max_new = min(unit['p_max_i'], unit['p_start_i'])\n                candidate_on.append((cost_per_mw, i, min_new, max_new))\n        candidate_on.sort(key=lambda x: x[0])\n        for cost_per_mw, i, min_new, max_new in candidate_on:\n            u[i] = 1\n            compute_min_max(i, 1)\n            total_min += min_new\n            total_max += max_new\n            if total_max >= current_load:\n                break\n\n    for i in range(n_units):\n        compute_min_max(i, u[i])\n        if u[i] == 0:\n            p[i] = 0.0\n        else:\n            p[i] = min_out[i]\n\n    residual = current_load - sum(min_out)\n    if residual > 0:\n        heap = []\n        for i in range(n_units):\n            if u[i] == 1 and min_out[i] < max_out[i]:\n                inc_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                heapq.heappush(heap, (inc_cost, i, min_out[i], max_out[i]))\n\n        while residual > 0 and heap:\n            inc_cost, i, current, max_val = heapq.heappop(heap)\n            available = min(residual, max_val - current)\n            p[i] += available\n            residual -= available\n            current += available\n            if current < max_val:\n                new_inc_cost = 2 * units_info[i]['c_i'] * current + units_info[i]['b_i']\n                heapq.heappush(heap, (new_inc_cost, i, current, max_val))\n\n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00613007,
          "gap_price_rate": 0.0113271693,
          "fitness": 0.0087286197
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "refined_rolling_commitment_v1",
          "algorithm": "1. Identify must-run units: units online with insufficient min-up time or previous output exceeding shutdown ramp limit.\n2. Identify must-off units: units offline with insufficient min-down time.\n3. Initialize flexible units to their previous commitment state.\n4. Compute feasible min/max outputs considering ramp and startup constraints:\n   - For units staying online: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - For units starting: [p_min, min(p_max, startup_limit, ramp_up)]\n5. Adjust commitment:\n   a. Turn off expensive flexible online units if total min output > load, while ensuring total max \u2265 load.\n   b. Turn on amortized-cheapest flexible offline units if total max < load.\n   c. After adding units, decommit most expensive units (both existing and new) if total min > load.\n6. Set committed units to min output and allocate residual load:\n   a. Distribute using priority queue based on incremental cost (2c_i\u00b7p_i + b_i).\n   b. Respect individual unit max outputs and ramp constraints.\n7. Set uncommitted units to off with zero output.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef refined_rolling_commitment_v1(units_info, load):\n    load_current = load[0]  # current load to satisfy\n    \n    # Extract unit attributes\n    n = len(units_info)\n    a_i = np.array([u['a_i'] for u in units_info])\n    b_i = np.array([u['b_i'] for u in units_info])\n    c_i = np.array([u['c_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_min_i = np.array([u['p_min_i'] for u in units_info])\n    p_max_i = np.array([u['p_max_i'] for u in units_info])\n    p_down_i = np.array([u['p_down_i'] for u in units_info])\n    p_up_i = np.array([u['p_up_i'] for u in units_info])\n    p_start_i = np.array([u['p_start_i'] for u in units_info])\n    p_shut_i = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min_i = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min_i = np.array([u['t_off_min_i'] for u in units_info])\n    s_i = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize arrays\n    u_arr = np.zeros(n)  # commitment state\n    p_arr = np.zeros(n)  # output power\n    min_p_arr = np.zeros(n)  # feasible min output\n    max_p_arr = np.zeros(n)  # feasible max output\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(n):\n        if u_i_0[i] == 1:\n            if (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i]):\n                must_run.append(i)\n        else:\n            if -t_i_0[i] < t_off_min_i[i]:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    committed = []\n    flexible_online = []\n    flexible_offline = []\n    \n    for i in range(n):\n        if i in must_run:\n            u_arr[i] = 1\n            committed.append(i)\n        elif i in must_off:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = u_i_0[i]\n            if u_i_0[i] == 1:\n                flexible_online.append(i)\n                committed.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Compute feasible min/max outputs for committed units\n    total_min = 0.0\n    total_max = 0.0\n    for i in range(n):\n        if u_arr[i] == 1:\n            if u_i_0[i] == 1:\n                min_p_arr[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                max_p_arr[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n            else:\n                min_p_arr[i] = p_min_i[i]\n                max_p_arr[i] = min(p_max_i[i], p_start_i[i], p_up_i[i])\n            total_min += min_p_arr[i]\n            total_max += max_p_arr[i]\n    \n    # Decommit expensive online units if over-generation\n    candidates_off = flexible_online.copy()\n    candidates_off.sort(key=lambda i: (a_i[i] + b_i[i]*min_p_arr[i] + c_i[i]*(min_p_arr[i]**2)) / min_p_arr[i], reverse=True)\n    \n    new_committed = committed.copy()\n    new_min = total_min\n    new_max = total_max\n    \n    for i in candidates_off:\n        if i not in new_committed: \n            continue\n        new_min_candidate = new_min - min_p_arr[i]\n        new_max_candidate = new_max - max_p_arr[i]\n        if new_max_candidate >= load_current:\n            new_committed.remove(i)\n            new_min = new_min_candidate\n            new_max = new_max_candidate\n        if new_min <= load_current:\n            break\n    \n    committed = new_committed\n    total_min = new_min\n    total_max = new_max\n    \n    # Update arrays after decommitment\n    for i in flexible_online:\n        if i not in committed:\n            u_arr[i] = 0\n            min_p_arr[i] = 0\n            max_p_arr[i] = 0\n    \n    # Commit additional units if under-capacity\n    if total_max < load_current:\n        candidates_on = flexible_offline.copy()\n        candidates_on.sort(key=lambda i: (a_i[i] + b_i[i]*p_min_i[i] + c_i[i]*(p_min_i[i]**2) + (s_i[i]/t_on_min_i[i])) / p_min_i[i])\n        \n        for i in candidates_on:\n            if total_max >= load_current:\n                break\n            startup_min = p_min_i[i]\n            startup_max = min(p_max_i[i], p_start_i[i], p_up_i[i])\n            committed.append(i)\n            u_arr[i] = 1\n            min_p_arr[i] = startup_min\n            max_p_arr[i] = startup_max\n            total_min += startup_min\n            total_max += startup_max\n    \n    # Post-addition decommitment if over-generation\n    if total_min > load_current:\n        candidates_off2 = [i for i in committed if i not in must_run]\n        candidates_off2.sort(key=lambda i: (a_i[i] + b_i[i]*min_p_arr[i] + c_i[i]*(min_p_arr[i]**2) + (s_i[i] if u_i_0[i]==0 else 0)) / min_p_arr[i], reverse=True)\n        \n        new_committed = committed.copy()\n        new_min = total_min\n        new_max = total_max\n        \n        for i in candidates_off2:\n            if i not in new_committed: \n                continue\n            new_min_candidate = new_min - min_p_arr[i]\n            new_max_candidate = new_max - max_p_arr[i]\n            if new_max_candidate >= load_current:\n                new_committed.remove(i)\n                new_min = new_min_candidate\n                new_max = new_max_candidate\n            if new_min <= load_current:\n                break\n        \n        committed = new_committed\n    \n    # Final commit state update\n    for i in range(n):\n        u_arr[i] = 1 if i in committed else 0\n        min_p_arr[i] = min_p_arr[i] if i in committed else 0\n        max_p_arr[i] = max_p_arr[i] if i in committed else 0\n    \n    # Initial dispatch at min output\n    for i in committed:\n        p_arr[i] = min_p_arr[i]\n    \n    residual = load_current - np.sum(p_arr)\n    \n    # Economic dispatch with incremental costs\n    if residual > 0:\n        heap = []\n        for i in committed:\n            headroom = max_p_arr[i] - min_p_arr[i]\n            if headroom > 0:\n                inc_cost = 2 * c_i[i] * p_arr[i] + b_i[i]\n                heapq.heappush(heap, (inc_cost, i, p_arr[i], headroom))\n        \n        while residual > 0 and heap:\n            inc_cost, i, current_p, headroom = heapq.heappop(heap)\n            delta = min(residual, headroom)\n            p_arr[i] += delta\n            residual -= delta\n            headroom -= delta\n            \n            if headroom > 0:\n                new_inc_cost = 2 * c_i[i] * p_arr[i] + b_i[i]\n                heapq.heappush(heap, (new_inc_cost, i, p_arr[i], headroom))\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0004313054,
          "gap_price_rate": 0.0191574847,
          "fitness": 0.009794395
     },
     {
          "name": "rolling_commitment_v2",
          "algorithm": "1. Identify must-run units if currently online and violating minimum up-time, shutdown ramp limit, or ramp-down constraint (previous output > ramp-down limit)\n2. Identify must-off units if currently offline and violating minimum down-time\n3. For must-run units, compute feasible outputs considering ramp constraints\n4. For remaining flexible units, calculate cost per MW at minimum output including startup cost for offline units\n5. Sort flexible units by ascending cost per MW\n6. Commit flexible units in cost order until total maximum capacity covers current load\n7. If total minimum output exceeds current load, set committed units to minimum outputs\n8. If total maximum output is below current load, set committed units to maximum outputs\n9. Otherwise perform economic dispatch starting at minimum outputs and allocating residual load by ascending incremental cost\n10. Ensure uncommitted units remain off with zero output\n",
          "code": "import numpy as np\n\ndef rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    \n    # Identify must-run and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']) or (unit['p_i_0'] > unit['p_down_i']):\n                must_run[i] = True\n        if unit['u_i_0'] == 0:\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run units\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    flexible_indices = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    flexible_list = []\n    \n    # Prepare flexible units for commitment\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2) / min_i\n        else:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2) / min_i\n        flexible_list.append((i, cost_per_mw, min_i, max_i))\n    \n    flexible_list.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    committed_flexible = []\n    for (i, cost_per_mw, min_i, max_i) in flexible_list:\n        if total_max < load[0]:\n            u[i] = 1\n            committed_flexible.append(i)\n            min_output[i] = min_i\n            max_output[i] = max_i\n            total_min += min_i\n            total_max += max_i\n        else:\n            break\n    \n    # Handle output levels\n    if total_min > load[0]:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n    elif total_max < load[0]:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = max_output[i]\n    else:\n        residual = load[0] - total_min\n        committed_indices = [i for i in range(n_units) if u[i] == 1]\n        dispatch_list = []\n        \n        for i in committed_indices:\n            inc_cost = 2 * units_info[i]['c_i'] * min_output[i] + units_info[i]['b_i']\n            headroom = max_output[i] - min_output[i]\n            dispatch_list.append((i, inc_cost, headroom))\n            p[i] = min_output[i]\n        \n        dispatch_list.sort(key=lambda x: x[1])\n        \n        for (i, inc_cost, headroom) in dispatch_list:\n            if residual <= 0:\n                break\n            alloc = min(headroom, residual)\n            p[i] += alloc\n            residual -= alloc\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0005091712,
          "gap_price_rate": 0.0232513196,
          "fitness": 0.0118802454
     }
]