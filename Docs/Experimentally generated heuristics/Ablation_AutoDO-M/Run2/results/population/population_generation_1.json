[
     {
          "name": "rolling_commitment_v1",
          "algorithm": "**  \n1. Identify must-run units if currently online but violating minimum up-time or previous output exceeds shutdown ramp limit.  \n2. Identify must-off units if currently offline but violating minimum down-time.  \n3. For must-run units, compute feasible min/max outputs considering ramp and startup constraints.  \n4. For remaining units, calculate cost/MW at minimum output (including startup cost for offline units) and sort ascending.  \n5. Add flexible units to commitment until total max feasible capacity meets load, updating cumulative min/max outputs.  \n6. If cumulative min output exceeds load, set all committed units to min output.  \n7. If cumulative max output is below load, set all committed units to max output.  \n8. Otherwise, perform economic dispatch:  \n   - Initialize each unit at min output  \n   - Allocate remaining load ascending by incremental cost at min output  \n   - Respect individual unit's max output and ramp constraints  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize vectors\n    min_on = np.zeros(n_units)\n    max_on = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    \n    # Step 1-3: Determine must-run/must-off and compute feasible ranges\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            min_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off.append(i)\n            min_on[i] = unit['p_min_i']\n            max_on[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize capacity\n    total_min = sum(min_on[i] for i in must_run)\n    total_max = sum(max_on[i] for i in must_run)\n    candidate_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    candidate_costs = []\n    \n    # Step 4: Calculate cost/MW for candidate units\n    for i in candidate_units:\n        unit = units_info[i]\n        min_p = min_on[i]\n        if unit['u_i_0'] == 1:  # Currently online\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        else:  # Currently offline (add startup cost)\n            cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2 + unit['s_i']\n        candidate_costs.append((i, cost / min_p))\n    \n    # Sort candidates by cost/MW\n    candidate_costs.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    \n    # Step 5: Commit flexible units\n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        total_min += min_on[i]\n        total_max += max_on[i]\n        committed.append(i)\n    \n    # Step 6-8: Dispatch generation\n    u_vec = [0] * n_units\n    p_vec = [0] * n_units\n    \n    if total_min > current_load:  # Over-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n    elif total_max < current_load:  # Under-generation\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = max_on[i]\n    else:  # Economic dispatch\n        # Initialize at min output\n        for i in committed:\n            u_vec[i] = 1\n            p_vec[i] = min_on[i]\n        deficit = current_load - total_min\n        \n        # Sort by incremental cost at min output\n        units_to_dispatch = []\n        for i in committed:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_on[i] + unit['b_i']\n            headroom = max_on[i] - min_on[i]\n            units_to_dispatch.append((inc_cost, i, headroom))\n        units_to_dispatch.sort(key=lambda x: x[0])\n        \n        # Allocate deficit\n        for inc_cost, i, headroom in units_to_dispatch:\n            if deficit <= 0:\n                break\n            allocate = min(headroom, deficit)\n            p_vec[i] += allocate\n            deficit -= allocate\n    \n    return np.array([u_vec, p_vec])",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "refined_commit_dispatch_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_commit_dispatch_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:\n            if (t_i_0 > 0 and t_i_0 < unit['t_on_min_i']) or p_i_0 > unit['p_shut_i']:\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if t_i_0 < 0 and abs(t_i_0) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    flex_on = [unit for unit in flexible if unit['u_i_0'] == 1]\n    flex_off = [unit for unit in flexible if unit['u_i_0'] == 0]\n    \n    must_run_min = 0\n    must_run_max = 0\n    for unit in must_run:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['LB'] = lb\n        unit['UB'] = ub\n        must_run_min += lb\n        must_run_max += ub\n    \n    flex_on_min = 0\n    flex_on_max = 0\n    for unit in flex_on:\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['LB'] = lb\n        unit['UB'] = ub\n        flex_on_min += lb\n        flex_on_max += ub\n    \n    total_min = must_run_min + flex_on_min\n    total_max = must_run_max + flex_on_max\n    \n    if current_load < total_min:\n        for unit in flex_on:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n        for unit in must_run:\n            unit['u_i'] = 1\n        committed_units = must_run\n        total_min_committed = must_run_min\n        total_max_committed = must_run_max\n        if current_load < total_min_committed:\n            for unit in committed_units:\n                unit['p_i'] = unit['LB']\n        else:\n            dispatch(committed_units, current_load)\n    elif current_load <= total_max:\n        for unit in flex_on:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n        for unit in must_run:\n            unit['u_i'] = 1\n        committed_units = must_run\n        dispatch(committed_units, current_load)\n    else:\n        for unit in must_run:\n            unit['u_i'] = 1\n        for unit in flex_on:\n            unit['u_i'] = 1\n        flex_off_sorted = sorted(flex_off, key=lambda unit: \n            (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i'])\n        added_min = 0\n        added_max = 0\n        new_units = []\n        for unit in flex_off_sorted:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            unit['LB'] = lb\n            unit['UB'] = ub\n            added_min += lb\n            added_max += ub\n            new_units.append(unit)\n            if must_run_max + flex_on_max + added_max >= current_load:\n                break\n        for unit in new_units:\n            unit['u_i'] = 1\n        committed_units = must_run + flex_on + new_units\n        dispatch(committed_units, current_load)\n    \n    for unit in must_off:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    for unit in flex_off:\n        if 'u_i' not in unit:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    schedules = np.zeros((2, n_units))\n    for i, unit in enumerate(units_info):\n        schedules[0, i] = unit.get('u_i', 0)\n        schedules[1, i] = unit.get('p_i', 0)\n    \n    return schedules\n\ndef dispatch(committed_units, load):\n    LB_arr = [unit['LB'] for unit in committed_units]\n    UB_arr = [unit['UB'] for unit in committed_units]\n    p_i = LB_arr.copy()\n    current_total = sum(p_i)\n    deficit = load - current_total\n    \n    active_indices = [i for i in range(len(committed_units)) if p_i[i] < UB_arr[i]]\n    \n    while deficit > 1e-5 and active_indices:\n        inc_costs = []\n        for idx in active_indices:\n            b = committed_units[idx]['b_i']\n            c = committed_units[idx]['c_i']\n            inc_cost = b + 2 * c * p_i[idx]\n            inc_costs.append(inc_cost)\n        \n        min_cost = min(inc_costs)\n        min_idx_in_active = inc_costs.index(min_cost)\n        idx = active_indices[min_idx_in_active]\n        \n        max_inc = UB_arr[idx] - p_i[idx]\n        actual_inc = min(max_inc, deficit)\n        p_i[idx] += actual_inc\n        deficit -= actual_inc\n        \n        if p_i[idx] >= UB_arr[idx] - 1e-5:\n            active_indices.remove(idx)\n    \n    for i, unit in enumerate(committed_units):\n        unit['p_i'] = p_i[i]",
          "from": "mutation",
          "gap_power_rate": 0.008144878,
          "gap_price_rate": 0.0088061188,
          "fitness": 0.0084754984
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints.  \n2. Initialize commitment states for flexible units to their previous state.  \n3. Adjust flexible unit commitments:  \n   - If current minimum output exceeds load, turn off flexible units with highest production costs.  \n   - If current maximum output falls short of load, turn on flexible units using amortized startup costs over min up-time.  \n4. Perform constrained economic dispatch:  \n   - Set initial output to lower bounds.  \n   - Distribute remaining load by increasing output of units with smallest incremental cost, respecting upper bounds.  \n5. Ensure units turned off have zero output.  \n\n",
          "code": "import numpy as np  \n\ndef rolling_commitment_heuristic(units_info, load):  \n    n = len(units_info)  \n    u = [0] * n  \n    p = [0.0] * n  \n    lb_list = [0.0] * n  \n    ub_list = [0.0] * n  \n    must_run = [False] * n  \n    must_off = [False] * n  \n    current_load = load[0]  \n      \n    # Identify must-run and must-off units  \n    for i, unit in enumerate(units_info):  \n        u_prev = unit['u_i_0']  \n        t_prev = unit['t_i_0']  \n        p_prev = unit['p_i_0']  \n        if u_prev == 1:  \n            if (t_prev < unit['t_on_min_i']) or (p_prev > unit['p_shut_i']):  \n                must_run[i] = True  \n        else:  \n            if -t_prev < unit['t_off_min_i']:  \n                must_off[i] = True  \n      \n    # Initialize commitment states  \n    for i in range(n):  \n        if must_run[i]:  \n            u[i] = 1  \n        elif must_off[i]:  \n            u[i] = 0  \n        else:  \n            u[i] = units_info[i]['u_i_0']  \n      \n    # Compute initial total min and max  \n    total_min, total_max = 0.0, 0.0  \n    for i, unit in enumerate(units_info):  \n        if u[i] == 1:  \n            if u[i] == 1 and unit['u_i_0'] == 1:  \n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n            elif u[i] == 1 and unit['u_i_0'] == 0:  \n                lb = unit['p_min_i']  \n                ub = min(unit['p_max_i'], unit['p_start_i'])  \n            else:  \n                lb, ub = 0.0, 0.0  \n            lb_list[i] = lb  \n            ub_list[i] = ub  \n            total_min += lb  \n            total_max += ub  \n        else:  \n            lb_list[i] = 0.0  \n            ub_list[i] = 0.0  \n      \n    # Adjust for over-commitment  \n    if total_min > current_load:  \n        candidate_off = []  \n        for i in range(n):  \n            if not must_run[i] and not must_off[i] and u[i] == 1:  \n                unit = units_info[i]  \n                a_i = unit['a_i']  \n                b_i = unit['b_i']  \n                c_i = unit['c_i']  \n                p_max_i = unit['p_max_i']  \n                if p_max_i > 0:  \n                    avg_cost = (a_i + b_i * p_max_i + c_i * p_max_i**2) / p_max_i  \n                else:  \n                    avg_cost = float('inf')  \n                candidate_off.append((i, avg_cost))  \n        candidate_off.sort(key=lambda x: x[1], reverse=True)  \n        for i, _ in candidate_off:  \n            if total_min <= current_load:  \n                break  \n            u[i] = 0  \n            total_min -= lb_list[i]  \n            total_max -= ub_list[i]  \n            lb_list[i] = 0.0  \n            ub_list[i] = 0.0  \n      \n    # Adjust for under-commitment  \n    if total_max < current_load:  \n        candidate_on = []  \n        for i in range(n):  \n            if not must_off[i] and u[i] == 0:  \n                unit = units_info[i]  \n                a_i = unit['a_i']  \n                b_i = unit['b_i']  \n                c_i = unit['c_i']  \n                s_i = unit['s_i']  \n                p_max_i = unit['p_max_i']  \n                p_start_i = unit['p_start_i']  \n                t_on_min_i = unit['t_on_min_i']  \n                curr_max = min(p_max_i, p_start_i)  \n                if t_on_min_i > 1:  \n                    min_out = unit['p_min_i']  \n                    total_energy = curr_max + (t_on_min_i - 1) * min_out  \n                    total_cost = s_i + a_i * t_on_min_i + b_i * (curr_max + (t_on_min_i - 1) * min_out) + c_i * (curr_max**2 + (t_on_min_i - 1) * min_out**2)  \n                    amort_cost = total_cost / total_energy if total_energy > 0 else float('inf')  \n                else:  \n                    total_cost = s_i + a_i + b_i * curr_max + c_i * curr_max**2  \n                    amort_cost = total_cost / curr_max if curr_max > 0 else float('inf')  \n                candidate_on.append((i, amort_cost))  \n        candidate_on.sort(key=lambda x: x[1])  \n        for i, cost_val in candidate_on:  \n            if total_max >= current_load:  \n                break  \n            u[i] = 1  \n            unit = units_info[i]  \n            lb_i = unit['p_min_i']  \n            ub_i = min(unit['p_max_i'], unit['p_start_i'])  \n            lb_list[i] = lb_i  \n            ub_list[i] = ub_i  \n            total_min += lb_i  \n            total_max += ub_i  \n      \n    # Set initial dispatch to lower bounds  \n    p = lb_list[:]  \n    total_assigned = sum(p)  \n    remaining = current_load - total_assigned  \n      \n    # Economic dispatch: incremental cost allocation  \n    if remaining > 1e-5:  \n        available_units = [i for i in range(n) if u[i] == 1 and p[i] < ub_list[i]]  \n        while available_units and remaining > 1e-5:  \n            costs = []  \n            for i in available_units:  \n                b = units_info[i]['b_i']  \n                c = units_info[i]['c_i']  \n                costs.append((2 * c * p[i] + b, i))  \n            min_cost, min_idx = min(costs, key=lambda x: x[0])  \n            headroom = ub_list[min_idx] - p[min_idx]  \n            delta = min(remaining, headroom)  \n            p[min_idx] += delta  \n            remaining -= delta  \n            if abs(p[min_idx] - ub_list[min_idx]) < 1e-5:  \n                available_units.remove(min_idx)  \n      \n    # Ensure turned-off units have zero output  \n    for i in range(n):  \n        if u[i] == 0:  \n            p[i] = 0.0  \n              \n    return np.array([u, p])  ",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "refined_rolling_uc_heuristic",
          "algorithm": "**  \n1. Classify units as must-run (violate downtime/shutdown ramp), must-off (violate downtime), or flexible. Initialize commitment states accordingly.  \n2. Compute feasible output ranges considering ramp constraints for committed units.  \n3. Handle over-generation: Turn off highest-cost flexible units if total minimum output exceeds load, ensuring sufficient capacity remains.  \n4. Handle under-commitment: Turn on flexible units by cheapest average cost (including startup) until total maximum output covers load.  \n5. Perform economic dispatch:  \n   - Set outputs to minimum feasible levels  \n   - Distribute remaining load by increasing outputs of units with lowest incremental cost, respecting ramp constraints.  \n6. Return commitment states and power outputs.  \n\n**",
          "code": "import numpy as np\n\ndef refined_rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    states = np.zeros(n_units, dtype=int)\n    outputs = np.zeros(n_units)\n    flexible_indices = []\n    \n    # Step 1: Classify units and initialize states\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                states[i] = 1  # Must-run\n            else:\n                flexible_indices.append(i)\n                states[i] = 1  # Initially keep online\n        else:  # Unit was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                states[i] = 0  # Must-off\n            else:\n                flexible_indices.append(i)\n                states[i] = 0  # Initially keep offline\n    \n    # Helper function to calculate min/max output for unit i\n    def get_output_limits(i):\n        unit = units_info[i]\n        if states[i] == 0:\n            return 0, 0\n        if unit['u_i_0'] == 0:  # Starting now\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Was online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return min_out, max_out\n    \n    # Step 2: Compute total feasible range\n    min_outputs, max_outputs = [], []\n    for i in range(n_units):\n        min_out, max_out = get_output_limits(i)\n        min_outputs.append(min_out)\n        max_outputs.append(max_out)\n    total_min = sum(min_outputs)\n    total_max = sum(max_outputs)\n    \n    # Step 3: Handle over-generation\n    if total_min > current_load:\n        # Find flexible online units with highest cost at min output\n        online_flex = [i for i in flexible_indices if states[i] == 1]\n        cost_at_min = [\n            unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i]**2 \n            for i, unit in zip(online_flex, [units_info[i] for i in online_flex])\n        ]\n        sorted_by_cost = sorted(zip(online_flex, cost_at_min), key=lambda x: x[1], reverse=True)\n        \n        # Turn off expensive units until feasible\n        for idx, _ in sorted_by_cost:\n            if total_min <= current_load and total_max >= current_load:\n                break\n            # Check if turning off this unit maintains feasibility\n            new_min = total_min - min_outputs[idx]\n            new_max = total_max - max_outputs[idx]\n            if new_max >= current_load:\n                states[idx] = 0\n                min_outputs[idx] = max_outputs[idx] = 0\n                total_min, total_max = new_min, new_max\n                flexible_indices.remove(idx)\n    \n    # Step 4: Handle under-commitment\n    if total_max < current_load:\n        # Find flexible offline units with cheapest average cost at min output\n        offline_flex = [i for i in flexible_indices if states[i] == 0]\n        avg_cost = [\n            (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n            for unit in [units_info[i] for i in offline_flex]\n        ]\n        sorted_by_avg_cost = sorted(zip(offline_flex, avg_cost), key=lambda x: x[1])\n        \n        # Turn on cheapest units until feasible\n        for idx, _ in sorted_by_avg_cost:\n            if total_max >= current_load:\n                break\n            states[idx] = 1\n            min_out, max_out = get_output_limits(idx)\n            min_outputs[idx] = min_out\n            max_outputs[idx] = max_out\n            total_min += min_out\n            total_max += max_out\n    \n    # Step 5: Economic dispatch\n    # Initialize outputs at minimum levels\n    for i in range(n_units):\n        outputs[i] = min_outputs[i] if states[i] == 1 else 0\n    remaining = current_load - total_min\n    \n    # Distribute remaining load by increasing cheapest units\n    while remaining > 0:\n        available = []\n        for i in range(n_units):\n            if states[i] == 1 and outputs[i] < max_outputs[i]:\n                marginal_cost = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                headroom = max_outputs[i] - outputs[i]\n                available.append((i, marginal_cost, headroom))\n        \n        if not available:\n            break\n        \n        # Find unit with smallest marginal cost\n        idx = min(available, key=lambda x: x[1])[0]\n        max_increase = max_outputs[idx] - outputs[idx]\n        allocation = min(remaining, max_increase)\n        outputs[idx] += allocation\n        remaining -= allocation\n    \n    return np.vstack((states, outputs))",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints.\n2. Initialize commitment states: must-run \u2192 on, must-off \u2192 off, flexible \u2192 maintain previous state.\n3. Compute effective output bounds considering ramp limits and startup/shutdown constraints.\n4. While total effective max output < load:\n   - Turn on flexible unit with smallest average cost at min output (including startup cost)\n   - Update bounds and totals\n5. While total effective min output > load:\n   - Turn off flexible unit with highest average cost at its current min output\n   - Update bounds and totals\n6. Dispatch load:\n   - Set outputs to min bounds\n   - Sort on-units by incremental cost at min output\n   - Allocate remaining load in merit order\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    # Extract parameters into lists\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    p_shut_i = [unit['p_shut_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    n = len(units_info)\n    \n    # Initialize commitment and output arrays\n    u_i = u_i_0.copy()\n    p_i = [0.0] * n\n    \n    # Step 1: Classify units\n    must_run = [False] * n\n    must_off = [False] * n\n    for i in range(n):\n        if u_i_0[i] == 1:\n            if (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i]):\n                must_run[i] = True\n                u_i[i] = 1\n        else:\n            if t_i_0[i] < 0 and -t_i_0[i] < t_off_min_i[i]:\n                must_off[i] = True\n                u_i[i] = 0\n    \n    # Compute initial bounds\n    low_bound = [0.0] * n\n    high_bound = [0.0] * n\n    for i in range(n):\n        if u_i[i] == 1:\n            if u_i_0[i] == 1:\n                low_bound[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                high_bound[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n            else:\n                low_bound[i] = p_min_i[i]\n                high_bound[i] = min(p_max_i[i], p_up_i[i], p_start_i[i])\n        else:\n            low_bound[i] = 0.0\n            high_bound[i] = 0.0\n    \n    # Current load and totals\n    current_load = load[0]\n    total_low = sum(low_bound)\n    total_high = sum(high_bound)\n    \n    # Identify flexible units\n    flexible_indices = [i for i in range(n) if not must_run[i] and not must_off[i]]\n    candidate_on = [i for i in flexible_indices if u_i[i] == 0]\n    candidate_off = [i for i in flexible_indices if u_i[i] == 1]\n    \n    # Step 4-5: Adjust commitment\n    changed = True\n    while changed:\n        changed = False\n        \n        # Undercommitted: turn on units\n        if total_high < current_load and candidate_on:\n            # Calculate average cost at min output (including startup)\n            avg_costs = []\n            for i in candidate_on:\n                if p_min_i[i] > 0:\n                    total_cost = s_i[i] + a_i[i] + b_i[i]*p_min_i[i] + c_i[i]*(p_min_i[i]**2)\n                    avg_costs.append(total_cost / p_min_i[i])\n                else:\n                    avg_costs.append(float('inf'))\n            \n            # Get candidate with min average cost\n            min_idx = np.argmin(avg_costs)\n            i_candidate = candidate_on[min_idx]\n            \n            # Update bounds and totals\n            u_i[i_candidate] = 1\n            low_bound[i_candidate] = p_min_i[i_candidate]\n            high_bound[i_candidate] = min(p_max_i[i_candidate], p_up_i[i_candidate], p_start_i[i_candidate])\n            total_low += low_bound[i_candidate]\n            total_high += high_bound[i_candidate]\n            \n            # Update candidate lists\n            candidate_on.remove(i_candidate)\n            candidate_off.append(i_candidate)\n            changed = True\n        \n        # Overcommitted: turn off units\n        if total_low > current_load and candidate_off:\n            # Calculate average cost at current min output\n            avg_costs = []\n            for i in candidate_off:\n                if low_bound[i] > 0:\n                    cost_val = a_i[i] + b_i[i]*low_bound[i] + c_i[i]*(low_bound[i]**2)\n                    avg_costs.append(cost_val / low_bound[i])\n                else:\n                    avg_costs.append(-float('inf'))\n            \n            # Get candidate with max average cost\n            max_idx = np.argmax(avg_costs)\n            i_candidate = candidate_off[max_idx]\n            \n            # Update bounds and totals\n            u_i[i_candidate] = 0\n            total_low -= low_bound[i_candidate]\n            total_high -= high_bound[i_candidate]\n            low_bound[i_candidate] = 0.0\n            high_bound[i_candidate] = 0.0\n            \n            # Update candidate lists\n            candidate_off.remove(i_candidate)\n            candidate_on.append(i_candidate)\n            changed = True\n    \n    # Step 6: Dispatch load\n    # Recompute bounds for all units\n    for i in range(n):\n        if u_i[i] == 1:\n            if u_i_0[i] == 1:\n                low_bound[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                high_bound[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n            else:\n                low_bound[i] = p_min_i[i]\n                high_bound[i] = min(p_max_i[i], p_up_i[i], p_start_i[i])\n        else:\n            low_bound[i] = 0.0\n            high_bound[i] = 0.0\n    \n    total_low = sum(low_bound)\n    gap = current_load - total_low\n    \n    # Initialize outputs\n    for i in range(n):\n        p_i[i] = low_bound[i]\n    \n    # Economic dispatch for on units\n    on_indices = [i for i in range(n) if u_i[i] == 1]\n    if on_indices:\n        # Sort by incremental cost at low bound\n        inc_costs = [2*c_i[i]*low_bound[i] + b_i[i] for i in on_indices]\n        sorted_indices = [i for _, i in sorted(zip(inc_costs, on_indices))]\n        \n        # Allocate remaining load\n        for i in sorted_indices:\n            avail = high_bound[i] - low_bound[i]\n            if avail > 0 and gap > 0:\n                add = min(avail, gap)\n                p_i[i] += add\n                gap -= add\n                if gap <= 0:\n                    break\n    \n    # Return schedules\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0392093598,
          "fitness": 0.0196695191
     },
     {
          "name": "rolling_commit_dispatch",
          "algorithm": "1. Identify must-run units: Units must remain online if violating min up-time, shutdown ramp (p_i_0 > p_shut_i), or if min output exceeds shutdown capacity (p_min_i > p_shut_i).\n2. Identify must-off units: Units failing min down-time cannot start.\n3. Initialize committed_units with must-run and non-must-off online units.\n4. Compute current capacity using ramp-constrained min/max outputs.\n5. If under-committed, start flexible offline units sorted by amortized startup cost (startup cost over min up-time plus cost at min output) until load is met.\n6. Perform constrained dispatch:\n   - Set committed units to min feasible outputs (considering ramp limits)\n   - Allocate residual load using greedy incremental cost (2\u00b7c_i\u00b7p_i + b_i)\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    must_run = []\n    must_off = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i'] or \n                unit['p_min_i'] > unit['p_shut_i']):\n                must_run.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n    \n    committed_units = must_run.copy()\n    for idx in range(num_units):\n        if units_info[idx]['u_i_0'] == 1 and idx not in must_run and idx not in must_off:\n            committed_units.append(idx)\n    \n    def min_output(unit):\n        if unit['u_i_0'] == 1:\n            return max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        return unit['p_min_i']\n    \n    def max_output(unit):\n        if unit['u_i_0'] == 1:\n            return min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = 0.0\n    total_max = 0.0\n    for idx in committed_units:\n        unit = units_info[idx]\n        total_min += min_output(unit)\n        total_max += max_output(unit)\n    \n    flexible_offline = [idx for idx in range(num_units) \n                        if idx not in committed_units and idx not in must_off]\n    \n    def cost_metric(idx):\n        unit = units_info[idx]\n        amortized_startup = unit['s_i'] / unit['t_on_min_i']\n        min_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i'] ** 2)\n        return amortized_startup + min_cost\n    \n    flexible_offline = sorted(flexible_offline, key=cost_metric)\n    \n    for idx in flexible_offline:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        committed_units.append(idx)\n        total_min += min_output(unit)\n        total_max += max_output(unit)\n    \n    lows = {}\n    highs = {}\n    for idx in committed_units:\n        unit = units_info[idx]\n        lows[idx] = min_output(unit)\n        highs[idx] = max_output(unit)\n    \n    total_low = sum(lows.values())\n    p_outputs = lows.copy()\n    residual = current_load - total_low\n    \n    if residual > 0:\n        units_headroom = [idx for idx in committed_units if p_outputs[idx] < highs[idx]]\n        while residual > 1e-5 and units_headroom:\n            min_mc = float('inf')\n            best_unit = None\n            for idx in units_headroom:\n                c_i = units_info[idx]['c_i']\n                b_i = units_info[idx]['b_i']\n                marginal = 2 * c_i * p_outputs[idx] + b_i\n                if marginal < min_mc:\n                    min_mc = marginal\n                    best_unit = idx\n            \n            headroom = min(residual, highs[best_unit] - p_outputs[best_unit])\n            p_outputs[best_unit] += headroom\n            residual -= headroom\n            \n            if abs(p_outputs[best_unit] - highs[best_unit]) < 1e-5:\n                units_headroom.remove(best_unit)\n    \n    u_out = [0] * num_units\n    p_out = [0] * num_units\n    for idx in range(num_units):\n        if idx in p_outputs:\n            u_out[idx] = 1\n            p_out[idx] = p_outputs[idx]\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0446045797,
          "fitness": 0.0223381359
     }
]