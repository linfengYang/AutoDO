[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "adaptive_dynamic_commitment",
          "algorithm": "1. Classify units into four categories based on physical constraints:\n   - Must-on: Cannot be turned off (min up-time violation risk or shutdown capacity exceeded)\n   - Must-off: Cannot be turned on (min down-time constraint)\n   - Free-on: Online units eligible for decommitment\n   - Free-off: Offline units eligible for commitment\n\n2. Compute effective min/max outputs considering ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, startup_ramp)\n\n3. Handle load allocation cases:\n   a. Over-generation: If must-on min_eff sum > load, commit only must-on at min_eff\n   b. Must-on coverage: If must-on max_eff sum > load, commit only must-on units\n   c. Capacity shortfall: Else:\n      - Initial commitment: must-on + free-on units\n      - Add free-off units by cost efficiency: (startup_cost + no_load_cost + min_output_cost) / min_output\n      - Remove non-must units by avoidable cost: (no_load_cost + min_output_cost + startup_cost if applicable) / min_output\n\n4. Hybrid dispatch:\n   - For small committed sets (\u226410 units): Use lambda iteration for precise quadratic cost optimization\n   - For larger sets: Use marginal-cost based greedy allocation:\n        \u2022 Initialize outputs at effective minimum\n        \u2022 Allocate remaining load using min-heap prioritized by marginal cost\n        \u2022 Respect individual unit capacity limits during allocation\n\n5. Set non-committed units to offline state (u_i=0, p_i=0)\n\n6. Return commitment states and power outputs\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef adaptive_dynamic_commitment(units_info, load):\n    current_load = load[0]  # Current period load only\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        # Must-on conditions: min up-time violation risk or exceeding shutdown capacity\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_on.append(i)\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Must-off condition: min down-time constraint\n        elif unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            must_off.append(i)\n            min_eff[i] = 0\n            max_eff[i] = 0\n        # Free-on units\n        elif unit['u_i_0'] == 1:\n            free_on.append(i)\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Free-off units\n        else:\n            free_off.append(i)\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Case 1: Must-on min outputs exceed load (over-generation)\n    must_on_min_sum = sum(min_eff[i] for i in must_on)\n    if must_on_min_sum >= current_load:\n        for i in must_on:\n            u[i] = 1\n            p[i] = min_eff[i]\n        return np.array([u, p])\n    \n    # Case 2: Must-on units can cover load alone\n    must_on_max_sum = sum(max_eff[i] for i in must_on)\n    if must_on_max_sum >= current_load:\n        committed = must_on.copy()\n    # Case 3: Need additional units\n    else:\n        committed = must_on + free_on\n        comm_min_sum = sum(min_eff[i] for i in committed)\n        comm_max_sum = sum(max_eff[i] for i in committed)\n        \n        # Add free-off units if capacity insufficient\n        if comm_max_sum < current_load:\n            # Efficiency metric: (startup + no-load + min-output cost)/min-output\n            eff_metrics = []\n            for i in free_off:\n                min_cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + \n                            units_info[i]['c_i'] * min_eff[i]**2)\n                metric = (units_info[i]['s_i'] + min_cost) / min_eff[i]\n                eff_metrics.append((metric, i))\n            \n            # Sort by ascending metric (cost efficiency)\n            eff_metrics.sort(key=lambda x: x[0])\n            \n            # Add most efficient units until load can be met\n            for metric, i in eff_metrics:\n                if comm_max_sum >= current_load:\n                    break\n                committed.append(i)\n                comm_min_sum += min_eff[i]\n                comm_max_sum += max_eff[i]\n        \n        # Remove non-must units if min outputs exceed load\n        if comm_min_sum > current_load:\n            avoidable_metrics = []\n            non_must = [i for i in committed if i not in must_on]\n            \n            for i in non_must:\n                min_cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + \n                            units_info[i]['c_i'] * min_eff[i]**2)\n                # Startup cost only applies to free-off\n                full_cost = min_cost + (units_info[i]['s_i'] if i in free_off else 0)\n                metric = full_cost / min_eff[i]  # Avoidable cost per MW\n                avoidable_metrics.append((metric, i))\n            \n            # Sort by descending metric (for removal priority)\n            avoidable_metrics.sort(key=lambda x: -x[0])\n            \n            # Remove highest avoidable cost units while maintaining feasibility\n            for metric, i in avoidable_metrics:\n                if comm_min_sum - min_eff[i] <= current_load:\n                    # Removal would maintain max coverage??\n                    new_max = comm_max_sum - max_eff[i]\n                    if new_max >= current_load:\n                        committed.remove(i)\n                        comm_min_sum -= min_eff[i]\n                        comm_max_sum -= max_eff[i]\n                if comm_min_sum <= current_load:\n                    break\n    \n    # Dispatch strategy selection\n    if len(committed) <= 10:\n        # Lambda iteration for small sets\n        low = min(units_info[i]['b_i'] + 2*units_info[i]['c_i']*min_eff[i] for i in committed)\n        high = max(units_info[i]['b_i'] + 2*units_info[i]['c_i']*max_eff[i] for i in committed)\n        tol = 0.1\n        \n        while (high - low) > tol:\n            lam = (low + high) / 2\n            total_power = 0\n            for i in committed:\n                if units_info[i]['c_i'] > 0:  # Quadratic unit\n                    p_i = max(min_eff[i], min(max_eff[i], (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])))\n                else:  # Linear unit\n                    p_i = max_eff[i] if lam > units_info[i]['b_i'] else min_eff[i]\n                total_power += p_i\n            \n            if total_power < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Final assignment\n        lam = (low + high) / 2\n        for i in committed:\n            if units_info[i]['c_i'] > 0:\n                p_i = max(min_eff[i], min(max_eff[i], (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])))\n            else:\n                p_i = max_eff[i] if lam > units_info[i]['b_i'] else min_eff[i]\n            p[i] = p_i\n            u[i] = 1\n    else:\n        # Greedy allocation for large sets\n        current_p = {i: min_eff[i] for i in committed}\n        residual = current_load - sum(min_eff[i] for i in committed)\n        \n        # Min-heap for marginal costs (b_i + 2*c_i*p)\n        heap = []\n        for i in committed:\n            mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p[i]\n            heapq.heappush(heap, (mc, i))\n        \n        while residual > 0 and heap:\n            mc, i = heapq.heappop(heap)\n            alloc = min(residual, max_eff[i] - current_p[i])\n            current_p[i] += alloc\n            residual -= alloc\n            \n            # Update heap if unit still has capacity\n            if current_p[i] < max_eff[i]:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p[i]\n                heapq.heappush(heap, (new_mc, i))\n        \n        for i in committed:\n            p[i] = current_p[i]\n            u[i] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0059048937,
          "gap_price_rate": 0.0080311131,
          "fitness": 0.0069680034
     },
     {
          "name": "novel_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints: for online units use max(p_min, p_prev - ramp_down) and min(p_max, p_prev + ramp_up); for free-off units use p_min and min(p_max, p_start).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, use lambda iteration to dispatch only must-on units.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by efficiency metric: (startup_cost + a_i + b_i*p_min + c_i*(p_min**2)) / p_min\n   c. If total min output exceeds load, remove non-must units by avoidable cost per MW: (a_i + b_i*p_min + c_i*(p_min**2) + (s_i if free-off)) / p_min\n   d. Dispatch via bisection-based lambda iteration respecting effective bounds\n6. Set non-committed units offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef novel_hybrid_heuristic(units_info, load):\n    current_load = load[0]\n    \n    # Define dispatch helper function\n    def dispatch_units(units, target):\n        lo, hi = -1e6, 1e6\n        n_iter = 100\n        min_sum = sum(unit['eff_min'] for unit in units)\n        max_sum = sum(unit['eff_max'] for unit in units)\n        target_clamped = max(min_sum, min(max_sum, target))\n        \n        for _ in range(n_iter):\n            lam = (lo + hi) / 2.0\n            total_p = 0.0\n            for unit in units:\n                p = (lam - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else unit['eff_max']\n                p_clamped = max(unit['eff_min'], min(unit['eff_max'], p))\n                total_p += p_clamped\n            \n            if total_p < target_clamped:\n                lo = lam\n            else:\n                hi = lam\n        \n        outputs = []\n        for unit in units:\n            p = (lam - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else unit['eff_max']\n            p_clamped = max(unit['eff_min'], min(unit['eff_max'], p))\n            outputs.append(p_clamped)\n        return outputs\n\n    # Classify units and compute effective bounds\n    units = [unit.copy() for unit in units_info]\n    must_on_indices = []\n    must_off_indices = []\n    free_on_indices = []\n    free_off_indices = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n            else:\n                free_on_indices.append(i)\n        else:\n            unit['eff_min'] = unit['p_min_i']\n            unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                free_off_indices.append(i)\n    \n    # Compute must-on totals\n    must_on_min = sum(units[i]['eff_min'] for i in must_on_indices)\n    must_on_max = sum(units[i]['eff_max'] for i in must_on_indices)\n    \n    # Case 1: Must-on min exceeds load\n    if must_on_min >= current_load:\n        u_list = [1 if i in must_on_indices else 0 for i in range(len(units))]\n        p_list = [units[i]['eff_min'] if i in must_on_indices else 0.0 for i in range(len(units))]\n        return np.array([u_list, p_list])\n    \n    # Case 2: Must-on covers load\n    if must_on_max >= current_load:\n        must_on_units = [units[i] for i in must_on_indices]\n        dispatch_out = dispatch_units(must_on_units, current_load)\n        u_list = [1 if i in must_on_indices else 0 for i in range(len(units))]\n        p_list = [dispatch_out[must_on_indices.index(i)] if i in must_on_indices else 0.0 for i in range(len(units))]\n        return np.array([u_list, p_list])\n    \n    # Case 3: Need additional units\n    committed_indices = must_on_indices + free_on_indices\n    total_min = must_on_min + sum(units[i]['eff_min'] for i in free_on_indices)\n    total_max = must_on_max + sum(units[i]['eff_max'] for i in free_on_indices)\n    \n    # Add free-off units if needed\n    if total_max < current_load:\n        free_off_candidates = []\n        for i in free_off_indices:\n            cost_at_min = units[i]['a_i'] + units[i]['b_i']*units[i]['p_min_i'] + units[i]['c_i']*(units[i]['p_min_i']**2)\n            efficiency = (units[i]['s_i'] + cost_at_min) / units[i]['p_min_i']\n            free_off_candidates.append((i, efficiency))\n        free_off_candidates.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_off_candidates:\n            committed_indices.append(idx)\n            total_max += units[idx]['eff_max']\n            total_min += units[idx]['eff_min']\n            if total_max >= current_load:\n                break\n    \n    # Remove non-must units if min too high\n    if total_min > current_load:\n        non_must = [i for i in committed_indices if i not in must_on_indices]\n        avoidable_costs = []\n        for i in non_must:\n            cost_at_min = units[i]['a_i'] + units[i]['b_i']*units[i]['p_min_i'] + units[i]['c_i']*(units[i]['p_min_i']**2)\n            if units[i]['u_i_0'] == 0:\n                cost_at_min += units[i]['s_i']\n            avoidable_per_mw = cost_at_min / units[i]['p_min_i']\n            avoidable_costs.append((i, avoidable_per_mw))\n        avoidable_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        temp_committed = set(committed_indices)\n        for i, _ in avoidable_costs:\n            new_total_min = total_min - units[i]['eff_min']\n            new_total_max = total_max - units[i]['eff_max']\n            if new_total_min <= current_load or new_total_max < current_load:\n                continue\n            temp_committed.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_min <= current_load:\n                break\n        committed_indices = list(temp_committed)\n    \n    # Dispatch committed units\n    committed_units = [units[i] for i in committed_indices]\n    dispatch_out = dispatch_units(committed_units, current_load)\n    \n    # Prepare final schedule\n    u_list = [0] * len(units)\n    p_list = [0.0] * len(units)\n    for idx, unit_idx in enumerate(committed_indices):\n        u_list[unit_idx] = 1\n        p_list[unit_idx] = dispatch_out[idx]\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0089176296,
          "fitness": 0.007173083
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot switch off due to min-up/shutdown constraints), must-off (cannot switch on due to min-down constraints), free-on (online units with switching flexibility), and free-off (offline units with switching flexibility).\n2. Compute effective min/max outputs:\n   - Online units: min_eff = max(p_min_i, p_i_0 - p_down_i), max_eff = min(p_max_i, p_i_0 + p_up_i)\n   - Free-off units: min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n   - Must-off units: min_eff = 0, max_eff = 0\n3. Handle must-on feasibility:\n   - If must-on min_eff sum > load: commit must-on at min_eff (over-generation)\n   - Else if must-on max_eff sum >= load: set committed = must-on\n   - Else: initially commit must-on + free-on. If capacity insufficient, add free-off units by ascending order of (startup_cost + cost_at_min_output)/min_output. If total min_eff > load, remove non-must units by highest avoidable_cost_per_MW while ensuring capacity feasibility.\n4. Dispatch committed units:\n   - If total min_eff > load: over-generate at min_eff\n   - Else: perform lambda-iteration (bisection) for economic dispatch, handling quadratic cost functions analytically and linear costs via thresholding\n5. Set non-committed units to offline (u_i=0, p_i=0) and return schedule\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    n = len(units_info)\n    units = [u.copy() for u in units_info]\n    for i, u in enumerate(units):\n        u['index'] = i\n    \n    # Step 1: Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            off_periods = -unit['t_i_0']  # Convert to positive offline count\n            if off_periods < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # Step 2: Compute effective min/max outputs\n    for unit in units:\n        if unit in must_off:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n        elif unit['u_i_0'] == 1:  # Online units\n            min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_eff'] = min_eff\n            unit['max_eff'] = max_eff\n        else:  # Free-off units\n            min_eff = unit['p_min_i']\n            max_eff = min(unit['p_max_i'], unit['p_start_i'])\n            unit['min_eff'] = min_eff\n            unit['max_eff'] = max_eff\n    \n    load_current = load[0]  # Current load to allocate\n    committed = []\n    \n    # Step 3.1: Handle must-on feasibility\n    total_min_must = sum(u['min_eff'] for u in must_on)\n    total_max_must = sum(u['max_eff'] for u in must_on)\n    \n    if total_min_must > load_current:\n        committed = must_on  # Over-generation case\n    elif total_max_must >= load_current:\n        committed = must_on  # Dispatch only must-on\n    else:\n        # Start with must-on + free-on\n        committed = must_on + free_on\n        total_min_comm = total_min_must + sum(u['min_eff'] for u in free_on)\n        total_max_comm = total_max_must + sum(u['max_eff'] for u in free_on)\n        \n        # Add free-off units if capacity insufficient\n        if total_max_comm < load_current:\n            # Sort by cost efficiency: (startup + cost_at_min_output)/min_output\n            free_off.sort(key=lambda u: \n                (u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff'] \n                if u['min_eff'] > 0 else float('inf'))\n            for unit in free_off:\n                if total_max_comm >= load_current:\n                    break\n                committed.append(unit)\n                total_min_comm += unit['min_eff']\n                total_max_comm += unit['max_eff']\n        \n        # Remove non-must units if minimum outputs exceed load\n        if total_min_comm > load_current:\n            non_must = [u for u in committed if u not in must_on]\n            # Compute avoidable cost per MW\n            for u in non_must:\n                if u in free_off:\n                    cost = u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2\n                else:  # free_on\n                    cost = u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2\n                u['avoidable_per_mw'] = cost / u['min_eff'] if u['min_eff'] > 0 else float('inf')\n            \n            # Sort descending by avoidable_per_mw\n            non_must.sort(key=lambda u: u['avoidable_per_mw'], reverse=True)\n            \n            # Remove units while preserving feasibility\n            removed = []\n            for unit in non_must:\n                if total_min_comm - unit['min_eff'] <= load_current and total_max_comm - unit['max_eff'] >= load_current:\n                    committed.remove(unit)\n                    total_min_comm -= unit['min_eff']\n                    total_max_comm -= unit['max_eff']\n                    removed.append(unit)\n                    if total_min_comm <= load_current:\n                        break\n    \n    # Dispatch preparation\n    u_out = [0] * n\n    p_out = [0] * n\n    total_min_comm = sum(u['min_eff'] for u in committed)\n    \n    if total_min_comm > load_current or len(committed) == 0:\n        # Over-generation or no units\n        for unit in committed:\n            p_out[unit['index']] = unit['min_eff']\n            u_out[unit['index']] = 1\n    else:\n        # Step 4: Lambda-iteration dispatch\n        low_lambda = float('inf')\n        high_lambda = -float('inf')\n        \n        # Find initial lambda bounds\n        for u in committed:\n            if u['c_i'] == 0:  # Linear unit\n                mc = u['b_i']\n            else:  # Quadratic unit\n                mc_min = 2 * u['c_i'] * u['min_eff'] + u['b_i']\n                mc_max = 2 * u['c_i'] * u['max_eff'] + u['b_i']\n                mc = max(mc_min, mc_max)\n            high_lambda = max(high_lambda, mc)\n            low_lambda = min(low_lambda, u['b_i'])  # Linear cost or marginal at min\n        \n        # Lambda bisection algorithm\n        tolerance = 1e-5\n        for _ in range(100):  # Max iterations\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0\n            for unit in committed:\n                if unit['c_i'] == 0:  # Linear\n                    p = unit['max_eff'] if unit['b_i'] <= mid_lambda else unit['min_eff']\n                else:  # Quadratic\n                    p_unbound = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p = max(unit['min_eff'], min(unit['max_eff'], p_unbound))\n                unit['p_temp'] = p\n                total_power += p\n            \n            if abs(total_power - load_current) < tolerance:\n                break\n            elif total_power < load_current:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Assign final dispatch values\n        for unit in committed:\n            p_out[unit['index']] = unit['p_temp']\n            u_out[unit['index']] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0089176297,
          "fitness": 0.0071730836
     },
     {
          "name": "optimized_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on with feasible startup constraints).\n2. Compute effective min/max outputs for online units considering ramp constraints and startup limits for free-off units.\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, commit only must-on units and use lambda iteration for dispatch.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by cost-efficiency if capacity is insufficient\n   c. Remove non-must units by avoidable cost per MW if min output exceeds load while maintaining feasibility\n6. Dispatch load using lambda iteration on committed units to minimize cost under constraints\n7. Set non-committed units to offline state (u=0, p=0)\n",
          "code": "import numpy as np\nimport heapq\n\ndef optimized_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u0 == 1 and ((t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif u0 == 0 and t0 > -unit['t_off_min_i']:  # t0 is negative for offline\n            must_off.append(i)\n        # Free-on\n        elif u0 == 1:\n            free_on.append(i)\n        # Free-off (with startup feasibility)\n        elif u0 == 0 and unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n            free_off.append(i)\n    \n    # Prepare unit dictionaries for processing\n    for i, unit in enumerate(units_info):\n        # Compute effective min/max for all relevant units\n        if i in must_on or i in free_on:\n            unit['min_eff'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            unit['min_eff'] = unit['p_min_i']\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n    \n    # Step 3: Check if must-on can cover alone (over-generation)\n    must_on_min_sum = sum(units_info[i]['min_eff'] for i in must_on)\n    must_on_max_sum = sum(units_info[i]['max_eff'] for i in must_on)\n    \n    if must_on_min_sum >= current_load:\n        committed = must_on\n        for i in committed:\n            units_info[i]['p_i'] = units_info[i]['min_eff']\n            units_info[i]['u_i'] = 1\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 4: Must-on coverage\n    elif must_on_max_sum >= current_load:\n        committed = must_on\n        dispatch_with_lambda(units_info, committed, current_load)\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 5: General case\n    else:\n        committed = must_on + free_on\n        total_min = sum(units_info[i]['min_eff'] for i in committed)\n        total_max = sum(units_info[i]['max_eff'] for i in committed)\n        \n        # Step 5b: Add free-off units if needed\n        if total_max < current_load and free_off:\n            # Calculate cost efficiency: (startup + fixed + variable) / min_output\n            cost_efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                total_cost = unit['s_i'] + cost_at_min\n                cost_efficiency.append((total_cost / min_eff, i))\n            \n            # Sort by cost efficiency (lowest first)\n            cost_efficiency.sort(key=lambda x: x[0])\n            \n            # Add units until capacity meets load\n            for _, i in cost_efficiency:\n                if total_max >= current_load:\n                    break\n                unit = units_info[i]\n                committed.append(i)\n                total_min += unit['min_eff']\n                total_max += unit['max_eff']\n        \n        # Step 5c: Remove non-must units if over-committed\n        if total_min > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            \n            # Calculate avoidable cost per MW (higher is better to remove)\n            avoidable_costs = []\n            for i in non_must:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                \n                if i in free_off:  # Can avoid startup cost\n                    avoidable_cost = unit['s_i'] + cost_at_min\n                else:  # Free-on units avoid only fuel cost\n                    avoidable_cost = cost_at_min\n                \n                avoidable_costs.append((avoidable_cost / min_eff, i))\n            \n            # Sort by avoidable cost per MW (highest first)\n            avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n            \n            # Try removing units starting with highest avoidable cost\n            for cost_per_mw, i in avoidable_costs:\n                unit = units_info[i]\n                new_total_max = total_max - unit['max_eff']\n                # Only remove if capacity remains sufficient\n                if new_total_max >= current_load:\n                    committed.remove(i)\n                    total_min -= unit['min_eff']\n                    total_max = new_total_max\n                if total_min <= current_load:\n                    break\n        \n        # Step 6: Dispatch with lambda iteration\n        dispatch_with_lambda(units_info, committed, current_load)\n        \n        # Set uncommitted units to offline\n        for i in range(num_units):\n            if i not in committed:\n                units_info[i]['u_i'] = 0\n                units_info[i]['p_i'] = 0\n        \n        return prepare_output(units_info)\n\ndef dispatch_with_lambda(units, committed, load):\n    if not committed:\n        return\n    \n    # Get effective min/max sum\n    total_min = sum(units[i]['min_eff'] for i in committed)\n    total_max = sum(units[i]['max_eff'] for i in committed)\n    \n    # Case 1: Over-generation (output at min_eff)\n    if total_min >= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['min_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 2: Under-generation (output at max_eff)\n    if total_max <= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['max_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 3: Lambda iteration for exact dispatch\n    # Initialize lambda bounds\n    low = min(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['min_eff'] for i in committed)\n    high = max(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['max_eff'] for i in committed)\n    tol = 0.1  # Tolerance for convergence (MW)\n    \n    # Binary search for optimal lambda\n    while high - low > 1e-6:\n        mid = (low + high) / 2\n        total_output = 0\n        \n        # Calculate outputs at current lambda\n        for i in committed:\n            unit = units[i]\n            # Unconstrained output\n            p = (mid - unit['b_i']) / (2 * unit['c_i'])\n            # Apply constraints\n            p = max(unit['min_eff'], min(p, unit['max_eff']))\n            total_output += p\n        \n        # Adjust lambda based on total output\n        if total_output < load:\n            low = mid\n        else:\n            high = mid\n    \n    # Set final outputs\n    total_output = 0\n    for i in committed:\n        unit = units[i]\n        p = (low - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['min_eff'], min(p, unit['max_eff']))\n        unit['p_i'] = p\n        unit['u_i'] = 1\n        total_output += p\n\ndef prepare_output(units_info):\n    u_i = [unit['u_i'] for unit in units_info]\n    p_i = [unit['p_i'] for unit in units_info]\n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.0054285791,
          "gap_price_rate": 0.0089176009,
          "fitness": 0.00717309
     },
     {
          "name": "enhanced_hybrid_heuristic",
          "algorithm": "**\n1. Classify units into:\n   - Must-on: Units that cannot be turned off due to minimum up-time violations (`t_i_0 < t_on_min_i`) or shutdown ramp constraints (`p_i_0 > p_shut_i`).\n   - Must-off: Units that cannot be turned on due to minimum down-time violations (`-t_i_0 < t_off_min_i`).\n   - Free-on: Online units that can be turned off.\n   - Free-off: Offline units that can be turned on.\n2. Compute effective min/max outputs:\n   - Online units: `eff_min = max(p_min, p_prev - ramp_down)`, `eff_max = min(p_max, p_prev + ramp_up)`.\n   - Free-off units: `eff_min = p_min`, `eff_max = min(p_max, startup_ramp)`.\n   - Must-off units: `eff_min = 0`, `eff_max = 0`.\n3. Handle cases based on must-on units:\n   - If `sum(must_on_eff_min) > load`: \n     - Commit only must-on units at their `eff_min` (over-generation).\n   - Else if `sum(must_on_eff_max) >= load`:\n     - Commit only must-on units and dispatch load using lambda iteration.\n4. For other cases:\n   - Initially commit must-on and free-on units.\n   - If total max output < load:\n     - Add free-off units sorted by cost efficiency: `(startup_cost + no_load_cost + cost_at_min) / min_output`.\n   - If total min output > load:\n     - Remove non-must units sorted by avoidable cost per MW: `(no_load_cost + cost_at_min + (startup_cost if free-off)) / min_output`).\n5. Dispatch load among committed units:\n   - Use lambda iteration (bisection) respecting effective min/max bounds.\n   - For linear cost units (`c_i=0`), use marginal-cost-based binding.\n   - Apply greedy adjustment to eliminate any residual load mismatch.\n6. Set non-committed units to offline (u_i=0, p_i=0).\n\n**",
          "code": "import numpy as np\n\ndef enhanced_hybrid_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n\n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 2: Compute effective min/max outputs\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in range(n_units):\n        unit = units_info[i]\n        if i in must_on or i in free_on:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            eff_min[i] = 0.0\n            eff_max[i] = 0.0\n\n    total_must_on_min = np.sum(eff_min[must_on])\n    total_must_on_max = np.sum(eff_max[must_on])\n    committed = []\n\n    # Step 3: Handle must-on cases\n    if total_must_on_min > current_load:\n        # Over-generation: commit only must-on at min output\n        committed = must_on\n    elif total_must_on_max >= current_load:\n        # Dispatch only must-on units\n        committed = must_on\n    else:\n        # Step 4: Commit must-on and free-on initially\n        committed = must_on + free_on\n        total_max = total_must_on_max + np.sum(eff_max[free_on])\n        \n        # Add free-off units if needed\n        if total_max < current_load:\n            cost_efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * eff_min[i]**2\n                efficiency = (unit['s_i'] + cost_at_min) / eff_min[i]\n                cost_efficiency.append((efficiency, i))\n            cost_efficiency.sort(key=lambda x: x[0])\n            \n            for eff, i in cost_efficiency:\n                committed.append(i)\n                total_max += eff_max[i]\n                if total_max >= current_load:\n                    break\n        \n        # Remove non-must units if min output exceeds load\n        total_min_committed = np.sum(eff_min[committed])\n        if total_min_committed > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            avoidable_cost = []\n            for i in non_must:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * eff_min[i]**2\n                if i in free_off:\n                    avoidable = (unit['s_i'] + cost_at_min) / eff_min[i]\n                else:\n                    avoidable = cost_at_min / eff_min[i]\n                avoidable_cost.append((avoidable, i))\n            avoidable_cost.sort(key=lambda x: x[0], reverse=True)\n            \n            for cost_val, i in avoidable_cost:\n                new_total_min = total_min_committed - eff_min[i]\n                new_total_max = total_max - eff_max[i]\n                if new_total_max >= current_load:\n                    committed.remove(i)\n                    total_min_committed = new_total_min\n                    total_max = new_total_max\n                    if total_min_committed <= current_load:\n                        break\n    \n    # Step 5: Dispatch using lambda iteration\n    u_vector = np.zeros(n_units)\n    p_vector = np.zeros(n_units)\n    \n    if not committed:\n        return np.array([u_vector, p_vector])\n    \n    # Extract parameters for committed units\n    a_vals = []\n    b_vals = []\n    c_vals = []\n    min_vals = []\n    max_vals = []\n    current_eff_min = []\n    current_eff_max = []\n    for i in committed:\n        unit = units_info[i]\n        a_vals.append(unit['a_i'])\n        b_vals.append(unit['b_i'])\n        c_vals.append(unit['c_i'])\n        current_eff_min.append(eff_min[i])\n        current_eff_max.append(eff_max[i])\n    \n    # Lambda iteration\n    low_lambda = -1e7\n    high_lambda = 1e7\n    tol = 1e-4\n    max_iter = 100\n    iter_count = 0\n    total_min = np.sum(current_eff_min)\n    total_max = np.sum(current_eff_max)\n    \n    if abs(total_min - current_load) < tol:\n        p_committed = current_eff_min\n    elif abs(total_max - current_load) < tol:\n        p_committed = current_eff_max\n    else:\n        n = len(committed)\n        p_committed = current_eff_min.copy()\n        while iter_count < max_iter and high_lambda - low_lambda > tol:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0.0\n            for j in range(n):\n                if c_vals[j] == 0:  # Linear cost\n                    if mid_lambda > b_vals[j]:\n                        p_committed[j] = current_eff_max[j]\n                    else:\n                        p_committed[j] = current_eff_min[j]\n                else:  # Quadratic cost\n                    p_ideal = (mid_lambda - b_vals[j]) / (2 * c_vals[j])\n                    p_committed[j] = max(current_eff_min[j], min(p_ideal, current_eff_max[j]))\n                total_power += p_committed[j]\n            \n            if total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            iter_count += 1\n        \n        # Greedy adjustment for any remaining mismatch\n        total_power = np.sum(p_committed)\n        deficit = current_load - total_power\n        tol_adj = 1e-2\n        if abs(deficit) > tol_adj:\n            if deficit > 0:  # Need to increase output\n                adjustable = []\n                for j in range(n):\n                    if p_committed[j] < current_eff_max[j] - tol_adj:\n                        if c_vals[j] == 0:\n                            marginal_cost = b_vals[j]\n                        else:\n                            marginal_cost = b_vals[j] + 2 * c_vals[j] * p_committed[j]\n                        adjustable.append((marginal_cost, j, current_eff_max[j] - p_committed[j]))\n                adjustable.sort(key=lambda x: x[0])\n                \n                for mc, j, headroom in adjustable:\n                    if deficit <= headroom:\n                        p_committed[j] += deficit\n                        break\n                    else:\n                        p_committed[j] = current_eff_max[j]\n                        deficit -= headroom\n            else:  # Need to decrease output\n                deficit = -deficit\n                adjustable = []\n                for j in range(n):\n                    if p_committed[j] > current_eff_min[j] + tol_adj:\n                        if c_vals[j] == 0:\n                            marginal_cost = b_vals[j]\n                        else:\n                            marginal_cost = b_vals[j] + 2 * c_vals[j] * p_committed[j]\n                        adjustable.append((marginal_cost, j, p_committed[j] - current_eff_min[j]))\n                adjustable.sort(key=lambda x: x[0], reverse=True)\n                \n                for mc, j, headroom in adjustable:\n                    if deficit <= headroom:\n                        p_committed[j] -= deficit\n                        break\n                    else:\n                        p_committed[j] = current_eff_min[j]\n                        deficit -= headroom\n    \n    # Set commitment and output for committed units\n    for idx, i in enumerate(committed):\n        u_vector[i] = 1\n        p_vector[i] = p_committed[idx]\n    \n    return np.array([u_vector, p_vector])",
          "from": "crossover",
          "gap_power_rate": 0.0054291016,
          "gap_price_rate": 0.0089174966,
          "fitness": 0.0071732991
     },
     {
          "name": "enhanced_lambda_commitment",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on) with specific feasibility checks.\n2. Compute effective min/max outputs using ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, p_start)\n3. If must-on min output \u2265 load: commit must-on at min_eff\n4. Else if must-on max output \u2265 load: commit must-on and dispatch via lambda iteration\n5. Else:\n   a. Commit must-on + free-on units\n   b. If total max < load: add free-off units sorted by startup cost efficiency\n   c. If total min > load: remove non-must units by highest avoidable cost per MW\n6. Dispatch load using lambda iteration on committed units\n7. Set non-committed units to offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_lambda_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedule_u = np.zeros(num_units)\n    schedule_p = np.zeros(num_units)\n    committed_indices = []\n    min_eff = []\n    max_eff = []\n    unit_categories = {\n        'must_on': [], \n        'must_off': [],\n        'free_on': [],\n        'free_off': []\n    }\n\n    # Classify units and compute effective limits\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        # Must-on condition\n        must_on_cond = (u_i_0 == 1) and (\n            t_i_0 < unit['t_on_min_i'] or \n            p_i_0 > unit['p_shut_i']\n        )\n        \n        # Must-off condition\n        must_off_cond = (u_i_0 == 0) and (abs(t_i_0) < unit['t_off_min_i'])\n        \n        # Free-on condition\n        free_on_cond = (u_i_0 == 1) and not must_on_cond and (p_i_0 <= unit['p_shut_i'])\n        \n        # Free-off condition\n        free_off_cond = (u_i_0 == 0) and not must_off_cond and (unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']))\n        \n        if must_on_cond:\n            unit_categories['must_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif must_off_cond:\n            unit_categories['must_off'].append(idx)\n            min_eff.append(0)\n            max_eff.append(0)\n        elif free_on_cond:\n            unit_categories['free_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif free_off_cond:\n            unit_categories['free_off'].append(idx)\n            min_eff_val = unit['p_min_i']\n            max_eff_val = min(unit['p_max_i'], unit['p_start_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        else:\n            min_eff.append(0)\n            max_eff.append(0)\n\n    # Initialize committed set\n    committed_set = unit_categories['must_on'][:]\n    committed_set.sort()\n\n    # Case 1: Must-on min output covers load\n    min_total = sum(min_eff[i] for i in unit_categories['must_on'])\n    if min_total >= current_load:\n        for idx in unit_categories['must_on']:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n        return np.vstack((schedule_u, schedule_p))\n\n    # Case 2: Must-on max output covers load\n    max_total = sum(max_eff[i] for i in unit_categories['must_on'])\n    if max_total >= current_load:\n        committed_set = unit_categories['must_on']\n    else:\n        # Step 5a: Commit must-on + free-on\n        committed_set = list(set(unit_categories['must_on'] + unit_categories['free_on']))\n        committed_set.sort()\n        \n        # Calculate current capacity\n        max_total = sum(max_eff[i] for i in committed_set)\n        \n        # Step 5b: Add free-off units by cost efficiency\n        if max_total < current_load:\n            free_off_costs = []\n            for idx in unit_categories['free_off']:\n                unit = units_info[idx]\n                startup_cost = unit['s_i']\n                min_cost = (unit['a_i'] + unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                cost_per_mw = (startup_cost + min_cost) / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                free_off_costs.append((cost_per_mw, idx))\n            \n            free_off_costs.sort(key=lambda x: x[0])\n            \n            for cost_per_mw, idx in free_off_costs:\n                if max_total >= current_load:\n                    break\n                committed_set.append(idx)\n                committed_set.sort()\n                max_total += max_eff[idx]\n        \n        # Step 5c: Remove non-must units if min output exceeds load\n        min_total = sum(min_eff[i] for i in committed_set)\n        if min_total > current_load:\n            non_must_units = [i for i in committed_set if i not in unit_categories['must_on']]\n            avoidable_costs = []\n            for idx in non_must_units:\n                unit = units_info[idx]\n                min_cost = (unit['a_i'] + \n                           unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                if units_info[idx]['u_i_0'] == 0:\n                    min_cost += unit['s_i']\n                cost_per_mw = min_cost / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                avoidable_costs.append((cost_per_mw, idx))\n            \n            avoidable_costs.sort(key=lambda x: -x[0])\n            \n            for cost_per_mw, idx in avoidable_costs:\n                if min_total - min_eff[idx] <= current_load:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n                else:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n\n    # Dispatch using lambda iteration\n    min_total = sum(min_eff[i] for i in committed_set)\n    max_total = sum(max_eff[i] for i in committed_set)\n    \n    if min_total >= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n    elif max_total <= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = max_eff[idx]\n    else:\n        # Lambda iteration setup\n        low, high = float('inf'), -float('inf')\n        b = [units_info[i]['b_i'] for i in committed_set]\n        c = [units_info[i]['c_i'] for i in committed_set]\n        mc_min = [2 * c[i] * min_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        mc_max = [2 * c[i] * max_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        \n        low = min(mc_min)\n        high = max(mc_max)\n        \n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_set):\n                p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                p_val = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                for i, idx in enumerate(committed_set):\n                    p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                    schedule_p[idx] = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                    schedule_u[idx] = 1\n                break\n            elif total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        else:  # Fallback to min_eff if lambda iteration fails\n            for idx in committed_set:\n                schedule_p[idx] = min_eff[idx]\n                schedule_u[idx] = 1\n\n    return np.vstack((schedule_u, schedule_p))",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091096178,
          "fitness": 0.0072690778
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints: for online units, effective min is max(p_min, p_prev - ramp_down) and max is min(p_max, p_prev + ramp_up); for free-off units, min is p_min and max is min(p_max, startup_ramp).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units' max output covers load, perform economic dispatch (lambda iteration) on must-on units to meet load.\n5. Else:\n   a. Commit must-on and free-on units initially.\n   b. If total max < load, add free-off units sorted by efficiency: (startup_cost + no_load_cost + cost_at_min_output) / min_output.\n   c. If total min > load, remove non-must units (free-on and free-off) sorted by avoidable cost per MW: (no_load_cost + variable_cost_at_min + (startup_cost if free-off)) / min_output.\n6. Perform economic dispatch via lambda iteration on committed units to minimize production cost while meeting load.\n7. Set non-committed units to offline state (u=0, p=0).\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    categories = []\n    min_eff = []\n    max_eff = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < min_up or p_i0 > p_shut:\n                category = 'must-on'\n            else:\n                category = 'free-on'\n            min_eff_i = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_eff_i = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if t_i0 > -min_down:\n                category = 'must-off'\n                min_eff_i = 0\n                max_eff_i = 0\n            else:\n                category = 'free-off'\n                min_eff_i = unit['p_min_i']\n                max_eff_i = min(unit['p_max_i'], unit['p_start_i'])\n        categories.append(category)\n        min_eff.append(min_eff_i)\n        max_eff.append(max_eff_i)\n    \n    must_on_indices = [i for i, cat in enumerate(categories) if cat == 'must-on']\n    free_on_indices = [i for i, cat in enumerate(categories) if cat == 'free-on']\n    free_off_indices = [i for i, cat in enumerate(categories) if cat == 'free-off']\n    \n    total_must_on_min = sum(min_eff[i] for i in must_on_indices)\n    if total_must_on_min >= current_load:\n        for i in must_on_indices:\n            u[i] = 1\n            p[i] = min_eff[i]\n        return np.array([u, p])\n    \n    total_must_on_max = sum(max_eff[i] for i in must_on_indices)\n    if total_must_on_max >= current_load:\n        min_eff_committed = [min_eff[i] for i in must_on_indices]\n        max_eff_committed = [max_eff[i] for i in must_on_indices]\n        b_list = [units_info[i]['b_i'] for i in must_on_indices]\n        c_list = [units_info[i]['c_i'] for i in must_on_indices]\n        p_committed = economic_dispatch(min_eff_committed, max_eff_committed, current_load, b_list, c_list)\n        for idx, unit_idx in enumerate(must_on_indices):\n            u[unit_idx] = 1\n            p[unit_idx] = p_committed[idx]\n        return np.array([u, p])\n    \n    committed_set = must_on_indices + free_on_indices\n    total_min_committed = sum(min_eff[i] for i in committed_set)\n    total_max_committed = sum(max_eff[i] for i in committed_set)\n    \n    if total_max_committed < current_load:\n        eff_vals = []\n        for i in free_off_indices:\n            unit = units_info[i]\n            cost_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            if categories[i] == 'free-off':\n                cost_min += unit['s_i']\n            eff_val = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            eff_vals.append((eff_val, i))\n        eff_vals.sort(key=lambda x: x[0])\n        \n        for eff_val, i in eff_vals:\n            committed_set.append(i)\n            total_max_committed += max_eff[i]\n            total_min_committed += min_eff[i]\n            if total_max_committed >= current_load:\n                break\n    \n    if total_min_committed > current_load:\n        non_must_units = [i for i in committed_set if categories[i] in ['free-on', 'free-off']]\n        avoidable_vals = []\n        for i in non_must_units:\n            unit = units_info[i]\n            cost_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            if categories[i] == 'free-off':\n                cost_min += unit['s_i']\n            avoidable_per_mw = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            avoidable_vals.append((avoidable_per_mw, i))\n        avoidable_vals.sort(key=lambda x: x[0], reverse=True)\n        \n        for avoidable_per_mw, i in avoidable_vals:\n            new_min = total_min_committed - min_eff[i]\n            new_max = total_max_committed - max_eff[i]\n            if new_max >= current_load:\n                committed_set.remove(i)\n                total_min_committed = new_min\n                total_max_committed = new_max\n                if total_min_committed <= current_load:\n                    break\n    \n    min_eff_committed = [min_eff[i] for i in committed_set]\n    max_eff_committed = [max_eff[i] for i in committed_set]\n    b_list = [units_info[i]['b_i'] for i in committed_set]\n    c_list = [units_info[i]['c_i'] for i in committed_set]\n    p_committed = economic_dispatch(min_eff_committed, max_eff_committed, current_load, b_list, c_list)\n    \n    for idx, unit_idx in enumerate(committed_set):\n        u[unit_idx] = 1\n        p[unit_idx] = p_committed[idx]\n    \n    return np.array([u, p])\n\ndef economic_dispatch(min_eff_list, max_eff_list, load, b_list, c_list):\n    n = len(min_eff_list)\n    if n == 0:\n        return []\n    total_min = sum(min_eff_list)\n    total_max = sum(max_eff_list)\n    if load <= total_min:\n        return min_eff_list\n    if load >= total_max:\n        return max_eff_list\n        \n    min_mc = [b_list[i] + 2 * c_list[i] * min_eff_list[i] for i in range(n)]\n    max_mc = [b_list[i] + 2 * c_list[i] * max_eff_list[i] for i in range(n)]\n    low = min(min_mc)\n    high = max(max_mc)\n    tol = 0.001\n    max_iter = 1000\n    p_vals = min_eff_list[:]\n    \n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        total_p = 0.0\n        for i in range(n):\n            if c_list[i] == 0:\n                p_ideal = max_eff_list[i] if mid > b_list[i] else min_eff_list[i]\n            else:\n                p_ideal = (mid - b_list[i]) / (2 * c_list[i])\n            p_i = max(min_eff_list[i], min(max_eff_list[i], p_ideal))\n            p_vals[i] = p_i\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        if total_p < load:\n            low = mid\n        else:\n            high = mid\n    \n    return p_vals",
          "from": "crossover",
          "gap_power_rate": 0.0054286422,
          "gap_price_rate": 0.0091096435,
          "fitness": 0.0072691429
     },
     {
          "name": "rolling_commitment",
          "algorithm": "1. Classify units into must-on (if online and violating min-up/shutdown constraints), must-off (if offline and violating min-down time), free-on (online without constraints), and free-off (offline without constraints).\n2. Compute effective min/max outputs with ramp constraints: online units consider ramp limits, free-off units use startup ramp limits.\n3. If must-on min output exceeds current load:\n   - Commit only must-on units at their min effective outputs\n4. Else if must-on max output covers load:\n   - Commit only must-on units\n   - Dispatch load among them via lambda iteration\n5. Else:\n   a. Initially commit must-on and free-on units\n   b. Compute efficiency metric for free-off units as (amortized startup cost + no-load cost) / min output and add most efficient units until generation capacity meets load\n   c. If total min output exceeds load, remove non-must units with highest avoidable cost per MW while maintaining generation feasibility\n6. Perform economic dispatch via lambda iteration on final committed units\n7. Set non-committed units to offline (0 output)\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    schedule_u = np.zeros(n_units)\n    schedule_p = np.zeros(n_units)\n    \n    if n_units == 0:\n        return np.array([schedule_u, schedule_p])\n    \n    current_load = load[0]\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units and compute effective limits\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:  # Online\n            min_eff[i] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            \n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if abs(t_i_0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Reset must_off limits\n    for i in must_off:\n        min_eff[i] = 0\n        max_eff[i] = 0\n    \n    # Step 3: Must-on min exceeds load\n    must_on_min_sum = np.sum(min_eff[must_on])\n    must_on_max_sum = np.sum(max_eff[must_on])\n    \n    if must_on_min_sum >= current_load:\n        committed = set(must_on)\n        for i in committed:\n            schedule_u[i] = 1\n            schedule_p[i] = min_eff[i]\n        return np.array([schedule_u, schedule_p])\n    \n    # Step 4: Must-on covers load\n    elif must_on_max_sum >= current_load:\n        committed = set(must_on)\n        dispatch_units = []\n        for i in committed:\n            dispatch_units.append({\n                'b': units_info[i]['b_i'],\n                'c': units_info[i]['c_i'],\n                'min_eff': min_eff[i],\n                'max_eff': max_eff[i]\n            })\n        dispatches = dispatch_ed(dispatch_units, current_load)\n        for idx, i in enumerate(committed):\n            schedule_u[i] = 1\n            schedule_p[i] = dispatches[idx]\n        return np.array([schedule_u, schedule_p])\n    \n    # Step 5: General case\n    committed = set(must_on + free_on)\n    total_min = must_on_min_sum + np.sum(min_eff[free_on])\n    total_max = must_on_max_sum + np.sum(max_eff[free_on])\n    \n    # Add free-off units until capacity meets demand\n    efficiencies = []\n    for i in free_off:\n        a = units_info[i]['a_i']\n        s = units_info[i]['s_i']\n        min_up = units_info[i]['t_on_min_i']\n        amortized_startup = s / min_up\n        cost_at_min = a + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2\n        efficiencies.append((amortized_startup + cost_at_min) / min_eff[i])\n    sorted_free_off = [i for _, i in sorted(zip(efficiencies, free_off), key=lambda x: x[0])]\n    \n    for i in sorted_free_off:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    # Remove non-must units if min output exceeds load\n    if total_min > current_load:\n        avoidable_costs = []\n        non_must = list(committed - set(must_on))\n        for i in non_must:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            min_cost = a + b * min_eff[i] + c * min_eff[i] ** 2\n            if i in free_off:\n                min_cost += unit['s_i']\n            avoidable_costs.append(min_cost / min_eff[i])\n        \n        sorted_remove = [i for _, i in sorted(zip(avoidable_costs, non_must), reverse=True)]\n        for i in sorted_remove:\n            if i not in committed:\n                continue\n            new_min = total_min - min_eff[i]\n            new_max = total_max - max_eff[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed.remove(i)\n                total_min = new_min\n                total_max = new_max\n            if total_min <= current_load:\n                break\n    \n    # Dispatch using lambda iteration\n    dispatch_units = []\n    comm_list = list(committed)\n    for i in comm_list:\n        dispatch_units.append({\n            'b': units_info[i]['b_i'],\n            'c': units_info[i]['c_i'],\n            'min_eff': min_eff[i],\n            'max_eff': max_eff[i]\n        })\n    dispatches = dispatch_ed(dispatch_units, current_load)\n    \n    for idx, i in enumerate(comm_list):\n        schedule_u[i] = 1\n        schedule_p[i] = dispatches[idx]\n    \n    return np.array([schedule_u, schedule_p])\n\ndef dispatch_ed(units, load):\n    tol = 0.01\n    min_sum = sum(unit['min_eff'] for unit in units)\n    max_sum = sum(unit['max_eff'] for unit in units)\n    \n    if load <= min_sum:\n        return [unit['min_eff'] for unit in units]\n    if load >= max_sum:\n        return [unit['max_eff'] for unit in units]\n    \n    low = min(unit['b'] + 2 * unit['c'] * unit['min_eff'] for unit in units) - 1\n    high = max(unit['b'] + 2 * unit['c'] * unit['max_eff'] for unit in units) + 1\n    \n    iter_count = 0\n    while high - low > tol and iter_count < 100:\n        lam = (low + high) / 2\n        p_sum = 0\n        for unit in units:\n            if unit['c'] == 0:\n                p = unit['max_eff'] if lam >= unit['b'] else unit['min_eff']\n            else:\n                p_val = (lam - unit['b']) / (2 * unit['c'])\n                p = max(unit['min_eff'], min(p_val, unit['max_eff']))\n            p_sum += p\n        \n        if p_sum < load:\n            low = lam\n        else:\n            high = lam\n        iter_count += 1\n    \n    # Final assignment with adjustment\n    lam = (low + high) / 2\n    outputs = []\n    for unit in units:\n        if unit['c'] == 0:\n            p = unit['max_eff'] if lam >= unit['b'] else unit['min_eff']\n        else:\n            p_val = (lam - unit['b']) / (2 * unit['c'])\n            p = max(unit['min_eff'], min(p_val, unit['max_eff']))\n        outputs.append(p)\n    \n    # Residual adjustment\n    residual = load - sum(outputs)\n    if residual > 0:\n        mcs = []\n        for i, unit in enumerate(units):\n            mc = unit['b'] + 2 * unit['c'] * outputs[i]\n            room = unit['max_eff'] - outputs[i]\n            if room > 1e-6:\n                mcs.append((mc, i, room))\n        mcs.sort(key=lambda x: x[0])\n        for mc, idx, room in mcs:\n            if residual < 1e-6:\n                break\n            alloc = min(room, residual)\n            outputs[idx] += alloc\n            residual -= alloc\n    elif residual < 0:\n        residual = abs(residual)\n        mcs = []\n        for i, unit in enumerate(units):\n            mc = unit['b'] + 2 * unit['c'] * outputs[i]\n            room = outputs[i] - unit['min_eff']\n            if room > 1e-6:\n                mcs.append((mc, i, room))\n        mcs.sort(key=lambda x: x[0], reverse=True)\n        for mc, idx, room in mcs:\n            if residual < 1e-6:\n                break\n            alloc = min(room, residual)\n            outputs[idx] -= alloc\n            residual -= alloc\n    \n    return outputs",
          "from": "mutation",
          "gap_power_rate": 0.0055426647,
          "gap_price_rate": 0.0093167212,
          "fitness": 0.007429693
     },
     {
          "name": "refined_optimized_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units with switching flexibility), and free-off (offline units with switching flexibility).\n2. Compute effective min/max outputs accounting for ramp constraints: \n   - Must-off units: (0, 0)\n   - Must-on/free-on units: (max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i))\n   - Free-off units: (p_min_i, min(p_max_i, p_start_i))\n3. Handle must-on feasibility:\n   - If must-on min output > current load: commit only must-on at min outputs\n   - Else if must-on max output \u2265 current load: commit only must-on units\n   - Else:\n        a. Commit must-on and free-on units\n        b. Add free-off units by ascending efficiency metric: (s_i + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n        c. If total min output > load: remove non-must units by avoidable cost per MW (free-on: (a_i + b_i * p_min_i + c_i * p_min_i**2)/p_min_i; free-off: (s_i + a_i + b_i * p_min_i + c_i * p_min_i**2)/p_min_i) while maintaining max output \u2265 load\n4. Dispatch via greedy incremental allocation:\n   - Initialize outputs at effective min for committed units\n   - Allocate residual load to units with lowest marginal cost (b_i + 2 * c_i * p_i) without exceeding effective max\n   - Repeat until load met or capacity exhausted\n5. Set non-committed units to offline state (u_i=0, p_i=0)\n",
          "code": "import numpy as np\n\ndef refined_optimized_hybrid_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Initialize arrays\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    u_i0 = np.array([unit['u_i_0'] for unit in units_info])\n    t_i0 = np.array([unit['t_i_0'] for unit in units_info])\n    \n    # Classify units: 0=must-off, 1=must-on, 2=free-on, 3=free-off\n    unit_class = np.zeros(n_units, dtype=int)\n    for i, unit in enumerate(units_info):\n        if u_i0[i] == 1:\n            if (t_i0[i] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                unit_class[i] = 1  # must-on\n            else:\n                unit_class[i] = 2  # free-on\n        else:\n            offline_duration = -t_i0[i]\n            if offline_duration < unit['t_off_min_i']:\n                unit_class[i] = 0  # must-off\n            else:\n                unit_class[i] = 3  # free-off\n                \n    # Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit_class[i] == 0:  # must-off\n            min_eff[i] = max_eff[i] = 0\n        elif unit_class[i] in (1, 2):  # must-on or free-on\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # free-off\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify unit groups\n    must_on = [i for i in range(n_units) if unit_class[i] == 1]\n    must_off = [i for i in range(n_units) if unit_class[i] == 0]\n    free_on = [i for i in range(n_units) if unit_class[i] == 2]\n    free_off = [i for i in range(n_units) if unit_class[i] == 3]\n    \n    # Calculate total min/max for must-on units\n    total_min_must_on = sum(min_eff[i] for i in must_on)\n    total_max_must_on = sum(max_eff[i] for i in must_on)\n    committed = set()\n    \n    # Commitment decisions\n    if total_min_must_on > current_load:\n        committed = set(must_on)\n    elif total_max_must_on >= current_load:\n        committed = set(must_on)\n    else:\n        # Initial commitment: must-on + free-on\n        committed = set(must_on + free_on)\n        total_min_committed = total_min_must_on + sum(min_eff[i] for i in free_on)\n        total_max_committed = total_max_must_on + sum(max_eff[i] for i in free_on)\n        \n        # Add free-off units if needed\n        if total_max_committed < current_load:\n            efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                cost_min = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                            unit['c_i'] * unit['p_min_i'] ** 2)\n                eff_value = (unit['s_i'] + cost_min) / unit['p_min_i']\n                efficiency.append((eff_value, i))\n            \n            efficiency.sort(key=lambda x: x[0])\n            for _, i in efficiency:\n                if total_max_committed < current_load:\n                    committed.add(i)\n                    total_min_committed += min_eff[i]\n                    total_max_committed += max_eff[i]\n        \n        # Remove non-must units if min output exceeds load\n        if total_min_committed > current_load:\n            avoidable_cost = []\n            non_must = [i for i in committed if i not in must_on]\n            for i in non_must:\n                unit = units_info[i]\n                cost_min = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                            unit['c_i'] * unit['p_min_i'] ** 2)\n                startup_cost = unit['s_i'] if unit_class[i] == 3 else 0\n                ac_mw = (startup_cost + cost_min) / unit['p_min_i']\n                avoidable_cost.append((ac_mw, i))\n            \n            avoidable_cost.sort(key=lambda x: x[0], reverse=True)\n            for _, i in avoidable_cost:\n                if total_min_committed <= current_load:\n                    break\n                if (total_max_committed - max_eff[i]) >= current_load:\n                    committed.remove(i)\n                    total_min_committed -= min_eff[i]\n                    total_max_committed -= max_eff[i]\n    \n    # Initialize schedules\n    u_schedule = np.zeros(n_units)\n    p_schedule = np.zeros(n_units)\n    for i in range(n_units):\n        if i in committed:\n            u_schedule[i] = 1\n            p_schedule[i] = min_eff[i]\n    \n    # Greedy dispatch for residual load\n    total_generation = np.sum(p_schedule)\n    residual = current_load - total_generation\n    active_units = [i for i in committed if p_schedule[i] < max_eff[i]]\n    \n    while residual > 0 and active_units:\n        # Find unit with lowest marginal cost\n        best_index = None\n        best_mc = float('inf')\n        for i in active_units:\n            mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_schedule[i]\n            if mc < best_mc:\n                best_mc = mc\n                best_index = i\n        \n        if best_index is None:\n            break\n        \n        # Allocate as much as possible\n        unit_max = max_eff[best_index]\n        max_increase = unit_max - p_schedule[best_index]\n        allocated = min(residual, max_increase)\n        p_schedule[best_index] += allocated\n        residual -= allocated\n        \n        # Update active units\n        if p_schedule[best_index] >= unit_max:\n            active_units.remove(best_index)\n    \n    # Return final schedules\n    schedules = np.array([u_schedule, p_schedule])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0100041649,
          "fitness": 0.0074306418
     }
]