[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                u[i] = 1\n                \n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in must_run_indices:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    total_min_must = np.sum(eff_min[must_run_indices])\n    total_max_must = np.sum(eff_max[must_run_indices])\n    \n    if total_min_must > current_load:\n        for i in must_run_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    if total_max_must >= current_load:\n        committed_indices = must_run_indices\n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    candidate_indices.append(i)\n                    \n        candidate_info = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                emin = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                emax = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['b_i'] + unit['c_i'] * emin) / emin\n            else:\n                emin = unit['p_min_i']\n                emax = min(unit['p_max_i'], unit['p_start_i'])\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                cost_per_mw = (startup_cost + unit['a_i'] + unit['b_i'] * emin + unit['c_i'] * emin**2) / emin\n            candidate_info.append((i, emin, emax, cost_per_mw))\n        \n        candidate_info.sort(key=lambda x: x[3])\n        committed_indices = must_run_indices.copy()\n        total_min_curr = total_min_must\n        total_max_curr = total_max_must\n        for i, emin, emax, _ in candidate_info:\n            if total_max_curr >= current_load:\n                break\n            committed_indices.append(i)\n            total_min_curr += emin\n            total_max_curr += emax\n        \n        for i in committed_indices:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                eff_min[i] = units_info[i]['p_min_i']\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min_committed = sum(eff_min[i] for i in committed_indices)\n    if total_min_committed > current_load:\n        for i in committed_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    b = []\n    c = []\n    lows = []\n    highs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n        lows.append(eff_min[i])\n        highs.append(eff_max[i])\n    \n    n_committed = len(committed_indices)\n    p_alloc = np.array(lows)\n    if abs(total_min_committed - current_load) < 1e-5:\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_alloc[idx]\n        return np.array([u, p])\n    \n    if n_committed == 0:\n        return np.array([u, p])\n    \n    low_lambda = min(b_i + 2 * c_i * low for b_i, c_i, low in zip(b, c, lows))\n    high_lambda = max(b_i + 2 * c_i * high for b_i, c_i, high in zip(b, c, highs))\n    tolerance = 1e-5\n    \n    for _ in range(1000):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for k in range(n_committed):\n            if c[k] == 0:\n                p_alloc[k] = highs[k] if mid_lambda >= b[k] else lows[k]\n            else:\n                p_val = (mid_lambda - b[k]) / (2 * c[k])\n                p_alloc[k] = np.clip(p_val, lows[k], highs[k])\n            total_p += p_alloc[k]\n        \n        if total_p < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tolerance:\n            diff = current_load - total_p\n            if diff > 0:\n                idx_min = np.argmin(np.array([b_i + 2*c_i*p_i for b_i, c_i, p_i in zip(b, c, p_alloc)]))\n                p_alloc[idx_min] = min(highs[idx_min], p_alloc[idx_min] + diff)\n            break\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_alloc[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054289451,
          "gap_price_rate": 0.0090732546,
          "fitness": 0.0072510999
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs for all units considering ramp constraints (current units use ramp limits, new starts use startup ramp limits).\n3. If must-on units' min output exceeds current load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, dispatch only among must-on units.\n5. Else:\n   a. Activate free-off units by cost-efficiency (startup cost + cost at min output)/min output until capacity meets load\n   b. If total min output of committed set exceeds load:\n      - Remove free units (free-on/new starts) with highest saving per MW while maintaining capacity and shutdown feasibility\n6. Perform greedy dispatch:\n   a. Initialize outputs at effective min\n   b. Increase outputs of units with lowest marginal cost first using min-heap\n   c. Respect ramp and output constraints during allocation\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize commitment states and power outputs\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n            eff_min[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            eff_max[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n                eff_min[idx] = 0.0\n                eff_max[idx] = 0.0\n            else:\n                free_off.append(idx)\n                eff_min[idx] = unit['p_min_i']\n                eff_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3-5: Commitment logic\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        committed = set(must_on)\n    elif must_on_max >= current_load:\n        committed = set(must_on)\n    else:\n        committed = set(must_on) | set(free_on)\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Activate free-off units\n        free_off_sorted = sorted(free_off, key=lambda i: \n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * eff_min[i] + \n             units_info[i]['c_i'] * eff_min[i] ** 2) / eff_min[i])\n        \n        for idx in free_off_sorted:\n            if total_max >= current_load:\n                break\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n            committed.add(idx)\n        \n        # Remove over-committed free units\n        if total_min > current_load:\n            removal_candidates = []\n            for idx in committed:\n                if idx in must_on:\n                    continue\n                if units_info[idx]['u_i_0'] == 1:\n                    if units_info[idx]['p_i_0'] > units_info[idx]['p_shut_i']:\n                        continue\n                    saving = (units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                else:\n                    saving = (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                removal_candidates.append((saving, idx))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            for saving, idx in removal_candidates:\n                if total_min <= current_load:\n                    break\n                if (total_max - eff_max[idx]) >= current_load:\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    committed.remove(idx)\n    \n    # Step 6: Dispatch\n    total_output = 0.0\n    for idx in committed:\n        p[idx] = eff_min[idx]\n        total_output += eff_min[idx]\n        u[idx] = 1\n    \n    deficit = current_load - total_output\n    if deficit > 0:\n        heap = []\n        for idx in committed:\n            if p[idx] < eff_max[idx]:\n                room = eff_max[idx] - p[idx]\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (mc, idx, room))\n        \n        while deficit > 0 and heap:\n            mc, idx, room = heapq.heappop(heap)\n            inc = min(room, deficit)\n            p[idx] += inc\n            deficit -= inc\n            total_output += inc\n            \n            # Update remaining room and marginal cost\n            new_room = eff_max[idx] - p[idx]\n            if new_room > 0:\n                new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (new_mc, idx, new_room))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0101961532,
          "fitness": 0.007526636
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs for must-on and free-on units considering ramp constraints. For free-off units if activated, use startup ramp limits.  \n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).  \n4. Else if must-on units can cover load, optimize dispatch only among must-on units.  \n5. Else, activate free-on and free-off candidates sorted by cost-efficiency (startup + min-output cost)/min-output), selecting until total max capacity meets load.  \n6. If the min output of committed units exceeds load, remove most expensive/least flexible candidates while maintaining capacity.  \n7. Dispatch load among committed units:  \n   - Initialize outputs at effective min  \n   - Increase cheapest units' output when below load  \n   - Decrease most expensive units' output when above load  \n   - Respect ramp and output constraints during dispatch  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    enhanced_units = []\n    \n    # Classify units and compute parameters\n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_up, p_down = unit['p_up_i'], unit['p_down_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        prev_u, prev_p, prev_t = unit['u_i_0'], unit['p_i_0'], unit['t_i_0']\n        \n        # Determine category\n        if prev_u == 1:\n            if prev_t < t_on_min or prev_p > p_shut:\n                category = 'must_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n            else:\n                category = 'free_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n        else:\n            if -prev_t < t_off_min:\n                category = 'must_off'\n                eff_min = eff_max = 0\n            else:\n                category = 'free_off'\n                eff_min = p_min\n                eff_max = min(p_max, p_start)\n        enhanced_units.append({\n            'index': i,\n            'category': category,\n            'eff_min': eff_min,\n            'eff_max': eff_max,\n            's_i': s_i,\n            'p_min': p_min,\n            'a_i': a_i, 'b_i': b_i, 'c_i': c_i\n        })\n    \n    # Separate units into categories\n    must_on = [u for u in enhanced_units if u['category'] == 'must_on']\n    must_off = [u for u in enhanced_units if u['category'] == 'must_off']\n    free_on = [u for u in enhanced_units if u['category'] == 'free_on']\n    free_off = [u for u in enhanced_units if u['category'] == 'free_off']\n    \n    # Initialize with must-on units\n    total_min = sum(u['eff_min'] for u in must_on)\n    total_max = sum(u['eff_max'] for u in must_on)\n    committed = must_on.copy()\n    \n    if total_min > current_load:\n        # Case 1: Must-on over-generation\n        for u in must_on:\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = u['eff_min']\n    elif total_max >= current_load:\n        # Case 2: Dispatch among must-on\n        if must_on:\n            p_values = [u['eff_min'] for u in must_on]\n            remaining = current_load - total_min\n            while abs(remaining) > 1e-5:\n                # Increase phase\n                while remaining > 1e-5:\n                    best_idx, best_mc = -1, float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] < u['eff_max']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc < best_mc:\n                                best_mc, best_idx = mc, j\n                    if best_idx == -1: break\n                    inc = min(remaining, must_on[best_idx]['eff_max'] - p_values[best_idx])\n                    p_values[best_idx] += inc\n                    remaining -= inc\n                # Decrease phase\n                while remaining < -1e-5:\n                    worst_idx, worst_mc = -1, -float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] > u['eff_min']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc > worst_mc:\n                                worst_mc, worst_idx = mc, j\n                    if worst_idx == -1: break\n                    dec = min(-remaining, p_values[worst_idx] - must_on[worst_idx]['eff_min'])\n                    p_values[worst_idx] -= dec\n                    remaining += dec\n            for u, p_val in zip(must_on, p_values):\n                i = u['index']\n                schedules[0, i] = 1\n                schedules[1, i] = p_val\n    else:\n        # Case 3: Need more capacity\n        candidates = []\n        # Free-on candidates\n        for u in free_on:\n            min_out = u['eff_min']\n            cost_per_mw = (u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Free-off candidates\n        for u in free_off:\n            min_out = u['eff_min']\n            cost_per_mw = (u['s_i'] + u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Sort by cost efficiency then min output\n        candidates.sort(key=lambda x: (x[1], x[2]))\n        \n        # Add candidates until capacity meets demand\n        added_candidates = []\n        for candidate in candidates:\n            if total_max < current_load:\n                u, _, min_out, max_out = candidate\n                added_candidates.append(candidate)\n                committed.append(u)\n                total_min += min_out\n                total_max += max_out\n        \n        # Remove over-committed candidates\n        added_candidates.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n        i = 0\n        while i < len(added_candidates) and total_min > current_load:\n            u, _, min_out, max_out = added_candidates[i]\n            if total_max - max_out >= current_load:\n                committed.remove(u)\n                added_candidates.pop(i)\n                total_min -= min_out\n                total_max -= max_out\n            else:\n                i += 1\n        \n        # Dispatch among committed units\n        p_values = []\n        bounds = []\n        for u in committed:\n            if u['category'] in ['must_on', 'free_on']:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            else:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            p_values.append(eff_min)\n            bounds.append((eff_min, eff_max))\n        remaining = current_load - sum(p_values)\n        \n        # Increase outputs for under-generation\n        while remaining > 1e-5:\n            best_idx, best_mc = -1, float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] < high:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc < best_mc:\n                        best_mc, best_idx = mc, j\n            if best_idx == -1: \n                break\n            inc = min(remaining, bounds[best_idx][1] - p_values[best_idx])\n            p_values[best_idx] += inc\n            remaining -= inc\n        \n        # Decrease outputs for over-generation\n        while remaining < -1e-5:\n            worst_idx, worst_mc = -1, -float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] > low:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc > worst_mc:\n                        worst_mc, worst_idx = mc, j\n            if worst_idx == -1: \n                break\n            dec = min(-remaining, p_values[worst_idx] - bounds[worst_idx][0])\n            p_values[worst_idx] -= dec\n            remaining += dec\n        \n        # Apply scheduled outputs\n        for u, p_val in zip(committed, p_values):\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = p_val\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "hybrid_enhanced_refined_heuristic",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on).  \n2. Compute effective min/max outputs: online units respect ramps, potential startups limited by startup ramp.  \n3. If must-on units force over-generation (sum(min) > load), commit only must-on at minimum outputs.  \n4. Else if must-on units can cover load alone (sum(max) >= load), dispatch only among must-on units using lambda iteration.  \n5. Else:  \n   a. Initially commit must-on and free-on units.  \n   b. If total capacity < load:  \n      i. Add free-off units by ascending average cost = (startup + min-output cost) / min-output  \n      ii. Stop when total max >= load  \n   c. If total min > load:  \n      i. Remove non-must units by descending avoidable cost = (startup if not online + min cost) / min-output  \n      ii. Maintain total max >= load during removal  \n6. Dispatch load among final committed set:  \n   a. Set outputs to min values  \n   b. Distribute deficit via lambda iteration respecting effective min/max limits  \n7. Set non-committed units to off state (output 0).  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_refined_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]  # current time step load\n\n    min_limits = np.zeros(n_units)\n    max_limits = np.zeros(n_units)\n    must_on = set()\n    must_off = set()\n    free_on = set()\n    free_off = set()\n\n    # Step 1: Classify units and compute effective min/max\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        \n        if u_i0:  # was online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.add(i)\n                min_limits[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_limits[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.add(i)\n                min_limits[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_limits[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # was offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.add(i)\n                min_limits[i] = 0\n                max_limits[i] = 0\n            else:\n                free_off.add(i)\n                min_limits[i] = unit['p_min_i']\n                max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Step 3: Handle must-on over-generation\n    total_must_on_min = sum(min_limits[i] for i in must_on)\n    total_must_on_max = sum(max_limits[i] for i in must_on)\n    if total_must_on_min > current_load:\n        u_outputs = [1 if i in must_on else 0 for i in range(n_units)]\n        p_outputs = [min_limits[i] if i in must_on else 0 for i in range(n_units)]\n        return np.array([u_outputs, p_outputs])\n    \n    # Step 4: Must-on can cover load\n    if total_must_on_max >= current_load:\n        committed = must_on\n        u_outputs = [1 if i in committed else 0 for i in range(n_units)]\n        # Lambda iteration for dispatch\n        p_outputs = lambda_iteration_dispatch(\n            units_info, committed, min_limits, max_limits, current_load\n        )\n        return np.array([u_outputs, p_outputs])\n    \n    # Step 5: Require additional units\n    committed = must_on | free_on  # must-on and free-on initially committed\n    total_min = sum(min_limits[i] for i in committed)\n    total_max = sum(max_limits[i] for i in committed)\n    \n    # Step 5b: Add free-off if needed\n    if total_max < current_load:\n        cost_efficiency = []\n        for i in free_off:\n            s_i = units_info[i]['s_i']\n            min_cost = units_info[i]['b_i'] * min_limits[i] + units_info[i]['c_i'] * min_limits[i] ** 2\n            cost_efficiency.append(( (s_i + min_cost) / min_limits[i], i))\n        cost_efficiency.sort(key=lambda x: x[0])\n        \n        for _, i in cost_efficiency:\n            if total_max < current_load:\n                committed.add(i)\n                total_min += min_limits[i]\n                total_max += max_limits[i]\n            else:\n                break\n    \n    # Step 5c: Remove non-must if min > load\n    non_must = [i for i in committed if i not in must_on]  # removable units\n    if total_min > current_load:\n        removal_efficiency = []\n        for i in non_must:\n            min_cost = units_info[i]['b_i'] * min_limits[i] + units_info[i]['c_i'] * min_limits[i] ** 2\n            # Avoidable cost includes startup if unit was off originally\n            avoidable_cost = min_cost + (units_info[i]['s_i'] if i in free_off else 0)\n            removal_efficiency.append((avoidable_cost / min_limits[i], i))\n        removal_efficiency.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in removal_efficiency:\n            if total_min > current_load and (total_max - max_limits[i]) >= current_load:\n                committed.remove(i)\n                total_min -= min_limits[i]\n                total_max -= max_limits[i]\n    \n    # Step 6: Dispatch final committed set\n    u_outputs = [1 if i in committed else 0 for i in range(n_units)]\n    p_outputs = lambda_iteration_dispatch(\n        units_info, committed, min_limits, max_limits, current_load\n    )\n    return np.array([u_outputs, p_outputs])\n\ndef lambda_iteration_dispatch(units_info, committed, min_limits, max_limits, load_current):\n    n_units = len(units_info)\n    p_outputs = np.zeros(n_units)\n    \n    # Initialize to min outputs\n    for i in committed:\n        p_outputs[i] = min_limits[i]\n    total_p = sum(p_outputs)\n    \n    # Only dispatch if load > total min output\n    if abs(total_p - load_current) < 1e-6:\n        return p_outputs.tolist()\n    \n    # Get initial lambda bounds\n    lb = float('inf')\n    ub = 0\n    for i in committed:\n        mc_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_limits[i]\n        mc_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_limits[i]\n        lb = min(lb, mc_min)\n        ub = max(ub, mc_max)\n    \n    # Binary search for lambda\n    tol = 0.01  # tolerance in MW\n    max_iter = 100\n    iter_count = 0\n    while ub - lb > tol and iter_count < max_iter:\n        lam = (lb + ub) / 2\n        total_p_temp = 0\n        for i in committed:\n            if units_info[i]['c_i'] == 0:  # linear unit\n                if lam >= units_info[i]['b_i']:\n                    p_i = max_limits[i]\n                else:\n                    p_i = min_limits[i]\n            else:  # quadratic unit\n                p_i = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_i = max(min_limits[i], min(max_limits[i], p_i))\n            total_p_temp += p_i\n        \n        if total_p_temp < load_current:\n            lb = lam\n        else:\n            ub = lam\n        iter_count += 1\n    \n    # Assign final outputs\n    lam = (lb + ub) / 2\n    for i in committed:\n        if units_info[i]['c_i'] == 0:\n            p_outputs[i] = max_limits[i] if lam >= units_info[i]['b_i'] else min_limits[i]\n        else:\n            p_unclamped = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            p_outputs[i] = max(min_limits[i], min(max_limits[i], p_unclamped))\n    \n    return p_outputs.tolist()",
          "from": "crossover",
          "gap_power_rate": 0.0048053347,
          "gap_price_rate": 0.0150684056,
          "fitness": 0.0099368701
     },
     {
          "name": "hybrid_rolling_commitment_optimized",
          "algorithm": "1. Classify units into must-on (units that must remain online due to min up-time or shutdown ramp constraints), must-off (units that must remain offline due to min down-time), free-on (online units that can be shut down), and free-off (offline units that can be started).\n2. Compute effective min/max outputs:\n   - For online units (must-on/free-on): min_eff = max(p_min_i, p_prev - ramp_down_i), max_eff = min(p_max_i, p_prev + ramp_up_i)\n   - For startable units (free-off): min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n3. If must-on min output > load: commit only must-on at min_eff (over-generation).\n4. Else if must-on can cover load: commit only must-on and proceed to dispatch.\n5. Else:\n   a. Initially commit must-on + free-on units\n   b. If total max_eff < load: add free-off units by cost-efficiency (startup + min-output cost)/min_output until load covered\n   c. If total min_eff > load: remove non-must units with highest cost/MW at min_eff first while maintaining feasibility\n6. Dispatch committed units:\n   a. Initialize all outputs to min_eff\n   b. Use min-heap to distribute deficit (load - sum(min_eff)) to units with lowest marginal cost\n   c. Handle over-generation by leaving outputs at min_eff\n7. Return commitment states and power outputs.\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef hybrid_rolling_commitment_optimized(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    for i, unit in enumerate(units_info):\n        if i in must_on + free_on:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff[i] = 0\n            max_eff[i] = 0\n    \n    total_min_must = sum(min_eff[i] for i in must_on)\n    total_max_must = sum(max_eff[i] for i in must_on)\n    \n    if total_min_must >= current_load:\n        u = [1 if i in must_on else 0 for i in range(n_units)]\n        p = [min_eff[i] if i in must_on else 0 for i in range(n_units)]\n        return np.array([u, p])\n    \n    if total_min_must <= current_load <= total_max_must:\n        committed = must_on\n    else:\n        committed = must_on + free_on\n        total_max = sum(max_eff[i] for i in committed)\n        total_min = sum(min_eff[i] for i in committed)\n        \n        if total_max < current_load:\n            candidates = []\n            for i in free_off:\n                min_cost = units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i]**2\n                total_cost = min_cost + units_info[i]['s_i']\n                if min_eff[i] > 1e-6:\n                    cost_per_mw = total_cost / min_eff[i]\n                    candidates.append((cost_per_mw, i))\n            \n            candidates.sort(key=lambda x: x[0])\n            for _, idx in candidates:\n                if total_max < current_load:\n                    committed.append(idx)\n                    total_min += min_eff[idx]\n                    total_max += max_eff[idx]\n                else:\n                    break\n        \n        total_min = sum(min_eff[i] for i in committed)\n        if total_min > current_load:\n            free_in_commit = [i for i in committed if i in free_on or (i in free_off and i not in must_on)]\n            candidates = []\n            for i in free_in_commit:\n                op_cost = units_info[i]['a_i'] + units_info[i]['b_i']*min_eff[i] + units_info[i]['c_i']*min_eff[i]**2\n                saving = op_cost\n                if i in free_off:\n                    saving += units_info[i]['s_i']\n                if min_eff[i] > 1e-6:\n                    saving_per_mw = saving / min_eff[i]\n                    candidates.append((saving_per_mw, saving, min_eff[i], max_eff[i], i))\n            \n            candidates.sort(key=lambda x: x[0], reverse=True)\n            removed = []\n            current_total_min = total_min\n            current_total_max = total_max\n            \n            for saving_per_mw, saving, m_eff, mx_eff, i in candidates:\n                if current_total_min - m_eff <= current_load and current_total_max - mx_eff >= current_load:\n                    removed.append(i)\n                    current_total_min -= m_eff\n                    current_total_max -= mx_eff\n                    if current_total_min <= current_load:\n                        break\n            \n            committed = [i for i in committed if i not in removed]\n    \n    u = [1 if i in committed else 0 for i in range(n_units)]\n    p = np.zeros(n_units)\n    for i in committed:\n        p[i] = min_eff[i]\n    \n    deficit = current_load - sum(p)\n    if deficit > 1e-6:\n        heap = []\n        for i in committed:\n            if p[i] < max_eff[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                room = max_eff[i] - p[i]\n                heapq.heappush(heap, (marginal_cost, i, room))\n        \n        while deficit > 1e-6 and heap:\n            mc, i, room = heapq.heappop(heap)\n            add = min(deficit, room)\n            p[i] += add\n            deficit -= add\n            new_room = room - add\n            if new_room > 1e-6:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                heapq.heappush(heap, (new_mc, i, new_room))\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.005211854,
          "gap_price_rate": 0.0150284964,
          "fitness": 0.0101201752
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     }
]