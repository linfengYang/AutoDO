[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "adaptive_dynamic_commitment",
          "algorithm": "1. Classify units into four categories based on physical constraints:\n   - Must-on: Cannot be turned off (min up-time violation risk or shutdown capacity exceeded)\n   - Must-off: Cannot be turned on (min down-time constraint)\n   - Free-on: Online units eligible for decommitment\n   - Free-off: Offline units eligible for commitment\n\n2. Compute effective min/max outputs considering ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, startup_ramp)\n\n3. Handle load allocation cases:\n   a. Over-generation: If must-on min_eff sum > load, commit only must-on at min_eff\n   b. Must-on coverage: If must-on max_eff sum > load, commit only must-on units\n   c. Capacity shortfall: Else:\n      - Initial commitment: must-on + free-on units\n      - Add free-off units by cost efficiency: (startup_cost + no_load_cost + min_output_cost) / min_output\n      - Remove non-must units by avoidable cost: (no_load_cost + min_output_cost + startup_cost if applicable) / min_output\n\n4. Hybrid dispatch:\n   - For small committed sets (\u226410 units): Use lambda iteration for precise quadratic cost optimization\n   - For larger sets: Use marginal-cost based greedy allocation:\n        \u2022 Initialize outputs at effective minimum\n        \u2022 Allocate remaining load using min-heap prioritized by marginal cost\n        \u2022 Respect individual unit capacity limits during allocation\n\n5. Set non-committed units to offline state (u_i=0, p_i=0)\n\n6. Return commitment states and power outputs\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef adaptive_dynamic_commitment(units_info, load):\n    current_load = load[0]  # Current period load only\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        # Must-on conditions: min up-time violation risk or exceeding shutdown capacity\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_on.append(i)\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Must-off condition: min down-time constraint\n        elif unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            must_off.append(i)\n            min_eff[i] = 0\n            max_eff[i] = 0\n        # Free-on units\n        elif unit['u_i_0'] == 1:\n            free_on.append(i)\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Free-off units\n        else:\n            free_off.append(i)\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Case 1: Must-on min outputs exceed load (over-generation)\n    must_on_min_sum = sum(min_eff[i] for i in must_on)\n    if must_on_min_sum >= current_load:\n        for i in must_on:\n            u[i] = 1\n            p[i] = min_eff[i]\n        return np.array([u, p])\n    \n    # Case 2: Must-on units can cover load alone\n    must_on_max_sum = sum(max_eff[i] for i in must_on)\n    if must_on_max_sum >= current_load:\n        committed = must_on.copy()\n    # Case 3: Need additional units\n    else:\n        committed = must_on + free_on\n        comm_min_sum = sum(min_eff[i] for i in committed)\n        comm_max_sum = sum(max_eff[i] for i in committed)\n        \n        # Add free-off units if capacity insufficient\n        if comm_max_sum < current_load:\n            # Efficiency metric: (startup + no-load + min-output cost)/min-output\n            eff_metrics = []\n            for i in free_off:\n                min_cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + \n                            units_info[i]['c_i'] * min_eff[i]**2)\n                metric = (units_info[i]['s_i'] + min_cost) / min_eff[i]\n                eff_metrics.append((metric, i))\n            \n            # Sort by ascending metric (cost efficiency)\n            eff_metrics.sort(key=lambda x: x[0])\n            \n            # Add most efficient units until load can be met\n            for metric, i in eff_metrics:\n                if comm_max_sum >= current_load:\n                    break\n                committed.append(i)\n                comm_min_sum += min_eff[i]\n                comm_max_sum += max_eff[i]\n        \n        # Remove non-must units if min outputs exceed load\n        if comm_min_sum > current_load:\n            avoidable_metrics = []\n            non_must = [i for i in committed if i not in must_on]\n            \n            for i in non_must:\n                min_cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + \n                            units_info[i]['c_i'] * min_eff[i]**2)\n                # Startup cost only applies to free-off\n                full_cost = min_cost + (units_info[i]['s_i'] if i in free_off else 0)\n                metric = full_cost / min_eff[i]  # Avoidable cost per MW\n                avoidable_metrics.append((metric, i))\n            \n            # Sort by descending metric (for removal priority)\n            avoidable_metrics.sort(key=lambda x: -x[0])\n            \n            # Remove highest avoidable cost units while maintaining feasibility\n            for metric, i in avoidable_metrics:\n                if comm_min_sum - min_eff[i] <= current_load:\n                    # Removal would maintain max coverage??\n                    new_max = comm_max_sum - max_eff[i]\n                    if new_max >= current_load:\n                        committed.remove(i)\n                        comm_min_sum -= min_eff[i]\n                        comm_max_sum -= max_eff[i]\n                if comm_min_sum <= current_load:\n                    break\n    \n    # Dispatch strategy selection\n    if len(committed) <= 10:\n        # Lambda iteration for small sets\n        low = min(units_info[i]['b_i'] + 2*units_info[i]['c_i']*min_eff[i] for i in committed)\n        high = max(units_info[i]['b_i'] + 2*units_info[i]['c_i']*max_eff[i] for i in committed)\n        tol = 0.1\n        \n        while (high - low) > tol:\n            lam = (low + high) / 2\n            total_power = 0\n            for i in committed:\n                if units_info[i]['c_i'] > 0:  # Quadratic unit\n                    p_i = max(min_eff[i], min(max_eff[i], (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])))\n                else:  # Linear unit\n                    p_i = max_eff[i] if lam > units_info[i]['b_i'] else min_eff[i]\n                total_power += p_i\n            \n            if total_power < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Final assignment\n        lam = (low + high) / 2\n        for i in committed:\n            if units_info[i]['c_i'] > 0:\n                p_i = max(min_eff[i], min(max_eff[i], (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])))\n            else:\n                p_i = max_eff[i] if lam > units_info[i]['b_i'] else min_eff[i]\n            p[i] = p_i\n            u[i] = 1\n    else:\n        # Greedy allocation for large sets\n        current_p = {i: min_eff[i] for i in committed}\n        residual = current_load - sum(min_eff[i] for i in committed)\n        \n        # Min-heap for marginal costs (b_i + 2*c_i*p)\n        heap = []\n        for i in committed:\n            mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p[i]\n            heapq.heappush(heap, (mc, i))\n        \n        while residual > 0 and heap:\n            mc, i = heapq.heappop(heap)\n            alloc = min(residual, max_eff[i] - current_p[i])\n            current_p[i] += alloc\n            residual -= alloc\n            \n            # Update heap if unit still has capacity\n            if current_p[i] < max_eff[i]:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p[i]\n                heapq.heappush(heap, (new_mc, i))\n        \n        for i in committed:\n            p[i] = current_p[i]\n            u[i] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0059048937,
          "gap_price_rate": 0.0080311131,
          "fitness": 0.0069680034
     },
     {
          "name": "enhanced_hybrid_lambda",
          "algorithm": "1. Classify units into must-on (previous online state with violated min up-time or shutdown constraints), must-off (previous offline state with violated min down-time), free-on (online units available for decommitment), and free-off (offline units available for commitment).\n2. Compute effective min/max outputs considering ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, p_start)\n   - Must-off units: min_eff = max_eff = 0\n3. If must-on units' total min_eff exceeds current load:\n   - Commit only must-on units at min_eff (over-generation)\n4. Else if must-on units' total max_eff covers current load:\n   - Commit only must-on units, dispatch via lambda iteration\n5. Else:\n   - Initially commit must-on and free-on units\n   - If total max_eff < current load:\n        - Add free-off units by ascending cost efficiency metric: (startup_cost + no_load_cost + cost_at_min_output)/min_output\n   - If total min_eff > current load:\n        - Remove non-must units by avoidable cost per MW while maintaining max output coverage\n6. Dispatch load among committed units:\n   - Use lambda iteration with bisection to minimize production cost\n   - Refine with greedy adjustment for residual mismatch\n7. Set non-committed units to offline state (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_lambda(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u_prev = [u['u_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    t0 = [u['t_i_0'] for u in units_info]\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    \n    must_on, must_off, free_on, free_off = [], [], [], []\n    eff_min = [0] * n\n    eff_max = [0] * n\n    u_out = [0] * n\n    p_out = [0] * n\n    \n    for i in range(n):\n        if u_prev[i] == 1:\n            if t0[i] < t_on_min[i] or p_prev[i] > p_shut[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            eff_min[i] = max(p_min[i], p_prev[i] - p_down[i])\n            eff_max[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            if -t0[i] < t_off_min[i]:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], p_start[i])\n    \n    for i in must_off:\n        eff_min[i] = 0\n        eff_max[i] = 0\n    \n    total_must_on_min = sum(eff_min[i] for i in must_on)\n    total_must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if total_must_on_min > current_load:\n        committed = must_on\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = eff_min[i]\n        return np.array([u_out, p_out])\n    \n    elif total_must_on_max >= current_load:\n        committed = must_on\n    else:\n        committed = must_on + free_on\n        total_min = total_must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = total_must_on_max + sum(eff_max[i] for i in free_on)\n        \n        if total_max < current_load:\n            free_off_list = free_off[:]\n            free_off_list.sort(key=lambda i: (s[i] + a[i] + b[i]*eff_min[i] + c[i]*eff_min[i]**2) / eff_min[i] if eff_min[i] > 0 else float('inf'))\n            for i in free_off_list:\n                if total_max >= current_load:\n                    break\n                committed.append(i)\n                total_min += eff_min[i]\n                total_max += eff_max[i]\n        \n        def avoidable_cost(i):\n            if i in free_off:\n                return s[i] + a[i] + b[i]*eff_min[i] + c[i]*eff_min[i]**2\n            else:\n                return a[i] + b[i]*eff_min[i] + c[i]*eff_min[i]**2\n        \n        non_must = [i for i in committed if i not in must_on]\n        non_must_zero = [i for i in non_must if eff_min[i] == 0]\n        non_must_positive = [i for i in non_must if eff_min[i] > 0]\n        non_must_positive.sort(key=lambda i: avoidable_cost(i) / eff_min[i], reverse=True)\n        non_must_sorted = non_must_zero + non_must_positive\n        to_remove = []\n        \n        for i in non_must_sorted:\n            if total_min - eff_min[i] < current_load and total_max - eff_max[i] >= current_load:\n                to_remove.append(i)\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n                if total_min <= current_load:\n                    break\n        \n        for i in to_remove:\n            committed.remove(i)\n    \n    def dispatch(committed, a, b, c, eff_min, eff_max, load):\n        n_d = len(a)\n        p_dispatch = [0] * n_d\n        total_min = sum(eff_min[i] for i in committed)\n        total_max = sum(eff_max[i] for i in committed)\n        \n        if total_min >= load:\n            for i in committed:\n                p_dispatch[i] = eff_min[i]\n            return p_dispatch\n        if total_max <= load:\n            for i in committed:\n                p_dispatch[i] = eff_max[i]\n            return p_dispatch\n        \n        mc_max = 0.0\n        for i in committed:\n            mc = b[i] + 2*c[i]*eff_max[i] if c[i] != 0 else b[i]\n            if mc > mc_max:\n                mc_max = mc\n        \n        low_lambda = 0.0\n        high_lambda = mc_max\n        tolerance = 1e-5\n        max_iter = 1000\n        \n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in committed:\n                if c[i] == 0:\n                    p_val = eff_max[i] if mid_lambda >= b[i] else eff_min[i]\n                else:\n                    mc_min = b[i] + 2*c[i]*eff_min[i]\n                    mc_max_i = b[i] + 2*c[i]*eff_max[i]\n                    if mid_lambda < mc_min:\n                        p_val = eff_min[i]\n                    elif mid_lambda > mc_max_i:\n                        p_val = eff_max[i]\n                    else:\n                        p_val = (mid_lambda - b[i]) / (2*c[i])\n                total_power += p_val\n            \n            if total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            \n            if high_lambda - low_lambda < tolerance:\n                break\n        \n        mid_lambda = (low_lambda + high_lambda) / 2.0\n        total_power = 0.0\n        for i in committed:\n            if c[i] == 0:\n                p_val = eff_max[i] if mid_lambda >= b[i] else eff_min[i]\n            else:\n                mc_min = b[i] + 2*c[i]*eff_min[i]\n                mc_max_i = b[i] + 2*c[i]*eff_max[i]\n                if mid_lambda < mc_min:\n                    p_val = eff_min[i]\n                elif mid_lambda > mc_max_i:\n                    p_val = eff_max[i]\n                else:\n                    p_val = (mid_lambda - b[i]) / (2*c[i])\n            p_dispatch[i] = p_val\n            total_power += p_val\n        \n        residual = load - total_power\n        tol = 0.01\n        max_iter_adj = 100\n        iter_count = 0\n        \n        while abs(residual) > tol and iter_count < max_iter_adj:\n            iter_count += 1\n            if residual > 0:\n                candidate = None\n                min_mc = float('inf')\n                for i in committed:\n                    if p_dispatch[i] < eff_max[i]:\n                        if c[i] == 0:\n                            mc = b[i]\n                        else:\n                            mc = b[i] + 2*c[i]*p_dispatch[i]\n                        if mc < min_mc:\n                            min_mc = mc\n                            candidate = i\n                if candidate is None:\n                    break\n                delta = min(residual, eff_max[candidate] - p_dispatch[candidate])\n                p_dispatch[candidate] += delta\n                residual -= delta\n            else:\n                candidate = None\n                max_mc = float('-inf')\n                for i in committed:\n                    if p_dispatch[i] > eff_min[i]:\n                        if c[i] == 0:\n                            mc = b[i]\n                        else:\n                            mc = b[i] + 2*c[i]*p_dispatch[i]\n                        if mc > max_mc:\n                            max_mc = mc\n                            candidate = i\n                if candidate is None:\n                    break\n                delta = min(-residual, p_dispatch[candidate] - eff_min[candidate])\n                p_dispatch[candidate] -= delta\n                residual += delta\n        \n        return p_dispatch\n    \n    p_committed = dispatch(committed, a, b, c, eff_min, eff_max, current_load)\n    for i in range(n):\n        if i in committed:\n            u_out[i] = 1\n            p_out[i] = p_committed[i]\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0050018175,
          "gap_price_rate": 0.0089493134,
          "fitness": 0.0069755654
     },
     {
          "name": "solve_ruc",
          "algorithm": "**  \n1. Classify units:  \n   - Must-on: Online units violating min up-time (`t_i_0 < t_on_min_i`) or exceeding shutdown ramp (`p_i_0 > p_shut_i`)  \n   - Must-off: Offline units violating min down-time (`-t_i_0 < t_off_min_i`)  \n   - Free-on: Online units eligible for decommitment  \n   - Free-off: Offline units eligible for commitment  \n2. Compute effective min/max outputs:  \n   - Must-on/Free-on: `max(p_min_i, p_i_0 - p_down_i)` and `min(p_max_i, p_i_0 + p_up_i)`  \n   - Free-off: `p_min_i` and `min(p_max_i, p_start_i)`  \n   - Must-off: `0` and `0`  \n3. Handle cases:  \n   a. Must-on min \u2265 load \u2192 Commit must-on at min output  \n   b. Must-on max \u2265 load \u2192 Dispatch only must-on  \n   c. Else:  \n      i. Commit must-on + free-on  \n      ii. Add free-off units by efficiency: `(s_i + a_i + b_i \u00d7 min + c_i \u00d7 min\u00b2) / min`  \n      iii. Remove non-must units by avoidable cost: `(a_i + b_i \u00d7 min + c_i \u00d7 min\u00b2 + (s_i if free-off)) / min`  \n4. Dispatch committed units:  \n   a. Lambda iteration with bisection for quadratic cost optimization  \n   b. Residual adjustment via priority heap for marginal cost  \n5. Set non-committed units offline (`u_i=0`, `p_i=0`)  \n\n**",
          "code": "import numpy as np\nimport heapq\n\ndef solve_ruc(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Compute effective min/max\n    eff_min = [0] * n\n    eff_max = [0] * n\n    for i in must_on + free_on:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    for i in free_off:\n        unit = units_info[i]\n        eff_min[i] = unit['p_min_i']\n        eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    for i in must_off:\n        eff_min[i], eff_max[i] = 0, 0\n        \n    # Initialize outputs\n    u_out = [0] * n\n    p_out = [0] * n\n    \n    # Case handling\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        # Case A: Over-generation\n        for i in must_on:\n            u_out[i] = 1\n            p_out[i] = eff_min[i]\n        return np.array([u_out, p_out])\n    \n    if must_on_max >= current_load:\n        # Case B: Must-on suffices\n        committed = must_on\n    else:\n        # Case C: Need additional units\n        committed = must_on + free_on\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Add free-off by cost efficiency\n        free_off_costs = []\n        for i in free_off:\n            unit = units_info[i]\n            min_i = eff_min[i]\n            cost_val = (unit['s_i'] + unit['a_i'] + \n                        unit['b_i'] * min_i + \n                        unit['c_i'] * min_i ** 2) / min_i\n            free_off_costs.append((cost_val, i))\n        free_off_costs.sort(key=lambda x: x[0])\n        \n        for cost_val, i in free_off_costs:\n            if total_max >= current_load:\n                break\n            committed.append(i)\n            total_min += eff_min[i]\n            total_max += eff_max[i]\n        \n        # Remove non-must units if over-committed\n        non_must = [i for i in committed if i not in must_on]\n        avoidable_costs = []\n        for i in non_must:\n            unit = units_info[i]\n            min_i = eff_min[i]\n            cost_val = unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i ** 2\n            if i in free_off:  # Avoid startup if removed\n                cost_val += unit['s_i']\n            avoidable_costs.append((cost_val / min_i, i))\n        avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        temp_min = total_min\n        temp_max = total_max\n        for cost_per_mw, i in avoidable_costs:\n            if temp_max - eff_max[i] >= current_load:\n                committed.remove(i)\n                temp_min -= eff_min[i]\n                temp_max -= eff_max[i]\n    \n    # Dispatch using lambda iteration with residual adjustment\n    if not committed:\n        return np.array([u_out, p_out])\n        \n    def dispatch(committed, load_demand):\n        n_c = len(committed)\n        c = [units_info[i]['c_i'] for i in committed]\n        b = [units_info[i]['b_i'] for i in committed]\n        eff_min_c = [eff_min[i] for i in committed]\n        eff_max_c = [eff_max[i] for i in committed]\n        \n        # Handle boundary cases\n        total_min = sum(eff_min_c)\n        total_max = sum(eff_max_c)\n        if total_min >= load_demand:\n            return eff_min_c\n        if total_max <= load_demand:\n            return eff_max_c\n        \n        # Lambda bisection\n        low = min(2 * c_i * min_i + b_i if c_i > 0 else b_i \n                  for c_i, b_i, min_i in zip(c, b, eff_min_c))\n        high = max(2 * c_i * max_i + b_i if c_i > 0 else b_i \n                   for c_i, b_i, max_i in zip(c, b, eff_max_c))\n        \n        def power_at_lmbda(lmbda):\n            p_vals = []\n            for i in range(n_c):\n                if c[i] > 0:\n                    p_i = (lmbda - b[i]) / (2 * c[i])\n                    p_i = max(eff_min_c[i], min(eff_max_c[i], p_i))\n                else:\n                    p_i = eff_max_c[i] if lmbda >= b[i] else eff_min_c[i]\n                p_vals.append(p_i)\n            return p_vals\n        \n        tol, max_iter = 1e-5, 1000\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            p_vals = power_at_lmbda(mid)\n            total_power = sum(p_vals)\n            if abs(total_power - load_demand) < tol:\n                break\n            if total_power < load_demand:\n                low = mid\n            else:\n                high = mid\n        \n        # Residual adjustment\n        p_vals = power_at_lmbda(mid)\n        residual = load_demand - sum(p_vals)\n        if residual > 0:  # Under generation\n            heap = []\n            for i, p_val in enumerate(p_vals):\n                if p_val < eff_max_c[i]:\n                    mc = 2 * c[i] * p_val + b[i] if c[i] > 0 else b[i]\n                    heapq.heappush(heap, (mc, i))\n            while abs(residual) > tol and heap:\n                mc, idx = heapq.heappop(heap)\n                delta = min(residual, eff_max_c[idx] - p_vals[idx])\n                p_vals[idx] += delta\n                residual -= delta\n                if p_vals[idx] < eff_max_c[idx]:\n                    new_mc = 2 * c[idx] * p_vals[idx] + b[idx] if c[idx] > 0 else b[idx]\n                    heapq.heappush(heap, (new_mc, idx))\n        elif residual < 0:  # Over generation\n            residual = -residual\n            heap = []\n            for i, p_val in enumerate(p_vals):\n                if p_val > eff_min_c[i]:\n                    mc = 2 * c[i] * p_val + b[i] if c[i] > 0 else b[i]\n                    heapq.heappush(heap, (-mc, i))\n            while abs(residual) > tol and heap:\n                neg_mc, idx = heapq.heappop(heap)\n                delta = min(residual, p_vals[idx] - eff_min_c[idx])\n                p_vals[idx] -= delta\n                residual -= delta\n                if p_vals[idx] > eff_min_c[idx]:\n                    new_mc = 2 * c[idx] * p_vals[idx] + b[idx] if c[idx] > 0 else b[idx]\n                    heapq.heappush(heap, (-new_mc, idx))\n        return p_vals\n    \n    # Set outputs for committed units\n    p_committed = dispatch(committed, current_load)\n    for i, p_val in zip(committed, p_committed):\n        u_out[i] = 1\n        p_out[i] = p_val\n        \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0050015912,
          "gap_price_rate": 0.0092352062,
          "fitness": 0.0071183987
     },
     {
          "name": "novel_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints: for online units use max(p_min, p_prev - ramp_down) and min(p_max, p_prev + ramp_up); for free-off units use p_min and min(p_max, p_start).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, use lambda iteration to dispatch only must-on units.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by efficiency metric: (startup_cost + a_i + b_i*p_min + c_i*(p_min**2)) / p_min\n   c. If total min output exceeds load, remove non-must units by avoidable cost per MW: (a_i + b_i*p_min + c_i*(p_min**2) + (s_i if free-off)) / p_min\n   d. Dispatch via bisection-based lambda iteration respecting effective bounds\n6. Set non-committed units offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef novel_hybrid_heuristic(units_info, load):\n    current_load = load[0]\n    \n    # Define dispatch helper function\n    def dispatch_units(units, target):\n        lo, hi = -1e6, 1e6\n        n_iter = 100\n        min_sum = sum(unit['eff_min'] for unit in units)\n        max_sum = sum(unit['eff_max'] for unit in units)\n        target_clamped = max(min_sum, min(max_sum, target))\n        \n        for _ in range(n_iter):\n            lam = (lo + hi) / 2.0\n            total_p = 0.0\n            for unit in units:\n                p = (lam - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else unit['eff_max']\n                p_clamped = max(unit['eff_min'], min(unit['eff_max'], p))\n                total_p += p_clamped\n            \n            if total_p < target_clamped:\n                lo = lam\n            else:\n                hi = lam\n        \n        outputs = []\n        for unit in units:\n            p = (lam - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else unit['eff_max']\n            p_clamped = max(unit['eff_min'], min(unit['eff_max'], p))\n            outputs.append(p_clamped)\n        return outputs\n\n    # Classify units and compute effective bounds\n    units = [unit.copy() for unit in units_info]\n    must_on_indices = []\n    must_off_indices = []\n    free_on_indices = []\n    free_off_indices = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n            else:\n                free_on_indices.append(i)\n        else:\n            unit['eff_min'] = unit['p_min_i']\n            unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                free_off_indices.append(i)\n    \n    # Compute must-on totals\n    must_on_min = sum(units[i]['eff_min'] for i in must_on_indices)\n    must_on_max = sum(units[i]['eff_max'] for i in must_on_indices)\n    \n    # Case 1: Must-on min exceeds load\n    if must_on_min >= current_load:\n        u_list = [1 if i in must_on_indices else 0 for i in range(len(units))]\n        p_list = [units[i]['eff_min'] if i in must_on_indices else 0.0 for i in range(len(units))]\n        return np.array([u_list, p_list])\n    \n    # Case 2: Must-on covers load\n    if must_on_max >= current_load:\n        must_on_units = [units[i] for i in must_on_indices]\n        dispatch_out = dispatch_units(must_on_units, current_load)\n        u_list = [1 if i in must_on_indices else 0 for i in range(len(units))]\n        p_list = [dispatch_out[must_on_indices.index(i)] if i in must_on_indices else 0.0 for i in range(len(units))]\n        return np.array([u_list, p_list])\n    \n    # Case 3: Need additional units\n    committed_indices = must_on_indices + free_on_indices\n    total_min = must_on_min + sum(units[i]['eff_min'] for i in free_on_indices)\n    total_max = must_on_max + sum(units[i]['eff_max'] for i in free_on_indices)\n    \n    # Add free-off units if needed\n    if total_max < current_load:\n        free_off_candidates = []\n        for i in free_off_indices:\n            cost_at_min = units[i]['a_i'] + units[i]['b_i']*units[i]['p_min_i'] + units[i]['c_i']*(units[i]['p_min_i']**2)\n            efficiency = (units[i]['s_i'] + cost_at_min) / units[i]['p_min_i']\n            free_off_candidates.append((i, efficiency))\n        free_off_candidates.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_off_candidates:\n            committed_indices.append(idx)\n            total_max += units[idx]['eff_max']\n            total_min += units[idx]['eff_min']\n            if total_max >= current_load:\n                break\n    \n    # Remove non-must units if min too high\n    if total_min > current_load:\n        non_must = [i for i in committed_indices if i not in must_on_indices]\n        avoidable_costs = []\n        for i in non_must:\n            cost_at_min = units[i]['a_i'] + units[i]['b_i']*units[i]['p_min_i'] + units[i]['c_i']*(units[i]['p_min_i']**2)\n            if units[i]['u_i_0'] == 0:\n                cost_at_min += units[i]['s_i']\n            avoidable_per_mw = cost_at_min / units[i]['p_min_i']\n            avoidable_costs.append((i, avoidable_per_mw))\n        avoidable_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        temp_committed = set(committed_indices)\n        for i, _ in avoidable_costs:\n            new_total_min = total_min - units[i]['eff_min']\n            new_total_max = total_max - units[i]['eff_max']\n            if new_total_min <= current_load or new_total_max < current_load:\n                continue\n            temp_committed.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_min <= current_load:\n                break\n        committed_indices = list(temp_committed)\n    \n    # Dispatch committed units\n    committed_units = [units[i] for i in committed_indices]\n    dispatch_out = dispatch_units(committed_units, current_load)\n    \n    # Prepare final schedule\n    u_list = [0] * len(units)\n    p_list = [0.0] * len(units)\n    for idx, unit_idx in enumerate(committed_indices):\n        u_list[unit_idx] = 1\n        p_list[unit_idx] = dispatch_out[idx]\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0089176296,
          "fitness": 0.007173083
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot switch off due to min-up/shutdown constraints), must-off (cannot switch on due to min-down constraints), free-on (online units with switching flexibility), and free-off (offline units with switching flexibility).\n2. Compute effective min/max outputs:\n   - Online units: min_eff = max(p_min_i, p_i_0 - p_down_i), max_eff = min(p_max_i, p_i_0 + p_up_i)\n   - Free-off units: min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n   - Must-off units: min_eff = 0, max_eff = 0\n3. Handle must-on feasibility:\n   - If must-on min_eff sum > load: commit must-on at min_eff (over-generation)\n   - Else if must-on max_eff sum >= load: set committed = must-on\n   - Else: initially commit must-on + free-on. If capacity insufficient, add free-off units by ascending order of (startup_cost + cost_at_min_output)/min_output. If total min_eff > load, remove non-must units by highest avoidable_cost_per_MW while ensuring capacity feasibility.\n4. Dispatch committed units:\n   - If total min_eff > load: over-generate at min_eff\n   - Else: perform lambda-iteration (bisection) for economic dispatch, handling quadratic cost functions analytically and linear costs via thresholding\n5. Set non-committed units to offline (u_i=0, p_i=0) and return schedule\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    n = len(units_info)\n    units = [u.copy() for u in units_info]\n    for i, u in enumerate(units):\n        u['index'] = i\n    \n    # Step 1: Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            off_periods = -unit['t_i_0']  # Convert to positive offline count\n            if off_periods < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # Step 2: Compute effective min/max outputs\n    for unit in units:\n        if unit in must_off:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n        elif unit['u_i_0'] == 1:  # Online units\n            min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_eff'] = min_eff\n            unit['max_eff'] = max_eff\n        else:  # Free-off units\n            min_eff = unit['p_min_i']\n            max_eff = min(unit['p_max_i'], unit['p_start_i'])\n            unit['min_eff'] = min_eff\n            unit['max_eff'] = max_eff\n    \n    load_current = load[0]  # Current load to allocate\n    committed = []\n    \n    # Step 3.1: Handle must-on feasibility\n    total_min_must = sum(u['min_eff'] for u in must_on)\n    total_max_must = sum(u['max_eff'] for u in must_on)\n    \n    if total_min_must > load_current:\n        committed = must_on  # Over-generation case\n    elif total_max_must >= load_current:\n        committed = must_on  # Dispatch only must-on\n    else:\n        # Start with must-on + free-on\n        committed = must_on + free_on\n        total_min_comm = total_min_must + sum(u['min_eff'] for u in free_on)\n        total_max_comm = total_max_must + sum(u['max_eff'] for u in free_on)\n        \n        # Add free-off units if capacity insufficient\n        if total_max_comm < load_current:\n            # Sort by cost efficiency: (startup + cost_at_min_output)/min_output\n            free_off.sort(key=lambda u: \n                (u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff'] \n                if u['min_eff'] > 0 else float('inf'))\n            for unit in free_off:\n                if total_max_comm >= load_current:\n                    break\n                committed.append(unit)\n                total_min_comm += unit['min_eff']\n                total_max_comm += unit['max_eff']\n        \n        # Remove non-must units if minimum outputs exceed load\n        if total_min_comm > load_current:\n            non_must = [u for u in committed if u not in must_on]\n            # Compute avoidable cost per MW\n            for u in non_must:\n                if u in free_off:\n                    cost = u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2\n                else:  # free_on\n                    cost = u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2\n                u['avoidable_per_mw'] = cost / u['min_eff'] if u['min_eff'] > 0 else float('inf')\n            \n            # Sort descending by avoidable_per_mw\n            non_must.sort(key=lambda u: u['avoidable_per_mw'], reverse=True)\n            \n            # Remove units while preserving feasibility\n            removed = []\n            for unit in non_must:\n                if total_min_comm - unit['min_eff'] <= load_current and total_max_comm - unit['max_eff'] >= load_current:\n                    committed.remove(unit)\n                    total_min_comm -= unit['min_eff']\n                    total_max_comm -= unit['max_eff']\n                    removed.append(unit)\n                    if total_min_comm <= load_current:\n                        break\n    \n    # Dispatch preparation\n    u_out = [0] * n\n    p_out = [0] * n\n    total_min_comm = sum(u['min_eff'] for u in committed)\n    \n    if total_min_comm > load_current or len(committed) == 0:\n        # Over-generation or no units\n        for unit in committed:\n            p_out[unit['index']] = unit['min_eff']\n            u_out[unit['index']] = 1\n    else:\n        # Step 4: Lambda-iteration dispatch\n        low_lambda = float('inf')\n        high_lambda = -float('inf')\n        \n        # Find initial lambda bounds\n        for u in committed:\n            if u['c_i'] == 0:  # Linear unit\n                mc = u['b_i']\n            else:  # Quadratic unit\n                mc_min = 2 * u['c_i'] * u['min_eff'] + u['b_i']\n                mc_max = 2 * u['c_i'] * u['max_eff'] + u['b_i']\n                mc = max(mc_min, mc_max)\n            high_lambda = max(high_lambda, mc)\n            low_lambda = min(low_lambda, u['b_i'])  # Linear cost or marginal at min\n        \n        # Lambda bisection algorithm\n        tolerance = 1e-5\n        for _ in range(100):  # Max iterations\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0\n            for unit in committed:\n                if unit['c_i'] == 0:  # Linear\n                    p = unit['max_eff'] if unit['b_i'] <= mid_lambda else unit['min_eff']\n                else:  # Quadratic\n                    p_unbound = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p = max(unit['min_eff'], min(unit['max_eff'], p_unbound))\n                unit['p_temp'] = p\n                total_power += p\n            \n            if abs(total_power - load_current) < tolerance:\n                break\n            elif total_power < load_current:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Assign final dispatch values\n        for unit in committed:\n            p_out[unit['index']] = unit['p_temp']\n            u_out[unit['index']] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0089176297,
          "fitness": 0.0071730836
     },
     {
          "name": "optimized_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on with feasible startup constraints).\n2. Compute effective min/max outputs for online units considering ramp constraints and startup limits for free-off units.\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, commit only must-on units and use lambda iteration for dispatch.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by cost-efficiency if capacity is insufficient\n   c. Remove non-must units by avoidable cost per MW if min output exceeds load while maintaining feasibility\n6. Dispatch load using lambda iteration on committed units to minimize cost under constraints\n7. Set non-committed units to offline state (u=0, p=0)\n",
          "code": "import numpy as np\nimport heapq\n\ndef optimized_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u0 == 1 and ((t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif u0 == 0 and t0 > -unit['t_off_min_i']:  # t0 is negative for offline\n            must_off.append(i)\n        # Free-on\n        elif u0 == 1:\n            free_on.append(i)\n        # Free-off (with startup feasibility)\n        elif u0 == 0 and unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n            free_off.append(i)\n    \n    # Prepare unit dictionaries for processing\n    for i, unit in enumerate(units_info):\n        # Compute effective min/max for all relevant units\n        if i in must_on or i in free_on:\n            unit['min_eff'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            unit['min_eff'] = unit['p_min_i']\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n    \n    # Step 3: Check if must-on can cover alone (over-generation)\n    must_on_min_sum = sum(units_info[i]['min_eff'] for i in must_on)\n    must_on_max_sum = sum(units_info[i]['max_eff'] for i in must_on)\n    \n    if must_on_min_sum >= current_load:\n        committed = must_on\n        for i in committed:\n            units_info[i]['p_i'] = units_info[i]['min_eff']\n            units_info[i]['u_i'] = 1\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 4: Must-on coverage\n    elif must_on_max_sum >= current_load:\n        committed = must_on\n        dispatch_with_lambda(units_info, committed, current_load)\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 5: General case\n    else:\n        committed = must_on + free_on\n        total_min = sum(units_info[i]['min_eff'] for i in committed)\n        total_max = sum(units_info[i]['max_eff'] for i in committed)\n        \n        # Step 5b: Add free-off units if needed\n        if total_max < current_load and free_off:\n            # Calculate cost efficiency: (startup + fixed + variable) / min_output\n            cost_efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                total_cost = unit['s_i'] + cost_at_min\n                cost_efficiency.append((total_cost / min_eff, i))\n            \n            # Sort by cost efficiency (lowest first)\n            cost_efficiency.sort(key=lambda x: x[0])\n            \n            # Add units until capacity meets load\n            for _, i in cost_efficiency:\n                if total_max >= current_load:\n                    break\n                unit = units_info[i]\n                committed.append(i)\n                total_min += unit['min_eff']\n                total_max += unit['max_eff']\n        \n        # Step 5c: Remove non-must units if over-committed\n        if total_min > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            \n            # Calculate avoidable cost per MW (higher is better to remove)\n            avoidable_costs = []\n            for i in non_must:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                \n                if i in free_off:  # Can avoid startup cost\n                    avoidable_cost = unit['s_i'] + cost_at_min\n                else:  # Free-on units avoid only fuel cost\n                    avoidable_cost = cost_at_min\n                \n                avoidable_costs.append((avoidable_cost / min_eff, i))\n            \n            # Sort by avoidable cost per MW (highest first)\n            avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n            \n            # Try removing units starting with highest avoidable cost\n            for cost_per_mw, i in avoidable_costs:\n                unit = units_info[i]\n                new_total_max = total_max - unit['max_eff']\n                # Only remove if capacity remains sufficient\n                if new_total_max >= current_load:\n                    committed.remove(i)\n                    total_min -= unit['min_eff']\n                    total_max = new_total_max\n                if total_min <= current_load:\n                    break\n        \n        # Step 6: Dispatch with lambda iteration\n        dispatch_with_lambda(units_info, committed, current_load)\n        \n        # Set uncommitted units to offline\n        for i in range(num_units):\n            if i not in committed:\n                units_info[i]['u_i'] = 0\n                units_info[i]['p_i'] = 0\n        \n        return prepare_output(units_info)\n\ndef dispatch_with_lambda(units, committed, load):\n    if not committed:\n        return\n    \n    # Get effective min/max sum\n    total_min = sum(units[i]['min_eff'] for i in committed)\n    total_max = sum(units[i]['max_eff'] for i in committed)\n    \n    # Case 1: Over-generation (output at min_eff)\n    if total_min >= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['min_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 2: Under-generation (output at max_eff)\n    if total_max <= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['max_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 3: Lambda iteration for exact dispatch\n    # Initialize lambda bounds\n    low = min(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['min_eff'] for i in committed)\n    high = max(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['max_eff'] for i in committed)\n    tol = 0.1  # Tolerance for convergence (MW)\n    \n    # Binary search for optimal lambda\n    while high - low > 1e-6:\n        mid = (low + high) / 2\n        total_output = 0\n        \n        # Calculate outputs at current lambda\n        for i in committed:\n            unit = units[i]\n            # Unconstrained output\n            p = (mid - unit['b_i']) / (2 * unit['c_i'])\n            # Apply constraints\n            p = max(unit['min_eff'], min(p, unit['max_eff']))\n            total_output += p\n        \n        # Adjust lambda based on total output\n        if total_output < load:\n            low = mid\n        else:\n            high = mid\n    \n    # Set final outputs\n    total_output = 0\n    for i in committed:\n        unit = units[i]\n        p = (low - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['min_eff'], min(p, unit['max_eff']))\n        unit['p_i'] = p\n        unit['u_i'] = 1\n        total_output += p\n\ndef prepare_output(units_info):\n    u_i = [unit['u_i'] for unit in units_info]\n    p_i = [unit['p_i'] for unit in units_info]\n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.0054285791,
          "gap_price_rate": 0.0089176009,
          "fitness": 0.00717309
     },
     {
          "name": "refined_novel_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on). \n2. Compute effective min/max outputs considering ramp constraints: for online units use max(p_min, p_prev - ramp_down) and min(p_max, p_prev + ramp_up); for free-off units use p_min and min(p_max, p_start).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, use lambda iteration to dispatch only must-on units.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by efficiency metric until capacity meets load: prioritize units with lowest (startup_cost + a_i + b_i*min_output + c_i*(min_output**2))/min_output\n   c. If total min output exceeds load, remove non-must units by highest avoidable cost per MW: (a_i + b_i*min_output + c_i*(min_output**2) + (s_i if free-off))/min_output while ensuring remaining set can still meet load\n   d. Dispatch via lambda iteration with bounds respecting and greedy residual adjustment\n6. Set non-committed units offline (u=0, p=0)\n",
          "code": "import numpy as np\nfrom heapq import heappush, heappop\n\ndef refined_novel_hybrid_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedule = np.zeros((2, n_units))\n    \n    # 1. Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Was online\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # 2. Compute effective min/max outputs\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if i in must_off:\n            eff_min[i], eff_max[i] = 0, 0\n        elif i in free_off:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # must_on or free_on\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # 3. Over-generation case\n    must_on_min_sum = sum(eff_min[i] for i in must_on)\n    must_on_max_sum = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min_sum > current_load:\n        committed = must_on\n        for i in committed:\n            schedule[0][i] = 1\n            schedule[1][i] = eff_min[i]\n        return schedule\n    \n    # 4. Must-on coverage case\n    if must_on_max_sum >= current_load:\n        committed = must_on\n    else:\n        # 5a. Initial commitment\n        committed = must_on + free_on\n        total_min = sum(eff_min[i] for i in committed)\n        total_max = sum(eff_max[i] for i in committed)\n        \n        # 5b. Add free-off units if needed\n        if total_max < current_load:\n            # Priority queue: (efficiency, index)\n            eff_queue = []\n            for i in free_off:\n                if units_info[i]['c_i'] > 0:\n                    cost_at_min = (units_info[i]['a_i'] + \n                                 units_info[i]['b_i'] * eff_min[i] + \n                                 units_info[i]['c_i'] * (eff_min[i]**2))\n                else:\n                    cost_at_min = units_info[i]['b_i'] * eff_min[i]\n                efficiency = (units_info[i]['s_i'] + cost_at_min) / eff_min[i]\n                heappush(eff_queue, (efficiency, i))\n            \n            while eff_queue and total_max < current_load:\n                _, unit_idx = heappop(eff_queue)\n                committed.append(unit_idx)\n                total_min += eff_min[unit_idx]\n                total_max += eff_max[unit_idx]\n        \n        # 5c. Remove excess non-must units\n        if total_min > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            # Calculate avoidable cost\n            avoid_costs = []\n            for i in non_must:\n                u_type = 'free_off' if i in free_off else 'free_on'\n                if units_info[i]['c_i'] > 0:\n                    cost_at_min = (units_info[i]['a_i'] + \n                                 units_info[i]['b_i'] * eff_min[i] + \n                                 units_info[i]['c_i'] * (eff_min[i]**2))\n                else:\n                    cost_at_min = units_info[i]['b_i'] * eff_min[i]\n                    \n                avoid_cost = cost_at_min\n                if u_type == 'free_off':\n                    avoid_cost += units_info[i]['s_i']\n                avoid_costs.append((avoid_cost / eff_min[i], i))\n            \n            avoid_costs.sort(reverse=True)\n            \n            for cost_per_mw, i in avoid_costs:\n                # Check feasibility after removal\n                new_min = total_min - eff_min[i]\n                new_max = total_max - eff_max[i]\n                if new_min <= current_load <= new_max or new_max >= current_load:\n                    committed.remove(i)\n                    total_min = new_min\n                    total_max = new_max\n                    if total_min <= current_load:\n                        break\n    \n    # Dispatch phase\n    dispatch_units = []\n    total_min = total_max = 0.0\n    for i in committed:\n        schedule[0][i] = 1\n        dispatch_units.append(i)\n        total_min += eff_min[i]\n        total_max += eff_max[i]\n    \n    if total_min > current_load:  # Over-generation\n        for i in dispatch_units:\n            schedule[1][i] = eff_min[i]\n    else:\n        # Lambda iteration with greedy residual adjustment\n        # Initial setup\n        low_lambda = -1e6\n        high_lambda = 1e6\n        tolerance = 1e-3\n        residual = current_load\n        p_alloc = np.zeros(len(dispatch_units))\n        \n        # Initialize allocation\n        for idx, i in enumerate(dispatch_units):\n            p_alloc[idx] = eff_min[i]\n            residual -= eff_min[i]\n        \n        # Lambda iteration\n        it = 0\n        while abs(residual) > tolerance and it < 1000:\n            it += 1\n            lambda_val = (low_lambda + high_lambda) / 2\n            total_gen = 0.0\n            residual = current_load\n            for idx, i in enumerate(dispatch_units):\n                unit = units_info[i]\n                c_i = unit['c_i']\n                b_i = unit['b_i']\n                p_min = eff_min[i]\n                p_max = eff_max[i]\n                \n                if c_i > 0:  # Quadratic cost\n                    unconstrained = (lambda_val - b_i) / (2 * c_i)\n                    p_alloc[idx] = max(p_min, min(p_max, unconstrained))\n                else:  # Linear cost\n                    p_alloc[idx] = p_max if lambda_val >= b_i else p_min\n                total_gen += p_alloc[idx]\n                residual = current_load - total_gen\n            \n            if residual > 0:\n                low_lambda = lambda_val\n            else:\n                high_lambda = lambda_val\n        \n        # Greedy adjustment for residual\n        residual = current_load - sum(p_alloc)\n        if abs(residual) > tolerance:\n            adjustment_heap = []\n            for idx, i in enumerate(dispatch_units):\n                if residual > 0 and p_alloc[idx] < eff_max[i]:\n                    margin = eff_max[i] - p_alloc[idx]\n                    if margin > 0:\n                        if units_info[i]['c_i'] > 0:\n                            marginal_cost = b_i + 2 * c_i * p_alloc[idx]\n                        else:\n                            marginal_cost = b_i\n                        heappush(adjustment_heap, (marginal_cost, idx, i, margin))\n                elif residual < 0 and p_alloc[idx] > eff_min[i]:\n                    margin = p_alloc[idx] - eff_min[i]\n                    if margin > 0:\n                        if units_info[i]['c_i'] > 0:\n                            marginal_cost = b_i + 2 * c_i * p_alloc[idx]\n                        else:\n                            marginal_cost = b_i\n                        # Use negative margin cost for decreasing\n                        heappush(adjustment_heap, (-marginal_cost, idx, i, margin))\n            \n            while adjustment_heap and abs(residual) > tolerance:\n                cost_val, idx, i, margin = heappop(adjustment_heap)\n                unit = units_info[i]\n                adjust = min(abs(residual), margin)\n                if residual > 0:\n                    p_alloc[idx] += adjust\n                    residual -= adjust\n                else:\n                    p_alloc[idx] -= adjust\n                    residual += adjust\n        \n        # Assign dispatch values\n        for idx, i in enumerate(dispatch_units):\n            schedule[1][i] = max(eff_min[i], min(eff_max[i], p_alloc[idx]))\n    \n    return schedule",
          "from": "mutation",
          "gap_power_rate": 0.005428641,
          "gap_price_rate": 0.0089176319,
          "fitness": 0.0071731365
     },
     {
          "name": "enhanced_hybrid_heuristic",
          "algorithm": "**\n1. Classify units into:\n   - Must-on: Units that cannot be turned off due to minimum up-time violations (`t_i_0 < t_on_min_i`) or shutdown ramp constraints (`p_i_0 > p_shut_i`).\n   - Must-off: Units that cannot be turned on due to minimum down-time violations (`-t_i_0 < t_off_min_i`).\n   - Free-on: Online units that can be turned off.\n   - Free-off: Offline units that can be turned on.\n2. Compute effective min/max outputs:\n   - Online units: `eff_min = max(p_min, p_prev - ramp_down)`, `eff_max = min(p_max, p_prev + ramp_up)`.\n   - Free-off units: `eff_min = p_min`, `eff_max = min(p_max, startup_ramp)`.\n   - Must-off units: `eff_min = 0`, `eff_max = 0`.\n3. Handle cases based on must-on units:\n   - If `sum(must_on_eff_min) > load`: \n     - Commit only must-on units at their `eff_min` (over-generation).\n   - Else if `sum(must_on_eff_max) >= load`:\n     - Commit only must-on units and dispatch load using lambda iteration.\n4. For other cases:\n   - Initially commit must-on and free-on units.\n   - If total max output < load:\n     - Add free-off units sorted by cost efficiency: `(startup_cost + no_load_cost + cost_at_min) / min_output`.\n   - If total min output > load:\n     - Remove non-must units sorted by avoidable cost per MW: `(no_load_cost + cost_at_min + (startup_cost if free-off)) / min_output`).\n5. Dispatch load among committed units:\n   - Use lambda iteration (bisection) respecting effective min/max bounds.\n   - For linear cost units (`c_i=0`), use marginal-cost-based binding.\n   - Apply greedy adjustment to eliminate any residual load mismatch.\n6. Set non-committed units to offline (u_i=0, p_i=0).\n\n**",
          "code": "import numpy as np\n\ndef enhanced_hybrid_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n\n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 2: Compute effective min/max outputs\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in range(n_units):\n        unit = units_info[i]\n        if i in must_on or i in free_on:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            eff_min[i] = 0.0\n            eff_max[i] = 0.0\n\n    total_must_on_min = np.sum(eff_min[must_on])\n    total_must_on_max = np.sum(eff_max[must_on])\n    committed = []\n\n    # Step 3: Handle must-on cases\n    if total_must_on_min > current_load:\n        # Over-generation: commit only must-on at min output\n        committed = must_on\n    elif total_must_on_max >= current_load:\n        # Dispatch only must-on units\n        committed = must_on\n    else:\n        # Step 4: Commit must-on and free-on initially\n        committed = must_on + free_on\n        total_max = total_must_on_max + np.sum(eff_max[free_on])\n        \n        # Add free-off units if needed\n        if total_max < current_load:\n            cost_efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * eff_min[i]**2\n                efficiency = (unit['s_i'] + cost_at_min) / eff_min[i]\n                cost_efficiency.append((efficiency, i))\n            cost_efficiency.sort(key=lambda x: x[0])\n            \n            for eff, i in cost_efficiency:\n                committed.append(i)\n                total_max += eff_max[i]\n                if total_max >= current_load:\n                    break\n        \n        # Remove non-must units if min output exceeds load\n        total_min_committed = np.sum(eff_min[committed])\n        if total_min_committed > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            avoidable_cost = []\n            for i in non_must:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * eff_min[i]**2\n                if i in free_off:\n                    avoidable = (unit['s_i'] + cost_at_min) / eff_min[i]\n                else:\n                    avoidable = cost_at_min / eff_min[i]\n                avoidable_cost.append((avoidable, i))\n            avoidable_cost.sort(key=lambda x: x[0], reverse=True)\n            \n            for cost_val, i in avoidable_cost:\n                new_total_min = total_min_committed - eff_min[i]\n                new_total_max = total_max - eff_max[i]\n                if new_total_max >= current_load:\n                    committed.remove(i)\n                    total_min_committed = new_total_min\n                    total_max = new_total_max\n                    if total_min_committed <= current_load:\n                        break\n    \n    # Step 5: Dispatch using lambda iteration\n    u_vector = np.zeros(n_units)\n    p_vector = np.zeros(n_units)\n    \n    if not committed:\n        return np.array([u_vector, p_vector])\n    \n    # Extract parameters for committed units\n    a_vals = []\n    b_vals = []\n    c_vals = []\n    min_vals = []\n    max_vals = []\n    current_eff_min = []\n    current_eff_max = []\n    for i in committed:\n        unit = units_info[i]\n        a_vals.append(unit['a_i'])\n        b_vals.append(unit['b_i'])\n        c_vals.append(unit['c_i'])\n        current_eff_min.append(eff_min[i])\n        current_eff_max.append(eff_max[i])\n    \n    # Lambda iteration\n    low_lambda = -1e7\n    high_lambda = 1e7\n    tol = 1e-4\n    max_iter = 100\n    iter_count = 0\n    total_min = np.sum(current_eff_min)\n    total_max = np.sum(current_eff_max)\n    \n    if abs(total_min - current_load) < tol:\n        p_committed = current_eff_min\n    elif abs(total_max - current_load) < tol:\n        p_committed = current_eff_max\n    else:\n        n = len(committed)\n        p_committed = current_eff_min.copy()\n        while iter_count < max_iter and high_lambda - low_lambda > tol:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0.0\n            for j in range(n):\n                if c_vals[j] == 0:  # Linear cost\n                    if mid_lambda > b_vals[j]:\n                        p_committed[j] = current_eff_max[j]\n                    else:\n                        p_committed[j] = current_eff_min[j]\n                else:  # Quadratic cost\n                    p_ideal = (mid_lambda - b_vals[j]) / (2 * c_vals[j])\n                    p_committed[j] = max(current_eff_min[j], min(p_ideal, current_eff_max[j]))\n                total_power += p_committed[j]\n            \n            if total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            iter_count += 1\n        \n        # Greedy adjustment for any remaining mismatch\n        total_power = np.sum(p_committed)\n        deficit = current_load - total_power\n        tol_adj = 1e-2\n        if abs(deficit) > tol_adj:\n            if deficit > 0:  # Need to increase output\n                adjustable = []\n                for j in range(n):\n                    if p_committed[j] < current_eff_max[j] - tol_adj:\n                        if c_vals[j] == 0:\n                            marginal_cost = b_vals[j]\n                        else:\n                            marginal_cost = b_vals[j] + 2 * c_vals[j] * p_committed[j]\n                        adjustable.append((marginal_cost, j, current_eff_max[j] - p_committed[j]))\n                adjustable.sort(key=lambda x: x[0])\n                \n                for mc, j, headroom in adjustable:\n                    if deficit <= headroom:\n                        p_committed[j] += deficit\n                        break\n                    else:\n                        p_committed[j] = current_eff_max[j]\n                        deficit -= headroom\n            else:  # Need to decrease output\n                deficit = -deficit\n                adjustable = []\n                for j in range(n):\n                    if p_committed[j] > current_eff_min[j] + tol_adj:\n                        if c_vals[j] == 0:\n                            marginal_cost = b_vals[j]\n                        else:\n                            marginal_cost = b_vals[j] + 2 * c_vals[j] * p_committed[j]\n                        adjustable.append((marginal_cost, j, p_committed[j] - current_eff_min[j]))\n                adjustable.sort(key=lambda x: x[0], reverse=True)\n                \n                for mc, j, headroom in adjustable:\n                    if deficit <= headroom:\n                        p_committed[j] -= deficit\n                        break\n                    else:\n                        p_committed[j] = current_eff_min[j]\n                        deficit -= headroom\n    \n    # Set commitment and output for committed units\n    for idx, i in enumerate(committed):\n        u_vector[i] = 1\n        p_vector[i] = p_committed[idx]\n    \n    return np.array([u_vector, p_vector])",
          "from": "crossover",
          "gap_power_rate": 0.0054291016,
          "gap_price_rate": 0.0089174966,
          "fitness": 0.0071732991
     }
]