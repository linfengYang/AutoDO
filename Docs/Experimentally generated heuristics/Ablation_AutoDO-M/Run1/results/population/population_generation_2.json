[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                u[i] = 1\n                \n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in must_run_indices:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    total_min_must = np.sum(eff_min[must_run_indices])\n    total_max_must = np.sum(eff_max[must_run_indices])\n    \n    if total_min_must > current_load:\n        for i in must_run_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    if total_max_must >= current_load:\n        committed_indices = must_run_indices\n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    candidate_indices.append(i)\n                    \n        candidate_info = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                emin = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                emax = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['b_i'] + unit['c_i'] * emin) / emin\n            else:\n                emin = unit['p_min_i']\n                emax = min(unit['p_max_i'], unit['p_start_i'])\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                cost_per_mw = (startup_cost + unit['a_i'] + unit['b_i'] * emin + unit['c_i'] * emin**2) / emin\n            candidate_info.append((i, emin, emax, cost_per_mw))\n        \n        candidate_info.sort(key=lambda x: x[3])\n        committed_indices = must_run_indices.copy()\n        total_min_curr = total_min_must\n        total_max_curr = total_max_must\n        for i, emin, emax, _ in candidate_info:\n            if total_max_curr >= current_load:\n                break\n            committed_indices.append(i)\n            total_min_curr += emin\n            total_max_curr += emax\n        \n        for i in committed_indices:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                eff_min[i] = units_info[i]['p_min_i']\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min_committed = sum(eff_min[i] for i in committed_indices)\n    if total_min_committed > current_load:\n        for i in committed_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    b = []\n    c = []\n    lows = []\n    highs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n        lows.append(eff_min[i])\n        highs.append(eff_max[i])\n    \n    n_committed = len(committed_indices)\n    p_alloc = np.array(lows)\n    if abs(total_min_committed - current_load) < 1e-5:\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_alloc[idx]\n        return np.array([u, p])\n    \n    if n_committed == 0:\n        return np.array([u, p])\n    \n    low_lambda = min(b_i + 2 * c_i * low for b_i, c_i, low in zip(b, c, lows))\n    high_lambda = max(b_i + 2 * c_i * high for b_i, c_i, high in zip(b, c, highs))\n    tolerance = 1e-5\n    \n    for _ in range(1000):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for k in range(n_committed):\n            if c[k] == 0:\n                p_alloc[k] = highs[k] if mid_lambda >= b[k] else lows[k]\n            else:\n                p_val = (mid_lambda - b[k]) / (2 * c[k])\n                p_alloc[k] = np.clip(p_val, lows[k], highs[k])\n            total_p += p_alloc[k]\n        \n        if total_p < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tolerance:\n            diff = current_load - total_p\n            if diff > 0:\n                idx_min = np.argmin(np.array([b_i + 2*c_i*p_i for b_i, c_i, p_i in zip(b, c, p_alloc)]))\n                p_alloc[idx_min] = min(highs[idx_min], p_alloc[idx_min] + diff)\n            break\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_alloc[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054289451,
          "gap_price_rate": 0.0090732546,
          "fitness": 0.0072510999
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs for all units considering ramp constraints (current units use ramp limits, new starts use startup ramp limits).\n3. If must-on units' min output exceeds current load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, dispatch only among must-on units.\n5. Else:\n   a. Activate free-off units by cost-efficiency (startup cost + cost at min output)/min output until capacity meets load\n   b. If total min output of committed set exceeds load:\n      - Remove free units (free-on/new starts) with highest saving per MW while maintaining capacity and shutdown feasibility\n6. Perform greedy dispatch:\n   a. Initialize outputs at effective min\n   b. Increase outputs of units with lowest marginal cost first using min-heap\n   c. Respect ramp and output constraints during allocation\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize commitment states and power outputs\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n            eff_min[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            eff_max[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n                eff_min[idx] = 0.0\n                eff_max[idx] = 0.0\n            else:\n                free_off.append(idx)\n                eff_min[idx] = unit['p_min_i']\n                eff_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3-5: Commitment logic\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        committed = set(must_on)\n    elif must_on_max >= current_load:\n        committed = set(must_on)\n    else:\n        committed = set(must_on) | set(free_on)\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Activate free-off units\n        free_off_sorted = sorted(free_off, key=lambda i: \n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * eff_min[i] + \n             units_info[i]['c_i'] * eff_min[i] ** 2) / eff_min[i])\n        \n        for idx in free_off_sorted:\n            if total_max >= current_load:\n                break\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n            committed.add(idx)\n        \n        # Remove over-committed free units\n        if total_min > current_load:\n            removal_candidates = []\n            for idx in committed:\n                if idx in must_on:\n                    continue\n                if units_info[idx]['u_i_0'] == 1:\n                    if units_info[idx]['p_i_0'] > units_info[idx]['p_shut_i']:\n                        continue\n                    saving = (units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                else:\n                    saving = (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                removal_candidates.append((saving, idx))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            for saving, idx in removal_candidates:\n                if total_min <= current_load:\n                    break\n                if (total_max - eff_max[idx]) >= current_load:\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    committed.remove(idx)\n    \n    # Step 6: Dispatch\n    total_output = 0.0\n    for idx in committed:\n        p[idx] = eff_min[idx]\n        total_output += eff_min[idx]\n        u[idx] = 1\n    \n    deficit = current_load - total_output\n    if deficit > 0:\n        heap = []\n        for idx in committed:\n            if p[idx] < eff_max[idx]:\n                room = eff_max[idx] - p[idx]\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (mc, idx, room))\n        \n        while deficit > 0 and heap:\n            mc, idx, room = heapq.heappop(heap)\n            inc = min(room, deficit)\n            p[idx] += inc\n            deficit -= inc\n            total_output += inc\n            \n            # Update remaining room and marginal cost\n            new_room = eff_max[idx] - p[idx]\n            if new_room > 0:\n                new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (new_mc, idx, new_room))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0101961532,
          "fitness": 0.007526636
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs for must-on and free-on units considering ramp constraints. For free-off units if activated, use startup ramp limits.  \n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).  \n4. Else if must-on units can cover load, optimize dispatch only among must-on units.  \n5. Else, activate free-on and free-off candidates sorted by cost-efficiency (startup + min-output cost)/min-output), selecting until total max capacity meets load.  \n6. If the min output of committed units exceeds load, remove most expensive/least flexible candidates while maintaining capacity.  \n7. Dispatch load among committed units:  \n   - Initialize outputs at effective min  \n   - Increase cheapest units' output when below load  \n   - Decrease most expensive units' output when above load  \n   - Respect ramp and output constraints during dispatch  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    enhanced_units = []\n    \n    # Classify units and compute parameters\n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_up, p_down = unit['p_up_i'], unit['p_down_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        prev_u, prev_p, prev_t = unit['u_i_0'], unit['p_i_0'], unit['t_i_0']\n        \n        # Determine category\n        if prev_u == 1:\n            if prev_t < t_on_min or prev_p > p_shut:\n                category = 'must_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n            else:\n                category = 'free_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n        else:\n            if -prev_t < t_off_min:\n                category = 'must_off'\n                eff_min = eff_max = 0\n            else:\n                category = 'free_off'\n                eff_min = p_min\n                eff_max = min(p_max, p_start)\n        enhanced_units.append({\n            'index': i,\n            'category': category,\n            'eff_min': eff_min,\n            'eff_max': eff_max,\n            's_i': s_i,\n            'p_min': p_min,\n            'a_i': a_i, 'b_i': b_i, 'c_i': c_i\n        })\n    \n    # Separate units into categories\n    must_on = [u for u in enhanced_units if u['category'] == 'must_on']\n    must_off = [u for u in enhanced_units if u['category'] == 'must_off']\n    free_on = [u for u in enhanced_units if u['category'] == 'free_on']\n    free_off = [u for u in enhanced_units if u['category'] == 'free_off']\n    \n    # Initialize with must-on units\n    total_min = sum(u['eff_min'] for u in must_on)\n    total_max = sum(u['eff_max'] for u in must_on)\n    committed = must_on.copy()\n    \n    if total_min > current_load:\n        # Case 1: Must-on over-generation\n        for u in must_on:\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = u['eff_min']\n    elif total_max >= current_load:\n        # Case 2: Dispatch among must-on\n        if must_on:\n            p_values = [u['eff_min'] for u in must_on]\n            remaining = current_load - total_min\n            while abs(remaining) > 1e-5:\n                # Increase phase\n                while remaining > 1e-5:\n                    best_idx, best_mc = -1, float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] < u['eff_max']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc < best_mc:\n                                best_mc, best_idx = mc, j\n                    if best_idx == -1: break\n                    inc = min(remaining, must_on[best_idx]['eff_max'] - p_values[best_idx])\n                    p_values[best_idx] += inc\n                    remaining -= inc\n                # Decrease phase\n                while remaining < -1e-5:\n                    worst_idx, worst_mc = -1, -float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] > u['eff_min']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc > worst_mc:\n                                worst_mc, worst_idx = mc, j\n                    if worst_idx == -1: break\n                    dec = min(-remaining, p_values[worst_idx] - must_on[worst_idx]['eff_min'])\n                    p_values[worst_idx] -= dec\n                    remaining += dec\n            for u, p_val in zip(must_on, p_values):\n                i = u['index']\n                schedules[0, i] = 1\n                schedules[1, i] = p_val\n    else:\n        # Case 3: Need more capacity\n        candidates = []\n        # Free-on candidates\n        for u in free_on:\n            min_out = u['eff_min']\n            cost_per_mw = (u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Free-off candidates\n        for u in free_off:\n            min_out = u['eff_min']\n            cost_per_mw = (u['s_i'] + u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Sort by cost efficiency then min output\n        candidates.sort(key=lambda x: (x[1], x[2]))\n        \n        # Add candidates until capacity meets demand\n        added_candidates = []\n        for candidate in candidates:\n            if total_max < current_load:\n                u, _, min_out, max_out = candidate\n                added_candidates.append(candidate)\n                committed.append(u)\n                total_min += min_out\n                total_max += max_out\n        \n        # Remove over-committed candidates\n        added_candidates.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n        i = 0\n        while i < len(added_candidates) and total_min > current_load:\n            u, _, min_out, max_out = added_candidates[i]\n            if total_max - max_out >= current_load:\n                committed.remove(u)\n                added_candidates.pop(i)\n                total_min -= min_out\n                total_max -= max_out\n            else:\n                i += 1\n        \n        # Dispatch among committed units\n        p_values = []\n        bounds = []\n        for u in committed:\n            if u['category'] in ['must_on', 'free_on']:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            else:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            p_values.append(eff_min)\n            bounds.append((eff_min, eff_max))\n        remaining = current_load - sum(p_values)\n        \n        # Increase outputs for under-generation\n        while remaining > 1e-5:\n            best_idx, best_mc = -1, float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] < high:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc < best_mc:\n                        best_mc, best_idx = mc, j\n            if best_idx == -1: \n                break\n            inc = min(remaining, bounds[best_idx][1] - p_values[best_idx])\n            p_values[best_idx] += inc\n            remaining -= inc\n        \n        # Decrease outputs for over-generation\n        while remaining < -1e-5:\n            worst_idx, worst_mc = -1, -float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] > low:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc > worst_mc:\n                        worst_mc, worst_idx = mc, j\n            if worst_idx == -1: \n                break\n            dec = min(-remaining, p_values[worst_idx] - bounds[worst_idx][0])\n            p_values[worst_idx] -= dec\n            remaining += dec\n        \n        # Apply scheduled outputs\n        for u, p_val in zip(committed, p_values):\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = p_val\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "commit_units_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (violating min up-time or shutdown ramp), must-off (violating min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Initialize commitments: must-on and free-on committed, must-off and free-off decommitted.\n3. Compute effective min/max outputs considering ramp constraints: \n   - For units remaining online: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - For units starting: [p_min, min(p_max, start_ramp)]\n4. If total min output > load:\n   - Identify eligible free-on units (p_prev <= shutdown ramp)\n   - Turn off units by largest min output then highest operating cost\n   - Recompute min/max totals\n5. If total max output < load:\n   - Identify eligible free-off units (can be started)\n   - Turn on units by lowest average cost (startup+min_cost)/min_output then highest effective max output\n   - Recompute min/max totals\n6. Dispatch load:\n   a. Set committed units to effective min outputs\n   b. Distribute remaining load using marginal cost priority with heap-based greedy algorithm:\n      i. Place each unit's marginal cost (b_i + 2*c_i*p_i) and room in a min-heap\n      ii. Increase cheapest unit until room or load exhausted\n      iii. Update heap after each change\n7. Return schedules: commitment states and power outputs.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef commit_units_hybrid_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    effective_min = [0] * n_units\n    effective_max = [0] * n_units\n    \n    # Classify units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if t0 > -unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n        # Initialize commitment\n        if must_on[i] or free_on[i]:\n            u[i] = 1\n        else:\n            u[i] = 0\n            \n    # Set effective min/max\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:  # Already online\n                min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n            effective_min[i] = min_val\n            effective_max[i] = max_val\n        else:\n            effective_min[i] = 0\n            effective_max[i] = 0\n            \n    total_min = sum(effective_min)\n    total_max = sum(effective_max)\n    \n    # Step 4: Turn off free-on units if over-committed\n    free_on_eligible = [i for i in range(n_units) if free_on[i] and u[i]==1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']]\n    def cost_at_min(i):\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        p_min = effective_min[i]\n        return a + b * p_min + c * p_min * p_min\n    free_on_eligible.sort(key=lambda i: (effective_min[i], -cost_at_min(i)), reverse=True)\n    \n    for i in free_on_eligible:\n        if total_min <= current_load:\n            break\n        u[i] = 0\n        total_min -= effective_min[i]\n        total_max -= effective_max[i]\n        effective_min[i] = 0\n        effective_max[i] = 0\n        \n    # Step 5: Turn on free-off units if under-committed\n    free_off_eligible = [i for i in range(n_units) if free_off[i] and u[i]==0]\n    def avg_cost(i):\n        a, b, c, s = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i']\n        p_min = units_info[i]['p_min_i']\n        return (a + b * p_min + c * p_min * p_min + s) / p_min\n    free_off_eligible.sort(key=lambda i: (avg_cost(i), -min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])))\n    \n    for i in free_off_eligible:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 6: Dispatch\n    p_out = [0.0] * n_units\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    # Initial allocation at effective min\n    for i in committed_indices:\n        p_out[i] = effective_min[i]\n    total_current = sum(p_out)\n    remaining = current_load - total_current\n    \n    # Heap-based dispatch for remaining load\n    if remaining > 1e-8:\n        heap = []\n        for i in committed_indices:\n            room = effective_max[i] - effective_min[i]\n            if room > 1e-8:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                heapq.heappush(heap, (marginal_cost, i, room))\n        \n        while heap and remaining > 1e-8:\n            mc, i, room = heapq.heappop(heap)\n            delta = min(remaining, room)\n            p_out[i] += delta\n            remaining -= delta\n            new_room = room - delta\n            \n            if new_room > 1e-8:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                heapq.heappush(heap, (new_mc, i, new_room))\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u[i]\n        schedules[1, i] = p_out[i] if u[i] == 1 else 0.0\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "enhanced_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online and can turn off), free-off (offline and can turn on)\n  2. Initialize commitments: must-on and free-on committed\n  3. Compute effective min/max outputs for committed units considering ramp constraints:\n        - Already online: [max(p_min, p_prev - p_down), min(p_max, p_prev + p_up)]\n        - New startups: [p_min, min(p_max, p_start)]\n  4. Remove over-committed free-on units (prioritized by highest operating cost per MW then largest min output) until total_min \u2264 load\n  5. Add free-off units (prioritized by lowest startup+min_cost per MW then largest max output) until total_max \u2265 load\n  6. Set outputs to effective min values\n  7. Distribute remaining load (>0) to units with cheapest marginal cost via heap-based greedy allocation in 1 MW steps\n  8. Format output schedules (commitment states and power outputs)\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_hybrid_heuristic(units_info, load):\n    current_load = load[0]  # Extract current period load\n    n_units = len(units_info)\n    \n    # Initialize classification lists\n    must_on, must_off, free_on, free_off = [], [], [], []\n    committed_units = []\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Was online\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Was offline\n            if t_i0 < 0 and -t_i0 < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 2: Initialize commitments\n    committed_units = must_on + free_on\n    for i in committed_units:\n        units_info[i]['u_i'] = 1\n    for i in must_off + free_off:\n        units_info[i]['u_i'] = 0\n    \n    # Step 3: Compute effective min/max for initial committed units\n    effective_min = {}\n    effective_max = {}\n    total_min = 0\n    total_max = 0\n    \n    for i in committed_units:\n        unit = units_info[i]\n        min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 4: Remove over-committed free-on units\n    remove_list = []\n    candidate_remove = [\n        (i, \n         (unit['a_i'] + unit['b_i']*effective_min[i] + unit['c_i']*(effective_min[i]**2)) / effective_min[i],\n         effective_min[i])\n        for i in free_on\n    ]\n    candidate_remove.sort(key=lambda x: (x[1], x[2]), reverse=True)  # Desc: cost/MW then min output\n    \n    for i, _, min_val in candidate_remove:\n        if total_min <= current_load:\n            break\n        remove_list.append(i)\n        total_min -= effective_min[i]\n        total_max -= effective_max[i]\n    \n    # Update commitment for removed units\n    for i in remove_list:\n        units_info[i]['u_i'] = 0\n    committed_units = [i for i in committed_units if i not in remove_list]\n    \n    # Step 5: Add free-off units if under-committed\n    add_list = []\n    candidate_add = []\n    for i in free_off:\n        unit = units_info[i]\n        min_val = unit['p_min_i']\n        max_val = min(unit['p_max_i'], unit['p_start_i'])\n        min_cost = unit['a_i'] + unit['b_i']*min_val + unit['c_i']*(min_val**2)\n        cost_per_MW = (unit['s_i'] + min_cost) / min_val\n        candidate_add.append((i, cost_per_MW, max_val))\n    \n    candidate_add.sort(key=lambda x: (x[1], -x[2]))  # Asc: cost/MW, then desc max output\n    \n    for i, cost_per_MW, max_val in candidate_add:\n        if total_max >= current_load:\n            break\n        add_list.append(i)\n        min_val = units_info[i]['p_min_i']\n        total_min += min_val\n        total_max += max_val\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n    \n    # Update commitment for added units\n    for i in add_list:\n        units_info[i]['u_i'] = 1\n    committed_units += add_list\n    \n    # Step 6: Set initial outputs to effective min\n    current_outputs = {}\n    for i in committed_units:\n        current_outputs[i] = effective_min[i]\n    \n    # Step 7: Dispatch remaining load (>0) using heap\n    remaining = current_load - total_min\n    if remaining > 0:\n        heap = []\n        for i in committed_units:\n            unit = units_info[i]\n            p_current = current_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_current\n            room = effective_max[i] - p_current\n            if room > 0:\n                heapq.heappush(heap, (marginal_cost, i, room))\n        \n        while remaining > 0 and heap:\n            cost, i, room = heapq.heappop(heap)\n            allocate = min(remaining, 1.0, room)  # 1 MW step\n            current_outputs[i] += allocate\n            remaining -= allocate\n            room -= allocate\n            \n            # Update marginal cost and push back if room remains\n            if room > 0:\n                unit = units_info[i]\n                p_new = current_outputs[i]\n                new_cost = unit['b_i'] + 2 * unit['c_i'] * p_new\n                heapq.heappush(heap, (new_cost, i, room))\n    \n    # Step 8: Format output schedules\n    schedules = np.zeros((2, n_units))\n    for i, unit in enumerate(units_info):\n        schedules[0, i] = unit['u_i']\n        if unit['u_i'] == 1:\n            schedules[1, i] = current_outputs[i]\n        else:\n            schedules[1, i] = 0.0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.035706541,
          "fitness": 0.0179181097
     },
     {
          "name": "hybrid_refined_commitment_heuristic",
          "algorithm": "1. Classify units into must-on (units violating minimum up-time/shutdown constraints), must-off (units violating minimum down-time), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup).\n2. Initialize commitment: must-on and free-on units committed; must-off and free-off units decommitted.\n3. Compute effective min/max outputs:\n   - Online units: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - Started units: [p_min, min(p_max, start_ramp)]\n4. Calculate total min/max capacity:\n   - While total_min > load and eligible free-on units exist:\n        - Sort by highest marginal cost at min output\n        - Turn off most expensive eligible free-on unit\n        - Recompute totals\n   - If total_max < load and eligible free-off units exist:\n        - Sort by lowest average cost per MW (startup + min cost)\n        - Turn on cheapest eligible free-off unit until max >= load\n        - Recompute totals\n   - If total_min > load after step 6, repeat step 4\n5. Dispatch load via lambda iteration:\n   - Binary search for lambda setting total output = load\n   - Clamp outputs within effective min/max limits\n6. Return schedules: commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef hybrid_refined_commitment_heuristic(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    schedules = np.zeros((2, n))\n    committed = [False] * n\n    eff_min = [0.0] * n\n    eff_max = [0.0] * n\n    must_on, must_off, free_on, free_off = [], [], [], []\n    \n    # Classify units and set effective limits\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commitment\n    for i in must_on:\n        committed[i] = True\n    for i in free_on:\n        committed[i] = True\n    \n    def compute_totals():\n        total_min = 0.0\n        total_max = 0.0\n        for i in range(n):\n            if committed[i]:\n                total_min += eff_min[i]\n                total_max += eff_max[i]\n        return total_min, total_max\n    \n    total_min, total_max = compute_totals()\n    \n    # Step 4: Turn off expensive free-on units if over-committed\n    def step4():\n        nonlocal total_min, total_max\n        eligible_free_on = [i for i in free_on if committed[i] and eff_min[i] <= unit['p_shut_i']]\n        eligible_free_on.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_min[i], reverse=True)\n        for i in eligible_free_on:\n            if total_min > current_load:\n                committed[i] = False\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n    \n    # Step 6: Turn on cheap free-off units if under-committed\n    def step6():\n        nonlocal total_min, total_max\n        eligible_free_off = [i for i in free_off if not committed[i]]\n        eligible_free_off.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                                               units_info[i]['b_i'] * eff_min[i] + \n                                               units_info[i]['c_i'] * (eff_min[i] ** 2)) / eff_min[i]\n                                      if eff_min[i] > 1e-5 else float('inf'))\n        for i in eligible_free_off:\n            if total_max < current_load:\n                committed[i] = True\n                total_min += eff_min[i]\n                total_max += eff_max[i]\n                if total_max >= current_load:\n                    break\n    \n    step4()\n    if total_max < current_load:\n        step6()\n        step4()  # Re-check over-commitment after adding units\n    \n    # Dispatch using lambda iteration\n    committed_idx = [i for i in range(n) if committed[i]]\n    if committed_idx:\n        # Binary search setup\n        lamb_low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_min[i] for i in committed_idx)\n        lamb_high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_max[i] for i in committed_idx) + 1\n        tol, max_iter = 1e-3, 50\n        # Lambda iteration\n        for _ in range(max_iter):\n            lamb = (lamb_low + lamb_high) / 2\n            total_power = 0\n            for i in committed_idx:\n                p_val = (lamb - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_clamped = max(eff_min[i], min(eff_max[i], p_val))\n                total_power += p_clamped\n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                lamb_low = lamb\n            else:\n                lamb_high = lamb\n        # Set outputs\n        for i in committed_idx:\n            p_val = (lamb - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            schedules[1, i] = max(eff_min[i], min(eff_max[i], p_val))\n    \n    # Set commitment states\n    for i in range(n):\n        schedules[0, i] = 1 if committed[i] else 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001297988,
          "gap_price_rate": 0.0360463149,
          "fitness": 0.0180880569
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must_on (previously online units that violate constraints if turned off), must_off (previously offline units that violate constraints if turned on), free_on (online units that can be safely turned off), and free_off (offline units that can be safely turned on).\n2. Initialize commitments and compute effective min/max outputs for each unit based on ramp limits and online status.\n3. Turn off expensive free_on units when total minimum output exceeds load to reduce over-commitment, prioritizing units with highest cost per MW.\n4. Turn on cheap free_off units when total maximum output falls below load to address under-commitment, prioritizing units with lowest (startup + min-output cost)/min-output.\n5. Perform economic dispatch using bisection to find optimal generation levels for committed units within their constraints.\n6. Return unit commitments and power outputs as a 2D NumPy array.\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online last period\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            # Set initial commitment\n            u[i] = 1\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Offline last period\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n\n    # Calculate initial totals\n    total_min = np.sum(min_eff)\n    total_max = np.sum(max_eff)\n\n    # Turn off free_on units if over-committed\n    if total_min > current_load and free_on:\n        # Calculate cost per MW for sorting\n        cost_per_mw = []\n        for i in free_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i] ** 2\n            cost_per_mw.append(cost / min_eff[i])\n        sorted_free_on = [x for _, x in sorted(zip(cost_per_mw, free_on), reverse=True)]\n        \n        for i in sorted_free_on:\n            if total_min <= current_load:\n                break\n            total_min -= min_eff[i]\n            total_max -= max_eff[i]\n            u[i] = 0\n            min_eff[i] = 0\n            max_eff[i] = 0\n            p[i] = 0\n\n    # Turn on free_off units if under-committed\n    if total_max < current_load and free_off:\n        # Calculate cost per MW for sorting\n        cost_per_mw = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            startup_cost = unit['s_i']\n            min_cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p ** 2\n            cost_per_mw.append((startup_cost + min_cost) / min_p)\n        sorted_free_off = [x for _, x in sorted(zip(cost_per_mw, free_off))]\n        \n        for i in sorted_free_off:\n            if total_max >= current_load:\n                break\n            min_val = unit_i = units_info[i]['p_min_i']\n            max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            u[i] = 1\n            min_eff[i] = min_val\n            max_eff[i] = max_val\n            total_min += min_val\n            total_max += max_val\n\n    committed_idx = np.where(u == 1)[0]\n    if not committed_idx.size:\n        return np.array([u, p])\n\n    # Over-generation handling\n    if total_min > current_load:\n        for i in committed_idx:\n            p[i] = min_eff[i]\n        return np.array([u, p])\n\n    # Under-supply handling\n    if total_max < current_load:\n        for i in committed_idx:\n            p[i] = max_eff[i]\n        return np.array([u, p])\n\n    # Lambda iteration for dispatch\n    low_lambda = 0\n    high_lambda = max(unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i'] for unit in units_info) + 1000\n    tol = 0.1\n    iter_max = 100\n    p_committed = min_eff[committed_idx].copy()\n    \n    for _ in range(iter_max):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0\n        for idx in range(len(committed_idx)):\n            i = committed_idx[idx]\n            if units_info[i]['c_i'] == 0:  # Linear cost\n                p_committed[idx] = max_eff[i] if mid_lambda > units_info[i]['b_i'] else min_eff[i]\n            else:\n                p_temp = (mid_lambda - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_committed[idx] = max(min_eff[i], min(max_eff[i], p_temp))\n            total_power += p_committed[idx]\n        \n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n\n    # Assign computed outputs\n    p[committed_idx] = p_committed\n\n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0001407881,
          "gap_price_rate": 0.0360459668,
          "fitness": 0.0180933775
     }
]