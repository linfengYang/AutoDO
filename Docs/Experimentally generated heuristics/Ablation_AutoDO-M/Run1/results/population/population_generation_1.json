[
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                u[i] = 1\n                \n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in must_run_indices:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    total_min_must = np.sum(eff_min[must_run_indices])\n    total_max_must = np.sum(eff_max[must_run_indices])\n    \n    if total_min_must > current_load:\n        for i in must_run_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    if total_max_must >= current_load:\n        committed_indices = must_run_indices\n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    candidate_indices.append(i)\n                    \n        candidate_info = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                emin = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                emax = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['b_i'] + unit['c_i'] * emin) / emin\n            else:\n                emin = unit['p_min_i']\n                emax = min(unit['p_max_i'], unit['p_start_i'])\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                cost_per_mw = (startup_cost + unit['a_i'] + unit['b_i'] * emin + unit['c_i'] * emin**2) / emin\n            candidate_info.append((i, emin, emax, cost_per_mw))\n        \n        candidate_info.sort(key=lambda x: x[3])\n        committed_indices = must_run_indices.copy()\n        total_min_curr = total_min_must\n        total_max_curr = total_max_must\n        for i, emin, emax, _ in candidate_info:\n            if total_max_curr >= current_load:\n                break\n            committed_indices.append(i)\n            total_min_curr += emin\n            total_max_curr += emax\n        \n        for i in committed_indices:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                eff_min[i] = units_info[i]['p_min_i']\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min_committed = sum(eff_min[i] for i in committed_indices)\n    if total_min_committed > current_load:\n        for i in committed_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    b = []\n    c = []\n    lows = []\n    highs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n        lows.append(eff_min[i])\n        highs.append(eff_max[i])\n    \n    n_committed = len(committed_indices)\n    p_alloc = np.array(lows)\n    if abs(total_min_committed - current_load) < 1e-5:\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_alloc[idx]\n        return np.array([u, p])\n    \n    if n_committed == 0:\n        return np.array([u, p])\n    \n    low_lambda = min(b_i + 2 * c_i * low for b_i, c_i, low in zip(b, c, lows))\n    high_lambda = max(b_i + 2 * c_i * high for b_i, c_i, high in zip(b, c, highs))\n    tolerance = 1e-5\n    \n    for _ in range(1000):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for k in range(n_committed):\n            if c[k] == 0:\n                p_alloc[k] = highs[k] if mid_lambda >= b[k] else lows[k]\n            else:\n                p_val = (mid_lambda - b[k]) / (2 * c[k])\n                p_alloc[k] = np.clip(p_val, lows[k], highs[k])\n            total_p += p_alloc[k]\n        \n        if total_p < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tolerance:\n            diff = current_load - total_p\n            if diff > 0:\n                idx_min = np.argmin(np.array([b_i + 2*c_i*p_i for b_i, c_i, p_i in zip(b, c, p_alloc)]))\n                p_alloc[idx_min] = min(highs[idx_min], p_alloc[idx_min] + diff)\n            break\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_alloc[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054289451,
          "gap_price_rate": 0.0090732546,
          "fitness": 0.0072510999
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs for must-on and free-on units considering ramp constraints. For free-off units if activated, use startup ramp limits.  \n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).  \n4. Else if must-on units can cover load, optimize dispatch only among must-on units.  \n5. Else, activate free-on and free-off candidates sorted by cost-efficiency (startup + min-output cost)/min-output), selecting until total max capacity meets load.  \n6. If the min output of committed units exceeds load, remove most expensive/least flexible candidates while maintaining capacity.  \n7. Dispatch load among committed units:  \n   - Initialize outputs at effective min  \n   - Increase cheapest units' output when below load  \n   - Decrease most expensive units' output when above load  \n   - Respect ramp and output constraints during dispatch  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    enhanced_units = []\n    \n    # Classify units and compute parameters\n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_up, p_down = unit['p_up_i'], unit['p_down_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        prev_u, prev_p, prev_t = unit['u_i_0'], unit['p_i_0'], unit['t_i_0']\n        \n        # Determine category\n        if prev_u == 1:\n            if prev_t < t_on_min or prev_p > p_shut:\n                category = 'must_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n            else:\n                category = 'free_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n        else:\n            if -prev_t < t_off_min:\n                category = 'must_off'\n                eff_min = eff_max = 0\n            else:\n                category = 'free_off'\n                eff_min = p_min\n                eff_max = min(p_max, p_start)\n        enhanced_units.append({\n            'index': i,\n            'category': category,\n            'eff_min': eff_min,\n            'eff_max': eff_max,\n            's_i': s_i,\n            'p_min': p_min,\n            'a_i': a_i, 'b_i': b_i, 'c_i': c_i\n        })\n    \n    # Separate units into categories\n    must_on = [u for u in enhanced_units if u['category'] == 'must_on']\n    must_off = [u for u in enhanced_units if u['category'] == 'must_off']\n    free_on = [u for u in enhanced_units if u['category'] == 'free_on']\n    free_off = [u for u in enhanced_units if u['category'] == 'free_off']\n    \n    # Initialize with must-on units\n    total_min = sum(u['eff_min'] for u in must_on)\n    total_max = sum(u['eff_max'] for u in must_on)\n    committed = must_on.copy()\n    \n    if total_min > current_load:\n        # Case 1: Must-on over-generation\n        for u in must_on:\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = u['eff_min']\n    elif total_max >= current_load:\n        # Case 2: Dispatch among must-on\n        if must_on:\n            p_values = [u['eff_min'] for u in must_on]\n            remaining = current_load - total_min\n            while abs(remaining) > 1e-5:\n                # Increase phase\n                while remaining > 1e-5:\n                    best_idx, best_mc = -1, float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] < u['eff_max']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc < best_mc:\n                                best_mc, best_idx = mc, j\n                    if best_idx == -1: break\n                    inc = min(remaining, must_on[best_idx]['eff_max'] - p_values[best_idx])\n                    p_values[best_idx] += inc\n                    remaining -= inc\n                # Decrease phase\n                while remaining < -1e-5:\n                    worst_idx, worst_mc = -1, -float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] > u['eff_min']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc > worst_mc:\n                                worst_mc, worst_idx = mc, j\n                    if worst_idx == -1: break\n                    dec = min(-remaining, p_values[worst_idx] - must_on[worst_idx]['eff_min'])\n                    p_values[worst_idx] -= dec\n                    remaining += dec\n            for u, p_val in zip(must_on, p_values):\n                i = u['index']\n                schedules[0, i] = 1\n                schedules[1, i] = p_val\n    else:\n        # Case 3: Need more capacity\n        candidates = []\n        # Free-on candidates\n        for u in free_on:\n            min_out = u['eff_min']\n            cost_per_mw = (u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Free-off candidates\n        for u in free_off:\n            min_out = u['eff_min']\n            cost_per_mw = (u['s_i'] + u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Sort by cost efficiency then min output\n        candidates.sort(key=lambda x: (x[1], x[2]))\n        \n        # Add candidates until capacity meets demand\n        added_candidates = []\n        for candidate in candidates:\n            if total_max < current_load:\n                u, _, min_out, max_out = candidate\n                added_candidates.append(candidate)\n                committed.append(u)\n                total_min += min_out\n                total_max += max_out\n        \n        # Remove over-committed candidates\n        added_candidates.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n        i = 0\n        while i < len(added_candidates) and total_min > current_load:\n            u, _, min_out, max_out = added_candidates[i]\n            if total_max - max_out >= current_load:\n                committed.remove(u)\n                added_candidates.pop(i)\n                total_min -= min_out\n                total_max -= max_out\n            else:\n                i += 1\n        \n        # Dispatch among committed units\n        p_values = []\n        bounds = []\n        for u in committed:\n            if u['category'] in ['must_on', 'free_on']:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            else:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            p_values.append(eff_min)\n            bounds.append((eff_min, eff_max))\n        remaining = current_load - sum(p_values)\n        \n        # Increase outputs for under-generation\n        while remaining > 1e-5:\n            best_idx, best_mc = -1, float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] < high:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc < best_mc:\n                        best_mc, best_idx = mc, j\n            if best_idx == -1: \n                break\n            inc = min(remaining, bounds[best_idx][1] - p_values[best_idx])\n            p_values[best_idx] += inc\n            remaining -= inc\n        \n        # Decrease outputs for over-generation\n        while remaining < -1e-5:\n            worst_idx, worst_mc = -1, -float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] > low:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc > worst_mc:\n                        worst_mc, worst_idx = mc, j\n            if worst_idx == -1: \n                break\n            dec = min(-remaining, p_values[worst_idx] - bounds[worst_idx][0])\n            p_values[worst_idx] -= dec\n            remaining += dec\n        \n        # Apply scheduled outputs\n        for u, p_val in zip(committed, p_values):\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = p_val\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "commit_units_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (violating min up-time or shutdown ramp), must-off (violating min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Initialize commitments: must-on and free-on committed, must-off and free-off decommitted.\n3. Compute effective min/max outputs considering ramp constraints: \n   - For units remaining online: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - For units starting: [p_min, min(p_max, start_ramp)]\n4. If total min output > load:\n   - Identify eligible free-on units (p_prev <= shutdown ramp)\n   - Turn off units by largest min output then highest operating cost\n   - Recompute min/max totals\n5. If total max output < load:\n   - Identify eligible free-off units (can be started)\n   - Turn on units by lowest average cost (startup+min_cost)/min_output then highest effective max output\n   - Recompute min/max totals\n6. Dispatch load:\n   a. Set committed units to effective min outputs\n   b. Distribute remaining load using marginal cost priority with heap-based greedy algorithm:\n      i. Place each unit's marginal cost (b_i + 2*c_i*p_i) and room in a min-heap\n      ii. Increase cheapest unit until room or load exhausted\n      iii. Update heap after each change\n7. Return schedules: commitment states and power outputs.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef commit_units_hybrid_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    effective_min = [0] * n_units\n    effective_max = [0] * n_units\n    \n    # Classify units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if t0 > -unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n        # Initialize commitment\n        if must_on[i] or free_on[i]:\n            u[i] = 1\n        else:\n            u[i] = 0\n            \n    # Set effective min/max\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:  # Already online\n                min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n            effective_min[i] = min_val\n            effective_max[i] = max_val\n        else:\n            effective_min[i] = 0\n            effective_max[i] = 0\n            \n    total_min = sum(effective_min)\n    total_max = sum(effective_max)\n    \n    # Step 4: Turn off free-on units if over-committed\n    free_on_eligible = [i for i in range(n_units) if free_on[i] and u[i]==1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']]\n    def cost_at_min(i):\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        p_min = effective_min[i]\n        return a + b * p_min + c * p_min * p_min\n    free_on_eligible.sort(key=lambda i: (effective_min[i], -cost_at_min(i)), reverse=True)\n    \n    for i in free_on_eligible:\n        if total_min <= current_load:\n            break\n        u[i] = 0\n        total_min -= effective_min[i]\n        total_max -= effective_max[i]\n        effective_min[i] = 0\n        effective_max[i] = 0\n        \n    # Step 5: Turn on free-off units if under-committed\n    free_off_eligible = [i for i in range(n_units) if free_off[i] and u[i]==0]\n    def avg_cost(i):\n        a, b, c, s = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i']\n        p_min = units_info[i]['p_min_i']\n        return (a + b * p_min + c * p_min * p_min + s) / p_min\n    free_off_eligible.sort(key=lambda i: (avg_cost(i), -min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])))\n    \n    for i in free_off_eligible:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 6: Dispatch\n    p_out = [0.0] * n_units\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    # Initial allocation at effective min\n    for i in committed_indices:\n        p_out[i] = effective_min[i]\n    total_current = sum(p_out)\n    remaining = current_load - total_current\n    \n    # Heap-based dispatch for remaining load\n    if remaining > 1e-8:\n        heap = []\n        for i in committed_indices:\n            room = effective_max[i] - effective_min[i]\n            if room > 1e-8:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                heapq.heappush(heap, (marginal_cost, i, room))\n        \n        while heap and remaining > 1e-8:\n            mc, i, room = heapq.heappop(heap)\n            delta = min(remaining, room)\n            p_out[i] += delta\n            remaining -= delta\n            new_room = room - delta\n            \n            if new_room > 1e-8:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                heapq.heappush(heap, (new_mc, i, new_room))\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u[i]\n        schedules[1, i] = p_out[i] if u[i] == 1 else 0.0\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Classify units into must-on (units that must remain on due to minimum up-time or shutdown ramp constraints), must-off (units that must remain off due to minimum down-time constraints), free-on (free units currently on that can be turned off), and free-off (free units currently off that can be turned on).\n2. Start by committing must-on and free-on units.\n3. Compute effective min/max outputs considering ramp constraints for committed units:\n   - Units that were online: [max(p_min, prev_output - ramp_down), min(p_max, prev_output + ramp_up)]\n   - Units being started: [p_min, min(p_max, startup_ramp)]\n4. If total effective min output exceeds load, turn off highest cost free-on units (based on cost at min output) until total min \u2264 load.\n5. If total effective max output is below load, turn on lowest cost free-off units (startup cost + min output cost) until total max \u2265 load.\n6. Set dispatch target as the clamped value between effective min/max and load.\n7. Perform economic dispatch using priority heap to allocate load optimally:\n   - Start at effective min outputs\n   - Increase output of units with lowest marginal cost first\n   - Use step size of 1 MW\n   - Iterate until load is met or headroom exhausted\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    units = []\n    for i, unit_dict in enumerate(units_info):\n        unit = {\n            'idx': i,\n            'a_i': unit_dict['a_i'],\n            'b_i': unit_dict['b_i'],\n            'c_i': unit_dict['c_i'],\n            'p_min_i': unit_dict['p_min_i'],\n            'p_max_i': unit_dict['p_max_i'],\n            'p_up_i': unit_dict['p_up_i'],\n            'p_down_i': unit_dict['p_down_i'],\n            'p_start_i': unit_dict['p_start_i'],\n            'p_shut_i': unit_dict['p_shut_i'],\n            't_on_min_i': unit_dict['t_on_min_i'],\n            't_off_min_i': unit_dict['t_off_min_i'],\n            's_i': unit_dict['s_i'],\n            'u_i_0': unit_dict['u_i_0'],\n            't_i_0': unit_dict['t_i_0'],\n            'p_i_0': unit_dict['p_i_0'],\n            'committed': False,\n            'p_alloc': 0.0\n        }\n        units.append(unit)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # Initial commitment\n    committed = must_on + free_on\n    for unit in committed:\n        unit['committed'] = True\n    \n    # Compute effective min/max for committed units\n    def compute_effective_limits(unit):\n        if unit in must_on or unit in free_on:  # Was online\n            effective_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            effective_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Being started\n            effective_min = unit['p_min_i']\n            effective_max = min(unit['p_max_i'], unit['p_start_i'])\n        return effective_min, effective_max\n    \n    for unit in committed:\n        effective_min, effective_max = compute_effective_limits(unit)\n        unit['effective_min'] = effective_min\n        unit['effective_max'] = effective_max\n    \n    # Calculate total capacity\n    def calculate_total_capacity(committed_units):\n        total_min = 0\n        total_max = 0\n        for unit in committed_units:\n            total_min += unit['effective_min']\n            total_max += unit['effective_max']\n        return total_min, total_max\n    \n    total_min, total_max = calculate_total_capacity(committed)\n    \n    # Turn off expensive free-on units if over-committed\n    if total_min > current_load:\n        free_on_committed = [u for u in committed if u in free_on]\n        # Sort by cost at effective min (descending)\n        free_on_committed.sort(\n            key=lambda u: u['a_i'] + u['b_i'] * u['effective_min'] + u['c_i'] * u['effective_min']**2,\n            reverse=True\n        )\n        \n        for unit in free_on_committed:\n            if total_min <= current_load:\n                break\n            committed.remove(unit)\n            unit['committed'] = False\n            total_min -= unit['effective_min']\n            total_max -= unit['effective_max']\n    \n    # Turn on cheapest free-off units if under-committed\n    if total_max < current_load:\n        free_off.sort(\n            key=lambda u: u['s_i'] + u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2\n        )\n        \n        for unit in free_off:\n            if total_max >= current_load:\n                break\n            committed.append(unit)\n            unit['committed'] = True\n            eff_min = unit['p_min_i']\n            eff_max = min(unit['p_max_i'], unit['p_start_i'])\n            unit['effective_min'] = eff_min\n            unit['effective_max'] = eff_max\n            total_min += eff_min\n            total_max += eff_max\n    \n    # Set dispatch target\n    dispatch_target = min(max(total_min, current_load), total_max)\n    \n    # Initialize allocation at effective min\n    for unit in committed:\n        unit['p_alloc'] = unit['effective_min']\n    remaining = dispatch_target - total_min\n    \n    # Economic dispatch with priority heap\n    heap = []\n    for unit in committed:\n        current_p = unit['effective_min']\n        headroom = unit['effective_max'] - current_p\n        if headroom > 1e-5:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            heapq.heappush(heap, (marginal_cost, id(unit), unit, current_p, headroom))\n    \n    step_size = 1.0\n    while remaining > 1e-5 and heap:\n        mc, uid, unit, current_p, headroom = heapq.heappop(heap)\n        delta = min(remaining, step_size, headroom)\n        unit['p_alloc'] += delta\n        remaining -= delta\n        new_headroom = headroom - delta\n        if new_headroom > 1e-5:\n            new_mc = unit['b_i'] + 2 * unit['c_i'] * unit['p_alloc']\n            heapq.heappush(heap, (new_mc, uid, unit, unit['p_alloc'], new_headroom))\n    \n    # Prepare output\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = 1 if unit['committed'] else 0\n        schedules[1, i] = unit['p_alloc'] if unit['committed'] else 0.0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.046049776,
          "fitness": 0.0230607341
     },
     {
          "name": "combined_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (violates min downtime or shutdown constraints if turned off), must-off (violates min downtime if turned on), free-on (online and can be turned off), free-off (offline and can be turned on).\n2. Initially commit must-on units and free-on units.\n3. Compute effective min/max outputs considering ramp constraints:\n   - Online units: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - Started units: [p_min, min(p_max, start_ramp)]\n4. Calculate total min/max capacity. If total min > current load:\n   - Turn off free-on units in descending order of min output to reduce over-commitment.\n5. If total max < current load:\n   - Turn on free-off units in ascending order of (startup cost + min output cost) until capacity suffices.\n6. Perform economic dispatch:\n   a. Set committed units to min output.\n   b. Distribute remaining load by increasing output of units with smallest incremental cost, respecting max limits.\n   c. If min outputs exceed load, accept over-generation; if max outputs are insufficient, accept under-supply.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef combined_dynamic_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    committed = [must_on[i] or free_on[i] for i in range(n_units)]\n    \n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            min_p[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_p[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n            \n    total_min = sum(min_p)\n    total_max = sum(max_p)\n    \n    if total_min > current_load:\n        free_on_indices = [i for i in range(n_units) if free_on[i] and committed[i]]\n        candidates = []\n        for i in free_on_indices:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            cost = a + b * min_p[i] + c * (min_p[i] ** 2)\n            candidates.append((min_p[i], cost, i))\n        candidates.sort(key=lambda x: (x[0], x[1]), reverse=True)\n        \n        for mp, _, idx in candidates:\n            committed[idx] = False\n            total_min -= mp\n            total_max -= max_p[idx]\n            min_p[idx] = 0\n            max_p[idx] = 0\n            if total_min <= current_load:\n                break\n                \n    if total_max < current_load:\n        free_off_indices = [i for i in range(n_units) if free_off[i] and not committed[i]]\n        candidates = []\n        for i in free_off_indices:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            s = units_info[i]['s_i']\n            p_min_val = units_info[i]['p_min_i']\n            max_eff = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            cost = s + a + b * p_min_val + c * (p_min_val ** 2)\n            candidates.append((cost, p_min_val, max_eff, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for cost_val, p_min_val, max_eff, idx in candidates:\n            committed[idx] = True\n            min_p[idx] = p_min_val\n            max_p[idx] = max_eff\n            total_min += p_min_val\n            total_max += max_eff\n            if total_max >= current_load:\n                break\n                \n    u_output = [1 if committed[i] else 0 for i in range(n_units)]\n    p_output = [min_p[i] if committed[i] else 0 for i in range(n_units)]\n    \n    current_total = sum(p_output)\n    residual = current_load - current_total\n    \n    if residual > 0:\n        active_indices = [i for i in range(n_units) if committed[i] and p_output[i] < max_p[i]]\n        while residual > 0 and active_indices:\n            min_ic = float('inf')\n            best_idx = -1\n            best_headroom = 0\n            for i in active_indices:\n                b_val = units_info[i]['b_i']\n                c_val = units_info[i]['c_i']\n                ic = b_val + 2 * c_val * p_output[i]\n                headroom = max_p[i] - p_output[i]\n                if ic < min_ic:\n                    min_ic = ic\n                    best_idx = i\n                    best_headroom = headroom\n            if best_idx == -1:\n                break\n            assign = min(residual, best_headroom)\n            p_output[best_idx] += assign\n            residual -= assign\n            if p_output[best_idx] >= max_p[best_idx]:\n                active_indices.remove(best_idx)\n                \n    schedules = np.array([u_output, p_output], dtype=float)\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0464761684,
          "fitness": 0.0232739303
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-on units (units that must remain on due to minimum up-time or shutdown constraints) and must-off units (units that must remain off due to minimum down-time constraints).\n2. Group remaining units into group1 (units that were on) and group2 (units that were off).\n3. Start with must-on and group1 units committed. Compute effective minimum and maximum outputs considering ramp constraints.\n4. If total effective minimum output exceeds load, decommit the most expensive group1 units (not must-on) until the total effective minimum is <= load and total effective maximum >= load.\n5. If total effective maximum output is below load, commit additional group2 units in ascending order of cost per MW at minimum output until total effective maximum >= load.\n6. Perform economic dispatch: set committed units to their effective minimum outputs, then distribute remaining load to units with the smallest incremental cost, respecting maximum output constraints.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    load_current = load[0]\n    n_units = len(units_info)\n    \n    must_on = []\n    must_off = []\n    group1 = []\n    group2 = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n        else:\n            if t_i0 > -t_off_min:\n                must_off.append(i)\n                \n    for i in range(n_units):\n        if i in must_on or i in must_off:\n            continue\n        if units_info[i]['u_i_0'] == 1:\n            group1.append(i)\n        else:\n            group2.append(i)\n            \n    committed_indices = must_on + group1\n    \n    def compute_bounds(indices):\n        total_min = 0.0\n        total_max = 0.0\n        for i in indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low = unit['p_min_i']\n                high = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low\n            total_max += high\n        return total_min, total_max\n        \n    total_min, total_max = compute_bounds(committed_indices)\n    \n    if total_min > load_current:\n        decommit_candidates = [i for i in group1 if i not in must_on]\n        candidate_list = []\n        for i in decommit_candidates:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_i = unit['p_min_i']\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * low_i\n            candidate_list.append((inc_cost, i))\n        candidate_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for inc, i in candidate_list:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_i = unit['p_min_i']\n                high_i = min(unit['p_max_i'], unit['p_start_i'])\n            new_total_min = total_min - low_i\n            new_total_max = total_max - high_i\n            if new_total_min <= load_current and new_total_max >= load_current:\n                committed_indices.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n            if total_min <= load_current:\n                break\n                \n    if total_max < load_current:\n        candidate_list = []\n        for i in group2:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost_at_min = a_i + b_i * p_min + c_i * p_min**2\n            cost_per_mw = (s_i + cost_at_min) / p_min\n            candidate_list.append((cost_per_mw, i))\n        candidate_list.sort(key=lambda x: x[0])\n        \n        for cost_per_mw, i in candidate_list:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            effective_max = min(unit['p_max_i'], unit['p_start_i'])\n            new_total_min = total_min + p_min\n            new_total_max = total_max + effective_max\n            committed_indices.append(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= load_current:\n                break\n                \n    low_bounds = {}\n    high_bounds = {}\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_b = unit['p_min_i']\n            high_b = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds[i] = low_b\n        high_bounds[i] = high_b\n        \n    p_vals = [0.0] * n_units\n    for i in committed_indices:\n        p_vals[i] = low_bounds[i]\n        \n    total_p = sum(p_vals[i] for i in committed_indices)\n    remaining = load_current - total_p\n    \n    while remaining > 0:\n        min_inc = float('inf')\n        candidate = None\n        for i in committed_indices:\n            if p_vals[i] < high_bounds[i]:\n                inc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_vals[i]\n                if inc < min_inc:\n                    min_inc = inc\n                    candidate = i\n        if candidate is None:\n            break\n        available = high_bounds[candidate] - p_vals[candidate]\n        if available > remaining:\n            p_vals[candidate] += remaining\n            remaining = 0\n        else:\n            p_vals[candidate] += available\n            remaining -= available\n            \n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    for i in range(n_units):\n        if i in committed_indices:\n            u_schedule[i] = 1\n            p_schedule[i] = p_vals[i]\n        else:\n            u_schedule[i] = 0\n            p_schedule[i] = 0.0\n            \n    schedules = np.array([u_schedule, p_schedule])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00023,
          "gap_price_rate": 0.04855,
          "fitness": 0.02439
     },
     {
          "name": "improved_commit_units",
          "algorithm": "1. Identify must-run units based on min up/down constraints and shutdown ramp limits\n2. Initialize commitment states for must-run and previously online free units\n3. Calculate effective min/max outputs for committed units considering ramp limits\n4. While over-committed (min > load): turn off eligible free units with highest cost per MW\n5. While under-committed (max < load): turn on eligible free units with lowest cost per MW\n6. Adjust commitment to handle new unit limits\n7. Dispatch load via lambda iteration with ramp-constrained bounds\n8. Ensure shutdown ramp compliance for turned-off units\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef improved_commit_units(units_info, load):\n    n_units = len(units_info)\n    load_current = load[0]\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize commitment states\n    u[free_on] = 1\n    u[must_on] = 1\n    u[must_off] = 0\n    \n    # Calculate effective min/max for committed units\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                effective_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                effective_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                effective_min[i] = unit['p_min_i']\n                effective_max[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n    \n    total_min = np.sum(effective_min[u == 1])\n    total_max = np.sum(effective_max[u == 1])\n    \n    # Turn off units if over-committed\n    candidate_off = [i for i in free_on if u[i] == 1 and unit['p_i_0'] <= unit['p_down_i']]\n    if total_min > load_current and candidate_off:\n        candidate_off.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + \n                                          units_info[i]['c_i'] * effective_min[i]**2) / effective_min[i], reverse=True)\n        for i in candidate_off:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= load_current and new_total_max >= load_current:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                if total_min <= load_current:\n                    break\n    \n    # Turn on units if under-committed\n    candidate_on = [i for i in free_off if u[i] == 0]\n    if total_max < load_current and candidate_on:\n        candidate_on.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                                         units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                                         units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i'])\n        for i in candidate_on:\n            new_min = units_info[i]['p_min_i']\n            new_max = min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n            if new_min <= new_max:\n                u[i] = 1\n                effective_min[i] = new_min\n                effective_max[i] = new_max\n                total_min += new_min\n                total_max += new_max\n                if total_max >= load_current:\n                    break\n    \n    # Update effective limits after commitment changes\n    committed_indices = np.where(u == 1)[0]\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            effective_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            effective_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            effective_min[i] = unit['p_min_i']\n            effective_max[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n    \n    # Lambda iteration for economic dispatch\n    lo = min(2*units_info[i]['c_i'] * effective_min[i] + units_info[i]['b_i'] for i in committed_indices)\n    hi = max(2*units_info[i]['c_i'] * effective_max[i] + units_info[i]['b_i'] for i in committed_indices)\n    \n    tol = 1e-5\n    while hi - lo > tol:\n        mid = (lo + hi) / 2\n        total_power = 0\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                if mid < unit['b_i']:\n                    p_i = effective_min[i]\n                else:\n                    p_i = effective_max[i]\n            else:\n                p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(effective_min[i], min(effective_max[i], p_i))\n            total_power += p_i\n        \n        if total_power < load_current:\n            lo = mid\n        else:\n            hi = mid\n    \n    # Final dispatch assignment\n    total_power = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['c_i'] == 0:\n            if mid < unit['b_i']:\n                p[i] = effective_min[i]\n            else:\n                p[i] = effective_max[i]\n        else:\n            p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n            p[i] = max(effective_min[i], min(effective_max[i], p_i))\n        total_power += p[i]\n    \n    # Adjust for possible numerical discrepancies\n    gap = load_current - total_power\n    if gap != 0:\n        sorted_units = sorted(committed_indices, \n                            key=lambda i: (2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']) * (1 if gap > 0 else -1))\n        for i in sorted_units:\n            adjustment = min(gap, effective_max[i] - p[i]) if gap > 0 else max(gap, effective_min[i] - p[i])\n            p[i] += adjustment\n            gap -= adjustment\n            if abs(gap) < 1e-5:\n                break\n    \n    # Ensure shutdown compliance for turned-off units\n    for i in range(n_units):\n        if u[i] == 0 and units_info[i]['u_i_0'] == 1:\n            if p[i] > units_info[i]['p_shut_i']:\n                p[i] = units_info[i]['p_shut_i']\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0254677271,
          "gap_price_rate": 0.0251321017,
          "fitness": 0.0252999144
     },
     {
          "name": "improved_commitment_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, free-on, and free-off based on their previous state and constraints:\n   - Must-on: Units that were online and haven't satisfied minimum up-time or exceeded shutdown capacity.\n   - Must-off: Units that were offline and haven't satisfied minimum down-time.\n   - Free-on: Units online that can be turned off.\n   - Free-off: Units offline that can be turned on.\n   \n2. Initialize outputs for each unit:\n   - Must-on/free-on: Set online, output to feasible lower bound (max of minimum output or previous output minus ramp down).\n   - Must-off/free-off: Set offline, output to 0.\n   - Calculate total output.\n\n3. Handle over-commitment (total output > load):\n   - Identify free-on units eligible for shutdown (current output \u2264 shutdown ramp limit).\n   - Sort eligible units by highest production cost per MW at minimum output.\n   - Turn off units in sorted order until total output \u2264 load or no units left.\n\n4. Handle under-commitment (total output < load):\n   a) Increase outputs of committed units:\n      - Calculate headroom for each committed unit (respecting ramp and capacity limits).\n      - While deficit exists and headroom available:\n          - Find unit with lowest marginal cost.\n          - Increase its output to reduce deficit.\n   b) Turn on free-off units if deficit remains:\n      - Identify free-off units that can start (minimum output \u2264 startup ramp, ramp up, and capacity limits).\n      - Sort eligible units by total startup and minimum output cost.\n      - Turn on units in sorted order. For each unit:\n          - Set online and output to minimum.\n          - Attempt to increase outputs of all committed units to reduce deficit.\n\n5. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef improved_commitment_heuristic(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    free_on = [False] * n\n    free_off = [False] * n\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n    \n    # Step 2: Initialize outputs\n    total_power = 0\n    for i, unit in enumerate(units_info):\n        if must_off[i] or free_off[i]:\n            u[i] = 0\n            p[i] = 0\n        else:\n            u[i] = 1\n            p_i_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p[i] = p_i_low\n            total_power += p[i]\n    \n    current_load = load[0]\n    # Step 3: Handle over-commitment\n    if total_power > current_load:\n        eligible_to_turn_off = []\n        for i in range(n):\n            if free_on[i]:\n                unit = units_info[i]\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                if p_low <= unit['p_shut_i']:\n                    eligible_to_turn_off.append(i)\n        \n        if eligible_to_turn_off:\n            costs = []\n            for i in eligible_to_turn_off:\n                unit = units_info[i]\n                p_min = unit['p_min_i']\n                cost_val = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n                costs.append((i, cost_val))\n            costs.sort(key=lambda x: x[1], reverse=True)\n            sorted_indices = [idx for idx, _ in costs]\n            \n            for i in sorted_indices:\n                if total_power <= current_load:\n                    break\n                u[i] = 0\n                total_power -= p[i]\n                p[i] = 0\n    \n    # Step 4: Handle under-commitment\n    deficit = current_load - total_power\n    if deficit > 1e-5:\n        committed = [i for i in range(n) if u[i] == 1]\n        changed = True\n        while deficit > 1e-5 and changed:\n            changed = False\n            candidate_units = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    max_output = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n                headroom = max_output - p[i]\n                if headroom < 1e-5:\n                    continue\n                marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                candidate_units.append((i, headroom, marginal_cost))\n            \n            if not candidate_units:\n                break\n            candidate_units.sort(key=lambda x: x[2])\n            i, headroom, _ = candidate_units[0]\n            inc = min(headroom, deficit)\n            p[i] += inc\n            total_power += inc\n            deficit -= inc\n            changed = True\n        \n        # If deficit remains, turn on free-off units\n        if deficit > 1e-5:\n            eligible_to_turn_on = []\n            for i in range(n):\n                if free_off[i]:\n                    unit = units_info[i]\n                    max_start = min(unit['p_up_i'], unit['p_start_i'], unit['p_max_i'])\n                    if unit['p_min_i'] <= max_start:\n                        eligible_to_turn_on.append(i)\n            \n            if eligible_to_turn_on:\n                costs = []\n                for i in eligible_to_turn_on:\n                    unit = units_info[i]\n                    p_min = unit['p_min_i']\n                    cost_val = unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n                    costs.append((i, cost_val))\n                costs.sort(key=lambda x: x[1])\n                sorted_indices = [idx for idx, _ in costs]\n                \n                for i in sorted_indices:\n                    if deficit < 1e-5:\n                        break\n                    u[i] = 1\n                    p_min_i = units_info[i]['p_min_i']\n                    p[i] = p_min_i\n                    total_power += p_min_i\n                    deficit -= p_min_i\n                    committed.append(i)\n                    \n                    changed = True\n                    while deficit > 1e-5 and changed:\n                        changed = False\n                        candidate_units = []\n                        for j in committed:\n                            if u[j] != 1:\n                                continue\n                            unit = units_info[j]\n                            if unit['u_i_0'] == 1:\n                                max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                            else:\n                                max_output = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n                            headroom_j = max_output - p[j]\n                            if headroom_j < 1e-5:\n                                continue\n                            marginal_cost = 2 * unit['c_i'] * p[j] + unit['b_i']\n                            candidate_units.append((j, headroom_j, marginal_cost))\n                        \n                        if not candidate_units:\n                            break\n                        candidate_units.sort(key=lambda x: x[2])\n                        j, headroom_j, _ = candidate_units[0]\n                        inc = min(headroom_j, deficit)\n                        p[j] += inc\n                        total_power += inc\n                        deficit -= inc\n                        changed = True\n    \n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u[i]\n        schedules[1, i] = p[i]\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0252986535,
          "gap_price_rate": 0.0274581174,
          "fitness": 0.0263783854
     }
]