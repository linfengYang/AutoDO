[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                u[i] = 1\n                \n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in must_run_indices:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    total_min_must = np.sum(eff_min[must_run_indices])\n    total_max_must = np.sum(eff_max[must_run_indices])\n    \n    if total_min_must > current_load:\n        for i in must_run_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    if total_max_must >= current_load:\n        committed_indices = must_run_indices\n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    candidate_indices.append(i)\n                    \n        candidate_info = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                emin = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                emax = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['b_i'] + unit['c_i'] * emin) / emin\n            else:\n                emin = unit['p_min_i']\n                emax = min(unit['p_max_i'], unit['p_start_i'])\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                cost_per_mw = (startup_cost + unit['a_i'] + unit['b_i'] * emin + unit['c_i'] * emin**2) / emin\n            candidate_info.append((i, emin, emax, cost_per_mw))\n        \n        candidate_info.sort(key=lambda x: x[3])\n        committed_indices = must_run_indices.copy()\n        total_min_curr = total_min_must\n        total_max_curr = total_max_must\n        for i, emin, emax, _ in candidate_info:\n            if total_max_curr >= current_load:\n                break\n            committed_indices.append(i)\n            total_min_curr += emin\n            total_max_curr += emax\n        \n        for i in committed_indices:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                eff_min[i] = units_info[i]['p_min_i']\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min_committed = sum(eff_min[i] for i in committed_indices)\n    if total_min_committed > current_load:\n        for i in committed_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    b = []\n    c = []\n    lows = []\n    highs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n        lows.append(eff_min[i])\n        highs.append(eff_max[i])\n    \n    n_committed = len(committed_indices)\n    p_alloc = np.array(lows)\n    if abs(total_min_committed - current_load) < 1e-5:\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_alloc[idx]\n        return np.array([u, p])\n    \n    if n_committed == 0:\n        return np.array([u, p])\n    \n    low_lambda = min(b_i + 2 * c_i * low for b_i, c_i, low in zip(b, c, lows))\n    high_lambda = max(b_i + 2 * c_i * high for b_i, c_i, high in zip(b, c, highs))\n    tolerance = 1e-5\n    \n    for _ in range(1000):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for k in range(n_committed):\n            if c[k] == 0:\n                p_alloc[k] = highs[k] if mid_lambda >= b[k] else lows[k]\n            else:\n                p_val = (mid_lambda - b[k]) / (2 * c[k])\n                p_alloc[k] = np.clip(p_val, lows[k], highs[k])\n            total_p += p_alloc[k]\n        \n        if total_p < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tolerance:\n            diff = current_load - total_p\n            if diff > 0:\n                idx_min = np.argmin(np.array([b_i + 2*c_i*p_i for b_i, c_i, p_i in zip(b, c, p_alloc)]))\n                p_alloc[idx_min] = min(highs[idx_min], p_alloc[idx_min] + diff)\n            break\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_alloc[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054289451,
          "gap_price_rate": 0.0090732546,
          "fitness": 0.0072510999
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs for all units considering ramp constraints (current units use ramp limits, new starts use startup ramp limits).\n3. If must-on units' min output exceeds current load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, dispatch only among must-on units.\n5. Else:\n   a. Activate free-off units by cost-efficiency (startup cost + cost at min output)/min output until capacity meets load\n   b. If total min output of committed set exceeds load:\n      - Remove free units (free-on/new starts) with highest saving per MW while maintaining capacity and shutdown feasibility\n6. Perform greedy dispatch:\n   a. Initialize outputs at effective min\n   b. Increase outputs of units with lowest marginal cost first using min-heap\n   c. Respect ramp and output constraints during allocation\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize commitment states and power outputs\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n            eff_min[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            eff_max[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n                eff_min[idx] = 0.0\n                eff_max[idx] = 0.0\n            else:\n                free_off.append(idx)\n                eff_min[idx] = unit['p_min_i']\n                eff_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3-5: Commitment logic\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        committed = set(must_on)\n    elif must_on_max >= current_load:\n        committed = set(must_on)\n    else:\n        committed = set(must_on) | set(free_on)\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Activate free-off units\n        free_off_sorted = sorted(free_off, key=lambda i: \n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * eff_min[i] + \n             units_info[i]['c_i'] * eff_min[i] ** 2) / eff_min[i])\n        \n        for idx in free_off_sorted:\n            if total_max >= current_load:\n                break\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n            committed.add(idx)\n        \n        # Remove over-committed free units\n        if total_min > current_load:\n            removal_candidates = []\n            for idx in committed:\n                if idx in must_on:\n                    continue\n                if units_info[idx]['u_i_0'] == 1:\n                    if units_info[idx]['p_i_0'] > units_info[idx]['p_shut_i']:\n                        continue\n                    saving = (units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                else:\n                    saving = (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                removal_candidates.append((saving, idx))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            for saving, idx in removal_candidates:\n                if total_min <= current_load:\n                    break\n                if (total_max - eff_max[idx]) >= current_load:\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    committed.remove(idx)\n    \n    # Step 6: Dispatch\n    total_output = 0.0\n    for idx in committed:\n        p[idx] = eff_min[idx]\n        total_output += eff_min[idx]\n        u[idx] = 1\n    \n    deficit = current_load - total_output\n    if deficit > 0:\n        heap = []\n        for idx in committed:\n            if p[idx] < eff_max[idx]:\n                room = eff_max[idx] - p[idx]\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (mc, idx, room))\n        \n        while deficit > 0 and heap:\n            mc, idx, room = heapq.heappop(heap)\n            inc = min(room, deficit)\n            p[idx] += inc\n            deficit -= inc\n            total_output += inc\n            \n            # Update remaining room and marginal cost\n            new_room = eff_max[idx] - p[idx]\n            if new_room > 0:\n                new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (new_mc, idx, new_room))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0101961532,
          "fitness": 0.007526636
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs for must-on and free-on units considering ramp constraints. For free-off units if activated, use startup ramp limits.  \n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).  \n4. Else if must-on units can cover load, optimize dispatch only among must-on units.  \n5. Else, activate free-on and free-off candidates sorted by cost-efficiency (startup + min-output cost)/min-output), selecting until total max capacity meets load.  \n6. If the min output of committed units exceeds load, remove most expensive/least flexible candidates while maintaining capacity.  \n7. Dispatch load among committed units:  \n   - Initialize outputs at effective min  \n   - Increase cheapest units' output when below load  \n   - Decrease most expensive units' output when above load  \n   - Respect ramp and output constraints during dispatch  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    enhanced_units = []\n    \n    # Classify units and compute parameters\n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_up, p_down = unit['p_up_i'], unit['p_down_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        prev_u, prev_p, prev_t = unit['u_i_0'], unit['p_i_0'], unit['t_i_0']\n        \n        # Determine category\n        if prev_u == 1:\n            if prev_t < t_on_min or prev_p > p_shut:\n                category = 'must_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n            else:\n                category = 'free_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n        else:\n            if -prev_t < t_off_min:\n                category = 'must_off'\n                eff_min = eff_max = 0\n            else:\n                category = 'free_off'\n                eff_min = p_min\n                eff_max = min(p_max, p_start)\n        enhanced_units.append({\n            'index': i,\n            'category': category,\n            'eff_min': eff_min,\n            'eff_max': eff_max,\n            's_i': s_i,\n            'p_min': p_min,\n            'a_i': a_i, 'b_i': b_i, 'c_i': c_i\n        })\n    \n    # Separate units into categories\n    must_on = [u for u in enhanced_units if u['category'] == 'must_on']\n    must_off = [u for u in enhanced_units if u['category'] == 'must_off']\n    free_on = [u for u in enhanced_units if u['category'] == 'free_on']\n    free_off = [u for u in enhanced_units if u['category'] == 'free_off']\n    \n    # Initialize with must-on units\n    total_min = sum(u['eff_min'] for u in must_on)\n    total_max = sum(u['eff_max'] for u in must_on)\n    committed = must_on.copy()\n    \n    if total_min > current_load:\n        # Case 1: Must-on over-generation\n        for u in must_on:\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = u['eff_min']\n    elif total_max >= current_load:\n        # Case 2: Dispatch among must-on\n        if must_on:\n            p_values = [u['eff_min'] for u in must_on]\n            remaining = current_load - total_min\n            while abs(remaining) > 1e-5:\n                # Increase phase\n                while remaining > 1e-5:\n                    best_idx, best_mc = -1, float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] < u['eff_max']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc < best_mc:\n                                best_mc, best_idx = mc, j\n                    if best_idx == -1: break\n                    inc = min(remaining, must_on[best_idx]['eff_max'] - p_values[best_idx])\n                    p_values[best_idx] += inc\n                    remaining -= inc\n                # Decrease phase\n                while remaining < -1e-5:\n                    worst_idx, worst_mc = -1, -float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] > u['eff_min']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc > worst_mc:\n                                worst_mc, worst_idx = mc, j\n                    if worst_idx == -1: break\n                    dec = min(-remaining, p_values[worst_idx] - must_on[worst_idx]['eff_min'])\n                    p_values[worst_idx] -= dec\n                    remaining += dec\n            for u, p_val in zip(must_on, p_values):\n                i = u['index']\n                schedules[0, i] = 1\n                schedules[1, i] = p_val\n    else:\n        # Case 3: Need more capacity\n        candidates = []\n        # Free-on candidates\n        for u in free_on:\n            min_out = u['eff_min']\n            cost_per_mw = (u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Free-off candidates\n        for u in free_off:\n            min_out = u['eff_min']\n            cost_per_mw = (u['s_i'] + u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Sort by cost efficiency then min output\n        candidates.sort(key=lambda x: (x[1], x[2]))\n        \n        # Add candidates until capacity meets demand\n        added_candidates = []\n        for candidate in candidates:\n            if total_max < current_load:\n                u, _, min_out, max_out = candidate\n                added_candidates.append(candidate)\n                committed.append(u)\n                total_min += min_out\n                total_max += max_out\n        \n        # Remove over-committed candidates\n        added_candidates.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n        i = 0\n        while i < len(added_candidates) and total_min > current_load:\n            u, _, min_out, max_out = added_candidates[i]\n            if total_max - max_out >= current_load:\n                committed.remove(u)\n                added_candidates.pop(i)\n                total_min -= min_out\n                total_max -= max_out\n            else:\n                i += 1\n        \n        # Dispatch among committed units\n        p_values = []\n        bounds = []\n        for u in committed:\n            if u['category'] in ['must_on', 'free_on']:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            else:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            p_values.append(eff_min)\n            bounds.append((eff_min, eff_max))\n        remaining = current_load - sum(p_values)\n        \n        # Increase outputs for under-generation\n        while remaining > 1e-5:\n            best_idx, best_mc = -1, float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] < high:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc < best_mc:\n                        best_mc, best_idx = mc, j\n            if best_idx == -1: \n                break\n            inc = min(remaining, bounds[best_idx][1] - p_values[best_idx])\n            p_values[best_idx] += inc\n            remaining -= inc\n        \n        # Decrease outputs for over-generation\n        while remaining < -1e-5:\n            worst_idx, worst_mc = -1, -float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] > low:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc > worst_mc:\n                        worst_mc, worst_idx = mc, j\n            if worst_idx == -1: \n                break\n            dec = min(-remaining, p_values[worst_idx] - bounds[worst_idx][0])\n            p_values[worst_idx] -= dec\n            remaining += dec\n        \n        # Apply scheduled outputs\n        for u, p_val in zip(committed, p_values):\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = p_val\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "hybrid_enhanced_refined_heuristic",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on).  \n2. Compute effective min/max outputs: online units respect ramps, potential startups limited by startup ramp.  \n3. If must-on units force over-generation (sum(min) > load), commit only must-on at minimum outputs.  \n4. Else if must-on units can cover load alone (sum(max) >= load), dispatch only among must-on units using lambda iteration.  \n5. Else:  \n   a. Initially commit must-on and free-on units.  \n   b. If total capacity < load:  \n      i. Add free-off units by ascending average cost = (startup + min-output cost) / min-output  \n      ii. Stop when total max >= load  \n   c. If total min > load:  \n      i. Remove non-must units by descending avoidable cost = (startup if not online + min cost) / min-output  \n      ii. Maintain total max >= load during removal  \n6. Dispatch load among final committed set:  \n   a. Set outputs to min values  \n   b. Distribute deficit via lambda iteration respecting effective min/max limits  \n7. Set non-committed units to off state (output 0).  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_refined_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]  # current time step load\n\n    min_limits = np.zeros(n_units)\n    max_limits = np.zeros(n_units)\n    must_on = set()\n    must_off = set()\n    free_on = set()\n    free_off = set()\n\n    # Step 1: Classify units and compute effective min/max\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        \n        if u_i0:  # was online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.add(i)\n                min_limits[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_limits[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.add(i)\n                min_limits[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_limits[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # was offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.add(i)\n                min_limits[i] = 0\n                max_limits[i] = 0\n            else:\n                free_off.add(i)\n                min_limits[i] = unit['p_min_i']\n                max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Step 3: Handle must-on over-generation\n    total_must_on_min = sum(min_limits[i] for i in must_on)\n    total_must_on_max = sum(max_limits[i] for i in must_on)\n    if total_must_on_min > current_load:\n        u_outputs = [1 if i in must_on else 0 for i in range(n_units)]\n        p_outputs = [min_limits[i] if i in must_on else 0 for i in range(n_units)]\n        return np.array([u_outputs, p_outputs])\n    \n    # Step 4: Must-on can cover load\n    if total_must_on_max >= current_load:\n        committed = must_on\n        u_outputs = [1 if i in committed else 0 for i in range(n_units)]\n        # Lambda iteration for dispatch\n        p_outputs = lambda_iteration_dispatch(\n            units_info, committed, min_limits, max_limits, current_load\n        )\n        return np.array([u_outputs, p_outputs])\n    \n    # Step 5: Require additional units\n    committed = must_on | free_on  # must-on and free-on initially committed\n    total_min = sum(min_limits[i] for i in committed)\n    total_max = sum(max_limits[i] for i in committed)\n    \n    # Step 5b: Add free-off if needed\n    if total_max < current_load:\n        cost_efficiency = []\n        for i in free_off:\n            s_i = units_info[i]['s_i']\n            min_cost = units_info[i]['b_i'] * min_limits[i] + units_info[i]['c_i'] * min_limits[i] ** 2\n            cost_efficiency.append(( (s_i + min_cost) / min_limits[i], i))\n        cost_efficiency.sort(key=lambda x: x[0])\n        \n        for _, i in cost_efficiency:\n            if total_max < current_load:\n                committed.add(i)\n                total_min += min_limits[i]\n                total_max += max_limits[i]\n            else:\n                break\n    \n    # Step 5c: Remove non-must if min > load\n    non_must = [i for i in committed if i not in must_on]  # removable units\n    if total_min > current_load:\n        removal_efficiency = []\n        for i in non_must:\n            min_cost = units_info[i]['b_i'] * min_limits[i] + units_info[i]['c_i'] * min_limits[i] ** 2\n            # Avoidable cost includes startup if unit was off originally\n            avoidable_cost = min_cost + (units_info[i]['s_i'] if i in free_off else 0)\n            removal_efficiency.append((avoidable_cost / min_limits[i], i))\n        removal_efficiency.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in removal_efficiency:\n            if total_min > current_load and (total_max - max_limits[i]) >= current_load:\n                committed.remove(i)\n                total_min -= min_limits[i]\n                total_max -= max_limits[i]\n    \n    # Step 6: Dispatch final committed set\n    u_outputs = [1 if i in committed else 0 for i in range(n_units)]\n    p_outputs = lambda_iteration_dispatch(\n        units_info, committed, min_limits, max_limits, current_load\n    )\n    return np.array([u_outputs, p_outputs])\n\ndef lambda_iteration_dispatch(units_info, committed, min_limits, max_limits, load_current):\n    n_units = len(units_info)\n    p_outputs = np.zeros(n_units)\n    \n    # Initialize to min outputs\n    for i in committed:\n        p_outputs[i] = min_limits[i]\n    total_p = sum(p_outputs)\n    \n    # Only dispatch if load > total min output\n    if abs(total_p - load_current) < 1e-6:\n        return p_outputs.tolist()\n    \n    # Get initial lambda bounds\n    lb = float('inf')\n    ub = 0\n    for i in committed:\n        mc_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_limits[i]\n        mc_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_limits[i]\n        lb = min(lb, mc_min)\n        ub = max(ub, mc_max)\n    \n    # Binary search for lambda\n    tol = 0.01  # tolerance in MW\n    max_iter = 100\n    iter_count = 0\n    while ub - lb > tol and iter_count < max_iter:\n        lam = (lb + ub) / 2\n        total_p_temp = 0\n        for i in committed:\n            if units_info[i]['c_i'] == 0:  # linear unit\n                if lam >= units_info[i]['b_i']:\n                    p_i = max_limits[i]\n                else:\n                    p_i = min_limits[i]\n            else:  # quadratic unit\n                p_i = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_i = max(min_limits[i], min(max_limits[i], p_i))\n            total_p_temp += p_i\n        \n        if total_p_temp < load_current:\n            lb = lam\n        else:\n            ub = lam\n        iter_count += 1\n    \n    # Assign final outputs\n    lam = (lb + ub) / 2\n    for i in committed:\n        if units_info[i]['c_i'] == 0:\n            p_outputs[i] = max_limits[i] if lam >= units_info[i]['b_i'] else min_limits[i]\n        else:\n            p_unclamped = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            p_outputs[i] = max(min_limits[i], min(max_limits[i], p_unclamped))\n    \n    return p_outputs.tolist()",
          "from": "crossover",
          "gap_power_rate": 0.0048053347,
          "gap_price_rate": 0.0150684056,
          "fitness": 0.0099368701
     },
     {
          "name": "hybrid_rolling_commitment_optimized",
          "algorithm": "1. Classify units into must-on (units that must remain online due to min up-time or shutdown ramp constraints), must-off (units that must remain offline due to min down-time), free-on (online units that can be shut down), and free-off (offline units that can be started).\n2. Compute effective min/max outputs:\n   - For online units (must-on/free-on): min_eff = max(p_min_i, p_prev - ramp_down_i), max_eff = min(p_max_i, p_prev + ramp_up_i)\n   - For startable units (free-off): min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n3. If must-on min output > load: commit only must-on at min_eff (over-generation).\n4. Else if must-on can cover load: commit only must-on and proceed to dispatch.\n5. Else:\n   a. Initially commit must-on + free-on units\n   b. If total max_eff < load: add free-off units by cost-efficiency (startup + min-output cost)/min_output until load covered\n   c. If total min_eff > load: remove non-must units with highest cost/MW at min_eff first while maintaining feasibility\n6. Dispatch committed units:\n   a. Initialize all outputs to min_eff\n   b. Use min-heap to distribute deficit (load - sum(min_eff)) to units with lowest marginal cost\n   c. Handle over-generation by leaving outputs at min_eff\n7. Return commitment states and power outputs.\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef hybrid_rolling_commitment_optimized(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    for i, unit in enumerate(units_info):\n        if i in must_on + free_on:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff[i] = 0\n            max_eff[i] = 0\n    \n    total_min_must = sum(min_eff[i] for i in must_on)\n    total_max_must = sum(max_eff[i] for i in must_on)\n    \n    if total_min_must >= current_load:\n        u = [1 if i in must_on else 0 for i in range(n_units)]\n        p = [min_eff[i] if i in must_on else 0 for i in range(n_units)]\n        return np.array([u, p])\n    \n    if total_min_must <= current_load <= total_max_must:\n        committed = must_on\n    else:\n        committed = must_on + free_on\n        total_max = sum(max_eff[i] for i in committed)\n        total_min = sum(min_eff[i] for i in committed)\n        \n        if total_max < current_load:\n            candidates = []\n            for i in free_off:\n                min_cost = units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i]**2\n                total_cost = min_cost + units_info[i]['s_i']\n                if min_eff[i] > 1e-6:\n                    cost_per_mw = total_cost / min_eff[i]\n                    candidates.append((cost_per_mw, i))\n            \n            candidates.sort(key=lambda x: x[0])\n            for _, idx in candidates:\n                if total_max < current_load:\n                    committed.append(idx)\n                    total_min += min_eff[idx]\n                    total_max += max_eff[idx]\n                else:\n                    break\n        \n        total_min = sum(min_eff[i] for i in committed)\n        if total_min > current_load:\n            free_in_commit = [i for i in committed if i in free_on or (i in free_off and i not in must_on)]\n            candidates = []\n            for i in free_in_commit:\n                op_cost = units_info[i]['a_i'] + units_info[i]['b_i']*min_eff[i] + units_info[i]['c_i']*min_eff[i]**2\n                saving = op_cost\n                if i in free_off:\n                    saving += units_info[i]['s_i']\n                if min_eff[i] > 1e-6:\n                    saving_per_mw = saving / min_eff[i]\n                    candidates.append((saving_per_mw, saving, min_eff[i], max_eff[i], i))\n            \n            candidates.sort(key=lambda x: x[0], reverse=True)\n            removed = []\n            current_total_min = total_min\n            current_total_max = total_max\n            \n            for saving_per_mw, saving, m_eff, mx_eff, i in candidates:\n                if current_total_min - m_eff <= current_load and current_total_max - mx_eff >= current_load:\n                    removed.append(i)\n                    current_total_min -= m_eff\n                    current_total_max -= mx_eff\n                    if current_total_min <= current_load:\n                        break\n            \n            committed = [i for i in committed if i not in removed]\n    \n    u = [1 if i in committed else 0 for i in range(n_units)]\n    p = np.zeros(n_units)\n    for i in committed:\n        p[i] = min_eff[i]\n    \n    deficit = current_load - sum(p)\n    if deficit > 1e-6:\n        heap = []\n        for i in committed:\n            if p[i] < max_eff[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                room = max_eff[i] - p[i]\n                heapq.heappush(heap, (marginal_cost, i, room))\n        \n        while deficit > 1e-6 and heap:\n            mc, i, room = heapq.heappop(heap)\n            add = min(deficit, room)\n            p[i] += add\n            deficit -= add\n            new_room = room - add\n            if new_room > 1e-6:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                heapq.heappush(heap, (new_mc, i, new_room))\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.005211854,
          "gap_price_rate": 0.0150284964,
          "fitness": 0.0101201752
     },
     {
          "name": "enhanced_hybrid_commitment",
          "algorithm": "1. Classify units:\n   - must_on: u_i_0=1 and (t_i_0 < t_on_min_i or p_i_0 > p_shut_i or p_i_0 > p_down_i)\n   - must_off: u_i_0=0 and |t_i_0| < t_off_min_i\n   - free_on: u_i_0=1 not must_on\n   - free_off: u_i_0=0 not must_off with available capacity (p_min_i <= min(p_max_i, p_start_i))\n\n2. Compute effective limits:\n   - must_on/free_on: min_eff = max(p_min_i, p_i_0 - p_down_i), max_eff = min(p_max_i, p_i_0 + p_up_i)\n   - free_off: min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n\n3. Handle special cases:\n   a. must_on min_eff sum \u2265 load: commit only must_on at min_eff\n   b. must_on max_eff sum \u2265 load: commit must_on, dispatch via min-heap (lowest marginal cost first)\n   c. Else:\n      - Initialize committed_set = must_on + free_on\n      - Add free_off sorted by cost-efficiency until max_eff sum \u2265 load\n      - If min_eff sum > load, remove non-must units sorted by avoidable cost/MW while maintaining max_eff \u2265 load\n      - Dispatch via min-heap (lowest marginal cost first) respecting min_eff/max_eff\n\n4. Turn off non-committed units when feasible (u_i_0=1 and p_i_0 \u2264 p_down_i and p_i_0 \u2264 p_shut_i)\n\n5. Return u_i, p_i for all units\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    categories = {'must_on': [], 'must_off': [], 'free_on': [], 'free_off': []}\n    units = []\n    idx_map = {}\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        key = (unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i'])\n        \n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i'] or p0 > unit['p_down_i']:\n                category = 'must_on'\n            else:\n                category = 'free_on'\n        else:\n            if abs(t0) < unit['t_off_min_i']:\n                category = 'must_off'\n            else:\n                if unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n                    category = 'free_off'\n                else:\n                    category = 'must_off'\n        \n        categories[category].append(i)\n        idx_map[i] = unit\n        units.append({\n            **unit, \n            'category': category,\n            'idx': i\n        })\n    \n    # Compute effective limits\n    for unit in units:\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        \n        if unit['category'] in ['must_on', 'free_on']:\n            min_eff = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_eff = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        elif unit['category'] == 'free_off':\n            min_eff = unit['p_min_i']\n            max_eff = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff = 0\n            max_eff = 0\n            \n        unit['min_eff'] = min_eff\n        unit['max_eff'] = max_eff\n    \n    # Initialize outputs and states\n    schedules = np.zeros((2, len(units)))\n    committed_set = []\n    \n    def must_on_units():\n        return [u for u in units if u['category'] == 'must_on']\n    \n    must_on_min_sum = sum(u['min_eff'] for u in must_on_units())\n    must_on_max_sum = sum(u['max_eff'] for u in must_on_units())\n    \n    # Case 1: Must-on over-generation\n    if must_on_min_sum >= current_load:\n        for u in must_on_units():\n            idx = u['idx']\n            schedules[0, idx] = 1\n            schedules[1, idx] = u['min_eff']\n        committed_set = must_on_units()\n    # Case 2: Must-on can cover\n    elif must_on_max_sum >= current_load:\n        committed_set = must_on_units()\n        # Initialize at min_eff\n        total_min = 0\n        for u in committed_set:\n            idx = u['idx']\n            schedules[0, idx] = 1\n            schedules[1, idx] = u['min_eff']\n            total_min += u['min_eff']\n        \n        deficit = current_load - total_min\n        heap = []\n        for u in committed_set:\n            if schedules[1, u['idx']] < u['max_eff']:\n                mc = u['b_i'] + 2 * u['c_i'] * schedules[1, u['idx']]\n                heapq.heappush(heap, (mc, u['idx'], u))\n        \n        while deficit > 0 and heap:\n            _, idx, u = heapq.heappop(heap)\n            avail = min(u['max_eff'] - schedules[1, idx], deficit)\n            schedules[1, idx] += avail\n            deficit -= avail\n            if schedules[1, idx] < u['max_eff']:\n                new_mc = u['b_i'] + 2 * u['c_i'] * schedules[1, idx]\n                heapq.heappush(heap, (new_mc, idx, u))\n    # Case 3: Need additional units\n    else:\n        committed_set = [u for u in units if u['category'] in ['must_on', 'free_on']]\n        free_off_avail = [u for u in units if u['category'] == 'free_off' and u['max_eff'] > 0]\n        min_sum = sum(u['min_eff'] for u in committed_set)\n        max_sum = sum(u['max_eff'] for u in committed_set)\n        \n        # Add free_off by cost-efficiency\n        free_off_avail.sort(key=lambda u: \n            (u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff']\n        )\n        \n        for u in free_off_avail:\n            if max_sum >= current_load:\n                break\n            committed_set.append(u)\n            min_sum += u['min_eff']\n            max_sum += u['max_eff']\n        \n        # Remove non-must if over-committed\n        non_must = [u for u in committed_set if u['category'] != 'must_on']\n        if min_sum > current_load and non_must:\n            non_must.sort(\n                key=lambda u: ( (u['s_i'] if u['category']=='free_off' else 0) + \n                               u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2 ) / u['min_eff'],\n                reverse=True\n            )\n            i = 0\n            while i < len(non_must) and min_sum > current_load:\n                u = non_must[i]\n                if max_sum - u['max_eff'] >= current_load:\n                    committed_set.remove(u)\n                    min_sum -= u['min_eff']\n                    max_sum -= u['max_eff']\n                i += 1\n        \n        # Dispatch for final set\n        for u in committed_set:\n            idx = u['idx']\n            schedules[0, idx] = 1\n            schedules[1, idx] = u['min_eff']\n        \n        deficit = current_load - min_sum\n        heap = []\n        for u in committed_set:\n            if schedules[1, u['idx']] < u['max_eff']:\n                mc = u['b_i'] + 2 * u['c_i'] * schedules[1, u['idx']]\n                heapq.heappush(heap, (mc, u['idx'], u))\n        \n        while deficit > 0 and heap:\n            _, idx, u = heapq.heappop(heap)\n            avail = min(u['max_eff'] - schedules[1, idx], deficit)\n            schedules[1, idx] += avail\n            deficit -= avail\n            if schedules[1, idx] < u['max_eff']:\n                new_mc = u['b_i'] + 2 * u['c_i'] * schedules[1, idx]\n                heapq.heappush(heap, (new_mc, idx, u))\n    \n    # Handle non-committed units (turn off if feasible)\n    for u in units:\n        if u not in committed_set and u['u_i_0'] == 1:\n            if u['p_i_0'] <= u['p_down_i'] and u['p_i_0'] <= u['p_shut_i']:\n                schedules[0, u['idx']] = 0\n                schedules[1, u['idx']] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0004980271,
          "gap_price_rate": 0.0220410863,
          "fitness": 0.0112695567
     },
     {
          "name": "hybrid_enhanced_commitment_refined",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off considering min up/down times, shutdown constraints, and ramp limits:\n   - Must-on: Online units violating min up-time or shutdown capacity constraint (p_i_0 > min(p_down_i, p_shut_i))\n   - Must-off: Offline units violating min down-time\n   - Free-on: Online units that can be turned off\n   - Free-off: Offline units that can be turned on\n2. Compute effective min/max outputs:\n   - Online units: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - Free-off units: [p_min, min(p_max, startup_ramp)]\n3. If must-on units' min outputs exceed load:\n   - Commit only must-on at min outputs (over-generation)\n4. Else if must-on units can cover load:\n   - Commit only must-on units and dispatch load among them\n5. Else:\n   a. Initially commit must-on and free-on units\n   b. If total max < load:\n      - Add free-off units by ascending cost-efficiency: (s_i + a_i + b_i * min_eff + c_i * min_eff\u00b2) / min_eff\n   c. If total min > load:\n      - Remove non-must units by descending saving per MW: (a_i + b_i * min_eff + c_i * min_eff\u00b2 + s_i * offline) / min_eff\n      - Maintain feasibility (total max >= load) during removal\n6. Dispatch load among committed units:\n   a. Initialize outputs at effective min\n   b. Use min-heap to distribute deficit to units with lowest incremental cost (b_i + 2 * c_i * p_i)\n   c. Handle over-generation by leaving at min outputs\n7. Assign commitment states/power outputs to all units\n",
          "code": "import heapq\nimport numpy as np\n\ndef hybrid_enhanced_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        if u0 == 1:  # Currently online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > min(unit['p_down_i'], unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Currently offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Case 1: Must-on units cause over-generation\n    total_min_must = sum(min_eff[i] for i in must_on)\n    if total_min_must > current_load:\n        committed = must_on\n        for i in committed:\n            u[i] = 1\n            p[i] = min_eff[i]\n        schedules = np.vstack((u, p))\n        return schedules\n    \n    # Case 2: Must-on units alone can cover load\n    total_max_must = sum(max_eff[i] for i in must_on)\n    if total_max_must >= current_load:\n        committed = must_on\n    else:\n        # Case 3: Need additional units\n        committed = must_on + free_on\n        total_min_comm = total_min_must + sum(min_eff[i] for i in free_on)\n        total_max_comm = total_max_must + sum(max_eff[i] for i in free_on)\n        \n        if total_max_comm < current_load:\n            # Add free-off units by cost efficiency\n            eff_ranks = []\n            for i in free_off:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i] ** 2\n                eff = cost / min_eff[i]\n                eff_ranks.append((eff, i))\n            eff_ranks.sort()\n            \n            for eff, idx in eff_ranks:\n                committed.append(idx)\n                total_min_comm += min_eff[idx]\n                total_max_comm += max_eff[idx]\n                if total_max_comm >= current_load:\n                    break\n        \n        if total_min_comm > current_load:\n            # Remove non-must units\n            saving_ranks = []\n            non_must = [i for i in committed if i not in must_on]\n            for i in non_must:\n                startup_cost = 0 if units_info[i]['u_i_0'] == 1 else units_info[i]['s_i']\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + \n                        units_info[i]['c_i'] * min_eff[i] ** 2 + startup_cost)\n                saving_ranks.append((cost / min_eff[i], i))\n            saving_ranks.sort(reverse=True)\n            \n            for sav_per_mw, idx in saving_ranks:\n                if (total_min_comm - min_eff[idx] <= current_load and \n                    total_max_comm - max_eff[idx] >= current_load):\n                    committed.remove(idx)\n                    total_min_comm -= min_eff[idx]\n                    total_max_comm -= max_eff[idx]\n                if total_min_comm <= current_load:\n                    break\n    \n    # Dispatch load among committed units\n    deficit = current_load - sum(min_eff[i] for i in committed)\n    p_committed = {i: min_eff[i] for i in committed}\n    \n    if deficit > 0:\n        heap = []\n        for i in committed:\n            ic = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_eff[i]\n            heapq.heappush(heap, (ic, i, units_info[i]))\n        \n        while deficit > 0 and heap:\n            ic, idx, unit = heapq.heappop(heap)\n            room = max_eff[idx] - p_committed[idx]\n            if room <= 1e-6:\n                continue\n            assign = min(room, deficit)\n            p_committed[idx] += assign\n            deficit -= assign\n            if p_committed[idx] < max_eff[idx]:\n                new_ic = unit['b_i'] + 2 * unit['c_i'] * p_committed[idx]\n                heapq.heappush(heap, (new_ic, idx, unit))\n    \n    for i in committed:\n        u[i] = 1\n        p[i] = p_committed[i]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0003866589,
          "gap_price_rate": 0.0329040147,
          "fitness": 0.0166453368
     },
     {
          "name": "rolling_commitment_optimized",
          "algorithm": "1. Classify units into must_on, must_off, free_on, and free_off based on current state and constraints.\n2. Compute effective min/max outputs considering ramp limits and startup/shutdown constraints.\n3. If must_on units can cover the load:\n   - If must_on min outputs exceed load, commit only must_on at min outputs (over-generation).\n   - Else, commit must_on and dispatch using min-heap allocation to meet load.\n4. Else (must_on cannot cover load):\n   a. Commit must_on and free_on units as base.\n   b. Add free_off units by cost-efficiency until load coverage achieved.\n   c. If total min outputs exceed load, remove non-must units by avoidable cost/MW until feasible.\n   d. Dispatch using min-heap allocation to distribute deficit if min outputs <= load.\n5. Set non-committed units to off state.\n6. Return commitment states and power outputs in input order.\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef rolling_commitment_optimized(units_info, load):\n    num_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    min_eff = np.zeros(num_units)\n    max_eff = np.zeros(num_units)\n    categories = {'must_on': [], 'must_off': [], 'free_on': [], 'free_off': []}\n    \n    # Classify units and compute effective limits\n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        # Classify units\n        must_on = False\n        must_off = False\n        if u_i_0 == 1:\n            must_on = (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i)\n        else:\n            must_off = -t_i_0 < t_off_min_i\n            \n        # Compute effective limits\n        if u_i_0 == 1:\n            min_eff[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_eff[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_eff[i] = p_min_i\n            max_eff[i] = min(p_max_i, p_start_i)\n        \n        # Categorize\n        if must_on:\n            categories['must_on'].append(i)\n        elif must_off:\n            categories['must_off'].append(i)\n        elif u_i_0 == 1:\n            categories['free_on'].append(i)\n        else:\n            categories['free_off'].append(i)\n    \n    # Check must_on coverage scenarios\n    must_on_indices = categories['must_on']\n    total_must_on_min = sum(min_eff[i] for i in must_on_indices)\n    total_must_on_max = sum(max_eff[i] for i in must_on_indices)\n    \n    if total_must_on_min > current_load:\n        # Scenario 1: Over-generation with must_on units\n        committed_set = set(must_on_indices)\n        for i in committed_set:\n            u[i] = 1\n            p[i] = min_eff[i]\n        schedules = np.array([u, p])\n        return schedules\n        \n    elif total_must_on_max >= current_load:\n        # Scenario 2: Dispatch only must_on units\n        committed_set = set(must_on_indices)\n        total_min = total_must_on_min\n        deficit = current_load - total_min\n        outputs = np.zeros(num_units)\n        for i in committed_set:\n            outputs[i] = min_eff[i]\n        \n        # Min-heap for incremental dispatch\n        heap = []\n        for i in committed_set:\n            marginal_cost = 2 * c_i * min_eff[i] + b_i\n            heapq.heappush(heap, (marginal_cost, i, min_eff[i]))\n        \n        while deficit > 1e-5 and heap:\n            cost, idx, current = heapq.heappop(heap)\n            max_additional = max_eff[idx] - current\n            if max_additional <= 0:\n                continue\n            increment = min(deficit, max_additional)\n            outputs[idx] += increment\n            deficit -= increment\n            new_marginal = 2 * units_info[idx]['c_i'] * outputs[idx] + units_info[idx]['b_i']\n            heapq.heappush(heap, (new_marginal, idx, outputs[idx]))\n        \n        for i in committed_set:\n            u[i] = 1\n            p[i] = outputs[i]\n        schedules = np.array([u, p])\n        return schedules\n    \n    else:\n        # Scenario 3: Need additional units\n        committed_set = set(must_on_indices + categories['free_on'])\n        total_max_eff = sum(max_eff[i] for i in committed_set)\n        free_off_indices = categories['free_off']\n        \n        # Add free_off units by cost-efficiency\n        candidate_units = []\n        for i in free_off_indices:\n            s_i = units_info[i]['s_i']\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i]**2\n            avg_cost = (s_i + cost_at_min) / min_eff[i]\n            candidate_units.append((avg_cost, i))\n        \n        candidate_units.sort(key=lambda x: x[0])\n        \n        for _, idx in candidate_units:\n            if total_max_eff >= current_load:\n                break\n            committed_set.add(idx)\n            total_max_eff += max_eff[idx]\n        \n        # Removal step if total min > load\n        total_min_eff = sum(min_eff[i] for i in committed_set)\n        non_must = [i for i in committed_set if i not in must_on_indices]\n        \n        if total_min_eff > current_load:\n            removal_candidates = []\n            for i in non_must:\n                unit = units_info[i]\n                s_i = unit['s_i'] if i in free_off_indices else 0\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n                avoidable_per_MW = (s_i + cost_at_min) / min_eff[i]\n                removal_candidates.append((avoidable_per_MW, i))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            removal_candidates = [i for _, i in removal_candidates]\n            \n            for idx in removal_candidates:\n                if total_min_eff <= current_load:\n                    break\n                if total_max_eff - max_eff[idx] >= current_load:\n                    committed_set.remove(idx)\n                    total_min_eff -= min_eff[idx]\n                    total_max_eff -= max_eff[idx]\n        \n        # Dispatch step\n        if total_min_eff > current_load:\n            # Over-generation: set to min_eff\n            for i in committed_set:\n                u[i] = 1\n                p[i] = min_eff[i]\n        else:\n            # Dispatch deficit using min-heap\n            total_min = total_min_eff\n            deficit = current_load - total_min\n            outputs = np.zeros(num_units)\n            heap = []\n            for i in committed_set:\n                outputs[i] = min_eff[i]\n                marginal_cost = 2 * units_info[i]['c_i'] * min_eff[i] + units_info[i]['b_i']\n                heapq.heappush(heap, (marginal_cost, i, min_eff[i]))\n            \n            while deficit > 1e-5 and heap:\n                cost, idx, current = heapq.heappop(heap)\n                max_additional = max_eff[idx] - current\n                if max_additional <= 0:\n                    continue\n                increment = min(deficit, max_additional)\n                outputs[idx] += increment\n                deficit -= increment\n                new_marginal = 2 * units_info[idx]['c_i'] * outputs[idx] + units_info[idx]['b_i']\n                heapq.heappush(heap, (new_marginal, idx, outputs[idx]))\n            \n            for i in committed_set:\n                u[i] = 1\n                p[i] = outputs[i]\n        \n        # Set non-committed units to off\n        for i in set(range(num_units)) - committed_set:\n            u[i] = 0\n            p[i] = 0\n        \n        schedules = np.array([u, p])\n        return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0010436061,
          "gap_price_rate": 0.0402391511,
          "fitness": 0.0206413786
     }
]