[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "novel_hybrid_heuristic",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints: for online units use max(p_min, p_prev - ramp_down) and min(p_max, p_prev + ramp_up); for free-off units use p_min and min(p_max, p_start).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, use lambda iteration to dispatch only must-on units.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by efficiency metric: (startup_cost + a_i + b_i*p_min + c_i*(p_min**2)) / p_min\n   c. If total min output exceeds load, remove non-must units by avoidable cost per MW: (a_i + b_i*p_min + c_i*(p_min**2) + (s_i if free-off)) / p_min\n   d. Dispatch via bisection-based lambda iteration respecting effective bounds\n6. Set non-committed units offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef novel_hybrid_heuristic(units_info, load):\n    current_load = load[0]\n    \n    # Define dispatch helper function\n    def dispatch_units(units, target):\n        lo, hi = -1e6, 1e6\n        n_iter = 100\n        min_sum = sum(unit['eff_min'] for unit in units)\n        max_sum = sum(unit['eff_max'] for unit in units)\n        target_clamped = max(min_sum, min(max_sum, target))\n        \n        for _ in range(n_iter):\n            lam = (lo + hi) / 2.0\n            total_p = 0.0\n            for unit in units:\n                p = (lam - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else unit['eff_max']\n                p_clamped = max(unit['eff_min'], min(unit['eff_max'], p))\n                total_p += p_clamped\n            \n            if total_p < target_clamped:\n                lo = lam\n            else:\n                hi = lam\n        \n        outputs = []\n        for unit in units:\n            p = (lam - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else unit['eff_max']\n            p_clamped = max(unit['eff_min'], min(unit['eff_max'], p))\n            outputs.append(p_clamped)\n        return outputs\n\n    # Classify units and compute effective bounds\n    units = [unit.copy() for unit in units_info]\n    must_on_indices = []\n    must_off_indices = []\n    free_on_indices = []\n    free_off_indices = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n            else:\n                free_on_indices.append(i)\n        else:\n            unit['eff_min'] = unit['p_min_i']\n            unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                free_off_indices.append(i)\n    \n    # Compute must-on totals\n    must_on_min = sum(units[i]['eff_min'] for i in must_on_indices)\n    must_on_max = sum(units[i]['eff_max'] for i in must_on_indices)\n    \n    # Case 1: Must-on min exceeds load\n    if must_on_min >= current_load:\n        u_list = [1 if i in must_on_indices else 0 for i in range(len(units))]\n        p_list = [units[i]['eff_min'] if i in must_on_indices else 0.0 for i in range(len(units))]\n        return np.array([u_list, p_list])\n    \n    # Case 2: Must-on covers load\n    if must_on_max >= current_load:\n        must_on_units = [units[i] for i in must_on_indices]\n        dispatch_out = dispatch_units(must_on_units, current_load)\n        u_list = [1 if i in must_on_indices else 0 for i in range(len(units))]\n        p_list = [dispatch_out[must_on_indices.index(i)] if i in must_on_indices else 0.0 for i in range(len(units))]\n        return np.array([u_list, p_list])\n    \n    # Case 3: Need additional units\n    committed_indices = must_on_indices + free_on_indices\n    total_min = must_on_min + sum(units[i]['eff_min'] for i in free_on_indices)\n    total_max = must_on_max + sum(units[i]['eff_max'] for i in free_on_indices)\n    \n    # Add free-off units if needed\n    if total_max < current_load:\n        free_off_candidates = []\n        for i in free_off_indices:\n            cost_at_min = units[i]['a_i'] + units[i]['b_i']*units[i]['p_min_i'] + units[i]['c_i']*(units[i]['p_min_i']**2)\n            efficiency = (units[i]['s_i'] + cost_at_min) / units[i]['p_min_i']\n            free_off_candidates.append((i, efficiency))\n        free_off_candidates.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_off_candidates:\n            committed_indices.append(idx)\n            total_max += units[idx]['eff_max']\n            total_min += units[idx]['eff_min']\n            if total_max >= current_load:\n                break\n    \n    # Remove non-must units if min too high\n    if total_min > current_load:\n        non_must = [i for i in committed_indices if i not in must_on_indices]\n        avoidable_costs = []\n        for i in non_must:\n            cost_at_min = units[i]['a_i'] + units[i]['b_i']*units[i]['p_min_i'] + units[i]['c_i']*(units[i]['p_min_i']**2)\n            if units[i]['u_i_0'] == 0:\n                cost_at_min += units[i]['s_i']\n            avoidable_per_mw = cost_at_min / units[i]['p_min_i']\n            avoidable_costs.append((i, avoidable_per_mw))\n        avoidable_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        temp_committed = set(committed_indices)\n        for i, _ in avoidable_costs:\n            new_total_min = total_min - units[i]['eff_min']\n            new_total_max = total_max - units[i]['eff_max']\n            if new_total_min <= current_load or new_total_max < current_load:\n                continue\n            temp_committed.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_min <= current_load:\n                break\n        committed_indices = list(temp_committed)\n    \n    # Dispatch committed units\n    committed_units = [units[i] for i in committed_indices]\n    dispatch_out = dispatch_units(committed_units, current_load)\n    \n    # Prepare final schedule\n    u_list = [0] * len(units)\n    p_list = [0.0] * len(units)\n    for idx, unit_idx in enumerate(committed_indices):\n        u_list[unit_idx] = 1\n        p_list[unit_idx] = dispatch_out[idx]\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0089176296,
          "fitness": 0.007173083
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot switch off due to min-up/shutdown constraints), must-off (cannot switch on due to min-down constraints), free-on (online units with switching flexibility), and free-off (offline units with switching flexibility).\n2. Compute effective min/max outputs:\n   - Online units: min_eff = max(p_min_i, p_i_0 - p_down_i), max_eff = min(p_max_i, p_i_0 + p_up_i)\n   - Free-off units: min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n   - Must-off units: min_eff = 0, max_eff = 0\n3. Handle must-on feasibility:\n   - If must-on min_eff sum > load: commit must-on at min_eff (over-generation)\n   - Else if must-on max_eff sum >= load: set committed = must-on\n   - Else: initially commit must-on + free-on. If capacity insufficient, add free-off units by ascending order of (startup_cost + cost_at_min_output)/min_output. If total min_eff > load, remove non-must units by highest avoidable_cost_per_MW while ensuring capacity feasibility.\n4. Dispatch committed units:\n   - If total min_eff > load: over-generate at min_eff\n   - Else: perform lambda-iteration (bisection) for economic dispatch, handling quadratic cost functions analytically and linear costs via thresholding\n5. Set non-committed units to offline (u_i=0, p_i=0) and return schedule\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    n = len(units_info)\n    units = [u.copy() for u in units_info]\n    for i, u in enumerate(units):\n        u['index'] = i\n    \n    # Step 1: Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            off_periods = -unit['t_i_0']  # Convert to positive offline count\n            if off_periods < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # Step 2: Compute effective min/max outputs\n    for unit in units:\n        if unit in must_off:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n        elif unit['u_i_0'] == 1:  # Online units\n            min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_eff'] = min_eff\n            unit['max_eff'] = max_eff\n        else:  # Free-off units\n            min_eff = unit['p_min_i']\n            max_eff = min(unit['p_max_i'], unit['p_start_i'])\n            unit['min_eff'] = min_eff\n            unit['max_eff'] = max_eff\n    \n    load_current = load[0]  # Current load to allocate\n    committed = []\n    \n    # Step 3.1: Handle must-on feasibility\n    total_min_must = sum(u['min_eff'] for u in must_on)\n    total_max_must = sum(u['max_eff'] for u in must_on)\n    \n    if total_min_must > load_current:\n        committed = must_on  # Over-generation case\n    elif total_max_must >= load_current:\n        committed = must_on  # Dispatch only must-on\n    else:\n        # Start with must-on + free-on\n        committed = must_on + free_on\n        total_min_comm = total_min_must + sum(u['min_eff'] for u in free_on)\n        total_max_comm = total_max_must + sum(u['max_eff'] for u in free_on)\n        \n        # Add free-off units if capacity insufficient\n        if total_max_comm < load_current:\n            # Sort by cost efficiency: (startup + cost_at_min_output)/min_output\n            free_off.sort(key=lambda u: \n                (u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff'] \n                if u['min_eff'] > 0 else float('inf'))\n            for unit in free_off:\n                if total_max_comm >= load_current:\n                    break\n                committed.append(unit)\n                total_min_comm += unit['min_eff']\n                total_max_comm += unit['max_eff']\n        \n        # Remove non-must units if minimum outputs exceed load\n        if total_min_comm > load_current:\n            non_must = [u for u in committed if u not in must_on]\n            # Compute avoidable cost per MW\n            for u in non_must:\n                if u in free_off:\n                    cost = u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2\n                else:  # free_on\n                    cost = u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2\n                u['avoidable_per_mw'] = cost / u['min_eff'] if u['min_eff'] > 0 else float('inf')\n            \n            # Sort descending by avoidable_per_mw\n            non_must.sort(key=lambda u: u['avoidable_per_mw'], reverse=True)\n            \n            # Remove units while preserving feasibility\n            removed = []\n            for unit in non_must:\n                if total_min_comm - unit['min_eff'] <= load_current and total_max_comm - unit['max_eff'] >= load_current:\n                    committed.remove(unit)\n                    total_min_comm -= unit['min_eff']\n                    total_max_comm -= unit['max_eff']\n                    removed.append(unit)\n                    if total_min_comm <= load_current:\n                        break\n    \n    # Dispatch preparation\n    u_out = [0] * n\n    p_out = [0] * n\n    total_min_comm = sum(u['min_eff'] for u in committed)\n    \n    if total_min_comm > load_current or len(committed) == 0:\n        # Over-generation or no units\n        for unit in committed:\n            p_out[unit['index']] = unit['min_eff']\n            u_out[unit['index']] = 1\n    else:\n        # Step 4: Lambda-iteration dispatch\n        low_lambda = float('inf')\n        high_lambda = -float('inf')\n        \n        # Find initial lambda bounds\n        for u in committed:\n            if u['c_i'] == 0:  # Linear unit\n                mc = u['b_i']\n            else:  # Quadratic unit\n                mc_min = 2 * u['c_i'] * u['min_eff'] + u['b_i']\n                mc_max = 2 * u['c_i'] * u['max_eff'] + u['b_i']\n                mc = max(mc_min, mc_max)\n            high_lambda = max(high_lambda, mc)\n            low_lambda = min(low_lambda, u['b_i'])  # Linear cost or marginal at min\n        \n        # Lambda bisection algorithm\n        tolerance = 1e-5\n        for _ in range(100):  # Max iterations\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0\n            for unit in committed:\n                if unit['c_i'] == 0:  # Linear\n                    p = unit['max_eff'] if unit['b_i'] <= mid_lambda else unit['min_eff']\n                else:  # Quadratic\n                    p_unbound = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p = max(unit['min_eff'], min(unit['max_eff'], p_unbound))\n                unit['p_temp'] = p\n                total_power += p\n            \n            if abs(total_power - load_current) < tolerance:\n                break\n            elif total_power < load_current:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Assign final dispatch values\n        for unit in committed:\n            p_out[unit['index']] = unit['p_temp']\n            u_out[unit['index']] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0089176297,
          "fitness": 0.0071730836
     },
     {
          "name": "optimized_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on with feasible startup constraints).\n2. Compute effective min/max outputs for online units considering ramp constraints and startup limits for free-off units.\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, commit only must-on units and use lambda iteration for dispatch.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by cost-efficiency if capacity is insufficient\n   c. Remove non-must units by avoidable cost per MW if min output exceeds load while maintaining feasibility\n6. Dispatch load using lambda iteration on committed units to minimize cost under constraints\n7. Set non-committed units to offline state (u=0, p=0)\n",
          "code": "import numpy as np\nimport heapq\n\ndef optimized_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u0 == 1 and ((t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif u0 == 0 and t0 > -unit['t_off_min_i']:  # t0 is negative for offline\n            must_off.append(i)\n        # Free-on\n        elif u0 == 1:\n            free_on.append(i)\n        # Free-off (with startup feasibility)\n        elif u0 == 0 and unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n            free_off.append(i)\n    \n    # Prepare unit dictionaries for processing\n    for i, unit in enumerate(units_info):\n        # Compute effective min/max for all relevant units\n        if i in must_on or i in free_on:\n            unit['min_eff'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            unit['min_eff'] = unit['p_min_i']\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n    \n    # Step 3: Check if must-on can cover alone (over-generation)\n    must_on_min_sum = sum(units_info[i]['min_eff'] for i in must_on)\n    must_on_max_sum = sum(units_info[i]['max_eff'] for i in must_on)\n    \n    if must_on_min_sum >= current_load:\n        committed = must_on\n        for i in committed:\n            units_info[i]['p_i'] = units_info[i]['min_eff']\n            units_info[i]['u_i'] = 1\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 4: Must-on coverage\n    elif must_on_max_sum >= current_load:\n        committed = must_on\n        dispatch_with_lambda(units_info, committed, current_load)\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 5: General case\n    else:\n        committed = must_on + free_on\n        total_min = sum(units_info[i]['min_eff'] for i in committed)\n        total_max = sum(units_info[i]['max_eff'] for i in committed)\n        \n        # Step 5b: Add free-off units if needed\n        if total_max < current_load and free_off:\n            # Calculate cost efficiency: (startup + fixed + variable) / min_output\n            cost_efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                total_cost = unit['s_i'] + cost_at_min\n                cost_efficiency.append((total_cost / min_eff, i))\n            \n            # Sort by cost efficiency (lowest first)\n            cost_efficiency.sort(key=lambda x: x[0])\n            \n            # Add units until capacity meets load\n            for _, i in cost_efficiency:\n                if total_max >= current_load:\n                    break\n                unit = units_info[i]\n                committed.append(i)\n                total_min += unit['min_eff']\n                total_max += unit['max_eff']\n        \n        # Step 5c: Remove non-must units if over-committed\n        if total_min > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            \n            # Calculate avoidable cost per MW (higher is better to remove)\n            avoidable_costs = []\n            for i in non_must:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                \n                if i in free_off:  # Can avoid startup cost\n                    avoidable_cost = unit['s_i'] + cost_at_min\n                else:  # Free-on units avoid only fuel cost\n                    avoidable_cost = cost_at_min\n                \n                avoidable_costs.append((avoidable_cost / min_eff, i))\n            \n            # Sort by avoidable cost per MW (highest first)\n            avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n            \n            # Try removing units starting with highest avoidable cost\n            for cost_per_mw, i in avoidable_costs:\n                unit = units_info[i]\n                new_total_max = total_max - unit['max_eff']\n                # Only remove if capacity remains sufficient\n                if new_total_max >= current_load:\n                    committed.remove(i)\n                    total_min -= unit['min_eff']\n                    total_max = new_total_max\n                if total_min <= current_load:\n                    break\n        \n        # Step 6: Dispatch with lambda iteration\n        dispatch_with_lambda(units_info, committed, current_load)\n        \n        # Set uncommitted units to offline\n        for i in range(num_units):\n            if i not in committed:\n                units_info[i]['u_i'] = 0\n                units_info[i]['p_i'] = 0\n        \n        return prepare_output(units_info)\n\ndef dispatch_with_lambda(units, committed, load):\n    if not committed:\n        return\n    \n    # Get effective min/max sum\n    total_min = sum(units[i]['min_eff'] for i in committed)\n    total_max = sum(units[i]['max_eff'] for i in committed)\n    \n    # Case 1: Over-generation (output at min_eff)\n    if total_min >= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['min_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 2: Under-generation (output at max_eff)\n    if total_max <= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['max_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 3: Lambda iteration for exact dispatch\n    # Initialize lambda bounds\n    low = min(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['min_eff'] for i in committed)\n    high = max(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['max_eff'] for i in committed)\n    tol = 0.1  # Tolerance for convergence (MW)\n    \n    # Binary search for optimal lambda\n    while high - low > 1e-6:\n        mid = (low + high) / 2\n        total_output = 0\n        \n        # Calculate outputs at current lambda\n        for i in committed:\n            unit = units[i]\n            # Unconstrained output\n            p = (mid - unit['b_i']) / (2 * unit['c_i'])\n            # Apply constraints\n            p = max(unit['min_eff'], min(p, unit['max_eff']))\n            total_output += p\n        \n        # Adjust lambda based on total output\n        if total_output < load:\n            low = mid\n        else:\n            high = mid\n    \n    # Set final outputs\n    total_output = 0\n    for i in committed:\n        unit = units[i]\n        p = (low - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['min_eff'], min(p, unit['max_eff']))\n        unit['p_i'] = p\n        unit['u_i'] = 1\n        total_output += p\n\ndef prepare_output(units_info):\n    u_i = [unit['u_i'] for unit in units_info]\n    p_i = [unit['p_i'] for unit in units_info]\n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.0054285791,
          "gap_price_rate": 0.0089176009,
          "fitness": 0.00717309
     },
     {
          "name": "enhanced_lambda_commitment",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on) with specific feasibility checks.\n2. Compute effective min/max outputs using ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, p_start)\n3. If must-on min output \u2265 load: commit must-on at min_eff\n4. Else if must-on max output \u2265 load: commit must-on and dispatch via lambda iteration\n5. Else:\n   a. Commit must-on + free-on units\n   b. If total max < load: add free-off units sorted by startup cost efficiency\n   c. If total min > load: remove non-must units by highest avoidable cost per MW\n6. Dispatch load using lambda iteration on committed units\n7. Set non-committed units to offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_lambda_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedule_u = np.zeros(num_units)\n    schedule_p = np.zeros(num_units)\n    committed_indices = []\n    min_eff = []\n    max_eff = []\n    unit_categories = {\n        'must_on': [], \n        'must_off': [],\n        'free_on': [],\n        'free_off': []\n    }\n\n    # Classify units and compute effective limits\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        # Must-on condition\n        must_on_cond = (u_i_0 == 1) and (\n            t_i_0 < unit['t_on_min_i'] or \n            p_i_0 > unit['p_shut_i']\n        )\n        \n        # Must-off condition\n        must_off_cond = (u_i_0 == 0) and (abs(t_i_0) < unit['t_off_min_i'])\n        \n        # Free-on condition\n        free_on_cond = (u_i_0 == 1) and not must_on_cond and (p_i_0 <= unit['p_shut_i'])\n        \n        # Free-off condition\n        free_off_cond = (u_i_0 == 0) and not must_off_cond and (unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']))\n        \n        if must_on_cond:\n            unit_categories['must_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif must_off_cond:\n            unit_categories['must_off'].append(idx)\n            min_eff.append(0)\n            max_eff.append(0)\n        elif free_on_cond:\n            unit_categories['free_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif free_off_cond:\n            unit_categories['free_off'].append(idx)\n            min_eff_val = unit['p_min_i']\n            max_eff_val = min(unit['p_max_i'], unit['p_start_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        else:\n            min_eff.append(0)\n            max_eff.append(0)\n\n    # Initialize committed set\n    committed_set = unit_categories['must_on'][:]\n    committed_set.sort()\n\n    # Case 1: Must-on min output covers load\n    min_total = sum(min_eff[i] for i in unit_categories['must_on'])\n    if min_total >= current_load:\n        for idx in unit_categories['must_on']:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n        return np.vstack((schedule_u, schedule_p))\n\n    # Case 2: Must-on max output covers load\n    max_total = sum(max_eff[i] for i in unit_categories['must_on'])\n    if max_total >= current_load:\n        committed_set = unit_categories['must_on']\n    else:\n        # Step 5a: Commit must-on + free-on\n        committed_set = list(set(unit_categories['must_on'] + unit_categories['free_on']))\n        committed_set.sort()\n        \n        # Calculate current capacity\n        max_total = sum(max_eff[i] for i in committed_set)\n        \n        # Step 5b: Add free-off units by cost efficiency\n        if max_total < current_load:\n            free_off_costs = []\n            for idx in unit_categories['free_off']:\n                unit = units_info[idx]\n                startup_cost = unit['s_i']\n                min_cost = (unit['a_i'] + unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                cost_per_mw = (startup_cost + min_cost) / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                free_off_costs.append((cost_per_mw, idx))\n            \n            free_off_costs.sort(key=lambda x: x[0])\n            \n            for cost_per_mw, idx in free_off_costs:\n                if max_total >= current_load:\n                    break\n                committed_set.append(idx)\n                committed_set.sort()\n                max_total += max_eff[idx]\n        \n        # Step 5c: Remove non-must units if min output exceeds load\n        min_total = sum(min_eff[i] for i in committed_set)\n        if min_total > current_load:\n            non_must_units = [i for i in committed_set if i not in unit_categories['must_on']]\n            avoidable_costs = []\n            for idx in non_must_units:\n                unit = units_info[idx]\n                min_cost = (unit['a_i'] + \n                           unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                if units_info[idx]['u_i_0'] == 0:\n                    min_cost += unit['s_i']\n                cost_per_mw = min_cost / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                avoidable_costs.append((cost_per_mw, idx))\n            \n            avoidable_costs.sort(key=lambda x: -x[0])\n            \n            for cost_per_mw, idx in avoidable_costs:\n                if min_total - min_eff[idx] <= current_load:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n                else:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n\n    # Dispatch using lambda iteration\n    min_total = sum(min_eff[i] for i in committed_set)\n    max_total = sum(max_eff[i] for i in committed_set)\n    \n    if min_total >= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n    elif max_total <= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = max_eff[idx]\n    else:\n        # Lambda iteration setup\n        low, high = float('inf'), -float('inf')\n        b = [units_info[i]['b_i'] for i in committed_set]\n        c = [units_info[i]['c_i'] for i in committed_set]\n        mc_min = [2 * c[i] * min_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        mc_max = [2 * c[i] * max_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        \n        low = min(mc_min)\n        high = max(mc_max)\n        \n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_set):\n                p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                p_val = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                for i, idx in enumerate(committed_set):\n                    p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                    schedule_p[idx] = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                    schedule_u[idx] = 1\n                break\n            elif total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        else:  # Fallback to min_eff if lambda iteration fails\n            for idx in committed_set:\n                schedule_p[idx] = min_eff[idx]\n                schedule_u[idx] = 1\n\n    return np.vstack((schedule_u, schedule_p))",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091096178,
          "fitness": 0.0072690778
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints: for online units, effective min is max(p_min, p_prev - ramp_down) and max is min(p_max, p_prev + ramp_up); for free-off units, min is p_min and max is min(p_max, startup_ramp).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units' max output covers load, perform economic dispatch (lambda iteration) on must-on units to meet load.\n5. Else:\n   a. Commit must-on and free-on units initially.\n   b. If total max < load, add free-off units sorted by efficiency: (startup_cost + no_load_cost + cost_at_min_output) / min_output.\n   c. If total min > load, remove non-must units (free-on and free-off) sorted by avoidable cost per MW: (no_load_cost + variable_cost_at_min + (startup_cost if free-off)) / min_output.\n6. Perform economic dispatch via lambda iteration on committed units to minimize production cost while meeting load.\n7. Set non-committed units to offline state (u=0, p=0).\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    categories = []\n    min_eff = []\n    max_eff = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < min_up or p_i0 > p_shut:\n                category = 'must-on'\n            else:\n                category = 'free-on'\n            min_eff_i = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_eff_i = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if t_i0 > -min_down:\n                category = 'must-off'\n                min_eff_i = 0\n                max_eff_i = 0\n            else:\n                category = 'free-off'\n                min_eff_i = unit['p_min_i']\n                max_eff_i = min(unit['p_max_i'], unit['p_start_i'])\n        categories.append(category)\n        min_eff.append(min_eff_i)\n        max_eff.append(max_eff_i)\n    \n    must_on_indices = [i for i, cat in enumerate(categories) if cat == 'must-on']\n    free_on_indices = [i for i, cat in enumerate(categories) if cat == 'free-on']\n    free_off_indices = [i for i, cat in enumerate(categories) if cat == 'free-off']\n    \n    total_must_on_min = sum(min_eff[i] for i in must_on_indices)\n    if total_must_on_min >= current_load:\n        for i in must_on_indices:\n            u[i] = 1\n            p[i] = min_eff[i]\n        return np.array([u, p])\n    \n    total_must_on_max = sum(max_eff[i] for i in must_on_indices)\n    if total_must_on_max >= current_load:\n        min_eff_committed = [min_eff[i] for i in must_on_indices]\n        max_eff_committed = [max_eff[i] for i in must_on_indices]\n        b_list = [units_info[i]['b_i'] for i in must_on_indices]\n        c_list = [units_info[i]['c_i'] for i in must_on_indices]\n        p_committed = economic_dispatch(min_eff_committed, max_eff_committed, current_load, b_list, c_list)\n        for idx, unit_idx in enumerate(must_on_indices):\n            u[unit_idx] = 1\n            p[unit_idx] = p_committed[idx]\n        return np.array([u, p])\n    \n    committed_set = must_on_indices + free_on_indices\n    total_min_committed = sum(min_eff[i] for i in committed_set)\n    total_max_committed = sum(max_eff[i] for i in committed_set)\n    \n    if total_max_committed < current_load:\n        eff_vals = []\n        for i in free_off_indices:\n            unit = units_info[i]\n            cost_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            if categories[i] == 'free-off':\n                cost_min += unit['s_i']\n            eff_val = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            eff_vals.append((eff_val, i))\n        eff_vals.sort(key=lambda x: x[0])\n        \n        for eff_val, i in eff_vals:\n            committed_set.append(i)\n            total_max_committed += max_eff[i]\n            total_min_committed += min_eff[i]\n            if total_max_committed >= current_load:\n                break\n    \n    if total_min_committed > current_load:\n        non_must_units = [i for i in committed_set if categories[i] in ['free-on', 'free-off']]\n        avoidable_vals = []\n        for i in non_must_units:\n            unit = units_info[i]\n            cost_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            if categories[i] == 'free-off':\n                cost_min += unit['s_i']\n            avoidable_per_mw = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            avoidable_vals.append((avoidable_per_mw, i))\n        avoidable_vals.sort(key=lambda x: x[0], reverse=True)\n        \n        for avoidable_per_mw, i in avoidable_vals:\n            new_min = total_min_committed - min_eff[i]\n            new_max = total_max_committed - max_eff[i]\n            if new_max >= current_load:\n                committed_set.remove(i)\n                total_min_committed = new_min\n                total_max_committed = new_max\n                if total_min_committed <= current_load:\n                    break\n    \n    min_eff_committed = [min_eff[i] for i in committed_set]\n    max_eff_committed = [max_eff[i] for i in committed_set]\n    b_list = [units_info[i]['b_i'] for i in committed_set]\n    c_list = [units_info[i]['c_i'] for i in committed_set]\n    p_committed = economic_dispatch(min_eff_committed, max_eff_committed, current_load, b_list, c_list)\n    \n    for idx, unit_idx in enumerate(committed_set):\n        u[unit_idx] = 1\n        p[unit_idx] = p_committed[idx]\n    \n    return np.array([u, p])\n\ndef economic_dispatch(min_eff_list, max_eff_list, load, b_list, c_list):\n    n = len(min_eff_list)\n    if n == 0:\n        return []\n    total_min = sum(min_eff_list)\n    total_max = sum(max_eff_list)\n    if load <= total_min:\n        return min_eff_list\n    if load >= total_max:\n        return max_eff_list\n        \n    min_mc = [b_list[i] + 2 * c_list[i] * min_eff_list[i] for i in range(n)]\n    max_mc = [b_list[i] + 2 * c_list[i] * max_eff_list[i] for i in range(n)]\n    low = min(min_mc)\n    high = max(max_mc)\n    tol = 0.001\n    max_iter = 1000\n    p_vals = min_eff_list[:]\n    \n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        total_p = 0.0\n        for i in range(n):\n            if c_list[i] == 0:\n                p_ideal = max_eff_list[i] if mid > b_list[i] else min_eff_list[i]\n            else:\n                p_ideal = (mid - b_list[i]) / (2 * c_list[i])\n            p_i = max(min_eff_list[i], min(max_eff_list[i], p_ideal))\n            p_vals[i] = p_i\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        if total_p < load:\n            low = mid\n        else:\n            high = mid\n    \n    return p_vals",
          "from": "crossover",
          "gap_power_rate": 0.0054286422,
          "gap_price_rate": 0.0091096435,
          "fitness": 0.0072691429
     },
     {
          "name": "rolling_commitment",
          "algorithm": "1. Classify units into must-on (if online and violating min-up/shutdown constraints), must-off (if offline and violating min-down time), free-on (online without constraints), and free-off (offline without constraints).\n2. Compute effective min/max outputs with ramp constraints: online units consider ramp limits, free-off units use startup ramp limits.\n3. If must-on min output exceeds current load:\n   - Commit only must-on units at their min effective outputs\n4. Else if must-on max output covers load:\n   - Commit only must-on units\n   - Dispatch load among them via lambda iteration\n5. Else:\n   a. Initially commit must-on and free-on units\n   b. Compute efficiency metric for free-off units as (amortized startup cost + no-load cost) / min output and add most efficient units until generation capacity meets load\n   c. If total min output exceeds load, remove non-must units with highest avoidable cost per MW while maintaining generation feasibility\n6. Perform economic dispatch via lambda iteration on final committed units\n7. Set non-committed units to offline (0 output)\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    schedule_u = np.zeros(n_units)\n    schedule_p = np.zeros(n_units)\n    \n    if n_units == 0:\n        return np.array([schedule_u, schedule_p])\n    \n    current_load = load[0]\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units and compute effective limits\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:  # Online\n            min_eff[i] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            \n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if abs(t_i_0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Reset must_off limits\n    for i in must_off:\n        min_eff[i] = 0\n        max_eff[i] = 0\n    \n    # Step 3: Must-on min exceeds load\n    must_on_min_sum = np.sum(min_eff[must_on])\n    must_on_max_sum = np.sum(max_eff[must_on])\n    \n    if must_on_min_sum >= current_load:\n        committed = set(must_on)\n        for i in committed:\n            schedule_u[i] = 1\n            schedule_p[i] = min_eff[i]\n        return np.array([schedule_u, schedule_p])\n    \n    # Step 4: Must-on covers load\n    elif must_on_max_sum >= current_load:\n        committed = set(must_on)\n        dispatch_units = []\n        for i in committed:\n            dispatch_units.append({\n                'b': units_info[i]['b_i'],\n                'c': units_info[i]['c_i'],\n                'min_eff': min_eff[i],\n                'max_eff': max_eff[i]\n            })\n        dispatches = dispatch_ed(dispatch_units, current_load)\n        for idx, i in enumerate(committed):\n            schedule_u[i] = 1\n            schedule_p[i] = dispatches[idx]\n        return np.array([schedule_u, schedule_p])\n    \n    # Step 5: General case\n    committed = set(must_on + free_on)\n    total_min = must_on_min_sum + np.sum(min_eff[free_on])\n    total_max = must_on_max_sum + np.sum(max_eff[free_on])\n    \n    # Add free-off units until capacity meets demand\n    efficiencies = []\n    for i in free_off:\n        a = units_info[i]['a_i']\n        s = units_info[i]['s_i']\n        min_up = units_info[i]['t_on_min_i']\n        amortized_startup = s / min_up\n        cost_at_min = a + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2\n        efficiencies.append((amortized_startup + cost_at_min) / min_eff[i])\n    sorted_free_off = [i for _, i in sorted(zip(efficiencies, free_off), key=lambda x: x[0])]\n    \n    for i in sorted_free_off:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    # Remove non-must units if min output exceeds load\n    if total_min > current_load:\n        avoidable_costs = []\n        non_must = list(committed - set(must_on))\n        for i in non_must:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            min_cost = a + b * min_eff[i] + c * min_eff[i] ** 2\n            if i in free_off:\n                min_cost += unit['s_i']\n            avoidable_costs.append(min_cost / min_eff[i])\n        \n        sorted_remove = [i for _, i in sorted(zip(avoidable_costs, non_must), reverse=True)]\n        for i in sorted_remove:\n            if i not in committed:\n                continue\n            new_min = total_min - min_eff[i]\n            new_max = total_max - max_eff[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed.remove(i)\n                total_min = new_min\n                total_max = new_max\n            if total_min <= current_load:\n                break\n    \n    # Dispatch using lambda iteration\n    dispatch_units = []\n    comm_list = list(committed)\n    for i in comm_list:\n        dispatch_units.append({\n            'b': units_info[i]['b_i'],\n            'c': units_info[i]['c_i'],\n            'min_eff': min_eff[i],\n            'max_eff': max_eff[i]\n        })\n    dispatches = dispatch_ed(dispatch_units, current_load)\n    \n    for idx, i in enumerate(comm_list):\n        schedule_u[i] = 1\n        schedule_p[i] = dispatches[idx]\n    \n    return np.array([schedule_u, schedule_p])\n\ndef dispatch_ed(units, load):\n    tol = 0.01\n    min_sum = sum(unit['min_eff'] for unit in units)\n    max_sum = sum(unit['max_eff'] for unit in units)\n    \n    if load <= min_sum:\n        return [unit['min_eff'] for unit in units]\n    if load >= max_sum:\n        return [unit['max_eff'] for unit in units]\n    \n    low = min(unit['b'] + 2 * unit['c'] * unit['min_eff'] for unit in units) - 1\n    high = max(unit['b'] + 2 * unit['c'] * unit['max_eff'] for unit in units) + 1\n    \n    iter_count = 0\n    while high - low > tol and iter_count < 100:\n        lam = (low + high) / 2\n        p_sum = 0\n        for unit in units:\n            if unit['c'] == 0:\n                p = unit['max_eff'] if lam >= unit['b'] else unit['min_eff']\n            else:\n                p_val = (lam - unit['b']) / (2 * unit['c'])\n                p = max(unit['min_eff'], min(p_val, unit['max_eff']))\n            p_sum += p\n        \n        if p_sum < load:\n            low = lam\n        else:\n            high = lam\n        iter_count += 1\n    \n    # Final assignment with adjustment\n    lam = (low + high) / 2\n    outputs = []\n    for unit in units:\n        if unit['c'] == 0:\n            p = unit['max_eff'] if lam >= unit['b'] else unit['min_eff']\n        else:\n            p_val = (lam - unit['b']) / (2 * unit['c'])\n            p = max(unit['min_eff'], min(p_val, unit['max_eff']))\n        outputs.append(p)\n    \n    # Residual adjustment\n    residual = load - sum(outputs)\n    if residual > 0:\n        mcs = []\n        for i, unit in enumerate(units):\n            mc = unit['b'] + 2 * unit['c'] * outputs[i]\n            room = unit['max_eff'] - outputs[i]\n            if room > 1e-6:\n                mcs.append((mc, i, room))\n        mcs.sort(key=lambda x: x[0])\n        for mc, idx, room in mcs:\n            if residual < 1e-6:\n                break\n            alloc = min(room, residual)\n            outputs[idx] += alloc\n            residual -= alloc\n    elif residual < 0:\n        residual = abs(residual)\n        mcs = []\n        for i, unit in enumerate(units):\n            mc = unit['b'] + 2 * unit['c'] * outputs[i]\n            room = outputs[i] - unit['min_eff']\n            if room > 1e-6:\n                mcs.append((mc, i, room))\n        mcs.sort(key=lambda x: x[0], reverse=True)\n        for mc, idx, room in mcs:\n            if residual < 1e-6:\n                break\n            alloc = min(room, residual)\n            outputs[idx] -= alloc\n            residual -= alloc\n    \n    return outputs",
          "from": "mutation",
          "gap_power_rate": 0.0055426647,
          "gap_price_rate": 0.0093167212,
          "fitness": 0.007429693
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs for all units considering ramp constraints (current units use ramp limits, new starts use startup ramp limits).\n3. If must-on units' min output exceeds current load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, dispatch only among must-on units.\n5. Else:\n   a. Activate free-off units by cost-efficiency (startup cost + cost at min output)/min output until capacity meets load\n   b. If total min output of committed set exceeds load:\n      - Remove free units (free-on/new starts) with highest saving per MW while maintaining capacity and shutdown feasibility\n6. Perform greedy dispatch:\n   a. Initialize outputs at effective min\n   b. Increase outputs of units with lowest marginal cost first using min-heap\n   c. Respect ramp and output constraints during allocation\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize commitment states and power outputs\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n            eff_min[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            eff_max[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n                eff_min[idx] = 0.0\n                eff_max[idx] = 0.0\n            else:\n                free_off.append(idx)\n                eff_min[idx] = unit['p_min_i']\n                eff_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3-5: Commitment logic\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        committed = set(must_on)\n    elif must_on_max >= current_load:\n        committed = set(must_on)\n    else:\n        committed = set(must_on) | set(free_on)\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Activate free-off units\n        free_off_sorted = sorted(free_off, key=lambda i: \n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * eff_min[i] + \n             units_info[i]['c_i'] * eff_min[i] ** 2) / eff_min[i])\n        \n        for idx in free_off_sorted:\n            if total_max >= current_load:\n                break\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n            committed.add(idx)\n        \n        # Remove over-committed free units\n        if total_min > current_load:\n            removal_candidates = []\n            for idx in committed:\n                if idx in must_on:\n                    continue\n                if units_info[idx]['u_i_0'] == 1:\n                    if units_info[idx]['p_i_0'] > units_info[idx]['p_shut_i']:\n                        continue\n                    saving = (units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                else:\n                    saving = (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                removal_candidates.append((saving, idx))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            for saving, idx in removal_candidates:\n                if total_min <= current_load:\n                    break\n                if (total_max - eff_max[idx]) >= current_load:\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    committed.remove(idx)\n    \n    # Step 6: Dispatch\n    total_output = 0.0\n    for idx in committed:\n        p[idx] = eff_min[idx]\n        total_output += eff_min[idx]\n        u[idx] = 1\n    \n    deficit = current_load - total_output\n    if deficit > 0:\n        heap = []\n        for idx in committed:\n            if p[idx] < eff_max[idx]:\n                room = eff_max[idx] - p[idx]\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (mc, idx, room))\n        \n        while deficit > 0 and heap:\n            mc, idx, room = heapq.heappop(heap)\n            inc = min(room, deficit)\n            p[idx] += inc\n            deficit -= inc\n            total_output += inc\n            \n            # Update remaining room and marginal cost\n            new_room = eff_max[idx] - p[idx]\n            if new_room > 0:\n                new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (new_mc, idx, new_room))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0101961532,
          "fitness": 0.007526636
     },
     {
          "name": "refined_enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online and can be turned off), free-off (offline and can be turned on).\n2. Compute effective min/max outputs using ramp constraints: online units consider ramp limits, free-off units use startup ramp limits.\n3. If must-on min output covers load: commit only must-on at min output.\n4. Else if must-on max output covers load: commit only must-on units.\n5. Else:\n   a. Commit must-on and free-on units initially.\n   b. If total max < load: add free-off units sorted by two-period startup cost efficiency metric (accounts for min-up time constraints).\n   c. If total min > load: remove non-must units by highest avoidable cost per MW while maintaining feasibility.\n6. Dispatch via greedy allocation: \n   a. Initialize outputs at effective min.\n   b. Allocate residual load using min-heap priority by marginal cost.\n7. Set non-committed units to offline state (u=0, p=0).\n",
          "code": "import numpy as np\nimport heapq\n\ndef refined_enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    must_on, must_off, free_on, free_off = [], [], [], []\n    \n    for unit in units:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    for unit in must_on + free_on:\n        p_i_0 = unit['p_i_0']\n        min_eff = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n        max_eff = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        unit['min_eff'] = min_eff\n        unit['max_eff'] = max_eff\n    \n    for unit in free_off:\n        min_eff = unit['p_min_i']\n        max_eff = min(unit['p_max_i'], unit['p_start_i'])\n        unit['min_eff'] = min_eff\n        unit['max_eff'] = max_eff\n    \n    committed_units = []\n    must_on_total_min = sum(unit['min_eff'] for unit in must_on)\n    must_on_total_max = sum(unit['max_eff'] for unit in must_on)\n    \n    if must_on_total_min >= current_load:\n        committed_units = must_on\n        for unit in committed_units:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['min_eff']\n    elif must_on_total_max >= current_load:\n        committed_units = must_on\n    else:\n        committed_units = must_on + free_on\n        total_min = sum(unit['min_eff'] for unit in committed_units)\n        total_max = sum(unit['max_eff'] for unit in committed_units)\n        \n        if total_max < current_load:\n            eff_list = []\n            for unit in free_off:\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                t_on_min_i = unit['t_on_min_i']\n                \n                cost_current = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n                total_cost = s_i + cost_current\n                total_power = p_min_i\n                \n                if t_on_min_i > 1:\n                    total_cost += cost_current\n                    total_power += p_min_i\n                \n                efficiency = total_cost / total_power\n                eff_list.append((efficiency, unit))\n            \n            eff_list.sort(key=lambda x: x[0])\n            for _, unit in eff_list:\n                if total_max >= current_load:\n                    break\n                committed_units.append(unit)\n                total_max += unit['max_eff']\n        \n        total_min_after = sum(unit['min_eff'] for unit in committed_units)\n        if total_min_after > current_load:\n            non_must = [u for u in committed_units if u not in must_on]\n            avoid_list = []\n            for unit in non_must:\n                p_min_i = unit['min_eff']\n                if unit in free_off:\n                    avoid_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min_i + unit['c_i'] * (p_min_i ** 2)\n                else:\n                    avoid_cost = unit['a_i'] + unit['b_i'] * p_min_i + unit['c_i'] * (p_min_i ** 2)\n                avoid_per_MW = avoid_cost / p_min_i\n                avoid_list.append((avoid_per_MW, unit))\n            \n            avoid_list.sort(key=lambda x: x[0], reverse=True)\n            for _, unit in avoid_list:\n                new_min = total_min_after - unit['min_eff']\n                new_max = total_max - unit['max_eff']\n                if new_min <= current_load and new_max >= current_load:\n                    committed_units.remove(unit)\n                    total_min_after = new_min\n                    total_max = new_max\n                if total_min_after <= current_load:\n                    break\n    \n    total_p = 0.0\n    for unit in committed_units:\n        unit['p_i'] = unit['min_eff']\n        total_p += unit['p_i']\n    \n    residual = current_load - total_p\n    if residual > 0:\n        heap = []\n        for idx, unit in enumerate(committed_units):\n            if unit['p_i'] < unit['max_eff']:\n                mc = 2 * unit['c_i'] * unit['p_i'] + unit['b_i']\n                heapq.heappush(heap, (mc, idx, unit))\n        \n        while residual > 0 and heap:\n            mc, _, unit = heapq.heappop(heap)\n            if unit['p_i'] < unit['max_eff']:\n                delta = min(residual, unit['max_eff'] - unit['p_i'])\n                unit['p_i'] += delta\n                residual -= delta\n                if unit['p_i'] < unit['max_eff']:\n                    new_mc = 2 * unit['c_i'] * unit['p_i'] + unit['b_i']\n                    heapq.heappush(heap, (new_mc, id(unit), unit))\n    \n    for unit in committed_units:\n        unit['u_i'] = 1\n    \n    non_committed = [unit for unit in units if unit not in committed_units]\n    for unit in non_committed:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n    \n    schedules = np.zeros((2, len(units_info)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.004889945,
          "gap_price_rate": 0.0102720894,
          "fitness": 0.0075810172
     },
     {
          "name": "enhanced_lambda_hybrid",
          "algorithm": "**\n1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints:\n   - Online units: effective_min = max(p_min_i, p_i_0 - p_down_i), effective_max = min(p_max_i, p_i_0 + p_up_i)\n   - Free-off units: effective_min = p_min_i, effective_max = min(p_max_i, p_start_i)\n3. If must-on units' minimum output exceeds current load:\n   - Commit only must-on units at effective minimum outputs (over-generation)\n   - Set all other units to offline (u_i=0, p_i=0)\n4. Else if must-on units can cover load (must-on maximum output >= load):\n   - Commit only must-on units\n   - Perform economic dispatch using lambda iteration\n5. Else:\n   a. Initially commit must-on and free-on units\n   b. If total maximum output < load:\n      - Add free-off units sorted by cost efficiency: (startup_cost + no_load_cost + cost_at_min_output) / min_output\n   c. If total minimum output > load:\n      - Remove non-must units (free-on and added free-off) by highest avoidable cost per MW: avoidable_cost / min_output (for free-on: no_load_cost + cost_at_min_output; for free-off: startup_cost + no_load_cost + cost_at_min_output)\n   d. Dispatch load using lambda iteration on committed units\n6. Return commitment states (u_i) and power outputs (p_i)\n\n**",
          "code": "import numpy as np\n\ndef enhanced_lambda_hybrid(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = [0] * num_units\n    p = [0] * num_units\n    \n    # Classify units and compute effective limits\n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_eff, max_eff = [0] * num_units, [0] * num_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Online previously\n            min_eff_i = max(p_min, p_i0 - ramp_down)\n            max_eff_i = min(p_max, p_i0 + ramp_up)\n            min_eff[i] = min_eff_i\n            max_eff[i] = max_eff_i\n            # Check must-on constraints\n            if t_i0 < t_up_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline previously\n            min_eff[i] = p_min\n            max_eff[i] = min(p_max, p_start)\n            if -t_i0 < t_down_min:  # Not satisfied min down-time\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Calculate total min and max for must-on units\n    total_min_must_on = sum(min_eff[i] for i in must_on)\n    total_max_must_on = sum(max_eff[i] for i in must_on)\n    \n    # Case 1: Must-on units can supply load minimum (over-generation)\n    if total_min_must_on >= current_load:\n        committed = must_on[:]\n        for i in committed:\n            u[i] = 1\n            p[i] = min_eff[i]\n        return np.array([u, p])\n    \n    # Case 2: Must-on units can cover load alone\n    if total_max_must_on >= current_load:\n        committed = must_on[:]\n    else:\n        # Case 3: Need additional units\n        committed = must_on + free_on  # Initially commit must-on and free-on\n        # Compute current capacity\n        total_min = sum(min_eff[i] for i in committed)\n        total_max = sum(max_eff[i] for i in committed)\n        \n        # Add free-off units if capacity insufficient\n        if total_max < current_load:\n            cost_efficiency = []\n            for i in free_off:\n                s_i = units_info[i]['s_i']\n                a_i = units_info[i]['a_i']\n                b_i = units_info[i]['b_i']\n                c_i = units_info[i]['c_i']\n                min_eff_i = min_eff[i]\n                cost_at_min = a_i + b_i * min_eff_i + c_i * min_eff_i ** 2\n                eff = (s_i + cost_at_min) / min_eff_i\n                cost_efficiency.append((i, eff))\n            \n            cost_efficiency.sort(key=lambda x: x[1])\n            for i, _ in cost_efficiency:\n                if total_max >= current_load:\n                    break\n                committed.append(i)\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n        \n        # Remove non-must units if minimum output exceeds load\n        non_must = [i for i in committed if i not in must_on]\n        while total_min > current_load and non_must:\n            avoidable_costs = []\n            for i in non_must:\n                unit = units_info[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_eff_i = min_eff[i]\n                cost_at_min = a_i + b_i * min_eff_i + c_i * min_eff_i ** 2\n                if unit['u_i_0'] == 0:  # Free-off unit being removed\n                    cost_at_min += unit['s_i']\n                avoidable_cost = cost_at_min / min_eff_i\n                avoidable_costs.append((i, avoidable_cost))\n            \n            avoidable_costs.sort(key=lambda x: x[1], reverse=True)\n            i_remove, _ = avoidable_costs[0]\n            committed.remove(i_remove)\n            non_must.remove(i_remove)\n            total_min -= min_eff[i_remove]\n            total_max -= max_eff[i_remove]\n    \n    # Perform economic dispatch using lambda iteration\n    dispatch_units = []\n    for i in committed:\n        unit = units_info[i]\n        dispatch_units.append((\n            i, \n            min_eff[i],\n            max_eff[i],\n            unit['b_i'],\n            unit['c_i']\n        ))\n    \n    # Handle edge cases and dispatch\n    total_min_dispatch = sum(min_e for _, min_e, _, _, _ in dispatch_units)\n    total_max_dispatch = sum(max_e for _, _, max_e, _, _ in dispatch_units)\n    \n    if current_load <= total_min_dispatch:\n        for i, min_e, _, _, _ in dispatch_units:\n            u[i] = 1\n            p[i] = min_e\n    elif current_load >= total_max_dispatch:\n        for i, _, max_e, _, _ in dispatch_units:\n            u[i] = 1\n            p[i] = max_e\n    else:\n        # Lambda iteration for quadratic dispatch\n        tol, max_iter = 0.1, 1000\n        lambda_low = min(2 * c * min_e + b for _, min_e, _, b, c in dispatch_units if c > 0)\n        lambda_high = max(2 * c * max_e + b for _, _, max_e, b, c in dispatch_units if c > 0)\n        iter_count = 0\n        \n        while iter_count < max_iter and abs(lambda_high - lambda_low) > tol:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            p_temp = {}\n            \n            # Calculate outputs for given lambda\n            for i, min_e, max_e, b, c in dispatch_units:\n                if c == 0:  # Linear cost function\n                    if lambda_mid < b:\n                        p_i = min_e\n                    else:\n                        p_i = max_e\n                else:  # Quadratic cost function\n                    p_i = (lambda_mid - b) / (2 * c)\n                    p_i = max(min_e, min(max_e, p_i))\n                p_temp[i] = p_i\n                total_power += p_i\n            \n            # Adjust lambda bounds\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            iter_count += 1\n        \n        # Final assignment for committed units\n        for i in committed:\n            u[i] = 1\n            p[i] = p_temp.get(i, 0)\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0081069834,
          "gap_price_rate": 0.0083296369,
          "fitness": 0.0082183101
     }
]