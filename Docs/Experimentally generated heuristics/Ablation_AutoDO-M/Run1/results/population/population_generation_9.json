[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "optimized_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on with feasible startup constraints).\n2. Compute effective min/max outputs for online units considering ramp constraints and startup limits for free-off units.\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, commit only must-on units and use lambda iteration for dispatch.\n5. Else:\n   a. Commit must-on and free-on units initially\n   b. Add free-off units by cost-efficiency if capacity is insufficient\n   c. Remove non-must units by avoidable cost per MW if min output exceeds load while maintaining feasibility\n6. Dispatch load using lambda iteration on committed units to minimize cost under constraints\n7. Set non-committed units to offline state (u=0, p=0)\n",
          "code": "import numpy as np\nimport heapq\n\ndef optimized_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u0 == 1 and ((t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif u0 == 0 and t0 > -unit['t_off_min_i']:  # t0 is negative for offline\n            must_off.append(i)\n        # Free-on\n        elif u0 == 1:\n            free_on.append(i)\n        # Free-off (with startup feasibility)\n        elif u0 == 0 and unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n            free_off.append(i)\n    \n    # Prepare unit dictionaries for processing\n    for i, unit in enumerate(units_info):\n        # Compute effective min/max for all relevant units\n        if i in must_on or i in free_on:\n            unit['min_eff'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            unit['min_eff'] = unit['p_min_i']\n            unit['max_eff'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['min_eff'] = 0\n            unit['max_eff'] = 0\n    \n    # Step 3: Check if must-on can cover alone (over-generation)\n    must_on_min_sum = sum(units_info[i]['min_eff'] for i in must_on)\n    must_on_max_sum = sum(units_info[i]['max_eff'] for i in must_on)\n    \n    if must_on_min_sum >= current_load:\n        committed = must_on\n        for i in committed:\n            units_info[i]['p_i'] = units_info[i]['min_eff']\n            units_info[i]['u_i'] = 1\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 4: Must-on coverage\n    elif must_on_max_sum >= current_load:\n        committed = must_on\n        dispatch_with_lambda(units_info, committed, current_load)\n        for i in free_on + free_off:\n            units_info[i]['u_i'] = 0\n            units_info[i]['p_i'] = 0\n        return prepare_output(units_info)\n    \n    # Step 5: General case\n    else:\n        committed = must_on + free_on\n        total_min = sum(units_info[i]['min_eff'] for i in committed)\n        total_max = sum(units_info[i]['max_eff'] for i in committed)\n        \n        # Step 5b: Add free-off units if needed\n        if total_max < current_load and free_off:\n            # Calculate cost efficiency: (startup + fixed + variable) / min_output\n            cost_efficiency = []\n            for i in free_off:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                total_cost = unit['s_i'] + cost_at_min\n                cost_efficiency.append((total_cost / min_eff, i))\n            \n            # Sort by cost efficiency (lowest first)\n            cost_efficiency.sort(key=lambda x: x[0])\n            \n            # Add units until capacity meets load\n            for _, i in cost_efficiency:\n                if total_max >= current_load:\n                    break\n                unit = units_info[i]\n                committed.append(i)\n                total_min += unit['min_eff']\n                total_max += unit['max_eff']\n        \n        # Step 5c: Remove non-must units if over-committed\n        if total_min > current_load:\n            non_must = [i for i in committed if i not in must_on]\n            \n            # Calculate avoidable cost per MW (higher is better to remove)\n            avoidable_costs = []\n            for i in non_must:\n                unit = units_info[i]\n                min_eff = unit['min_eff']\n                cost_at_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * min_eff**2\n                \n                if i in free_off:  # Can avoid startup cost\n                    avoidable_cost = unit['s_i'] + cost_at_min\n                else:  # Free-on units avoid only fuel cost\n                    avoidable_cost = cost_at_min\n                \n                avoidable_costs.append((avoidable_cost / min_eff, i))\n            \n            # Sort by avoidable cost per MW (highest first)\n            avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n            \n            # Try removing units starting with highest avoidable cost\n            for cost_per_mw, i in avoidable_costs:\n                unit = units_info[i]\n                new_total_max = total_max - unit['max_eff']\n                # Only remove if capacity remains sufficient\n                if new_total_max >= current_load:\n                    committed.remove(i)\n                    total_min -= unit['min_eff']\n                    total_max = new_total_max\n                if total_min <= current_load:\n                    break\n        \n        # Step 6: Dispatch with lambda iteration\n        dispatch_with_lambda(units_info, committed, current_load)\n        \n        # Set uncommitted units to offline\n        for i in range(num_units):\n            if i not in committed:\n                units_info[i]['u_i'] = 0\n                units_info[i]['p_i'] = 0\n        \n        return prepare_output(units_info)\n\ndef dispatch_with_lambda(units, committed, load):\n    if not committed:\n        return\n    \n    # Get effective min/max sum\n    total_min = sum(units[i]['min_eff'] for i in committed)\n    total_max = sum(units[i]['max_eff'] for i in committed)\n    \n    # Case 1: Over-generation (output at min_eff)\n    if total_min >= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['min_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 2: Under-generation (output at max_eff)\n    if total_max <= load:\n        for i in committed:\n            units[i]['p_i'] = units[i]['max_eff']\n            units[i]['u_i'] = 1\n        return\n    \n    # Case 3: Lambda iteration for exact dispatch\n    # Initialize lambda bounds\n    low = min(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['min_eff'] for i in committed)\n    high = max(units[i]['b_i'] + 2*units[i]['c_i']*units[i]['max_eff'] for i in committed)\n    tol = 0.1  # Tolerance for convergence (MW)\n    \n    # Binary search for optimal lambda\n    while high - low > 1e-6:\n        mid = (low + high) / 2\n        total_output = 0\n        \n        # Calculate outputs at current lambda\n        for i in committed:\n            unit = units[i]\n            # Unconstrained output\n            p = (mid - unit['b_i']) / (2 * unit['c_i'])\n            # Apply constraints\n            p = max(unit['min_eff'], min(p, unit['max_eff']))\n            total_output += p\n        \n        # Adjust lambda based on total output\n        if total_output < load:\n            low = mid\n        else:\n            high = mid\n    \n    # Set final outputs\n    total_output = 0\n    for i in committed:\n        unit = units[i]\n        p = (low - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['min_eff'], min(p, unit['max_eff']))\n        unit['p_i'] = p\n        unit['u_i'] = 1\n        total_output += p\n\ndef prepare_output(units_info):\n    u_i = [unit['u_i'] for unit in units_info]\n    p_i = [unit['p_i'] for unit in units_info]\n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.0054285791,
          "gap_price_rate": 0.0089176009,
          "fitness": 0.00717309
     },
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                u[i] = 1\n                \n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in must_run_indices:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    total_min_must = np.sum(eff_min[must_run_indices])\n    total_max_must = np.sum(eff_max[must_run_indices])\n    \n    if total_min_must > current_load:\n        for i in must_run_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    if total_max_must >= current_load:\n        committed_indices = must_run_indices\n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    candidate_indices.append(i)\n                    \n        candidate_info = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                emin = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                emax = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['b_i'] + unit['c_i'] * emin) / emin\n            else:\n                emin = unit['p_min_i']\n                emax = min(unit['p_max_i'], unit['p_start_i'])\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                cost_per_mw = (startup_cost + unit['a_i'] + unit['b_i'] * emin + unit['c_i'] * emin**2) / emin\n            candidate_info.append((i, emin, emax, cost_per_mw))\n        \n        candidate_info.sort(key=lambda x: x[3])\n        committed_indices = must_run_indices.copy()\n        total_min_curr = total_min_must\n        total_max_curr = total_max_must\n        for i, emin, emax, _ in candidate_info:\n            if total_max_curr >= current_load:\n                break\n            committed_indices.append(i)\n            total_min_curr += emin\n            total_max_curr += emax\n        \n        for i in committed_indices:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                eff_min[i] = units_info[i]['p_min_i']\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min_committed = sum(eff_min[i] for i in committed_indices)\n    if total_min_committed > current_load:\n        for i in committed_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    b = []\n    c = []\n    lows = []\n    highs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n        lows.append(eff_min[i])\n        highs.append(eff_max[i])\n    \n    n_committed = len(committed_indices)\n    p_alloc = np.array(lows)\n    if abs(total_min_committed - current_load) < 1e-5:\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_alloc[idx]\n        return np.array([u, p])\n    \n    if n_committed == 0:\n        return np.array([u, p])\n    \n    low_lambda = min(b_i + 2 * c_i * low for b_i, c_i, low in zip(b, c, lows))\n    high_lambda = max(b_i + 2 * c_i * high for b_i, c_i, high in zip(b, c, highs))\n    tolerance = 1e-5\n    \n    for _ in range(1000):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for k in range(n_committed):\n            if c[k] == 0:\n                p_alloc[k] = highs[k] if mid_lambda >= b[k] else lows[k]\n            else:\n                p_val = (mid_lambda - b[k]) / (2 * c[k])\n                p_alloc[k] = np.clip(p_val, lows[k], highs[k])\n            total_p += p_alloc[k]\n        \n        if total_p < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tolerance:\n            diff = current_load - total_p\n            if diff > 0:\n                idx_min = np.argmin(np.array([b_i + 2*c_i*p_i for b_i, c_i, p_i in zip(b, c, p_alloc)]))\n                p_alloc[idx_min] = min(highs[idx_min], p_alloc[idx_min] + diff)\n            break\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_alloc[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054289451,
          "gap_price_rate": 0.0090732546,
          "fitness": 0.0072510999
     },
     {
          "name": "enhanced_lambda_commitment",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on) with specific feasibility checks.\n2. Compute effective min/max outputs using ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, p_start)\n3. If must-on min output \u2265 load: commit must-on at min_eff\n4. Else if must-on max output \u2265 load: commit must-on and dispatch via lambda iteration\n5. Else:\n   a. Commit must-on + free-on units\n   b. If total max < load: add free-off units sorted by startup cost efficiency\n   c. If total min > load: remove non-must units by highest avoidable cost per MW\n6. Dispatch load using lambda iteration on committed units\n7. Set non-committed units to offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_lambda_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedule_u = np.zeros(num_units)\n    schedule_p = np.zeros(num_units)\n    committed_indices = []\n    min_eff = []\n    max_eff = []\n    unit_categories = {\n        'must_on': [], \n        'must_off': [],\n        'free_on': [],\n        'free_off': []\n    }\n\n    # Classify units and compute effective limits\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        # Must-on condition\n        must_on_cond = (u_i_0 == 1) and (\n            t_i_0 < unit['t_on_min_i'] or \n            p_i_0 > unit['p_shut_i']\n        )\n        \n        # Must-off condition\n        must_off_cond = (u_i_0 == 0) and (abs(t_i_0) < unit['t_off_min_i'])\n        \n        # Free-on condition\n        free_on_cond = (u_i_0 == 1) and not must_on_cond and (p_i_0 <= unit['p_shut_i'])\n        \n        # Free-off condition\n        free_off_cond = (u_i_0 == 0) and not must_off_cond and (unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']))\n        \n        if must_on_cond:\n            unit_categories['must_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif must_off_cond:\n            unit_categories['must_off'].append(idx)\n            min_eff.append(0)\n            max_eff.append(0)\n        elif free_on_cond:\n            unit_categories['free_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif free_off_cond:\n            unit_categories['free_off'].append(idx)\n            min_eff_val = unit['p_min_i']\n            max_eff_val = min(unit['p_max_i'], unit['p_start_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        else:\n            min_eff.append(0)\n            max_eff.append(0)\n\n    # Initialize committed set\n    committed_set = unit_categories['must_on'][:]\n    committed_set.sort()\n\n    # Case 1: Must-on min output covers load\n    min_total = sum(min_eff[i] for i in unit_categories['must_on'])\n    if min_total >= current_load:\n        for idx in unit_categories['must_on']:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n        return np.vstack((schedule_u, schedule_p))\n\n    # Case 2: Must-on max output covers load\n    max_total = sum(max_eff[i] for i in unit_categories['must_on'])\n    if max_total >= current_load:\n        committed_set = unit_categories['must_on']\n    else:\n        # Step 5a: Commit must-on + free-on\n        committed_set = list(set(unit_categories['must_on'] + unit_categories['free_on']))\n        committed_set.sort()\n        \n        # Calculate current capacity\n        max_total = sum(max_eff[i] for i in committed_set)\n        \n        # Step 5b: Add free-off units by cost efficiency\n        if max_total < current_load:\n            free_off_costs = []\n            for idx in unit_categories['free_off']:\n                unit = units_info[idx]\n                startup_cost = unit['s_i']\n                min_cost = (unit['a_i'] + unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                cost_per_mw = (startup_cost + min_cost) / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                free_off_costs.append((cost_per_mw, idx))\n            \n            free_off_costs.sort(key=lambda x: x[0])\n            \n            for cost_per_mw, idx in free_off_costs:\n                if max_total >= current_load:\n                    break\n                committed_set.append(idx)\n                committed_set.sort()\n                max_total += max_eff[idx]\n        \n        # Step 5c: Remove non-must units if min output exceeds load\n        min_total = sum(min_eff[i] for i in committed_set)\n        if min_total > current_load:\n            non_must_units = [i for i in committed_set if i not in unit_categories['must_on']]\n            avoidable_costs = []\n            for idx in non_must_units:\n                unit = units_info[idx]\n                min_cost = (unit['a_i'] + \n                           unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                if units_info[idx]['u_i_0'] == 0:\n                    min_cost += unit['s_i']\n                cost_per_mw = min_cost / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                avoidable_costs.append((cost_per_mw, idx))\n            \n            avoidable_costs.sort(key=lambda x: -x[0])\n            \n            for cost_per_mw, idx in avoidable_costs:\n                if min_total - min_eff[idx] <= current_load:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n                else:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n\n    # Dispatch using lambda iteration\n    min_total = sum(min_eff[i] for i in committed_set)\n    max_total = sum(max_eff[i] for i in committed_set)\n    \n    if min_total >= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n    elif max_total <= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = max_eff[idx]\n    else:\n        # Lambda iteration setup\n        low, high = float('inf'), -float('inf')\n        b = [units_info[i]['b_i'] for i in committed_set]\n        c = [units_info[i]['c_i'] for i in committed_set]\n        mc_min = [2 * c[i] * min_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        mc_max = [2 * c[i] * max_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        \n        low = min(mc_min)\n        high = max(mc_max)\n        \n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_set):\n                p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                p_val = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                for i, idx in enumerate(committed_set):\n                    p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                    schedule_p[idx] = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                    schedule_u[idx] = 1\n                break\n            elif total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        else:  # Fallback to min_eff if lambda iteration fails\n            for idx in committed_set:\n                schedule_p[idx] = min_eff[idx]\n                schedule_u[idx] = 1\n\n    return np.vstack((schedule_u, schedule_p))",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091096178,
          "fitness": 0.0072690778
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs considering ramp constraints: for online units, effective min is max(p_min, p_prev - ramp_down) and max is min(p_max, p_prev + ramp_up); for free-off units, min is p_min and max is min(p_max, startup_ramp).\n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units' max output covers load, perform economic dispatch (lambda iteration) on must-on units to meet load.\n5. Else:\n   a. Commit must-on and free-on units initially.\n   b. If total max < load, add free-off units sorted by efficiency: (startup_cost + no_load_cost + cost_at_min_output) / min_output.\n   c. If total min > load, remove non-must units (free-on and free-off) sorted by avoidable cost per MW: (no_load_cost + variable_cost_at_min + (startup_cost if free-off)) / min_output.\n6. Perform economic dispatch via lambda iteration on committed units to minimize production cost while meeting load.\n7. Set non-committed units to offline state (u=0, p=0).\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    categories = []\n    min_eff = []\n    max_eff = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < min_up or p_i0 > p_shut:\n                category = 'must-on'\n            else:\n                category = 'free-on'\n            min_eff_i = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_eff_i = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if t_i0 > -min_down:\n                category = 'must-off'\n                min_eff_i = 0\n                max_eff_i = 0\n            else:\n                category = 'free-off'\n                min_eff_i = unit['p_min_i']\n                max_eff_i = min(unit['p_max_i'], unit['p_start_i'])\n        categories.append(category)\n        min_eff.append(min_eff_i)\n        max_eff.append(max_eff_i)\n    \n    must_on_indices = [i for i, cat in enumerate(categories) if cat == 'must-on']\n    free_on_indices = [i for i, cat in enumerate(categories) if cat == 'free-on']\n    free_off_indices = [i for i, cat in enumerate(categories) if cat == 'free-off']\n    \n    total_must_on_min = sum(min_eff[i] for i in must_on_indices)\n    if total_must_on_min >= current_load:\n        for i in must_on_indices:\n            u[i] = 1\n            p[i] = min_eff[i]\n        return np.array([u, p])\n    \n    total_must_on_max = sum(max_eff[i] for i in must_on_indices)\n    if total_must_on_max >= current_load:\n        min_eff_committed = [min_eff[i] for i in must_on_indices]\n        max_eff_committed = [max_eff[i] for i in must_on_indices]\n        b_list = [units_info[i]['b_i'] for i in must_on_indices]\n        c_list = [units_info[i]['c_i'] for i in must_on_indices]\n        p_committed = economic_dispatch(min_eff_committed, max_eff_committed, current_load, b_list, c_list)\n        for idx, unit_idx in enumerate(must_on_indices):\n            u[unit_idx] = 1\n            p[unit_idx] = p_committed[idx]\n        return np.array([u, p])\n    \n    committed_set = must_on_indices + free_on_indices\n    total_min_committed = sum(min_eff[i] for i in committed_set)\n    total_max_committed = sum(max_eff[i] for i in committed_set)\n    \n    if total_max_committed < current_load:\n        eff_vals = []\n        for i in free_off_indices:\n            unit = units_info[i]\n            cost_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            if categories[i] == 'free-off':\n                cost_min += unit['s_i']\n            eff_val = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            eff_vals.append((eff_val, i))\n        eff_vals.sort(key=lambda x: x[0])\n        \n        for eff_val, i in eff_vals:\n            committed_set.append(i)\n            total_max_committed += max_eff[i]\n            total_min_committed += min_eff[i]\n            if total_max_committed >= current_load:\n                break\n    \n    if total_min_committed > current_load:\n        non_must_units = [i for i in committed_set if categories[i] in ['free-on', 'free-off']]\n        avoidable_vals = []\n        for i in non_must_units:\n            unit = units_info[i]\n            cost_min = unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            if categories[i] == 'free-off':\n                cost_min += unit['s_i']\n            avoidable_per_mw = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            avoidable_vals.append((avoidable_per_mw, i))\n        avoidable_vals.sort(key=lambda x: x[0], reverse=True)\n        \n        for avoidable_per_mw, i in avoidable_vals:\n            new_min = total_min_committed - min_eff[i]\n            new_max = total_max_committed - max_eff[i]\n            if new_max >= current_load:\n                committed_set.remove(i)\n                total_min_committed = new_min\n                total_max_committed = new_max\n                if total_min_committed <= current_load:\n                    break\n    \n    min_eff_committed = [min_eff[i] for i in committed_set]\n    max_eff_committed = [max_eff[i] for i in committed_set]\n    b_list = [units_info[i]['b_i'] for i in committed_set]\n    c_list = [units_info[i]['c_i'] for i in committed_set]\n    p_committed = economic_dispatch(min_eff_committed, max_eff_committed, current_load, b_list, c_list)\n    \n    for idx, unit_idx in enumerate(committed_set):\n        u[unit_idx] = 1\n        p[unit_idx] = p_committed[idx]\n    \n    return np.array([u, p])\n\ndef economic_dispatch(min_eff_list, max_eff_list, load, b_list, c_list):\n    n = len(min_eff_list)\n    if n == 0:\n        return []\n    total_min = sum(min_eff_list)\n    total_max = sum(max_eff_list)\n    if load <= total_min:\n        return min_eff_list\n    if load >= total_max:\n        return max_eff_list\n        \n    min_mc = [b_list[i] + 2 * c_list[i] * min_eff_list[i] for i in range(n)]\n    max_mc = [b_list[i] + 2 * c_list[i] * max_eff_list[i] for i in range(n)]\n    low = min(min_mc)\n    high = max(max_mc)\n    tol = 0.001\n    max_iter = 1000\n    p_vals = min_eff_list[:]\n    \n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        total_p = 0.0\n        for i in range(n):\n            if c_list[i] == 0:\n                p_ideal = max_eff_list[i] if mid > b_list[i] else min_eff_list[i]\n            else:\n                p_ideal = (mid - b_list[i]) / (2 * c_list[i])\n            p_i = max(min_eff_list[i], min(max_eff_list[i], p_ideal))\n            p_vals[i] = p_i\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        if total_p < load:\n            low = mid\n        else:\n            high = mid\n    \n    return p_vals",
          "from": "crossover",
          "gap_power_rate": 0.0054286422,
          "gap_price_rate": 0.0091096435,
          "fitness": 0.0072691429
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs for all units considering ramp constraints (current units use ramp limits, new starts use startup ramp limits).\n3. If must-on units' min output exceeds current load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, dispatch only among must-on units.\n5. Else:\n   a. Activate free-off units by cost-efficiency (startup cost + cost at min output)/min output until capacity meets load\n   b. If total min output of committed set exceeds load:\n      - Remove free units (free-on/new starts) with highest saving per MW while maintaining capacity and shutdown feasibility\n6. Perform greedy dispatch:\n   a. Initialize outputs at effective min\n   b. Increase outputs of units with lowest marginal cost first using min-heap\n   c. Respect ramp and output constraints during allocation\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize commitment states and power outputs\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n            eff_min[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            eff_max[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n                eff_min[idx] = 0.0\n                eff_max[idx] = 0.0\n            else:\n                free_off.append(idx)\n                eff_min[idx] = unit['p_min_i']\n                eff_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3-5: Commitment logic\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        committed = set(must_on)\n    elif must_on_max >= current_load:\n        committed = set(must_on)\n    else:\n        committed = set(must_on) | set(free_on)\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Activate free-off units\n        free_off_sorted = sorted(free_off, key=lambda i: \n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * eff_min[i] + \n             units_info[i]['c_i'] * eff_min[i] ** 2) / eff_min[i])\n        \n        for idx in free_off_sorted:\n            if total_max >= current_load:\n                break\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n            committed.add(idx)\n        \n        # Remove over-committed free units\n        if total_min > current_load:\n            removal_candidates = []\n            for idx in committed:\n                if idx in must_on:\n                    continue\n                if units_info[idx]['u_i_0'] == 1:\n                    if units_info[idx]['p_i_0'] > units_info[idx]['p_shut_i']:\n                        continue\n                    saving = (units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                else:\n                    saving = (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                removal_candidates.append((saving, idx))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            for saving, idx in removal_candidates:\n                if total_min <= current_load:\n                    break\n                if (total_max - eff_max[idx]) >= current_load:\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    committed.remove(idx)\n    \n    # Step 6: Dispatch\n    total_output = 0.0\n    for idx in committed:\n        p[idx] = eff_min[idx]\n        total_output += eff_min[idx]\n        u[idx] = 1\n    \n    deficit = current_load - total_output\n    if deficit > 0:\n        heap = []\n        for idx in committed:\n            if p[idx] < eff_max[idx]:\n                room = eff_max[idx] - p[idx]\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (mc, idx, room))\n        \n        while deficit > 0 and heap:\n            mc, idx, room = heapq.heappop(heap)\n            inc = min(room, deficit)\n            p[idx] += inc\n            deficit -= inc\n            total_output += inc\n            \n            # Update remaining room and marginal cost\n            new_room = eff_max[idx] - p[idx]\n            if new_room > 0:\n                new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (new_mc, idx, new_room))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0101961532,
          "fitness": 0.007526636
     }
]