[
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time/shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs considering ramp constraints: for online units (max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)); for potential startups (p_min, min(p_max, startup_ramp)).  \n3. If must-on min exceeds load, commit only must-on at min outputs (over-generation).  \n4. Else if must-on max covers load, commit only must-on units.  \n5. Else:  \n   a. Initially commit must-on and free-on.  \n   b. If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   c. If total min > load, remove non-must units by highest cost per MW from committed set while maintaining feasibility.  \n6. Dispatch using priority heap:  \n   a. Initialize outputs at effective min.  \n   b. Distribute deficit to units with lowest marginal cost until load met or capacity exhausted.  \n   c. Handle over-generation by accepting min outputs.  \n7. Assign commitment states and outputs to all units.  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_commitment(units_info, load):\n    load_curr = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # 1. Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # 2. Compute effective min/max\n    for unit in must_on + free_on:\n        unit['eff_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in free_off:\n        unit['eff_min'] = unit['p_min_i']\n        unit['eff_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # 3. Check must-on alone\n    muston_min = sum(unit['eff_min'] for unit in must_on)\n    muston_max = sum(unit['eff_max'] for unit in must_on)\n    \n    if muston_min > load_curr:\n        for unit in must_on:\n            unit['u_i'] = 1\n            unit['p_i'] = unit['eff_min']\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        return build_output(units)\n    \n    elif muston_min <= load_curr <= muston_max:\n        committed = must_on\n        for unit in must_on:\n            unit['u_i'] = 1\n        for unit in free_on + free_off + must_off:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n        dispatch_load(committed, load_curr)\n        return build_output(units)\n    \n    # 5. Expand and reduce committed set\n    current_committed = must_on + free_on\n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    total_max = sum(unit['eff_max'] for unit in current_committed)\n    \n    if total_max < load_curr:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min']\n        )\n        for unit in free_off_sorted:\n            current_committed.append(unit)\n            total_max += unit['eff_max']\n            if total_max >= load_curr:\n                break\n    \n    total_min = sum(unit['eff_min'] for unit in current_committed)\n    non_must_units = [u for u in current_committed if u not in must_on]\n    non_must_units_sorted = sorted(\n        non_must_units,\n        key=lambda u: ((u['s_i'] if u in free_off else 0) + u['a_i'] + u['b_i']*u['eff_min'] + u['c_i']*u['eff_min']**2) / u['eff_min'],\n        reverse=True\n    )\n    \n    for unit in non_must_units_sorted:\n        new_min = total_min - unit['eff_min']\n        new_max = total_max - unit['eff_max']\n        if new_min <= load_curr <= new_max:\n            current_committed.remove(unit)\n            total_min = new_min\n            total_max = new_max\n    \n    # 6. Dispatch and assign final states\n    for unit in units:\n        unit['u_i'] = 1 if unit in current_committed else 0\n        unit['p_i'] = unit['eff_min'] if unit in current_committed else 0.0\n    \n    if total_min <= load_curr:\n        dispatch_load(current_committed, load_curr)\n    \n    for unit in must_off + free_off:\n        if unit not in current_committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    return build_output(units)\n\ndef dispatch_load(committed, load_curr):\n    outputs = [unit['eff_min'] for unit in committed]\n    total_assigned = sum(outputs)\n    deficit = load_curr - total_assigned\n    \n    if deficit <= 1e-5:\n        for i, unit in enumerate(committed):\n            unit['p_i'] = outputs[i]\n        return\n    \n    heap = []\n    for i, unit in enumerate(committed):\n        headroom = unit['eff_max'] - unit['eff_min']\n        if headroom > 1e-5:\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            heapq.heappush(heap, (mc, i, outputs[i], headroom))\n    \n    while deficit > 1e-5 and heap:\n        mc, idx, cur, headroom = heapq.heappop(heap)\n        assign_amount = min(headroom, deficit)\n        new_cur = cur + assign_amount\n        outputs[idx] = new_cur\n        deficit -= assign_amount\n        headroom -= assign_amount\n        \n        if headroom > 1e-5:\n            new_mc = committed[idx]['b_i'] + 2 * committed[idx]['c_i'] * new_cur\n            heapq.heappush(heap, (new_mc, idx, new_cur, headroom))\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = outputs[i]\n\ndef build_output(units):\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                u[i] = 1\n                \n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in must_run_indices:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    total_min_must = np.sum(eff_min[must_run_indices])\n    total_max_must = np.sum(eff_max[must_run_indices])\n    \n    if total_min_must > current_load:\n        for i in must_run_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    if total_max_must >= current_load:\n        committed_indices = must_run_indices\n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    candidate_indices.append(i)\n                    \n        candidate_info = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                emin = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                emax = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['b_i'] + unit['c_i'] * emin) / emin\n            else:\n                emin = unit['p_min_i']\n                emax = min(unit['p_max_i'], unit['p_start_i'])\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                cost_per_mw = (startup_cost + unit['a_i'] + unit['b_i'] * emin + unit['c_i'] * emin**2) / emin\n            candidate_info.append((i, emin, emax, cost_per_mw))\n        \n        candidate_info.sort(key=lambda x: x[3])\n        committed_indices = must_run_indices.copy()\n        total_min_curr = total_min_must\n        total_max_curr = total_max_must\n        for i, emin, emax, _ in candidate_info:\n            if total_max_curr >= current_load:\n                break\n            committed_indices.append(i)\n            total_min_curr += emin\n            total_max_curr += emax\n        \n        for i in committed_indices:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                eff_min[i] = units_info[i]['p_min_i']\n                eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min_committed = sum(eff_min[i] for i in committed_indices)\n    if total_min_committed > current_load:\n        for i in committed_indices:\n            p[i] = eff_min[i]\n        return np.array([u, p])\n    \n    b = []\n    c = []\n    lows = []\n    highs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n        lows.append(eff_min[i])\n        highs.append(eff_max[i])\n    \n    n_committed = len(committed_indices)\n    p_alloc = np.array(lows)\n    if abs(total_min_committed - current_load) < 1e-5:\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_alloc[idx]\n        return np.array([u, p])\n    \n    if n_committed == 0:\n        return np.array([u, p])\n    \n    low_lambda = min(b_i + 2 * c_i * low for b_i, c_i, low in zip(b, c, lows))\n    high_lambda = max(b_i + 2 * c_i * high for b_i, c_i, high in zip(b, c, highs))\n    tolerance = 1e-5\n    \n    for _ in range(1000):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for k in range(n_committed):\n            if c[k] == 0:\n                p_alloc[k] = highs[k] if mid_lambda >= b[k] else lows[k]\n            else:\n                p_val = (mid_lambda - b[k]) / (2 * c[k])\n                p_alloc[k] = np.clip(p_val, lows[k], highs[k])\n            total_p += p_alloc[k]\n        \n        if total_p < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tolerance:\n            diff = current_load - total_p\n            if diff > 0:\n                idx_min = np.argmin(np.array([b_i + 2*c_i*p_i for b_i, c_i, p_i in zip(b, c, p_alloc)]))\n                p_alloc[idx_min] = min(highs[idx_min], p_alloc[idx_min] + diff)\n            break\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_alloc[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054289451,
          "gap_price_rate": 0.0090732546,
          "fitness": 0.0072510999
     },
     {
          "name": "enhanced_lambda_commitment",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on) with specific feasibility checks.\n2. Compute effective min/max outputs using ramp constraints:\n   - Online units: min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up)\n   - Free-off units: min_eff = p_min, max_eff = min(p_max, p_start)\n3. If must-on min output \u2265 load: commit must-on at min_eff\n4. Else if must-on max output \u2265 load: commit must-on and dispatch via lambda iteration\n5. Else:\n   a. Commit must-on + free-on units\n   b. If total max < load: add free-off units sorted by startup cost efficiency\n   c. If total min > load: remove non-must units by highest avoidable cost per MW\n6. Dispatch load using lambda iteration on committed units\n7. Set non-committed units to offline (u=0, p=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_lambda_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedule_u = np.zeros(num_units)\n    schedule_p = np.zeros(num_units)\n    committed_indices = []\n    min_eff = []\n    max_eff = []\n    unit_categories = {\n        'must_on': [], \n        'must_off': [],\n        'free_on': [],\n        'free_off': []\n    }\n\n    # Classify units and compute effective limits\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        # Must-on condition\n        must_on_cond = (u_i_0 == 1) and (\n            t_i_0 < unit['t_on_min_i'] or \n            p_i_0 > unit['p_shut_i']\n        )\n        \n        # Must-off condition\n        must_off_cond = (u_i_0 == 0) and (abs(t_i_0) < unit['t_off_min_i'])\n        \n        # Free-on condition\n        free_on_cond = (u_i_0 == 1) and not must_on_cond and (p_i_0 <= unit['p_shut_i'])\n        \n        # Free-off condition\n        free_off_cond = (u_i_0 == 0) and not must_off_cond and (unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']))\n        \n        if must_on_cond:\n            unit_categories['must_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif must_off_cond:\n            unit_categories['must_off'].append(idx)\n            min_eff.append(0)\n            max_eff.append(0)\n        elif free_on_cond:\n            unit_categories['free_on'].append(idx)\n            min_eff_val = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_eff_val = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        elif free_off_cond:\n            unit_categories['free_off'].append(idx)\n            min_eff_val = unit['p_min_i']\n            max_eff_val = min(unit['p_max_i'], unit['p_start_i'])\n            min_eff.append(min_eff_val)\n            max_eff.append(max_eff_val)\n        else:\n            min_eff.append(0)\n            max_eff.append(0)\n\n    # Initialize committed set\n    committed_set = unit_categories['must_on'][:]\n    committed_set.sort()\n\n    # Case 1: Must-on min output covers load\n    min_total = sum(min_eff[i] for i in unit_categories['must_on'])\n    if min_total >= current_load:\n        for idx in unit_categories['must_on']:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n        return np.vstack((schedule_u, schedule_p))\n\n    # Case 2: Must-on max output covers load\n    max_total = sum(max_eff[i] for i in unit_categories['must_on'])\n    if max_total >= current_load:\n        committed_set = unit_categories['must_on']\n    else:\n        # Step 5a: Commit must-on + free-on\n        committed_set = list(set(unit_categories['must_on'] + unit_categories['free_on']))\n        committed_set.sort()\n        \n        # Calculate current capacity\n        max_total = sum(max_eff[i] for i in committed_set)\n        \n        # Step 5b: Add free-off units by cost efficiency\n        if max_total < current_load:\n            free_off_costs = []\n            for idx in unit_categories['free_off']:\n                unit = units_info[idx]\n                startup_cost = unit['s_i']\n                min_cost = (unit['a_i'] + unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                cost_per_mw = (startup_cost + min_cost) / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                free_off_costs.append((cost_per_mw, idx))\n            \n            free_off_costs.sort(key=lambda x: x[0])\n            \n            for cost_per_mw, idx in free_off_costs:\n                if max_total >= current_load:\n                    break\n                committed_set.append(idx)\n                committed_set.sort()\n                max_total += max_eff[idx]\n        \n        # Step 5c: Remove non-must units if min output exceeds load\n        min_total = sum(min_eff[i] for i in committed_set)\n        if min_total > current_load:\n            non_must_units = [i for i in committed_set if i not in unit_categories['must_on']]\n            avoidable_costs = []\n            for idx in non_must_units:\n                unit = units_info[idx]\n                min_cost = (unit['a_i'] + \n                           unit['b_i'] * min_eff[idx] + \n                           unit['c_i'] * (min_eff[idx] ** 2))\n                if units_info[idx]['u_i_0'] == 0:\n                    min_cost += unit['s_i']\n                cost_per_mw = min_cost / min_eff[idx] if min_eff[idx] > 0 else float('inf')\n                avoidable_costs.append((cost_per_mw, idx))\n            \n            avoidable_costs.sort(key=lambda x: -x[0])\n            \n            for cost_per_mw, idx in avoidable_costs:\n                if min_total - min_eff[idx] <= current_load:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n                else:\n                    if max_total - max_eff[idx] >= current_load:\n                        committed_set.remove(idx)\n                        min_total -= min_eff[idx]\n                        max_total -= max_eff[idx]\n\n    # Dispatch using lambda iteration\n    min_total = sum(min_eff[i] for i in committed_set)\n    max_total = sum(max_eff[i] for i in committed_set)\n    \n    if min_total >= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = min_eff[idx]\n    elif max_total <= current_load:\n        for idx in committed_set:\n            schedule_u[idx] = 1\n            schedule_p[idx] = max_eff[idx]\n    else:\n        # Lambda iteration setup\n        low, high = float('inf'), -float('inf')\n        b = [units_info[i]['b_i'] for i in committed_set]\n        c = [units_info[i]['c_i'] for i in committed_set]\n        mc_min = [2 * c[i] * min_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        mc_max = [2 * c[i] * max_eff[committed_set[i]] + b[i] for i in range(len(committed_set))]\n        \n        low = min(mc_min)\n        high = max(mc_max)\n        \n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_set):\n                p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                p_val = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                for i, idx in enumerate(committed_set):\n                    p_ideal = (lam - b[i]) / (2 * c[i]) if c[i] != 0 else min_eff[idx]\n                    schedule_p[idx] = max(min_eff[idx], min(max_eff[idx], p_ideal))\n                    schedule_u[idx] = 1\n                break\n            elif total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        else:  # Fallback to min_eff if lambda iteration fails\n            for idx in committed_set:\n                schedule_p[idx] = min_eff[idx]\n                schedule_u[idx] = 1\n\n    return np.vstack((schedule_u, schedule_p))",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091096178,
          "fitness": 0.0072690778
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Compute effective min/max outputs for all units considering ramp constraints (current units use ramp limits, new starts use startup ramp limits).\n3. If must-on units' min output exceeds current load, commit only must-on units at min outputs (over-generation).\n4. Else if must-on units can cover load, dispatch only among must-on units.\n5. Else:\n   a. Activate free-off units by cost-efficiency (startup cost + cost at min output)/min output until capacity meets load\n   b. If total min output of committed set exceeds load:\n      - Remove free units (free-on/new starts) with highest saving per MW while maintaining capacity and shutdown feasibility\n6. Perform greedy dispatch:\n   a. Initialize outputs at effective min\n   b. Increase outputs of units with lowest marginal cost first using min-heap\n   c. Respect ramp and output constraints during allocation\n",
          "code": "import heapq\nimport numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize commitment states and power outputs\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n            eff_min[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            eff_max[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n                eff_min[idx] = 0.0\n                eff_max[idx] = 0.0\n            else:\n                free_off.append(idx)\n                eff_min[idx] = unit['p_min_i']\n                eff_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3-5: Commitment logic\n    must_on_min = sum(eff_min[i] for i in must_on)\n    must_on_max = sum(eff_max[i] for i in must_on)\n    \n    if must_on_min > current_load:\n        committed = set(must_on)\n    elif must_on_max >= current_load:\n        committed = set(must_on)\n    else:\n        committed = set(must_on) | set(free_on)\n        total_min = must_on_min + sum(eff_min[i] for i in free_on)\n        total_max = must_on_max + sum(eff_max[i] for i in free_on)\n        \n        # Activate free-off units\n        free_off_sorted = sorted(free_off, key=lambda i: \n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * eff_min[i] + \n             units_info[i]['c_i'] * eff_min[i] ** 2) / eff_min[i])\n        \n        for idx in free_off_sorted:\n            if total_max >= current_load:\n                break\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n            committed.add(idx)\n        \n        # Remove over-committed free units\n        if total_min > current_load:\n            removal_candidates = []\n            for idx in committed:\n                if idx in must_on:\n                    continue\n                if units_info[idx]['u_i_0'] == 1:\n                    if units_info[idx]['p_i_0'] > units_info[idx]['p_shut_i']:\n                        continue\n                    saving = (units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                else:\n                    saving = (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                             units_info[idx]['b_i'] * eff_min[idx] + \n                             units_info[idx]['c_i'] * eff_min[idx] ** 2) / eff_min[idx]\n                removal_candidates.append((saving, idx))\n            \n            removal_candidates.sort(reverse=True, key=lambda x: x[0])\n            for saving, idx in removal_candidates:\n                if total_min <= current_load:\n                    break\n                if (total_max - eff_max[idx]) >= current_load:\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    committed.remove(idx)\n    \n    # Step 6: Dispatch\n    total_output = 0.0\n    for idx in committed:\n        p[idx] = eff_min[idx]\n        total_output += eff_min[idx]\n        u[idx] = 1\n    \n    deficit = current_load - total_output\n    if deficit > 0:\n        heap = []\n        for idx in committed:\n            if p[idx] < eff_max[idx]:\n                room = eff_max[idx] - p[idx]\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (mc, idx, room))\n        \n        while deficit > 0 and heap:\n            mc, idx, room = heapq.heappop(heap)\n            inc = min(room, deficit)\n            p[idx] += inc\n            deficit -= inc\n            total_output += inc\n            \n            # Update remaining room and marginal cost\n            new_room = eff_max[idx] - p[idx]\n            if new_room > 0:\n                new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                heapq.heappush(heap, (new_mc, idx, new_room))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0101961532,
          "fitness": 0.007526636
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Compute effective min/max outputs for must-on and free-on units considering ramp constraints. For free-off units if activated, use startup ramp limits.  \n3. If must-on units' min output exceeds load, commit only must-on units at min outputs (over-generation).  \n4. Else if must-on units can cover load, optimize dispatch only among must-on units.  \n5. Else, activate free-on and free-off candidates sorted by cost-efficiency (startup + min-output cost)/min-output), selecting until total max capacity meets load.  \n6. If the min output of committed units exceeds load, remove most expensive/least flexible candidates while maintaining capacity.  \n7. Dispatch load among committed units:  \n   - Initialize outputs at effective min  \n   - Increase cheapest units' output when below load  \n   - Decrease most expensive units' output when above load  \n   - Respect ramp and output constraints during dispatch  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    enhanced_units = []\n    \n    # Classify units and compute parameters\n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_up, p_down = unit['p_up_i'], unit['p_down_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        prev_u, prev_p, prev_t = unit['u_i_0'], unit['p_i_0'], unit['t_i_0']\n        \n        # Determine category\n        if prev_u == 1:\n            if prev_t < t_on_min or prev_p > p_shut:\n                category = 'must_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n            else:\n                category = 'free_on'\n                eff_min = max(p_min, prev_p - p_down)\n                eff_max = min(p_max, prev_p + p_up)\n        else:\n            if -prev_t < t_off_min:\n                category = 'must_off'\n                eff_min = eff_max = 0\n            else:\n                category = 'free_off'\n                eff_min = p_min\n                eff_max = min(p_max, p_start)\n        enhanced_units.append({\n            'index': i,\n            'category': category,\n            'eff_min': eff_min,\n            'eff_max': eff_max,\n            's_i': s_i,\n            'p_min': p_min,\n            'a_i': a_i, 'b_i': b_i, 'c_i': c_i\n        })\n    \n    # Separate units into categories\n    must_on = [u for u in enhanced_units if u['category'] == 'must_on']\n    must_off = [u for u in enhanced_units if u['category'] == 'must_off']\n    free_on = [u for u in enhanced_units if u['category'] == 'free_on']\n    free_off = [u for u in enhanced_units if u['category'] == 'free_off']\n    \n    # Initialize with must-on units\n    total_min = sum(u['eff_min'] for u in must_on)\n    total_max = sum(u['eff_max'] for u in must_on)\n    committed = must_on.copy()\n    \n    if total_min > current_load:\n        # Case 1: Must-on over-generation\n        for u in must_on:\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = u['eff_min']\n    elif total_max >= current_load:\n        # Case 2: Dispatch among must-on\n        if must_on:\n            p_values = [u['eff_min'] for u in must_on]\n            remaining = current_load - total_min\n            while abs(remaining) > 1e-5:\n                # Increase phase\n                while remaining > 1e-5:\n                    best_idx, best_mc = -1, float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] < u['eff_max']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc < best_mc:\n                                best_mc, best_idx = mc, j\n                    if best_idx == -1: break\n                    inc = min(remaining, must_on[best_idx]['eff_max'] - p_values[best_idx])\n                    p_values[best_idx] += inc\n                    remaining -= inc\n                # Decrease phase\n                while remaining < -1e-5:\n                    worst_idx, worst_mc = -1, -float('inf')\n                    for j, u in enumerate(must_on):\n                        if p_values[j] > u['eff_min']:\n                            mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                            if mc > worst_mc:\n                                worst_mc, worst_idx = mc, j\n                    if worst_idx == -1: break\n                    dec = min(-remaining, p_values[worst_idx] - must_on[worst_idx]['eff_min'])\n                    p_values[worst_idx] -= dec\n                    remaining += dec\n            for u, p_val in zip(must_on, p_values):\n                i = u['index']\n                schedules[0, i] = 1\n                schedules[1, i] = p_val\n    else:\n        # Case 3: Need more capacity\n        candidates = []\n        # Free-on candidates\n        for u in free_on:\n            min_out = u['eff_min']\n            cost_per_mw = (u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Free-off candidates\n        for u in free_off:\n            min_out = u['eff_min']\n            cost_per_mw = (u['s_i'] + u['a_i'] + u['b_i']*min_out + u['c_i']*min_out**2) / min_out\n            candidates.append((u, cost_per_mw, min_out, u['eff_max']))\n        # Sort by cost efficiency then min output\n        candidates.sort(key=lambda x: (x[1], x[2]))\n        \n        # Add candidates until capacity meets demand\n        added_candidates = []\n        for candidate in candidates:\n            if total_max < current_load:\n                u, _, min_out, max_out = candidate\n                added_candidates.append(candidate)\n                committed.append(u)\n                total_min += min_out\n                total_max += max_out\n        \n        # Remove over-committed candidates\n        added_candidates.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n        i = 0\n        while i < len(added_candidates) and total_min > current_load:\n            u, _, min_out, max_out = added_candidates[i]\n            if total_max - max_out >= current_load:\n                committed.remove(u)\n                added_candidates.pop(i)\n                total_min -= min_out\n                total_max -= max_out\n            else:\n                i += 1\n        \n        # Dispatch among committed units\n        p_values = []\n        bounds = []\n        for u in committed:\n            if u['category'] in ['must_on', 'free_on']:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            else:\n                eff_min, eff_max = u['eff_min'], u['eff_max']\n            p_values.append(eff_min)\n            bounds.append((eff_min, eff_max))\n        remaining = current_load - sum(p_values)\n        \n        # Increase outputs for under-generation\n        while remaining > 1e-5:\n            best_idx, best_mc = -1, float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] < high:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc < best_mc:\n                        best_mc, best_idx = mc, j\n            if best_idx == -1: \n                break\n            inc = min(remaining, bounds[best_idx][1] - p_values[best_idx])\n            p_values[best_idx] += inc\n            remaining -= inc\n        \n        # Decrease outputs for over-generation\n        while remaining < -1e-5:\n            worst_idx, worst_mc = -1, -float('inf')\n            for j, u in enumerate(committed):\n                low, high = bounds[j]\n                if p_values[j] > low:\n                    mc = u['b_i'] + 2 * u['c_i'] * p_values[j]\n                    if mc > worst_mc:\n                        worst_mc, worst_idx = mc, j\n            if worst_idx == -1: \n                break\n            dec = min(-remaining, p_values[worst_idx] - bounds[worst_idx][0])\n            p_values[worst_idx] -= dec\n            remaining += dec\n        \n        # Apply scheduled outputs\n        for u, p_val in zip(committed, p_values):\n            i = u['index']\n            schedules[0, i] = 1\n            schedules[1, i] = p_val\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "refined_hybrid_commitment_v2",
          "algorithm": "**  \n1. **Classify Units:** Categorize units into must-on (cannot turn off due to min up-time or shutdown constraints), must-off (cannot turn on due to min down-time), free-on (online units that can be shut down), and free-off (offline units that can be started).  \n2. **Compute Effective Limits:** For online units, effective min/max consider ramp constraints. For startable free-off units, max is capped by startup ramp.  \n3. **Special Cases:**  \n   - If must-on min sum > load, commit only must-on at min outputs.  \n   - Else if must-on max sum \u2265 load, dispatch only must-on units via economic dispatch.  \n4. **General Case (must-on insufficient):**  \n   - Commit must-on + free-on units initially.  \n   - If total max < load, add free-off units by cost-efficiency (startup + min-output cost)/min-output.  \n   - If total min > load, remove non-must units by highest avoidable cost per MW while maintaining feasibility.  \n5. **Economic Dispatch:** Use lambda iteration (bisection) on committed units to minimize cost while respecting min/max limits.  \n6. **Finalization:** Non-committed units set to off state and output 0.  \n\n**",
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        t_i_0, t_on_min_i = unit['t_i_0'], unit['t_on_min_i']\n        p_shut_i, t_off_min_i = unit['p_shut_i'], unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Unit was online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Unit was offline\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    # Step 2: Compute effective min/max\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if i in must_off:\n            min_eff[i], max_eff[i] = 0, 0\n        elif unit['u_i_0'] == 1:  # Online units\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Startable free-off\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    def dispatch(committed):\n        total_min = sum(min_eff[i] for i in committed)\n        total_max = sum(max_eff[i] for i in committed)\n        p = np.zeros(n_units)\n        \n        if abs(current_load - total_min) < 1e-3:\n            for i in committed:\n                p[i] = min_eff[i]\n            return p\n        if current_load <= total_min:  # Over-gen\n            for i in committed:\n                p[i] = min_eff[i]\n            return p\n        if current_load >= total_max:  # Under-gen\n            for i in committed:\n                p[i] = max_eff[i]\n            return p\n        \n        # Lambda iteration for dispatch\n        lambda_low = 0\n        lambda_high = 1e6\n        p_vals = np.zeros(n_units)\n        \n        for _ in range(100):  # Bisection iterations\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                b_i, c_i = unit['b_i'], unit['c_i']\n                if c_i > 0:\n                    p_i = max(min_eff[i], min((lambda_mid - b_i) / (2 * c_i), max_eff[i]))\n                else:  # Linear cost\n                    p_i = max_eff[i] if lambda_mid > b_i else min_eff[i]\n                p_vals[i] = p_i\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        return p_vals\n    \n    # Step 3: Special cases\n    total_must_on_min = sum(min_eff[i] for i in must_on)\n    total_must_on_max = sum(max_eff[i] for i in must_on)\n    \n    if total_must_on_min > current_load:  # Over-gen\n        p_out = dispatch(must_on)\n        u_out = [1 if i in must_on else 0 for i in range(n_units)]\n        return np.array([u_out, p_out])\n    \n    if total_must_on_max >= current_load:  # Dispatch must-on only\n        p_out = dispatch(must_on)\n        u_out = [1 if i in must_on else 0 for i in range(n_units)]\n        return np.array([u_out, p_out])\n    \n    # Step 4: General case\n    committed = must_on + free_on\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Add free-off if needed\n    if total_max < current_load:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            cost_min = unit['s_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            ce = cost_min / min_eff[i] if min_eff[i] > 0 else float('inf')\n            candidates.append((ce, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, i in candidates:\n            committed.append(i)\n            total_max += max_eff[i]\n            if total_max >= current_load:\n                break\n                \n    # Remove units if min_eff sum > load\n    total_min_committed = sum(min_eff[i] for i in committed)\n    if total_min_committed > current_load:\n        non_must = [i for i in committed if i not in must_on]\n        avoidable_costs = []\n        \n        for i in non_must:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:  # Free-off (avoid startup + min cost)\n                cost = unit['s_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            else:  # Free-on (avoid min cost)\n                cost = unit['b_i'] * min_eff[i] + unit['c_i'] * min_eff[i]**2\n            ac_mw = cost / min_eff[i] if min_eff[i] > 0 else float('inf')\n            avoidable_costs.append((ac_mw, i))\n            \n        avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n        remove_candidates = [idx for _, idx in avoidable_costs]\n        \n        new_min = total_min_committed\n        for i in remove_candidates:\n            if new_min - min_eff[i] <= current_load:\n                break\n            if total_max - max_eff[i] < current_load:\n                continue\n            if i in committed:\n                committed.remove(i)\n                new_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Step 5 & 6: Dispatch and finalize\n    p_out = dispatch(committed)\n    u_out = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0045823358,
          "gap_price_rate": 0.0150066113,
          "fitness": 0.0097944735
     },
     {
          "name": "hybrid_enhanced_refined_heuristic",
          "algorithm": "1. Classify units into must-on (violated min-up/shutdown constraints), must-off (violated min-down time), free-on (can turn off), and free-off (can turn on).  \n2. Compute effective min/max outputs: online units respect ramps, potential startups limited by startup ramp.  \n3. If must-on units force over-generation (sum(min) > load), commit only must-on at minimum outputs.  \n4. Else if must-on units can cover load alone (sum(max) >= load), dispatch only among must-on units using lambda iteration.  \n5. Else:  \n   a. Initially commit must-on and free-on units.  \n   b. If total capacity < load:  \n      i. Add free-off units by ascending average cost = (startup + min-output cost) / min-output  \n      ii. Stop when total max >= load  \n   c. If total min > load:  \n      i. Remove non-must units by descending avoidable cost = (startup if not online + min cost) / min-output  \n      ii. Maintain total max >= load during removal  \n6. Dispatch load among final committed set:  \n   a. Set outputs to min values  \n   b. Distribute deficit via lambda iteration respecting effective min/max limits  \n7. Set non-committed units to off state (output 0).  \n\n",
          "code": "import numpy as np\nimport heapq\n\ndef hybrid_enhanced_refined_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]  # current time step load\n\n    min_limits = np.zeros(n_units)\n    max_limits = np.zeros(n_units)\n    must_on = set()\n    must_off = set()\n    free_on = set()\n    free_off = set()\n\n    # Step 1: Classify units and compute effective min/max\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        \n        if u_i0:  # was online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.add(i)\n                min_limits[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_limits[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.add(i)\n                min_limits[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_limits[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # was offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.add(i)\n                min_limits[i] = 0\n                max_limits[i] = 0\n            else:\n                free_off.add(i)\n                min_limits[i] = unit['p_min_i']\n                max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Step 3: Handle must-on over-generation\n    total_must_on_min = sum(min_limits[i] for i in must_on)\n    total_must_on_max = sum(max_limits[i] for i in must_on)\n    if total_must_on_min > current_load:\n        u_outputs = [1 if i in must_on else 0 for i in range(n_units)]\n        p_outputs = [min_limits[i] if i in must_on else 0 for i in range(n_units)]\n        return np.array([u_outputs, p_outputs])\n    \n    # Step 4: Must-on can cover load\n    if total_must_on_max >= current_load:\n        committed = must_on\n        u_outputs = [1 if i in committed else 0 for i in range(n_units)]\n        # Lambda iteration for dispatch\n        p_outputs = lambda_iteration_dispatch(\n            units_info, committed, min_limits, max_limits, current_load\n        )\n        return np.array([u_outputs, p_outputs])\n    \n    # Step 5: Require additional units\n    committed = must_on | free_on  # must-on and free-on initially committed\n    total_min = sum(min_limits[i] for i in committed)\n    total_max = sum(max_limits[i] for i in committed)\n    \n    # Step 5b: Add free-off if needed\n    if total_max < current_load:\n        cost_efficiency = []\n        for i in free_off:\n            s_i = units_info[i]['s_i']\n            min_cost = units_info[i]['b_i'] * min_limits[i] + units_info[i]['c_i'] * min_limits[i] ** 2\n            cost_efficiency.append(( (s_i + min_cost) / min_limits[i], i))\n        cost_efficiency.sort(key=lambda x: x[0])\n        \n        for _, i in cost_efficiency:\n            if total_max < current_load:\n                committed.add(i)\n                total_min += min_limits[i]\n                total_max += max_limits[i]\n            else:\n                break\n    \n    # Step 5c: Remove non-must if min > load\n    non_must = [i for i in committed if i not in must_on]  # removable units\n    if total_min > current_load:\n        removal_efficiency = []\n        for i in non_must:\n            min_cost = units_info[i]['b_i'] * min_limits[i] + units_info[i]['c_i'] * min_limits[i] ** 2\n            # Avoidable cost includes startup if unit was off originally\n            avoidable_cost = min_cost + (units_info[i]['s_i'] if i in free_off else 0)\n            removal_efficiency.append((avoidable_cost / min_limits[i], i))\n        removal_efficiency.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in removal_efficiency:\n            if total_min > current_load and (total_max - max_limits[i]) >= current_load:\n                committed.remove(i)\n                total_min -= min_limits[i]\n                total_max -= max_limits[i]\n    \n    # Step 6: Dispatch final committed set\n    u_outputs = [1 if i in committed else 0 for i in range(n_units)]\n    p_outputs = lambda_iteration_dispatch(\n        units_info, committed, min_limits, max_limits, current_load\n    )\n    return np.array([u_outputs, p_outputs])\n\ndef lambda_iteration_dispatch(units_info, committed, min_limits, max_limits, load_current):\n    n_units = len(units_info)\n    p_outputs = np.zeros(n_units)\n    \n    # Initialize to min outputs\n    for i in committed:\n        p_outputs[i] = min_limits[i]\n    total_p = sum(p_outputs)\n    \n    # Only dispatch if load > total min output\n    if abs(total_p - load_current) < 1e-6:\n        return p_outputs.tolist()\n    \n    # Get initial lambda bounds\n    lb = float('inf')\n    ub = 0\n    for i in committed:\n        mc_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_limits[i]\n        mc_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_limits[i]\n        lb = min(lb, mc_min)\n        ub = max(ub, mc_max)\n    \n    # Binary search for lambda\n    tol = 0.01  # tolerance in MW\n    max_iter = 100\n    iter_count = 0\n    while ub - lb > tol and iter_count < max_iter:\n        lam = (lb + ub) / 2\n        total_p_temp = 0\n        for i in committed:\n            if units_info[i]['c_i'] == 0:  # linear unit\n                if lam >= units_info[i]['b_i']:\n                    p_i = max_limits[i]\n                else:\n                    p_i = min_limits[i]\n            else:  # quadratic unit\n                p_i = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_i = max(min_limits[i], min(max_limits[i], p_i))\n            total_p_temp += p_i\n        \n        if total_p_temp < load_current:\n            lb = lam\n        else:\n            ub = lam\n        iter_count += 1\n    \n    # Assign final outputs\n    lam = (lb + ub) / 2\n    for i in committed:\n        if units_info[i]['c_i'] == 0:\n            p_outputs[i] = max_limits[i] if lam >= units_info[i]['b_i'] else min_limits[i]\n        else:\n            p_unclamped = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            p_outputs[i] = max(min_limits[i], min(max_limits[i], p_unclamped))\n    \n    return p_outputs.tolist()",
          "from": "crossover",
          "gap_power_rate": 0.0048053347,
          "gap_price_rate": 0.0150684056,
          "fitness": 0.0099368701
     },
     {
          "name": "hybrid_rolling_commitment_optimized",
          "algorithm": "1. Classify units into must-on (units that must remain online due to min up-time or shutdown ramp constraints), must-off (units that must remain offline due to min down-time), free-on (online units that can be shut down), and free-off (offline units that can be started).\n2. Compute effective min/max outputs:\n   - For online units (must-on/free-on): min_eff = max(p_min_i, p_prev - ramp_down_i), max_eff = min(p_max_i, p_prev + ramp_up_i)\n   - For startable units (free-off): min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n3. If must-on min output > load: commit only must-on at min_eff (over-generation).\n4. Else if must-on can cover load: commit only must-on and proceed to dispatch.\n5. Else:\n   a. Initially commit must-on + free-on units\n   b. If total max_eff < load: add free-off units by cost-efficiency (startup + min-output cost)/min_output until load covered\n   c. If total min_eff > load: remove non-must units with highest cost/MW at min_eff first while maintaining feasibility\n6. Dispatch committed units:\n   a. Initialize all outputs to min_eff\n   b. Use min-heap to distribute deficit (load - sum(min_eff)) to units with lowest marginal cost\n   c. Handle over-generation by leaving outputs at min_eff\n7. Return commitment states and power outputs.\n\n",
          "code": "import heapq\nimport numpy as np\n\ndef hybrid_rolling_commitment_optimized(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    for i, unit in enumerate(units_info):\n        if i in must_on + free_on:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff[i] = 0\n            max_eff[i] = 0\n    \n    total_min_must = sum(min_eff[i] for i in must_on)\n    total_max_must = sum(max_eff[i] for i in must_on)\n    \n    if total_min_must >= current_load:\n        u = [1 if i in must_on else 0 for i in range(n_units)]\n        p = [min_eff[i] if i in must_on else 0 for i in range(n_units)]\n        return np.array([u, p])\n    \n    if total_min_must <= current_load <= total_max_must:\n        committed = must_on\n    else:\n        committed = must_on + free_on\n        total_max = sum(max_eff[i] for i in committed)\n        total_min = sum(min_eff[i] for i in committed)\n        \n        if total_max < current_load:\n            candidates = []\n            for i in free_off:\n                min_cost = units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i]**2\n                total_cost = min_cost + units_info[i]['s_i']\n                if min_eff[i] > 1e-6:\n                    cost_per_mw = total_cost / min_eff[i]\n                    candidates.append((cost_per_mw, i))\n            \n            candidates.sort(key=lambda x: x[0])\n            for _, idx in candidates:\n                if total_max < current_load:\n                    committed.append(idx)\n                    total_min += min_eff[idx]\n                    total_max += max_eff[idx]\n                else:\n                    break\n        \n        total_min = sum(min_eff[i] for i in committed)\n        if total_min > current_load:\n            free_in_commit = [i for i in committed if i in free_on or (i in free_off and i not in must_on)]\n            candidates = []\n            for i in free_in_commit:\n                op_cost = units_info[i]['a_i'] + units_info[i]['b_i']*min_eff[i] + units_info[i]['c_i']*min_eff[i]**2\n                saving = op_cost\n                if i in free_off:\n                    saving += units_info[i]['s_i']\n                if min_eff[i] > 1e-6:\n                    saving_per_mw = saving / min_eff[i]\n                    candidates.append((saving_per_mw, saving, min_eff[i], max_eff[i], i))\n            \n            candidates.sort(key=lambda x: x[0], reverse=True)\n            removed = []\n            current_total_min = total_min\n            current_total_max = total_max\n            \n            for saving_per_mw, saving, m_eff, mx_eff, i in candidates:\n                if current_total_min - m_eff <= current_load and current_total_max - mx_eff >= current_load:\n                    removed.append(i)\n                    current_total_min -= m_eff\n                    current_total_max -= mx_eff\n                    if current_total_min <= current_load:\n                        break\n            \n            committed = [i for i in committed if i not in removed]\n    \n    u = [1 if i in committed else 0 for i in range(n_units)]\n    p = np.zeros(n_units)\n    for i in committed:\n        p[i] = min_eff[i]\n    \n    deficit = current_load - sum(p)\n    if deficit > 1e-6:\n        heap = []\n        for i in committed:\n            if p[i] < max_eff[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                room = max_eff[i] - p[i]\n                heapq.heappush(heap, (marginal_cost, i, room))\n        \n        while deficit > 1e-6 and heap:\n            mc, i, room = heapq.heappop(heap)\n            add = min(deficit, room)\n            p[i] += add\n            deficit -= add\n            new_room = room - add\n            if new_room > 1e-6:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                heapq.heappush(heap, (new_mc, i, new_room))\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.005211854,
          "gap_price_rate": 0.0150284964,
          "fitness": 0.0101201752
     },
     {
          "name": "enhanced_hybrid_commitment",
          "algorithm": "1. Classify units:\n   - must_on: u_i_0=1 and (t_i_0 < t_on_min_i or p_i_0 > p_shut_i or p_i_0 > p_down_i)\n   - must_off: u_i_0=0 and |t_i_0| < t_off_min_i\n   - free_on: u_i_0=1 not must_on\n   - free_off: u_i_0=0 not must_off with available capacity (p_min_i <= min(p_max_i, p_start_i))\n\n2. Compute effective limits:\n   - must_on/free_on: min_eff = max(p_min_i, p_i_0 - p_down_i), max_eff = min(p_max_i, p_i_0 + p_up_i)\n   - free_off: min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n\n3. Handle special cases:\n   a. must_on min_eff sum \u2265 load: commit only must_on at min_eff\n   b. must_on max_eff sum \u2265 load: commit must_on, dispatch via min-heap (lowest marginal cost first)\n   c. Else:\n      - Initialize committed_set = must_on + free_on\n      - Add free_off sorted by cost-efficiency until max_eff sum \u2265 load\n      - If min_eff sum > load, remove non-must units sorted by avoidable cost/MW while maintaining max_eff \u2265 load\n      - Dispatch via min-heap (lowest marginal cost first) respecting min_eff/max_eff\n\n4. Turn off non-committed units when feasible (u_i_0=1 and p_i_0 \u2264 p_down_i and p_i_0 \u2264 p_shut_i)\n\n5. Return u_i, p_i for all units\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    categories = {'must_on': [], 'must_off': [], 'free_on': [], 'free_off': []}\n    units = []\n    idx_map = {}\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        key = (unit['a_i'], unit['b_i'], unit['c_i'], unit['p_min_i'])\n        \n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i'] or p0 > unit['p_down_i']:\n                category = 'must_on'\n            else:\n                category = 'free_on'\n        else:\n            if abs(t0) < unit['t_off_min_i']:\n                category = 'must_off'\n            else:\n                if unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n                    category = 'free_off'\n                else:\n                    category = 'must_off'\n        \n        categories[category].append(i)\n        idx_map[i] = unit\n        units.append({\n            **unit, \n            'category': category,\n            'idx': i\n        })\n    \n    # Compute effective limits\n    for unit in units:\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        \n        if unit['category'] in ['must_on', 'free_on']:\n            min_eff = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_eff = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        elif unit['category'] == 'free_off':\n            min_eff = unit['p_min_i']\n            max_eff = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff = 0\n            max_eff = 0\n            \n        unit['min_eff'] = min_eff\n        unit['max_eff'] = max_eff\n    \n    # Initialize outputs and states\n    schedules = np.zeros((2, len(units)))\n    committed_set = []\n    \n    def must_on_units():\n        return [u for u in units if u['category'] == 'must_on']\n    \n    must_on_min_sum = sum(u['min_eff'] for u in must_on_units())\n    must_on_max_sum = sum(u['max_eff'] for u in must_on_units())\n    \n    # Case 1: Must-on over-generation\n    if must_on_min_sum >= current_load:\n        for u in must_on_units():\n            idx = u['idx']\n            schedules[0, idx] = 1\n            schedules[1, idx] = u['min_eff']\n        committed_set = must_on_units()\n    # Case 2: Must-on can cover\n    elif must_on_max_sum >= current_load:\n        committed_set = must_on_units()\n        # Initialize at min_eff\n        total_min = 0\n        for u in committed_set:\n            idx = u['idx']\n            schedules[0, idx] = 1\n            schedules[1, idx] = u['min_eff']\n            total_min += u['min_eff']\n        \n        deficit = current_load - total_min\n        heap = []\n        for u in committed_set:\n            if schedules[1, u['idx']] < u['max_eff']:\n                mc = u['b_i'] + 2 * u['c_i'] * schedules[1, u['idx']]\n                heapq.heappush(heap, (mc, u['idx'], u))\n        \n        while deficit > 0 and heap:\n            _, idx, u = heapq.heappop(heap)\n            avail = min(u['max_eff'] - schedules[1, idx], deficit)\n            schedules[1, idx] += avail\n            deficit -= avail\n            if schedules[1, idx] < u['max_eff']:\n                new_mc = u['b_i'] + 2 * u['c_i'] * schedules[1, idx]\n                heapq.heappush(heap, (new_mc, idx, u))\n    # Case 3: Need additional units\n    else:\n        committed_set = [u for u in units if u['category'] in ['must_on', 'free_on']]\n        free_off_avail = [u for u in units if u['category'] == 'free_off' and u['max_eff'] > 0]\n        min_sum = sum(u['min_eff'] for u in committed_set)\n        max_sum = sum(u['max_eff'] for u in committed_set)\n        \n        # Add free_off by cost-efficiency\n        free_off_avail.sort(key=lambda u: \n            (u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff']\n        )\n        \n        for u in free_off_avail:\n            if max_sum >= current_load:\n                break\n            committed_set.append(u)\n            min_sum += u['min_eff']\n            max_sum += u['max_eff']\n        \n        # Remove non-must if over-committed\n        non_must = [u for u in committed_set if u['category'] != 'must_on']\n        if min_sum > current_load and non_must:\n            non_must.sort(\n                key=lambda u: ( (u['s_i'] if u['category']=='free_off' else 0) + \n                               u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2 ) / u['min_eff'],\n                reverse=True\n            )\n            i = 0\n            while i < len(non_must) and min_sum > current_load:\n                u = non_must[i]\n                if max_sum - u['max_eff'] >= current_load:\n                    committed_set.remove(u)\n                    min_sum -= u['min_eff']\n                    max_sum -= u['max_eff']\n                i += 1\n        \n        # Dispatch for final set\n        for u in committed_set:\n            idx = u['idx']\n            schedules[0, idx] = 1\n            schedules[1, idx] = u['min_eff']\n        \n        deficit = current_load - min_sum\n        heap = []\n        for u in committed_set:\n            if schedules[1, u['idx']] < u['max_eff']:\n                mc = u['b_i'] + 2 * u['c_i'] * schedules[1, u['idx']]\n                heapq.heappush(heap, (mc, u['idx'], u))\n        \n        while deficit > 0 and heap:\n            _, idx, u = heapq.heappop(heap)\n            avail = min(u['max_eff'] - schedules[1, idx], deficit)\n            schedules[1, idx] += avail\n            deficit -= avail\n            if schedules[1, idx] < u['max_eff']:\n                new_mc = u['b_i'] + 2 * u['c_i'] * schedules[1, idx]\n                heapq.heappush(heap, (new_mc, idx, u))\n    \n    # Handle non-committed units (turn off if feasible)\n    for u in units:\n        if u not in committed_set and u['u_i_0'] == 1:\n            if u['p_i_0'] <= u['p_down_i'] and u['p_i_0'] <= u['p_shut_i']:\n                schedules[0, u['idx']] = 0\n                schedules[1, u['idx']] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0004980271,
          "gap_price_rate": 0.0220410863,
          "fitness": 0.0112695567
     },
     {
          "name": "combined_enhanced_commitment",
          "algorithm": "1. Classify units into categories: must_on (cannot turn off due to min up-time, shutdown constraints, or ramp-down limitations), must_off (cannot turn on due to min down-time), free_on (online units that can be turned off), and free_off (offline units that can be turned on). \n2. Compute effective output limits: For online units (must_on, free_on), min_eff = max(p_min, p_prev - ramp_down), max_eff = min(p_max, p_prev + ramp_up). For startable units (free_off), min_eff = p_min, max_eff = min(p_max, startup_ramp).\n3. If total min_eff of must_on units exceeds load, commit only must_on units at min_eff (over-generation).\n4. Else if total max_eff of must_on units >= load, commit only must_on units for dispatch.\n5. Else:\n   a. Initially commit must_on + free_on units.\n   b. While total max_eff < load and free_off units available, add the most cost-efficient free_off unit: minimize (startup + cost at min_eff) / min_eff.\n   c. If total min_eff > load, remove non-must units with highest avoidable cost per MW: (startup if not online + cost at min_eff) / min_eff, while maintaining total max_eff >= load.\n6. Dispatch committed units using lambda iteration: \n   a. Initialize outputs to min_eff. \n   b. Balance load within effective limits using marginal costs.\n7. Set non-committed units to off state (u_i=0, p_i=0).\n",
          "code": "import numpy as np\n\ndef combined_enhanced_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i'] or \n                unit['p_i_0'] > unit['p_down_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Compute effective limits\n    for i in range(n_units):\n        unit = units_info[i]\n        if i in must_on or i in free_on:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # must_off\n            min_eff[i] = 0\n            max_eff[i] = 0\n\n    # Special cases\n    must_on_min_sum = sum(min_eff[i] for i in must_on)\n    must_on_max_sum = sum(max_eff[i] for i in must_on)\n    if must_on_min_sum > current_load:\n        committed_set = must_on\n    elif must_on_max_sum >= current_load:\n        committed_set = must_on\n    else:\n        committed_set = must_on + free_on\n        total_min = must_on_min_sum + sum(min_eff[i] for i in free_on)\n        total_max = must_on_max_sum + sum(max_eff[i] for i in free_on)\n        free_off_available = free_off.copy()\n        \n        # Add free_off by cost efficiency\n        while total_max < current_load and free_off_available:\n            costs = []\n            for idx in free_off_available:\n                unit = units_info[idx]\n                min_e = min_eff[idx]\n                cost_min = unit['a_i'] + unit['b_i'] * min_e + unit['c_i'] * min_e**2\n                cost_eff = (unit['s_i'] + cost_min) / min_e\n                costs.append((cost_eff, idx))\n            if not costs:\n                break\n            _, selected = min(costs, key=lambda x: x[0])\n            committed_set.append(selected)\n            free_off_available.remove(selected)\n            total_min += min_eff[selected]\n            total_max += max_eff[selected]\n            if total_max >= current_load:\n                break\n        \n        # Remove non-must units if over-generation\n        non_must = [idx for idx in committed_set if idx not in must_on]\n        if total_min > current_load and non_must:\n            avoidable_costs = []\n            for idx in non_must:\n                unit = units_info[idx]\n                min_e = min_eff[idx]\n                cost_min = unit['a_i'] + unit['b_i'] * min_e + unit['c_i'] * min_e**2\n                cost_avoid = cost_min / min_e\n                if unit['u_i_0'] == 0:\n                    cost_avoid += unit['s_i'] / min_e\n                avoidable_costs.append((cost_avoid, idx))\n            avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n            to_remove = []\n            for ac, idx in avoidable_costs:\n                if total_max - max_eff[idx] >= current_load:\n                    to_remove.append(idx)\n                    total_min -= min_eff[idx]\n                    total_max -= max_eff[idx]\n                    if total_min <= current_load:\n                        break\n            committed_set = [idx for idx in committed_set if idx not in to_remove]\n    \n    # Dispatch using lambda iteration\n    p_output = np.zeros(n_units)\n    u_output = np.zeros(n_units)\n    comm_min = [min_eff[i] for i in committed_set]\n    comm_max = [max_eff[i] for i in committed_set]\n    comm_total_min = sum(comm_min)\n    comm_total_max = sum(comm_max)\n    \n    if committed_set:\n        if current_load <= comm_total_min:\n            for idx in committed_set:\n                p_output[idx] = min_eff[idx]\n                u_output[idx] = 1\n        elif current_load >= comm_total_max:\n            for idx in committed_set:\n                p_output[idx] = max_eff[idx]\n                u_output[idx] = 1\n        else:\n            a_list = [units_info[i]['a_i'] for i in committed_set]\n            b_list = [units_info[i]['b_i'] for i in committed_set]\n            c_list = [units_info[i]['c_i'] for i in committed_set]\n            \n            # Binary search for lambda\n            low = min(b_i + 2*c_i*min_eff_i for (min_eff_i, b_i, c_i) in zip(comm_min, b_list, c_list) if c_i != 0 or b_i)\n            high = max(b_i + 2*c_i*max_eff_i for (max_eff_i, b_i, c_i) in zip(comm_max, b_list, c_list) if c_i != 0 or b_i)\n            for _ in range(100):\n                mid = (low + high) / 2\n                total_p = 0\n                for i, (min_e, max_e, b, c) in enumerate(zip(comm_min, comm_max, b_list, c_list)):\n                    if c == 0:\n                        if mid < b:\n                            p_val = min_e\n                        else:\n                            p_val = max_e\n                    else:\n                        p_val = (mid - b) / (2 * c)\n                        if p_val < min_e:\n                            p_val = min_e\n                        elif p_val > max_e:\n                            p_val = max_e\n                    total_p += p_val\n                if total_p < current_load:\n                    low = mid\n                else:\n                    high = mid\n            # Apply final dispatch\n            mid = (low + high) / 2\n            for idx, (min_e, max_e, b, c) in zip(committed_set, zip(comm_min, comm_max, b_list, c_list)):\n                if c == 0:\n                    if mid < b:\n                        p_output[idx] = min_e\n                    else:\n                        p_output[idx] = max_e\n                else:\n                    p_val = (mid - b) / (2 * c)\n                    if p_val < min_e:\n                        p_val = min_e\n                    elif p_val > max_e:\n                        p_val = max_e\n                    p_output[idx] = p_val\n                u_output[idx] = 1\n    # Build output array\n    return np.array([u_output, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0004982041,
          "gap_price_rate": 0.0235443266,
          "fitness": 0.0120212653
     }
]