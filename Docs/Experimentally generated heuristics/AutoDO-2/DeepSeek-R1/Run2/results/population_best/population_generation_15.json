{
     "name": "refined_rolling_commitment_v8",
     "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity while considering next period's forecasted load and dynamically updating constraints. 7. Perform economic dispatch using incremental cost method with ramp constraints.\n",
     "code": "import numpy as np\n\ndef refined_rolling_commitment_v8(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    forecasted_load_next = load[1]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i] if min_out[i] > 0 else float('inf'), i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p if min_p > 0 else float('inf'), i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i] if min_out[i] > 0 else float('inf'), i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            remaining_max = total_max - max_out[i]\n            if remaining_max >= forecasted_load_next:\n                candidate_decommit.append(i)\n                \n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i] if min_out[i] > 0 else float('inf'), i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load) and (total_max - max_out[i] >= forecasted_load_next):\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.00129,
     "gap_price_rate": 0.01095,
     "fitness": 0.00612
}