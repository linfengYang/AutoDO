{
     "name": "enhanced_hybrid_rolling_commitment_v4",
     "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform constrained economic dispatch using incremental cost method with ramp constraints.\n",
     "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Step 2: Initialize commitment states\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    \n    for idx in must_on:\n        u_current[idx] = 1\n    for idx in free_on:\n        u_current[idx] = 1\n    for idx in must_off:\n        u_current[idx] = 0\n    for idx in free_off:\n        u_current[idx] = 0\n    \n    # Helper functions\n    def total_min_output():\n        total_min = 0\n        for idx in range(n_units):\n            if u_current[idx] == 1:\n                if units_info[idx]['u_i_0'] == 1:\n                    min_output = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n                else:\n                    min_output = units_info[idx]['p_min_i']\n                total_min += min_output\n        return total_min\n    \n    def total_max_output():\n        total_max = 0\n        for idx in range(n_units):\n            if u_current[idx] == 1:\n                if units_info[idx]['u_i_0'] == 1:\n                    max_output = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n                else:\n                    max_output = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                total_max += max_output\n        return total_max\n    \n    # Step 3: Decommit expensive free-on units if total_min > load\n    total_min = total_min_output()\n    if total_min > current_load:\n        free_on_sorted = sorted(free_on, \n                                key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                reverse=True)\n        for idx in free_on_sorted:\n            if total_min <= current_load:\n                break\n            u_current[idx] = 0\n            total_min = total_min_output()\n    \n    # Step 4: Commit cheapest free-off units if total_max < load\n    total_max = total_max_output()\n    if total_max < current_load:\n        free_off_sorted = sorted(free_off, \n                                 key=lambda idx: (units_info[idx]['a_i'] + units_info[idx]['b_i'] * units_info[idx]['p_max_i'] + \n                                                 units_info[idx]['c_i'] * (units_info[idx]['p_max_i']**2) + units_info[idx]['s_i']) / units_info[idx]['p_max_i'])\n        for idx in free_off_sorted:\n            u_current[idx] = 1\n            total_max = total_max_output()\n            if total_max >= current_load:\n                break\n    \n    # Step 5: Decommit expensive non-must-on if total_min still > load\n    non_must_on = free_on + free_off\n    committed_non_must_on = [idx for idx in non_must_on if u_current[idx] == 1]\n    total_min = total_min_output()\n    if total_min > current_load:\n        committed_non_must_on_sorted = sorted(committed_non_must_on, \n                                             key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                             reverse=True)\n        for idx in committed_non_must_on_sorted:\n            if total_min <= current_load:\n                break\n            u_current[idx] = 0\n            total_min = total_min_output()\n    \n    # Step 6: Decommit expensive non-must-on with excess capacity\n    committed_units = [idx for idx in range(n_units) if u_current[idx] == 1]\n    non_must_on_committed = [idx for idx in committed_units if idx in non_must_on]\n    non_must_on_committed_sorted = sorted(non_must_on_committed, \n                                         key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                         reverse=True)\n    for idx in non_must_on_committed_sorted:\n        u_current[idx] = 0\n        if total_max_output() < current_load or total_min_output() > current_load:\n            u_current[idx] = 1\n    \n    # Step 7: Economic dispatch for committed units\n    committed_idxs = [idx for idx in range(n_units) if u_current[idx] == 1]\n    \n    # Set bounds for each committed unit\n    lower_bounds = []\n    upper_bounds = []\n    for idx in committed_idxs:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Was online\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Starting up\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_lb = sum(lower_bounds)\n    total_ub = sum(upper_bounds)\n    \n    # Initialize outputs to lower bounds\n    p_alloc = [lb for lb in lower_bounds]\n    remaining = current_load - total_lb\n    \n    # Distribute remaining load\n    if remaining > 0:\n        # Active units are those not at upper bound\n        active_units = [i for i in range(len(committed_idxs)) if p_alloc[i] < upper_bounds[i]]\n        \n        while remaining > 0 and active_units:\n            # Find unit with smallest incremental cost\n            min_ic = float('inf')\n            candidate_idx = None\n            for i in active_units:\n                unit_idx = committed_idxs[i]\n                ic = 2 * units_info[unit_idx]['c_i'] * p_alloc[i] + units_info[unit_idx]['b_i']\n                if ic < min_ic:\n                    min_ic = ic\n                    candidate_idx = i\n            \n            if candidate_idx is None:\n                break\n                \n            # Calculate available capacity for candidate\n            available = upper_bounds[candidate_idx] - p_alloc[candidate_idx]\n            if available > 0:\n                add = min(available, remaining)\n                p_alloc[candidate_idx] += add\n                remaining -= add\n                # Check if unit reached upper bound\n                if p_alloc[candidate_idx] >= upper_bounds[candidate_idx] - 1e-5:\n                    active_units.remove(candidate_idx)\n    \n    # Map allocations back to units\n    for i, idx in enumerate(committed_idxs):\n        p_current[idx] = p_alloc[i]\n    \n    # Create output array\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u_current[i]\n        schedules[1, i] = p_current[i]\n    \n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.00407,
     "gap_price_rate": 0.01134,
     "fitness": 0.0077
}