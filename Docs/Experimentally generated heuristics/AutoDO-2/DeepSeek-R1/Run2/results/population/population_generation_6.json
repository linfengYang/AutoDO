[
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01183,
          "fitness": 0.00812
     },
     {
          "name": "enhanced_rolling_commitment_ed",
          "algorithm": "1. Classify units into must-on (violate min up-time/shutdown ramp), must-off (violate min down-time), free-on (can be turned off), and free-off (can be turned on). 2. Initialize commitment with must-on and free-on units. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit free-off units by ascending cost per MW if total maximum output is below load. 5. Decommit unneeded free-on units if excess capacity remains. 6. Perform economic dispatch using incremental cost method to distribute load.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_ed(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        free_on_committed = [i for i in free_on if u[i] == 1]\n        if free_on_committed:\n            cost_per_mw = []\n            for i in free_on_committed:\n                unit = units_info[i]\n                p_val = min_out[i]\n                cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n                cost_per_mw.append((cost_val, i))\n            cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n            for cost_val, i in cost_per_mw:\n                if total_min > current_load:\n                    u[i] = 0\n                    total_min -= min_out[i]\n                    total_max -= max_out[i]\n                    min_out[i] = 0\n                    max_out[i] = 0\n                else:\n                    break\n                    \n    if total_max < current_load:\n        free_off_not_committed = [i for i in free_off if u[i] == 0]\n        if free_off_not_committed:\n            cost_per_mw = []\n            for i in free_off_not_committed:\n                unit = units_info[i]\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n                cost_val = total_cost / min_p\n                cost_per_mw.append((cost_val, i, min_p, max_p))\n            cost_per_mw.sort(key=lambda x: x[0])\n            for cost_val, i, min_p, max_p in cost_per_mw:\n                if total_max < current_load:\n                    u[i] = 1\n                    min_out[i] = min_p\n                    max_out[i] = max_p\n                    total_min += min_p\n                    total_max += max_p\n                else:\n                    break\n                    \n    free_on_committed = [i for i in free_on if u[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        for i in free_on_committed:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_max - max_out[i] >= current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0048,
          "gap_price_rate": 0.01286,
          "fitness": 0.00883
     },
     {
          "name": "refined_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (can be decommitted), and free-off (can be committed). 2. Initialize committed_set with must-on and free-on units. 3. If current load exceeds total capacity, commit free-off units prioritized by (startup cost + production cost at min output)/min output. 4. If minimum generation exceeds load, decommit free-on units prioritized by highest production cost per MW at min output while maintaining feasibility. 5. Perform economic dispatch via lambda iteration respecting ramp constraints. 6. Refine commitment by removing one expensive free-on unit if feasible after initial dispatch.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed_set = set()\n    \n    current_load = load[0]\n    next_load = load[1]\n    \n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                free_off.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p[i] for i in committed_set)\n    total_max = sum(max_p[i] for i in committed_set)\n    \n    if current_load > total_max:\n        candidate_free_off = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost_at_min = s_i + a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val if min_p_i_val > 0 else float('inf')\n            candidate_free_off.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_off.sort(key=lambda x: x[3])\n        \n        for cand in candidate_free_off:\n            i, min_val, max_val, _ = cand\n            committed_set.add(i)\n            total_min += min_val\n            total_max += max_val\n            if total_max >= current_load:\n                break\n                \n    if current_load < total_min:\n        candidate_free_on = []\n        for i in free_on:\n            if i in committed_set:\n                a_i = units_info[i]['a_i']\n                b_i = units_info[i]['b_i']\n                c_i = units_info[i]['c_i']\n                min_p_i_val = min_p[i]\n                max_p_i_val = max_p[i]\n                cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n                priority = cost_at_min / min_p_i_val\n                candidate_free_on.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_on.sort(key=lambda x: x[3], reverse=True)\n        \n        for cand in candidate_free_on:\n            if total_min <= current_load:\n                break\n            i, min_val, max_val, _ = cand\n            new_total_min = total_min - min_val\n            new_total_max = total_max - max_val\n            if new_total_min <= current_load <= new_total_max:\n                committed_set.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n    \n    candidate_free_on_refine = []\n    for i in free_on:\n        if i in committed_set:\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_on_refine.append((i, min_p_i_val, max_p_i_val, priority))\n    \n    candidate_free_on_refine.sort(key=lambda x: x[3], reverse=True)\n    \n    for cand in candidate_free_on_refine:\n        i, min_val, max_val, _ = cand\n        new_total_min = total_min - min_val\n        new_total_max = total_max - max_val\n        if new_total_min <= current_load <= new_total_max:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            break\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if len(committed_set) > 0:\n        indices_committed = sorted(committed_set)\n        min_p_list = [min_p[i] for i in indices_committed]\n        max_p_list = [max_p[i] for i in indices_committed]\n        b_list = [units_info[i]['b_i'] for i in indices_committed]\n        c_list = [units_info[i]['c_i'] for i in indices_committed]\n        \n        low = min(b_i + 2 * c_i * min_p_i for b_i, c_i, min_p_i in zip(b_list, c_list, min_p_list))\n        high = max(b_i + 2 * c_i * max_p_i for b_i, c_i, max_p_i in zip(b_list, c_list, max_p_list))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2.0\n            total_p = 0.0\n            for i in range(len(indices_committed)):\n                p_val = (mid - b_list[i]) / (2 * c_list[i])\n                if p_val < min_p_list[i]:\n                    p_val = min_p_list[i]\n                elif p_val > max_p_list[i]:\n                    p_val = max_p_list[i]\n                total_p += p_val\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        mid = (low + high) / 2.0\n        p_committed = []\n        for i in range(len(indices_committed)):\n            p_val = (mid - b_list[i]) / (2 * c_list[i])\n            if p_val < min_p_list[i]:\n                p_val = min_p_list[i]\n            elif p_val > max_p_list[i]:\n                p_val = max_p_list[i]\n            p_committed.append(p_val)\n        \n        for idx, p_val in zip(indices_committed, p_committed):\n            p_out[idx] = p_val\n            u_out[idx] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00072,
          "gap_price_rate": 0.01762,
          "fitness": 0.00917
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "dynamic_rolling_commitment_enhanced",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on). 2. Start with must-on and free-on units committed. 3. If initial dispatch fails due to insufficient capacity, activate free-off units by prioritizing lowest (startup cost + marginal cost at min output)/min output. 4. If minimum generation exceeds load, deactivate free-on units by prioritizing highest (production cost at min output)/min output while ensuring feasibility. 5. Perform economic dispatch using lambda iteration respecting ramp limits and output constraints. 6. Refine commitment by deactivating non-essential free-on units based on cost savings and feasibility.\n",
          "code": "import numpy as np\n\ndef dynamic_rolling_commitment_enhanced(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed_set = set()\n    \n    current_load = load[0]\n    \n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                free_off.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p[i] for i in committed_set)\n    total_max = sum(max_p[i] for i in committed_set)\n    \n    if current_load > total_max:\n        candidate_free_off = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost_at_min = s_i + a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_off.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_off.sort(key=lambda x: x[3])\n        \n        for cand in candidate_free_off:\n            i, min_val, max_val, _ = cand\n            new_total_min = total_min + min_val\n            new_total_max = total_max + max_val\n            committed_set.add(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= current_load:\n                break\n                \n    elif current_load < total_min:\n        candidate_free_on = []\n        for i in free_on:\n            if i not in committed_set:\n                continue\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_on.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_on.sort(key=lambda x: x[3], reverse=True)\n        \n        for cand in candidate_free_on:\n            i, min_val, max_val, _ = cand\n            new_total_min = total_min - min_val\n            new_total_max = total_max - max_val\n            if new_total_min <= current_load <= new_total_max:\n                committed_set.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n            if total_min <= current_load:\n                break\n    \n    candidate_free_on_refine = []\n    for i in free_on:\n        if i in committed_set:\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_on_refine.append((i, min_p_i_val, max_p_i_val, priority))\n    \n    candidate_free_on_refine.sort(key=lambda x: x[3], reverse=True)\n    \n    for cand in candidate_free_on_refine:\n        i, min_val, max_val, _ = cand\n        new_total_min = total_min - min_val\n        new_total_max = total_max - max_val\n        if new_total_min <= current_load <= new_total_max:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if len(committed_set) > 0:\n        indices_committed = sorted(committed_set)\n        min_p_list = [min_p[i] for i in indices_committed]\n        max_p_list = [max_p[i] for i in indices_committed]\n        b_list = [units_info[i]['b_i'] for i in indices_committed]\n        c_list = [units_info[i]['c_i'] for i in indices_committed]\n        \n        low = min(b_i + 2 * c_i * min_p_i for b_i, c_i, min_p_i in zip(b_list, c_list, min_p_list))\n        high = max(b_i + 2 * c_i * max_p_i for b_i, c_i, max_p_i in zip(b_list, c_list, max_p_list))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2.0\n            total_p = 0.0\n            for i in range(len(indices_committed)):\n                p_val = (mid - b_list[i]) / (2 * c_list[i])\n                if p_val < min_p_list[i]:\n                    p_val = min_p_list[i]\n                elif p_val > max_p_list[i]:\n                    p_val = max_p_list[i]\n                total_p += p_val\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        mid = (low + high) / 2.0\n        p_committed = []\n        for i in range(len(indices_committed)):\n            p_val = (mid - b_list[i]) / (2 * c_list[i])\n            if p_val < min_p_list[i]:\n                p_val = min_p_list[i]\n            elif p_val > max_p_list[i]:\n                p_val = max_p_list[i]\n            p_committed.append(p_val)\n        \n        for idx, p_val in zip(indices_committed, p_committed):\n            p_out[idx] = p_val\n            u_out[idx] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01741,
          "fitness": 0.01101
     },
     {
          "name": "enhanced_rolling_commitment_v6",
          "algorithm": "1. Identify must-run units (online in previous period that haven't satisfied minimum up-time or exceeded shutdown capacity) and must-stay-off units (offline units still within minimum down-time). 2. Compute total min/max capacity from must-run units considering ramp constraints. 3. If current load \u2264 total min, set must-run units to min output and turn off others. 4. Else if load within must-run capacity, dispatch only must-run units economically. 5. Else, consider base units (all previously online units) and compute their capacity. 6. If load within base capacity, dispatch base units economically. 7. Else, sort candidate units by adjusted cost per MW (accounting for startup costs over minimum up-time) and add cheapest until capacity meets load. 8. Dispatch all committed units using lambda iteration considering ramp constraints and startup/shutdown limits. 9. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v6(units_info, load):\n    num_units = len(units_info)\n    u_i = np.zeros(num_units)\n    p_i = np.zeros(num_units)\n    \n    # Identify must-run and must-stay-off units\n    must_run = []\n    must_stay_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_stay_off.append(i)\n    \n    # Compute total min/max from must-run units with ramp constraints\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_must += lb\n        total_max_must += ub\n    \n    current_load = load[0]\n    # Case 1: load <= total_min_must\n    if current_load <= total_min_must:\n        for i in range(num_units):\n            if i in must_run:\n                unit = units_info[i]\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                u_i[i] = 1\n                p_i[i] = lb\n            else:\n                u_i[i] = 0\n                p_i[i] = 0\n        return np.array([u_i, p_i])\n    \n    # Case 2: load within must-run capacity\n    if current_load <= total_max_must:\n        committed = must_run\n        bounds = []\n        coeffs = []\n        for i in committed:\n            unit = units_info[i]\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            bounds.append((lb, ub))\n            coeffs.append((unit['b_i'], unit['c_i']))\n        p_vals = economic_dispatch(committed, current_load, bounds, coeffs)\n        for idx, i in enumerate(committed):\n            u_i[i] = 1\n            p_i[i] = p_vals[idx]\n        return np.array([u_i, p_i])\n    \n    # Case 3: Beyond must-run capacity\n    base_units = [i for i, unit in enumerate(units_info) if unit['u_i_0'] == 1]\n    base_min = 0\n    base_max = 0\n    base_bounds = {}\n    for i in base_units:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        base_min += lb\n        base_max += ub\n        base_bounds[i] = (lb, ub)\n    \n    # Subcase 3a: Load within base capacity\n    if current_load <= base_max:\n        committed = base_units\n        bounds = [base_bounds[i] for i in committed]\n        coeffs = [(units_info[i]['b_i'], units_info[i]['c_i']) for i in committed]\n        p_vals = economic_dispatch(committed, current_load, bounds, coeffs)\n        for idx, i in enumerate(committed):\n            u_i[i] = 1\n            p_i[i] = p_vals[idx]\n        return np.array([u_i, p_i])\n    \n    # Subcase 3b: Need additional units\n    candidate_units = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 0 and i not in must_stay_off:\n            candidate_units.append(i)\n    \n    # Calculate adjusted costs for candidates\n    adjusted_costs = []\n    for i in candidate_units:\n        unit = units_info[i]\n        min_p = unit['p_min_i']\n        if unit['t_on_min_i'] > 1:\n            total_cost = unit['s_i'] + unit['t_on_min_i'] * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)\n            cost_per_mw = total_cost / (unit['t_on_min_i'] * min_p)\n        else:\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        adjusted_costs.append((i, cost_per_mw))\n    \n    # Sort candidates by cost\n    candidate_units_sorted = [i for i, _ in sorted(adjusted_costs, key=lambda x: x[1])]\n    committed = base_units.copy()\n    current_capacity = base_max\n    added_units = []\n    for i in candidate_units_sorted:\n        if current_capacity >= current_load:\n            break\n        unit = units_info[i]\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        current_capacity += max_p\n        committed.append(i)\n        added_units.append(i)\n    \n    # Prepare bounds for dispatch\n    bounds_list = []\n    coeffs_list = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds_list.append((lb, ub))\n        coeffs_list.append((unit['b_i'], unit['c_i']))\n    \n    # Dispatch\n    p_vals = economic_dispatch(committed, current_load, bounds_list, coeffs_list)\n    for idx, i in enumerate(committed):\n        u_i[i] = 1\n        p_i[i] = p_vals[idx]\n    \n    return np.array([u_i, p_i])\n\ndef economic_dispatch(committed, load, bounds, coeffs):\n    n = len(committed)\n    if n == 0:\n        return []\n    \n    # Calculate total min and max\n    total_min = sum(lb for lb, ub in bounds)\n    total_max = sum(ub for lb, ub in bounds)\n    \n    # If load is below total min, set to min\n    if load <= total_min:\n        return [lb for lb, ub in bounds]\n    \n    # If load is above total max, set to max\n    if load >= total_max:\n        return [ub for lb, ub in bounds]\n    \n    # Lambda iteration\n    low = min(b + 2*c*lb for (lb, ub), (b, c) in zip(bounds, coeffs))\n    high = max(b + 2*c*ub for (lb, ub), (b, c) in zip(bounds, coeffs))\n    lmbda = (low + high) / 2\n    tol = 1e-5\n    iteration = 0\n    max_iter = 1000\n    \n    while iteration < max_iter:\n        total_p = 0\n        p_vals = []\n        for (lb, ub), (b, c) in zip(bounds, coeffs):\n            p = (lmbda - b) / (2 * c)\n            p = max(lb, min(ub, p))\n            p_vals.append(p)\n            total_p += p\n        \n        if abs(total_p - load) < tol:\n            return p_vals\n        \n        if total_p < load:\n            low = lmbda\n        else:\n            high = lmbda\n        \n        lmbda = (low + high) / 2\n        iteration += 1\n    \n    # Adjust for any imbalance after iterations\n    diff = load - sum(p_vals)\n    if abs(diff) > tol:\n        p_vals = adjust_imbalance(p_vals, diff, bounds)\n    \n    return p_vals\n\ndef adjust_imbalance(p_vals, diff, bounds):\n    n = len(p_vals)\n    if diff > 0:  # Need to increase generation\n        indices = sorted(range(n), key=lambda i: p_vals[i] - bounds[i][1])  # Most below max\n        for i in indices:\n            if diff <= 0:\n                break\n            available = bounds[i][1] - p_vals[i]\n            add = min(available, diff)\n            p_vals[i] += add\n            diff -= add\n    else:  # Need to decrease generation\n        diff = abs(diff)\n        indices = sorted(range(n), key=lambda i: bounds[i][0] - p_vals[i])  # Most above min\n        for i in indices:\n            if diff <= 0:\n                break\n            available = p_vals[i] - bounds[i][0]\n            sub = min(available, diff)\n            p_vals[i] -= sub\n            diff -= sub\n    return p_vals",
          "from": "crossover",
          "gap_power_rate": 0.00473,
          "gap_price_rate": 0.01766,
          "fitness": 0.0112
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "enhanced_rolling_commitment_v5",
          "algorithm": "1. Classify units into must-on (due to min up-time constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on). 2. Start with must-on and free-on units committed. Perform economic dispatch considering ramp constraints and startup/shutdown limits. 3. If dispatch fails, turn on free-off units sorted by startup efficiency (startup cost plus fixed cost per available capacity plus marginal cost at min output) until dispatch succeeds. 4. If dispatch succeeds, attempt to turn off free-on units by evaluating actual cost savings through re-dispatch. 5. Return final commitment and dispatch schedules.\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        idx = indices[i]\n        dispatch_dict[idx] = p[i]\n        if unit['u_i_0'] == 0 and p[i] > 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef enhanced_rolling_commitment_v5(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, total_cost = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            available_capacity = min(unit['p_max_i'], unit['p_start_i'])\n            if available_capacity <= 0:\n                continue\n            key = (unit['s_i'] + unit['a_i']) / available_capacity + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, total_cost = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            total_cost = 0\n            for i in online_set:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    ub_i = min(unit['p_max_i'], unit['p_start_i'])\n                dispatch_result[i] = ub_i\n                if unit['u_i_0'] == 0:\n                    total_cost += unit['s_i']\n                total_cost += unit['a_i'] + unit['b_i'] * ub_i + unit['c_i'] * (ub_i ** 2)\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i not in online_set or i not in dispatch_result:\n                continue\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, new_total_cost = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None and new_total_cost < total_cost:\n                saving = total_cost - new_total_cost\n                candidates.append((saving, i, new_online_set, new_dispatch, new_total_cost))\n        \n        if candidates:\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            saving, i, new_online_set, new_dispatch, new_total_cost = candidates[0]\n            online_set = new_online_set\n            dispatch_result = new_dispatch\n            total_cost = new_total_cost\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00081,
          "gap_price_rate": 0.02267,
          "fitness": 0.01174
     },
     {
          "name": "enhanced_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v4(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        free_on_committed = [i for i in free_on if u[i] == 1]\n        candidate_to_decommit = [i for i in free_on_committed if units_info[i]['p_i_0'] <= units_info[i]['p_down_i']]\n        if candidate_to_decommit:\n            cost_per_mw = []\n            for i in candidate_to_decommit:\n                unit = units_info[i]\n                p_val = min_out[i]\n                cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n                cost_per_mw.append((cost_val, i))\n            cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n            for cost_val, i in cost_per_mw:\n                if total_min > current_load:\n                    u[i] = 0\n                    total_min -= min_out[i]\n                    total_max -= max_out[i]\n                    min_out[i] = 0\n                    max_out[i] = 0\n                else:\n                    break\n                    \n    if total_max < current_load:\n        free_off_not_committed = [i for i in free_off if u[i] == 0]\n        if free_off_not_committed:\n            cost_per_mw = []\n            for i in free_off_not_committed:\n                unit = units_info[i]\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n                cost_val = total_cost / min_p\n                cost_per_mw.append((cost_val, i, min_p, max_p))\n            cost_per_mw.sort(key=lambda x: x[0])\n            for cost_val, i, min_p, max_p in cost_per_mw:\n                if total_max < current_load:\n                    u[i] = 1\n                    min_out[i] = min_p\n                    max_out[i] = max_p\n                    total_min += min_p\n                    total_max += max_p\n                else:\n                    break\n                    \n    free_on_committed = [i for i in free_on if u[i] == 1]\n    candidate_to_decommit = [i for i in free_on_committed if units_info[i]['p_i_0'] <= units_info[i]['p_down_i']]\n    if candidate_to_decommit:\n        cost_per_mw = []\n        for i in candidate_to_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_max - max_out[i] >= current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00077,
          "gap_price_rate": 0.02381,
          "fitness": 0.01229
     },
     {
          "name": "hybrid_rolling_commitment_optimized",
          "algorithm": "1. Identify must-run units that were online previously and either haven't satisfied minimum up-time or exceed shutdown capacity. 2. Calculate total min/max capacity from must-run units with ramp constraints. 3. If must-run min capacity exceeds load, set them to min outputs and turn off other units respecting shutdown constraints. 4. If load is within must-run capacity, dispatch only must-run units. 5. Otherwise, consider candidate units (non-must-run) sorted by cost efficiency including startup costs. 6. Add cheapest candidates until available capacity meets or exceeds load. 7. Perform economic dispatch using bisection-based lambda iteration on committed units to minimize costs. 8. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(b_list, c_list, bounds, load):\n    total_min = sum(bound[0] for bound in bounds)\n    total_max = sum(bound[1] for bound in bounds)\n    n_units = len(b_list)\n    if total_min >= load:\n        return [bound[0] for bound in bounds]\n    if total_max <= load:\n        return [bound[1] for bound in bounds]\n    \n    inc_min = []\n    inc_max = []\n    for i in range(n_units):\n        if c_list[i] > 0:\n            inc_min.append(b_list[i] + 2 * c_list[i] * bounds[i][0])\n            inc_max.append(b_list[i] + 2 * c_list[i] * bounds[i][1])\n        else:\n            inc_min.append(b_list[i])\n            inc_max.append(b_list[i])\n    \n    lambda_low = min(inc_min)\n    lambda_high = max(inc_max)\n    tol = 0.1\n    max_iter = 100\n    p_out = [0] * n_units\n    \n    for _ in range(max_iter):\n        lm = (lambda_low + lambda_high) / 2.0\n        total_p = 0.0\n        for i in range(n_units):\n            if c_list[i] > 0:\n                p_i = (lm - b_list[i]) / (2 * c_list[i])\n                if p_i < bounds[i][0]:\n                    p_i = bounds[i][0]\n                elif p_i > bounds[i][1]:\n                    p_i = bounds[i][1]\n            else:\n                if lm > b_list[i]:\n                    p_i = bounds[i][1]\n                elif lm < b_list[i]:\n                    p_i = bounds[i][0]\n                else:\n                    p_i = bounds[i][0]\n            p_out[i] = p_i\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        if total_p < load:\n            lambda_low = lm\n        else:\n            lambda_high = lm\n    \n    return p_out\n\ndef hybrid_rolling_commitment_optimized(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_run_indices = []\n    min_outputs = [0] * n_units\n    max_outputs = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run_indices.append(i)\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min_A = sum(min_outputs[i] for i in must_run_indices)\n    total_max_A = sum(max_outputs[i] for i in must_run_indices)\n    \n    u = [0] * n_units\n    p = [0] * n_units\n    \n    if total_min_A > current_load:\n        for i in must_run_indices:\n            u[i] = 1\n            p[i] = min_outputs[i]\n        for i in range(n_units):\n            if i not in must_run_indices:\n                if units_info[i]['u_i_0'] == 1:\n                    if units_info[i]['p_i_0'] <= units_info[i]['p_down_i'] and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                        u[i] = 0\n                    else:\n                        u[i] = 1\n                        p[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    u[i] = 0\n    \n    elif current_load <= total_max_A:\n        for i in must_run_indices:\n            u[i] = 1\n        for i in range(n_units):\n            if i not in must_run_indices:\n                if units_info[i]['u_i_0'] == 1:\n                    if units_info[i]['p_i_0'] <= units_info[i]['p_down_i'] and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                        u[i] = 0\n                    else:\n                        u[i] = 1\n                        p[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    u[i] = 0\n        \n        committed_units = [i for i in range(n_units) if u[i] == 1]\n        bounds_ed = []\n        b_list = []\n        c_list = []\n        for i in committed_units:\n            if i in must_run_indices or units_info[i]['u_i_0'] == 1:\n                low = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                high = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                low = units_info[i]['p_min_i']\n                high = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            bounds_ed.append((low, high))\n            b_list.append(units_info[i]['b_i'])\n            c_list.append(units_info[i]['c_i'])\n        \n        p_committed = economic_dispatch(b_list, c_list, bounds_ed, current_load)\n        for idx, val in zip(committed_units, p_committed):\n            p[idx] = val\n    \n    else:\n        candidate_indices = []\n        for i in range(n_units):\n            if i in must_run_indices:\n                continue\n            if units_info[i]['u_i_0'] == 1:\n                candidate_indices.append(i)\n            else:\n                if units_info[i]['t_i_0'] < 0 and -units_info[i]['t_i_0'] < units_info[i]['t_off_min_i']:\n                    continue\n                candidate_indices.append(i)\n        \n        candidate_costs = []\n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                total_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            else:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            cost_per_mw = total_cost / unit['p_min_i']\n            candidate_costs.append((cost_per_mw, i))\n        \n        candidate_costs.sort(key=lambda x: x[0])\n        sorted_candidates = [idx for _, idx in candidate_costs]\n        total_min = total_min_A\n        total_max = total_max_A\n        committed_candidates = []\n        \n        for idx in sorted_candidates:\n            if units_info[idx]['u_i_0'] == 1:\n                low = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n                high = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            else:\n                low = units_info[idx]['p_min_i']\n                high = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            total_min += low\n            total_max += high\n            committed_candidates.append(idx)\n            if total_max >= current_load:\n                break\n        \n        for i in must_run_indices:\n            u[i] = 1\n        for i in committed_candidates:\n            u[i] = 1\n        for i in range(n_units):\n            if u[i] == 0 and units_info[i]['u_i_0'] == 1:\n                if units_info[i]['p_i_0'] <= units_info[i]['p_down_i'] and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                    u[i] = 0\n                else:\n                    u[i] = 1\n                    p[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                    if i not in committed_candidates:\n                        committed_candidates.append(i)\n        \n        committed_units = must_run_indices + committed_candidates\n        bounds_ed = []\n        b_list = []\n        c_list = []\n        for i in committed_units:\n            if i in must_run_indices or units_info[i]['u_i_0'] == 1:\n                low = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                high = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                low = units_info[i]['p_min_i']\n                high = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            bounds_ed.append((low, high))\n            b_list.append(units_info[i]['b_i'])\n            c_list.append(units_info[i]['c_i'])\n        \n        p_committed = economic_dispatch(b_list, c_list, bounds_ed, current_load)\n        for idx, val in zip(committed_units, p_committed):\n            p[idx] = val\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00064,
          "gap_price_rate": 0.03002,
          "fitness": 0.01533
     }
]