[
     {
          "name": "refined_rolling_commitment_v5",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity without breaking loop on unmet conditions. 7. Perform economic dispatch using incremental cost method with improved numerical stability.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v5(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 1e-5:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i] - 1e-5]\n        while remaining > 1e-5 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01172,
          "fitness": 0.00806
     },
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        avg_costs = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw = total_cost / min_p\n            avg_costs.append((cost_per_mw, i, min_p, max_p))\n        avg_costs.sort(key=lambda x: x[0])\n        for cost_per_mw, i, min_p, max_p in avg_costs:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    incremental_costs = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n        incremental_costs.append((inc_cost, i))\n    incremental_costs.sort(key=lambda x: x[0], reverse=True)\n    for inc_cost, i in incremental_costs:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01179,
          "fitness": 0.0081
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01183,
          "fitness": 0.00812
     },
     {
          "name": "refined_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v4(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            continue\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01189,
          "fitness": 0.00815
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v2",
          "algorithm": "1. Precompute current period min/max outputs for online units considering ramp constraints.  \n2. Identify must-run units (online units violating min up-time or shutdown capacity).  \n3. Calculate total min/max capacity from must-run units.  \n4. If must-run min capacity exceeds load, set must-run units to min output and turn off others.  \n5. Else if load within must-run capacity, perform economic dispatch on must-run units.  \n6. Else:  \n   a. Identify candidate units (offline units satisfying min down-time).  \n   b. Sort candidates by average cost at min output (including startup cost).  \n   c. Add cheapest candidates until total capacity >= load.  \n   d. If insufficient capacity, set units to max output.  \n   e. Else perform economic dispatch on committed units considering constraints.  \n7. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_hybrid_rolling_commitment_v2(units_info, load):  \n    n_units = len(units_info)  \n    schedules = np.zeros((2, n_units))  \n    current_load = load[0]  \n    \n    # Step 1: Precompute current period min/max for online units  \n    min_outputs = np.zeros(n_units)  \n    max_outputs = np.zeros(n_units)  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  # Online last period  \n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  # Offline last period  \n            min_outputs[i] = 0  \n            max_outputs[i] = 0  \n    \n    # Step 2: Identify must-run units  \n    must_run = []  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):  \n                must_run.append(i)  \n    \n    # Step 3: Total must-run capacity  \n    must_run_min = sum(min_outputs[i] for i in must_run)  \n    must_run_max = sum(max_outputs[i] for i in must_run)  \n    \n    # Step 4: Must-run min exceeds load  \n    if must_run_min > current_load:  \n        for i in range(n_units):  \n            if i in must_run:  \n                schedules[0, i] = 1  \n                schedules[1, i] = min_outputs[i]  \n            else:  \n                schedules[0, i] = 0  \n                schedules[1, i] = 0  \n        return schedules  \n    \n    # Step 5: Load within must-run capacity  \n    if current_load <= must_run_max:  \n        committed = must_run  \n        min_vals = [min_outputs[i] for i in committed]  \n        max_vals = [max_outputs[i] for i in committed]  \n        b_vals = [units_info[i]['b_i'] for i in committed]  \n        c_vals = [units_info[i]['c_i'] for i in committed]  \n        p_alloc = economic_dispatch(min_vals, max_vals, b_vals, c_vals, current_load)  \n        for idx, unit_idx in enumerate(committed):  \n            schedules[0, unit_idx] = 1  \n            schedules[1, unit_idx] = p_alloc[idx]  \n        return schedules  \n    \n    # Step 6: Need additional units  \n    # 6a. Identify candidate units  \n    candidates = []  \n    for i, unit in enumerate(units_info):  \n        if i in must_run:  \n            continue  \n        if unit['u_i_0'] == 0 and unit['t_i_0'] <= -unit['t_off_min_i']:  \n            candidates.append(i)  \n    \n    # 6b. Sort candidates by cost efficiency  \n    def cost_efficiency(i):  \n        u = units_info[i]  \n        base_cost = u['s_i'] + u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*(u['p_min_i']**2)  \n        return base_cost / u['p_min_i']  \n    candidates.sort(key=cost_efficiency)  \n    \n    # 6c. Add candidates until capacity >= load  \n    committed = must_run.copy()  \n    total_capacity = must_run_max  \n    added = []  \n    for i in candidates:  \n        unit_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])  \n        total_capacity += unit_max  \n        committed.append(i)  \n        added.append(i)  \n        if total_capacity >= current_load:  \n            break  \n    \n    # Prepare for dispatch  \n    min_vals = []  \n    max_vals = []  \n    b_vals = []  \n    c_vals = []  \n    for i in committed:  \n        if i in must_run:  \n            min_vals.append(min_outputs[i])  \n            max_vals.append(max_outputs[i])  \n        else:  \n            min_vals.append(units_info[i]['p_min_i'])  \n            max_vals.append(min(units_info[i]['p_max_i'], units_info[i]['p_start_i']))  \n        b_vals.append(units_info[i]['b_i'])  \n        c_vals.append(units_info[i]['c_i'])  \n    \n    total_min = sum(min_vals)  \n    total_max = sum(max_vals)  \n    \n    # 6d. Insufficient capacity  \n    if total_max < current_load:  \n        for idx, unit_idx in enumerate(committed):  \n            schedules[0, unit_idx] = 1  \n            schedules[1, unit_idx] = max_vals[idx]  \n        return schedules  \n    \n    # 6e. Perform economic dispatch  \n    if total_min > current_load:  \n        p_alloc = min_vals  # Overproduce at min  \n    elif total_max < current_load:  \n        p_alloc = max_vals  # Underproduce at max  \n    else:  \n        p_alloc = economic_dispatch(min_vals, max_vals, b_vals, c_vals, current_load)  \n    \n    for idx, unit_idx in enumerate(committed):  \n        schedules[0, unit_idx] = 1  \n        schedules[1, unit_idx] = p_alloc[idx]  \n    return schedules  \n\ndef economic_dispatch(min_vals, max_vals, b_vals, c_vals, load):  \n    n = len(min_vals)  \n    p_alloc = [0] * n  \n    total_min = sum(min_vals)  \n    total_max = sum(max_vals)  \n    \n    if abs(total_min - total_max) < 1e-5 or load <= total_min:  \n        return min_vals  \n    if load >= total_max:  \n        return max_vals  \n    \n    # Bisection method  \n    tol = 1e-5  \n    max_iter = 1000  \n    lambda_low = min(b_i + 2 * c_i * min_i for min_i, b_i, c_i in zip(min_vals, b_vals, c_vals))  \n    lambda_high = max(b_i + 2 * c_i * max_i for max_i, b_i, c_i in zip(max_vals, b_vals, c_vals))  \n    \n    for _ in range(max_iter):  \n        lambda_mid = (lambda_low + lambda_high) / 2  \n        total_p = 0  \n        for i in range(n):  \n            if c_vals[i] == 0:  \n                p_i = max_vals[i] if lambda_mid > b_vals[i] else min_vals[i]  \n            else:  \n                p_i = (lambda_mid - b_vals[i]) / (2 * c_vals[i])  \n                p_i = max(min_vals[i], min(max_vals[i], p_i))  \n            p_alloc[i] = p_i  \n            total_p += p_i  \n        \n        if abs(total_p - load) < tol:  \n            break  \n        if total_p < load:  \n            lambda_low = lambda_mid  \n        else:  \n            lambda_high = lambda_mid  \n    \n    return p_alloc  ",
          "from": "crossover",
          "gap_power_rate": 0.0057,
          "gap_price_rate": 0.01187,
          "fitness": 0.00878
     },
     {
          "name": "enhanced_rolling_commitment_ed",
          "algorithm": "1. Classify units into must-on (violate min up-time/shutdown ramp), must-off (violate min down-time), free-on (can be turned off), and free-off (can be turned on). 2. Initialize commitment with must-on and free-on units. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit free-off units by ascending cost per MW if total maximum output is below load. 5. Decommit unneeded free-on units if excess capacity remains. 6. Perform economic dispatch using incremental cost method to distribute load.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_ed(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        free_on_committed = [i for i in free_on if u[i] == 1]\n        if free_on_committed:\n            cost_per_mw = []\n            for i in free_on_committed:\n                unit = units_info[i]\n                p_val = min_out[i]\n                cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n                cost_per_mw.append((cost_val, i))\n            cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n            for cost_val, i in cost_per_mw:\n                if total_min > current_load:\n                    u[i] = 0\n                    total_min -= min_out[i]\n                    total_max -= max_out[i]\n                    min_out[i] = 0\n                    max_out[i] = 0\n                else:\n                    break\n                    \n    if total_max < current_load:\n        free_off_not_committed = [i for i in free_off if u[i] == 0]\n        if free_off_not_committed:\n            cost_per_mw = []\n            for i in free_off_not_committed:\n                unit = units_info[i]\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n                cost_val = total_cost / min_p\n                cost_per_mw.append((cost_val, i, min_p, max_p))\n            cost_per_mw.sort(key=lambda x: x[0])\n            for cost_val, i, min_p, max_p in cost_per_mw:\n                if total_max < current_load:\n                    u[i] = 1\n                    min_out[i] = min_p\n                    max_out[i] = max_p\n                    total_min += min_p\n                    total_max += max_p\n                else:\n                    break\n                    \n    free_on_committed = [i for i in free_on if u[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        for i in free_on_committed:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_max - max_out[i] >= current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0048,
          "gap_price_rate": 0.01286,
          "fitness": 0.00883
     },
     {
          "name": "refined_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (can be decommitted), and free-off (can be committed). 2. Initialize committed_set with must-on and free-on units. 3. If current load exceeds total capacity, commit free-off units prioritized by (startup cost + production cost at min output)/min output. 4. If minimum generation exceeds load, decommit free-on units prioritized by highest production cost per MW at min output while maintaining feasibility. 5. Perform economic dispatch via lambda iteration respecting ramp constraints. 6. Refine commitment by removing one expensive free-on unit if feasible after initial dispatch.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed_set = set()\n    \n    current_load = load[0]\n    next_load = load[1]\n    \n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                free_off.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p[i] for i in committed_set)\n    total_max = sum(max_p[i] for i in committed_set)\n    \n    if current_load > total_max:\n        candidate_free_off = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost_at_min = s_i + a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val if min_p_i_val > 0 else float('inf')\n            candidate_free_off.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_off.sort(key=lambda x: x[3])\n        \n        for cand in candidate_free_off:\n            i, min_val, max_val, _ = cand\n            committed_set.add(i)\n            total_min += min_val\n            total_max += max_val\n            if total_max >= current_load:\n                break\n                \n    if current_load < total_min:\n        candidate_free_on = []\n        for i in free_on:\n            if i in committed_set:\n                a_i = units_info[i]['a_i']\n                b_i = units_info[i]['b_i']\n                c_i = units_info[i]['c_i']\n                min_p_i_val = min_p[i]\n                max_p_i_val = max_p[i]\n                cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n                priority = cost_at_min / min_p_i_val\n                candidate_free_on.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_on.sort(key=lambda x: x[3], reverse=True)\n        \n        for cand in candidate_free_on:\n            if total_min <= current_load:\n                break\n            i, min_val, max_val, _ = cand\n            new_total_min = total_min - min_val\n            new_total_max = total_max - max_val\n            if new_total_min <= current_load <= new_total_max:\n                committed_set.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n    \n    candidate_free_on_refine = []\n    for i in free_on:\n        if i in committed_set:\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_on_refine.append((i, min_p_i_val, max_p_i_val, priority))\n    \n    candidate_free_on_refine.sort(key=lambda x: x[3], reverse=True)\n    \n    for cand in candidate_free_on_refine:\n        i, min_val, max_val, _ = cand\n        new_total_min = total_min - min_val\n        new_total_max = total_max - max_val\n        if new_total_min <= current_load <= new_total_max:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            break\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if len(committed_set) > 0:\n        indices_committed = sorted(committed_set)\n        min_p_list = [min_p[i] for i in indices_committed]\n        max_p_list = [max_p[i] for i in indices_committed]\n        b_list = [units_info[i]['b_i'] for i in indices_committed]\n        c_list = [units_info[i]['c_i'] for i in indices_committed]\n        \n        low = min(b_i + 2 * c_i * min_p_i for b_i, c_i, min_p_i in zip(b_list, c_list, min_p_list))\n        high = max(b_i + 2 * c_i * max_p_i for b_i, c_i, max_p_i in zip(b_list, c_list, max_p_list))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2.0\n            total_p = 0.0\n            for i in range(len(indices_committed)):\n                p_val = (mid - b_list[i]) / (2 * c_list[i])\n                if p_val < min_p_list[i]:\n                    p_val = min_p_list[i]\n                elif p_val > max_p_list[i]:\n                    p_val = max_p_list[i]\n                total_p += p_val\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        mid = (low + high) / 2.0\n        p_committed = []\n        for i in range(len(indices_committed)):\n            p_val = (mid - b_list[i]) / (2 * c_list[i])\n            if p_val < min_p_list[i]:\n                p_val = min_p_list[i]\n            elif p_val > max_p_list[i]:\n                p_val = max_p_list[i]\n            p_committed.append(p_val)\n        \n        for idx, p_val in zip(indices_committed, p_committed):\n            p_out[idx] = p_val\n            u_out[idx] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00072,
          "gap_price_rate": 0.01762,
          "fitness": 0.00917
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "enhanced_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-run (online in previous period with insufficient min up-time or exceeding shutdown capacity), must-off (offline with insufficient min down-time), free-on (online units that can be decommitted), and free-off (offline units that can be committed). 2. Compute must-run capacity considering ramp constraints. 3. If current load \u2264 total must-run min, set must-run to min output and turn off all other units. 4. Else if load within must-run capacity, dispatch only must-run units economically. 5. Else, consider base units (must-run + free-on) and compute capacity. If load within base capacity, dispatch base units. 6. Else, commit free-off units sorted by adjusted cost (startup + min-output cost per MW) until capacity meets load. 7. Perform economic dispatch via lambda iteration respecting ramp and startup/shutdown constraints. 8. Refine commitment by removing one expensive free-on unit if feasible.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    state = []\n    for i, unit in enumerate(units_info):\n        state.append({\n            'idx': i,\n            'a_i': unit['a_i'],\n            'b_i': unit['b_i'],\n            'c_i': unit['c_i'],\n            'u_i_0': unit['u_i_0'],\n            'p_i_0': unit['p_i_0'],\n            'p_min_i': unit['p_min_i'],\n            'p_max_i': unit['p_max_i'],\n            'p_up_i': unit['p_up_i'],\n            'p_down_i': unit['p_down_i'],\n            'p_start_i': unit['p_start_i'],\n            'p_shut_i': unit['p_shut_i'],\n            't_on_min_i': unit['t_on_min_i'],\n            't_off_min_i': unit['t_off_min_i'],\n            's_i': unit['s_i'],\n            't_i_0': unit['t_i_0'],\n            'u_i': 0,\n            'p_i': 0\n        })\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    for s in state:\n        if s['u_i_0'] == 1:\n            if s['t_i_0'] < s['t_on_min_i'] or s['p_i_0'] > s['p_shut_i']:\n                must_on.append(s)\n            else:\n                free_on.append(s)\n        else:\n            if -s['t_i_0'] < s['t_off_min_i']:\n                must_off.append(s)\n            else:\n                free_off.append(s)\n    \n    # Compute must-run capacity\n    total_min_must = 0\n    total_max_must = 0\n    for s in must_on:\n        if s['u_i_0'] == 1:\n            lb = max(s['p_min_i'], s['p_i_0'] - s['p_down_i'])\n            ub = min(s['p_max_i'], s['p_i_0'] + s['p_up_i'])\n        else:\n            lb = s['p_min_i']\n            ub = min(s['p_max_i'], s['p_start_i'])\n        total_min_must += lb\n        total_max_must += ub\n    \n    # Case 1: Load <= total_min_must\n    if current_load <= total_min_must:\n        for s in must_on:\n            s['u_i'] = 1\n            if s['u_i_0'] == 1:\n                s['p_i'] = max(s['p_min_i'], s['p_i_0'] - s['p_down_i'])\n            else:\n                s['p_i'] = s['p_min_i']\n        committed_set = must_on\n    \n    # Case 2: Load within must-run capacity\n    elif current_load <= total_max_must:\n        for s in must_on:\n            s['u_i'] = 1\n        committed_set = must_on\n    \n    # Case 3: Load > must-run capacity\n    else:\n        base_set = must_on + free_on\n        total_min_base = total_min_must\n        total_max_base = total_max_must\n        for s in free_on:\n            if s['u_i_0'] == 1:\n                lb = max(s['p_min_i'], s['p_i_0'] - s['p_down_i'])\n                ub = min(s['p_max_i'], s['p_i_0'] + s['p_up_i'])\n            else:\n                lb = s['p_min_i']\n                ub = min(s['p_max_i'], s['p_start_i'])\n            total_min_base += lb\n            total_max_base += ub\n        \n        if current_load <= total_max_base:\n            committed_set = base_set\n            for s in base_set:\n                s['u_i'] = 1\n        else:\n            candidate_units = free_off.copy()\n            candidate_units.sort(key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'])\n            committed_set = base_set.copy()\n            for s in base_set:\n                s['u_i'] = 1\n            total_min = total_min_base\n            total_max = total_max_base\n            for u in candidate_units:\n                u_min = u['p_min_i']\n                u_max = min(u['p_max_i'], u['p_start_i'])\n                total_min += u_min\n                total_max += u_max\n                u['u_i'] = 1\n                committed_set.append(u)\n                if total_max >= current_load:\n                    break\n    \n    # Economic dispatch\n    lb_list = []\n    ub_list = []\n    b_list = []\n    c_list = []\n    committed_units = []\n    for s in committed_set:\n        s['u_i'] = 1\n        if s['u_i_0'] == 1:\n            lb = max(s['p_min_i'], s['p_i_0'] - s['p_down_i'])\n            ub = min(s['p_max_i'], s['p_i_0'] + s['p_up_i'])\n        else:\n            lb = s['p_min_i']\n            ub = min(s['p_max_i'], s['p_start_i'])\n        lb_list.append(lb)\n        ub_list.append(ub)\n        b_list.append(s['b_i'])\n        c_list.append(s['c_i'])\n        committed_units.append(s)\n    \n    total_min_committed = sum(lb_list)\n    total_max_committed = sum(ub_list)\n    \n    if current_load <= total_min_committed:\n        for i, s in enumerate(committed_units):\n            s['p_i'] = lb_list[i]\n    elif current_load >= total_max_committed:\n        for i, s in enumerate(committed_units):\n            s['p_i'] = ub_list[i]\n    else:\n        p_i_list = [(lb + ub) / 2 for lb, ub in zip(lb_list, ub_list)]\n        total_p = sum(p_i_list)\n        tol = 1e-5\n        max_iter = 1000\n        iter_count = 0\n        \n        # Find lambda bounds\n        inc_costs = []\n        for i in range(len(committed_units)):\n            if c_list[i] > 0:\n                inc_costs.append(b_list[i] + 2 * c_list[i] * lb_list[i])\n                inc_costs.append(b_list[i] + 2 * c_list[i] * ub_list[i])\n            else:\n                inc_costs.append(b_list[i])\n        lambda_low = min(inc_costs)\n        lambda_high = max(inc_costs)\n        \n        # Lambda iteration\n        while abs(total_p - current_load) > tol and iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i in range(len(committed_units)):\n                if c_list[i] > 0:\n                    p_i = (lambda_mid - b_list[i]) / (2 * c_list[i])\n                    p_i = max(lb_list[i], min(ub_list[i], p_i))\n                else:\n                    if lambda_mid < b_list[i]:\n                        p_i = lb_list[i]\n                    elif lambda_mid > b_list[i]:\n                        p_i = ub_list[i]\n                    else:\n                        p_i = lb_list[i]\n                p_i_list[i] = p_i\n                total_p += p_i\n            \n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            iter_count += 1\n        \n        # Adjust for any remaining imbalance\n        diff = current_load - total_p\n        if abs(diff) > tol:\n            flexible_indices = []\n            for i in range(len(committed_units)):\n                if lb_list[i] < p_i_list[i] < ub_list[i]:\n                    flexible_indices.append(i)\n            \n            if flexible_indices:\n                if diff > 0:\n                    inc_costs = [b_list[i] + 2*c_list[i]*p_i_list[i] for i in flexible_indices]\n                    sorted_indices = [i for _, i in sorted(zip(inc_costs, flexible_indices))]\n                    for i in sorted_indices:\n                        if diff <= 0:\n                            break\n                        margin = ub_list[i] - p_i_list[i]\n                        if margin > 0:\n                            add = min(margin, diff)\n                            p_i_list[i] += add\n                            diff -= add\n                else:\n                    inc_costs = [b_list[i] + 2*c_list[i]*p_i_list[i] for i in flexible_indices]\n                    sorted_indices = [i for _, i in sorted(zip(inc_costs, flexible_indices), reverse=True)]\n                    for i in sorted_indices:\n                        if diff >= 0:\n                            break\n                        margin = p_i_list[i] - lb_list[i]\n                        if margin > 0:\n                            sub = min(margin, -diff)\n                            p_i_list[i] -= sub\n                            diff += sub\n        \n        for i, s in enumerate(committed_units):\n            s['p_i'] = p_i_list[i]\n    \n    # Refinement: remove expensive free-on unit if feasible\n    free_on_committed = [s for s in committed_set if s in free_on and s['u_i'] == 1]\n    if free_on_committed:\n        free_on_committed.sort(\n            key=lambda u: (u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'],\n            reverse=True\n        )\n        for unit in free_on_committed:\n            temp_committed = [s for s in committed_set if s != unit]\n            total_min_temp = 0\n            total_max_temp = 0\n            for s in temp_committed:\n                if s['u_i_0'] == 1:\n                    lb = max(s['p_min_i'], s['p_i_0'] - s['p_down_i'])\n                    ub = min(s['p_max_i'], s['p_i_0'] + s['p_up_i'])\n                else:\n                    lb = s['p_min_i']\n                    ub = min(s['p_max_i'], s['p_start_i'])\n                total_min_temp += lb\n                total_max_temp += ub\n            if total_min_temp <= current_load <= total_max_temp:\n                unit['u_i'] = 0\n                unit['p_i'] = 0\n                committed_set = temp_committed\n                # Re-dispatch after removal\n                lb_list = []\n                ub_list = []\n                b_list = []\n                c_list = []\n                committed_units = []\n                for s in committed_set:\n                    if s['u_i'] == 1:\n                        if s['u_i_0'] == 1:\n                            lb = max(s['p_min_i'], s['p_i_0'] - s['p_down_i'])\n                            ub = min(s['p_max_i'], s['p_i_0'] + s['p_up_i'])\n                        else:\n                            lb = s['p_min_i']\n                            ub = min(s['p_max_i'], s['p_start_i'])\n                        lb_list.append(lb)\n                        ub_list.append(ub)\n                        b_list.append(s['b_i'])\n                        c_list.append(s['c_i'])\n                        committed_units.append(s)\n                \n                total_min_committed = sum(lb_list)\n                total_max_committed = sum(ub_list)\n                if current_load <= total_min_committed:\n                    for i, s in enumerate(committed_units):\n                        s['p_i'] = lb_list[i]\n                elif current_load >= total_max_committed:\n                    for i, s in enumerate(committed_units):\n                        s['p_i'] = ub_list[i]\n                else:\n                    p_i_list = [(lb + ub) / 2 for lb, ub in zip(lb_list, ub_list)]\n                    total_p = sum(p_i_list)\n                    tol = 1e-5\n                    max_iter = 1000\n                    iter_count = 0\n                    inc_costs = []\n                    for i in range(len(committed_units)):\n                        if c_list[i] > 0:\n                            inc_costs.append(b_list[i] + 2 * c_list[i] * lb_list[i])\n                            inc_costs.append(b_list[i] + 2 * c_list[i] * ub_list[i])\n                        else:\n                            inc_costs.append(b_list[i])\n                    lambda_low = min(inc_costs)\n                    lambda_high = max(inc_costs)\n                    while abs(total_p - current_load) > tol and iter_count < max_iter:\n                        lambda_mid = (lambda_low + lambda_high) / 2\n                        total_p = 0\n                        for i in range(len(committed_units)):\n                            if c_list[i] > 0:\n                                p_i = (lambda_mid - b_list[i]) / (2 * c_list[i])\n                                p_i = max(lb_list[i], min(ub_list[i], p_i))\n                            else:\n                                if lambda_mid < b_list[i]:\n                                    p_i = lb_list[i]\n                                elif lambda_mid > b_list[i]:\n                                    p_i = ub_list[i]\n                                else:\n                                    p_i = lb_list[i]\n                            p_i_list[i] = p_i\n                            total_p += p_i\n                        if total_p < current_load:\n                            lambda_low = lambda_mid\n                        else:\n                            lambda_high = lambda_mid\n                        iter_count += 1\n                    diff = current_load - total_p\n                    if abs(diff) > tol:\n                        flexible_indices = []\n                        for i in range(len(committed_units)):\n                            if lb_list[i] < p_i_list[i] < ub_list[i]:\n                                flexible_indices.append(i)\n                        if flexible_indices:\n                            if diff > 0:\n                                inc_costs = [b_list[i] + 2*c_list[i]*p_i_list[i] for i in flexible_indices]\n                                sorted_indices = [i for _, i in sorted(zip(inc_costs, flexible_indices))]\n                                for i in sorted_indices:\n                                    if diff <= 0:\n                                        break\n                                    margin = ub_list[i] - p_i_list[i]\n                                    if margin > 0:\n                                        add = min(margin, diff)\n                                        p_i_list[i] += add\n                                        diff -= add\n                            else:\n                                inc_costs = [b_list[i] + 2*c_list[i]*p_i_list[i] for i in flexible_indices]\n                                sorted_indices = [i for _, i in sorted(zip(inc_costs, flexible_indices), reverse=True)]\n                                for i in sorted_indices:\n                                    if diff >= 0:\n                                        break\n                                    margin = p_i_list[i] - lb_list[i]\n                                    if margin > 0:\n                                        sub = min(margin, -diff)\n                                        p_i_list[i] -= sub\n                                        diff += sub\n                    for i, s in enumerate(committed_units):\n                        s['p_i'] = p_i_list[i]\n                break\n    \n    # Prepare output\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    for s in state:\n        idx = s['idx']\n        u_out[idx] = s['u_i']\n        p_out[idx] = s['p_i']\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00464,
          "gap_price_rate": 0.01734,
          "fitness": 0.01099
     },
     {
          "name": "hybrid_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-on (online units not meeting min up-time or shutdown capacity) and must-off (offline units within min down-time). 2. If load <= total min of must-on units, set must-on units to min output. 3. Else if load <= total max of must-on units, dispatch must-on units economically. 4. Else consider base units (all previously online units). If load within base capacity, dispatch base units. 5. Else add free-off units sorted by adjusted cost/MW until total capacity meets load. 6. If total min > load, remove expensive non-must-on units while maintaining capacity. 7. Perform economic dispatch on final committed set using lambda iteration.\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    # Classify must-on and must-off units\n    must_on = [False] * n\n    must_off = [False] * n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off[i] = True\n                \n    # Helper functions for min/max output\n    def get_min_output(unit):\n        if unit['u_i_0'] == 1:\n            return max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        return unit['p_min_i']\n    \n    def get_max_output(unit):\n        if unit['u_i_0'] == 1:\n            return min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 1: Check must-on units\n    must_on_indices = [i for i in range(n) if must_on[i]]\n    total_min_must = sum(get_min_output(units_info[i]) for i in must_on_indices)\n    total_max_must = sum(get_max_output(units_info[i]) for i in must_on_indices)\n    \n    if current_load <= total_min_must:\n        u = [0] * n\n        p = [0.0] * n\n        for i in must_on_indices:\n            u[i] = 1\n            p[i] = get_min_output(units_info[i])\n        return np.array([u, p])\n    \n    elif current_load <= total_max_must:\n        bounds = {}\n        for i in must_on_indices:\n            lb = get_min_output(units_info[i])\n            ub = get_max_output(units_info[i])\n            bounds[i] = (lb, ub)\n        p_values = economic_dispatch(units_info, must_on_indices, bounds, current_load)\n        u = [0] * n\n        p = [0.0] * n\n        for idx, unit_idx in enumerate(must_on_indices):\n            u[unit_idx] = 1\n            p[unit_idx] = p_values[idx]\n        return np.array([u, p])\n    \n    # Step 2: Check base units (previously online)\n    base_units = [i for i in range(n) if units_info[i]['u_i_0'] == 1]\n    total_min_base = 0\n    total_max_base = 0\n    base_bounds = {}\n    for i in base_units:\n        lb = get_min_output(units_info[i])\n        ub = get_max_output(units_info[i])\n        base_bounds[i] = (lb, ub)\n        total_min_base += lb\n        total_max_base += ub\n        \n    if current_load <= total_max_base:\n        p_values = economic_dispatch(units_info, base_units, base_bounds, current_load)\n        u = [0] * n\n        p = [0.0] * n\n        for idx, unit_idx in enumerate(base_units):\n            u[unit_idx] = 1\n            p[unit_idx] = p_values[idx]\n        return np.array([u, p])\n    \n    # Step 3: Add free-off units\n    free_off_units = [i for i in range(n) if not must_on[i] and not must_off[i] and units_info[i]['u_i_0'] == 0]\n    adjusted_costs = []\n    for i in free_off_units:\n        unit = units_info[i]\n        p_min = get_min_output(unit)\n        cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        adjusted_costs.append((i, cost_per_mw))\n    adjusted_costs.sort(key=lambda x: x[1])\n    \n    candidate_indices = base_units.copy()\n    total_min_candidate = total_min_base\n    total_max_candidate = total_max_base\n    for i, cost in adjusted_costs:\n        min_i = get_min_output(units_info[i])\n        max_i = get_max_output(units_info[i])\n        total_min_candidate += min_i\n        total_max_candidate += max_i\n        candidate_indices.append(i)\n        if total_max_candidate >= current_load:\n            break\n            \n    # Step 4: Remove expensive units if overcommitted\n    if total_min_candidate > current_load:\n        non_must_on = [i for i in candidate_indices if not must_on[i]]\n        marginal_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            min_i = get_min_output(unit)\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_i\n            marginal_costs.append((i, marginal_cost))\n        marginal_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, mc in marginal_costs:\n            min_i = get_min_output(units_info[i])\n            max_i = get_max_output(units_info[i])\n            new_min = total_min_candidate - min_i\n            new_max = total_max_candidate - max_i\n            if new_min <= current_load and new_max >= current_load:\n                candidate_indices.remove(i)\n                total_min_candidate = new_min\n                total_max_candidate = new_max\n            if total_min_candidate <= current_load:\n                break\n                \n    # Step 5: Dispatch candidate units\n    candidate_bounds = {}\n    for i in candidate_indices:\n        lb = get_min_output(units_info[i])\n        ub = get_max_output(units_info[i])\n        candidate_bounds[i] = (lb, ub)\n    p_values = economic_dispatch(units_info, candidate_indices, candidate_bounds, current_load)\n    \n    u = [0] * n\n    p = [0.0] * n\n    for idx, unit_idx in enumerate(candidate_indices):\n        u[unit_idx] = 1\n        p[unit_idx] = p_values[idx]\n    return np.array([u, p])\n\ndef economic_dispatch(units_info, indices, bounds, load, tolerance=1e-3, max_iter=100):\n    if not indices:\n        return []\n    lambda_min = min(2 * units_info[i]['c_i'] * bounds[i][0] + units_info[i]['b_i'] for i in indices)\n    lambda_max = max(2 * units_info[i]['c_i'] * bounds[i][1] + units_info[i]['b_i'] for i in indices)\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_min + lambda_max) / 2.0\n        total_p = 0.0\n        p_list = []\n        for i in indices:\n            unit = units_info[i]\n            p_desired = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_clamped = max(bounds[i][0], min(bounds[i][1], p_desired))\n            p_list.append(p_clamped)\n            total_p += p_clamped\n            \n        if abs(total_p - load) < tolerance:\n            return p_list\n        if total_p < load:\n            lambda_min = lambda_mid\n        else:\n            lambda_max = lambda_mid\n    return p_list",
          "from": "crossover",
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01739,
          "fitness": 0.011
     }
]