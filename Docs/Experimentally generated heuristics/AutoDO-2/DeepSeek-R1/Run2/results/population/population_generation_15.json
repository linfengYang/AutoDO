[
     {
          "name": "refined_rolling_commitment_v8",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity while considering next period's forecasted load and dynamically updating constraints. 7. Perform economic dispatch using incremental cost method with ramp constraints.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v8(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    forecasted_load_next = load[1]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i] if min_out[i] > 0 else float('inf'), i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p if min_p > 0 else float('inf'), i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i] if min_out[i] > 0 else float('inf'), i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            remaining_max = total_max - max_out[i]\n            if remaining_max >= forecasted_load_next:\n                candidate_decommit.append(i)\n                \n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i] if min_out[i] > 0 else float('inf'), i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load) and (total_max - max_out[i] >= forecasted_load_next):\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00129,
          "gap_price_rate": 0.01095,
          "fitness": 0.00612
     },
     {
          "name": "refined_rolling_commitment_v6",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity while considering next period's forecasted load. 7. Perform economic dispatch using incremental cost method with ramp constraints.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v6(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    forecasted_load_next = load[1]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            remaining_max = total_max - max_out[i]\n            if remaining_max >= forecasted_load_next:\n                candidate_decommit.append(i)\n                \n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules\n",
          "from": "mutation",
          "gap_power_rate": 0.00319,
          "gap_price_rate": 0.01059,
          "fitness": 0.00689
     },
     {
          "name": "hybrid_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds current load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below current load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit non-essential non-must-on units with excess capacity considering next period's forecasted load using incremental cost. 7. Perform economic dispatch using incremental cost method with ramp constraints.\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u_i = [0] * n_units\n    p_i = [0] * n_units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    def calculate_min_output(i):\n        unit = units_info[i]\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                return max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                return unit['p_min_i']\n        return 0\n    \n    def calculate_max_output(i):\n        unit = units_info[i]\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                return min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                return min(unit['p_max_i'], unit['p_start_i'])\n        return 0\n    \n    total_min = sum(calculate_min_output(i) for i in range(n_units))\n    free_on_indices = [i for i in range(n_units) if u_i[i] == 1 and not must_on[i] and units_info[i]['u_i_0'] == 1]\n    free_on_indices.sort(key=lambda i: 2 * units_info[i]['c_i'] * calculate_min_output(i) + units_info[i]['b_i'], reverse=True)\n    \n    for i in free_on_indices:\n        if total_min > current_load:\n            min_i = calculate_min_output(i)\n            total_min -= min_i\n            u_i[i] = 0\n        else:\n            break\n    \n    total_max = sum(calculate_max_output(i) for i in range(n_units))\n    free_off_indices = [i for i in range(n_units) if u_i[i] == 0 and not must_off[i] and units_info[i]['u_i_0'] == 0]\n    free_off_indices.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_max_i'] + \n                                        units_info[i]['c_i'] * (units_info[i]['p_max_i'] ** 2) + \n                                        units_info[i]['s_i']) / units_info[i]['p_max_i'] if units_info[i]['p_max_i'] > 0 else float('inf'))\n    \n    for i in free_off_indices:\n        if total_max < current_load:\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_max += max_i\n            u_i[i] = 1\n        else:\n            break\n    \n    total_min = sum(calculate_min_output(i) for i in range(n_units) if u_i[i] == 1)\n    non_must_on_indices = [i for i in range(n_units) if u_i[i] == 1 and not must_on[i]]\n    non_must_on_indices.sort(key=lambda i: 2 * units_info[i]['c_i'] * calculate_min_output(i) + units_info[i]['b_i'], reverse=True)\n    \n    for i in non_must_on_indices:\n        if total_min > current_load:\n            min_i = calculate_min_output(i)\n            total_min -= min_i\n            u_i[i] = 0\n        else:\n            break\n    \n    max_outputs = [calculate_max_output(i) for i in range(n_units)]\n    total_max = sum(max_outputs)\n    non_must_on_indices = [i for i in range(n_units) if u_i[i] == 1 and not must_on[i]]\n    non_must_on_indices.sort(key=lambda i: 2 * units_info[i]['c_i'] * max_outputs[i] + units_info[i]['b_i'], reverse=True)\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in non_must_on_indices:\n            if u_i[i] == 1:\n                candidate_total_max = total_max - max_outputs[i]\n                if candidate_total_max >= current_load and candidate_total_max >= next_load:\n                    u_i[i] = 0\n                    total_max = candidate_total_max\n                    changed = True\n                    break\n    \n    lb = [0] * n_units\n    ub = [0] * n_units\n    for i in range(n_units):\n        if u_i[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                lb[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                ub[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                lb[i] = units_info[i]['p_min_i']\n                ub[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            lb[i] = 0\n            ub[i] = 0\n    \n    for i in range(n_units):\n        p_i[i] = lb[i] if u_i[i] == 1 else 0\n    \n    total_output = sum(p_i)\n    remaining = current_load - total_output\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    \n    while remaining > 1e-6 and committed_indices:\n        min_ic = float('inf')\n        candidate_index = None\n        for i in committed_indices:\n            if p_i[i] < ub[i]:\n                ic = 2 * units_info[i]['c_i'] * p_i[i] + units_info[i]['b_i']\n                if ic < min_ic:\n                    min_ic = ic\n                    candidate_index = i\n        if candidate_index is None:\n            break\n        delta = min(remaining, ub[candidate_index] - p_i[candidate_index])\n        p_i[candidate_index] += delta\n        remaining -= delta\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u_i[i]\n        schedules[1, i] = p_i[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0016,
          "gap_price_rate": 0.0128,
          "fitness": 0.0072
     },
     {
          "name": "refined_rolling_commitment_v7",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds current load while maintaining sufficient capacity. 4. Commit cheapest free-off units if total maximum output is below current load, tracking newly committed units. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity for current and forecasted loads, excluding newly committed units. 7. Perform economic dispatch using incremental cost method within ramp-constrained bounds.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v7(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    forecasted_load_next = load[1]\n    just_committed = set()\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n                just_committed.add(i)\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load) and i not in just_committed:\n            remaining_max = total_max - max_out[i]\n            if remaining_max >= forecasted_load_next:\n                candidate_decommit.append(i)\n                \n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00327,
          "gap_price_rate": 0.01156,
          "fitness": 0.00742
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform constrained economic dispatch using incremental cost method with ramp constraints.\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Step 2: Initialize commitment states\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    \n    for idx in must_on:\n        u_current[idx] = 1\n    for idx in free_on:\n        u_current[idx] = 1\n    for idx in must_off:\n        u_current[idx] = 0\n    for idx in free_off:\n        u_current[idx] = 0\n    \n    # Helper functions\n    def total_min_output():\n        total_min = 0\n        for idx in range(n_units):\n            if u_current[idx] == 1:\n                if units_info[idx]['u_i_0'] == 1:\n                    min_output = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n                else:\n                    min_output = units_info[idx]['p_min_i']\n                total_min += min_output\n        return total_min\n    \n    def total_max_output():\n        total_max = 0\n        for idx in range(n_units):\n            if u_current[idx] == 1:\n                if units_info[idx]['u_i_0'] == 1:\n                    max_output = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n                else:\n                    max_output = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                total_max += max_output\n        return total_max\n    \n    # Step 3: Decommit expensive free-on units if total_min > load\n    total_min = total_min_output()\n    if total_min > current_load:\n        free_on_sorted = sorted(free_on, \n                                key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                reverse=True)\n        for idx in free_on_sorted:\n            if total_min <= current_load:\n                break\n            u_current[idx] = 0\n            total_min = total_min_output()\n    \n    # Step 4: Commit cheapest free-off units if total_max < load\n    total_max = total_max_output()\n    if total_max < current_load:\n        free_off_sorted = sorted(free_off, \n                                 key=lambda idx: (units_info[idx]['a_i'] + units_info[idx]['b_i'] * units_info[idx]['p_max_i'] + \n                                                 units_info[idx]['c_i'] * (units_info[idx]['p_max_i']**2) + units_info[idx]['s_i']) / units_info[idx]['p_max_i'])\n        for idx in free_off_sorted:\n            u_current[idx] = 1\n            total_max = total_max_output()\n            if total_max >= current_load:\n                break\n    \n    # Step 5: Decommit expensive non-must-on if total_min still > load\n    non_must_on = free_on + free_off\n    committed_non_must_on = [idx for idx in non_must_on if u_current[idx] == 1]\n    total_min = total_min_output()\n    if total_min > current_load:\n        committed_non_must_on_sorted = sorted(committed_non_must_on, \n                                             key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                             reverse=True)\n        for idx in committed_non_must_on_sorted:\n            if total_min <= current_load:\n                break\n            u_current[idx] = 0\n            total_min = total_min_output()\n    \n    # Step 6: Decommit expensive non-must-on with excess capacity\n    committed_units = [idx for idx in range(n_units) if u_current[idx] == 1]\n    non_must_on_committed = [idx for idx in committed_units if idx in non_must_on]\n    non_must_on_committed_sorted = sorted(non_must_on_committed, \n                                         key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                         reverse=True)\n    for idx in non_must_on_committed_sorted:\n        u_current[idx] = 0\n        if total_max_output() < current_load or total_min_output() > current_load:\n            u_current[idx] = 1\n    \n    # Step 7: Economic dispatch for committed units\n    committed_idxs = [idx for idx in range(n_units) if u_current[idx] == 1]\n    \n    # Set bounds for each committed unit\n    lower_bounds = []\n    upper_bounds = []\n    for idx in committed_idxs:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Was online\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Starting up\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_lb = sum(lower_bounds)\n    total_ub = sum(upper_bounds)\n    \n    # Initialize outputs to lower bounds\n    p_alloc = [lb for lb in lower_bounds]\n    remaining = current_load - total_lb\n    \n    # Distribute remaining load\n    if remaining > 0:\n        # Active units are those not at upper bound\n        active_units = [i for i in range(len(committed_idxs)) if p_alloc[i] < upper_bounds[i]]\n        \n        while remaining > 0 and active_units:\n            # Find unit with smallest incremental cost\n            min_ic = float('inf')\n            candidate_idx = None\n            for i in active_units:\n                unit_idx = committed_idxs[i]\n                ic = 2 * units_info[unit_idx]['c_i'] * p_alloc[i] + units_info[unit_idx]['b_i']\n                if ic < min_ic:\n                    min_ic = ic\n                    candidate_idx = i\n            \n            if candidate_idx is None:\n                break\n                \n            # Calculate available capacity for candidate\n            available = upper_bounds[candidate_idx] - p_alloc[candidate_idx]\n            if available > 0:\n                add = min(available, remaining)\n                p_alloc[candidate_idx] += add\n                remaining -= add\n                # Check if unit reached upper bound\n                if p_alloc[candidate_idx] >= upper_bounds[candidate_idx] - 1e-5:\n                    active_units.remove(candidate_idx)\n    \n    # Map allocations back to units\n    for i, idx in enumerate(committed_idxs):\n        p_current[idx] = p_alloc[i]\n    \n    # Create output array\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u_current[i]\n        schedules[1, i] = p_current[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00407,
          "gap_price_rate": 0.01134,
          "fitness": 0.0077
     },
     {
          "name": "refined_rolling_commitment_v6",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units using incremental cost at minimum output if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v6(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        incremental_costs = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            inc_cost = 2 * unit['c_i'] * min_p + unit['b_i']\n            incremental_costs.append((inc_cost, i, min_p, max_p))\n        incremental_costs.sort(key=lambda x: x[0])\n        for inc_cost, i, min_p, max_p in incremental_costs:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    incremental_costs = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n        incremental_costs.append((inc_cost, i))\n    incremental_costs.sort(key=lambda x: x[0], reverse=True)\n    for inc_cost, i in incremental_costs:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00433,
          "gap_price_rate": 0.01142,
          "fitness": 0.00787
     },
     {
          "name": "refined_rolling_commitment_v5",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity without breaking loop on unmet conditions. 7. Perform economic dispatch using incremental cost method with improved numerical stability.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v5(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 1e-5:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i] - 1e-5]\n        while remaining > 1e-5 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01172,
          "fitness": 0.00806
     },
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        avg_costs = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw = total_cost / min_p\n            avg_costs.append((cost_per_mw, i, min_p, max_p))\n        avg_costs.sort(key=lambda x: x[0])\n        for cost_per_mw, i, min_p, max_p in avg_costs:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    incremental_costs = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n        incremental_costs.append((inc_cost, i))\n    incremental_costs.sort(key=lambda x: x[0], reverse=True)\n    for inc_cost, i in incremental_costs:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01179,
          "fitness": 0.0081
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01183,
          "fitness": 0.00812
     },
     {
          "name": "refined_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v4(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            continue\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01189,
          "fitness": 0.00815
     }
]