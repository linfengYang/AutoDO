[
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "dynamic_rolling_commitment_enhanced",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on). 2. Start with must-on and free-on units committed. 3. If initial dispatch fails due to insufficient capacity, activate free-off units by prioritizing lowest (startup cost + marginal cost at min output)/min output. 4. If minimum generation exceeds load, deactivate free-on units by prioritizing highest (production cost at min output)/min output while ensuring feasibility. 5. Perform economic dispatch using lambda iteration respecting ramp limits and output constraints. 6. Refine commitment by deactivating non-essential free-on units based on cost savings and feasibility.\n",
          "code": "import numpy as np\n\ndef dynamic_rolling_commitment_enhanced(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed_set = set()\n    \n    current_load = load[0]\n    \n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_on.append(i)\n                committed_set.add(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                free_off.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p[i] for i in committed_set)\n    total_max = sum(max_p[i] for i in committed_set)\n    \n    if current_load > total_max:\n        candidate_free_off = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost_at_min = s_i + a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_off.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_off.sort(key=lambda x: x[3])\n        \n        for cand in candidate_free_off:\n            i, min_val, max_val, _ = cand\n            new_total_min = total_min + min_val\n            new_total_max = total_max + max_val\n            committed_set.add(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= current_load:\n                break\n                \n    elif current_load < total_min:\n        candidate_free_on = []\n        for i in free_on:\n            if i not in committed_set:\n                continue\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_on.append((i, min_p_i_val, max_p_i_val, priority))\n        \n        candidate_free_on.sort(key=lambda x: x[3], reverse=True)\n        \n        for cand in candidate_free_on:\n            i, min_val, max_val, _ = cand\n            new_total_min = total_min - min_val\n            new_total_max = total_max - max_val\n            if new_total_min <= current_load <= new_total_max:\n                committed_set.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n            if total_min <= current_load:\n                break\n    \n    candidate_free_on_refine = []\n    for i in free_on:\n        if i in committed_set:\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            min_p_i_val = min_p[i]\n            max_p_i_val = max_p[i]\n            cost_at_min = a_i + b_i * min_p_i_val + c_i * min_p_i_val**2\n            priority = cost_at_min / min_p_i_val\n            candidate_free_on_refine.append((i, min_p_i_val, max_p_i_val, priority))\n    \n    candidate_free_on_refine.sort(key=lambda x: x[3], reverse=True)\n    \n    for cand in candidate_free_on_refine:\n        i, min_val, max_val, _ = cand\n        new_total_min = total_min - min_val\n        new_total_max = total_max - max_val\n        if new_total_min <= current_load <= new_total_max:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if len(committed_set) > 0:\n        indices_committed = sorted(committed_set)\n        min_p_list = [min_p[i] for i in indices_committed]\n        max_p_list = [max_p[i] for i in indices_committed]\n        b_list = [units_info[i]['b_i'] for i in indices_committed]\n        c_list = [units_info[i]['c_i'] for i in indices_committed]\n        \n        low = min(b_i + 2 * c_i * min_p_i for b_i, c_i, min_p_i in zip(b_list, c_list, min_p_list))\n        high = max(b_i + 2 * c_i * max_p_i for b_i, c_i, max_p_i in zip(b_list, c_list, max_p_list))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2.0\n            total_p = 0.0\n            for i in range(len(indices_committed)):\n                p_val = (mid - b_list[i]) / (2 * c_list[i])\n                if p_val < min_p_list[i]:\n                    p_val = min_p_list[i]\n                elif p_val > max_p_list[i]:\n                    p_val = max_p_list[i]\n                total_p += p_val\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        mid = (low + high) / 2.0\n        p_committed = []\n        for i in range(len(indices_committed)):\n            p_val = (mid - b_list[i]) / (2 * c_list[i])\n            if p_val < min_p_list[i]:\n                p_val = min_p_list[i]\n            elif p_val > max_p_list[i]:\n                p_val = max_p_list[i]\n            p_committed.append(p_val)\n        \n        for idx, p_val in zip(indices_committed, p_committed):\n            p_out[idx] = p_val\n            u_out[idx] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01741,
          "fitness": 0.01101
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-on units (units that must remain on due to minimum up-time or shutdown constraints) and must-off units (units that must remain off due to minimum down-time constraints).\n2. Group remaining units into group1 (units that were on) and group2 (units that were off).\n3. Start with must-on and group1 units committed. Compute effective minimum and maximum outputs considering ramp constraints.\n4. If total effective minimum output exceeds load, decommit the most expensive group1 units (not must-on) until the total effective minimum is <= load and total effective maximum >= load.\n5. If total effective maximum output is below load, commit additional group2 units in ascending order of cost per MW at minimum output until total effective maximum >= load.\n6. Perform economic dispatch: set committed units to their effective minimum outputs, then distribute remaining load to units with the smallest incremental cost, respecting maximum output constraints.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    load_current = load[0]\n    n_units = len(units_info)\n    \n    must_on = []\n    must_off = []\n    group1 = []\n    group2 = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n        else:\n            if t_i0 > -t_off_min:\n                must_off.append(i)\n                \n    for i in range(n_units):\n        if i in must_on or i in must_off:\n            continue\n        if units_info[i]['u_i_0'] == 1:\n            group1.append(i)\n        else:\n            group2.append(i)\n            \n    committed_indices = must_on + group1\n    \n    def compute_bounds(indices):\n        total_min = 0.0\n        total_max = 0.0\n        for i in indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low = unit['p_min_i']\n                high = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low\n            total_max += high\n        return total_min, total_max\n        \n    total_min, total_max = compute_bounds(committed_indices)\n    \n    if total_min > load_current:\n        decommit_candidates = [i for i in group1 if i not in must_on]\n        candidate_list = []\n        for i in decommit_candidates:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_i = unit['p_min_i']\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * low_i\n            candidate_list.append((inc_cost, i))\n        candidate_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for inc, i in candidate_list:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_i = unit['p_min_i']\n                high_i = min(unit['p_max_i'], unit['p_start_i'])\n            new_total_min = total_min - low_i\n            new_total_max = total_max - high_i\n            if new_total_min <= load_current and new_total_max >= load_current:\n                committed_indices.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n            if total_min <= load_current:\n                break\n                \n    if total_max < load_current:\n        candidate_list = []\n        for i in group2:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost_at_min = a_i + b_i * p_min + c_i * p_min**2\n            cost_per_mw = (s_i + cost_at_min) / p_min\n            candidate_list.append((cost_per_mw, i))\n        candidate_list.sort(key=lambda x: x[0])\n        \n        for cost_per_mw, i in candidate_list:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            effective_max = min(unit['p_max_i'], unit['p_start_i'])\n            new_total_min = total_min + p_min\n            new_total_max = total_max + effective_max\n            committed_indices.append(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= load_current:\n                break\n                \n    low_bounds = {}\n    high_bounds = {}\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_b = unit['p_min_i']\n            high_b = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds[i] = low_b\n        high_bounds[i] = high_b\n        \n    p_vals = [0.0] * n_units\n    for i in committed_indices:\n        p_vals[i] = low_bounds[i]\n        \n    total_p = sum(p_vals[i] for i in committed_indices)\n    remaining = load_current - total_p\n    \n    while remaining > 0:\n        min_inc = float('inf')\n        candidate = None\n        for i in committed_indices:\n            if p_vals[i] < high_bounds[i]:\n                inc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_vals[i]\n                if inc < min_inc:\n                    min_inc = inc\n                    candidate = i\n        if candidate is None:\n            break\n        available = high_bounds[candidate] - p_vals[candidate]\n        if available > remaining:\n            p_vals[candidate] += remaining\n            remaining = 0\n        else:\n            p_vals[candidate] += available\n            remaining -= available\n            \n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    for i in range(n_units):\n        if i in committed_indices:\n            u_schedule[i] = 1\n            p_schedule[i] = p_vals[i]\n        else:\n            u_schedule[i] = 0\n            p_schedule[i] = 0.0\n            \n    schedules = np.array([u_schedule, p_schedule])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00023,
          "gap_price_rate": 0.04855,
          "fitness": 0.02439
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "The heuristic classifies units into must-on, must-off, free-on, and free-off based on their previous state and constraints. Must-on units are set to their minimum output considering ramp-down limits. Free-on units are initially set to their minimum output. If total output exceeds load, free-on units are turned off in descending order of output to minimize overproduction. If total output is below load, on units are increased in merit order of marginal cost. If a deficit remains, free-off units are turned on in ascending order of average cost per MW at minimum output, set to the minimum output plus any remaining deficit within limits.\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    \n    must_on_indices = []\n    must_off_indices = []\n    free_on_indices = []\n    free_off_indices = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_on_indices.append(idx)\n        elif unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            must_off_indices.append(idx)\n        else:\n            if unit['u_i_0'] == 1:\n                free_on_indices.append(idx)\n            else:\n                free_off_indices.append(idx)\n    \n    for idx in must_on_indices:\n        unit = units_info[idx]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        u[idx] = 1\n        p[idx] = min_output\n        unit['min_output'] = min_output\n        unit['max_output'] = max_output\n    \n    for idx in free_on_indices:\n        unit = units_info[idx]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        u[idx] = 1\n        p[idx] = min_output\n        unit['min_output'] = min_output\n        unit['max_output'] = max_output\n    \n    for idx in must_off_indices + free_off_indices:\n        u[idx] = 0\n        p[idx] = 0\n    \n    total = sum(p)\n    \n    if total > current_load:\n        candidate_indices = free_on_indices.copy()\n        candidate_indices.sort(key=lambda idx: p[idx], reverse=True)\n        new_total = total\n        for idx in candidate_indices:\n            candidate_total = new_total - p[idx]\n            if candidate_total >= current_load:\n                u[idx] = 0\n                p[idx] = 0\n                new_total = candidate_total\n            else:\n                gap1 = new_total - current_load\n                gap2 = current_load - candidate_total\n                if gap2 < gap1:\n                    u[idx] = 0\n                    p[idx] = 0\n                    new_total = candidate_total\n                break\n        total = new_total\n    \n    if total < current_load:\n        deficit = current_load - total\n        on_indices = [idx for idx in must_on_indices + free_on_indices if u[idx] == 1]\n        on_indices_sorted = sorted(on_indices, key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx])\n        \n        for idx in on_indices_sorted:\n            if deficit <= 0:\n                break\n            unit = units_info[idx]\n            headroom = unit['max_output'] - p[idx]\n            if headroom > 0:\n                increase = min(headroom, deficit)\n                p[idx] += increase\n                deficit -= increase\n                total += increase\n        \n        if deficit > 0:\n            candidate_indices = free_off_indices.copy()\n            candidate_indices.sort(key=lambda idx: (units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n                                                   units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                                                   units_info[idx]['c_i'] * (units_info[idx]['p_min_i'] ** 2)) / \n                                                   units_info[idx]['p_min_i'] if units_info[idx]['p_min_i'] > 0 else float('inf'))\n            for idx in candidate_indices:\n                if deficit <= 0:\n                    break\n                unit = units_info[idx]\n                min_output = unit['p_min_i']\n                max_output = min(unit['p_max_i'], unit['p_start_i'])\n                output = min(min_output + deficit, max_output)\n                u[idx] = 1\n                p[idx] = output\n                total += output\n                deficit -= output\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00109,
          "gap_price_rate": 0.05225,
          "fitness": 0.02667
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (min up-time not satisfied or previous output exceeds shutdown ramp), must-off (min down-time not satisfied), free-on (online and can be turned off), and free-off (offline and can be turned on).\n2. Initialize commitment: must-on and free-on units are committed; must-off and free-off units are decommitted.\n3. Compute effective min/max outputs for each unit considering ramp constraints and startup/shutdown limits.\n4. If current load exceeds total max output, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until the total max output meets or exceeds the load.\n5. If after step 4 the total min output exceeds the load, turn off free-on units in priority order (highest cost saving per MW at min output) while ensuring the total max output remains at least the load.\n6. If the load is below total min output, turn off free-on units in priority order (as in step 5) until total min output is at most the load while maintaining sufficient max output.\n7. Perform economic dispatch using lambda iteration to allocate load optimally among committed units, respecting min/max constraints. If total max output is less than load, set outputs to maximum.\n8. Return commitment status and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    \n    # Initialize arrays for categories and effective limits\n    category = [''] * n\n    min_p_eff = [0.0] * n\n    max_p_eff = [0.0] * n\n    \n    # Step 1: Classify units and compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_p_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                category[i] = 'must_on'\n            else:\n                category[i] = 'free_on'\n        else:  # Previously offline\n            time_off = -unit['t_i_0']\n            if time_off < unit['t_off_min_i']:\n                category[i] = 'must_off'\n                min_p_eff[i] = 0.0\n                max_p_eff[i] = 0.0\n            else:\n                category[i] = 'free_off'\n                min_p_eff[i] = unit['p_min_i']\n                max_p_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize sets\n    must_on_indices = [i for i in range(n) if category[i] == 'must_on']\n    free_on_indices = [i for i in range(n) if category[i] == 'free_on']\n    must_off_indices = [i for i in range(n) if category[i] == 'must_off']\n    free_off_indices = [i for i in range(n) if category[i] == 'free_off']\n    \n    # Step 2: Initialize committed units\n    committed_set = set(must_on_indices) | set(free_on_indices)\n    total_min = sum(min_p_eff[i] for i in committed_set)\n    total_max = sum(max_p_eff[i] for i in committed_set)\n    \n    # Step 4: Handle insufficient capacity (load > total_max)\n    if current_load > total_max:\n        # Compute priorities for free-off units: (startup cost / min_p) + marginal cost at min_p\n        priorities = []\n        for i in free_off_indices:\n            min_p = min_p_eff[i]\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_p\n            priority = (units_info[i]['s_i'] / min_p) + marginal_cost\n            priorities.append((priority, i))\n        priorities.sort(key=lambda x: x[0])\n        \n        # Turn on free-off units in priority order\n        for _, i in priorities:\n            if total_max >= current_load:\n                break\n            committed_set.add(i)\n            total_min += min_p_eff[i]\n            total_max += max_p_eff[i]\n            free_off_indices.remove(i)\n    \n    # Steps 5-6: Handle over-commitment (load < total_min) or excess min capacity after step 4\n    if current_load < total_min or (current_load > total_max and total_min > current_load):\n        candidate_free_on = free_on_indices.copy()\n        while total_min > current_load and candidate_free_on:\n            # Compute cost saving per MW for free-on units\n            saving_per_MW = []\n            for i in candidate_free_on:\n                min_p = min_p_eff[i]\n                cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p + units_info[i]['c_i'] * (min_p ** 2)\n                saving_per_MW.append((cost_at_min / min_p, i))\n            saving_per_MW.sort(key=lambda x: x[0], reverse=True)\n            \n            found = False\n            for _, i in saving_per_MW:\n                new_total_max = total_max - max_p_eff[i]\n                if new_total_max >= current_load:\n                    committed_set.remove(i)\n                    total_min -= min_p_eff[i]\n                    total_max -= max_p_eff[i]\n                    candidate_free_on.remove(i)\n                    found = True\n                    break\n            if not found:\n                break\n    \n    # Step 7: Economic Dispatch\n    u_schedule = [0] * n\n    p_schedule = [0.0] * n\n    committed_indices = list(committed_set)\n    \n    if committed_indices:\n        # Prepare dispatch parameters for committed units\n        min_limits = [min_p_eff[i] for i in committed_indices]\n        max_limits = [max_p_eff[i] for i in committed_indices]\n        b_vals = [units_info[i]['b_i'] for i in committed_indices]\n        c_vals = [units_info[i]['c_i'] for i in committed_indices]\n        \n        # Determine total power to dispatch\n        P_total = min(current_load, total_max) if total_max < current_load else current_load\n        \n        # Lambda iteration for economic dispatch\n        lambda_low = min(b + 2 * c * min_p for b, c, min_p in zip(b_vals, c_vals, min_limits))\n        lambda_high = max(b + 2 * c * max_p for b, c, max_p in zip(b_vals, c_vals, max_limits))\n        tol = 1e-5\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter and abs(lambda_high - lambda_low) > tol:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0.0\n            for i in range(len(committed_indices)):\n                if c_vals[i] == 0:\n                    p_val = max_limits[i] if b_vals[i] < lambda_mid else min_limits[i]\n                else:\n                    p_uncon = (lambda_mid - b_vals[i]) / (2 * c_vals[i])\n                    p_val = max(min_limits[i], min(max_limits[i], p_uncon))\n                total_p += p_val\n            \n            if total_p < P_total:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            iter_count += 1\n        \n        # Final dispatch at converged lambda\n        lambda_final = (lambda_low + lambda_high) / 2\n        for idx, i in enumerate(committed_indices):\n            if c_vals[idx] == 0:\n                p_schedule[i] = max_limits[idx] if b_vals[idx] < lambda_final else min_limits[idx]\n            else:\n                p_uncon = (lambda_final - b_vals[idx]) / (2 * c_vals[idx])\n                p_schedule[i] = max(min_limits[idx], min(max_limits[idx], p_uncon))\n            u_schedule[i] = 1\n    \n    # Step 8: Format output\n    schedules = np.array([u_schedule, p_schedule])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.05886,
          "fitness": 0.02952
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on (units that must remain on due to min up-time or shutdown ramp constraints), must-off (units that must remain off due to min down-time constraints), free-on (free units currently on that can be turned off), and free-off (free units currently off that can be turned on).\n2. Start with must-on and free-on units committed. If current load is below their total minimum output, turn off eligible free-on units (previous output \u2264 shutdown ramp limit) in descending order of minimum output until total minimum \u2264 load or no eligible units remain.\n3. If current load exceeds total maximum output of committed units, turn on free-off units in ascending order of startup cost plus production cost at minimum output until total maximum \u2265 load or no units remain.\n4. Dispatch load to committed units by initializing outputs at feasible lower bounds, then adjusting using incremental costs (cheapest units increased first when below target, most expensive decreased first when above target) while respecting ramp and output limits.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on_indices = []\n    must_off_indices = []\n    free_on_indices = []\n    free_off_indices = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on_indices.append(idx)\n            else:\n                free_on_indices.append(idx)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off_indices.append(idx)\n            else:\n                free_off_indices.append(idx)\n    \n    on_indices = must_on_indices + free_on_indices\n    off_indices = must_off_indices + free_off_indices\n    \n    total_min = sum(units_info[i]['p_min_i'] for i in on_indices)\n    total_max = sum(units_info[i]['p_max_i'] for i in on_indices)\n    current_load = load[0]\n    \n    if current_load < total_min:\n        candidate_off = [idx for idx in free_on_indices if units_info[idx]['p_i_0'] <= units_info[idx]['p_shut_i']]\n        candidate_off.sort(key=lambda idx: units_info[idx]['p_min_i'], reverse=True)\n        for idx in candidate_off:\n            total_min -= units_info[idx]['p_min_i']\n            total_max -= units_info[idx]['p_max_i']\n            on_indices.remove(idx)\n            off_indices.append(idx)\n            if total_min <= current_load:\n                break\n                \n    if current_load > total_max:\n        candidate_on = []\n        for idx in free_off_indices:\n            unit = units_info[idx]\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            candidate_on.append((idx, cost))\n        candidate_on.sort(key=lambda x: x[1])\n        for idx, _ in candidate_on:\n            total_min += units_info[idx]['p_min_i']\n            total_max += units_info[idx]['p_max_i']\n            on_indices.append(idx)\n            off_indices.remove(idx)\n            if total_max >= current_load:\n                break\n                \n    target = min(max(total_min, current_load), total_max)\n    p = [0.0] * n_units\n    u = [0] * n_units\n    for idx in on_indices:\n        u[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        p[idx] = low_bound\n        \n    total_p = sum(p)\n    \n    if total_p < target:\n        inc_units = []\n        for idx in on_indices:\n            unit = units_info[idx]\n            current_p = p[idx]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < high_bound:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                inc_units.append((idx, current_p, high_bound, inc_cost))\n        inc_units.sort(key=lambda x: x[3])\n        remaining = target - total_p\n        while remaining > 1e-5 and inc_units:\n            idx, current_p, high_bound, inc_cost = inc_units.pop(0)\n            max_inc = high_bound - current_p\n            inc = min(max_inc, remaining)\n            p[idx] += inc\n            total_p += inc\n            remaining -= inc\n            new_p = current_p + inc\n            if new_p < high_bound:\n                new_inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * new_p\n                inserted = False\n                for i, (_, _, _, cost_val) in enumerate(inc_units):\n                    if new_inc_cost < cost_val:\n                        inc_units.insert(i, (idx, new_p, high_bound, new_inc_cost))\n                        inserted = True\n                        break\n                if not inserted:\n                    inc_units.append((idx, new_p, high_bound, new_inc_cost))\n                    \n    elif total_p > target:\n        dec_units = []\n        for idx in on_indices:\n            unit = units_info[idx]\n            current_p = p[idx]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            if current_p > low_bound:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                dec_units.append((idx, current_p, low_bound, inc_cost))\n        dec_units.sort(key=lambda x: x[3], reverse=True)\n        remaining = total_p - target\n        while remaining > 1e-5 and dec_units:\n            idx, current_p, low_bound, inc_cost = dec_units.pop(0)\n            max_dec = current_p - low_bound\n            dec = min(max_dec, remaining)\n            p[idx] -= dec\n            total_p -= dec\n            remaining -= dec\n            new_p = current_p - dec\n            if new_p > low_bound:\n                new_inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * new_p\n                inserted = False\n                for i, (_, _, _, cost_val) in enumerate(dec_units):\n                    if new_inc_cost > cost_val:\n                        dec_units.insert(i, (idx, new_p, low_bound, new_inc_cost))\n                        inserted = True\n                        break\n                if not inserted:\n                    dec_units.append((idx, new_p, low_bound, new_inc_cost))\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.02101,
          "gap_price_rate": 0.039,
          "fitness": 0.03
     },
     {
          "name": "commit_units_by_priority_and_ed",
          "algorithm": "1. Classify units into must-on (min up-time not satisfied), must-off (min down-time not satisfied), free-on (online and free to turn off), and free-off (offline and free to turn on).\n2. Initialize commitment states: must-on units and free-on units committed, must-off units and free-off units decommitted.\n3. Compute effective min/max outputs considering ramp constraints: \n   - Online units: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - Started units: [p_min, min(p_max, start_ramp)]\n4. While total min output > load, turn off free-on units with largest min output to reduce over-commitment.\n5. While total max output < load, turn on free-off units with lowest (startup cost + min output cost) to increase capacity.\n6. Perform economic dispatch using lambda iteration to allocate load optimally among committed units, respecting min/max constraints.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_and_ed(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    \n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    u_0 = [unit['u_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i in range(n):\n        if u_0[i] == 1:\n            if t_0[i] < t_on_min[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(t_0[i]) < t_off_min[i]:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    u = [0] * n\n    min_eff = [0.0] * n\n    max_eff = [0.0] * n\n    \n    for i in must_on:\n        u[i] = 1\n        min_eff[i] = max(p_min[i], p_0[i] - p_down[i])\n        max_eff[i] = min(p_max[i], p_0[i] + p_up[i])\n    \n    for i in free_on:\n        u[i] = 1\n        min_eff[i] = max(p_min[i], p_0[i] - p_down[i])\n        max_eff[i] = min(p_max[i], p_0[i] + p_up[i])\n    \n    for i in must_off:\n        u[i] = 0\n        min_eff[i] = 0.0\n        max_eff[i] = 0.0\n    \n    for i in free_off:\n        u[i] = 0\n        min_eff[i] = 0.0\n        max_eff[i] = 0.0\n    \n    total_min = sum(min_eff)\n    total_max = sum(max_eff)\n    \n    free_on_sorted = sorted(free_on, key=lambda i: min_eff[i], reverse=True)\n    while total_min > current_load and free_on_sorted:\n        i = free_on_sorted.pop(0)\n        u[i] = 0\n        total_min -= min_eff[i]\n        total_max -= max_eff[i]\n        min_eff[i] = 0.0\n        max_eff[i] = 0.0\n    \n    free_off_sorted = sorted(free_off, key=lambda i: s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2))\n    while total_max < current_load and free_off_sorted:\n        i = free_off_sorted.pop(0)\n        u[i] = 1\n        min_eff[i] = p_min[i]\n        max_eff[i] = min(p_max[i], p_start[i])\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    committed_indices = [i for i in range(n) if u[i] == 1]\n    if not committed_indices:\n        p = [0.0] * n\n        return np.array([u, p])\n    \n    a_comm = [a[i] for i in committed_indices]\n    b_comm = [b[i] for i in committed_indices]\n    c_comm = [c[i] for i in committed_indices]\n    min_comm = [min_eff[i] for i in committed_indices]\n    max_comm = [max_eff[i] for i in committed_indices]\n    \n    low = min(b_i + 2*c_i*min_i for (b_i, c_i, min_i) in zip(b_comm, c_comm, min_comm))\n    high = max(b_i + 2*c_i*max_i for (b_i, c_i, max_i) in zip(b_comm, c_comm, max_comm))\n    \n    tol = 1e-5\n    while high - low > tol:\n        lam = (low + high) / 2\n        p_comm = []\n        for i in range(len(committed_indices)):\n            p_val = (lam - b_comm[i]) / (2 * c_comm[i])\n            p_val = max(min_comm[i], min(max_comm[i], p_val))\n            p_comm.append(p_val)\n        total_p = sum(p_comm)\n        if total_p < current_load:\n            low = lam\n        else:\n            high = lam\n    \n    lam = (low + high) / 2\n    p_comm = []\n    for i in range(len(committed_indices)):\n        p_val = (lam - b_comm[i]) / (2 * c_comm[i])\n        p_val = max(min_comm[i], min(max_comm[i], p_val))\n        p_comm.append(p_val)\n    \n    p = [0.0] * n\n    for idx, i in enumerate(committed_indices):\n        p[i] = p_comm[idx]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.06217,
          "fitness": 0.03117
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "This heuristic solves the Rolling Unit Commitment Problem in three main steps. First, it classifies units into must-run (due to minimum uptime constraints) and must-off (due to minimum downtime constraints). Second, it adjusts the commitment of free units based on load demand: if load exceeds maximum possible output, it starts additional units by lowest cost; if load is below minimum possible output, it shuts down units by highest savings. Third, it performs economic dispatch to allocate the exact load among committed units using incremental cost sorting while respecting ramp and output limits.\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    L = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_units = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_units.append(i)\n    \n    # Initial commitment\n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_units:\n        u[i] = units_info[i]['u_i_0']\n    \n    # Calculate min and max possible output\n    min_output = 0\n    max_output = 0\n    min_max = []\n    for i in range(n_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                low = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                high = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                low = units_info[i]['p_min_i']\n                high = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_output += low\n            max_output += high\n            min_max.append((low, high))\n        else:\n            min_max.append((0, 0))\n    \n    # Adjust commitment for insufficient capacity\n    if L > max_output:\n        candidates = []\n        for i in free_units:\n            if u[i] == 0 and units_info[i]['u_i_0'] == 0:\n                min_cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + units_info[i]['c_i'] * (units_info[i]['p_min_i'] ** 2)\n                candidates.append((i, min_cost))\n        candidates.sort(key=lambda x: x[1])\n        for i, cost in candidates:\n            u[i] = 1\n            min_output += units_info[i]['p_min_i']\n            max_output += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_max[i] = (units_info[i]['p_min_i'], min(units_info[i]['p_max_i'], units_info[i]['p_start_i']))\n            if max_output >= L:\n                break\n    \n    # Adjust commitment for excess capacity\n    elif L < min_output:\n        candidates = []\n        for i in free_units:\n            if u[i] == 1 and units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                saving = units_info[i]['a_i'] + units_info[i]['b_i'] * min_max[i][0] + units_info[i]['c_i'] * (min_max[i][0] ** 2)\n                candidates.append((i, saving))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        for i, saving in candidates:\n            u[i] = 0\n            min_output -= min_max[i][0]\n            max_output -= min_max[i][1]\n            min_max[i] = (0, 0)\n            if min_output <= L:\n                break\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    dispatch_units = []\n    total_p = 0\n    for i in committed_indices:\n        if units_info[i]['u_i_0'] == 1:\n            low = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            high = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            low = units_info[i]['p_min_i']\n            high = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        p[i] = low\n        total_p += low\n        dispatch_units.append({\n            'index': i,\n            'p': low,\n            'high': high,\n            'b': units_info[i]['b_i'],\n            'c': units_info[i]['c_i']\n        })\n    \n    L_remaining = L - total_p\n    while L_remaining > 0:\n        min_inc = float('inf')\n        best_unit = None\n        for unit in dispatch_units:\n            if unit['p'] < unit['high']:\n                inc_cost = unit['b'] + 2 * unit['c'] * unit['p']\n                if inc_cost < min_inc:\n                    min_inc = inc_cost\n                    best_unit = unit\n        if best_unit is None:\n            break\n        delta = min(L_remaining, best_unit['high'] - best_unit['p'])\n        best_unit['p'] += delta\n        p[best_unit['index']] = best_unit['p']\n        L_remaining -= delta\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.06234,
          "fitness": 0.03126
     },
     {
          "name": "rolling_commitment_heuristic_ed",
          "algorithm": "1. Classify units into must-on (must remain on due to min up-time or shutdown ramp constraints), must-off (must remain off due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Initialize committed units as must-on and free-on. Compute total min/max capacity considering ramp constraints.\n3. If current load is below total min, turn off eligible free-on units (previous output \u2264 ramp down limit) in descending order of min output until total min \u2264 load or no eligible units remain.\n4. If next period's forecast exceeds current total max, turn on beneficial free-off units (startup cost > min output cost) that don't cause over-commitment.\n5. If current load exceeds total max, turn on free-off units in ascending order of startup + min output cost until capacity meets load.\n6. Dispatch load to committed units: initialize at min outputs, then adjust using incremental costs (increase cheapest first if below load, decrease costliest first if above load) while respecting output and ramp limits.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic_ed(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load_forecast = load[1]\n    \n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    p_shut_i = [unit['p_shut_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            if (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i]):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i_0[i] < t_off_min_i[i]:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = set(must_on) | set(free_on)\n    \n    min_outputs = [0.0] * n_units\n    max_outputs = [0.0] * n_units\n    for i in range(n_units):\n        if i in committed:\n            if u_i_0[i] == 1:\n                min_outputs[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                max_outputs[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n            else:\n                min_outputs[i] = p_min_i[i]\n                max_outputs[i] = min(p_max_i[i], p_start_i[i], p_up_i[i])\n        else:\n            min_outputs[i] = 0.0\n            max_outputs[i] = 0.0\n    \n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n    \n    if current_load < total_min:\n        free_on_eligible = [i for i in free_on if i in committed and p_i_0[i] <= p_down_i[i]]\n        free_on_eligible.sort(key=lambda i: min_outputs[i], reverse=True)\n        for i in free_on_eligible:\n            if total_min <= current_load:\n                break\n            if p_i_0[i] <= p_down_i[i]:\n                committed.remove(i)\n                total_min -= min_outputs[i]\n                total_max -= max_outputs[i]\n                min_outputs[i] = 0.0\n                max_outputs[i] = 0.0\n    \n    if current_load <= total_max and next_load_forecast > total_max:\n        free_off_benefit = []\n        for i in free_off:\n            min_cost = a_i[i] + b_i[i] * p_min_i[i] + c_i[i] * p_min_i[i] ** 2\n            if s_i[i] > min_cost and (total_min + p_min_i[i] <= current_load):\n                free_off_benefit.append((s_i[i] - min_cost, i))\n        free_off_benefit.sort(reverse=True)\n        for benefit, i in free_off_benefit:\n            min_outputs[i] = p_min_i[i]\n            max_outputs[i] = min(p_max_i[i], p_start_i[i], p_up_i[i])\n            committed.add(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            free_off.remove(i)\n            break\n    \n    if current_load > total_max:\n        free_off_costs = []\n        for i in free_off:\n            min_cost = a_i[i] + b_i[i] * p_min_i[i] + c_i[i] * p_min_i[i] ** 2\n            total_cost = s_i[i] + min_cost\n            free_off_costs.append((total_cost, i))\n        free_off_costs.sort()\n        for cost, i in free_off_costs:\n            new_max = min(p_max_i[i], p_start_i[i], p_up_i[i])\n            committed.add(i)\n            min_outputs[i] = p_min_i[i]\n            max_outputs[i] = new_max\n            total_min += min_outputs[i]\n            total_max += new_max\n            if total_max >= current_load:\n                break\n    \n    p_alloc = [0.0] * n_units\n    for i in committed:\n        if u_i_0[i] == 1:\n            min_outputs[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n            max_outputs[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n        else:\n            min_outputs[i] = p_min_i[i]\n            max_outputs[i] = min(p_max_i[i], p_start_i[i], p_up_i[i])\n        p_alloc[i] = min_outputs[i]\n    \n    total_output = sum(p_alloc)\n    remaining = current_load - total_output\n    \n    if remaining > 0:\n        while remaining > 1e-6:\n            candidates = []\n            for i in committed:\n                if p_alloc[i] < max_outputs[i]:\n                    inc_cost = b_i[i] + 2 * c_i[i] * p_alloc[i]\n                    gap = max_outputs[i] - p_alloc[i]\n                    candidates.append((inc_cost, gap, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            inc_cost, gap, idx = candidates[0]\n            add = min(remaining, gap)\n            p_alloc[idx] += add\n            remaining -= add\n    elif remaining < 0:\n        remaining = -remaining\n        while remaining > 1e-6:\n            candidates = []\n            for i in committed:\n                if p_alloc[i] > min_outputs[i]:\n                    inc_cost = b_i[i] + 2 * c_i[i] * p_alloc[i]\n                    gap = p_alloc[i] - min_outputs[i]\n                    candidates.append((inc_cost, gap, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            inc_cost, gap, idx = candidates[0]\n            reduce = min(remaining, gap)\n            p_alloc[idx] -= reduce\n            remaining -= reduce\n    \n    u_out = [1 if i in committed else 0 for i in range(n_units)]\n    schedules = np.array([u_out, p_alloc])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.06342,
          "fitness": 0.0318
     }
]