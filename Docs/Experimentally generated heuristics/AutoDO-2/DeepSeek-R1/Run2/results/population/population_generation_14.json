[
     {
          "name": "refined_rolling_commitment_v6",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity while considering next period's forecasted load. 7. Perform economic dispatch using incremental cost method with ramp constraints.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v6(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    forecasted_load_next = load[1]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            remaining_max = total_max - max_out[i]\n            if remaining_max >= forecasted_load_next:\n                candidate_decommit.append(i)\n                \n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules\n",
          "from": "mutation",
          "gap_power_rate": 0.00319,
          "gap_price_rate": 0.01059,
          "fitness": 0.00689
     },
     {
          "name": "refined_rolling_commitment_v7",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds current load while maintaining sufficient capacity. 4. Commit cheapest free-off units if total maximum output is below current load, tracking newly committed units. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity for current and forecasted loads, excluding newly committed units. 7. Perform economic dispatch using incremental cost method within ramp-constrained bounds.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v7(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    forecasted_load_next = load[1]\n    just_committed = set()\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n                just_committed.add(i)\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load) and i not in just_committed:\n            remaining_max = total_max - max_out[i]\n            if remaining_max >= forecasted_load_next:\n                candidate_decommit.append(i)\n                \n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00327,
          "gap_price_rate": 0.01156,
          "fitness": 0.00742
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform constrained economic dispatch using incremental cost method with ramp constraints.\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Step 2: Initialize commitment states\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    \n    for idx in must_on:\n        u_current[idx] = 1\n    for idx in free_on:\n        u_current[idx] = 1\n    for idx in must_off:\n        u_current[idx] = 0\n    for idx in free_off:\n        u_current[idx] = 0\n    \n    # Helper functions\n    def total_min_output():\n        total_min = 0\n        for idx in range(n_units):\n            if u_current[idx] == 1:\n                if units_info[idx]['u_i_0'] == 1:\n                    min_output = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n                else:\n                    min_output = units_info[idx]['p_min_i']\n                total_min += min_output\n        return total_min\n    \n    def total_max_output():\n        total_max = 0\n        for idx in range(n_units):\n            if u_current[idx] == 1:\n                if units_info[idx]['u_i_0'] == 1:\n                    max_output = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n                else:\n                    max_output = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                total_max += max_output\n        return total_max\n    \n    # Step 3: Decommit expensive free-on units if total_min > load\n    total_min = total_min_output()\n    if total_min > current_load:\n        free_on_sorted = sorted(free_on, \n                                key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                reverse=True)\n        for idx in free_on_sorted:\n            if total_min <= current_load:\n                break\n            u_current[idx] = 0\n            total_min = total_min_output()\n    \n    # Step 4: Commit cheapest free-off units if total_max < load\n    total_max = total_max_output()\n    if total_max < current_load:\n        free_off_sorted = sorted(free_off, \n                                 key=lambda idx: (units_info[idx]['a_i'] + units_info[idx]['b_i'] * units_info[idx]['p_max_i'] + \n                                                 units_info[idx]['c_i'] * (units_info[idx]['p_max_i']**2) + units_info[idx]['s_i']) / units_info[idx]['p_max_i'])\n        for idx in free_off_sorted:\n            u_current[idx] = 1\n            total_max = total_max_output()\n            if total_max >= current_load:\n                break\n    \n    # Step 5: Decommit expensive non-must-on if total_min still > load\n    non_must_on = free_on + free_off\n    committed_non_must_on = [idx for idx in non_must_on if u_current[idx] == 1]\n    total_min = total_min_output()\n    if total_min > current_load:\n        committed_non_must_on_sorted = sorted(committed_non_must_on, \n                                             key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                             reverse=True)\n        for idx in committed_non_must_on_sorted:\n            if total_min <= current_load:\n                break\n            u_current[idx] = 0\n            total_min = total_min_output()\n    \n    # Step 6: Decommit expensive non-must-on with excess capacity\n    committed_units = [idx for idx in range(n_units) if u_current[idx] == 1]\n    non_must_on_committed = [idx for idx in committed_units if idx in non_must_on]\n    non_must_on_committed_sorted = sorted(non_must_on_committed, \n                                         key=lambda idx: 2 * units_info[idx]['c_i'] * units_info[idx]['p_min_i'] + units_info[idx]['b_i'], \n                                         reverse=True)\n    for idx in non_must_on_committed_sorted:\n        u_current[idx] = 0\n        if total_max_output() < current_load or total_min_output() > current_load:\n            u_current[idx] = 1\n    \n    # Step 7: Economic dispatch for committed units\n    committed_idxs = [idx for idx in range(n_units) if u_current[idx] == 1]\n    \n    # Set bounds for each committed unit\n    lower_bounds = []\n    upper_bounds = []\n    for idx in committed_idxs:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Was online\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Starting up\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_lb = sum(lower_bounds)\n    total_ub = sum(upper_bounds)\n    \n    # Initialize outputs to lower bounds\n    p_alloc = [lb for lb in lower_bounds]\n    remaining = current_load - total_lb\n    \n    # Distribute remaining load\n    if remaining > 0:\n        # Active units are those not at upper bound\n        active_units = [i for i in range(len(committed_idxs)) if p_alloc[i] < upper_bounds[i]]\n        \n        while remaining > 0 and active_units:\n            # Find unit with smallest incremental cost\n            min_ic = float('inf')\n            candidate_idx = None\n            for i in active_units:\n                unit_idx = committed_idxs[i]\n                ic = 2 * units_info[unit_idx]['c_i'] * p_alloc[i] + units_info[unit_idx]['b_i']\n                if ic < min_ic:\n                    min_ic = ic\n                    candidate_idx = i\n            \n            if candidate_idx is None:\n                break\n                \n            # Calculate available capacity for candidate\n            available = upper_bounds[candidate_idx] - p_alloc[candidate_idx]\n            if available > 0:\n                add = min(available, remaining)\n                p_alloc[candidate_idx] += add\n                remaining -= add\n                # Check if unit reached upper bound\n                if p_alloc[candidate_idx] >= upper_bounds[candidate_idx] - 1e-5:\n                    active_units.remove(candidate_idx)\n    \n    # Map allocations back to units\n    for i, idx in enumerate(committed_idxs):\n        p_current[idx] = p_alloc[i]\n    \n    # Create output array\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u_current[i]\n        schedules[1, i] = p_current[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00407,
          "gap_price_rate": 0.01134,
          "fitness": 0.0077
     },
     {
          "name": "refined_rolling_commitment_v6",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units using incremental cost at minimum output if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v6(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        incremental_costs = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            inc_cost = 2 * unit['c_i'] * min_p + unit['b_i']\n            incremental_costs.append((inc_cost, i, min_p, max_p))\n        incremental_costs.sort(key=lambda x: x[0])\n        for inc_cost, i, min_p, max_p in incremental_costs:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    incremental_costs = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n        incremental_costs.append((inc_cost, i))\n    incremental_costs.sort(key=lambda x: x[0], reverse=True)\n    for inc_cost, i in incremental_costs:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00433,
          "gap_price_rate": 0.01142,
          "fitness": 0.00787
     },
     {
          "name": "refined_rolling_commitment_v5",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity without breaking loop on unmet conditions. 7. Perform economic dispatch using incremental cost method with improved numerical stability.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v5(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 1e-5:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i] - 1e-5]\n        while remaining > 1e-5 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01172,
          "fitness": 0.00806
     },
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load using incremental cost. 4. Commit cheapest free-off units if total maximum output is below load using average cost. 5. Decommit expensive non-must-on units if minimum output still exceeds load using incremental cost. 6. Decommit expensive non-must-on units with excess capacity using incremental cost. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        avg_costs = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw = total_cost / min_p\n            avg_costs.append((cost_per_mw, i, min_p, max_p))\n        avg_costs.sort(key=lambda x: x[0])\n        for cost_per_mw, i, min_p, max_p in avg_costs:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        incremental_costs = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n            incremental_costs.append((inc_cost, i))\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        for inc_cost, i in incremental_costs:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    incremental_costs = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        inc_cost = 2 * unit['c_i'] * min_out[i] + unit['b_i']\n        incremental_costs.append((inc_cost, i))\n    incremental_costs.sort(key=lambda x: x[0], reverse=True)\n    for inc_cost, i in incremental_costs:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01179,
          "fitness": 0.0081
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load. 6. Decommit expensive non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_val = total_cost / min_p\n            cost_per_mw.append((cost_val, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        cost_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    cost_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        p_val = min_out[i]\n        cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n        cost_per_mw.append((cost_val, i))\n    cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for cost_val, i in cost_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            break\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01183,
          "fitness": 0.00812
     },
     {
          "name": "refined_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-on, must-off, free-on, free-off based on operational constraints. 2. Initialize commitment states. 3. Decommit expensive free-on units if total minimum output exceeds load, considering cost savings. 4. Commit cheapest free-off units if total maximum output is below load. 5. Decommit expensive non-must-on units if minimum output still exceeds load, including startup cost avoidance. 6. Decommit non-essential non-must-on units with excess capacity. 7. Perform economic dispatch using incremental cost method.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v4(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        candidate_decommit = [i for i in free_on if u[i] == 1]\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load and (total_max - max_out[i] >= current_load):\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    if total_max < current_load:\n        candidate_commit = [i for i in free_off if u[i] == 0]\n        cost_per_mw = []\n        for i in candidate_commit:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append((total_cost / min_p, i, min_p, max_p))\n        cost_per_mw.sort(key=lambda x: x[0])\n        for cost_val, i, min_p, max_p in cost_per_mw:\n            if total_max < current_load:\n                u[i] = 1\n                min_out[i] = min_p\n                max_out[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n                \n    if total_min > current_load:\n        candidate_decommit = []\n        for i in range(n_units):\n            if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n                candidate_decommit.append(i)\n        saving_per_mw = []\n        for i in candidate_decommit:\n            unit = units_info[i]\n            saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n            if unit['u_i_0'] == 0:\n                saving += unit['s_i']\n            saving_per_mw.append((saving / min_out[i], i))\n        saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for saving_val, i in saving_per_mw:\n            if total_min > current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n            else:\n                break\n                \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and i not in must_on and (total_max - max_out[i] >= current_load):\n            candidate_decommit.append(i)\n    saving_per_mw = []\n    for i in candidate_decommit:\n        unit = units_info[i]\n        saving = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2\n        if unit['u_i_0'] == 0:\n            saving += unit['s_i']\n        saving_per_mw.append((saving / min_out[i], i))\n    saving_per_mw.sort(key=lambda x: x[0], reverse=True)\n    for saving_val, i in saving_per_mw:\n        if total_max - max_out[i] >= current_load:\n            u[i] = 0\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n            min_out[i] = 0\n            max_out[i] = 0\n        else:\n            continue\n            \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00441,
          "gap_price_rate": 0.01189,
          "fitness": 0.00815
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v2",
          "algorithm": "1. Precompute current period min/max outputs for online units considering ramp constraints.  \n2. Identify must-run units (online units violating min up-time or shutdown capacity).  \n3. Calculate total min/max capacity from must-run units.  \n4. If must-run min capacity exceeds load, set must-run units to min output and turn off others.  \n5. Else if load within must-run capacity, perform economic dispatch on must-run units.  \n6. Else:  \n   a. Identify candidate units (offline units satisfying min down-time).  \n   b. Sort candidates by average cost at min output (including startup cost).  \n   c. Add cheapest candidates until total capacity >= load.  \n   d. If insufficient capacity, set units to max output.  \n   e. Else perform economic dispatch on committed units considering constraints.  \n7. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_hybrid_rolling_commitment_v2(units_info, load):  \n    n_units = len(units_info)  \n    schedules = np.zeros((2, n_units))  \n    current_load = load[0]  \n    \n    # Step 1: Precompute current period min/max for online units  \n    min_outputs = np.zeros(n_units)  \n    max_outputs = np.zeros(n_units)  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  # Online last period  \n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  # Offline last period  \n            min_outputs[i] = 0  \n            max_outputs[i] = 0  \n    \n    # Step 2: Identify must-run units  \n    must_run = []  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):  \n                must_run.append(i)  \n    \n    # Step 3: Total must-run capacity  \n    must_run_min = sum(min_outputs[i] for i in must_run)  \n    must_run_max = sum(max_outputs[i] for i in must_run)  \n    \n    # Step 4: Must-run min exceeds load  \n    if must_run_min > current_load:  \n        for i in range(n_units):  \n            if i in must_run:  \n                schedules[0, i] = 1  \n                schedules[1, i] = min_outputs[i]  \n            else:  \n                schedules[0, i] = 0  \n                schedules[1, i] = 0  \n        return schedules  \n    \n    # Step 5: Load within must-run capacity  \n    if current_load <= must_run_max:  \n        committed = must_run  \n        min_vals = [min_outputs[i] for i in committed]  \n        max_vals = [max_outputs[i] for i in committed]  \n        b_vals = [units_info[i]['b_i'] for i in committed]  \n        c_vals = [units_info[i]['c_i'] for i in committed]  \n        p_alloc = economic_dispatch(min_vals, max_vals, b_vals, c_vals, current_load)  \n        for idx, unit_idx in enumerate(committed):  \n            schedules[0, unit_idx] = 1  \n            schedules[1, unit_idx] = p_alloc[idx]  \n        return schedules  \n    \n    # Step 6: Need additional units  \n    # 6a. Identify candidate units  \n    candidates = []  \n    for i, unit in enumerate(units_info):  \n        if i in must_run:  \n            continue  \n        if unit['u_i_0'] == 0 and unit['t_i_0'] <= -unit['t_off_min_i']:  \n            candidates.append(i)  \n    \n    # 6b. Sort candidates by cost efficiency  \n    def cost_efficiency(i):  \n        u = units_info[i]  \n        base_cost = u['s_i'] + u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*(u['p_min_i']**2)  \n        return base_cost / u['p_min_i']  \n    candidates.sort(key=cost_efficiency)  \n    \n    # 6c. Add candidates until capacity >= load  \n    committed = must_run.copy()  \n    total_capacity = must_run_max  \n    added = []  \n    for i in candidates:  \n        unit_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])  \n        total_capacity += unit_max  \n        committed.append(i)  \n        added.append(i)  \n        if total_capacity >= current_load:  \n            break  \n    \n    # Prepare for dispatch  \n    min_vals = []  \n    max_vals = []  \n    b_vals = []  \n    c_vals = []  \n    for i in committed:  \n        if i in must_run:  \n            min_vals.append(min_outputs[i])  \n            max_vals.append(max_outputs[i])  \n        else:  \n            min_vals.append(units_info[i]['p_min_i'])  \n            max_vals.append(min(units_info[i]['p_max_i'], units_info[i]['p_start_i']))  \n        b_vals.append(units_info[i]['b_i'])  \n        c_vals.append(units_info[i]['c_i'])  \n    \n    total_min = sum(min_vals)  \n    total_max = sum(max_vals)  \n    \n    # 6d. Insufficient capacity  \n    if total_max < current_load:  \n        for idx, unit_idx in enumerate(committed):  \n            schedules[0, unit_idx] = 1  \n            schedules[1, unit_idx] = max_vals[idx]  \n        return schedules  \n    \n    # 6e. Perform economic dispatch  \n    if total_min > current_load:  \n        p_alloc = min_vals  # Overproduce at min  \n    elif total_max < current_load:  \n        p_alloc = max_vals  # Underproduce at max  \n    else:  \n        p_alloc = economic_dispatch(min_vals, max_vals, b_vals, c_vals, current_load)  \n    \n    for idx, unit_idx in enumerate(committed):  \n        schedules[0, unit_idx] = 1  \n        schedules[1, unit_idx] = p_alloc[idx]  \n    return schedules  \n\ndef economic_dispatch(min_vals, max_vals, b_vals, c_vals, load):  \n    n = len(min_vals)  \n    p_alloc = [0] * n  \n    total_min = sum(min_vals)  \n    total_max = sum(max_vals)  \n    \n    if abs(total_min - total_max) < 1e-5 or load <= total_min:  \n        return min_vals  \n    if load >= total_max:  \n        return max_vals  \n    \n    # Bisection method  \n    tol = 1e-5  \n    max_iter = 1000  \n    lambda_low = min(b_i + 2 * c_i * min_i for min_i, b_i, c_i in zip(min_vals, b_vals, c_vals))  \n    lambda_high = max(b_i + 2 * c_i * max_i for max_i, b_i, c_i in zip(max_vals, b_vals, c_vals))  \n    \n    for _ in range(max_iter):  \n        lambda_mid = (lambda_low + lambda_high) / 2  \n        total_p = 0  \n        for i in range(n):  \n            if c_vals[i] == 0:  \n                p_i = max_vals[i] if lambda_mid > b_vals[i] else min_vals[i]  \n            else:  \n                p_i = (lambda_mid - b_vals[i]) / (2 * c_vals[i])  \n                p_i = max(min_vals[i], min(max_vals[i], p_i))  \n            p_alloc[i] = p_i  \n            total_p += p_i  \n        \n        if abs(total_p - load) < tol:  \n            break  \n        if total_p < load:  \n            lambda_low = lambda_mid  \n        else:  \n            lambda_high = lambda_mid  \n    \n    return p_alloc  ",
          "from": "crossover",
          "gap_power_rate": 0.0057,
          "gap_price_rate": 0.01187,
          "fitness": 0.00878
     },
     {
          "name": "enhanced_rolling_commitment_ed",
          "algorithm": "1. Classify units into must-on (violate min up-time/shutdown ramp), must-off (violate min down-time), free-on (can be turned off), and free-off (can be turned on). 2. Initialize commitment with must-on and free-on units. 3. Decommit expensive free-on units if total minimum output exceeds load. 4. Commit free-off units by ascending cost per MW if total maximum output is below load. 5. Decommit unneeded free-on units if excess capacity remains. 6. Perform economic dispatch using incremental cost method to distribute load.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_ed(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    u = [0] * n_units\n    min_out = [0] * n_units\n    max_out = [0] * n_units\n    \n    for i in must_on:\n        u[i] = 1\n    for i in free_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free_off:\n        u[i] = 0\n        \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n            \n    total_min = sum(min_out)\n    total_max = sum(max_out)\n    current_load = load[0]\n    \n    if total_min > current_load:\n        free_on_committed = [i for i in free_on if u[i] == 1]\n        if free_on_committed:\n            cost_per_mw = []\n            for i in free_on_committed:\n                unit = units_info[i]\n                p_val = min_out[i]\n                cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n                cost_per_mw.append((cost_val, i))\n            cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n            for cost_val, i in cost_per_mw:\n                if total_min > current_load:\n                    u[i] = 0\n                    total_min -= min_out[i]\n                    total_max -= max_out[i]\n                    min_out[i] = 0\n                    max_out[i] = 0\n                else:\n                    break\n                    \n    if total_max < current_load:\n        free_off_not_committed = [i for i in free_off if u[i] == 0]\n        if free_off_not_committed:\n            cost_per_mw = []\n            for i in free_off_not_committed:\n                unit = units_info[i]\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n                cost_val = total_cost / min_p\n                cost_per_mw.append((cost_val, i, min_p, max_p))\n            cost_per_mw.sort(key=lambda x: x[0])\n            for cost_val, i, min_p, max_p in cost_per_mw:\n                if total_max < current_load:\n                    u[i] = 1\n                    min_out[i] = min_p\n                    max_out[i] = max_p\n                    total_min += min_p\n                    total_max += max_p\n                else:\n                    break\n                    \n    free_on_committed = [i for i in free_on if u[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        for i in free_on_committed:\n            unit = units_info[i]\n            p_val = min_out[i]\n            cost_val = (unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2) / p_val\n            cost_per_mw.append((cost_val, i))\n        cost_per_mw.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in cost_per_mw:\n            if total_max - max_out[i] >= current_load:\n                u[i] = 0\n                total_min -= min_out[i]\n                total_max -= max_out[i]\n                min_out[i] = 0\n                max_out[i] = 0\n                \n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_out[i]\n            \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        candidate_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_out[i]]\n        while remaining > 0 and candidate_indices:\n            min_inc = float('inf')\n            best_i = None\n            for i in candidate_indices:\n                inc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if inc < min_inc:\n                    min_inc = inc\n                    best_i = i\n            if best_i is None:\n                break\n            delta = min(remaining, max_out[best_i] - p[best_i])\n            p[best_i] += delta\n            remaining -= delta\n            if p[best_i] >= max_out[best_i] - 1e-5:\n                candidate_indices.remove(best_i)\n                \n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0048,
          "gap_price_rate": 0.01286,
          "fitness": 0.00883
     }
]