[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "hybrid_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or violation of shutdown ramp constraint) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state\n3. Calculate feasible power ranges for committed units considering ramp constraints and startup/shutdown limits\n4. Adjust commitment based on system adequacy:\n   - Under-committed: activate flexible units sorted by lowest (startup cost + min-power cost)/min-power\n   - Over-committed: decommit non-must-on units sorted by highest min-power operating cost\n   - Adequate: decommit non-must-on units sorted by highest min-power cost if system remains adequate\n5. Perform constrained economic dispatch using lambda iteration for committed units:\n   - Solve optimal dispatch via bisection on system lambda\n   - Adjust any residual load using greedy merit-order based on marginal costs\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    min_bound = [0.0] * n\n    max_bound = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    current_load = load[0]\n    \n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u_arr[i] = 1\n        elif must_off[i]:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n\n    # Step 3: Calculate feasible power ranges for committed units\n    for i, unit in enumerate(units_info):\n        if u_arr[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n\n    # Step 4: Adjust commitment based on system adequacy\n    total_min = sum(min_bound[i] for i in range(n) if u_arr[i] == 1)\n    total_max = sum(max_bound[i] for i in range(n) if u_arr[i] == 1)\n    \n    # Case A: Under-committed\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if not must_on[i] and not must_off[i] and u_arr[i] == 0]\n        metrics = []\n        for i in flexible_off:\n            unit = units_info[i]\n            startup_cost = unit['s_i']\n            min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            metric = (startup_cost + min_cost) / unit['p_min_i']\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for metric, i in metrics:\n            if total_max >= current_load:\n                break\n            u_arr[i] = 1\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Case B: Over-committed\n    if total_min > current_load:\n        non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n        costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n            costs.append((cost, i))\n        costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in costs:\n            if total_min <= current_load:\n                break\n            u_arr[i] = 0\n            total_min -= min_bound[i]\n            total_max -= max_bound[i]\n            min_bound[i] = 0\n            max_bound[i] = 0\n    \n    # Case C: Adequate - decommit expensive non-must-on units\n    non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n    costs = []\n    for i in non_must_on:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n        costs.append((cost, i))\n    costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in costs:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load <= new_max:\n            u_arr[i] = 0\n            total_min = new_min\n            total_max = new_max\n            min_bound[i] = 0\n            max_bound[i] = 0\n\n    # Step 5: Economic dispatch for committed units\n    committed_indices = [i for i in range(n) if u_arr[i] == 1]\n    l_dispatch = [min_bound[i] for i in committed_indices]\n    u_dispatch = [max_bound[i] for i in committed_indices]\n    b_dispatch = [units_info[i]['b_i'] for i in committed_indices]\n    c_dispatch = [units_info[i]['c_i'] for i in committed_indices]\n    p_dispatch = l_dispatch[:] if committed_indices else []\n    residual = current_load - sum(p_dispatch)\n    \n    # Lambda iteration for dispatch\n    if committed_indices:\n        tol = 0.001\n        max_iter = 1000\n        low_lambda = float('inf')\n        high_lambda = float('-inf')\n        \n        for i in range(len(committed_indices)):\n            mc_low = b_dispatch[i] + 2 * c_dispatch[i] * l_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            mc_high = b_dispatch[i] + 2 * c_dispatch[i] * u_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            if mc_low < low_lambda:\n                low_lambda = mc_low\n            if mc_high > high_lambda:\n                high_lambda = mc_high\n        \n        lambda_low = min(low_lambda - 1.0, 0)\n        lambda_high = high_lambda + 1.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in range(len(committed_indices)):\n                if c_dispatch[i] == 0:\n                    if lambda_mid < b_dispatch[i]:\n                        p_dispatch[i] = l_dispatch[i]\n                    elif lambda_mid > b_dispatch[i]:\n                        p_dispatch[i] = u_dispatch[i]\n                    else:\n                        p_dispatch[i] = l_dispatch[i]\n                else:\n                    p = (lambda_mid - b_dispatch[i]) / (2.0 * c_dispatch[i])\n                    p_dispatch[i] = min(u_dispatch[i], max(l_dispatch[i], p))\n                total_gen += p_dispatch[i]\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > tol:\n            # Residual >0: distribute to units with cheapest marginal cost\n            if residual > 0:\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] < u_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    min_mc = min(mc_list, key=lambda x: x[0])\n                    i = min_mc[1]\n                    add = min(residual, u_dispatch[i] - p_dispatch[i])\n                    p_dispatch[i] += add\n                    residual -= add\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] < u_dispatch[j]]\n            # Residual <0: reduce from units with highest marginal cost\n            else:\n                residual = abs(residual)\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] > l_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    max_mc = max(mc_list, key=lambda x: x[0])\n                    i = max_mc[1]\n                    reduce_by = min(residual, p_dispatch[i] - l_dispatch[i])\n                    p_dispatch[i] -= reduce_by\n                    residual -= reduce_by\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] > l_dispatch[j]]\n        \n        # Assign dispatched power to output array\n        for idx, p_val in zip(committed_indices, p_dispatch):\n            p_arr[idx] = p_val\n    \n    # Build return array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_arr[i]\n        schedules[1, i] = p_arr[i]\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049948693,
          "gap_price_rate": 0.0092619027,
          "fitness": 0.007128386
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Identify must-run and must-off units based on min up/down times and shutdown constraints\n2. Initialize commitment states using forced status and previous states\n3. Compute current power ranges and check system adequacy\n4. If under-committed (total capacity < load), activate units by lowest average cost\n5. If over-committed (min capacity > load), deactivate non-essential units by highest operating cost\n6. Optimize adequate systems by turning off expensive non-essential units\n7. Perform economic dispatch using priority queue based on marginal costs\n",
          "code": "import heapq\nimport numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    # Initialize lists for must-run, must-off, and commitment state\n    must_commit = [False] * n\n    must_off = [False] * n\n    u_i = [0] * n\n    \n    # Step 1: Determine forced units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_commit[i] = True\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n                \n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_commit[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    # Helper function to compute power limits\n    def compute_power_limits(i, state):\n        if state == 0:\n            return 0, 0\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Starting unit\n            p_min_i = unit['p_min_i']\n            p_max_i = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        else:  # Running unit\n            p_min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return p_min_i, p_max_i\n    \n    # Initialize power limits arrays\n    p_min_arr = [0] * n\n    p_max_arr = [0] * n\n    for i in range(n):\n        p_min_arr[i], p_max_arr[i] = compute_power_limits(i, u_i[i])\n    \n    total_min = sum(p_min_arr)\n    total_max = sum(p_max_arr)\n    \n    # Step 3a: Handle under-committed case\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if u_i[i] == 0 and not must_off[i]]\n        def avg_cost(i):\n            unit = units_info[i]\n            min_power = unit['p_min_i']\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n        flexible_off.sort(key=avg_cost)\n        \n        for i in flexible_off:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            new_min, new_max = compute_power_limits(i, 1)\n            total_min = total_min + new_min\n            total_max = total_max + new_max\n            p_min_arr[i] = new_min\n            p_max_arr[i] = new_max\n    \n    # Step 3b: Handle over-committed case\n    if total_min > current_load:\n        flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            total_min -= p_min_arr[i]\n            total_max -= p_max_arr[i]\n            p_min_arr[i] = 0\n            p_max_arr[i] = 0\n    \n    # Step 3c: Optimize adequate case\n    flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n    if total_min <= current_load <= total_max:\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            new_total_min = total_min - p_min_arr[i]\n            new_total_max = total_max - p_max_arr[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                p_min_arr[i] = 0\n                p_max_arr[i] = 0\n    \n    # Finalize power limits\n    for i in range(n):\n        if u_i[i] == 1:\n            p_min_arr[i], p_max_arr[i] = compute_power_limits(i, 1)\n        else:\n            p_min_arr[i], p_max_arr[i] = 0, 0\n    \n    # Step 4: Economic Dispatch\n    p_i = [0] * n\n    committed_indices = [i for i in range(n) if u_i[i] == 1]\n    for i in committed_indices:\n        p_i[i] = p_min_arr[i]\n    \n    total_output = sum(p_i)\n    remaining = current_load - total_output\n    heap = []\n    \n    # Initialize priority queue\n    for i in committed_indices:\n        if p_i[i] < p_max_arr[i]:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    # Dispatch remaining load\n    while remaining > 1e-5 and heap:\n        mc, idx = heapq.heappop(heap)\n        max_inc = min(remaining, p_max_arr[idx] - p_i[idx])\n        p_i[idx] += max_inc\n        remaining -= max_inc\n        if p_i[idx] < p_max_arr[idx]:\n            new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_i[idx]\n            heapq.heappush(heap, (new_mc, idx))\n    \n    # Create and return schedule\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0062438914,
          "gap_price_rate": 0.0084205625,
          "fitness": 0.007332227
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into three categories based on constraints:\n   - Must-on: Units forced to remain on due to min-up time or shutdown capacity violation.\n   - Must-off: Units forced to remain off due to min-down time constraints.\n   - Flexible: Units that can be turned on or off.\n2. For must-on units, compute feasible output ranges considering ramp limits.\n3. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) output from must-on units.\n4. Based on current load and total must-on capacity:\n   a. If load is within must-on capacity: Dispatch load optimally among must-on units using lambda iteration.\n   b. If load < total must-on minimum: Set must-on units to minimum, others off.\n   c. If load > total must-on maximum: Turn on flexible units in priority order (cheapest average cost first) until demand is covered, then dispatch optimally among all online units.\n5. For must-off units: Set to off state and zero output.\n6. Return 2D array with commitment states (u_i) and outputs (p_i).\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_for_dispatch, load):\n    L_arr = np.array([u['L'] for u in units_for_dispatch])\n    U_arr = np.array([u['U'] for u in units_for_dispatch])\n    total_min = np.sum(L_arr)\n    total_max = np.sum(U_arr)\n    n = len(units_for_dispatch)\n    \n    if load <= total_min:\n        return L_arr.tolist()\n    elif load >= total_max:\n        return U_arr.tolist()\n    else:\n        low = float('inf')\n        high = -float('inf')\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                mc_low = u['b_i'] + 2*u['c_i'] * u['L']\n                mc_high = u['b_i'] + 2*u['c_i'] * u['U']\n                low = min(low, mc_low)\n                high = max(high, mc_high)\n            else:\n                low = min(low, u['b_i'])\n                high = max(high, u['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_power = 0\n            for u in units_for_dispatch:\n                if u['c_i'] > 0:\n                    p = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n                else:\n                    p = u['U'] if mid >= u['b_i'] else u['L']\n                total_power += p\n            if abs(total_power - load) < tol:\n                break\n            if total_power < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_list = []\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                p_val = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n            else:\n                p_val = u['U'] if mid >= u['b_i'] else u['L']\n            p_list.append(p_val)\n        \n        return p_list\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_periods = -unit['t_i_0']\n            if offline_periods < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    L_must_on = []\n    U_must_on = []\n    for i in must_on:\n        unit = units[i]\n        L = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        U = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        L_must_on.append(L)\n        U_must_on.append(U)\n    \n    total_min = sum(L_must_on) if must_on else 0\n    total_max = sum(U_must_on) if must_on else 0\n    schedules = np.zeros((2, len(units)))\n    \n    if total_min <= current_load <= total_max:\n        units_for_dispatch = []\n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    elif current_load < total_min:\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = L_must_on[idx]\n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    else:\n        flex_candidates = []\n        for i in flexible:\n            unit = units[i]\n            avg_cost = (unit['s_i'] + unit['a_i'] + \n                        unit['b_i']*unit['p_min_i'] + \n                        unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            flex_candidates.append((avg_cost, i))\n        flex_candidates.sort(key=lambda x: x[0])\n        \n        selected_flex = []\n        cum_added = 0\n        deficit = current_load - total_max\n        for _, i in flex_candidates:\n            capacity = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            selected_flex.append(i)\n            cum_added += capacity\n            if cum_added >= deficit:\n                break\n        \n        on_units_indices = must_on + selected_flex\n        units_for_dispatch = []\n        L_dict = {}\n        U_dict = {}\n        \n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            L_dict[i] = L_val\n            U_dict[i] = U_val\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        \n        for i in selected_flex:\n            unit = units[i]\n            L_dict[i] = unit['p_min_i']\n            U_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_dict[i],\n                'U': U_dict[i]\n            })\n        \n        total_min_dispatch = sum(L_dict[i] for i in on_units_indices)\n        total_max_dispatch = sum(U_dict[i] for i in on_units_indices)\n        \n        if current_load < total_min_dispatch:\n            dispatch_result = [L_dict[i] for i in on_units_indices]\n        elif current_load > total_max_dispatch:\n            dispatch_result = [U_dict[i] for i in on_units_indices]\n        else:\n            dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        \n        for idx, i in enumerate(on_units_indices):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in on_units_indices:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    for i in must_off:\n        schedules[0][i] = 0\n        schedules[1][i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058061183,
          "gap_price_rate": 0.0091680778,
          "fitness": 0.0074870981
     },
     {
          "name": "refined_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-run (forced-on) and must-off (forced-off) units based on min up/down times and shutdown ramp constraints.\n2. Initialize commitment states for forced-on (on), forced-off (off), and flexible units (keep previous state).\n3. Compute feasible power ranges for committed units considering ramp, startup, and shutdown constraints.\n4. Classify system state:\n   - Over-committed: total minimum generation > current load\n   - Under-committed: total maximum generation < current load\n   - Adequate: load within feasible range\n5. Adjust commitment:\n   - Over-committed: Deactivate non-must-run units by highest operating cost at minimum power until feasible.\n   - Under-committed: Activate cheapest offline units (considering startup cost averaged at minimum output) until feasible.\n   - Adequate: Deactivate expensive non-must-run units if system adequacy maintained.\n6. Perform constrained economic dispatch:\n   - Initialize unit outputs to minimum feasible power.\n   - Distribute residual load to units with smallest marginal cost, respecting ramp limits.\n   - Handle under/over-generation by setting outputs to min/max when necessary.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]  # Current time step load\n    n_units = len(units_info)\n    u_i = [unit['u_i_0'] for unit in units_info]  # Initial commitment states\n    forced_on = []\n    forced_off = []\n\n    # Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if (unit['t_i_0'] >= 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] <= 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Apply forced states\n    for i in forced_on:\n        u_i[i] = 1\n    for i in forced_off:\n        u_i[i] = 0\n    \n    # Compute feasible min and max outputs for current commitment\n    min_i = [0] * n_units\n    max_i = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:  # Committed units\n            if unit['u_i_0'] == 1:  # Staying online\n                min_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_i[i] = unit['p_min_i']\n                max_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Decommitted units\n            min_i[i] = 0\n            max_i[i] = 0\n    \n    total_min = sum(min_i)\n    total_max = sum(max_i)\n    \n    # Adjust commitment based on system state\n    non_forced_committed = [i for i in range(n_units) if u_i[i] == 1 and i not in forced_on]\n    \n    if total_min > current_load:  # Over-committed\n        # Sort by operating cost at min output (descending)\n        non_forced_committed.sort(\n            key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + units_info[i]['c_i'] * min_i[i] ** 2,\n            reverse=True\n        )\n        for i in non_forced_committed:\n            if total_min <= current_load:\n                break\n            total_min -= min_i[i]\n            total_max -= max_i[i]\n            u_i[i] = 0\n            min_i[i] = 0\n            max_i[i] = 0\n    \n    elif total_max < current_load:  # Under-committed\n        candidate_on = [i for i in range(n_units) if u_i[i] == 0 and i not in forced_off]\n        # Sort by (startup cost + operating cost at min) / min output (ascending)\n        candidate_on.sort(\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                           units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                           units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n        )\n        for i in candidate_on:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            min_i[i] = units_info[i]['p_min_i']\n            max_i[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_i[i]\n            total_max += max_i[i]\n    \n    else:  # Adequate\n        non_forced_committed = [i for i in range(n_units) if u_i[i] == 1 and i not in forced_on]\n        non_forced_committed.sort(\n            key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + units_info[i]['c_i'] * min_i[i] ** 2,\n            reverse=True\n        )\n        for i in non_forced_committed:\n            test_min = total_min - min_i[i]\n            test_max = total_max - max_i[i]\n            if test_min <= current_load and test_max >= current_load:\n                total_min = test_min\n                total_max = test_max\n                u_i[i] = 0\n                min_i[i] = 0\n                max_i[i] = 0\n    \n    # Dispatch\n    p_i = [0.0] * n_units\n    for i in range(n_units):\n        if u_i[i] == 1:\n            p_i[i] = min_i[i]\n        else:\n            p_i[i] = 0.0\n    \n    residual = current_load - total_min\n    \n    # Handle under/over-generation scenarios\n    if residual < 0:  # Over-generation\n        for i in range(n_units):\n            if u_i[i] == 1:\n                p_i[i] = min_i[i]  # Set to minimum feasible output\n    \n    elif residual > 0:\n        if total_max == total_min:  # No dispatch flexibility\n            for i in range(n_units):\n                if u_i[i] == 1:\n                    p_i[i] = max_i[i]  # Set to maximum output\n        else:\n            # Dispatch residual load based on marginal costs\n            residual_to_dispatch = residual\n            candidate_units = []\n            for i in range(n_units):\n                if u_i[i] == 1:\n                    headroom = max_i[i] - min_i[i]\n                    if headroom > 0:\n                        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_i[i]\n                        candidate_units.append((marginal_cost, i, min_i[i]))\n            \n            while residual_to_dispatch > 0 and candidate_units:\n                candidate_units.sort(key=lambda x: x[0])\n                cost, idx, current_p = candidate_units[0]\n                headroom = max_i[idx] - p_i[idx]\n                \n                if headroom <= 0:\n                    candidate_units.pop(0)\n                    continue\n                \n                # Increase output by minimum of headroom and residual\n                delta = min(headroom, residual_to_dispatch)\n                p_i[idx] += delta\n                residual_to_dispatch -= delta\n                \n                # Update marginal cost and remove unit if no headroom\n                new_headroom = max_i[idx] - p_i[idx]\n                if new_headroom > 0:\n                    new_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_i[idx]\n                    candidate_units[0] = (new_cost, idx, p_i[idx])\n                else:\n                    candidate_units.pop(0)\n    \n    # Return commitment and output arrays\n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099124187,
          "fitness": 0.0077966516
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown capacity constraints) and forced-off units (must remain offline due to min down-time constraints)  \n2. Initialize committed units to forced-on units and previously online non-forced units  \n3. Compute total minimum and maximum power outputs from committed units  \n4. Classify system state:  \n   - Over-committed if total minimum > load: remove expensive non-forced units  \n   - Under-committed if total maximum < load: activate cheapest non-forced units  \n   - Adequate: remove non-essential units by cost priority  \n5. Perform economic dispatch:  \n   a. Set all units to minimum output if total minimum \u2265 load  \n   b. Set all units to maximum output if total maximum \u2264 load  \n   c. Otherwise, distribute load using greedy merit-order dispatch  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < min_up and t_i0 >= 0) or (p_i0 > p_shut):\n                forced_on[i] = True\n            min_output[i] = max(p_min, p_i0 - p_down)\n            max_output[i] = min(p_max, p_i0 + p_up)\n        else:\n            if u_i0 == 0 and t_i0 < 0 and -t_i0 < min_down:\n                forced_off[i] = True\n            min_output[i] = p_min\n            max_output[i] = min(p_max, p_start)\n        \n        if forced_off[i]:\n            min_output[i] = 0.0\n            max_output[i] = 0.0\n    \n    non_forced = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    committed_units = [i for i in range(n_units) if forced_on[i]]\n    non_forced_online = [i for i in non_forced if units_info[i]['u_i_0'] == 1]\n    non_forced_offline = [i for i in non_forced if units_info[i]['u_i_0'] == 0]\n    committed_units.extend(non_forced_online)\n    \n    avg_costs = []\n    for i in non_forced:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        if units_info[i]['u_i_0'] == 0:\n            cost_val = s + a + b * min_output[i] + c * min_output[i] ** 2\n        else:\n            cost_val = a + b * min_output[i] + c * min_output[i] ** 2\n        avg_costs.append(cost_val / min_output[i] if min_output[i] > 0 else float('inf'))\n    avg_costs = dict(zip(non_forced, avg_costs))\n    \n    total_min = sum(min_output[i] for i in committed_units)\n    total_max = sum(max_output[i] for i in committed_units)\n    \n    if total_min > current_load:\n        non_forced_in_committed = [i for i in committed_units if not forced_on[i]]\n        non_forced_in_committed.sort(key=lambda i: avg_costs[i], reverse=True)\n        for i in non_forced_in_committed:\n            new_min = total_min - min_output[i]\n            committed_units.remove(i)\n            total_min = new_min\n            total_max -= max_output[i]\n            if total_min <= current_load:\n                break\n    \n    elif total_max < current_load:\n        non_forced_offline.sort(key=lambda i: avg_costs[i])\n        for i in non_forced_offline:\n            if total_max < current_load:\n                committed_units.append(i)\n                total_min += min_output[i]\n                total_max += max_output[i]\n    \n    else:\n        non_forced_in_committed = [i for i in committed_units if not forced_on[i]]\n        non_forced_in_committed.sort(key=lambda i: avg_costs[i], reverse=True)\n        for i in non_forced_in_committed:\n            new_min = total_min - min_output[i]\n            new_max = total_max - max_output[i]\n            if new_min <= current_load <= new_max:\n                committed_units.remove(i)\n                total_min = new_min\n                total_max = new_max\n            else:\n                break\n    \n    u_final = [0] * n_units\n    p_final = [0] * n_units\n    for i in committed_units:\n        u_final[i] = 1\n        p_final[i] = min_output[i]\n    \n    if current_load <= total_min:\n        pass\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_final[i] = max_output[i]\n    else:\n        residual = current_load - total_min\n        candidate_units = [i for i in committed_units if p_final[i] < max_output[i]]\n        while residual > 0 and candidate_units:\n            marginal_costs = []\n            for i in candidate_units:\n                unit = units_info[i]\n                p_i = p_final[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_i\n                marginal_costs.append(marginal_cost)\n            \n            min_mc_idx = np.argmin(marginal_costs)\n            unit_idx = candidate_units[min_mc_idx]\n            max_add = max_output[unit_idx] - p_final[unit_idx]\n            add = min(residual, max_add)\n            p_final[unit_idx] += add\n            residual -= add\n            \n            if p_final[unit_idx] >= max_output[unit_idx]:\n                candidate_units.remove(unit_idx)\n    \n    return np.array([u_final, p_final])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     }
]