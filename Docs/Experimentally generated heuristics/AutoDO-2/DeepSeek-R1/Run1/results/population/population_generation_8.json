[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "hybrid_rolling_commitment_dispatch",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output exceeding shutdown capacity) and must-off units (offline with insufficient min-down time).  \n2. Initialize commitment states: must-on units to on, must-off units to off, flexible units to previous states.  \n3. Compute feasible power ranges for committed units considering ramp limits and startup capabilities.  \n4. Adjust commitment:  \n   - Over-committed (total min > load): Deactivate non-must-on units with highest min-power cost until feasible.  \n   - Under-committed (total max < load): Activate offline units with smallest cost/MW metric (startup + min-power cost)/min-power until feasible.  \n   - Adequate: Deactivate expensive non-must-on units if system remains adequate.  \n5. Dispatch:  \n   - If load <= total min: Set all to min output.  \n   - If load >= total max: Set all to max output.  \n   - Else: Perform constrained dispatch: set min outputs then increment based on marginal costs.  \n6. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np  \n\ndef hybrid_rolling_commitment_dispatch(units_info, load):  \n    n_units = len(units_info)  \n    current_load = load[0]  \n\n    must_on = [False] * n_units  \n    must_off = [False] * n_units  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):  \n                must_on[i] = True  \n        else:  \n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:  \n                must_off[i] = True  \n\n    u = [1 if must_on[i] else (0 if must_off[i] else units_info[i]['u_i_0']) for i in range(n_units)]  \n    L = [0] * n_units  \n    U = [0] * n_units  \n    for i, unit in enumerate(units_info):  \n        if u[i] == 1:  \n            if unit['u_i_0'] == 1:  \n                L[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n                U[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n            else:  \n                L[i] = unit['p_min_i']  \n                U[i] = min(unit['p_max_i'], unit['p_start_i'])  \n        else:  \n            L[i] = U[i] = 0  \n    total_min = sum(L)  \n    total_max = sum(U)  \n\n    def classify():  \n        if total_min > current_load: return 'over'  \n        elif total_max < current_load: return 'under'  \n        else: return 'adequate'  \n    state = classify()  \n\n    non_must_on_online = [i for i in range(n_units) if not must_on[i] and u[i]==1]  \n    available_offline = [i for i in range(n_units) if not must_off[i] and u[i]==0]  \n\n    if state == 'over':  \n        while non_must_on_online and state == 'over':  \n            costs = [(i, units_info[i]['a_i'] + units_info[i]['b_i']*L[i] + units_info[i]['c_i']*L[i]**2) for i in non_must_on_online]  \n            i_max = max(costs, key=lambda x: x[1])[0]  \n            u[i_max] = 0  \n            total_min -= L[i_max]  \n            total_max -= U[i_max]  \n            non_must_on_online.remove(i_max)  \n            state = classify()  \n\n    if state == 'under':  \n        while available_offline and state == 'under':  \n            metrics = []  \n            for i in available_offline:  \n                unit = units_info[i]  \n                min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2  \n                metric = (unit['s_i'] + min_cost) / unit['p_min_i']  \n                metrics.append((i, metric))  \n            i_min = min(metrics, key=lambda x: x[1])[0]  \n            u[i_min] = 1  \n            L[i_min] = units_info[i_min]['p_min_i']  \n            U[i_min] = min(units_info[i_min]['p_max_i'], units_info[i_min]['p_start_i'])  \n            total_min += L[i_min]  \n            total_max += U[i_min]  \n            available_offline.remove(i_min)  \n            state = classify()  \n\n    if state == 'adequate':  \n        non_must_on_online = [i for i in range(n_units) if not must_on[i] and u[i]==1]  \n        costs = [(i, units_info[i]['a_i'] + units_info[i]['b_i']*L[i] + units_info[i]['c_i']*L[i]**2) for i in non_must_on_online]  \n        for i, cost in sorted(costs, key=lambda x: x[1], reverse=True):  \n            new_min = total_min - L[i]  \n            new_max = total_max - U[i]  \n            if new_min <= current_load <= new_max:  \n                u[i] = 0  \n                total_min = new_min  \n                total_max = new_max  \n\n    if total_min >= current_load:  \n        p_output = [L[i] if u[i]==1 else 0.0 for i in range(n_units)]  \n    elif total_max <= current_load:  \n        p_output = [U[i] if u[i]==1 else 0.0 for i in range(n_units)]  \n    else:  \n        p_output = [L[i] if u[i]==1 else 0.0 for i in range(n_units)]  \n        residual = current_load - total_min  \n        active_units = [i for i in range(n_units) if u[i]==1]  \n        while residual > 1e-5:  \n            min_mc, best_i = float('inf'), -1  \n            for i in active_units:  \n                if p_output[i] < U[i]:  \n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_output[i]  \n                    if mc < min_mc:  \n                        min_mc, best_i = mc, i  \n            if best_i == -1: break  \n            inc = min(residual, U[best_i] - p_output[best_i])  \n            p_output[best_i] += inc  \n            residual -= inc  \n\n    schedules = np.zeros((2, n_units))  \n    for i in range(n_units):  \n        schedules[0, i] = u[i]  \n        schedules[1, i] = p_output[i]  \n    return schedules  ",
          "from": "crossover",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.0086286729,
          "fitness": 0.0068754583
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Identify must-run units (online with insufficient min-up time or previous output exceeding shutdown ramp) and must-off units (offline with insufficient min-down time)\n2. Initialize commitments: must-run on, must-off off, others retain previous state\n3. Compute feasible power ranges for committed units considering ramp constraints and startup/shutdown capabilities\n4. Calculate total min/max generation and adjust commitments:\n   a. Over-committed (total_min > load): Remove expensive non-must-run units in descending min-power cost order while maintaining system adequacy (min-gen \u2264 load and max-gen \u2265 load)\n   b. Under-committed (total_max < load): Activate most cost-effective offline units (min (startup_cost + min-power_cost)/min_power) until feasible\n   c. Adequate (total_min \u2264 load \u2264 total_max): Decommit expensive non-must-run units in descending min-power cost order while maintaining adequacy\n5. Perform constrained economic dispatch:\n   a. Over-committed: Set outputs to feasible minimum\n   b. Under-committed: Set outputs to feasible maximum\n   c. Adequate: Assign minimum feasible outputs, then distribute residual load to units with lowest marginal costs\n6. Set non-committed units to off state and zero output\n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Step 1: Identify must-run and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:  # Unit was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Initialize commitment states\n    for i, unit in enumerate(units_info):\n        if i in must_on:\n            unit['u_i'] = 1\n        elif i in must_off:\n            unit['u_i'] = 0\n        else:\n            unit['u_i'] = unit['u_i_0']\n    \n    # Dictionaries for feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    committed_indices = []\n    \n    # Step 3: Compute feasible power ranges for committed units\n    for i, unit in enumerate(units_info):\n        if unit['u_i'] == 1:\n            committed_indices.append(i)\n            if unit['u_i_0'] == 1:  # Remained online\n                p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Started this period\n                p_min_feasible[i] = unit['p_min_i']\n                p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate total min/max generation\n    total_min = sum(p_min_feasible[i] for i in committed_indices)\n    total_max = sum(p_max_feasible[i] for i in committed_indices)\n    \n    # Step 4: Adjust commitments based on system state\n    # (a) Over-committed case\n    if total_min > current_load:\n        non_must_on = [i for i in committed_indices if i not in must_on]\n        non_must_on.sort(key=lambda i: unit_cost(units_info[i], p_min_feasible[i]), reverse=True)\n        \n        for i in non_must_on:\n            new_min = total_min - p_min_feasible[i]\n            new_max = total_max - p_max_feasible[i]\n            if new_min <= current_load and new_max >= current_load:\n                units_info[i]['u_i'] = 0\n                p_min_feasible[i] = 0\n                p_max_feasible[i] = 0\n                total_min = new_min\n                total_max = new_max\n                committed_indices.remove(i)\n                if total_min <= current_load:\n                    break\n    \n    # (b) Under-committed case\n    if total_max < current_load:\n        available_units = [i for i in range(n_units) \n                          if units_info[i]['u_i'] == 0 and i not in must_off]\n        metrics = []\n        for i in available_units:\n            min_cost = unit_cost(units_info[i], units_info[i]['p_min_i'])\n            metric = (units_info[i]['s_i'] + min_cost) / units_info[i]['p_min_i']\n            metrics.append((i, metric))\n        metrics.sort(key=lambda x: x[1])\n        \n        for i, _ in metrics:\n            if total_max >= current_load:\n                break\n            units_info[i]['u_i'] = 1\n            committed_indices.append(i)\n            p_min_feasible[i] = units_info[i]['p_min_i']\n            p_max_feasible[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += p_min_feasible[i]\n            total_max += p_max_feasible[i]\n    \n    # (c) Adequate case (recompute in case state changed)\n    if total_min <= current_load <= total_max:\n        non_must_on = [i for i in committed_indices if i not in must_on]\n        non_must_on.sort(key=lambda i: unit_cost(units_info[i], p_min_feasible[i]), reverse=True)\n        \n        for i in non_must_on:\n            new_min = total_min - p_min_feasible[i]\n            new_max = total_max - p_max_feasible[i]\n            if new_min <= current_load <= new_max:\n                units_info[i]['u_i'] = 0\n                p_min_feasible[i] = 0\n                p_max_feasible[i] = 0\n                total_min = new_min\n                total_max = new_max\n                committed_indices.remove(i)\n    \n    # Recompute total min/max after adjustments\n    total_min = sum(p_min_feasible[i] for i in committed_indices)\n    total_max = sum(p_max_feasible[i] for i in committed_indices)\n    \n    # Step 5: Dispatch\n    # Initialize outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i'] == 1:\n            unit['p_i'] = p_min_feasible[i]\n        else:\n            unit['p_i'] = 0\n    \n    # Handle over/under commitment cases\n    if total_min > current_load:\n        pass  # Already set to min in initialization\n    elif total_max < current_load:\n        for i in committed_indices:\n            units_info[i]['p_i'] = p_max_feasible[i]\n    else:  # Economic dispatch\n        residual = current_load - total_min\n        if residual > 0:\n            units_sorted = sorted(\n                committed_indices,\n                key=lambda i: marginal_cost(units_info[i], units_info[i]['p_i'])\n            )\n            for i in units_sorted:\n                headroom = p_max_feasible[i] - units_info[i]['p_i']\n                if headroom > residual:\n                    units_info[i]['p_i'] += residual\n                    residual = 0\n                    break\n                else:\n                    units_info[i]['p_i'] += headroom\n                    residual -= headroom\n    \n    # Step 6: Prepare schedule output\n    schedules = np.zeros((2, n_units))\n    for i, unit in enumerate(units_info):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules\n\n# Helper functions for cost calculations\ndef unit_cost(unit, p):\n    return unit['a_i'] + unit['b_i'] * p + unit['c_i'] * p**2\n\ndef marginal_cost(unit, p):\n    return unit['b_i'] + 2 * unit['c_i'] * p",
          "from": "mutation",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.008773668,
          "fitness": 0.0069479559
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "hybrid_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or violation of shutdown ramp constraint) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state\n3. Calculate feasible power ranges for committed units considering ramp constraints and startup/shutdown limits\n4. Adjust commitment based on system adequacy:\n   - Under-committed: activate flexible units sorted by lowest (startup cost + min-power cost)/min-power\n   - Over-committed: decommit non-must-on units sorted by highest min-power operating cost\n   - Adequate: decommit non-must-on units sorted by highest min-power cost if system remains adequate\n5. Perform constrained economic dispatch using lambda iteration for committed units:\n   - Solve optimal dispatch via bisection on system lambda\n   - Adjust any residual load using greedy merit-order based on marginal costs\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    min_bound = [0.0] * n\n    max_bound = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    current_load = load[0]\n    \n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u_arr[i] = 1\n        elif must_off[i]:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n\n    # Step 3: Calculate feasible power ranges for committed units\n    for i, unit in enumerate(units_info):\n        if u_arr[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n\n    # Step 4: Adjust commitment based on system adequacy\n    total_min = sum(min_bound[i] for i in range(n) if u_arr[i] == 1)\n    total_max = sum(max_bound[i] for i in range(n) if u_arr[i] == 1)\n    \n    # Case A: Under-committed\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if not must_on[i] and not must_off[i] and u_arr[i] == 0]\n        metrics = []\n        for i in flexible_off:\n            unit = units_info[i]\n            startup_cost = unit['s_i']\n            min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            metric = (startup_cost + min_cost) / unit['p_min_i']\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for metric, i in metrics:\n            if total_max >= current_load:\n                break\n            u_arr[i] = 1\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Case B: Over-committed\n    if total_min > current_load:\n        non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n        costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n            costs.append((cost, i))\n        costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in costs:\n            if total_min <= current_load:\n                break\n            u_arr[i] = 0\n            total_min -= min_bound[i]\n            total_max -= max_bound[i]\n            min_bound[i] = 0\n            max_bound[i] = 0\n    \n    # Case C: Adequate - decommit expensive non-must-on units\n    non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n    costs = []\n    for i in non_must_on:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n        costs.append((cost, i))\n    costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in costs:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load <= new_max:\n            u_arr[i] = 0\n            total_min = new_min\n            total_max = new_max\n            min_bound[i] = 0\n            max_bound[i] = 0\n\n    # Step 5: Economic dispatch for committed units\n    committed_indices = [i for i in range(n) if u_arr[i] == 1]\n    l_dispatch = [min_bound[i] for i in committed_indices]\n    u_dispatch = [max_bound[i] for i in committed_indices]\n    b_dispatch = [units_info[i]['b_i'] for i in committed_indices]\n    c_dispatch = [units_info[i]['c_i'] for i in committed_indices]\n    p_dispatch = l_dispatch[:] if committed_indices else []\n    residual = current_load - sum(p_dispatch)\n    \n    # Lambda iteration for dispatch\n    if committed_indices:\n        tol = 0.001\n        max_iter = 1000\n        low_lambda = float('inf')\n        high_lambda = float('-inf')\n        \n        for i in range(len(committed_indices)):\n            mc_low = b_dispatch[i] + 2 * c_dispatch[i] * l_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            mc_high = b_dispatch[i] + 2 * c_dispatch[i] * u_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            if mc_low < low_lambda:\n                low_lambda = mc_low\n            if mc_high > high_lambda:\n                high_lambda = mc_high\n        \n        lambda_low = min(low_lambda - 1.0, 0)\n        lambda_high = high_lambda + 1.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in range(len(committed_indices)):\n                if c_dispatch[i] == 0:\n                    if lambda_mid < b_dispatch[i]:\n                        p_dispatch[i] = l_dispatch[i]\n                    elif lambda_mid > b_dispatch[i]:\n                        p_dispatch[i] = u_dispatch[i]\n                    else:\n                        p_dispatch[i] = l_dispatch[i]\n                else:\n                    p = (lambda_mid - b_dispatch[i]) / (2.0 * c_dispatch[i])\n                    p_dispatch[i] = min(u_dispatch[i], max(l_dispatch[i], p))\n                total_gen += p_dispatch[i]\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > tol:\n            # Residual >0: distribute to units with cheapest marginal cost\n            if residual > 0:\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] < u_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    min_mc = min(mc_list, key=lambda x: x[0])\n                    i = min_mc[1]\n                    add = min(residual, u_dispatch[i] - p_dispatch[i])\n                    p_dispatch[i] += add\n                    residual -= add\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] < u_dispatch[j]]\n            # Residual <0: reduce from units with highest marginal cost\n            else:\n                residual = abs(residual)\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] > l_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    max_mc = max(mc_list, key=lambda x: x[0])\n                    i = max_mc[1]\n                    reduce_by = min(residual, p_dispatch[i] - l_dispatch[i])\n                    p_dispatch[i] -= reduce_by\n                    residual -= reduce_by\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] > l_dispatch[j]]\n        \n        # Assign dispatched power to output array\n        for idx, p_val in zip(committed_indices, p_dispatch):\n            p_arr[idx] = p_val\n    \n    # Build return array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_arr[i]\n        schedules[1, i] = p_arr[i]\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049948693,
          "gap_price_rate": 0.0092619027,
          "fitness": 0.007128386
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "hybrid_enhanced_dispatch",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output exceeding shutdown ramp limit) and must-off units (offline with insufficient min-down time).\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state.\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints.\n4. Calculate total min/max generation capacity from committed units.\n5. Adjust commitment:\n   a. For over-committed systems (total min > load): remove expensive non-must-on units until feasible.\n   b. For under-committed systems (total max < load): activate most cost-effective offline units considering startup costs.\n   c. For adequate systems: remove expensive non-must-on units if system adequacy holds.\n6. For dispatch:\n   - Set must-off and non-committed units to off with zero output.\n   - For committed units:\n        - If load <= total min: set to minimum output.\n        - If load >= total max: set to maximum output.\n        - Otherwise: perform lambda iteration for economic dispatch.\n   - Resolve any residual load with greedy adjustment.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    u_i = [0] * n_units\n    for i in must_on:\n        u_i[i] = 1\n    for i in must_off:\n        u_i[i] = 0\n    for i in range(n_units):\n        if i not in must_on and i not in must_off:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    # Initialize min/max output constraints\n    min_p_i = [0] * n_units\n    max_p_i = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n    \n    # Commitment adjustment logic\n    if total_min > current_load:  # Over-committed\n        non_forced = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        cost_list = []\n        for i in non_forced:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            cost = a + b * min_p_i[i] + c * min_p_i[i] ** 2\n            cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in cost_list:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            min_p_i[i] = 0\n            max_p_i[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    elif total_max < current_load:  # Under-committed\n        non_forced_off = [i for i in range(n_units) if u_i[i] == 0 and i not in must_off]\n        candidate_list = []\n        for i in non_forced_off:\n            s = units_info[i]['s_i']\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            min_p_val = units_info[i]['p_min_i']\n            cost_min = a + b * min_p_val + c * min_p_val ** 2\n            avg_cost = (s + cost_min) / min_p_val if min_p_val > 0 else float('inf')\n            candidate_list.append((avg_cost, i))\n        candidate_list.sort(key=lambda x: x[0])\n        for avg_cost, i in candidate_list:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            min_p_val = units_info[i]['p_min_i']\n            max_p_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_p_i[i] = min_p_val\n            max_p_i[i] = max_p_val\n            total_min += min_p_val\n            total_max += max_p_val\n    \n    else:  # Adequately committed\n        non_forced = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        cost_list = []\n        for i in non_forced:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            cost = a + b * min_p_i[i] + c * min_p_i[i] ** 2\n            cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in cost_list:\n            new_min = total_min - min_p_i[i]\n            new_max = total_max - max_p_i[i]\n            if new_min <= current_load <= new_max:\n                u_i[i] = 0\n                min_p_i[i] = 0\n                max_p_i[i] = 0\n                total_min = new_min\n                total_max = new_max\n    \n    # Update min/max for adjusted commitments\n    for i in range(n_units):\n        if u_i[i] == 1 and min_p_i[i] > max_p_i[i]:\n            min_p_i[i] = max_p_i[i] = (min_p_i[i] + max_p_i[i]) / 2\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n    \n    # Dispatch\n    p_i = [0] * n_units\n    if total_min >= current_load:\n        for i in range(n_units):\n            p_i[i] = min_p_i[i] if u_i[i] == 1 else 0\n    elif total_max <= current_load:\n        for i in range(n_units):\n            p_i[i] = max_p_i[i] if u_i[i] == 1 else 0\n    else:\n        committed_idx = [i for i in range(n_units) if u_i[i] == 1]\n        a_vals = [units_info[i]['a_i'] for i in committed_idx]\n        b_vals = [units_info[i]['b_i'] for i in committed_idx]\n        c_vals = [units_info[i]['c_i'] for i in committed_idx]\n        min_vals = [min_p_i[i] for i in committed_idx]\n        max_vals = [max_p_i[i] for i in committed_idx]\n        n_committed = len(committed_idx)\n        \n        # Lambda iteration setup\n        low = min(b_vals[j] + 2 * c_vals[j] * min_vals[j] for j in range(n_committed))\n        high = max(b_vals[j] + 2 * c_vals[j] * max_vals[j] for j in range(n_committed))\n        tol = 0.01\n        \n        # Perform bisection\n        for _ in range(100):\n            mid = (low + high) / 2\n            total_p = 0\n            for j in range(n_committed):\n                if c_vals[j] == 0:\n                    p_val = max_vals[j] if mid >= b_vals[j] else min_vals[j]\n                else:\n                    p_val = (mid - b_vals[j]) / (2 * c_vals[j])\n                    p_val = max(min_vals[j], min(max_vals[j], p_val))\n                total_p += p_val\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n            \n            if high - low < tol:\n                break\n        \n        # Apply final lambda value\n        lambda_final = (low + high) / 2\n        total_p = 0\n        for j in range(n_committed):\n            if c_vals[j] == 0:\n                p_val = max_vals[j] if lambda_final >= b_vals[j] else min_vals[j]\n            else:\n                p_val = (lambda_final - b_vals[j]) / (2 * c_vals[j])\n                p_val = max(min_vals[j], min(max_vals[j], p_val))\n            total_p += p_val\n            p_i[committed_idx[j]] = p_val\n        \n        # Greedy residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                # Sort units with available capacity by marginal cost\n                candidates = []\n                for j in range(n_committed):\n                    i_idx = committed_idx[j]\n                    mc = b_vals[j] + 2 * c_vals[j] * p_i[i_idx]\n                    if p_i[i_idx] < max_vals[j]:\n                        candidates.append((mc, i_idx, j))\n                candidates.sort()\n                for mc, i_idx, j in candidates:\n                    if residual <= 0:\n                        break\n                    add = min(residual, max_vals[j] - p_i[i_idx])\n                    p_i[i_idx] += add\n                    residual -= add\n            else:\n                # Sort units by marginal cost descending\n                candidates = []\n                for j in range(n_committed):\n                    i_idx = committed_idx[j]\n                    mc = b_vals[j] + 2 * c_vals[j] * p_i[i_idx]\n                    if p_i[i_idx] > min_vals[j]:\n                        candidates.append((mc, i_idx, j))\n                candidates.sort(reverse=True)\n                for mc, i_idx, j in candidates:\n                    if residual >= 0:\n                        break\n                    reduce_val = min(-residual, p_i[i_idx] - min_vals[j])\n                    p_i[i_idx] -= reduce_val\n                    residual += reduce_val\n    \n    # Format output\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054283885,
          "gap_price_rate": 0.0090999183,
          "fitness": 0.0072641534
     },
     {
          "name": "adaptive_commitment_lambda_dispatch",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or previous output exceeding shutdown ramp) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, flexible units to previous state\n3. Compute feasible power ranges for all units considering ramp and startup/shutdown constraints\n4. Calculate total min/max generation capacity from committed units and classify system state:\n   - Over-committed: total min > current load\n   - Under-committed: total max < current load\n   - Adequate: load within feasible range\n5. Adjust commitment state:\n   - Over-committed: Deactivate non-must-on units with highest operating cost at minimum output until feasible\n   - Under-committed: Activate most cost-effective offline units (startup cost + min-power cost) until capacity meets demand\n   - Adequate: Deactivate expensive non-must-on units if adequacy holds\n6. Perform constrained economic dispatch:\n   - Use lambda iteration to determine optimal generation levels\n   - Adjust for any residual load using greedy merit-order based on marginal costs\n7. Set non-committed units to off with zero output\n8. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef adaptive_commitment_lambda_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    load_current = load[0]\n    \n    # Precompute feasible power ranges\n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0']:\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[i] = unit['p_min_i']\n            ub[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0']:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Adjust commitment based on system adequacy\n    committed_indices = np.where(u == 1)[0]\n    total_min = sum(lb[i] for i in committed_indices)\n    total_max = sum(ub[i] for i in committed_indices)\n    \n    # Over-committed: deactivate expensive non-must-on units\n    if total_min > load_current:\n        non_must_on = [i for i in committed_indices if i not in must_on]\n        # Sort by operating cost at min power descending\n        non_must_on.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*lb[i] + units_info[i]['c_i']*lb[i]**2, reverse=True)\n        for unit_idx in non_must_on:\n            if total_min - lb[unit_idx] <= load_current and total_max - ub[unit_idx] >= load_current:\n                u[unit_idx] = 0\n                total_min -= lb[unit_idx]\n                total_max -= ub[unit_idx]\n            if total_min <= load_current:\n                break\n    \n    # Under-committed: activate cheapest offline units\n    elif total_max < load_current:\n        flexible_off = [i for i in range(n_units) if u[i]==0 and i not in must_off]\n        # Sort by cost per MW at min power (including startup cost)\n        flexible_off.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*lb[i] + units_info[i]['c_i']*lb[i]**2) / lb[i] if lb[i] > 0 else float('inf'))\n        for unit_idx in flexible_off:\n            u[unit_idx] = 1\n            total_min += lb[unit_idx]\n            total_max += ub[unit_idx]\n            if total_max >= load_current:\n                break\n    \n    # Adequate: remove expensive non-must-on units if possible\n    else:\n        non_must_on = [i for i in np.where(u==1)[0] if i not in must_on]\n        # Sort by operating cost at min power descending\n        non_must_on.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*lb[i] + units_info[i]['c_i']*lb[i]**2, reverse=True)\n        for unit_idx in non_must_on:\n            new_min = total_min - lb[unit_idx]\n            new_max = total_max - ub[unit_idx]\n            if new_min <= load_current and new_max >= load_current:\n                u[unit_idx] = 0\n                total_min = new_min\n                total_max = new_max\n    \n    # Economic dispatch using lambda iteration\n    committed_indices = np.where(u == 1)[0]\n    lb_committed = np.array([lb[i] for i in committed_indices])\n    ub_committed = np.array([ub[i] for i in committed_indices])\n    a = np.array([units_info[i]['a_i'] for i in committed_indices])\n    b = np.array([units_info[i]['b_i'] for i in committed_indices])\n    c = np.array([units_info[i]['c_i'] for i in committed_indices])\n    \n    # Initial lambda bounds\n    if len(committed_indices) > 0:\n        marginal_min = b + 2*c*lb_committed\n        marginal_max = b + 2*c*ub_committed\n        lambda_low = np.min(marginal_min)\n        lambda_high = np.max(marginal_max)\n    else:\n        lambda_low = lambda_high = 0\n    \n    # Lambda iteration\n    tolerance = 1e-5\n    p_dispatch = lb_committed.copy()\n    for _ in range(100):\n        if abs(lambda_high - lambda_low) < tolerance:\n            break\n        lambda_mid = (lambda_low + lambda_high) / 2\n        # Calculate desired power outputs\n        p_desired = np.clip((lambda_mid - b) / (2*c), lb_committed, ub_committed)\n        total_gen = np.sum(p_desired)\n        \n        if total_gen < load_current:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        p_dispatch = p_desired\n    \n    # Handle residual load\n    residual = load_current - np.sum(p_dispatch)\n    if abs(residual) > tolerance:\n        if residual > 0:  # Increase generation\n            idx_inc = np.where(p_dispatch < ub_committed)[0]\n            if len(idx_inc) > 0:\n                marginal_costs = b[idx_inc] + 2*c[idx_inc]*p_dispatch[idx_inc]\n                sorted_idx = np.argsort(marginal_costs)\n                for i in sorted_idx:\n                    unit_idx = idx_inc[i]\n                    available = ub_committed[unit_idx] - p_dispatch[unit_idx]\n                    allocation = min(available, residual)\n                    p_dispatch[unit_idx] += allocation\n                    residual -= allocation\n                    if residual <= 0:\n                        break\n        else:  # Decrease generation\n            residual = -residual\n            idx_dec = np.where(p_dispatch > lb_committed)[0]\n            if len(idx_dec) > 0:\n                marginal_costs = b[idx_dec] + 2*c[idx_dec]*p_dispatch[idx_dec]\n                sorted_idx = np.argsort(marginal_costs)[::-1]\n                for i in sorted_idx:\n                    unit_idx = idx_dec[i]\n                    available = p_dispatch[unit_idx] - lb_committed[unit_idx]\n                    allocation = min(available, residual)\n                    p_dispatch[unit_idx] -= allocation\n                    residual -= allocation\n                    if residual <= 0:\n                        break\n    \n    # Set outputs\n    for idx, unit_idx in enumerate(committed_indices):\n        p[unit_idx] = max(lb[unit_idx], min(ub[unit_idx], p_dispatch[idx]))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285359,
          "gap_price_rate": 0.0091002177,
          "fitness": 0.0072643768
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Identify must-run and must-off units based on min up/down times and shutdown constraints\n2. Initialize commitment states using forced status and previous states\n3. Compute current power ranges and check system adequacy\n4. If under-committed (total capacity < load), activate units by lowest average cost\n5. If over-committed (min capacity > load), deactivate non-essential units by highest operating cost\n6. Optimize adequate systems by turning off expensive non-essential units\n7. Perform economic dispatch using priority queue based on marginal costs\n",
          "code": "import heapq\nimport numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    # Initialize lists for must-run, must-off, and commitment state\n    must_commit = [False] * n\n    must_off = [False] * n\n    u_i = [0] * n\n    \n    # Step 1: Determine forced units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_commit[i] = True\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n                \n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_commit[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    # Helper function to compute power limits\n    def compute_power_limits(i, state):\n        if state == 0:\n            return 0, 0\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Starting unit\n            p_min_i = unit['p_min_i']\n            p_max_i = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        else:  # Running unit\n            p_min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return p_min_i, p_max_i\n    \n    # Initialize power limits arrays\n    p_min_arr = [0] * n\n    p_max_arr = [0] * n\n    for i in range(n):\n        p_min_arr[i], p_max_arr[i] = compute_power_limits(i, u_i[i])\n    \n    total_min = sum(p_min_arr)\n    total_max = sum(p_max_arr)\n    \n    # Step 3a: Handle under-committed case\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if u_i[i] == 0 and not must_off[i]]\n        def avg_cost(i):\n            unit = units_info[i]\n            min_power = unit['p_min_i']\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n        flexible_off.sort(key=avg_cost)\n        \n        for i in flexible_off:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            new_min, new_max = compute_power_limits(i, 1)\n            total_min = total_min + new_min\n            total_max = total_max + new_max\n            p_min_arr[i] = new_min\n            p_max_arr[i] = new_max\n    \n    # Step 3b: Handle over-committed case\n    if total_min > current_load:\n        flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            total_min -= p_min_arr[i]\n            total_max -= p_max_arr[i]\n            p_min_arr[i] = 0\n            p_max_arr[i] = 0\n    \n    # Step 3c: Optimize adequate case\n    flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n    if total_min <= current_load <= total_max:\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            new_total_min = total_min - p_min_arr[i]\n            new_total_max = total_max - p_max_arr[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                p_min_arr[i] = 0\n                p_max_arr[i] = 0\n    \n    # Finalize power limits\n    for i in range(n):\n        if u_i[i] == 1:\n            p_min_arr[i], p_max_arr[i] = compute_power_limits(i, 1)\n        else:\n            p_min_arr[i], p_max_arr[i] = 0, 0\n    \n    # Step 4: Economic Dispatch\n    p_i = [0] * n\n    committed_indices = [i for i in range(n) if u_i[i] == 1]\n    for i in committed_indices:\n        p_i[i] = p_min_arr[i]\n    \n    total_output = sum(p_i)\n    remaining = current_load - total_output\n    heap = []\n    \n    # Initialize priority queue\n    for i in committed_indices:\n        if p_i[i] < p_max_arr[i]:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    # Dispatch remaining load\n    while remaining > 1e-5 and heap:\n        mc, idx = heapq.heappop(heap)\n        max_inc = min(remaining, p_max_arr[idx] - p_i[idx])\n        p_i[idx] += max_inc\n        remaining -= max_inc\n        if p_i[idx] < p_max_arr[idx]:\n            new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_i[idx]\n            heapq.heappush(heap, (new_mc, idx))\n    \n    # Create and return schedule\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0062438914,
          "gap_price_rate": 0.0084205625,
          "fitness": 0.007332227
     }
]