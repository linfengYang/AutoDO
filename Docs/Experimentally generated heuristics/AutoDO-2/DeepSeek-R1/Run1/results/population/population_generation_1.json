[
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into three categories based on constraints:\n   - Must-on: Units forced to remain on due to min-up time or shutdown capacity violation.\n   - Must-off: Units forced to remain off due to min-down time constraints.\n   - Flexible: Units that can be turned on or off.\n2. For must-on units, compute feasible output ranges considering ramp limits.\n3. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) output from must-on units.\n4. Based on current load and total must-on capacity:\n   a. If load is within must-on capacity: Dispatch load optimally among must-on units using lambda iteration.\n   b. If load < total must-on minimum: Set must-on units to minimum, others off.\n   c. If load > total must-on maximum: Turn on flexible units in priority order (cheapest average cost first) until demand is covered, then dispatch optimally among all online units.\n5. For must-off units: Set to off state and zero output.\n6. Return 2D array with commitment states (u_i) and outputs (p_i).\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_for_dispatch, load):\n    L_arr = np.array([u['L'] for u in units_for_dispatch])\n    U_arr = np.array([u['U'] for u in units_for_dispatch])\n    total_min = np.sum(L_arr)\n    total_max = np.sum(U_arr)\n    n = len(units_for_dispatch)\n    \n    if load <= total_min:\n        return L_arr.tolist()\n    elif load >= total_max:\n        return U_arr.tolist()\n    else:\n        low = float('inf')\n        high = -float('inf')\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                mc_low = u['b_i'] + 2*u['c_i'] * u['L']\n                mc_high = u['b_i'] + 2*u['c_i'] * u['U']\n                low = min(low, mc_low)\n                high = max(high, mc_high)\n            else:\n                low = min(low, u['b_i'])\n                high = max(high, u['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_power = 0\n            for u in units_for_dispatch:\n                if u['c_i'] > 0:\n                    p = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n                else:\n                    p = u['U'] if mid >= u['b_i'] else u['L']\n                total_power += p\n            if abs(total_power - load) < tol:\n                break\n            if total_power < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_list = []\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                p_val = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n            else:\n                p_val = u['U'] if mid >= u['b_i'] else u['L']\n            p_list.append(p_val)\n        \n        return p_list\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_periods = -unit['t_i_0']\n            if offline_periods < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    L_must_on = []\n    U_must_on = []\n    for i in must_on:\n        unit = units[i]\n        L = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        U = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        L_must_on.append(L)\n        U_must_on.append(U)\n    \n    total_min = sum(L_must_on) if must_on else 0\n    total_max = sum(U_must_on) if must_on else 0\n    schedules = np.zeros((2, len(units)))\n    \n    if total_min <= current_load <= total_max:\n        units_for_dispatch = []\n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    elif current_load < total_min:\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = L_must_on[idx]\n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    else:\n        flex_candidates = []\n        for i in flexible:\n            unit = units[i]\n            avg_cost = (unit['s_i'] + unit['a_i'] + \n                        unit['b_i']*unit['p_min_i'] + \n                        unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            flex_candidates.append((avg_cost, i))\n        flex_candidates.sort(key=lambda x: x[0])\n        \n        selected_flex = []\n        cum_added = 0\n        deficit = current_load - total_max\n        for _, i in flex_candidates:\n            capacity = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            selected_flex.append(i)\n            cum_added += capacity\n            if cum_added >= deficit:\n                break\n        \n        on_units_indices = must_on + selected_flex\n        units_for_dispatch = []\n        L_dict = {}\n        U_dict = {}\n        \n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            L_dict[i] = L_val\n            U_dict[i] = U_val\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        \n        for i in selected_flex:\n            unit = units[i]\n            L_dict[i] = unit['p_min_i']\n            U_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_dict[i],\n                'U': U_dict[i]\n            })\n        \n        total_min_dispatch = sum(L_dict[i] for i in on_units_indices)\n        total_max_dispatch = sum(U_dict[i] for i in on_units_indices)\n        \n        if current_load < total_min_dispatch:\n            dispatch_result = [L_dict[i] for i in on_units_indices]\n        elif current_load > total_max_dispatch:\n            dispatch_result = [U_dict[i] for i in on_units_indices]\n        else:\n            dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        \n        for idx, i in enumerate(on_units_indices):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in on_units_indices:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    for i in must_off:\n        schedules[0][i] = 0\n        schedules[1][i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058061183,
          "gap_price_rate": 0.0091680778,
          "fitness": 0.0074870981
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-run (due to min-up/shutdown constraints), must-off (due to min-down time), and flexible (remaining units).\n2. Compute feasible power range for each unit based on ramp limits and startup/shutdown constraints.\n3. Calculate base load from must-run units set to minimum feasible power.\n4. Sort flexible units by average cost per MW (including startup cost if turned on) at minimum power.\n5. Activate flexible units in order of increasing cost until cumulative maximum capacity meets or exceeds current load.\n6. Perform economic dispatch:\n   - If minimum base load exceeds current load, set all committed units to minimum power.\n   - Otherwise, distribute remaining load among committed units using greedy adjustment based on marginal cost.\n7. Set non-committed units to off state with zero power output.\n8. Return schedule with commitment states and dispatch levels.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u_commit = [0] * n_units\n    p_dispatch = [0] * n_units\n    min_power = [0] * n_units\n    max_power = [0] * n_units\n    must_run = []\n    must_off = []\n    flex = []\n\n    # Precompute min/max power and classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pstart = unit['p_start_i']\n        pshut = unit['p_shut_i']\n        minup = unit['t_on_min_i']\n        mindown = unit['t_off_min_i']\n        \n        # Compute feasible power range\n        if u0 == 1:\n            min_power[i] = max(pmin, p0 - pdown)\n            max_power[i] = min(pmax, p0 + pup)\n            if t0 < minup or p0 > pshut:\n                must_run.append(i)\n                u_commit[i] = 1\n            else:\n                flex.append(i)\n        else:\n            min_power[i] = pmin\n            max_power[i] = min(pmax, pstart)\n            if abs(t0) < mindown:\n                must_off.append(i)\n                u_commit[i] = 0\n            else:\n                flex.append(i)\n    \n    # Calculate base capacity from must-run units\n    base_min = sum(min_power[i] for i in must_run)\n    base_max = sum(max_power[i] for i in must_run)\n    flex_costs = []\n    flex_idx = []\n\n    # Calculate average cost per MW for flexible units\n    for i in flex:\n        unit = units_info[i]\n        minp = min_power[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost_val = a + b * minp + c * minp**2 + s\n        cost_per_mw = cost_val / minp if minp > 0 else float('inf')\n        flex_costs.append(cost_per_mw)\n        flex_idx.append(i)\n    \n    # Sort flexible units by cost (lowest first)\n    sorted_flex = sorted(zip(flex_idx, flex_costs), key=lambda x: x[1])\n    flex_sorted = [x[0] for x in sorted_flex]\n    committed_flex = []\n    curr_min = base_min\n    curr_max = base_max\n\n    # Commit flexible units until capacity meets load\n    for i in flex_sorted:\n        if curr_max < load[0]:\n            committed_flex.append(i)\n            u_commit[i] = 1\n            curr_min += min_power[i]\n            curr_max += max_power[i]\n        else:\n            break\n    \n    # Set initial dispatch to minimum power for committed units\n    for i in must_run + committed_flex:\n        p_dispatch[i] = min_power[i]\n    active_units = must_run + committed_flex\n    total_power = curr_min\n\n    # Economic dispatch: distribute remaining load\n    if total_power < load[0]:\n        need = load[0] - total_power\n        while need > 0 and active_units:\n            best_unit = None\n            best_marginal = float('inf')\n            # Find unit with lowest marginal cost\n            for i in active_units:\n                p_i = p_dispatch[i]\n                if p_i < max_power[i]:\n                    marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n            if best_unit is None:\n                break\n            # Calculate maximum possible increase\n            room = max_power[best_unit] - p_dispatch[best_unit]\n            delta = min(need, room)\n            p_dispatch[best_unit] += delta\n            need -= delta\n            # Remove unit if at maximum\n            if p_dispatch[best_unit] >= max_power[best_unit]:\n                active_units.remove(best_unit)\n    # Set non-committed units to off state\n    for i in set(range(n_units)) - set(must_run + committed_flex):\n        u_commit[i] = 0\n        p_dispatch[i] = 0\n    \n    return np.array([u_commit, p_dispatch])",
          "from": null,
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "commit_units_with_forced_constraints",
          "algorithm": "1. Identify units that are forced to stay on (due to minimum up-time or shutdown ramp constraints) or forced to stay off (due to minimum down-time constraints).\n2. Calculate the minimum and maximum output limits for forced-on units considering their ramp constraints.\n3. Sort candidate units (non-forced and not forced off) by average cost per MWh at minimum output.\n4. Commit candidate units in order of priority until the total maximum output can meet the current load.\n5. For committed units, compute actual output bounds considering ramp constraints and whether the unit is starting.\n6. If the load is below the total minimum output of committed units, set outputs to their minimum values.\n7. If the load exceeds the total maximum output of committed units, set outputs to their maximum values.\n8. For loads within the feasible range, perform economic dispatch using a greedy algorithm that increases the unit with the smallest marginal cost until the load is met.\n9. Output the commitment status and power output for each unit.\n\n",
          "code": "import numpy as np\n\ndef commit_units_with_forced_constraints(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    low_bound = [0.0] * n_units\n    high_bound = [0.0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            p_i_prev = units_info[i]['p_i_0']\n            low_bound[i] = max(units_info[i]['p_min_i'], p_i_prev - units_info[i]['p_down_i'])\n            high_bound[i] = min(units_info[i]['p_max_i'], p_i_prev + units_info[i]['p_up_i'])\n        elif forced_off[i]:\n            low_bound[i] = 0.0\n            high_bound[i] = 0.0\n    \n    forced_on_set = set(i for i in range(n_units) if forced_on[i])\n    T_min_total = sum(low_bound[i] for i in forced_on_set)\n    T_max_total = sum(high_bound[i] for i in forced_on_set)\n    \n    candidate_units = []\n    for i in range(n_units):\n        if not forced_on[i] and not forced_off[i]:\n            candidate_units.append(i)\n    \n    def compute_avg_cost(i):\n        unit = units_info[i]\n        if unit['p_min_i'] == 0:\n            return float('inf')\n        cost_start = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        return cost_start / unit['p_min_i']\n    \n    candidate_units.sort(key=compute_avg_cost)\n    S = set(forced_on_set)\n    \n    for i in candidate_units:\n        if T_max_total >= load[0]:\n            break\n        low_candidate = units_info[i]['p_min_i']\n        high_candidate = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        S.add(i)\n        T_min_total += low_candidate\n        T_max_total += high_candidate\n    \n    low_bound_S = {}\n    high_bound_S = {}\n    for i in S:\n        if units_info[i]['u_i_0'] == 1:\n            p_i_prev = units_info[i]['p_i_0']\n            low_bound_S[i] = max(units_info[i]['p_min_i'], p_i_prev - units_info[i]['p_down_i'])\n            high_bound_S[i] = min(units_info[i]['p_max_i'], p_i_prev + units_info[i]['p_up_i'])\n        else:\n            low_bound_S[i] = units_info[i]['p_min_i']\n            high_bound_S[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    T_min_S = sum(low_bound_S.get(i, 0) for i in S)\n    T_max_S = sum(high_bound_S.get(i, 0) for i in S)\n    L = load[0]\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if L <= T_min_S:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = low_bound_S[i]\n    elif L >= T_max_S:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = high_bound_S[i]\n    else:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = low_bound_S[i]\n        total_p = T_min_S\n        active_set = set(i for i in S if p_out[i] < high_bound_S[i] - 1e-6)\n        \n        while total_p < L and active_set:\n            min_mc = float('inf')\n            candidate = None\n            for i in active_set:\n                if units_info[i]['c_i'] == 0:\n                    mc = units_info[i]['b_i']\n                else:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n            \n            if candidate is None:\n                break\n                \n            max_inc = high_bound_S[candidate] - p_out[candidate]\n            inc = min(max_inc, L - total_p)\n            p_out[candidate] += inc\n            total_p += inc\n            if p_out[candidate] >= high_bound_S[candidate] - 1e-6:\n                active_set.remove(candidate)\n    \n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u_out\n    schedules[1, :] = p_out\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "adaptive_priority_rolling_commitment",
          "algorithm": "1. Determine must-commit and must-off units based on min up/down time and shutdown ramp constraints  \n2. Compute minimum/maximum power from committed units considering ramp limits  \n3. Classify commitment case (under, over, adequate) with candidate units  \n4. For under-committed: Start cheapest candidate units until load can be met  \n5. For over-committed: Turn off expensive candidate units to reduce minimum generation  \n6. For adequate: Optimize by turning off expensive non-essential units  \n7. Perform constrained economic dispatch using greedy incremental cost allocation  \n8. Return commitment and dispatch schedule  \n\n",
          "code": "import numpy as np  \n\ndef adaptive_priority_rolling_commitment(units_info, load):  \n    current_load = load[0]  \n    next_load_forecast = load[1]  \n    n_units = len(units_info)  \n    schedules = np.zeros((2, n_units))  \n    committed = [False] * n_units  \n    min_output = [0.0] * n_units  \n    max_output = [0.0] * n_units  \n    forced_on = [False] * n_units  \n    forced_off = [False] * n_units  \n    candidate_off = []  \n    candidate_on = []  \n    \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_up = unit['p_up_i']  \n        p_down = unit['p_down_i']  \n        p_start = unit['p_start_i']  \n        p_shut = unit['p_shut_i']  \n        t_on_min = unit['t_on_min_i']  \n        t_off_min = unit['t_off_min_i']  \n        \n        if u_i0 == 1:  \n            min_output[i] = max(p_min, p_i0 - p_down)  \n            max_output[i] = min(p_max, p_i0 + p_up)  \n            if t_i0 < t_on_min:  \n                committed[i] = True  \n                forced_on[i] = True  \n            elif p_i0 > p_shut:  \n                committed[i] = True  \n                forced_on[i] = True  \n            else:  \n                candidate_off.append(i)  \n        else:  \n            min_output[i] = p_min  \n            max_output[i] = min(p_max, p_start)  \n            if abs(t_i0) < t_off_min:  \n                committed[i] = False  \n                forced_off[i] = True  \n            else:  \n                candidate_on.append(i)  \n    \n    min_forced = sum(min_output[i] for i in range(n_units) if forced_on[i])  \n    max_forced = sum(max_output[i] for i in range(n_units) if forced_on[i])  \n    min_candidate_off = sum(min_output[i] for i in candidate_off)  \n    max_candidate_off = sum(max_output[i] for i in candidate_off)  \n    total_min = min_forced + min_candidate_off  \n    total_max = max_forced + max_candidate_off  \n    \n    if current_load > total_max:  \n        case = 'under'  \n    elif current_load < min_forced:  \n        case = 'over'  \n    else:  \n        case = 'adequate'  \n    \n    turned_off = []  \n    started = []  \n    \n    if case == 'under':  \n        candidate_on_sorted = sorted(  \n            candidate_on,  \n            key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_output[i]  \n        )  \n        for i in candidate_on_sorted:  \n            if total_max >= current_load:  \n                break  \n            unit = units_info[i]  \n            total_min += min_output[i]  \n            total_max += max_output[i]  \n            committed[i] = True  \n            started.append(i)  \n    \n    elif case == 'over':  \n        cost_candidate_off = [  \n            (i, units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] +  \n             units_info[i]['c_i'] * min_output[i]**2)  \n            for i in candidate_off  \n        ]  \n        candidate_off_sorted = sorted(cost_candidate_off, key=lambda x: x[1], reverse=True)  \n        turned_off = []  \n        for i, cost_val in candidate_off_sorted:  \n            new_min = total_min - min_output[i]  \n            new_max = total_max - max_output[i]  \n            if new_min <= current_load <= new_max:  \n                turned_off.append(i)  \n                total_min = new_min  \n                total_max = new_max  \n            if total_min <= current_load:  \n                break  \n        for i in turned_off:  \n            committed[i] = False  \n            candidate_off.remove(i)  \n    \n    else:  \n        cost_candidate_off = [  \n            (i, units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] +  \n             units_info[i]['c_i'] * min_output[i]**2)  \n            for i in candidate_off  \n        ]  \n        candidate_off_sorted = sorted(cost_candidate_off, key=lambda x: x[1], reverse=True)  \n        for i, cost_val in candidate_off_sorted:  \n            new_min = total_min - min_output[i]  \n            new_max = total_max - max_output[i]  \n            if new_min <= current_load <= new_max:  \n                committed[i] = False  \n                total_min = new_min  \n                total_max = new_max  \n    \n    # Initialize dispatch and adjust for ramp constraints  \n    p_alloc = [0.0] * n_units  \n    allocated = 0.0  \n    residual = current_load  \n    increments = []  \n    \n    for i in range(n_units):  \n        if not committed[i]:  \n            continue  \n        unit = units_info[i]  \n        if forced_off[i] or not committed[i]:  \n            continue  \n        u_i0 = unit['u_i_0']  \n        p_i0 = unit['p_i_0']  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_up = unit['p_up_i']  \n        p_down = unit['p_down_i']  \n        p_start = unit['p_start_i']  \n        b_i = unit['b_i']  \n        c_i = unit['c_i']  \n        \n        if u_i0 == 1:  \n            p_low = max(p_min, p_i0 - p_down)  \n            p_high = min(p_max, p_i0 + p_up)  \n        else:  \n            p_low = p_min  \n            p_high = min(p_max, p_start)  \n        \n        p_alloc[i] = p_low  \n        residual -= p_low  \n        avail = p_high - p_low  \n        marginal_cost = b_i + 2 * c_i * p_low  \n        increments.append((i, marginal_cost, avail))  \n    \n    if residual > 0:  \n        increments_sorted = sorted(increments, key=lambda x: x[1])  \n        for (i, mc, avail) in increments_sorted:  \n            if residual <= avail:  \n                p_alloc[i] += residual  \n                residual = 0  \n                break  \n            else:  \n                p_alloc[i] += avail  \n                residual -= avail  \n    \n    # Handle startup costs by setting commitment state  \n    for i in range(n_units):  \n        schedules[0, i] = int(committed[i])  \n        schedules[1, i] = p_alloc[i]  \n    \n    return schedules  ",
          "from": null,
          "gap_power_rate": 0.0101077905,
          "gap_price_rate": 0.010495207,
          "fitness": 0.0103014987
     },
     {
          "name": "rolling_commit_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_commit_heuristic(units_info, load):\n    n = len(units_info)\n    \n    # Extract parameters\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    # Initialize outputs\n    u = [0] * n\n    p = [0] * n\n    min_output = [0] * n\n    max_output = [0] * n\n    current_load = load[0]\n    forecast_load = load[1]  # Not used in this version\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i in range(n):\n        if u_i_0[i] == 1:\n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i_0[i] < t_off_min[i]:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    for i in must_on + free_on:\n        u[i] = 1\n        min_output[i] = max(p_min[i], p_i_0[i] - p_down[i])\n        max_output[i] = min(p_max[i], p_i_0[i] + p_up[i])\n    \n    total_min_on = sum(min_output[i] for i in must_on + free_on)\n    total_max_on = sum(max_output[i] for i in must_on + free_on)\n    \n    # Case 1: Load < total min must-on capacity\n    if current_load < total_min_on:\n        for i in must_on + free_on:\n            p[i] = min_output[i]\n        return np.array([u, p])\n    \n    # Case 2: Load within must-on capacity\n    if current_load <= total_max_on:\n        committed = must_on + free_on\n        for i in committed:\n            p[i] = min_output[i]\n        remaining = current_load - total_min_on\n        while remaining > 0:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < max_output[i]:\n                    mc = b[i] + 2 * c[i] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(remaining, max_output[candidate] - p[candidate])\n            p[candidate] += increase\n            remaining -= increase\n        return np.array([u, p])\n    \n    # Case 3: Load exceeds must-on capacity\n    cost_priority = []\n    for i in free_off:\n        amortized_startup = s[i] / max(1, t_on_min[i])\n        min_cost = a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n        avg_cost = (amortized_startup + min_cost) / p_min[i]\n        cost_priority.append((avg_cost, i))\n    cost_priority.sort(key=lambda x: x[0])\n    \n    committed = must_on + free_on\n    new_min = total_min_on\n    new_max = total_max_on\n    to_commit = []\n    for _, i in cost_priority:\n        if new_max >= current_load:\n            break\n        to_commit.append(i)\n        u[i] = 1\n        min_output_i = p_min[i]\n        max_output_i = min(p_max[i], p_start[i])\n        min_output[i] = min_output_i\n        max_output[i] = max_output_i\n        new_min += min_output_i\n        new_max += max_output_i\n    \n    committed += to_commit\n    total_min_comm = new_min\n    total_max_comm = new_max\n    \n    # Set outputs for committed units\n    if current_load < total_min_comm:\n        for i in committed:\n            p[i] = min_output[i]\n    elif current_load <= total_max_comm:\n        for i in committed:\n            p[i] = min_output[i]\n        remaining = current_load - total_min_comm\n        while remaining > 0:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < max_output[i]:\n                    mc = b[i] + 2 * c[i] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(remaining, max_output[candidate] - p[candidate])\n            p[candidate] += increase\n            remaining -= increase\n    else:\n        for i in committed:\n            p[i] = max_output[i]\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "commit_units_by_priority",
          "algorithm": "1. Classify units into must-run (due to min up-time or shutdown constraints), must-off (due to min down-time), flexible-on (currently on but can be decommitted), and flexible-off (currently off but can be committed).\n2. Compute total minimum and maximum generation from must-run and initially kept flexible-on units.\n3. If current load exceeds maximum generation, turn on flexible-off units by ascending average cost per MW at min output.\n4. If current load is below minimum generation, turn off flexible-on units by descending cost per MW at min output.\n5. Perform economic dispatch among committed units using a greedy algorithm based on marginal cost.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority(units_info, load):\n    n = len(units_info)\n    u_i_current = [0] * n\n    p_i_current = [0.0] * n\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    must_on = []\n    must_off = []\n    flex_on = []\n    flex_off = []\n\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n                u_i_current[i] = 1\n            else:\n                flex_on.append(i)\n                u_i_current[i] = 1\n        else:\n            if -t_i0 < t_off_min:\n                must_off.append(i)\n                u_i_current[i] = 0\n            else:\n                flex_off.append(i)\n                u_i_current[i] = 0\n\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in range(n):\n        if u_i_current[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                min_output[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                min_output[i] = units_info[i]['p_min_i']\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    current_load = load[0]\n    \n    # Turn on flex_off units if needed\n    if total_max < current_load:\n        candidates = []\n        for i in flex_off:\n            min_p = units_info[i]['p_min_i']\n            max_p = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            s = units_info[i]['s_i']\n            cost_at_min = a + b * min_p + c * min_p ** 2 + s\n            avg_cost = cost_at_min / min_p\n            candidates.append((i, min_p, max_p, avg_cost))\n        \n        candidates.sort(key=lambda x: x[3])\n        \n        for i, min_p, max_p, _ in candidates:\n            if total_max < current_load:\n                u_i_current[i] = 1\n                min_output[i] = min_p\n                max_output[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n    \n    # Turn off flex_on units if needed\n    if current_load < total_min:\n        candidates = []\n        for i in flex_on:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            min_p = min_output[i]\n            cost_at_min = a + b * min_p + c * min_p ** 2\n            saving_per_mw = cost_at_min / min_p\n            candidates.append((i, min_p, saving_per_mw))\n        \n        candidates.sort(key=lambda x: x[2], reverse=True)\n        \n        for i, min_p, _ in candidates:\n            if total_min > current_load:\n                u_i_current[i] = 0\n                total_min -= min_p\n                total_max -= max_output[i]\n                min_output[i] = 0\n                max_output[i] = 0\n            else:\n                break\n    \n    # Initialize outputs with minimum power\n    for i in range(n):\n        if u_i_current[i] == 1:\n            p_i_current[i] = min_output[i]\n        else:\n            p_i_current[i] = 0.0\n    \n    total_power = sum(p_i_current)\n    remaining = current_load - total_power\n    \n    # Adjust output allocation using marginal cost\n    units_to_adjust = [i for i in range(n) \n                       if u_i_current[i] == 1 and p_i_current[i] < max_output[i]]\n    \n    while remaining > 1e-5 and units_to_adjust:\n        min_mc = float('inf')\n        best_i = -1\n        \n        for i in units_to_adjust:\n            unit = units_info[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * p_i_current[i]\n            if mc < min_mc:\n                min_mc = mc\n                best_i = i\n        \n        if best_i == -1:\n            break\n        \n        unit = units_info[best_i]\n        inc = min(remaining, max_output[best_i] - p_i_current[best_i])\n        p_i_current[best_i] += inc\n        remaining -= inc\n        \n        if p_i_current[best_i] >= max_output[best_i]:\n            units_to_adjust.remove(best_i)\n    \n    # Prepare output array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_i_current[i]\n        schedules[1, i] = p_i_current[i]\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "refined_commitment",
          "algorithm": "1. Classify units into must-on (forced online due to min up-time/shutdown constraints), must-off (forced offline due to min down-time), and free units (adjustable).\n2. Set initial commitment for free units to their previous state.\n3. Compute power bounds for committed units considering ramp and startup/shutdown constraints.\n4. Handle under-commitment by turning on additional free units sorted by increasing average cost at min output until total capacity meets/exceeds load.\n5. Handle over-commitment by turning off expensive free units (sorted by descending operating cost at min output) that satisfy ramp-down constraints until total min output \u2264 load.\n6. Dispatch load to committed units: \n   - If load \u2264 total min output, set units to min outputs.\n   - If load \u2265 total max output, set units to max outputs.\n   - Otherwise, perform greedy incremental dispatch based on marginal cost.\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef refined_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Extract parameters\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    \n    # Initialize arrays\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    p_min_curr = np.zeros(n_units)\n    p_max_curr = np.zeros(n_units)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free = []\n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            if (t_i_0[i] < t_on_min[i]) or (p_i_0[i] > p_shut[i]):\n                must_on.append(i)\n            else:\n                free.append(i)\n        else:\n            if t_i_0[i] < 0 and abs(t_i_0[i]) < t_off_min[i]:\n                must_off.append(i)\n            else:\n                free.append(i)\n    \n    # Set initial commitment\n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in free:\n        u[i] = u_i_0[i]\n    \n    # Compute power bounds\n    for i in range(n_units):\n        if u[i] == 1:\n            if u_i_0[i] == 1:\n                p_min_curr[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                p_max_curr[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:\n                p_min_curr[i] = p_min[i]\n                p_max_curr[i] = min(p_max[i], p_start[i])\n        else:\n            p_min_curr[i] = 0\n            p_max_curr[i] = 0\n    \n    total_min = np.sum(p_min_curr)\n    total_max = np.sum(p_max_curr)\n    \n    # Under-commitment handling\n    candidates_under = [i for i in free if u[i] == 0]\n    candidates_under.sort(\n        key=lambda i: (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]\n    )\n    for i in candidates_under:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        if u_i_0[i] == 1:\n            p_min_curr[i] = max(p_min[i], p_i_0[i] - p_down[i])\n            p_max_curr[i] = min(p_max[i], p_i_0[i] + p_up[i])\n        else:\n            p_min_curr[i] = p_min[i]\n            p_max_curr[i] = min(p_max[i], p_start[i])\n        total_min += p_min_curr[i]\n        total_max += p_max_curr[i]\n    \n    # Over-commitment handling\n    candidates_over = [\n        i for i in free \n        if u[i] == 1 and p_i_0[i] <= p_down[i]\n    ]\n    candidates_over.sort(\n        key=lambda i: a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2),\n        reverse=True\n    )\n    for i in candidates_over:\n        if total_min <= current_load:\n            break\n        u[i] = 0\n        total_min -= p_min_curr[i]\n        total_max -= p_max_curr[i]\n        p_min_curr[i] = 0\n        p_max_curr[i] = 0\n    \n    # Dispatch the load\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p])\n    \n    if current_load <= total_min:\n        for i in committed_indices:\n            p[i] = p_min_curr[i]\n    elif current_load >= total_max:\n        for i in committed_indices:\n            p[i] = p_max_curr[i]\n    else:\n        # Greedy incremental dispatch\n        p_alloc = np.array(p_min_curr)\n        remaining = current_load - total_min\n        step = 0.1\n        \n        while remaining > 1e-3:\n            min_mc = float('inf')\n            best_idx = None\n            for i in committed_indices:\n                if p_alloc[i] < p_max_curr[i]:\n                    mc = b[i] + 2 * c[i] * p_alloc[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_idx = i\n            if best_idx is None:\n                break\n            delta = min(step, remaining, p_max_curr[best_idx] - p_alloc[best_idx])\n            p_alloc[best_idx] += delta\n            remaining -= delta\n        p = p_alloc\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0360464105,
          "fitness": 0.0180880445
     },
     {
          "name": "commit_units_by_priority_forecast",
          "algorithm": "1. Classify units into forced on, forced off, and free units based on min up/down times and shutdown ramp limits.\n2. Initially set free units that were on to on, and free units that were off to off.\n3. Compute total available power from committed units (forced on + initially set free units).\n4. If total power is below current load, commit additional free units (off previously) in ascending order of marginal cost at min power until power >= load.\n5. Perform economic dispatch to allocate current load to committed units with min/max constraints derived from ramp limits.\n6. Check if forecasted next load can be met by expanding committed units based on min down time and startup limits, adding highest priority unit if necessary.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_info, n_units, u_current, load_current):\n    p_current = [0.0] * n_units\n    p_low = [0.0] * n_units\n    p_high = [0.0] * n_units\n    \n    for i in range(n_units):\n        if u_current[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                p_low[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                p_high[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                p_low[i] = units_info[i]['p_min_i']\n                p_high[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(p_low[i] for i in range(n_units) if u_current[i] == 1)\n    if total_min > load_current:\n        for i in range(n_units):\n            if u_current[i] == 1:\n                p_current[i] = p_low[i]\n        return p_current\n    \n    remaining = load_current - total_min\n    for i in range(n_units):\n        if u_current[i] == 1:\n            p_current[i] = p_low[i]\n    \n    while remaining > 1e-5:\n        min_mc = float('inf')\n        candidate = -1\n        for i in range(n_units):\n            if u_current[i] == 1 and p_current[i] < p_high[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_current[i]\n                if marginal_cost < min_mc:\n                    min_mc = marginal_cost\n                    candidate = i\n        if candidate == -1:\n            break\n        amount = min(remaining, p_high[candidate] - p_current[candidate])\n        p_current[candidate] += amount\n        remaining -= amount\n    \n    return p_current\n\ndef commit_units_by_priority_forecast(units_info, load):\n    n_units = len(units_info)\n    u_current = [0] * n_units\n    load_current, forecast_next = load\n    \n    forced_on = []\n    forced_off = []\n    free_units = []\n    free_units_on = []\n    free_units_off = []\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_units_on.append(i)\n        else:\n            free_units_off.append(i)\n    \n    for i in forced_on:\n        u_current[i] = 1\n    for i in forced_off:\n        u_current[i] = 0\n    for i in free_units_on:\n        u_current[i] = 1\n    for i in free_units_off:\n        u_current[i] = 0\n    \n    total_max_power = 0.0\n    for i in forced_on + free_units_on:\n        if units_info[i]['u_i_0'] == 1:\n            total_max_power += min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n    \n    sorted_free_off = sorted(free_units_off, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'])\n    additional_commit = []\n    for i in sorted_free_off:\n        if total_max_power >= load_current:\n            break\n        u_current[i] = 1\n        additional_commit.append(i)\n        total_max_power += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    p_current = economic_dispatch(units_info, n_units, u_current, load_current)\n    \n    total_max_next = 0.0\n    for i in range(n_units):\n        if u_current[i] == 1:\n            total_max_next += min(units_info[i]['p_max_i'], p_current[i] + units_info[i]['p_up_i'])\n        else:\n            if units_info[i]['u_i_0'] == 1 and u_current[i] == 0:\n                downtime_next = 1\n            else:\n                downtime_next = abs(units_info[i]['t_i_0']) + 1\n            if downtime_next >= units_info[i]['t_off_min_i']:\n                total_max_next += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    if total_max_next < forecast_next:\n        available_units = [i for i in free_units_off if u_current[i] == 0]\n        if available_units:\n            sorted_available = sorted(available_units, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'])\n            i_extra = sorted_available[0]\n            u_current[i_extra] = 1\n            p_current = economic_dispatch(units_info, n_units, u_current, load_current)\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u_current[i]\n        schedules[1, i] = p_current[i]\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0375214362,
          "fitness": 0.0187965642
     }
]