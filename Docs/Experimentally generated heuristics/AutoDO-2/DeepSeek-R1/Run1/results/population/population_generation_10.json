[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "greedy_ramp_commit_dispatch",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output exceeding shutdown capacity) and must-off units (offline with insufficient min-down time)\n2. Initialize commitment state to must-on, must-off, or previous state for flexible units\n3. Compute feasible power ranges for committed units considering min/max outputs, ramps, and start/shutdown constraints\n4. Adjust commitment:\n   - Under-committed: Activate offline units by lowest (startup cost + min-power operating cost)/min-power metric\n   - Over-committed: Deactivate non-must-on units by highest min-power operating cost until feasible\n   - Adequate: Deactivate expensive non-must-on units if system adequacy holds\n5. Dispatch power:\n   - Set committed units to min power output\n   - Greedily allocate residual load to units with smallest marginal cost while respecting max output limits\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef greedy_ramp_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n                \n    u_i = [1 if i in must_on else (0 if i in must_off else unit['u_i_0']) \n           for i, unit in enumerate(units_info)]\n    \n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p)\n    total_max = sum(max_p)\n    \n    # Under-committed: Activate units\n    if total_max < current_load:\n        available = [i for i in range(n_units) if u_i[i] == 0 and i not in must_off]\n        metrics = []\n        for i in available:\n            unit = units_info[i]\n            min_base = unit['p_min_i']\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i']*min_base + unit['c_i']*min_base**2\n            metric = cost / min_base\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for _, i in metrics:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            min_p[i] = unit_i = units_info[i]\n            min_base = unit_i['p_min_i']\n            max_start = min(unit_i['p_max_i'], unit_i['p_start_i'])\n            min_p[i] = min_base\n            max_p[i] = max_start\n            total_min += min_base\n            total_max += max_start\n    \n    # Over-committed: Deactivate units\n    if total_min > current_load:\n        non_must_on = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        op_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_p[i] + unit['c_i'] * min_p[i]**2\n            op_costs.append((cost, i))\n        op_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost_val, i in op_costs:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            total_min -= min_p[i]\n            total_max -= max_p[i]\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    # Adequate: Deactivate expensive units\n    if total_min <= current_load <= total_max:\n        non_must_on = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        op_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_p[i] + unit['c_i'] * min_p[i]**2\n            op_costs.append((cost, i))\n        op_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost_val, i in op_costs:\n            new_total_min = total_min - min_p[i]\n            new_total_max = total_max - max_p[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p[i] = 0\n                max_p[i] = 0\n    \n    # Power dispatch\n    p_i = [min_p[i] if u_i[i] == 1 else 0.0 for i in range(n_units)]\n    residual = current_load - sum(p_i)\n    tol = 1e-6\n    \n    while residual > tol:\n        min_mc = float('inf')\n        candidate = -1\n        for i in range(n_units):\n            if u_i[i] == 1 and p_i[i] < max_p[i] - tol:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n        if candidate == -1:\n            break\n        add = min(residual, max_p[candidate] - p_i[candidate])\n        p_i[candidate] += add\n        residual -= add\n    \n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.0086286729,
          "fitness": 0.0068754583
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "refined_lambda_commitment_dispatch",
          "algorithm": "1. Identify must-on units (currently online units failing min-up time or shutdown ramp constraints) and must-off units (offline units failing min-down time).\n2. Initialize commitment: set must-on units to 'on', must-off units to 'off', others retain previous state.\n3. Calculate feasible power ranges for committed units considering ramp rates, startup/shutdown constraints.\n4. Iteratively adjust commitment:\n   a. For under-committed systems (insufficient max capacity), activate most cost-effective offline units.\n   b. For over-committed systems (excess min capacity), decommit highest-cost non-must-on units.\n   c. Decommission expensive non-must-on units if adequacy holds.\n5. Perform lambda iteration for economic dispatch respecting output constraints.\n6. Handle residual load after dispatch via greedy adjustment.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_lambda_commitment_dispatch(units_info, load):\n    load_current = load[0]  # current load to meet\n    \n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min and t_i0 > 0) or p_i0 > p_shut:\n                must_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    u = [0] * n_units\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Initialize min and max power outputs\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            min_outputs[i] = max_outputs[i] = 0.0\n            continue\n            \n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_i0 = unit['p_i_0']\n        \n        if unit['u_i_0'] == 1 and u[i] == 1:  # remains on\n            min_outputs[i] = max(p_min, p_i0 - p_down)\n            max_outputs[i] = min(p_max, p_i0 + p_up)\n        elif unit['u_i_0'] == 0 and u[i] == 1:  # starting up\n            min_outputs[i] = p_min\n            max_outputs[i] = min(p_max, p_start)\n        elif unit['u_i_0'] == 1 and u[i] == 0:  # shutting down\n            min_outputs[i] = max_outputs[i] = 0.0\n        else:  # remains off\n            min_outputs[i] = max_outputs[i] = 0.0\n    \n    total_min = np.sum(min_outputs)\n    total_max = np.sum(max_outputs)\n    \n    # Adjust commitment iteratively\n    max_iter = n_units\n    iter_count = 0\n    \n    while iter_count < max_iter:\n        iter_count += 1\n        \n        if total_max < load_current:  # Under-committed\n            available_offline = [i for i in range(n_units) \n                                if u[i] == 0 and i not in must_off]\n            if not available_offline:\n                break\n                \n            metrics = []\n            for i in available_offline:\n                unit = units_info[i]\n                p_min_candidate = unit['p_min_i']\n                cost = unit['a_i'] + unit['b_i'] * p_min_candidate + unit['c_i'] * p_min_candidate**2 + unit['s_i']\n                metrics.append((cost / p_min_candidate, i))\n            \n            if not metrics:\n                break\n            metrics.sort(key=lambda x: x[0])\n            candidate = metrics[0][1]\n            u[candidate] = 1\n            unit_candidate = units_info[candidate]\n            min_candidate = unit_candidate['p_min_i']\n            max_candidate = min(unit_candidate['p_max_i'], unit_candidate['p_start_i'])\n            min_outputs[candidate] = min_candidate\n            max_outputs[candidate] = max_candidate\n            total_min += min_candidate\n            total_max += max_candidate\n            \n        elif total_min > load_current:  # Over-committed\n            decommitable = [i for i in range(n_units) \n                           if u[i] == 1 and i not in must_on]\n            if not decommitable:\n                break\n                \n            metrics = []\n            for i in decommitable:\n                cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2\n                metrics.append((cost, i))\n            \n            metrics.sort(key=lambda x: x[0], reverse=True)\n            candidate = metrics[0][1]\n            u[candidate] = 0\n            removed_min = min_outputs[candidate]\n            removed_max = max_outputs[candidate]\n            min_outputs[candidate] = 0.0\n            max_outputs[candidate] = 0.0\n            total_min -= removed_min\n            total_max -= removed_max\n            \n        else:  # Adequate\n            break\n    \n    # Greedy decommitment for expensive non-must-on units\n    decommitable = [i for i in range(n_units) \n                   if u[i] == 1 and i not in must_on]\n    if decommitable:\n        metrics = []\n        for i in decommitable:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2\n            metrics.append((cost, i))\n        \n        metrics.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in metrics:\n            new_total_min = total_min - min_outputs[i]\n            new_total_max = total_max - max_outputs[i]\n            if new_total_min <= load_current <= new_total_max:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_outputs[i] = 0.0\n                max_outputs[i] = 0.0\n    \n    # Commit if none are committed but load exists (emergency)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices and abs(load_current) > 1e-6:\n        candidate = np.argmin([unit['p_min_i'] for unit in units_info])\n        u[candidate] = 1\n        min_outputs[candidate] = units_info[candidate]['p_min_i']\n        max_outputs[candidate] = min(units_info[candidate]['p_max_i'], units_info[candidate]['p_start_i'])\n        committed_indices = [candidate]\n        total_min = min_outputs[candidate]\n        total_max = max_outputs[candidate]\n    \n    # Lambda iteration for economic dispatch\n    p = min_outputs.copy()\n    if committed_indices and abs(total_max - total_min) > 1e-6:\n        # Calculate lambda bounds\n        lam_low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_outputs[i] for i in committed_indices) - 1.0\n        lam_high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_outputs[i] for i in committed_indices) + 1.0\n        \n        # Bisection for optimal lambda\n        for _ in range(100):\n            if abs(lam_high - lam_low) < 1e-6:\n                break\n            lam_mid = (lam_low + lam_high) / 2.0\n            total_mid = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                marginal_low = unit['b_i'] + 2 * unit['c_i'] * min_outputs[i]\n                marginal_high = unit['b_i'] + 2 * unit['c_i'] * max_outputs[i]\n                if lam_mid < marginal_low:\n                    p_i = min_outputs[i]\n                elif lam_mid > marginal_high:\n                    p_i = max_outputs[i]\n                else:\n                    p_i = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_outputs[i], min(p_i, max_outputs[i]))\n                total_mid += p_i\n            \n            if total_mid < load_current:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n        \n        # Calculate final dispatch with optimal lambda\n        lam = (lam_low + lam_high) / 2\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_low = unit['b_i'] + 2 * unit['c_i'] * min_outputs[i]\n            marginal_high = unit['b_i'] + 2 * unit['c_i'] * max_outputs[i]\n            if lam < marginal_low:\n                p_i = min_outputs[i]\n            elif lam > marginal_high:\n                p_i = max_outputs[i]\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(min_outputs[i], min(p_i, max_outputs[i]))\n            p[i] = p_i\n        \n        total_output = np.sum(p)\n        residual = load_current - total_output\n        \n        # Residual load adjustment\n        if residual > 1e-6:  # Under generation\n            candidates = [i for i in committed_indices if p[i] < max_outputs[i] - 1e-6]\n            candidates.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n            for i in candidates:\n                avail = max_outputs[i] - p[i]\n                to_add = min(avail, residual)\n                p[i] += to_add\n                residual -= to_add\n                if residual <= 1e-6:\n                    break\n        elif residual < -1e-6:  # Over generation\n            residual = abs(residual)\n            candidates = [i for i in committed_indices if p[i] > min_outputs[i] + 1e-6]\n            candidates.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n            for i in candidates:\n                avail = p[i] - min_outputs[i]\n                to_remove = min(avail, residual)\n                p[i] -= to_remove\n                residual -= to_remove\n                if residual <= 1e-6:\n                    break\n    \n    # Format output\n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0049947365,
          "gap_price_rate": 0.0092619258,
          "fitness": 0.0071283312
     },
     {
          "name": "hybrid_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or violation of shutdown ramp constraint) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state\n3. Calculate feasible power ranges for committed units considering ramp constraints and startup/shutdown limits\n4. Adjust commitment based on system adequacy:\n   - Under-committed: activate flexible units sorted by lowest (startup cost + min-power cost)/min-power\n   - Over-committed: decommit non-must-on units sorted by highest min-power operating cost\n   - Adequate: decommit non-must-on units sorted by highest min-power cost if system remains adequate\n5. Perform constrained economic dispatch using lambda iteration for committed units:\n   - Solve optimal dispatch via bisection on system lambda\n   - Adjust any residual load using greedy merit-order based on marginal costs\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    min_bound = [0.0] * n\n    max_bound = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    current_load = load[0]\n    \n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u_arr[i] = 1\n        elif must_off[i]:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n\n    # Step 3: Calculate feasible power ranges for committed units\n    for i, unit in enumerate(units_info):\n        if u_arr[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n\n    # Step 4: Adjust commitment based on system adequacy\n    total_min = sum(min_bound[i] for i in range(n) if u_arr[i] == 1)\n    total_max = sum(max_bound[i] for i in range(n) if u_arr[i] == 1)\n    \n    # Case A: Under-committed\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if not must_on[i] and not must_off[i] and u_arr[i] == 0]\n        metrics = []\n        for i in flexible_off:\n            unit = units_info[i]\n            startup_cost = unit['s_i']\n            min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            metric = (startup_cost + min_cost) / unit['p_min_i']\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for metric, i in metrics:\n            if total_max >= current_load:\n                break\n            u_arr[i] = 1\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Case B: Over-committed\n    if total_min > current_load:\n        non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n        costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n            costs.append((cost, i))\n        costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in costs:\n            if total_min <= current_load:\n                break\n            u_arr[i] = 0\n            total_min -= min_bound[i]\n            total_max -= max_bound[i]\n            min_bound[i] = 0\n            max_bound[i] = 0\n    \n    # Case C: Adequate - decommit expensive non-must-on units\n    non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n    costs = []\n    for i in non_must_on:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n        costs.append((cost, i))\n    costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in costs:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load <= new_max:\n            u_arr[i] = 0\n            total_min = new_min\n            total_max = new_max\n            min_bound[i] = 0\n            max_bound[i] = 0\n\n    # Step 5: Economic dispatch for committed units\n    committed_indices = [i for i in range(n) if u_arr[i] == 1]\n    l_dispatch = [min_bound[i] for i in committed_indices]\n    u_dispatch = [max_bound[i] for i in committed_indices]\n    b_dispatch = [units_info[i]['b_i'] for i in committed_indices]\n    c_dispatch = [units_info[i]['c_i'] for i in committed_indices]\n    p_dispatch = l_dispatch[:] if committed_indices else []\n    residual = current_load - sum(p_dispatch)\n    \n    # Lambda iteration for dispatch\n    if committed_indices:\n        tol = 0.001\n        max_iter = 1000\n        low_lambda = float('inf')\n        high_lambda = float('-inf')\n        \n        for i in range(len(committed_indices)):\n            mc_low = b_dispatch[i] + 2 * c_dispatch[i] * l_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            mc_high = b_dispatch[i] + 2 * c_dispatch[i] * u_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            if mc_low < low_lambda:\n                low_lambda = mc_low\n            if mc_high > high_lambda:\n                high_lambda = mc_high\n        \n        lambda_low = min(low_lambda - 1.0, 0)\n        lambda_high = high_lambda + 1.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in range(len(committed_indices)):\n                if c_dispatch[i] == 0:\n                    if lambda_mid < b_dispatch[i]:\n                        p_dispatch[i] = l_dispatch[i]\n                    elif lambda_mid > b_dispatch[i]:\n                        p_dispatch[i] = u_dispatch[i]\n                    else:\n                        p_dispatch[i] = l_dispatch[i]\n                else:\n                    p = (lambda_mid - b_dispatch[i]) / (2.0 * c_dispatch[i])\n                    p_dispatch[i] = min(u_dispatch[i], max(l_dispatch[i], p))\n                total_gen += p_dispatch[i]\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > tol:\n            # Residual >0: distribute to units with cheapest marginal cost\n            if residual > 0:\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] < u_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    min_mc = min(mc_list, key=lambda x: x[0])\n                    i = min_mc[1]\n                    add = min(residual, u_dispatch[i] - p_dispatch[i])\n                    p_dispatch[i] += add\n                    residual -= add\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] < u_dispatch[j]]\n            # Residual <0: reduce from units with highest marginal cost\n            else:\n                residual = abs(residual)\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] > l_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    max_mc = max(mc_list, key=lambda x: x[0])\n                    i = max_mc[1]\n                    reduce_by = min(residual, p_dispatch[i] - l_dispatch[i])\n                    p_dispatch[i] -= reduce_by\n                    residual -= reduce_by\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] > l_dispatch[j]]\n        \n        # Assign dispatched power to output array\n        for idx, p_val in zip(committed_indices, p_dispatch):\n            p_arr[idx] = p_val\n    \n    # Build return array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_arr[i]\n        schedules[1, i] = p_arr[i]\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049948693,
          "gap_price_rate": 0.0092619027,
          "fitness": 0.007128386
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "hybrid_enhanced_dispatch",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output exceeding shutdown ramp limit) and must-off units (offline with insufficient min-down time).\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state.\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints.\n4. Calculate total min/max generation capacity from committed units.\n5. Adjust commitment:\n   a. For over-committed systems (total min > load): remove expensive non-must-on units until feasible.\n   b. For under-committed systems (total max < load): activate most cost-effective offline units considering startup costs.\n   c. For adequate systems: remove expensive non-must-on units if system adequacy holds.\n6. For dispatch:\n   - Set must-off and non-committed units to off with zero output.\n   - For committed units:\n        - If load <= total min: set to minimum output.\n        - If load >= total max: set to maximum output.\n        - Otherwise: perform lambda iteration for economic dispatch.\n   - Resolve any residual load with greedy adjustment.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    u_i = [0] * n_units\n    for i in must_on:\n        u_i[i] = 1\n    for i in must_off:\n        u_i[i] = 0\n    for i in range(n_units):\n        if i not in must_on and i not in must_off:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    # Initialize min/max output constraints\n    min_p_i = [0] * n_units\n    max_p_i = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n    \n    # Commitment adjustment logic\n    if total_min > current_load:  # Over-committed\n        non_forced = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        cost_list = []\n        for i in non_forced:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            cost = a + b * min_p_i[i] + c * min_p_i[i] ** 2\n            cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in cost_list:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            min_p_i[i] = 0\n            max_p_i[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    elif total_max < current_load:  # Under-committed\n        non_forced_off = [i for i in range(n_units) if u_i[i] == 0 and i not in must_off]\n        candidate_list = []\n        for i in non_forced_off:\n            s = units_info[i]['s_i']\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            min_p_val = units_info[i]['p_min_i']\n            cost_min = a + b * min_p_val + c * min_p_val ** 2\n            avg_cost = (s + cost_min) / min_p_val if min_p_val > 0 else float('inf')\n            candidate_list.append((avg_cost, i))\n        candidate_list.sort(key=lambda x: x[0])\n        for avg_cost, i in candidate_list:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            min_p_val = units_info[i]['p_min_i']\n            max_p_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_p_i[i] = min_p_val\n            max_p_i[i] = max_p_val\n            total_min += min_p_val\n            total_max += max_p_val\n    \n    else:  # Adequately committed\n        non_forced = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        cost_list = []\n        for i in non_forced:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            cost = a + b * min_p_i[i] + c * min_p_i[i] ** 2\n            cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in cost_list:\n            new_min = total_min - min_p_i[i]\n            new_max = total_max - max_p_i[i]\n            if new_min <= current_load <= new_max:\n                u_i[i] = 0\n                min_p_i[i] = 0\n                max_p_i[i] = 0\n                total_min = new_min\n                total_max = new_max\n    \n    # Update min/max for adjusted commitments\n    for i in range(n_units):\n        if u_i[i] == 1 and min_p_i[i] > max_p_i[i]:\n            min_p_i[i] = max_p_i[i] = (min_p_i[i] + max_p_i[i]) / 2\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n    \n    # Dispatch\n    p_i = [0] * n_units\n    if total_min >= current_load:\n        for i in range(n_units):\n            p_i[i] = min_p_i[i] if u_i[i] == 1 else 0\n    elif total_max <= current_load:\n        for i in range(n_units):\n            p_i[i] = max_p_i[i] if u_i[i] == 1 else 0\n    else:\n        committed_idx = [i for i in range(n_units) if u_i[i] == 1]\n        a_vals = [units_info[i]['a_i'] for i in committed_idx]\n        b_vals = [units_info[i]['b_i'] for i in committed_idx]\n        c_vals = [units_info[i]['c_i'] for i in committed_idx]\n        min_vals = [min_p_i[i] for i in committed_idx]\n        max_vals = [max_p_i[i] for i in committed_idx]\n        n_committed = len(committed_idx)\n        \n        # Lambda iteration setup\n        low = min(b_vals[j] + 2 * c_vals[j] * min_vals[j] for j in range(n_committed))\n        high = max(b_vals[j] + 2 * c_vals[j] * max_vals[j] for j in range(n_committed))\n        tol = 0.01\n        \n        # Perform bisection\n        for _ in range(100):\n            mid = (low + high) / 2\n            total_p = 0\n            for j in range(n_committed):\n                if c_vals[j] == 0:\n                    p_val = max_vals[j] if mid >= b_vals[j] else min_vals[j]\n                else:\n                    p_val = (mid - b_vals[j]) / (2 * c_vals[j])\n                    p_val = max(min_vals[j], min(max_vals[j], p_val))\n                total_p += p_val\n            \n            if total_p < current_load:\n                low = mid\n            else:\n                high = mid\n            \n            if high - low < tol:\n                break\n        \n        # Apply final lambda value\n        lambda_final = (low + high) / 2\n        total_p = 0\n        for j in range(n_committed):\n            if c_vals[j] == 0:\n                p_val = max_vals[j] if lambda_final >= b_vals[j] else min_vals[j]\n            else:\n                p_val = (lambda_final - b_vals[j]) / (2 * c_vals[j])\n                p_val = max(min_vals[j], min(max_vals[j], p_val))\n            total_p += p_val\n            p_i[committed_idx[j]] = p_val\n        \n        # Greedy residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                # Sort units with available capacity by marginal cost\n                candidates = []\n                for j in range(n_committed):\n                    i_idx = committed_idx[j]\n                    mc = b_vals[j] + 2 * c_vals[j] * p_i[i_idx]\n                    if p_i[i_idx] < max_vals[j]:\n                        candidates.append((mc, i_idx, j))\n                candidates.sort()\n                for mc, i_idx, j in candidates:\n                    if residual <= 0:\n                        break\n                    add = min(residual, max_vals[j] - p_i[i_idx])\n                    p_i[i_idx] += add\n                    residual -= add\n            else:\n                # Sort units by marginal cost descending\n                candidates = []\n                for j in range(n_committed):\n                    i_idx = committed_idx[j]\n                    mc = b_vals[j] + 2 * c_vals[j] * p_i[i_idx]\n                    if p_i[i_idx] > min_vals[j]:\n                        candidates.append((mc, i_idx, j))\n                candidates.sort(reverse=True)\n                for mc, i_idx, j in candidates:\n                    if residual >= 0:\n                        break\n                    reduce_val = min(-residual, p_i[i_idx] - min_vals[j])\n                    p_i[i_idx] -= reduce_val\n                    residual += reduce_val\n    \n    # Format output\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054283885,
          "gap_price_rate": 0.0090999183,
          "fitness": 0.0072641534
     },
     {
          "name": "adaptive_commitment_lambda_dispatch",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or previous output exceeding shutdown ramp) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, flexible units to previous state\n3. Compute feasible power ranges for all units considering ramp and startup/shutdown constraints\n4. Calculate total min/max generation capacity from committed units and classify system state:\n   - Over-committed: total min > current load\n   - Under-committed: total max < current load\n   - Adequate: load within feasible range\n5. Adjust commitment state:\n   - Over-committed: Deactivate non-must-on units with highest operating cost at minimum output until feasible\n   - Under-committed: Activate most cost-effective offline units (startup cost + min-power cost) until capacity meets demand\n   - Adequate: Deactivate expensive non-must-on units if adequacy holds\n6. Perform constrained economic dispatch:\n   - Use lambda iteration to determine optimal generation levels\n   - Adjust for any residual load using greedy merit-order based on marginal costs\n7. Set non-committed units to off with zero output\n8. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef adaptive_commitment_lambda_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    load_current = load[0]\n    \n    # Precompute feasible power ranges\n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0']:\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[i] = unit['p_min_i']\n            ub[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0']:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Adjust commitment based on system adequacy\n    committed_indices = np.where(u == 1)[0]\n    total_min = sum(lb[i] for i in committed_indices)\n    total_max = sum(ub[i] for i in committed_indices)\n    \n    # Over-committed: deactivate expensive non-must-on units\n    if total_min > load_current:\n        non_must_on = [i for i in committed_indices if i not in must_on]\n        # Sort by operating cost at min power descending\n        non_must_on.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*lb[i] + units_info[i]['c_i']*lb[i]**2, reverse=True)\n        for unit_idx in non_must_on:\n            if total_min - lb[unit_idx] <= load_current and total_max - ub[unit_idx] >= load_current:\n                u[unit_idx] = 0\n                total_min -= lb[unit_idx]\n                total_max -= ub[unit_idx]\n            if total_min <= load_current:\n                break\n    \n    # Under-committed: activate cheapest offline units\n    elif total_max < load_current:\n        flexible_off = [i for i in range(n_units) if u[i]==0 and i not in must_off]\n        # Sort by cost per MW at min power (including startup cost)\n        flexible_off.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*lb[i] + units_info[i]['c_i']*lb[i]**2) / lb[i] if lb[i] > 0 else float('inf'))\n        for unit_idx in flexible_off:\n            u[unit_idx] = 1\n            total_min += lb[unit_idx]\n            total_max += ub[unit_idx]\n            if total_max >= load_current:\n                break\n    \n    # Adequate: remove expensive non-must-on units if possible\n    else:\n        non_must_on = [i for i in np.where(u==1)[0] if i not in must_on]\n        # Sort by operating cost at min power descending\n        non_must_on.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*lb[i] + units_info[i]['c_i']*lb[i]**2, reverse=True)\n        for unit_idx in non_must_on:\n            new_min = total_min - lb[unit_idx]\n            new_max = total_max - ub[unit_idx]\n            if new_min <= load_current and new_max >= load_current:\n                u[unit_idx] = 0\n                total_min = new_min\n                total_max = new_max\n    \n    # Economic dispatch using lambda iteration\n    committed_indices = np.where(u == 1)[0]\n    lb_committed = np.array([lb[i] for i in committed_indices])\n    ub_committed = np.array([ub[i] for i in committed_indices])\n    a = np.array([units_info[i]['a_i'] for i in committed_indices])\n    b = np.array([units_info[i]['b_i'] for i in committed_indices])\n    c = np.array([units_info[i]['c_i'] for i in committed_indices])\n    \n    # Initial lambda bounds\n    if len(committed_indices) > 0:\n        marginal_min = b + 2*c*lb_committed\n        marginal_max = b + 2*c*ub_committed\n        lambda_low = np.min(marginal_min)\n        lambda_high = np.max(marginal_max)\n    else:\n        lambda_low = lambda_high = 0\n    \n    # Lambda iteration\n    tolerance = 1e-5\n    p_dispatch = lb_committed.copy()\n    for _ in range(100):\n        if abs(lambda_high - lambda_low) < tolerance:\n            break\n        lambda_mid = (lambda_low + lambda_high) / 2\n        # Calculate desired power outputs\n        p_desired = np.clip((lambda_mid - b) / (2*c), lb_committed, ub_committed)\n        total_gen = np.sum(p_desired)\n        \n        if total_gen < load_current:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        p_dispatch = p_desired\n    \n    # Handle residual load\n    residual = load_current - np.sum(p_dispatch)\n    if abs(residual) > tolerance:\n        if residual > 0:  # Increase generation\n            idx_inc = np.where(p_dispatch < ub_committed)[0]\n            if len(idx_inc) > 0:\n                marginal_costs = b[idx_inc] + 2*c[idx_inc]*p_dispatch[idx_inc]\n                sorted_idx = np.argsort(marginal_costs)\n                for i in sorted_idx:\n                    unit_idx = idx_inc[i]\n                    available = ub_committed[unit_idx] - p_dispatch[unit_idx]\n                    allocation = min(available, residual)\n                    p_dispatch[unit_idx] += allocation\n                    residual -= allocation\n                    if residual <= 0:\n                        break\n        else:  # Decrease generation\n            residual = -residual\n            idx_dec = np.where(p_dispatch > lb_committed)[0]\n            if len(idx_dec) > 0:\n                marginal_costs = b[idx_dec] + 2*c[idx_dec]*p_dispatch[idx_dec]\n                sorted_idx = np.argsort(marginal_costs)[::-1]\n                for i in sorted_idx:\n                    unit_idx = idx_dec[i]\n                    available = p_dispatch[unit_idx] - lb_committed[unit_idx]\n                    allocation = min(available, residual)\n                    p_dispatch[unit_idx] -= allocation\n                    residual -= allocation\n                    if residual <= 0:\n                        break\n    \n    # Set outputs\n    for idx, unit_idx in enumerate(committed_indices):\n        p[unit_idx] = max(lb[unit_idx], min(ub[unit_idx], p_dispatch[idx]))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285359,
          "gap_price_rate": 0.0091002177,
          "fitness": 0.0072643768
     },
     {
          "name": "hybrid_lambda_greedy_commitment",
          "algorithm": "1. Identify must-on units (units with insufficient min-up time or previous output exceeding shutdown capacity) and must-off units (units with insufficient min-down time)\n2. Initialize commitment: must-on units set to 1, must-off units to 0, others retain previous state\n3. Compute feasible power ranges considering ramp limits, startup/shutdown constraints\n4. Adjust commitment:\n   - Under-committed: Activate offline units using cost-effectiveness metric (startup cost + min-power production cost)/min-power\n   - Over-committed: Decommit non-must-on units by highest min-power operating cost until feasible\n   - Adequate: Decommit expensive non-must-on units while maintaining system adequacy\n5. Perform constrained economic dispatch:\n   - Use lambda iteration for core dispatch with bisection method\n   - Adjust residual load with greedy merit-order based on marginal costs\n   - Strictly enforce all physical constraints during dispatch\n6. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef hybrid_lambda_greedy_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Identify must-run and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Was online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n        else:  # Was offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Compute feasible generation ranges\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:  # Committed\n            if unit['u_i_0'] == 1:  # Was online\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Not committed\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    # Calculate total available capacity\n    total_min = sum(min_p)\n    total_max = sum(max_p)\n    \n    # Commitment adjustment\n    # Case 1: Under-committed (insufficient max capacity)\n    if total_max < current_load:\n        # Find available offline units\n        available = [i for i in range(n_units) \n                    if u[i] == 0 and i not in must_off]\n        \n        # Calculate cost-effectiveness metric\n        cost_effect = []\n        for i in available:\n            unit = units_info[i]\n            min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            cost_effect.append((i, (unit['s_i'] + min_cost) / unit['p_min_i']))\n        \n        # Sort by ascending cost-effectiveness\n        cost_effect.sort(key=lambda x: x[1])\n        \n        # Activate units until capacity meets demand\n        for i, _ in cost_effect:\n            if total_max >= current_load:\n                break\n                \n            u[i] = 1\n            min_p[i] = units_info[i]['p_min_i']\n            max_p[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Case 2: Over-committed (minimum capacity exceeds demand)\n    elif total_min > current_load:\n        # Find non-must-on units that can be decommitted\n        candidates = [i for i in range(n_units)\n                      if u[i] == 1 and i not in must_on]\n        \n        # Calculate operating cost at minimum output\n        op_costs = []\n        for i in candidates:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                    unit['c_i'] * min_p[i]**2)\n            op_costs.append((i, cost))\n        \n        # Sort by descending operating cost\n        op_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        # Decommit units until capacity becomes feasible\n        for i, _ in op_costs:\n            if total_min <= current_load:\n                break\n                \n            u[i] = 0\n            total_min -= min_p[i]\n            total_max -= max_p[i]\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    # Case 3: Adequate system (demand within min/max range)\n    else:\n        # Find non-must-on units\n        candidates = [i for i in range(n_units)\n                      if u[i] == 1 and i not in must_on]\n        \n        # Calculate operating cost at minimum output\n        op_costs = []\n        for i in candidates:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                    unit['c_i'] * min_p[i]**2)\n            op_costs.append((i, cost))\n        \n        # Sort by descending operating cost\n        op_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        # Decommit expensive units if system remains adequate\n        for i, _ in op_costs:\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= current_load <= new_max:\n                u[i] = 0\n                total_min = new_min\n                total_max = new_max\n                min_p[i] = 0\n                max_p[i] = 0\n    \n    # Economic dispatch for committed units\n    committed = [i for i in range(n_units) if u[i] == 1]\n    \n    if committed:\n        # Lambda initialization\n        b_vals = [units_info[i]['b_i'] for i in committed]\n        c_vals = [units_info[i]['c_i'] for i in committed]\n        lambda_low = min(b_vals)\n        lambda_high = max(b_i + 2*c_i*max_p[i] for i, (b_i, c_i) in \n                         enumerate(zip(b_vals, c_vals)))\n        \n        # Bisection algorithm\n        tol = 1e-3\n        n_iter = 1000\n        total_p = 0\n        \n        for _ in range(n_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            p_vals = []\n            \n            for idx, i in enumerate(committed):\n                unit = units_info[i]\n                c_i = c_vals[idx]\n                \n                if c_i == 0:  # Linear cost function\n                    if lambda_mid < b_vals[idx]:\n                        p_val = min_p[i]\n                    else:\n                        p_val = max_p[i]\n                else:\n                    # Unconstrained optimum\n                    p_val = (lambda_mid - b_vals[idx]) / (2 * c_i)\n                    # Apply constraints\n                    p_val = max(min_p[i], min(max_p[i], p_val))\n                \n                p_vals.append(p_val)\n                total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        else:\n            # Iteration limit reached, use last valid dispatch\n            pass\n        \n        # Assign dispatch results\n        for idx, i in enumerate(committed):\n            p[i] = p_vals[idx]\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                # Find units below max output\n                candidates = [(i, units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i])\n                             for i in committed if p[i] < max_p[i]]\n                candidates.sort(key=lambda x: x[1])\n                \n                for i, mc in candidates:\n                    if residual <= 0:\n                        break\n                    increase = min(max_p[i] - p[i], residual)\n                    p[i] += increase\n                    residual -= increase\n            else:\n                # Find units above min output\n                candidates = [(i, units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i])\n                             for i in committed if p[i] > min_p[i]]\n                candidates.sort(key=lambda x: x[1], reverse=True)\n                \n                for i, mc in candidates:\n                    if residual >= 0:\n                        break\n                    decrease = min(p[i] - min_p[i], -residual)\n                    p[i] -= decrease\n                    residual += decrease\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.005428673,
          "gap_price_rate": 0.0091001953,
          "fitness": 0.0072644341
     }
]