[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Identify must-run and must-off units based on min up/down times and shutdown constraints\n2. Initialize commitment states using forced status and previous states\n3. Compute current power ranges and check system adequacy\n4. If under-committed (total capacity < load), activate units by lowest average cost\n5. If over-committed (min capacity > load), deactivate non-essential units by highest operating cost\n6. Optimize adequate systems by turning off expensive non-essential units\n7. Perform economic dispatch using priority queue based on marginal costs\n",
          "code": "import heapq\nimport numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    # Initialize lists for must-run, must-off, and commitment state\n    must_commit = [False] * n\n    must_off = [False] * n\n    u_i = [0] * n\n    \n    # Step 1: Determine forced units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_commit[i] = True\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n                \n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_commit[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    # Helper function to compute power limits\n    def compute_power_limits(i, state):\n        if state == 0:\n            return 0, 0\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Starting unit\n            p_min_i = unit['p_min_i']\n            p_max_i = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        else:  # Running unit\n            p_min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return p_min_i, p_max_i\n    \n    # Initialize power limits arrays\n    p_min_arr = [0] * n\n    p_max_arr = [0] * n\n    for i in range(n):\n        p_min_arr[i], p_max_arr[i] = compute_power_limits(i, u_i[i])\n    \n    total_min = sum(p_min_arr)\n    total_max = sum(p_max_arr)\n    \n    # Step 3a: Handle under-committed case\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if u_i[i] == 0 and not must_off[i]]\n        def avg_cost(i):\n            unit = units_info[i]\n            min_power = unit['p_min_i']\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n        flexible_off.sort(key=avg_cost)\n        \n        for i in flexible_off:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            new_min, new_max = compute_power_limits(i, 1)\n            total_min = total_min + new_min\n            total_max = total_max + new_max\n            p_min_arr[i] = new_min\n            p_max_arr[i] = new_max\n    \n    # Step 3b: Handle over-committed case\n    if total_min > current_load:\n        flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            total_min -= p_min_arr[i]\n            total_max -= p_max_arr[i]\n            p_min_arr[i] = 0\n            p_max_arr[i] = 0\n    \n    # Step 3c: Optimize adequate case\n    flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n    if total_min <= current_load <= total_max:\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            new_total_min = total_min - p_min_arr[i]\n            new_total_max = total_max - p_max_arr[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                p_min_arr[i] = 0\n                p_max_arr[i] = 0\n    \n    # Finalize power limits\n    for i in range(n):\n        if u_i[i] == 1:\n            p_min_arr[i], p_max_arr[i] = compute_power_limits(i, 1)\n        else:\n            p_min_arr[i], p_max_arr[i] = 0, 0\n    \n    # Step 4: Economic Dispatch\n    p_i = [0] * n\n    committed_indices = [i for i in range(n) if u_i[i] == 1]\n    for i in committed_indices:\n        p_i[i] = p_min_arr[i]\n    \n    total_output = sum(p_i)\n    remaining = current_load - total_output\n    heap = []\n    \n    # Initialize priority queue\n    for i in committed_indices:\n        if p_i[i] < p_max_arr[i]:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    # Dispatch remaining load\n    while remaining > 1e-5 and heap:\n        mc, idx = heapq.heappop(heap)\n        max_inc = min(remaining, p_max_arr[idx] - p_i[idx])\n        p_i[idx] += max_inc\n        remaining -= max_inc\n        if p_i[idx] < p_max_arr[idx]:\n            new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_i[idx]\n            heapq.heappush(heap, (new_mc, idx))\n    \n    # Create and return schedule\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0062438914,
          "gap_price_rate": 0.0084205625,
          "fitness": 0.007332227
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into three categories based on constraints:\n   - Must-on: Units forced to remain on due to min-up time or shutdown capacity violation.\n   - Must-off: Units forced to remain off due to min-down time constraints.\n   - Flexible: Units that can be turned on or off.\n2. For must-on units, compute feasible output ranges considering ramp limits.\n3. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) output from must-on units.\n4. Based on current load and total must-on capacity:\n   a. If load is within must-on capacity: Dispatch load optimally among must-on units using lambda iteration.\n   b. If load < total must-on minimum: Set must-on units to minimum, others off.\n   c. If load > total must-on maximum: Turn on flexible units in priority order (cheapest average cost first) until demand is covered, then dispatch optimally among all online units.\n5. For must-off units: Set to off state and zero output.\n6. Return 2D array with commitment states (u_i) and outputs (p_i).\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_for_dispatch, load):\n    L_arr = np.array([u['L'] for u in units_for_dispatch])\n    U_arr = np.array([u['U'] for u in units_for_dispatch])\n    total_min = np.sum(L_arr)\n    total_max = np.sum(U_arr)\n    n = len(units_for_dispatch)\n    \n    if load <= total_min:\n        return L_arr.tolist()\n    elif load >= total_max:\n        return U_arr.tolist()\n    else:\n        low = float('inf')\n        high = -float('inf')\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                mc_low = u['b_i'] + 2*u['c_i'] * u['L']\n                mc_high = u['b_i'] + 2*u['c_i'] * u['U']\n                low = min(low, mc_low)\n                high = max(high, mc_high)\n            else:\n                low = min(low, u['b_i'])\n                high = max(high, u['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_power = 0\n            for u in units_for_dispatch:\n                if u['c_i'] > 0:\n                    p = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n                else:\n                    p = u['U'] if mid >= u['b_i'] else u['L']\n                total_power += p\n            if abs(total_power - load) < tol:\n                break\n            if total_power < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_list = []\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                p_val = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n            else:\n                p_val = u['U'] if mid >= u['b_i'] else u['L']\n            p_list.append(p_val)\n        \n        return p_list\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_periods = -unit['t_i_0']\n            if offline_periods < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    L_must_on = []\n    U_must_on = []\n    for i in must_on:\n        unit = units[i]\n        L = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        U = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        L_must_on.append(L)\n        U_must_on.append(U)\n    \n    total_min = sum(L_must_on) if must_on else 0\n    total_max = sum(U_must_on) if must_on else 0\n    schedules = np.zeros((2, len(units)))\n    \n    if total_min <= current_load <= total_max:\n        units_for_dispatch = []\n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    elif current_load < total_min:\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = L_must_on[idx]\n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    else:\n        flex_candidates = []\n        for i in flexible:\n            unit = units[i]\n            avg_cost = (unit['s_i'] + unit['a_i'] + \n                        unit['b_i']*unit['p_min_i'] + \n                        unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            flex_candidates.append((avg_cost, i))\n        flex_candidates.sort(key=lambda x: x[0])\n        \n        selected_flex = []\n        cum_added = 0\n        deficit = current_load - total_max\n        for _, i in flex_candidates:\n            capacity = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            selected_flex.append(i)\n            cum_added += capacity\n            if cum_added >= deficit:\n                break\n        \n        on_units_indices = must_on + selected_flex\n        units_for_dispatch = []\n        L_dict = {}\n        U_dict = {}\n        \n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            L_dict[i] = L_val\n            U_dict[i] = U_val\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        \n        for i in selected_flex:\n            unit = units[i]\n            L_dict[i] = unit['p_min_i']\n            U_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_dict[i],\n                'U': U_dict[i]\n            })\n        \n        total_min_dispatch = sum(L_dict[i] for i in on_units_indices)\n        total_max_dispatch = sum(U_dict[i] for i in on_units_indices)\n        \n        if current_load < total_min_dispatch:\n            dispatch_result = [L_dict[i] for i in on_units_indices]\n        elif current_load > total_max_dispatch:\n            dispatch_result = [U_dict[i] for i in on_units_indices]\n        else:\n            dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        \n        for idx, i in enumerate(on_units_indices):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in on_units_indices:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    for i in must_off:\n        schedules[0][i] = 0\n        schedules[1][i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058061183,
          "gap_price_rate": 0.0091680778,
          "fitness": 0.0074870981
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown capacity constraints) and forced-off units (must remain offline due to min down-time constraints)  \n2. Initialize committed units to forced-on units and previously online non-forced units  \n3. Compute total minimum and maximum power outputs from committed units  \n4. Classify system state:  \n   - Over-committed if total minimum > load: remove expensive non-forced units  \n   - Under-committed if total maximum < load: activate cheapest non-forced units  \n   - Adequate: remove non-essential units by cost priority  \n5. Perform economic dispatch:  \n   a. Set all units to minimum output if total minimum \u2265 load  \n   b. Set all units to maximum output if total maximum \u2264 load  \n   c. Otherwise, distribute load using greedy merit-order dispatch  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < min_up and t_i0 >= 0) or (p_i0 > p_shut):\n                forced_on[i] = True\n            min_output[i] = max(p_min, p_i0 - p_down)\n            max_output[i] = min(p_max, p_i0 + p_up)\n        else:\n            if u_i0 == 0 and t_i0 < 0 and -t_i0 < min_down:\n                forced_off[i] = True\n            min_output[i] = p_min\n            max_output[i] = min(p_max, p_start)\n        \n        if forced_off[i]:\n            min_output[i] = 0.0\n            max_output[i] = 0.0\n    \n    non_forced = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    committed_units = [i for i in range(n_units) if forced_on[i]]\n    non_forced_online = [i for i in non_forced if units_info[i]['u_i_0'] == 1]\n    non_forced_offline = [i for i in non_forced if units_info[i]['u_i_0'] == 0]\n    committed_units.extend(non_forced_online)\n    \n    avg_costs = []\n    for i in non_forced:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        if units_info[i]['u_i_0'] == 0:\n            cost_val = s + a + b * min_output[i] + c * min_output[i] ** 2\n        else:\n            cost_val = a + b * min_output[i] + c * min_output[i] ** 2\n        avg_costs.append(cost_val / min_output[i] if min_output[i] > 0 else float('inf'))\n    avg_costs = dict(zip(non_forced, avg_costs))\n    \n    total_min = sum(min_output[i] for i in committed_units)\n    total_max = sum(max_output[i] for i in committed_units)\n    \n    if total_min > current_load:\n        non_forced_in_committed = [i for i in committed_units if not forced_on[i]]\n        non_forced_in_committed.sort(key=lambda i: avg_costs[i], reverse=True)\n        for i in non_forced_in_committed:\n            new_min = total_min - min_output[i]\n            committed_units.remove(i)\n            total_min = new_min\n            total_max -= max_output[i]\n            if total_min <= current_load:\n                break\n    \n    elif total_max < current_load:\n        non_forced_offline.sort(key=lambda i: avg_costs[i])\n        for i in non_forced_offline:\n            if total_max < current_load:\n                committed_units.append(i)\n                total_min += min_output[i]\n                total_max += max_output[i]\n    \n    else:\n        non_forced_in_committed = [i for i in committed_units if not forced_on[i]]\n        non_forced_in_committed.sort(key=lambda i: avg_costs[i], reverse=True)\n        for i in non_forced_in_committed:\n            new_min = total_min - min_output[i]\n            new_max = total_max - max_output[i]\n            if new_min <= current_load <= new_max:\n                committed_units.remove(i)\n                total_min = new_min\n                total_max = new_max\n            else:\n                break\n    \n    u_final = [0] * n_units\n    p_final = [0] * n_units\n    for i in committed_units:\n        u_final[i] = 1\n        p_final[i] = min_output[i]\n    \n    if current_load <= total_min:\n        pass\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_final[i] = max_output[i]\n    else:\n        residual = current_load - total_min\n        candidate_units = [i for i in committed_units if p_final[i] < max_output[i]]\n        while residual > 0 and candidate_units:\n            marginal_costs = []\n            for i in candidate_units:\n                unit = units_info[i]\n                p_i = p_final[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_i\n                marginal_costs.append(marginal_cost)\n            \n            min_mc_idx = np.argmin(marginal_costs)\n            unit_idx = candidate_units[min_mc_idx]\n            max_add = max_output[unit_idx] - p_final[unit_idx]\n            add = min(residual, max_add)\n            p_final[unit_idx] += add\n            residual -= add\n            \n            if p_final[unit_idx] >= max_output[unit_idx]:\n                candidate_units.remove(unit_idx)\n    \n    return np.array([u_final, p_final])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "refined_commit_forced_constraints",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown ramp constraints) and forced-off units (must remain offline due to min down-time constraints).\n2. Initialize committed units with forced-on units. Compute feasible power ranges considering ramp limits for each.\n3. Classify non-forced units as candidate units. Calculate average cost including startup cost for candidate units currently offline. Sort candidate units by increasing average cost.\n4. Commit cheapest candidate units until cumulative maximum output meets or exceeds current load, updating feasible power ranges for newly committed units.\n5. If cumulative minimum output exceeds load, remove most expensive non-forced committed units until feasible minimum generation satisfies the load or capacity limitations.\n6. Set outputs to minimum values if total minimum output \u2265 load, or to maximum values if total maximum output \u2264 load.\n7. Otherwise, perform greedy incremental dispatch starting from minimum outputs: increment unit with smallest marginal cost until load is satisfied.\n8. Return commitment status and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef refined_commit_forced_constraints(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    # Identify forced on/off and candidate units\n    forced_on_indices = []\n    forced_off_indices = []\n    candidate_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_indices.append(i)\n            else:\n                candidate_indices.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                candidate_indices.append(i)\n    \n    # Initialize committed set and compute feasible ranges for forced-on units\n    committed_indices = forced_on_indices.copy()\n    committed_data = {}\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in forced_on_indices:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        committed_data[i] = {'min_p': min_p, 'max_p': max_p}\n        total_min += min_p\n        total_max += max_p\n    \n    # Process candidate units: calculate average cost and sort\n    candidate_list = []\n    for i in candidate_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Offline candidate\n            cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']\n        else:  # Online candidate\n            cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n        avg_cost = cost / unit['p_min_i'] if unit['p_min_i'] > 0 else float('inf')\n        candidate_list.append((avg_cost, i))\n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Commit candidate units until capacity meets/exceeds load\n    temp_added = []\n    for avg_cost, i in candidate_list:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Offline unit being started\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        else:  # Online unit\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        committed_indices.append(i)\n        committed_data[i] = {'min_p': min_p, 'max_p': max_p}\n        total_min += min_p\n        total_max += max_p\n        temp_added.append((i, min_p, max_p, avg_cost))\n    \n    # Remove expensive units if minimum generation exceeds load\n    if total_min > current_load:\n        temp_added_sorted = sorted(temp_added, key=lambda x: x[3], reverse=True)\n        for i, min_p, max_p, _ in temp_added_sorted:\n            if total_max - max_p >= current_load:\n                committed_indices.remove(i)\n                del committed_data[i]\n                total_min -= min_p\n                total_max -= max_p\n                if total_min <= current_load:\n                    break\n    \n    # Set default dispatch to minimum outputs\n    for i in committed_indices:\n        u_arr[i] = 1\n        p_arr[i] = committed_data[i]['min_p']\n    \n    # Handle dispatch cases\n    total_output = sum(p_arr)\n    deficit = current_load - total_output\n    \n    if deficit > 0:  # Need to increase output\n        # Greedy incremental dispatch based on marginal cost\n        active_units = [(i, p_arr[i]) for i in committed_indices \n                        if p_arr[i] < committed_data[i]['max_p']]\n        while deficit > 0 and active_units:\n            min_mc = float('inf')\n            best_i = None\n            for idx, (i, current_p) in enumerate(active_units):\n                unit = units_info[i]\n                mc = 2 * unit['c_i'] * current_p + unit['b_i']\n                if mc < min_mc:\n                    min_mc = mc\n                    best_i = i\n                    best_idx = idx\n                    best_current_p = current_p\n            \n            if best_i is None:\n                break\n                \n            unit = units_info[best_i]\n            max_inc = committed_data[best_i]['max_p'] - best_current_p\n            inc = min(deficit, max_inc)\n            p_arr[best_i] += inc\n            deficit -= inc\n            \n            # Update active units\n            if inc == max_inc:  # Unit at max\n                del active_units[best_idx]\n            else:  # Update unit's current output\n                active_units[best_idx] = (best_i, p_arr[best_i])\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0061537333,
          "gap_price_rate": 0.0098240279,
          "fitness": 0.0079888806
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-run (due to min-up/shutdown constraints), must-off (due to min-down time), and flexible (remaining units).\n2. Compute feasible power range for each unit based on ramp limits and startup/shutdown constraints.\n3. Calculate base load from must-run units set to minimum feasible power.\n4. Sort flexible units by average cost per MW (including startup cost if turned on) at minimum power.\n5. Activate flexible units in order of increasing cost until cumulative maximum capacity meets or exceeds current load.\n6. Perform economic dispatch:\n   - If minimum base load exceeds current load, set all committed units to minimum power.\n   - Otherwise, distribute remaining load among committed units using greedy adjustment based on marginal cost.\n7. Set non-committed units to off state with zero power output.\n8. Return schedule with commitment states and dispatch levels.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u_commit = [0] * n_units\n    p_dispatch = [0] * n_units\n    min_power = [0] * n_units\n    max_power = [0] * n_units\n    must_run = []\n    must_off = []\n    flex = []\n\n    # Precompute min/max power and classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pstart = unit['p_start_i']\n        pshut = unit['p_shut_i']\n        minup = unit['t_on_min_i']\n        mindown = unit['t_off_min_i']\n        \n        # Compute feasible power range\n        if u0 == 1:\n            min_power[i] = max(pmin, p0 - pdown)\n            max_power[i] = min(pmax, p0 + pup)\n            if t0 < minup or p0 > pshut:\n                must_run.append(i)\n                u_commit[i] = 1\n            else:\n                flex.append(i)\n        else:\n            min_power[i] = pmin\n            max_power[i] = min(pmax, pstart)\n            if abs(t0) < mindown:\n                must_off.append(i)\n                u_commit[i] = 0\n            else:\n                flex.append(i)\n    \n    # Calculate base capacity from must-run units\n    base_min = sum(min_power[i] for i in must_run)\n    base_max = sum(max_power[i] for i in must_run)\n    flex_costs = []\n    flex_idx = []\n\n    # Calculate average cost per MW for flexible units\n    for i in flex:\n        unit = units_info[i]\n        minp = min_power[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost_val = a + b * minp + c * minp**2 + s\n        cost_per_mw = cost_val / minp if minp > 0 else float('inf')\n        flex_costs.append(cost_per_mw)\n        flex_idx.append(i)\n    \n    # Sort flexible units by cost (lowest first)\n    sorted_flex = sorted(zip(flex_idx, flex_costs), key=lambda x: x[1])\n    flex_sorted = [x[0] for x in sorted_flex]\n    committed_flex = []\n    curr_min = base_min\n    curr_max = base_max\n\n    # Commit flexible units until capacity meets load\n    for i in flex_sorted:\n        if curr_max < load[0]:\n            committed_flex.append(i)\n            u_commit[i] = 1\n            curr_min += min_power[i]\n            curr_max += max_power[i]\n        else:\n            break\n    \n    # Set initial dispatch to minimum power for committed units\n    for i in must_run + committed_flex:\n        p_dispatch[i] = min_power[i]\n    active_units = must_run + committed_flex\n    total_power = curr_min\n\n    # Economic dispatch: distribute remaining load\n    if total_power < load[0]:\n        need = load[0] - total_power\n        while need > 0 and active_units:\n            best_unit = None\n            best_marginal = float('inf')\n            # Find unit with lowest marginal cost\n            for i in active_units:\n                p_i = p_dispatch[i]\n                if p_i < max_power[i]:\n                    marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n            if best_unit is None:\n                break\n            # Calculate maximum possible increase\n            room = max_power[best_unit] - p_dispatch[best_unit]\n            delta = min(need, room)\n            p_dispatch[best_unit] += delta\n            need -= delta\n            # Remove unit if at maximum\n            if p_dispatch[best_unit] >= max_power[best_unit]:\n                active_units.remove(best_unit)\n    # Set non-committed units to off state\n    for i in set(range(n_units)) - set(must_run + committed_flex):\n        u_commit[i] = 0\n        p_dispatch[i] = 0\n    \n    return np.array([u_commit, p_dispatch])",
          "from": null,
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     }
]