[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Identify must-run and must-off units based on min up/down times and shutdown constraints\n2. Initialize commitment states using forced status and previous states\n3. Compute current power ranges and check system adequacy\n4. If under-committed (total capacity < load), activate units by lowest average cost\n5. If over-committed (min capacity > load), deactivate non-essential units by highest operating cost\n6. Optimize adequate systems by turning off expensive non-essential units\n7. Perform economic dispatch using priority queue based on marginal costs\n",
          "code": "import heapq\nimport numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    # Initialize lists for must-run, must-off, and commitment state\n    must_commit = [False] * n\n    must_off = [False] * n\n    u_i = [0] * n\n    \n    # Step 1: Determine forced units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_commit[i] = True\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n                \n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_commit[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n    \n    # Helper function to compute power limits\n    def compute_power_limits(i, state):\n        if state == 0:\n            return 0, 0\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Starting unit\n            p_min_i = unit['p_min_i']\n            p_max_i = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        else:  # Running unit\n            p_min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        return p_min_i, p_max_i\n    \n    # Initialize power limits arrays\n    p_min_arr = [0] * n\n    p_max_arr = [0] * n\n    for i in range(n):\n        p_min_arr[i], p_max_arr[i] = compute_power_limits(i, u_i[i])\n    \n    total_min = sum(p_min_arr)\n    total_max = sum(p_max_arr)\n    \n    # Step 3a: Handle under-committed case\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if u_i[i] == 0 and not must_off[i]]\n        def avg_cost(i):\n            unit = units_info[i]\n            min_power = unit['p_min_i']\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2) / min_power\n        flexible_off.sort(key=avg_cost)\n        \n        for i in flexible_off:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            new_min, new_max = compute_power_limits(i, 1)\n            total_min = total_min + new_min\n            total_max = total_max + new_max\n            p_min_arr[i] = new_min\n            p_max_arr[i] = new_max\n    \n    # Step 3b: Handle over-committed case\n    if total_min > current_load:\n        flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            total_min -= p_min_arr[i]\n            total_max -= p_max_arr[i]\n            p_min_arr[i] = 0\n            p_max_arr[i] = 0\n    \n    # Step 3c: Optimize adequate case\n    flexible_on = [i for i in range(n) if u_i[i] == 1 and not must_commit[i]]\n    if total_min <= current_load <= total_max:\n        def prod_cost(i):\n            return units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_arr[i] + units_info[i]['c_i'] * p_min_arr[i]**2\n        flexible_on.sort(key=prod_cost, reverse=True)\n        \n        for i in flexible_on:\n            new_total_min = total_min - p_min_arr[i]\n            new_total_max = total_max - p_max_arr[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                p_min_arr[i] = 0\n                p_max_arr[i] = 0\n    \n    # Finalize power limits\n    for i in range(n):\n        if u_i[i] == 1:\n            p_min_arr[i], p_max_arr[i] = compute_power_limits(i, 1)\n        else:\n            p_min_arr[i], p_max_arr[i] = 0, 0\n    \n    # Step 4: Economic Dispatch\n    p_i = [0] * n\n    committed_indices = [i for i in range(n) if u_i[i] == 1]\n    for i in committed_indices:\n        p_i[i] = p_min_arr[i]\n    \n    total_output = sum(p_i)\n    remaining = current_load - total_output\n    heap = []\n    \n    # Initialize priority queue\n    for i in committed_indices:\n        if p_i[i] < p_max_arr[i]:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    # Dispatch remaining load\n    while remaining > 1e-5 and heap:\n        mc, idx = heapq.heappop(heap)\n        max_inc = min(remaining, p_max_arr[idx] - p_i[idx])\n        p_i[idx] += max_inc\n        remaining -= max_inc\n        if p_i[idx] < p_max_arr[idx]:\n            new_mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_i[idx]\n            heapq.heappush(heap, (new_mc, idx))\n    \n    # Create and return schedule\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0062438914,
          "gap_price_rate": 0.0084205625,
          "fitness": 0.007332227
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into three categories based on constraints:\n   - Must-on: Units forced to remain on due to min-up time or shutdown capacity violation.\n   - Must-off: Units forced to remain off due to min-down time constraints.\n   - Flexible: Units that can be turned on or off.\n2. For must-on units, compute feasible output ranges considering ramp limits.\n3. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) output from must-on units.\n4. Based on current load and total must-on capacity:\n   a. If load is within must-on capacity: Dispatch load optimally among must-on units using lambda iteration.\n   b. If load < total must-on minimum: Set must-on units to minimum, others off.\n   c. If load > total must-on maximum: Turn on flexible units in priority order (cheapest average cost first) until demand is covered, then dispatch optimally among all online units.\n5. For must-off units: Set to off state and zero output.\n6. Return 2D array with commitment states (u_i) and outputs (p_i).\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_for_dispatch, load):\n    L_arr = np.array([u['L'] for u in units_for_dispatch])\n    U_arr = np.array([u['U'] for u in units_for_dispatch])\n    total_min = np.sum(L_arr)\n    total_max = np.sum(U_arr)\n    n = len(units_for_dispatch)\n    \n    if load <= total_min:\n        return L_arr.tolist()\n    elif load >= total_max:\n        return U_arr.tolist()\n    else:\n        low = float('inf')\n        high = -float('inf')\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                mc_low = u['b_i'] + 2*u['c_i'] * u['L']\n                mc_high = u['b_i'] + 2*u['c_i'] * u['U']\n                low = min(low, mc_low)\n                high = max(high, mc_high)\n            else:\n                low = min(low, u['b_i'])\n                high = max(high, u['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_power = 0\n            for u in units_for_dispatch:\n                if u['c_i'] > 0:\n                    p = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n                else:\n                    p = u['U'] if mid >= u['b_i'] else u['L']\n                total_power += p\n            if abs(total_power - load) < tol:\n                break\n            if total_power < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_list = []\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                p_val = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n            else:\n                p_val = u['U'] if mid >= u['b_i'] else u['L']\n            p_list.append(p_val)\n        \n        return p_list\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_periods = -unit['t_i_0']\n            if offline_periods < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    L_must_on = []\n    U_must_on = []\n    for i in must_on:\n        unit = units[i]\n        L = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        U = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        L_must_on.append(L)\n        U_must_on.append(U)\n    \n    total_min = sum(L_must_on) if must_on else 0\n    total_max = sum(U_must_on) if must_on else 0\n    schedules = np.zeros((2, len(units)))\n    \n    if total_min <= current_load <= total_max:\n        units_for_dispatch = []\n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    elif current_load < total_min:\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = L_must_on[idx]\n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    else:\n        flex_candidates = []\n        for i in flexible:\n            unit = units[i]\n            avg_cost = (unit['s_i'] + unit['a_i'] + \n                        unit['b_i']*unit['p_min_i'] + \n                        unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            flex_candidates.append((avg_cost, i))\n        flex_candidates.sort(key=lambda x: x[0])\n        \n        selected_flex = []\n        cum_added = 0\n        deficit = current_load - total_max\n        for _, i in flex_candidates:\n            capacity = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            selected_flex.append(i)\n            cum_added += capacity\n            if cum_added >= deficit:\n                break\n        \n        on_units_indices = must_on + selected_flex\n        units_for_dispatch = []\n        L_dict = {}\n        U_dict = {}\n        \n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            L_dict[i] = L_val\n            U_dict[i] = U_val\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        \n        for i in selected_flex:\n            unit = units[i]\n            L_dict[i] = unit['p_min_i']\n            U_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_dict[i],\n                'U': U_dict[i]\n            })\n        \n        total_min_dispatch = sum(L_dict[i] for i in on_units_indices)\n        total_max_dispatch = sum(U_dict[i] for i in on_units_indices)\n        \n        if current_load < total_min_dispatch:\n            dispatch_result = [L_dict[i] for i in on_units_indices]\n        elif current_load > total_max_dispatch:\n            dispatch_result = [U_dict[i] for i in on_units_indices]\n        else:\n            dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        \n        for idx, i in enumerate(on_units_indices):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in on_units_indices:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    for i in must_off:\n        schedules[0][i] = 0\n        schedules[1][i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058061183,
          "gap_price_rate": 0.0091680778,
          "fitness": 0.0074870981
     },
     {
          "name": "refined_commit_forced_constraints",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown ramp constraints) and forced-off units (must remain offline due to min down-time constraints).\n2. Initialize committed units with forced-on units. Compute feasible power ranges considering ramp limits for each.\n3. Classify non-forced units as candidate units. Calculate average cost including startup cost for candidate units currently offline. Sort candidate units by increasing average cost.\n4. Commit cheapest candidate units until cumulative maximum output meets or exceeds current load, updating feasible power ranges for newly committed units.\n5. If cumulative minimum output exceeds load, remove most expensive non-forced committed units until feasible minimum generation satisfies the load or capacity limitations.\n6. Set outputs to minimum values if total minimum output \u2265 load, or to maximum values if total maximum output \u2264 load.\n7. Otherwise, perform greedy incremental dispatch starting from minimum outputs: increment unit with smallest marginal cost until load is satisfied.\n8. Return commitment status and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef refined_commit_forced_constraints(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    # Identify forced on/off and candidate units\n    forced_on_indices = []\n    forced_off_indices = []\n    candidate_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_indices.append(i)\n            else:\n                candidate_indices.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                candidate_indices.append(i)\n    \n    # Initialize committed set and compute feasible ranges for forced-on units\n    committed_indices = forced_on_indices.copy()\n    committed_data = {}\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in forced_on_indices:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        committed_data[i] = {'min_p': min_p, 'max_p': max_p}\n        total_min += min_p\n        total_max += max_p\n    \n    # Process candidate units: calculate average cost and sort\n    candidate_list = []\n    for i in candidate_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Offline candidate\n            cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']\n        else:  # Online candidate\n            cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n        avg_cost = cost / unit['p_min_i'] if unit['p_min_i'] > 0 else float('inf')\n        candidate_list.append((avg_cost, i))\n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Commit candidate units until capacity meets/exceeds load\n    temp_added = []\n    for avg_cost, i in candidate_list:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Offline unit being started\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        else:  # Online unit\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        committed_indices.append(i)\n        committed_data[i] = {'min_p': min_p, 'max_p': max_p}\n        total_min += min_p\n        total_max += max_p\n        temp_added.append((i, min_p, max_p, avg_cost))\n    \n    # Remove expensive units if minimum generation exceeds load\n    if total_min > current_load:\n        temp_added_sorted = sorted(temp_added, key=lambda x: x[3], reverse=True)\n        for i, min_p, max_p, _ in temp_added_sorted:\n            if total_max - max_p >= current_load:\n                committed_indices.remove(i)\n                del committed_data[i]\n                total_min -= min_p\n                total_max -= max_p\n                if total_min <= current_load:\n                    break\n    \n    # Set default dispatch to minimum outputs\n    for i in committed_indices:\n        u_arr[i] = 1\n        p_arr[i] = committed_data[i]['min_p']\n    \n    # Handle dispatch cases\n    total_output = sum(p_arr)\n    deficit = current_load - total_output\n    \n    if deficit > 0:  # Need to increase output\n        # Greedy incremental dispatch based on marginal cost\n        active_units = [(i, p_arr[i]) for i in committed_indices \n                        if p_arr[i] < committed_data[i]['max_p']]\n        while deficit > 0 and active_units:\n            min_mc = float('inf')\n            best_i = None\n            for idx, (i, current_p) in enumerate(active_units):\n                unit = units_info[i]\n                mc = 2 * unit['c_i'] * current_p + unit['b_i']\n                if mc < min_mc:\n                    min_mc = mc\n                    best_i = i\n                    best_idx = idx\n                    best_current_p = current_p\n            \n            if best_i is None:\n                break\n                \n            unit = units_info[best_i]\n            max_inc = committed_data[best_i]['max_p'] - best_current_p\n            inc = min(deficit, max_inc)\n            p_arr[best_i] += inc\n            deficit -= inc\n            \n            # Update active units\n            if inc == max_inc:  # Unit at max\n                del active_units[best_idx]\n            else:  # Update unit's current output\n                active_units[best_idx] = (best_i, p_arr[best_i])\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0061537333,
          "gap_price_rate": 0.0098240279,
          "fitness": 0.0079888806
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-run (due to min-up/shutdown constraints), must-off (due to min-down time), and flexible (remaining units).\n2. Compute feasible power range for each unit based on ramp limits and startup/shutdown constraints.\n3. Calculate base load from must-run units set to minimum feasible power.\n4. Sort flexible units by average cost per MW (including startup cost if turned on) at minimum power.\n5. Activate flexible units in order of increasing cost until cumulative maximum capacity meets or exceeds current load.\n6. Perform economic dispatch:\n   - If minimum base load exceeds current load, set all committed units to minimum power.\n   - Otherwise, distribute remaining load among committed units using greedy adjustment based on marginal cost.\n7. Set non-committed units to off state with zero power output.\n8. Return schedule with commitment states and dispatch levels.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u_commit = [0] * n_units\n    p_dispatch = [0] * n_units\n    min_power = [0] * n_units\n    max_power = [0] * n_units\n    must_run = []\n    must_off = []\n    flex = []\n\n    # Precompute min/max power and classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pstart = unit['p_start_i']\n        pshut = unit['p_shut_i']\n        minup = unit['t_on_min_i']\n        mindown = unit['t_off_min_i']\n        \n        # Compute feasible power range\n        if u0 == 1:\n            min_power[i] = max(pmin, p0 - pdown)\n            max_power[i] = min(pmax, p0 + pup)\n            if t0 < minup or p0 > pshut:\n                must_run.append(i)\n                u_commit[i] = 1\n            else:\n                flex.append(i)\n        else:\n            min_power[i] = pmin\n            max_power[i] = min(pmax, pstart)\n            if abs(t0) < mindown:\n                must_off.append(i)\n                u_commit[i] = 0\n            else:\n                flex.append(i)\n    \n    # Calculate base capacity from must-run units\n    base_min = sum(min_power[i] for i in must_run)\n    base_max = sum(max_power[i] for i in must_run)\n    flex_costs = []\n    flex_idx = []\n\n    # Calculate average cost per MW for flexible units\n    for i in flex:\n        unit = units_info[i]\n        minp = min_power[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost_val = a + b * minp + c * minp**2 + s\n        cost_per_mw = cost_val / minp if minp > 0 else float('inf')\n        flex_costs.append(cost_per_mw)\n        flex_idx.append(i)\n    \n    # Sort flexible units by cost (lowest first)\n    sorted_flex = sorted(zip(flex_idx, flex_costs), key=lambda x: x[1])\n    flex_sorted = [x[0] for x in sorted_flex]\n    committed_flex = []\n    curr_min = base_min\n    curr_max = base_max\n\n    # Commit flexible units until capacity meets load\n    for i in flex_sorted:\n        if curr_max < load[0]:\n            committed_flex.append(i)\n            u_commit[i] = 1\n            curr_min += min_power[i]\n            curr_max += max_power[i]\n        else:\n            break\n    \n    # Set initial dispatch to minimum power for committed units\n    for i in must_run + committed_flex:\n        p_dispatch[i] = min_power[i]\n    active_units = must_run + committed_flex\n    total_power = curr_min\n\n    # Economic dispatch: distribute remaining load\n    if total_power < load[0]:\n        need = load[0] - total_power\n        while need > 0 and active_units:\n            best_unit = None\n            best_marginal = float('inf')\n            # Find unit with lowest marginal cost\n            for i in active_units:\n                p_i = p_dispatch[i]\n                if p_i < max_power[i]:\n                    marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n            if best_unit is None:\n                break\n            # Calculate maximum possible increase\n            room = max_power[best_unit] - p_dispatch[best_unit]\n            delta = min(need, room)\n            p_dispatch[best_unit] += delta\n            need -= delta\n            # Remove unit if at maximum\n            if p_dispatch[best_unit] >= max_power[best_unit]:\n                active_units.remove(best_unit)\n    # Set non-committed units to off state\n    for i in set(range(n_units)) - set(must_run + committed_flex):\n        u_commit[i] = 0\n        p_dispatch[i] = 0\n    \n    return np.array([u_commit, p_dispatch])",
          "from": null,
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "commit_units_with_forced_constraints",
          "algorithm": "1. Identify units that are forced to stay on (due to minimum up-time or shutdown ramp constraints) or forced to stay off (due to minimum down-time constraints).\n2. Calculate the minimum and maximum output limits for forced-on units considering their ramp constraints.\n3. Sort candidate units (non-forced and not forced off) by average cost per MWh at minimum output.\n4. Commit candidate units in order of priority until the total maximum output can meet the current load.\n5. For committed units, compute actual output bounds considering ramp constraints and whether the unit is starting.\n6. If the load is below the total minimum output of committed units, set outputs to their minimum values.\n7. If the load exceeds the total maximum output of committed units, set outputs to their maximum values.\n8. For loads within the feasible range, perform economic dispatch using a greedy algorithm that increases the unit with the smallest marginal cost until the load is met.\n9. Output the commitment status and power output for each unit.\n\n",
          "code": "import numpy as np\n\ndef commit_units_with_forced_constraints(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    low_bound = [0.0] * n_units\n    high_bound = [0.0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            p_i_prev = units_info[i]['p_i_0']\n            low_bound[i] = max(units_info[i]['p_min_i'], p_i_prev - units_info[i]['p_down_i'])\n            high_bound[i] = min(units_info[i]['p_max_i'], p_i_prev + units_info[i]['p_up_i'])\n        elif forced_off[i]:\n            low_bound[i] = 0.0\n            high_bound[i] = 0.0\n    \n    forced_on_set = set(i for i in range(n_units) if forced_on[i])\n    T_min_total = sum(low_bound[i] for i in forced_on_set)\n    T_max_total = sum(high_bound[i] for i in forced_on_set)\n    \n    candidate_units = []\n    for i in range(n_units):\n        if not forced_on[i] and not forced_off[i]:\n            candidate_units.append(i)\n    \n    def compute_avg_cost(i):\n        unit = units_info[i]\n        if unit['p_min_i'] == 0:\n            return float('inf')\n        cost_start = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        return cost_start / unit['p_min_i']\n    \n    candidate_units.sort(key=compute_avg_cost)\n    S = set(forced_on_set)\n    \n    for i in candidate_units:\n        if T_max_total >= load[0]:\n            break\n        low_candidate = units_info[i]['p_min_i']\n        high_candidate = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        S.add(i)\n        T_min_total += low_candidate\n        T_max_total += high_candidate\n    \n    low_bound_S = {}\n    high_bound_S = {}\n    for i in S:\n        if units_info[i]['u_i_0'] == 1:\n            p_i_prev = units_info[i]['p_i_0']\n            low_bound_S[i] = max(units_info[i]['p_min_i'], p_i_prev - units_info[i]['p_down_i'])\n            high_bound_S[i] = min(units_info[i]['p_max_i'], p_i_prev + units_info[i]['p_up_i'])\n        else:\n            low_bound_S[i] = units_info[i]['p_min_i']\n            high_bound_S[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    T_min_S = sum(low_bound_S.get(i, 0) for i in S)\n    T_max_S = sum(high_bound_S.get(i, 0) for i in S)\n    L = load[0]\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if L <= T_min_S:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = low_bound_S[i]\n    elif L >= T_max_S:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = high_bound_S[i]\n    else:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = low_bound_S[i]\n        total_p = T_min_S\n        active_set = set(i for i in S if p_out[i] < high_bound_S[i] - 1e-6)\n        \n        while total_p < L and active_set:\n            min_mc = float('inf')\n            candidate = None\n            for i in active_set:\n                if units_info[i]['c_i'] == 0:\n                    mc = units_info[i]['b_i']\n                else:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n            \n            if candidate is None:\n                break\n                \n            max_inc = high_bound_S[candidate] - p_out[candidate]\n            inc = min(max_inc, L - total_p)\n            p_out[candidate] += inc\n            total_p += inc\n            if p_out[candidate] >= high_bound_S[candidate] - 1e-6:\n                active_set.remove(candidate)\n    \n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u_out\n    schedules[1, :] = p_out\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "adaptive_priority_rolling_commitment",
          "algorithm": "1. Determine must-commit and must-off units based on min up/down time and shutdown ramp constraints  \n2. Compute minimum/maximum power from committed units considering ramp limits  \n3. Classify commitment case (under, over, adequate) with candidate units  \n4. For under-committed: Start cheapest candidate units until load can be met  \n5. For over-committed: Turn off expensive candidate units to reduce minimum generation  \n6. For adequate: Optimize by turning off expensive non-essential units  \n7. Perform constrained economic dispatch using greedy incremental cost allocation  \n8. Return commitment and dispatch schedule  \n\n",
          "code": "import numpy as np  \n\ndef adaptive_priority_rolling_commitment(units_info, load):  \n    current_load = load[0]  \n    next_load_forecast = load[1]  \n    n_units = len(units_info)  \n    schedules = np.zeros((2, n_units))  \n    committed = [False] * n_units  \n    min_output = [0.0] * n_units  \n    max_output = [0.0] * n_units  \n    forced_on = [False] * n_units  \n    forced_off = [False] * n_units  \n    candidate_off = []  \n    candidate_on = []  \n    \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_up = unit['p_up_i']  \n        p_down = unit['p_down_i']  \n        p_start = unit['p_start_i']  \n        p_shut = unit['p_shut_i']  \n        t_on_min = unit['t_on_min_i']  \n        t_off_min = unit['t_off_min_i']  \n        \n        if u_i0 == 1:  \n            min_output[i] = max(p_min, p_i0 - p_down)  \n            max_output[i] = min(p_max, p_i0 + p_up)  \n            if t_i0 < t_on_min:  \n                committed[i] = True  \n                forced_on[i] = True  \n            elif p_i0 > p_shut:  \n                committed[i] = True  \n                forced_on[i] = True  \n            else:  \n                candidate_off.append(i)  \n        else:  \n            min_output[i] = p_min  \n            max_output[i] = min(p_max, p_start)  \n            if abs(t_i0) < t_off_min:  \n                committed[i] = False  \n                forced_off[i] = True  \n            else:  \n                candidate_on.append(i)  \n    \n    min_forced = sum(min_output[i] for i in range(n_units) if forced_on[i])  \n    max_forced = sum(max_output[i] for i in range(n_units) if forced_on[i])  \n    min_candidate_off = sum(min_output[i] for i in candidate_off)  \n    max_candidate_off = sum(max_output[i] for i in candidate_off)  \n    total_min = min_forced + min_candidate_off  \n    total_max = max_forced + max_candidate_off  \n    \n    if current_load > total_max:  \n        case = 'under'  \n    elif current_load < min_forced:  \n        case = 'over'  \n    else:  \n        case = 'adequate'  \n    \n    turned_off = []  \n    started = []  \n    \n    if case == 'under':  \n        candidate_on_sorted = sorted(  \n            candidate_on,  \n            key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_output[i]  \n        )  \n        for i in candidate_on_sorted:  \n            if total_max >= current_load:  \n                break  \n            unit = units_info[i]  \n            total_min += min_output[i]  \n            total_max += max_output[i]  \n            committed[i] = True  \n            started.append(i)  \n    \n    elif case == 'over':  \n        cost_candidate_off = [  \n            (i, units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] +  \n             units_info[i]['c_i'] * min_output[i]**2)  \n            for i in candidate_off  \n        ]  \n        candidate_off_sorted = sorted(cost_candidate_off, key=lambda x: x[1], reverse=True)  \n        turned_off = []  \n        for i, cost_val in candidate_off_sorted:  \n            new_min = total_min - min_output[i]  \n            new_max = total_max - max_output[i]  \n            if new_min <= current_load <= new_max:  \n                turned_off.append(i)  \n                total_min = new_min  \n                total_max = new_max  \n            if total_min <= current_load:  \n                break  \n        for i in turned_off:  \n            committed[i] = False  \n            candidate_off.remove(i)  \n    \n    else:  \n        cost_candidate_off = [  \n            (i, units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] +  \n             units_info[i]['c_i'] * min_output[i]**2)  \n            for i in candidate_off  \n        ]  \n        candidate_off_sorted = sorted(cost_candidate_off, key=lambda x: x[1], reverse=True)  \n        for i, cost_val in candidate_off_sorted:  \n            new_min = total_min - min_output[i]  \n            new_max = total_max - max_output[i]  \n            if new_min <= current_load <= new_max:  \n                committed[i] = False  \n                total_min = new_min  \n                total_max = new_max  \n    \n    # Initialize dispatch and adjust for ramp constraints  \n    p_alloc = [0.0] * n_units  \n    allocated = 0.0  \n    residual = current_load  \n    increments = []  \n    \n    for i in range(n_units):  \n        if not committed[i]:  \n            continue  \n        unit = units_info[i]  \n        if forced_off[i] or not committed[i]:  \n            continue  \n        u_i0 = unit['u_i_0']  \n        p_i0 = unit['p_i_0']  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_up = unit['p_up_i']  \n        p_down = unit['p_down_i']  \n        p_start = unit['p_start_i']  \n        b_i = unit['b_i']  \n        c_i = unit['c_i']  \n        \n        if u_i0 == 1:  \n            p_low = max(p_min, p_i0 - p_down)  \n            p_high = min(p_max, p_i0 + p_up)  \n        else:  \n            p_low = p_min  \n            p_high = min(p_max, p_start)  \n        \n        p_alloc[i] = p_low  \n        residual -= p_low  \n        avail = p_high - p_low  \n        marginal_cost = b_i + 2 * c_i * p_low  \n        increments.append((i, marginal_cost, avail))  \n    \n    if residual > 0:  \n        increments_sorted = sorted(increments, key=lambda x: x[1])  \n        for (i, mc, avail) in increments_sorted:  \n            if residual <= avail:  \n                p_alloc[i] += residual  \n                residual = 0  \n                break  \n            else:  \n                p_alloc[i] += avail  \n                residual -= avail  \n    \n    # Handle startup costs by setting commitment state  \n    for i in range(n_units):  \n        schedules[0, i] = int(committed[i])  \n        schedules[1, i] = p_alloc[i]  \n    \n    return schedules  ",
          "from": null,
          "gap_power_rate": 0.0101077905,
          "gap_price_rate": 0.010495207,
          "fitness": 0.0103014987
     },
     {
          "name": "refined_commit_forced_constraints_enhanced",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown ramp constraints) and forced-off (must remain offline due to min down-time constraints)\n2. Initialize committed units as forced-on units with updated power bounds considering ramp constraints\n3. Calculate average cost per MW (including startup cost if offline) for candidate units (non-forced, non-off), sort by increasing average cost\n4. Iteratively commit cheapest candidate units until the total maximum output of committed units meets/exceeds current load\n   - Update power bounds for newly committed units considering startup/shutdown and ramp constraints\n5. While total minimum output of committed units exceeds load and removal doesn't violate load coverage:\n   - Remove highest-cost non-forced unit from committed units that allows remaining units to meet load at max output\n6. Adjust units' outputs:\n   a) If total minimum output \u2265 load: set all outputs to minimum\n   b) If total maximum output \u2264 load: set all outputs to maximum\n   c) Otherwise: perform economic dispatch using lambda iteration with bounds to distribute load\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef refined_commit_forced_constraints_enhanced(units_info, load):\n    current_load = load[0]  # Extract current load\n    num_units = len(units_info)\n    u_i = np.zeros(num_units)  # Commitment states\n    p_i = np.zeros(num_units)  # Power outputs\n    min_i = np.zeros(num_units)  # Min power for committed units\n    max_i = np.zeros(num_units)  # Max power for committed units\n    \n    # Identify forced-on and forced-off units\n    forced_on = [False] * num_units\n    forced_off = [False] * num_units\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        p_down = unit['p_down_i']\n        \n        # Forced-on: currently on with min up-time not met or can't shut down due to output\n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on[idx] = True\n        \n        # Forced-off: currently off with min down-time not met\n        if u_i0 == 0 and abs(t_i0) < t_off_min:\n            forced_off[idx] = True\n    \n    # Initialize committed units with forced-on, set output bounds\n    committed_units = []\n    for idx, unit in enumerate(units_info):\n        if forced_on[idx]:\n            u_i0 = unit['u_i_0']\n            p_i0 = unit['p_i_0']\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_down = unit['p_down_i']\n            p_up = unit['p_up_i']\n            \n            # Units already on have ramp constraints\n            min_val = max(p_min, p_i0 - p_down)\n            max_val = min(p_max, p_i0 + p_up)\n            min_i[idx] = min_val\n            max_i[idx] = max_val\n            u_i[idx] = 1\n            committed_units.append(idx)\n    \n    # Prepare candidate units (non-forced, non-off)\n    candidate_units = []\n    for idx, unit in enumerate(units_info):\n        if not forced_on[idx] and not forced_off[idx]:\n            u_i0 = unit['u_i_0']\n            p_min = unit['p_min_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            \n            # Calculate average cost per MW\n            min_cost = b_i * p_min + c_i * p_min**2\n            if u_i0 == 0:\n                min_cost += s_i  # Include startup cost if off\n            avg_cost = min_cost / p_min if p_min > 0 else 0\n            candidate_units.append((idx, avg_cost, u_i0))\n    \n    # Sort candidate units by increasing average cost\n    candidate_units.sort(key=lambda x: x[1])\n    \n    # Step 4: Commit candidate units until sufficient capacity\n    total_min = sum(min_i[i] for i in committed_units)\n    total_max = sum(max_i[i] for i in committed_units)\n    \n    for cand in candidate_units:\n        if total_max >= current_load:\n            break  # Stop when capacity meets demand\n        idx, avg_cost, u_i0 = cand\n        \n        # Skip if unit already committed\n        if u_i[idx] == 1:\n            continue\n        \n        unit = units_info[idx]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        \n        # Determine min/max output for candidate\n        if u_i0 == 1:  # Already running\n            min_val = max(p_min, p_i0 - p_down)\n            max_val = min(p_max, p_i0 + p_up)\n        else:  # Starting up\n            min_val = p_min\n            max_val = min(p_max, p_start)\n        \n        # Update total capacity\n        total_min += min_val\n        total_max += max_val\n        min_i[idx] = min_val\n        max_i[idx] = max_val\n        u_i[idx] = 1\n        committed_units.append(idx)\n    \n    # Step 5: Remove expensive non-forced units if over-committed\n    if total_min > current_load:\n        non_forced_committed = []\n        for idx in committed_units:\n            if not forced_on[idx]:\n                unit = units_info[idx]\n                avg_cost = (unit['b_i'] * min_i[idx] + \n                            unit['c_i'] * min_i[idx]**2) / min_i[idx]\n                non_forced_committed.append((idx, avg_cost, min_i[idx], max_i[idx]))\n        \n        # Sort non-forced units by descending cost\n        non_forced_committed.sort(key=lambda x: x[1], reverse=True)\n        removed_units = []\n        \n        # Try removing expensive units while maintaining feasibility\n        for cand in non_forced_committed:\n            if total_min <= current_load:\n                break\n            idx, _, min_val, max_val = cand\n            # Check if remaining capacity can still cover load\n            if total_max - max_val >= current_load:\n                u_i[idx] = 0\n                p_i[idx] = 0\n                total_min -= min_val\n                total_max -= max_val\n                removed_units.append(idx)\n        \n        # Update committed units list\n        for ru in removed_units:\n            committed_units.remove(ru)\n    \n    # Step 6: Dispatch load\n    # Case a: Minimum outputs already meet load\n    if total_min >= current_load:\n        for i in committed_units:\n            p_i[i] = min_i[i]\n    \n    # Case b: Load requires all units at maximum\n    elif total_max <= current_load:\n        for i in committed_units:\n            p_i[i] = max_i[i]\n    \n    # Case c: Perform economic dispatch\n    else:\n        # Lambda iteration parameters\n        tolerance = 0.1  # MW\n        max_iter = 100\n        low_lambda = 0\n        high_lambda = 0\n        \n        # Find initial lambda range\n        for i in committed_units:\n            unit = units_info[i]\n            b_i_val = unit['b_i']\n            c_i_val = unit['c_i']\n            mc_min = b_i_val + 2 * c_i_val * min_i[i]\n            mc_max = b_i_val + 2 * c_i_val * max_i[i]\n            if mc_min < low_lambda or low_lambda == 0:\n                low_lambda = mc_min\n            if mc_max > high_lambda:\n                high_lambda = mc_max\n        \n        # Bisection method for lambda iteration\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            # Calculate power for each unit based on current lambda\n            for i in committed_units:\n                unit = units_info[i]\n                b_i_val = unit['b_i']\n                c_i_val = unit['c_i']\n                marginal = b_i_val + 2 * c_i_val * min_i[i]\n                if mid_lambda < marginal:\n                    power = min_i[i]\n                else:\n                    marginal_max = b_i_val + 2 * c_i_val * max_i[i]\n                    if mid_lambda > marginal_max:\n                        power = max_i[i]\n                    else:\n                        power = (mid_lambda - b_i_val) / (2 * c_i_val)\n                total_power += power\n            \n            # Adjust lambda boundaries based on current power\n            if abs(total_power - current_load) < tolerance:\n                for i in committed_units:\n                    unit = units_info[i]\n                    b_i_val = unit['b_i']\n                    c_i_val = unit['c_i']\n                    marginal = b_i_val + 2 * c_i_val * min_i[i]\n                    if mid_lambda < marginal:\n                        p_i[i] = min_i[i]\n                    else:\n                        marginal_max = b_i_val + 2 * c_i_val * max_i[i]\n                        if mid_lambda > marginal_max:\n                            p_i[i] = max_i[i]\n                        else:\n                            p_i[i] = (mid_lambda - b_i_val) / (2 * c_i_val)\n                break\n            elif total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        else:  # Fallback to greedy dispatch if not converged\n            for i in committed_units:\n                p_i[i] = min_i[i]\n            total_power = sum(min_i[i] for i in committed_units)\n            remaining = current_load - total_power\n            \n            # Increase outputs of units with lowest marginal cost\n            while remaining > tolerance:\n                min_marginal = float('inf')\n                selected_idx = -1\n                for i in committed_units:\n                    if p_i[i] < max_i[i]:\n                        unit = units_info[i]\n                        marginal = unit['b_i'] + 2 * unit['c_i'] * p_i[i]\n                        if marginal < min_marginal:\n                            min_marginal = marginal\n                            selected_idx = i\n                if selected_idx == -1:\n                    break\n                max_addition = min(max_i[selected_idx] - p_i[selected_idx], remaining)\n                p_i[selected_idx] += max_addition\n                remaining -= max_addition\n    \n    # Format output: 2D array with states and outputs\n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0057706611,
          "gap_price_rate": 0.0154707164,
          "fitness": 0.0106206887
     },
     {
          "name": "rolling_commit_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_commit_heuristic(units_info, load):\n    n = len(units_info)\n    \n    # Extract parameters\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    # Initialize outputs\n    u = [0] * n\n    p = [0] * n\n    min_output = [0] * n\n    max_output = [0] * n\n    current_load = load[0]\n    forecast_load = load[1]  # Not used in this version\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i in range(n):\n        if u_i_0[i] == 1:\n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i_0[i] < t_off_min[i]:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    for i in must_on + free_on:\n        u[i] = 1\n        min_output[i] = max(p_min[i], p_i_0[i] - p_down[i])\n        max_output[i] = min(p_max[i], p_i_0[i] + p_up[i])\n    \n    total_min_on = sum(min_output[i] for i in must_on + free_on)\n    total_max_on = sum(max_output[i] for i in must_on + free_on)\n    \n    # Case 1: Load < total min must-on capacity\n    if current_load < total_min_on:\n        for i in must_on + free_on:\n            p[i] = min_output[i]\n        return np.array([u, p])\n    \n    # Case 2: Load within must-on capacity\n    if current_load <= total_max_on:\n        committed = must_on + free_on\n        for i in committed:\n            p[i] = min_output[i]\n        remaining = current_load - total_min_on\n        while remaining > 0:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < max_output[i]:\n                    mc = b[i] + 2 * c[i] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(remaining, max_output[candidate] - p[candidate])\n            p[candidate] += increase\n            remaining -= increase\n        return np.array([u, p])\n    \n    # Case 3: Load exceeds must-on capacity\n    cost_priority = []\n    for i in free_off:\n        amortized_startup = s[i] / max(1, t_on_min[i])\n        min_cost = a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n        avg_cost = (amortized_startup + min_cost) / p_min[i]\n        cost_priority.append((avg_cost, i))\n    cost_priority.sort(key=lambda x: x[0])\n    \n    committed = must_on + free_on\n    new_min = total_min_on\n    new_max = total_max_on\n    to_commit = []\n    for _, i in cost_priority:\n        if new_max >= current_load:\n            break\n        to_commit.append(i)\n        u[i] = 1\n        min_output_i = p_min[i]\n        max_output_i = min(p_max[i], p_start[i])\n        min_output[i] = min_output_i\n        max_output[i] = max_output_i\n        new_min += min_output_i\n        new_max += max_output_i\n    \n    committed += to_commit\n    total_min_comm = new_min\n    total_max_comm = new_max\n    \n    # Set outputs for committed units\n    if current_load < total_min_comm:\n        for i in committed:\n            p[i] = min_output[i]\n    elif current_load <= total_max_comm:\n        for i in committed:\n            p[i] = min_output[i]\n        remaining = current_load - total_min_comm\n        while remaining > 0:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < max_output[i]:\n                    mc = b[i] + 2 * c[i] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(remaining, max_output[candidate] - p[candidate])\n            p[candidate] += increase\n            remaining -= increase\n    else:\n        for i in committed:\n            p[i] = max_output[i]\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     }
]