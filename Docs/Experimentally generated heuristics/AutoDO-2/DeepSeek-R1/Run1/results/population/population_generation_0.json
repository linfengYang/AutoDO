[
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into three categories based on constraints:\n   - Must-on: Units forced to remain on due to min-up time or shutdown capacity violation.\n   - Must-off: Units forced to remain off due to min-down time constraints.\n   - Flexible: Units that can be turned on or off.\n2. For must-on units, compute feasible output ranges considering ramp limits.\n3. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) output from must-on units.\n4. Based on current load and total must-on capacity:\n   a. If load is within must-on capacity: Dispatch load optimally among must-on units using lambda iteration.\n   b. If load < total must-on minimum: Set must-on units to minimum, others off.\n   c. If load > total must-on maximum: Turn on flexible units in priority order (cheapest average cost first) until demand is covered, then dispatch optimally among all online units.\n5. For must-off units: Set to off state and zero output.\n6. Return 2D array with commitment states (u_i) and outputs (p_i).\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_for_dispatch, load):\n    L_arr = np.array([u['L'] for u in units_for_dispatch])\n    U_arr = np.array([u['U'] for u in units_for_dispatch])\n    total_min = np.sum(L_arr)\n    total_max = np.sum(U_arr)\n    n = len(units_for_dispatch)\n    \n    if load <= total_min:\n        return L_arr.tolist()\n    elif load >= total_max:\n        return U_arr.tolist()\n    else:\n        low = float('inf')\n        high = -float('inf')\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                mc_low = u['b_i'] + 2*u['c_i'] * u['L']\n                mc_high = u['b_i'] + 2*u['c_i'] * u['U']\n                low = min(low, mc_low)\n                high = max(high, mc_high)\n            else:\n                low = min(low, u['b_i'])\n                high = max(high, u['b_i'])\n        \n        tol = 0.1\n        max_iter = 100\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_power = 0\n            for u in units_for_dispatch:\n                if u['c_i'] > 0:\n                    p = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n                else:\n                    p = u['U'] if mid >= u['b_i'] else u['L']\n                total_power += p\n            if abs(total_power - load) < tol:\n                break\n            if total_power < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_list = []\n        for u in units_for_dispatch:\n            if u['c_i'] > 0:\n                p_val = max(u['L'], min(u['U'], (mid - u['b_i']) / (2*u['c_i'])))\n            else:\n                p_val = u['U'] if mid >= u['b_i'] else u['L']\n            p_list.append(p_val)\n        \n        return p_list\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_periods = -unit['t_i_0']\n            if offline_periods < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    L_must_on = []\n    U_must_on = []\n    for i in must_on:\n        unit = units[i]\n        L = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        U = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        L_must_on.append(L)\n        U_must_on.append(U)\n    \n    total_min = sum(L_must_on) if must_on else 0\n    total_max = sum(U_must_on) if must_on else 0\n    schedules = np.zeros((2, len(units)))\n    \n    if total_min <= current_load <= total_max:\n        units_for_dispatch = []\n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    elif current_load < total_min:\n        for idx, i in enumerate(must_on):\n            schedules[0][i] = 1\n            schedules[1][i] = L_must_on[idx]\n        for i in range(len(units)):\n            if i not in must_on:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    else:\n        flex_candidates = []\n        for i in flexible:\n            unit = units[i]\n            avg_cost = (unit['s_i'] + unit['a_i'] + \n                        unit['b_i']*unit['p_min_i'] + \n                        unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            flex_candidates.append((avg_cost, i))\n        flex_candidates.sort(key=lambda x: x[0])\n        \n        selected_flex = []\n        cum_added = 0\n        deficit = current_load - total_max\n        for _, i in flex_candidates:\n            capacity = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            selected_flex.append(i)\n            cum_added += capacity\n            if cum_added >= deficit:\n                break\n        \n        on_units_indices = must_on + selected_flex\n        units_for_dispatch = []\n        L_dict = {}\n        U_dict = {}\n        \n        for i in must_on:\n            unit = units[i]\n            L_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            L_dict[i] = L_val\n            U_dict[i] = U_val\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_val,\n                'U': U_val\n            })\n        \n        for i in selected_flex:\n            unit = units[i]\n            L_dict[i] = unit['p_min_i']\n            U_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n            units_for_dispatch.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'L': L_dict[i],\n                'U': U_dict[i]\n            })\n        \n        total_min_dispatch = sum(L_dict[i] for i in on_units_indices)\n        total_max_dispatch = sum(U_dict[i] for i in on_units_indices)\n        \n        if current_load < total_min_dispatch:\n            dispatch_result = [L_dict[i] for i in on_units_indices]\n        elif current_load > total_max_dispatch:\n            dispatch_result = [U_dict[i] for i in on_units_indices]\n        else:\n            dispatch_result = economic_dispatch(units_for_dispatch, current_load)\n        \n        for idx, i in enumerate(on_units_indices):\n            schedules[0][i] = 1\n            schedules[1][i] = dispatch_result[idx]\n        \n        for i in range(len(units)):\n            if i not in on_units_indices:\n                schedules[0][i] = 0\n                schedules[1][i] = 0\n    \n    for i in must_off:\n        schedules[0][i] = 0\n        schedules[1][i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058061183,
          "gap_price_rate": 0.0091680778,
          "fitness": 0.0074870981
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-run (due to min-up/shutdown constraints), must-off (due to min-down time), and flexible (remaining units).\n2. Compute feasible power range for each unit based on ramp limits and startup/shutdown constraints.\n3. Calculate base load from must-run units set to minimum feasible power.\n4. Sort flexible units by average cost per MW (including startup cost if turned on) at minimum power.\n5. Activate flexible units in order of increasing cost until cumulative maximum capacity meets or exceeds current load.\n6. Perform economic dispatch:\n   - If minimum base load exceeds current load, set all committed units to minimum power.\n   - Otherwise, distribute remaining load among committed units using greedy adjustment based on marginal cost.\n7. Set non-committed units to off state with zero power output.\n8. Return schedule with commitment states and dispatch levels.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u_commit = [0] * n_units\n    p_dispatch = [0] * n_units\n    min_power = [0] * n_units\n    max_power = [0] * n_units\n    must_run = []\n    must_off = []\n    flex = []\n\n    # Precompute min/max power and classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pstart = unit['p_start_i']\n        pshut = unit['p_shut_i']\n        minup = unit['t_on_min_i']\n        mindown = unit['t_off_min_i']\n        \n        # Compute feasible power range\n        if u0 == 1:\n            min_power[i] = max(pmin, p0 - pdown)\n            max_power[i] = min(pmax, p0 + pup)\n            if t0 < minup or p0 > pshut:\n                must_run.append(i)\n                u_commit[i] = 1\n            else:\n                flex.append(i)\n        else:\n            min_power[i] = pmin\n            max_power[i] = min(pmax, pstart)\n            if abs(t0) < mindown:\n                must_off.append(i)\n                u_commit[i] = 0\n            else:\n                flex.append(i)\n    \n    # Calculate base capacity from must-run units\n    base_min = sum(min_power[i] for i in must_run)\n    base_max = sum(max_power[i] for i in must_run)\n    flex_costs = []\n    flex_idx = []\n\n    # Calculate average cost per MW for flexible units\n    for i in flex:\n        unit = units_info[i]\n        minp = min_power[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost_val = a + b * minp + c * minp**2 + s\n        cost_per_mw = cost_val / minp if minp > 0 else float('inf')\n        flex_costs.append(cost_per_mw)\n        flex_idx.append(i)\n    \n    # Sort flexible units by cost (lowest first)\n    sorted_flex = sorted(zip(flex_idx, flex_costs), key=lambda x: x[1])\n    flex_sorted = [x[0] for x in sorted_flex]\n    committed_flex = []\n    curr_min = base_min\n    curr_max = base_max\n\n    # Commit flexible units until capacity meets load\n    for i in flex_sorted:\n        if curr_max < load[0]:\n            committed_flex.append(i)\n            u_commit[i] = 1\n            curr_min += min_power[i]\n            curr_max += max_power[i]\n        else:\n            break\n    \n    # Set initial dispatch to minimum power for committed units\n    for i in must_run + committed_flex:\n        p_dispatch[i] = min_power[i]\n    active_units = must_run + committed_flex\n    total_power = curr_min\n\n    # Economic dispatch: distribute remaining load\n    if total_power < load[0]:\n        need = load[0] - total_power\n        while need > 0 and active_units:\n            best_unit = None\n            best_marginal = float('inf')\n            # Find unit with lowest marginal cost\n            for i in active_units:\n                p_i = p_dispatch[i]\n                if p_i < max_power[i]:\n                    marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n            if best_unit is None:\n                break\n            # Calculate maximum possible increase\n            room = max_power[best_unit] - p_dispatch[best_unit]\n            delta = min(need, room)\n            p_dispatch[best_unit] += delta\n            need -= delta\n            # Remove unit if at maximum\n            if p_dispatch[best_unit] >= max_power[best_unit]:\n                active_units.remove(best_unit)\n    # Set non-committed units to off state\n    for i in set(range(n_units)) - set(must_run + committed_flex):\n        u_commit[i] = 0\n        p_dispatch[i] = 0\n    \n    return np.array([u_commit, p_dispatch])",
          "from": null,
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "commit_units_with_forced_constraints",
          "algorithm": "1. Identify units that are forced to stay on (due to minimum up-time or shutdown ramp constraints) or forced to stay off (due to minimum down-time constraints).\n2. Calculate the minimum and maximum output limits for forced-on units considering their ramp constraints.\n3. Sort candidate units (non-forced and not forced off) by average cost per MWh at minimum output.\n4. Commit candidate units in order of priority until the total maximum output can meet the current load.\n5. For committed units, compute actual output bounds considering ramp constraints and whether the unit is starting.\n6. If the load is below the total minimum output of committed units, set outputs to their minimum values.\n7. If the load exceeds the total maximum output of committed units, set outputs to their maximum values.\n8. For loads within the feasible range, perform economic dispatch using a greedy algorithm that increases the unit with the smallest marginal cost until the load is met.\n9. Output the commitment status and power output for each unit.\n\n",
          "code": "import numpy as np\n\ndef commit_units_with_forced_constraints(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    low_bound = [0.0] * n_units\n    high_bound = [0.0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            p_i_prev = units_info[i]['p_i_0']\n            low_bound[i] = max(units_info[i]['p_min_i'], p_i_prev - units_info[i]['p_down_i'])\n            high_bound[i] = min(units_info[i]['p_max_i'], p_i_prev + units_info[i]['p_up_i'])\n        elif forced_off[i]:\n            low_bound[i] = 0.0\n            high_bound[i] = 0.0\n    \n    forced_on_set = set(i for i in range(n_units) if forced_on[i])\n    T_min_total = sum(low_bound[i] for i in forced_on_set)\n    T_max_total = sum(high_bound[i] for i in forced_on_set)\n    \n    candidate_units = []\n    for i in range(n_units):\n        if not forced_on[i] and not forced_off[i]:\n            candidate_units.append(i)\n    \n    def compute_avg_cost(i):\n        unit = units_info[i]\n        if unit['p_min_i'] == 0:\n            return float('inf')\n        cost_start = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        return cost_start / unit['p_min_i']\n    \n    candidate_units.sort(key=compute_avg_cost)\n    S = set(forced_on_set)\n    \n    for i in candidate_units:\n        if T_max_total >= load[0]:\n            break\n        low_candidate = units_info[i]['p_min_i']\n        high_candidate = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        S.add(i)\n        T_min_total += low_candidate\n        T_max_total += high_candidate\n    \n    low_bound_S = {}\n    high_bound_S = {}\n    for i in S:\n        if units_info[i]['u_i_0'] == 1:\n            p_i_prev = units_info[i]['p_i_0']\n            low_bound_S[i] = max(units_info[i]['p_min_i'], p_i_prev - units_info[i]['p_down_i'])\n            high_bound_S[i] = min(units_info[i]['p_max_i'], p_i_prev + units_info[i]['p_up_i'])\n        else:\n            low_bound_S[i] = units_info[i]['p_min_i']\n            high_bound_S[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    T_min_S = sum(low_bound_S.get(i, 0) for i in S)\n    T_max_S = sum(high_bound_S.get(i, 0) for i in S)\n    L = load[0]\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    if L <= T_min_S:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = low_bound_S[i]\n    elif L >= T_max_S:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = high_bound_S[i]\n    else:\n        for i in S:\n            u_out[i] = 1\n            p_out[i] = low_bound_S[i]\n        total_p = T_min_S\n        active_set = set(i for i in S if p_out[i] < high_bound_S[i] - 1e-6)\n        \n        while total_p < L and active_set:\n            min_mc = float('inf')\n            candidate = None\n            for i in active_set:\n                if units_info[i]['c_i'] == 0:\n                    mc = units_info[i]['b_i']\n                else:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n            \n            if candidate is None:\n                break\n                \n            max_inc = high_bound_S[candidate] - p_out[candidate]\n            inc = min(max_inc, L - total_p)\n            p_out[candidate] += inc\n            total_p += inc\n            if p_out[candidate] >= high_bound_S[candidate] - 1e-6:\n                active_set.remove(candidate)\n    \n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u_out\n    schedules[1, :] = p_out\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "adaptive_priority_rolling_commitment",
          "algorithm": "1. Determine must-commit and must-off units based on min up/down time and shutdown ramp constraints  \n2. Compute minimum/maximum power from committed units considering ramp limits  \n3. Classify commitment case (under, over, adequate) with candidate units  \n4. For under-committed: Start cheapest candidate units until load can be met  \n5. For over-committed: Turn off expensive candidate units to reduce minimum generation  \n6. For adequate: Optimize by turning off expensive non-essential units  \n7. Perform constrained economic dispatch using greedy incremental cost allocation  \n8. Return commitment and dispatch schedule  \n\n",
          "code": "import numpy as np  \n\ndef adaptive_priority_rolling_commitment(units_info, load):  \n    current_load = load[0]  \n    next_load_forecast = load[1]  \n    n_units = len(units_info)  \n    schedules = np.zeros((2, n_units))  \n    committed = [False] * n_units  \n    min_output = [0.0] * n_units  \n    max_output = [0.0] * n_units  \n    forced_on = [False] * n_units  \n    forced_off = [False] * n_units  \n    candidate_off = []  \n    candidate_on = []  \n    \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_up = unit['p_up_i']  \n        p_down = unit['p_down_i']  \n        p_start = unit['p_start_i']  \n        p_shut = unit['p_shut_i']  \n        t_on_min = unit['t_on_min_i']  \n        t_off_min = unit['t_off_min_i']  \n        \n        if u_i0 == 1:  \n            min_output[i] = max(p_min, p_i0 - p_down)  \n            max_output[i] = min(p_max, p_i0 + p_up)  \n            if t_i0 < t_on_min:  \n                committed[i] = True  \n                forced_on[i] = True  \n            elif p_i0 > p_shut:  \n                committed[i] = True  \n                forced_on[i] = True  \n            else:  \n                candidate_off.append(i)  \n        else:  \n            min_output[i] = p_min  \n            max_output[i] = min(p_max, p_start)  \n            if abs(t_i0) < t_off_min:  \n                committed[i] = False  \n                forced_off[i] = True  \n            else:  \n                candidate_on.append(i)  \n    \n    min_forced = sum(min_output[i] for i in range(n_units) if forced_on[i])  \n    max_forced = sum(max_output[i] for i in range(n_units) if forced_on[i])  \n    min_candidate_off = sum(min_output[i] for i in candidate_off)  \n    max_candidate_off = sum(max_output[i] for i in candidate_off)  \n    total_min = min_forced + min_candidate_off  \n    total_max = max_forced + max_candidate_off  \n    \n    if current_load > total_max:  \n        case = 'under'  \n    elif current_load < min_forced:  \n        case = 'over'  \n    else:  \n        case = 'adequate'  \n    \n    turned_off = []  \n    started = []  \n    \n    if case == 'under':  \n        candidate_on_sorted = sorted(  \n            candidate_on,  \n            key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_output[i]  \n        )  \n        for i in candidate_on_sorted:  \n            if total_max >= current_load:  \n                break  \n            unit = units_info[i]  \n            total_min += min_output[i]  \n            total_max += max_output[i]  \n            committed[i] = True  \n            started.append(i)  \n    \n    elif case == 'over':  \n        cost_candidate_off = [  \n            (i, units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] +  \n             units_info[i]['c_i'] * min_output[i]**2)  \n            for i in candidate_off  \n        ]  \n        candidate_off_sorted = sorted(cost_candidate_off, key=lambda x: x[1], reverse=True)  \n        turned_off = []  \n        for i, cost_val in candidate_off_sorted:  \n            new_min = total_min - min_output[i]  \n            new_max = total_max - max_output[i]  \n            if new_min <= current_load <= new_max:  \n                turned_off.append(i)  \n                total_min = new_min  \n                total_max = new_max  \n            if total_min <= current_load:  \n                break  \n        for i in turned_off:  \n            committed[i] = False  \n            candidate_off.remove(i)  \n    \n    else:  \n        cost_candidate_off = [  \n            (i, units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] +  \n             units_info[i]['c_i'] * min_output[i]**2)  \n            for i in candidate_off  \n        ]  \n        candidate_off_sorted = sorted(cost_candidate_off, key=lambda x: x[1], reverse=True)  \n        for i, cost_val in candidate_off_sorted:  \n            new_min = total_min - min_output[i]  \n            new_max = total_max - max_output[i]  \n            if new_min <= current_load <= new_max:  \n                committed[i] = False  \n                total_min = new_min  \n                total_max = new_max  \n    \n    # Initialize dispatch and adjust for ramp constraints  \n    p_alloc = [0.0] * n_units  \n    allocated = 0.0  \n    residual = current_load  \n    increments = []  \n    \n    for i in range(n_units):  \n        if not committed[i]:  \n            continue  \n        unit = units_info[i]  \n        if forced_off[i] or not committed[i]:  \n            continue  \n        u_i0 = unit['u_i_0']  \n        p_i0 = unit['p_i_0']  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_up = unit['p_up_i']  \n        p_down = unit['p_down_i']  \n        p_start = unit['p_start_i']  \n        b_i = unit['b_i']  \n        c_i = unit['c_i']  \n        \n        if u_i0 == 1:  \n            p_low = max(p_min, p_i0 - p_down)  \n            p_high = min(p_max, p_i0 + p_up)  \n        else:  \n            p_low = p_min  \n            p_high = min(p_max, p_start)  \n        \n        p_alloc[i] = p_low  \n        residual -= p_low  \n        avail = p_high - p_low  \n        marginal_cost = b_i + 2 * c_i * p_low  \n        increments.append((i, marginal_cost, avail))  \n    \n    if residual > 0:  \n        increments_sorted = sorted(increments, key=lambda x: x[1])  \n        for (i, mc, avail) in increments_sorted:  \n            if residual <= avail:  \n                p_alloc[i] += residual  \n                residual = 0  \n                break  \n            else:  \n                p_alloc[i] += avail  \n                residual -= avail  \n    \n    # Handle startup costs by setting commitment state  \n    for i in range(n_units):  \n        schedules[0, i] = int(committed[i])  \n        schedules[1, i] = p_alloc[i]  \n    \n    return schedules  ",
          "from": null,
          "gap_power_rate": 0.0101077905,
          "gap_price_rate": 0.010495207,
          "fitness": 0.0103014987
     },
     {
          "name": "commit_units_by_priority",
          "algorithm": "1. Classify units into must-run (due to min up-time or shutdown constraints), must-off (due to min down-time), flexible-on (currently on but can be decommitted), and flexible-off (currently off but can be committed).\n2. Compute total minimum and maximum generation from must-run and initially kept flexible-on units.\n3. If current load exceeds maximum generation, turn on flexible-off units by ascending average cost per MW at min output.\n4. If current load is below minimum generation, turn off flexible-on units by descending cost per MW at min output.\n5. Perform economic dispatch among committed units using a greedy algorithm based on marginal cost.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority(units_info, load):\n    n = len(units_info)\n    u_i_current = [0] * n\n    p_i_current = [0.0] * n\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    must_on = []\n    must_off = []\n    flex_on = []\n    flex_off = []\n\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n                u_i_current[i] = 1\n            else:\n                flex_on.append(i)\n                u_i_current[i] = 1\n        else:\n            if -t_i0 < t_off_min:\n                must_off.append(i)\n                u_i_current[i] = 0\n            else:\n                flex_off.append(i)\n                u_i_current[i] = 0\n\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in range(n):\n        if u_i_current[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                min_output[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                min_output[i] = units_info[i]['p_min_i']\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    current_load = load[0]\n    \n    # Turn on flex_off units if needed\n    if total_max < current_load:\n        candidates = []\n        for i in flex_off:\n            min_p = units_info[i]['p_min_i']\n            max_p = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            s = units_info[i]['s_i']\n            cost_at_min = a + b * min_p + c * min_p ** 2 + s\n            avg_cost = cost_at_min / min_p\n            candidates.append((i, min_p, max_p, avg_cost))\n        \n        candidates.sort(key=lambda x: x[3])\n        \n        for i, min_p, max_p, _ in candidates:\n            if total_max < current_load:\n                u_i_current[i] = 1\n                min_output[i] = min_p\n                max_output[i] = max_p\n                total_min += min_p\n                total_max += max_p\n            else:\n                break\n    \n    # Turn off flex_on units if needed\n    if current_load < total_min:\n        candidates = []\n        for i in flex_on:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            min_p = min_output[i]\n            cost_at_min = a + b * min_p + c * min_p ** 2\n            saving_per_mw = cost_at_min / min_p\n            candidates.append((i, min_p, saving_per_mw))\n        \n        candidates.sort(key=lambda x: x[2], reverse=True)\n        \n        for i, min_p, _ in candidates:\n            if total_min > current_load:\n                u_i_current[i] = 0\n                total_min -= min_p\n                total_max -= max_output[i]\n                min_output[i] = 0\n                max_output[i] = 0\n            else:\n                break\n    \n    # Initialize outputs with minimum power\n    for i in range(n):\n        if u_i_current[i] == 1:\n            p_i_current[i] = min_output[i]\n        else:\n            p_i_current[i] = 0.0\n    \n    total_power = sum(p_i_current)\n    remaining = current_load - total_power\n    \n    # Adjust output allocation using marginal cost\n    units_to_adjust = [i for i in range(n) \n                       if u_i_current[i] == 1 and p_i_current[i] < max_output[i]]\n    \n    while remaining > 1e-5 and units_to_adjust:\n        min_mc = float('inf')\n        best_i = -1\n        \n        for i in units_to_adjust:\n            unit = units_info[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * p_i_current[i]\n            if mc < min_mc:\n                min_mc = mc\n                best_i = i\n        \n        if best_i == -1:\n            break\n        \n        unit = units_info[best_i]\n        inc = min(remaining, max_output[best_i] - p_i_current[best_i])\n        p_i_current[best_i] += inc\n        remaining -= inc\n        \n        if p_i_current[best_i] >= max_output[best_i]:\n            units_to_adjust.remove(best_i)\n    \n    # Prepare output array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_i_current[i]\n        schedules[1, i] = p_i_current[i]\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "commit_units_by_priority_forecast",
          "algorithm": "1. Classify units into forced on, forced off, and free units based on min up/down times and shutdown ramp limits.\n2. Initially set free units that were on to on, and free units that were off to off.\n3. Compute total available power from committed units (forced on + initially set free units).\n4. If total power is below current load, commit additional free units (off previously) in ascending order of marginal cost at min power until power >= load.\n5. Perform economic dispatch to allocate current load to committed units with min/max constraints derived from ramp limits.\n6. Check if forecasted next load can be met by expanding committed units based on min down time and startup limits, adding highest priority unit if necessary.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(units_info, n_units, u_current, load_current):\n    p_current = [0.0] * n_units\n    p_low = [0.0] * n_units\n    p_high = [0.0] * n_units\n    \n    for i in range(n_units):\n        if u_current[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                p_low[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                p_high[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                p_low[i] = units_info[i]['p_min_i']\n                p_high[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(p_low[i] for i in range(n_units) if u_current[i] == 1)\n    if total_min > load_current:\n        for i in range(n_units):\n            if u_current[i] == 1:\n                p_current[i] = p_low[i]\n        return p_current\n    \n    remaining = load_current - total_min\n    for i in range(n_units):\n        if u_current[i] == 1:\n            p_current[i] = p_low[i]\n    \n    while remaining > 1e-5:\n        min_mc = float('inf')\n        candidate = -1\n        for i in range(n_units):\n            if u_current[i] == 1 and p_current[i] < p_high[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_current[i]\n                if marginal_cost < min_mc:\n                    min_mc = marginal_cost\n                    candidate = i\n        if candidate == -1:\n            break\n        amount = min(remaining, p_high[candidate] - p_current[candidate])\n        p_current[candidate] += amount\n        remaining -= amount\n    \n    return p_current\n\ndef commit_units_by_priority_forecast(units_info, load):\n    n_units = len(units_info)\n    u_current = [0] * n_units\n    load_current, forecast_next = load\n    \n    forced_on = []\n    forced_off = []\n    free_units = []\n    free_units_on = []\n    free_units_off = []\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_units_on.append(i)\n        else:\n            free_units_off.append(i)\n    \n    for i in forced_on:\n        u_current[i] = 1\n    for i in forced_off:\n        u_current[i] = 0\n    for i in free_units_on:\n        u_current[i] = 1\n    for i in free_units_off:\n        u_current[i] = 0\n    \n    total_max_power = 0.0\n    for i in forced_on + free_units_on:\n        if units_info[i]['u_i_0'] == 1:\n            total_max_power += min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n    \n    sorted_free_off = sorted(free_units_off, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'])\n    additional_commit = []\n    for i in sorted_free_off:\n        if total_max_power >= load_current:\n            break\n        u_current[i] = 1\n        additional_commit.append(i)\n        total_max_power += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    p_current = economic_dispatch(units_info, n_units, u_current, load_current)\n    \n    total_max_next = 0.0\n    for i in range(n_units):\n        if u_current[i] == 1:\n            total_max_next += min(units_info[i]['p_max_i'], p_current[i] + units_info[i]['p_up_i'])\n        else:\n            if units_info[i]['u_i_0'] == 1 and u_current[i] == 0:\n                downtime_next = 1\n            else:\n                downtime_next = abs(units_info[i]['t_i_0']) + 1\n            if downtime_next >= units_info[i]['t_off_min_i']:\n                total_max_next += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    if total_max_next < forecast_next:\n        available_units = [i for i in free_units_off if u_current[i] == 0]\n        if available_units:\n            sorted_available = sorted(available_units, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'])\n            i_extra = sorted_available[0]\n            u_current[i_extra] = 1\n            p_current = economic_dispatch(units_info, n_units, u_current, load_current)\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = u_current[i]\n        schedules[1, i] = p_current[i]\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0375214362,
          "fitness": 0.0187965642
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into must-on (min up-time not met or shutdown capacity exceeded), must-off (min down-time not met), and free (neither).\n2. Set must-off units to off (u=0, p=0).\n3. For must-on units:\n   - For previously online units, set output bounds using ramp limits.\n   - For previously offline units (unlikely), set bounds using minimum output and startup capacity.\n4. Calculate total min/max output from must-on units.\n5. If load < total min: set must-on units to min output.\n6. If load within must-on capacity range: dispatch load among must-on units.\n7. If load > total max:\n   - Sort free units by average cost at min output (including startup cost).\n   - Commit free units until total available capacity \u2265 load or all considered.\n   - Set bounds for committed free units (considering startup capacity).\n   - Dispatch min(load, achievable) among all committed units.\n8. Dispatch uses Newton-like lambda iteration respecting bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    \n    must_on_indices = []\n    must_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on_indices.append(i)\n            else:\n                free_indices.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off_indices.append(i)\n            else:\n                free_indices.append(i)\n    \n    for i in must_off_indices:\n        u_current[i] = 0\n        p_current[i] = 0\n        min_bound[i] = 0\n        max_bound[i] = 0\n    \n    for i in must_on_indices:\n        unit = units_info[i]\n        u_current[i] = 1\n        if unit['u_i_0'] == 1:\n            min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound[i] = unit['p_min_i']\n            max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min_must = np.sum(min_bound[must_on_indices])\n    total_max_must = np.sum(max_bound[must_on_indices])\n    \n    def dispatch_units(committed_indices, load_target):\n        n_committed = len(committed_indices)\n        if n_committed == 0:\n            return np.zeros_like(p_current)\n        \n        b_arr = np.array([units_info[i]['b_i'] for i in committed_indices])\n        c_arr = np.array([units_info[i]['c_i'] for i in committed_indices])\n        min_arr = np.array([min_bound[i] for i in committed_indices])\n        max_arr = np.array([max_bound[i] for i in committed_indices])\n        total_min = np.sum(min_arr)\n        total_max = np.sum(max_arr)\n        \n        p_dispatch = np.zeros(n_units)\n        if load_target <= total_min:\n            for i, idx in enumerate(committed_indices):\n                p_dispatch[idx] = min_arr[i]\n            return p_dispatch\n        if load_target >= total_max:\n            for i, idx in enumerate(committed_indices):\n                p_dispatch[idx] = max_arr[i]\n            return p_dispatch\n        \n        denom = np.sum(1/(2*c_arr))\n        if denom < 1e-10:\n            lambda_val = np.mean(b_arr)\n        else:\n            lambda_val = (load_target + np.sum(b_arr/(2*c_arr))) / denom\n        \n        max_iter = 100\n        tol = 1e-2\n        p_arr = (lambda_val - b_arr) / (2 * c_arr)\n        total_p = 0.0\n        \n        for iter in range(max_iter):\n            total_p = 0.0\n            d_totalp_dlambda = 0.0\n            for j in range(n_committed):\n                if p_arr[j] < min_arr[j]:\n                    p_val = min_arr[j]\n                elif p_arr[j] > max_arr[j]:\n                    p_val = max_arr[j]\n                else:\n                    p_val = p_arr[j]\n                    d_totalp_dlambda += 1/(2*c_arr[j])\n                total_p += p_val\n            \n            if abs(total_p - load_target) < tol:\n                break\n            \n            if d_totalp_dlambda < 1e-10:\n                lambda_val += 0.5 * (load_target - total_p)\n            else:\n                lambda_val += (load_target - total_p) / d_totalp_dlambda\n            \n            p_arr = (lambda_val - b_arr) / (2 * c_arr)\n        \n        for j, idx in enumerate(committed_indices):\n            if p_arr[j] < min_arr[j]:\n                p_dispatch[idx] = min_arr[j]\n            elif p_arr[j] > max_arr[j]:\n                p_dispatch[idx] = max_arr[j]\n            else:\n                p_dispatch[idx] = p_arr[j]\n        \n        return p_dispatch\n    \n    if current_load < total_min_must:\n        for i in must_on_indices:\n            p_current[i] = min_bound[i]\n        schedules = np.array([u_current, p_current])\n        return schedules\n    elif total_min_must <= current_load <= total_max_must:\n        p_current = dispatch_units(must_on_indices, current_load)\n        schedules = np.array([u_current, p_current])\n        return schedules\n    else:\n        free_candidates = []\n        for i in free_indices:\n            unit = units_info[i]\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            s_i = unit['s_i']\n            cost = a_i + b_i * p_min_i + c_i * p_min_i**2 + s_i\n            cost_per_mw = cost / p_min_i\n            p_max_start = min(unit['p_max_i'], unit['p_start_i'])\n            free_candidates.append((i, cost_per_mw, p_min_i, p_max_start))\n        \n        free_candidates.sort(key=lambda x: x[1])\n        committed_free = []\n        current_max = total_max_must\n        \n        for i, *_, p_max_start in free_candidates:\n            if current_max >= current_load:\n                break\n            current_max += p_max_start\n            committed_free.append(i)\n            u_current[i] = 1\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        \n        all_committed = must_on_indices + committed_free\n        target_load = min(current_load, current_max)\n        p_current = dispatch_units(all_committed, target_load)\n        schedules = np.array([u_current, p_current])\n        return schedules",
          "from": null,
          "gap_power_rate": 0.0255888174,
          "gap_price_rate": 0.0172752652,
          "fitness": 0.0214320413
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Identify must-run units based on min up-time and shutdown ramp constraints, and must-off units based on min down-time.\n2. Initialize commitment: must-run units are on, must-off units are off; flexible units retain previous state.\n3. If current load exceeds max generation capacity:\n   - Rank available off-units by composite cost (marginal cost + startup cost amortized over min up-time).\n   - Turn on units until max capacity meets or exceeds load, considering startup ramp limits.\n4. If min generation capacity exceeds current load:\n   - Rank flexible on-units by marginal cost (descending) that can be turned off (satisfying min up-time and shutdown ramp).\n   - Turn off highest-cost units until min capacity <= load or no candidates remain.\n5. Perform economic dispatch for committed units:\n   a. Set each unit to its feasible minimum (respecting ramp-down limits and min output).\n   b. If total generation is below load, increase output of units with lowest marginal cost (within ramp-up/startup limits).\n   c. If total generation is above load, decrease output of units with highest marginal cost (within ramp-down/min output limits).\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p_vals = [0] * n_units\n    current_load = load[0]\n    \n    # Step 1: Identify must-run and must-off units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Step 2: Initial commitment\n    min_power = 0\n    max_power = 0\n    for i in range(n_units):\n        if must_on[i]:\n            u[i] = 1\n            min_power += units_info[i]['p_min_i']\n            max_power += units_info[i]['p_max_i']\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n            if u[i] == 1:\n                min_power += units_info[i]['p_min_i']\n                max_power += units_info[i]['p_max_i']\n    \n    # Step 3: Handle under-capacity (turn on more units)\n    if current_load > max_power:\n        candidate_on = []\n        for i, unit in enumerate(units_info):\n            if not must_on[i] and not must_off[i] and unit['u_i_0'] == 0:\n                if unit['p_min_i'] <= unit['p_start_i']:\n                    priority = (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']) + (unit['s_i'] / unit['t_on_min_i'])\n                    candidate_on.append((i, priority))\n        candidate_on.sort(key=lambda x: x[1])\n        for i, _ in candidate_on:\n            if max_power >= current_load:\n                break\n            u[i] = 1\n            min_power += units_info[i]['p_min_i']\n            max_power += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    # Step 4: Handle over-commitment (turn off expensive units)\n    if current_load < min_power:\n        candidate_off = []\n        for i, unit in enumerate(units_info):\n            if not must_on[i] and u[i] == 1 and abs(unit['t_i_0']) >= unit['t_on_min_i'] and unit['p_i_0'] <= unit['p_shut_i']:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n                candidate_off.append((i, marginal_cost))\n        candidate_off.sort(key=lambda x: x[1], reverse=True)\n        for i, _ in candidate_off:\n            if min_power <= current_load:\n                break\n            u[i] = 0\n            min_power -= units_info[i]['p_min_i']\n            max_power -= units_info[i]['p_max_i']\n    \n    # Step 5: Economic dispatch\n    low_bounds = [0] * n_units\n    high_bounds = [0] * n_units\n    committed_indices = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            # Set low bound considering ramp-down and min output\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            # Set high bound considering ramp-up and startup ramp (if applicable)\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                high_bound = min(high_bound, unit['p_start_i'])\n            low_bounds[i] = low_bound\n            high_bounds[i] = high_bound\n            p_vals[i] = low_bound\n            committed_indices.append(i)\n    \n    total_p = sum(p_vals[i] for i in committed_indices)\n    deficit = current_load - total_p\n    \n    # Case 1: Increase generation\n    if deficit > 0:\n        candidate_up = []\n        for i in committed_indices:\n            if p_vals[i] < high_bounds[i]:\n                marginal_cost = 2 * units_info[i]['c_i'] * p_vals[i] + units_info[i]['b_i']\n                candidate_up.append((i, marginal_cost))\n        candidate_up.sort(key=lambda x: x[1])\n        for idx, _ in candidate_up:\n            if deficit <= 0:\n                break\n            headroom = high_bounds[idx] - p_vals[idx]\n            if headroom > 0:\n                add = min(headroom, deficit)\n                p_vals[idx] += add\n                deficit -= add\n    \n    # Case 2: Decrease generation\n    surplus = -deficit\n    if surplus > 0:\n        candidate_down = []\n        for i in committed_indices:\n            if p_vals[i] > low_bounds[i]:\n                marginal_cost = 2 * units_info[i]['c_i'] * p_vals[i] + units_info[i]['b_i']\n                candidate_down.append((i, marginal_cost))\n        candidate_down.sort(key=lambda x: x[1], reverse=True)\n        for idx, _ in candidate_down:\n            if surplus <= 0:\n                break\n            footroom = p_vals[idx] - low_bounds[idx]\n            if footroom > 0:\n                reduce_by = min(footroom, surplus)\n                p_vals[idx] -= reduce_by\n                surplus -= reduce_by\n    \n    # Prepare output\n    schedules = np.array([u, p_vals])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.007349429,
          "gap_price_rate": 0.0360209124,
          "fitness": 0.0216851707
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-run-on, must-stay-off, and free based on min up/down times, previous state, and shutdown constraints.\n2. If must-run-on units' minimum outputs exceed load, set them to minimum and keep others off (overproduction).\n3. Else, if must-run-on units can meet load at maximum output, dispatch them economically to meet load exactly.\n4. Else, turn on free units in increasing order of average cost at minimum output until capacity meets load.\n5. Dispatch committed units (must-run-on and selected free units) economically to meet load:\n   - Start at minimum outputs\n   - Incrementally increase output of unit with lowest marginal cost until load met or capacity exhausted\n6. Set output: active units at dispatched outputs, others at 0.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free = []\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n\n    # Classify units and compute min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                free.append(i)\n                if unit['u_i_0'] == 1:\n                    min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    min_p[i] = unit['p_min_i']\n                    max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                free.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Must-on totals\n    min_total_must_on = sum(min_p[i] for i in must_on)\n    max_total_must_on = sum(max_p[i] for i in must_on)\n    \n    # Initialize schedules\n    u_schedule = [0] * n_units\n    p_schedule = [0] * n_units\n    \n    # Case 1: Overproduction with must-on units\n    if min_total_must_on >= current_load:\n        for i in must_on:\n            u_schedule[i] = 1\n            p_schedule[i] = min_p[i]\n        return np.array([u_schedule, p_schedule])\n    \n    # Case 2: Must-on units can cover load when maxed\n    if max_total_must_on >= current_load:\n        online = must_on.copy()\n        init_p = [min_p[i] for i in online]\n        remaining = current_load - sum(init_p)\n        p_online = init_p.copy()\n        maxes = [max_p[i] for i in online]\n        indices = list(range(len(online)))\n        \n        while remaining > 1e-4:\n            min_mc = float('inf')\n            best_idx = -1\n            for pos, idx in enumerate(online):\n                if p_online[pos] >= maxes[pos]:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_online[pos]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_pos = pos\n            if best_idx < 0:\n                break\n            unit_idx = online[best_pos]\n            inc = min(remaining, maxes[best_pos] - p_online[best_pos])\n            p_online[best_pos] += inc\n            remaining -= inc\n        \n        for pos, idx in enumerate(online):\n            u_schedule[idx] = 1\n            p_schedule[idx] = p_online[pos]\n        return np.array([u_schedule, p_schedule])\n    \n    # Case 3: Need free units\n    online = must_on.copy()\n    min_online = min_total_must_on\n    max_online = max_total_must_on\n    free_candidates = []\n    for i in free:\n        if units_info[i]['u_i_0'] == 1:\n            startup_cost = 0\n        else:\n            startup_cost = units_info[i]['s_i']\n        cost_at_min = startup_cost + units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * (min_p[i] ** 2)\n        avg_cost = cost_at_min / min_p[i] if min_p[i] > 0 else float('inf')\n        free_candidates.append((i, avg_cost, min_p[i], max_p[i]))\n    \n    free_candidates.sort(key=lambda x: x[1])\n    chosen_free = []\n    for idx, avg, minp, maxp in free_candidates:\n        if max_online >= current_load:\n            break\n        chosen_free.append(idx)\n        online.append(idx)\n        min_online += minp\n        max_online += maxp\n    \n    # Dispatch all online units\n    init_p = [min_p[i] if i in must_on else min_p[i] for i in online]\n    remaining = current_load - min_online\n    p_online = init_p.copy()\n    bounds_online = [max_p[i] for i in online]\n    unit_indices = online.copy()\n    \n    while remaining > 1e-4 and any(p_online[i] < bounds_online[i] for i in range(len(online))):\n        min_mc = float('inf')\n        best_idx = -1\n        for pos in range(len(online)):\n            if p_online[pos] >= bounds_online[pos]:\n                continue\n            unit_idx = online[pos]\n            mc = units_info[unit_idx]['b_i'] + 2 * units_info[unit_idx]['c_i'] * p_online[pos]\n            if mc < min_mc:\n                min_mc = mc\n                best_idx = pos\n        if best_idx < 0:\n            break\n        inc = min(remaining, bounds_online[best_idx] - p_online[best_idx])\n        p_online[best_idx] += inc\n        remaining -= inc\n    \n    for pos, idx in enumerate(online):\n        u_schedule[idx] = 1\n        p_schedule[idx] = p_online[pos]\n    \n    return np.array([u_schedule, p_schedule])",
          "from": null,
          "gap_power_rate": 0.2110830287,
          "gap_price_rate": 0.1066750575,
          "fitness": 0.1588790431
     }
]