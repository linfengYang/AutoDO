[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "rolling_commitment",
          "algorithm": "**  \n1. **Identify must-on/must-off units:** Must-on units are currently online and violate minimum up-time or shutdown ramp constraints; must-off units are offline and violate minimum down-time.  \n2. **Initialize commitment:** Set must-on units to committed (1), must-off units to decommitted (0), and flexible units to their previous state.  \n3. **Compute feasible power ranges:** For committed units, account for min/max power, ramp rates, and startup/shutdown constraints.  \n4. **Adjust commitment:**  \n   - **Over-committed (total min > load):** Decommit non-must-on units with the highest operating cost at minimum output until feasible.  \n   - **Under-committed (total max < load):** Commit available offline units with the best cost-effectiveness metric (startup cost + min-power cost)/min-power.  \n   - **Adequate (load within [total min, total max]):** Decommit expensive non-must-on units if adequacy persists.  \n5. **Lambda economic dispatch:** For committed units, minimize production costs using lambda iteration with bisection for optimal load distribution.  \n6. **Greedy residual adjustment:** Address small load deviations by adjusting outputs of units with the lowest/highest marginal costs.  \n7. **Output schedules:** Return commitment states and power outputs.  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u = [0] * n\n    p_output = [0.0] * n\n    min_power = [0.0] * n\n    max_power = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        elif t_i0 < 0 and -t_i0 < unit['t_off_min_i']:\n            must_off[i] = True\n    \n    # Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Set feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_power[i] = unit['p_min_i']\n                max_power[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            else:\n                min_power[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_power[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_power[i], max_power[i] = 0.0, 0.0\n    \n    total_min = sum(min_power)\n    total_max = sum(max_power)\n    \n    # Adjust commitment\n    candidate_off = []\n    for i in range(n):\n        if u[i] == 1 and not must_on[i]:\n            if units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                candidate_off.append(i)\n    \n    candidate_on = [i for i in range(n) if u[i] == 0 and not must_off[i]]\n    \n    # Over-committed\n    while total_min > current_load and candidate_off:\n        cost_list = []\n        for i in candidate_off:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_power[i] + unit['c_i'] * min_power[i]**2\n            cost_list.append((i, cost))\n        cost_list.sort(key=lambda x: x[1], reverse=True)\n        idx = cost_list[0][0]\n        u[idx] = 0\n        candidate_off.remove(idx)\n        total_min -= min_power[idx]\n        total_max -= max_power[idx]\n        min_power[idx], max_power[idx] = 0.0, 0.0\n    \n    # Under-committed\n    while total_max < current_load and candidate_on:\n        metric_list = []\n        for i in candidate_on:\n            unit = units_info[i]\n            op_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            metric = (unit['s_i'] + op_cost) / unit['p_min_i']\n            metric_list.append((i, metric))\n        metric_list.sort(key=lambda x: x[1])\n        idx = metric_list[0][0]\n        u[idx] = 1\n        candidate_on.remove(idx)\n        min_val = units_info[idx]['p_min_i']\n        max_val = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'], units_info[idx]['p_up_i'])\n        min_power[idx], max_power[idx] = min_val, max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Adequate: Decommission expensive non-must-on units\n    candidate_off_adequate = []\n    for i in range(n):\n        if u[i] == 1 and not must_on[i]:\n            if units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                candidate_off_adequate.append(i)\n    cost_list_adequate = []\n    for i in candidate_off_adequate:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_power[i] + unit['c_i'] * min_power[i]**2\n        cost_list_adequate.append((i, cost))\n    cost_list_adequate.sort(key=lambda x: x[1], reverse=True)\n    for i, _ in cost_list_adequate:\n        new_min = total_min - min_power[i]\n        new_max = total_max - max_power[i]\n        if new_min <= current_load and new_max >= current_load:\n            u[i] = 0\n            total_min, total_max = new_min, new_max\n            min_power[i], max_power[i] = 0.0, 0.0\n    \n    # Dispatch using lambda iteration\n    committed_indices = [i for i in range(n) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p_output])\n    \n    b_list = []; c_list = []; min_list = []; max_list = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b_list.append(unit['b_i'])\n        c_list.append(unit['c_i'])\n        min_list.append(min_power[i])\n        max_list.append(max_power[i])\n    \n    # Lambda iteration setup\n    low = min(b + 2*c*min_val for (b,c,min_val) in zip(b_list, c_list, min_list))\n    high = max(b + 2*c*max_val for (b,c,max_val) in zip(b_list, c_list, max_list))\n    tol_lambda = 1e-5\n    max_iter = 1000\n    p_temp = [0.0] * len(committed_indices)\n    total_power = 0.0\n    \n    # Bisection method for lambda\n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        total_power = 0.0\n        for idx, (b, c, min_val, max_val) in enumerate(zip(b_list, c_list, min_list, max_list)):\n            if c == 0:\n                p_i = min_val if mid < b else max_val\n            else:\n                p_star = (mid - b) / (2 * c)\n                p_i = max(min_val, min(max_val, p_star))\n            p_temp[idx] = p_i\n            total_power += p_i\n        \n        diff = total_power - current_load\n        if abs(diff) < tol_lambda:\n            break\n        low = mid if diff < 0 else low\n        high = mid if diff >= 0 else high\n    \n    # Assign dispatch results\n    for idx, i in enumerate(committed_indices):\n        p_output[i] = p_temp[idx]\n    \n    # Greedy residual adjustment\n    residual = current_load - sum(p_output)\n    if abs(residual) > 1e-5:\n        committed_units = [(i, p_output[i], units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i]) \n                          for i in committed_indices]\n        if residual > 0:\n            candidates = [(i, mc, max_power[i] - p_output[i]) \n                          for i, p, mc in committed_units if p_output[i] < max_power[i]]\n            if candidates:\n                i, _, headroom = min(candidates, key=lambda x: x[1])\n                inc = min(residual, headroom)\n                p_output[i] += inc\n        else:\n            candidates = [(i, mc, p_output[i] - min_power[i])\n                          for i, p, mc in committed_units if p_output[i] > min_power[i]]\n            if candidates:\n                i, _, headroom = max(candidates, key=lambda x: x[1])\n                dec = min(-residual, headroom)\n                p_output[i] -= dec\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0051590988,
          "gap_price_rate": 0.0085132484,
          "fitness": 0.0068361736
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or exceeding shutdown ramp) and must-off units (offline with insufficient min-down time)\n2. Initialize commitment: must-on units to committed, must-off units to off, flexible units retain previous state\n3. Compute feasible power ranges for committed units considering ramp and startup constraints\n4. Adjust commitment iteratively:\n   a) Over-committed: Turn off non-must-on units by highest min-power cost until within load\n   b) Under-committed: Turn on offline units by best (startup cost + min-power cost)/min-power metric\n   c) Adequate: Decommit expensive non-must-on units if system adequacy holds\n5. Recompute power ranges post-adjustment\n6. Perform constrained economic dispatch:\n   a) Set committed units to minimum feasible power\n   b) Distribute residual load by increasing outputs of units with lowest marginal cost\n7. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online in previous period\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:  # Offline in previous period\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Step 2: Initialize commitment states\n    u = [0] * n_units\n    for i in range(n_units):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Step 3: Compute initial feasible power ranges\n    p_min_curr = [0] * n_units\n    p_max_curr = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:  # Unit was online\n                p_min_curr[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                p_max_curr[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:  # Unit started now\n                p_min_curr[i] = units_info[i]['p_min_i']\n                p_max_curr[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            p_min_curr[i] = 0\n            p_max_curr[i] = 0\n    \n    # Step 4: Adjust commitment iteratively\n    total_min = sum(p_min_curr)\n    total_max = sum(p_max_curr)\n    \n    # 4a: Over-committed adjustment\n    cand_off = []\n    for i in range(n_units):\n        if u[i] == 1 and not must_on[i] and p_min_curr[i] <= units_info[i]['p_shut_i']:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_curr[i] + units_info[i]['c_i'] * (p_min_curr[i]**2)\n            cand_off.append((i, cost_at_min))\n    cand_off.sort(key=lambda x: x[1], reverse=True)\n    \n    for i, _ in cand_off:\n        if total_min > current_load:\n            u[i] = 0\n            total_min -= p_min_curr[i]\n            total_max -= p_max_curr[i]\n        else:\n            break\n    \n    # 4b: Under-committed adjustment\n    cand_on = []\n    for i in range(n_units):\n        if u[i] == 0 and not must_off[i]:\n            p_min_candidate = units_info[i]['p_min_i']\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_candidate + units_info[i]['c_i'] * (p_min_candidate**2)\n            metric = (units_info[i]['s_i'] + cost_at_min) / p_min_candidate\n            cand_on.append((i, metric, p_min_candidate, min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])))\n    cand_on.sort(key=lambda x: x[1])\n    \n    for i, _, p_min_cand, p_max_cand in cand_on:\n        if total_max < current_load:\n            u[i] = 1\n            total_min += p_min_cand\n            total_max += p_max_cand\n        else:\n            break\n    \n    # Step 5: Recompute power ranges post-adjustment\n    p_min_curr = [0] * n_units\n    p_max_curr = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1 and u[i] == 1:  # Unit remains online\n                p_min_curr[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                p_max_curr[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:  # Unit started in current period\n                p_min_curr[i] = units_info[i]['p_min_i']\n                p_max_curr[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            p_min_curr[i] = 0\n            p_max_curr[i] = 0\n    total_min = sum(p_min_curr)\n    total_max = sum(p_max_curr)\n    \n    # 4c: Adequate adjustment\n    if total_min <= current_load <= total_max:\n        cand_off2 = []\n        for i in range(n_units):\n            if u[i] == 1 and not must_on[i] and p_min_curr[i] <= units_info[i]['p_shut_i']:\n                cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_curr[i] + units_info[i]['c_i'] * (p_min_curr[i]**2)\n                cand_off2.append((i, cost_at_min, p_min_curr[i], p_max_curr[i]))\n        cand_off2.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, cost, p_min_val, p_max_val in cand_off2:\n            new_min = total_min - p_min_val\n            new_max = total_max - p_max_val\n            if new_min <= current_load <= new_max:\n                u[i] = 0\n                total_min = new_min\n                total_max = new_max\n                p_min_curr[i] = 0\n                p_max_curr[i] = 0\n    \n    # Step 6: Economic dispatch\n    p = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = p_min_curr[i]\n    residual = current_load - sum(p)\n    \n    # Distribute residual load\n    while residual > 1e-6:  # Account for floating point precision\n        candidate = -1\n        min_mc = float('inf')\n        for i in range(n_units):\n            if u[i] == 1 and p[i] < p_max_curr[i] - 1e-6:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if marginal_cost < min_mc:\n                    min_mc = marginal_cost\n                    candidate = i\n        if candidate == -1:\n            break\n        alloc = min(p_max_curr[candidate] - p[candidate], residual)\n        p[candidate] += alloc\n        residual -= alloc\n    \n    # Step 7: Output\n    schedules = np.vstack([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.0086286729,
          "fitness": 0.0068754583
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "enhanced_adaptive_with_forecast",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown ramp) and must-off units (offline with insufficient min-down time)  \n2. Initialize commitment: must-on units committed, must-off units decommitted, flexible units retain previous state  \n3. Compute feasible power ranges considering ramp/startup/shutdown constraints  \n4. Adjust commitment iteratively:  \n   - Under-committed: Activate units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: Decommit non-must-on units by highest min-power cost  \n   - Adequate: Decommit units only if savings exceed next-period startup risk (using forecast)  \n5. Perform economic dispatch using lambda iteration with bisection  \n6. Handle residual load with marginal cost-based greedy adjustment  \n7. Return final commitment states and power outputs  \n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_with_forecast(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    units = units_info\n    n_units = len(units)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    status_changed = np.zeros(n_units, dtype=bool)\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units):\n        t_i_0 = unit['t_i_0']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Was online\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Initialize commitment\n    for i, unit in enumerate(units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = unit['u_i_0']\n        status_changed[i] = (u[i] != unit['u_i_0'])\n    \n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units):\n        if u[i] == 1:  # Committed\n            if unit['u_i_0'] == 1:  # Was online\n                p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                p_min[i] = unit['p_min_i']\n                p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Decommitted\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    # Calculate current min/max capacities\n    total_min = sum(p_min[i] for i in range(n_units))\n    total_max = sum(p_max[i] for i in range(n_units))\n    \n    # Step 4: Adjust commitment\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    non_must_on = [i for i in committed_indices if i not in must_on]\n    \n    # Under-committed\n    while total_max < current_load:\n        candidates = []\n        for i, unit in enumerate(units):\n            if u[i] == 0 and i not in must_off:  # Offline and flexible\n                # Startup cost + min power cost\n                cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n                metric = (unit['s_i'] + cost_min) / unit['p_min_i']\n                candidates.append((metric, i))\n        \n        if not candidates:\n            break\n            \n        _, best_i = min(candidates)\n        u[best_i] = 1\n        status_changed[best_i] = True\n        \n        # Update power ranges for activated unit\n        unit = units[best_i]\n        p_min[best_i] = unit['p_min_i']\n        p_max[best_i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min[best_i]\n        total_max += p_max[best_i]\n    \n    # Over-committed\n    while total_min > current_load and non_must_on:\n        # Get costs at minimum power\n        cost_at_min = []\n        for i in non_must_on:\n            unit = units[i]\n            cost = unit['a_i'] + unit['b_i'] * p_min[i] + unit['c_i'] * p_min[i] ** 2\n            cost_at_min.append((cost, i))\n        \n        cost_at_min.sort(reverse=True)\n        _, worst_i = cost_at_min[0]\n        \n        # Update totals and commit status\n        total_min -= p_min[worst_i]\n        total_max -= p_max[worst_i]\n        u[worst_i] = 0\n        status_changed[worst_i] = (units[worst_i]['u_i_0'] == 1)\n        non_must_on.remove(worst_i)\n        p_min[worst_i] = p_max[worst_i] = 0\n    \n    # Adequate case with forecast awareness\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    non_must_on = [i for i in committed_indices if i not in must_on]\n    non_must_on_costs = []\n    \n    for i in non_must_on:\n        unit = units[i]\n        cost = unit['a_i'] + unit['b_i'] * p_min[i] + unit['c_i'] * p_min[i] ** 2\n        non_must_on_costs.append((cost, i))\n    \n    non_must_on_costs.sort(reverse=True)\n    \n    for cost, i in non_must_on_costs:\n        # Check system adequacy without unit i\n        new_min = total_min - p_min[i]\n        new_max = total_max - p_max[i]\n        \n        # Check if unit would be needed next period\n        cost_saving = cost\n        startup_penalty = units[i]['s_i']\n        need_next_period = (new_max < next_load)\n        \n        # Turn off if adequate and (no next-period need OR saving exceeds startup)\n        if new_min <= current_load <= new_max and (not need_next_period or cost_saving > startup_penalty):\n            u[i] = 0\n            status_changed[i] = (units[i]['u_i_0'] == 1)\n            total_min = new_min\n            total_max = new_max\n            p_min[i] = p_max[i] = 0\n    \n    # Step 5: Economic dispatch using Lambda iteration\n    committed_units = [i for i in range(n_units) if u[i] == 1]\n    \n    # Initialize all units at minimum power\n    for i in committed_units:\n        p[i] = p_min[i]\n    \n    # Residual load after min-power allocation\n    residual = current_load - sum(p[i] for i in committed_units)\n    \n    # Bisection parameters\n    tol = 0.01\n    lambda_low = 0\n    lambda_high = 10000\n    \n    # Lambda bisection\n    while abs(residual) > tol and lambda_high - lambda_low > tol:\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_output = 0\n        \n        # Calculate outputs for all units at current lambda\n        for i in committed_units:\n            unit = units[i]\n            if unit['c_i'] > 0:\n                p_desired = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            else:  # Linear cost function\n                p_desired = p_max[i] if lambda_mid >= unit['b_i'] else p_min[i]\n            \n            # Respect power limits\n            p_i = max(p_min[i], min(p_max[i], p_desired))\n            total_output += p_i\n        \n        # Update bisection bounds\n        if total_output < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        residual = current_load - total_output\n    \n    # Set power outputs\n    for i in committed_units:\n        unit = units[i]\n        if unit['c_i'] > 0:\n            p_desired = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        else:\n            p_desired = p_max[i] if lambda_mid >= unit['b_i'] else p_min[i]\n        p[i] = max(p_min[i], min(p_max[i], p_desired))\n    \n    # Step 6: Handle residual with greedy adjustment\n    residual = current_load - sum(p)\n    \n    while abs(residual) > tol:\n        adjustments = []\n        if residual > 0:  # Need more power\n            for i in committed_units:\n                if p[i] < p_max[i]:\n                    margin = p_max[i] - p[i]\n                    marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    adjustments.append((marginal_cost, margin, i))\n            adjustments.sort()\n        else:  # Need less power\n            for i in committed_units:\n                if p[i] > p_min[i]:\n                    margin = p[i] - p_min[i]\n                    marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    adjustments.append((marginal_cost, margin, i))\n            adjustments.sort(reverse=True)\n        \n        if not adjustments:\n            break\n        \n        # Find unit with maximum adjustable margin\n        _, max_adjust, best_i = adjustments[0]\n        adjustment = min(abs(residual), max_adjust)\n        if residual > 0:\n            p[best_i] += adjustment\n            residual -= adjustment\n        else:\n            p[best_i] -= adjustment\n            residual += adjustment\n    \n    # Final schedule\n    schedules = np.array([u.tolist(), p.tolist()])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0050012153,
          "gap_price_rate": 0.0092115206,
          "fitness": 0.0071063679
     },
     {
          "name": "lambda_priority_rolling_commitment",
          "algorithm": "1. Identify must-on units (currently online with insufficient min-up time or exceeding shutdown capacity) and must-off units (currently offline with insufficient min-down time)  \n2. Initialize commitment: set must-on to 1, must-off to 0, others retain previous state  \n3. Calculate feasible power ranges for committed units considering ramp/startup constraints  \n4. Adjust commitment iteratively:  \n   - For under-committed systems (insufficient max capacity), activate units by cost-effectiveness metric: (startup_cost + min_power_cost)/min_power  \n   - For over-committed systems (excess min capacity), deactivate non-must-on units by highest min_power_cost  \n   - For adequate systems, deactivate expensive non-must-on units while maintaining system adequacy  \n5. Perform constrained economic dispatch via lambda iteration with bisection  \n6. Resolve residual load with greedy adjustment based on marginal costs  \n7. Return final commitment states and power outputs  \n\n",
          "code": "import numpy as np\n\ndef lambda_priority_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_current = [0] * n_units\n    p_current = [0.0] * n_units\n    p_min_current = [0.0] * n_units\n    p_max_current = [0.0] * n_units\n\n    # Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i, unit in enumerate(units_info):\n        if i in must_on:\n            u_current[i] = 1\n        elif i in must_off:\n            u_current[i] = 0\n        else:\n            u_current[i] = unit['u_i_0']\n            \n        if u_current[i] == 1:\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            u_i0 = unit['u_i_0']\n            p_i0 = unit['p_i_0']\n            \n            if u_i0 == 1:\n                p_min_current[i] = max(p_min, p_i0 - unit['p_down_i'])\n                p_max_current[i] = min(p_max, p_i0 + unit['p_up_i'])\n            else:\n                p_min_current[i] = p_min\n                p_max_current[i] = min(p_max, unit['p_start_i'])\n        else:\n            p_min_current[i] = 0\n            p_max_current[i] = 0\n\n    # Compute total min/max capacity\n    total_min = sum(p_min_current)\n    total_max = sum(p_max_current)\n    \n    # Adjust under-committed state\n    if total_max < current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_current[i] == 0 and i not in must_off:\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_p = unit['p_min_i']\n                min_cost = a_i + b_i * min_p + c_i * min_p**2\n                metric = (s_i + min_cost) / min_p\n                candidates.append((metric, i))\n        \n        candidates.sort(key=lambda x: x[0])\n        for _, idx in candidates:\n            if total_max >= current_load:\n                break\n                \n            p_min_here = units_info[idx]['p_min_i']\n            p_max_here = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            \n            u_current[idx] = 1\n            p_min_current[idx] = p_min_here\n            p_max_current[idx] = p_max_here\n            total_min += p_min_here\n            total_max += p_max_here\n    \n    # Adjust over-committed state\n    if total_min > current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_current[i] == 1 and i not in must_on:\n                min_p = p_min_current[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_cost = a_i + b_i * min_p + c_i * min_p**2\n                candidates.append((min_cost, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, idx in candidates:\n            if total_min <= current_load:\n                break\n                \n            total_min -= p_min_current[idx]\n            total_max -= p_max_current[idx]\n            u_current[idx] = 0\n            p_min_current[idx] = 0\n            p_max_current[idx] = 0\n            p_current[idx] = 0\n    \n    # Deactivate expensive units in adequate state\n    if total_min <= current_load <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_current[i] == 1 and i not in must_on:\n                min_p = p_min_current[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_cost = a_i + b_i * min_p + c_i * min_p**2\n                candidates.append((min_cost, i, p_min_current[i], p_max_current[i]))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, p_min_here, p_max_here in candidates:\n            new_min = total_min - p_min_here\n            new_max = total_max - p_max_here\n            if new_min <= current_load <= new_max:\n                total_min = new_min\n                total_max = new_max\n                u_current[idx] = 0\n                p_min_current[idx] = 0\n                p_max_current[idx] = 0\n                p_current[idx] = 0\n    \n    # Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if u_current[i] == 1]\n    if committed_indices:\n        # Find lambda bounds\n        lambd_low = min(unit['b_i'] + 2*unit['c_i']*p_min_current[i] for i, unit in enumerate(units_info) if i in committed_indices)\n        lambd_high = max(unit['b_i'] + 2*unit['c_i']*p_max_current[i] for i, unit in enumerate(units_info) if i in committed_indices)\n        \n        # Bisection loop\n        for _ in range(100):\n            lambd_mid = (lambd_low + lambd_high) / 2\n            total_output = 0.0\n            for idx in committed_indices:\n                unit = units_info[idx]\n                if unit['c_i'] != 0:\n                    p_val = (lambd_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = p_max_current[idx] if lambd_mid > unit['b_i'] else p_min_current[idx]\n                \n                p_val = max(p_min_current[idx], min(p_max_current[idx], p_val))\n                p_current[idx] = p_val\n                total_output += p_val\n            \n            if abs(total_output - current_load) < 0.1:\n                break\n                \n            if total_output < current_load:\n                lambd_low = lambd_mid\n            else:\n                lambd_high = lambd_mid\n        \n        # Residual adjustment\n        residual = current_load - total_output\n        if residual > 0:\n            candidates = []\n            for idx in committed_indices:\n                if p_current[idx] < p_max_current[idx]:\n                    marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_current[idx]\n                    candidates.append((marginal_cost, idx))\n            candidates.sort(key=lambda x: x[0])\n            for mc, idx in candidates:\n                avail = p_max_current[idx] - p_current[idx]\n                if avail > residual:\n                    p_current[idx] += residual\n                    residual = 0\n                else:\n                    p_current[idx] += avail\n                    residual -= avail\n                if residual <= 1e-3:\n                    break\n        elif residual < 0:\n            residual = abs(residual)\n            candidates = []\n            for idx in committed_indices:\n                if p_current[idx] > p_min_current[idx]:\n                    marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_current[idx]\n                    candidates.append((-marginal_cost, idx))\n            candidates.sort(key=lambda x: x[0])\n            for _, idx in candidates:\n                avail = p_current[idx] - p_min_current[idx]\n                if avail > residual:\n                    p_current[idx] -= residual\n                    residual = 0\n                else:\n                    p_current[idx] -= avail\n                    residual -= avail\n                if residual <= 1e-3:\n                    break\n\n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_current[i] == 0:\n            p_current[i] = 0.0\n\n    return np.array([u_current, p_current], dtype=np.float64)",
          "from": "crossover",
          "gap_power_rate": 0.0049946815,
          "gap_price_rate": 0.009261831,
          "fitness": 0.0071282563
     },
     {
          "name": "hybrid_lambda_enhanced_commitment",
          "algorithm": "1. Identify must-on units (insufficient min-up time or previous output exceeding shutdown ramp) and must-off units (insufficient min-down time). 2. Initialize commitment: set must-on units to 1, must-off units to 0, others retain previous state. 3. For committed units, compute current feasible power ranges considering ramp/startup constraints. 4. Adjust commitment iteratively: a) Under-committed: activate units by lowest (startup cost + min-power cost)/min-power metric b) Over-committed: decommit units by highest min-power cost c) Adequate: decommission expensive non-must-on units while maintaining adequacy. 5. Perform economic dispatch via lambda iteration within feasible ranges. 6. Resolve residual load with constrained greedy adjustment. 7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef hybrid_lambda_enhanced_commitment(units_info, load):\n    # Extract current load\n    load_current = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    p_min_current = np.zeros(n_units)\n    p_max_current = np.zeros(n_units)\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        # Must-on conditions\n        if (unit['u_i_0'] == 1) and ((unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif (unit['u_i_0'] == 0) and (unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(i)\n    \n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u_arr[i] = 1\n        elif i in must_off:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n    \n    # Step 3: Compute feasible power ranges for committed units\n    def calc_feasible_ranges():\n        for i, unit in enumerate(units_info):\n            if u_arr[i] == 1:\n                if unit['u_i_0'] == 1:  # Previously online\n                    p_min_current[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    p_max_current[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:  # Starting up\n                    p_min_current[i] = unit['p_min_i']\n                    p_max_current[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n        return p_min_current.copy(), p_max_current.copy()\n    \n    p_min_current, p_max_current = calc_feasible_ranges()\n    \n    # Step 4: Adjust commitment states\n    total_min = np.sum(p_min_current)\n    total_max = np.sum(p_max_current)\n    load_current = load[0]\n    \n    # Case a: Under-committed (total_max < load_current)\n    if total_max < load_current:\n        # Find candidate offline units (not must-off)\n        candidate_on = [i for i in range(n_units) if u_arr[i] == 0 and i not in must_off]\n        while total_max < load_current and candidate_on:\n            # Calculate cost-effectiveness metric\n            metrics = []\n            for i in candidate_on:\n                unit = units_info[i]\n                min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n                metric = (unit['s_i'] + min_cost) / unit['p_min_i']\n                metrics.append((metric, i))\n            \n            # Activate most cost-effective unit\n            metrics.sort(key=lambda x: x[0])\n            activate_idx = metrics[0][1]\n            u_arr[activate_idx] = 1\n            # Update feasible ranges\n            p_min_current[activate_idx] = units_info[activate_idx]['p_min_i']\n            p_max_current[activate_idx] = min(units_info[activate_idx]['p_max_i'], units_info[activate_idx]['p_start_i'])\n            # Recompute total min/max\n            total_min += p_min_current[activate_idx]\n            total_max += p_max_current[activate_idx]\n            # Remove activated unit from candidates\n            candidate_on.remove(activate_idx)\n    \n    # Case b: Over-committed (total_min > load_current)\n    if total_min > load_current:\n        # Find candidate units to turn off (non-must-on)\n        candidate_off = [i for i in range(n_units) if u_arr[i] == 1 and i not in must_on]\n        # Sort by highest min-power operating cost\n        candidate_off.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + units_info[i]['c_i']*units_info[i]['p_min_i']**2, \n                          reverse=True)\n        \n        for i in candidate_off:\n            if total_min <= load_current:\n                break\n            # Decommit unit\n            u_arr[i] = 0\n            p_min_current[i] = 0\n            p_max_current[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= units_info[i]['p_start_i'] if units_info[i]['u_i_0'] == 0 else units_info[i]['p_max_i']\n    \n    # Case c: Adequate system\n    if total_min <= load_current <= total_max:\n        # Find candidate non-must-on units to turn off\n        candidate_off = [i for i in range(n_units) if u_arr[i] == 1 and i not in must_on]\n        # Sort by highest min-power cost\n        candidate_off.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + units_info[i]['c_i']*units_info[i]['p_min_i']**2, \n                          reverse=True)\n        \n        for i in candidate_off:\n            new_total_max = total_max - p_max_current[i]\n            if new_total_max >= load_current:\n                # Decommit unit\n                u_arr[i] = 0\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n                total_min -= units_info[i]['p_min_i']\n                total_max = new_total_max\n    \n    # Recalculate feasible ranges after commitment adjustments\n    p_min_current, p_max_current = calc_feasible_ranges()\n    committed_indices = [i for i in range(n_units) if u_arr[i] == 1]\n    \n    # Step 5: Economic dispatch via lambda iteration\n    if committed_indices:\n        # Set initial output to min\n        for i in committed_indices:\n            p_arr[i] = p_min_current[i]\n        residual = load_current - np.sum(p_arr)\n        \n        # Lambda iteration setup\n        if abs(residual) > 1e-4:\n            b_vals = np.array([units_info[i]['b_i'] for i in committed_indices])\n            c_vals = np.array([units_info[i]['c_i'] for i in committed_indices])\n            p_mins = np.array([p_min_current[i] for i in committed_indices])\n            p_maxs = np.array([p_max_current[i] for i in committed_indices])\n            \n            # Bounds for lambda\n            low = np.min(2 * c_vals * p_mins + b_vals)\n            high = np.max(2 * c_vals * p_maxs + b_vals)\n            lambda_mid = (low + high) / 2\n            tolerance_lambda = 0.1  # MW tolerance\n            max_iter = 1000\n            \n            # Lambda iteration\n            for _ in range(max_iter):\n                p_dispatch = []\n                for idx, i in enumerate(committed_indices):\n                    if c_vals[idx] == 0:\n                        if lambda_mid < b_vals[idx]:\n                            p_dispatch.append(p_mins[idx])\n                        else:\n                            p_dispatch.append(p_maxs[idx])\n                    else:\n                        # Calculate unconstrained dispatch\n                        p_unc = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx])\n                        # Enforce constraints\n                        p_val = max(p_mins[idx], min(p_maxs[idx], p_unc))\n                        p_dispatch.append(p_val)\n                \n                total_gen = np.sum(p_dispatch)\n                gen_diff = total_gen - load_current\n                \n                if abs(gen_diff) < tolerance_lambda:\n                    for j, i in enumerate(committed_indices):\n                        p_arr[i] = p_dispatch[j]\n                    residual = load_current - total_gen\n                    break\n                \n                if gen_diff < 0:\n                    low = lambda_mid\n                else:\n                    high = lambda_mid\n                lambda_mid = (low + high) / 2\n            else:\n                # Fallback to greedy dispatch if not converged\n                p_dispatch = np.clip(p_dispatch, p_mins, p_maxs)\n                for j, i in enumerate(committed_indices):\n                    p_arr[i] = p_dispatch[j]\n                residual = load_current - np.sum(p_dispatch)\n            \n            # Step 6: Greedy residual adjustment\n            tolerance_greedy = 1e-4\n            if residual > tolerance_greedy:\n                # Increase generation from cheapest units\n                candidates = [i for i in committed_indices if p_arr[i] < p_max_current[i]]\n                if candidates:\n                    marginal_costs = [2 * units_info[i]['c_i'] * p_arr[i] + units_info[i]['b_i'] for i in candidates]\n                    sorted_indices = np.argsort(marginal_costs)\n                    \n                    for idx in sorted_indices:\n                        i = candidates[idx]\n                        increment = min(residual, p_max_current[i] - p_arr[i])\n                        p_arr[i] += increment\n                        residual -= increment\n                        if residual < tolerance_greedy:\n                            break\n            \n            elif residual < -tolerance_greedy:\n                # Decrease generation from most expensive units\n                candidates = [i for i in committed_indices if p_arr[i] > p_min_current[i]]\n                if candidates:\n                    marginal_costs = [2 * units_info[i]['c_i'] * p_arr[i] + units_info[i]['b_i'] for i in candidates]\n                    sorted_indices = np.argsort(marginal_costs)[::-1]\n                    \n                    for idx in sorted_indices:\n                        i = candidates[idx]\n                        decrement = min(-residual, p_arr[i] - p_min_current[i])\n                        p_arr[i] -= decrement\n                        residual += decrement\n                        if residual > -tolerance_greedy:\n                            break\n    \n    # Prepare output\n    schedules = np.vstack((u_arr, p_arr))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049947392,
          "gap_price_rate": 0.0092618964,
          "fitness": 0.0071283178
     },
     {
          "name": "combined_lambda_adaptive_rolling",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown ramp) and must-off units (offline with insufficient min-down time).\n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to previous state.\n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints.\n4. Adjust commitment:\n   a. Under-committed: activate offline units using (startup cost + min-power production cost)/min-power metric\n   b. Over-committed: decommit non-must-on units by highest min-power operating cost\n   c. Adequate: decommission expensive non-must-on units while maintaining system adequacy\n5. Perform economic dispatch using lambda iteration with bisection\n6. Adjust residual load via greedy method based on marginal costs\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef combined_lambda_adaptive_rolling(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:  # Was online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < t_off_min_i:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate feasible power ranges for committed units\n    feasible_min = [0.0] * n_units\n    feasible_max = [0.0] * n_units\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            u_i_0 = unit['u_i_0']\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            if u_i_0 == 1:  # Was online\n                feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n                feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n            else:  # Starting up\n                feasible_min[i] = p_min_i\n                feasible_max[i] = min(p_max_i, p_start_i)\n    \n    # Calculate total min/max generation\n    total_min = sum(feasible_min)\n    total_max = sum(feasible_max)\n    \n    # Adjust commitment for under-committed case\n    if total_max < current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 0 and i not in must_off:\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                cost_at_min = a_i + b_i * p_min_i + c_i * p_min_i**2\n                metric = (s_i + cost_at_min) / p_min_i\n                candidates.append((metric, i))\n        \n        candidates.sort(key=lambda x: x[0])\n        for metric, i in candidates:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            p_min_i = units_info[i]['p_min_i']\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += p_min_i\n            total_max += feasible_max[i]\n    \n    # Adjust commitment for over-committed case\n    if total_min > current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and i not in must_on:\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                cost_at_min = a_i + b_i * feasible_min[i] + c_i * feasible_min[i]**2\n                candidates.append((cost_at_min, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in candidates:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n    \n    # Adjust commitment for adequate case\n    if total_min <= current_load <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and i not in must_on:\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                cost_at_min = a_i + b_i * feasible_min[i] + c_i * feasible_min[i]**2\n                candidates.append((cost_at_min, i, feasible_min[i], feasible_max[i]))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for cost, i, fmin, fmax in candidates:\n            new_total_min = total_min - fmin\n            new_total_max = total_max - fmax\n            if new_total_min <= current_load <= new_total_max:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                feasible_min[i] = 0\n                feasible_max[i] = 0\n    \n    # Economic dispatch using lambda iteration\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    for i in committed_indices:\n        p[i] = feasible_min[i]\n    total_gen = sum(p)\n    \n    if abs(total_gen - current_load) > 1e-6 and committed_indices:\n        # Lambda iteration setup\n        lambda_low = 0\n        lambda_high = 0\n        for i in committed_indices:\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            marginal_min = b_i + 2 * c_i * feasible_min[i]\n            marginal_max = b_i + 2 * c_i * feasible_max[i]\n            lambda_high = max(lambda_high, marginal_max)\n        lambda_high += 1  # Ensure initial high value\n        \n        # Bisection method\n        max_iter = 100\n        tol = 0.1\n        for _ in range(max_iter):\n            lam = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_opt = (lam - b_i) / (2 * c_i) if c_i > 0 else feasible_max[i]\n                p_i = max(feasible_min[i], min(p_opt, feasible_max[i]))\n                p[i] = p_i\n                total_gen += p_i\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lam\n            else:\n                lambda_high = lam\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > 1e-3 and committed_indices:\n            if residual > 0:  # Under generation\n                candidates = []\n                for i in committed_indices:\n                    if p[i] < feasible_max[i]:\n                        unit = units_info[i]\n                        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                        candidates.append((marginal_cost, i))\n                candidates.sort(key=lambda x: x[0])\n                for mc, i in candidates:\n                    if residual <= 0:\n                        break\n                    max_additional = feasible_max[i] - p[i]\n                    to_add = min(max_additional, residual)\n                    p[i] += to_add\n                    residual -= to_add\n            else:  # Over generation\n                residual = abs(residual)\n                candidates = []\n                for i in committed_indices:\n                    if p[i] > feasible_min[i]:\n                        unit = units_info[i]\n                        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                        candidates.append((marginal_cost, i))\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                for mc, i in candidates:\n                    if residual <= 0:\n                        break\n                    max_reduction = p[i] - feasible_min[i]\n                    to_reduce = min(max_reduction, residual)\n                    p[i] -= to_reduce\n                    residual -= to_reduce\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0049947449,
          "gap_price_rate": 0.0092619052,
          "fitness": 0.0071283251
     },
     {
          "name": "refined_lambda_commitment_dispatch",
          "algorithm": "1. Identify must-on units (currently online units failing min-up time or shutdown ramp constraints) and must-off units (offline units failing min-down time).\n2. Initialize commitment: set must-on units to 'on', must-off units to 'off', others retain previous state.\n3. Calculate feasible power ranges for committed units considering ramp rates, startup/shutdown constraints.\n4. Iteratively adjust commitment:\n   a. For under-committed systems (insufficient max capacity), activate most cost-effective offline units.\n   b. For over-committed systems (excess min capacity), decommit highest-cost non-must-on units.\n   c. Decommission expensive non-must-on units if adequacy holds.\n5. Perform lambda iteration for economic dispatch respecting output constraints.\n6. Handle residual load after dispatch via greedy adjustment.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_lambda_commitment_dispatch(units_info, load):\n    load_current = load[0]  # current load to meet\n    \n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min and t_i0 > 0) or p_i0 > p_shut:\n                must_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    u = [0] * n_units\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Initialize min and max power outputs\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            min_outputs[i] = max_outputs[i] = 0.0\n            continue\n            \n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_i0 = unit['p_i_0']\n        \n        if unit['u_i_0'] == 1 and u[i] == 1:  # remains on\n            min_outputs[i] = max(p_min, p_i0 - p_down)\n            max_outputs[i] = min(p_max, p_i0 + p_up)\n        elif unit['u_i_0'] == 0 and u[i] == 1:  # starting up\n            min_outputs[i] = p_min\n            max_outputs[i] = min(p_max, p_start)\n        elif unit['u_i_0'] == 1 and u[i] == 0:  # shutting down\n            min_outputs[i] = max_outputs[i] = 0.0\n        else:  # remains off\n            min_outputs[i] = max_outputs[i] = 0.0\n    \n    total_min = np.sum(min_outputs)\n    total_max = np.sum(max_outputs)\n    \n    # Adjust commitment iteratively\n    max_iter = n_units\n    iter_count = 0\n    \n    while iter_count < max_iter:\n        iter_count += 1\n        \n        if total_max < load_current:  # Under-committed\n            available_offline = [i for i in range(n_units) \n                                if u[i] == 0 and i not in must_off]\n            if not available_offline:\n                break\n                \n            metrics = []\n            for i in available_offline:\n                unit = units_info[i]\n                p_min_candidate = unit['p_min_i']\n                cost = unit['a_i'] + unit['b_i'] * p_min_candidate + unit['c_i'] * p_min_candidate**2 + unit['s_i']\n                metrics.append((cost / p_min_candidate, i))\n            \n            if not metrics:\n                break\n            metrics.sort(key=lambda x: x[0])\n            candidate = metrics[0][1]\n            u[candidate] = 1\n            unit_candidate = units_info[candidate]\n            min_candidate = unit_candidate['p_min_i']\n            max_candidate = min(unit_candidate['p_max_i'], unit_candidate['p_start_i'])\n            min_outputs[candidate] = min_candidate\n            max_outputs[candidate] = max_candidate\n            total_min += min_candidate\n            total_max += max_candidate\n            \n        elif total_min > load_current:  # Over-committed\n            decommitable = [i for i in range(n_units) \n                           if u[i] == 1 and i not in must_on]\n            if not decommitable:\n                break\n                \n            metrics = []\n            for i in decommitable:\n                cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2\n                metrics.append((cost, i))\n            \n            metrics.sort(key=lambda x: x[0], reverse=True)\n            candidate = metrics[0][1]\n            u[candidate] = 0\n            removed_min = min_outputs[candidate]\n            removed_max = max_outputs[candidate]\n            min_outputs[candidate] = 0.0\n            max_outputs[candidate] = 0.0\n            total_min -= removed_min\n            total_max -= removed_max\n            \n        else:  # Adequate\n            break\n    \n    # Greedy decommitment for expensive non-must-on units\n    decommitable = [i for i in range(n_units) \n                   if u[i] == 1 and i not in must_on]\n    if decommitable:\n        metrics = []\n        for i in decommitable:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2\n            metrics.append((cost, i))\n        \n        metrics.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in metrics:\n            new_total_min = total_min - min_outputs[i]\n            new_total_max = total_max - max_outputs[i]\n            if new_total_min <= load_current <= new_total_max:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_outputs[i] = 0.0\n                max_outputs[i] = 0.0\n    \n    # Commit if none are committed but load exists (emergency)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices and abs(load_current) > 1e-6:\n        candidate = np.argmin([unit['p_min_i'] for unit in units_info])\n        u[candidate] = 1\n        min_outputs[candidate] = units_info[candidate]['p_min_i']\n        max_outputs[candidate] = min(units_info[candidate]['p_max_i'], units_info[candidate]['p_start_i'])\n        committed_indices = [candidate]\n        total_min = min_outputs[candidate]\n        total_max = max_outputs[candidate]\n    \n    # Lambda iteration for economic dispatch\n    p = min_outputs.copy()\n    if committed_indices and abs(total_max - total_min) > 1e-6:\n        # Calculate lambda bounds\n        lam_low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_outputs[i] for i in committed_indices) - 1.0\n        lam_high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_outputs[i] for i in committed_indices) + 1.0\n        \n        # Bisection for optimal lambda\n        for _ in range(100):\n            if abs(lam_high - lam_low) < 1e-6:\n                break\n            lam_mid = (lam_low + lam_high) / 2.0\n            total_mid = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                marginal_low = unit['b_i'] + 2 * unit['c_i'] * min_outputs[i]\n                marginal_high = unit['b_i'] + 2 * unit['c_i'] * max_outputs[i]\n                if lam_mid < marginal_low:\n                    p_i = min_outputs[i]\n                elif lam_mid > marginal_high:\n                    p_i = max_outputs[i]\n                else:\n                    p_i = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_outputs[i], min(p_i, max_outputs[i]))\n                total_mid += p_i\n            \n            if total_mid < load_current:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n        \n        # Calculate final dispatch with optimal lambda\n        lam = (lam_low + lam_high) / 2\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_low = unit['b_i'] + 2 * unit['c_i'] * min_outputs[i]\n            marginal_high = unit['b_i'] + 2 * unit['c_i'] * max_outputs[i]\n            if lam < marginal_low:\n                p_i = min_outputs[i]\n            elif lam > marginal_high:\n                p_i = max_outputs[i]\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(min_outputs[i], min(p_i, max_outputs[i]))\n            p[i] = p_i\n        \n        total_output = np.sum(p)\n        residual = load_current - total_output\n        \n        # Residual load adjustment\n        if residual > 1e-6:  # Under generation\n            candidates = [i for i in committed_indices if p[i] < max_outputs[i] - 1e-6]\n            candidates.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n            for i in candidates:\n                avail = max_outputs[i] - p[i]\n                to_add = min(avail, residual)\n                p[i] += to_add\n                residual -= to_add\n                if residual <= 1e-6:\n                    break\n        elif residual < -1e-6:  # Over generation\n            residual = abs(residual)\n            candidates = [i for i in committed_indices if p[i] > min_outputs[i] + 1e-6]\n            candidates.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n            for i in candidates:\n                avail = p[i] - min_outputs[i]\n                to_remove = min(avail, residual)\n                p[i] -= to_remove\n                residual -= to_remove\n                if residual <= 1e-6:\n                    break\n    \n    # Format output\n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0049947365,
          "gap_price_rate": 0.0092619258,
          "fitness": 0.0071283312
     },
     {
          "name": "hybrid_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or violation of shutdown ramp constraint) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state\n3. Calculate feasible power ranges for committed units considering ramp constraints and startup/shutdown limits\n4. Adjust commitment based on system adequacy:\n   - Under-committed: activate flexible units sorted by lowest (startup cost + min-power cost)/min-power\n   - Over-committed: decommit non-must-on units sorted by highest min-power operating cost\n   - Adequate: decommit non-must-on units sorted by highest min-power cost if system remains adequate\n5. Perform constrained economic dispatch using lambda iteration for committed units:\n   - Solve optimal dispatch via bisection on system lambda\n   - Adjust any residual load using greedy merit-order based on marginal costs\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    min_bound = [0.0] * n\n    max_bound = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    current_load = load[0]\n    \n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u_arr[i] = 1\n        elif must_off[i]:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n\n    # Step 3: Calculate feasible power ranges for committed units\n    for i, unit in enumerate(units_info):\n        if u_arr[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n\n    # Step 4: Adjust commitment based on system adequacy\n    total_min = sum(min_bound[i] for i in range(n) if u_arr[i] == 1)\n    total_max = sum(max_bound[i] for i in range(n) if u_arr[i] == 1)\n    \n    # Case A: Under-committed\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if not must_on[i] and not must_off[i] and u_arr[i] == 0]\n        metrics = []\n        for i in flexible_off:\n            unit = units_info[i]\n            startup_cost = unit['s_i']\n            min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            metric = (startup_cost + min_cost) / unit['p_min_i']\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for metric, i in metrics:\n            if total_max >= current_load:\n                break\n            u_arr[i] = 1\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Case B: Over-committed\n    if total_min > current_load:\n        non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n        costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n            costs.append((cost, i))\n        costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in costs:\n            if total_min <= current_load:\n                break\n            u_arr[i] = 0\n            total_min -= min_bound[i]\n            total_max -= max_bound[i]\n            min_bound[i] = 0\n            max_bound[i] = 0\n    \n    # Case C: Adequate - decommit expensive non-must-on units\n    non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n    costs = []\n    for i in non_must_on:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n        costs.append((cost, i))\n    costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in costs:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load <= new_max:\n            u_arr[i] = 0\n            total_min = new_min\n            total_max = new_max\n            min_bound[i] = 0\n            max_bound[i] = 0\n\n    # Step 5: Economic dispatch for committed units\n    committed_indices = [i for i in range(n) if u_arr[i] == 1]\n    l_dispatch = [min_bound[i] for i in committed_indices]\n    u_dispatch = [max_bound[i] for i in committed_indices]\n    b_dispatch = [units_info[i]['b_i'] for i in committed_indices]\n    c_dispatch = [units_info[i]['c_i'] for i in committed_indices]\n    p_dispatch = l_dispatch[:] if committed_indices else []\n    residual = current_load - sum(p_dispatch)\n    \n    # Lambda iteration for dispatch\n    if committed_indices:\n        tol = 0.001\n        max_iter = 1000\n        low_lambda = float('inf')\n        high_lambda = float('-inf')\n        \n        for i in range(len(committed_indices)):\n            mc_low = b_dispatch[i] + 2 * c_dispatch[i] * l_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            mc_high = b_dispatch[i] + 2 * c_dispatch[i] * u_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            if mc_low < low_lambda:\n                low_lambda = mc_low\n            if mc_high > high_lambda:\n                high_lambda = mc_high\n        \n        lambda_low = min(low_lambda - 1.0, 0)\n        lambda_high = high_lambda + 1.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in range(len(committed_indices)):\n                if c_dispatch[i] == 0:\n                    if lambda_mid < b_dispatch[i]:\n                        p_dispatch[i] = l_dispatch[i]\n                    elif lambda_mid > b_dispatch[i]:\n                        p_dispatch[i] = u_dispatch[i]\n                    else:\n                        p_dispatch[i] = l_dispatch[i]\n                else:\n                    p = (lambda_mid - b_dispatch[i]) / (2.0 * c_dispatch[i])\n                    p_dispatch[i] = min(u_dispatch[i], max(l_dispatch[i], p))\n                total_gen += p_dispatch[i]\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > tol:\n            # Residual >0: distribute to units with cheapest marginal cost\n            if residual > 0:\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] < u_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    min_mc = min(mc_list, key=lambda x: x[0])\n                    i = min_mc[1]\n                    add = min(residual, u_dispatch[i] - p_dispatch[i])\n                    p_dispatch[i] += add\n                    residual -= add\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] < u_dispatch[j]]\n            # Residual <0: reduce from units with highest marginal cost\n            else:\n                residual = abs(residual)\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] > l_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    max_mc = max(mc_list, key=lambda x: x[0])\n                    i = max_mc[1]\n                    reduce_by = min(residual, p_dispatch[i] - l_dispatch[i])\n                    p_dispatch[i] -= reduce_by\n                    residual -= reduce_by\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] > l_dispatch[j]]\n        \n        # Assign dispatched power to output array\n        for idx, p_val in zip(committed_indices, p_dispatch):\n            p_arr[idx] = p_val\n    \n    # Build return array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_arr[i]\n        schedules[1, i] = p_arr[i]\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049948693,
          "gap_price_rate": 0.0092619027,
          "fitness": 0.007128386
     }
]