[
     {
          "name": "solve_ruc",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown capacity) and must-off units (offline with insufficient min-down time)  \n2. Initialize commitment states: must-on units committed (1), must-off units decommitted (0), others retain previous state  \n3. Compute feasible power ranges for committed units considering ramp rates, startup, and shutdown constraints  \n4. Adjust commitment iteratively:  \n   a. Under-committed (total max < load): Activate available units by best metric (startup cost + min-power cost)/min-power  \n   b. Over-committed (total min > load): Decommit non-must-on units by highest min-power cost until feasible  \n   c. Adequate: Decommission non-must-on units by highest min-power cost only if both current and forecasted loads remain within feasible ranges post-decommission  \n5. Perform economic dispatch using lambda iteration with bisection on marginal costs within constrained power ranges  \n6. Adjust residual load via greedy approach using marginal cost-based prioritization  \n7. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np\n\ndef solve_ruc(units_info, load):\n    units = units_info\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n    \n    # Step 2: Initialize commitment states\n    committed_units = []\n    for unit in units:\n        if unit in must_on:\n            unit['u_i'] = 1\n            committed_units.append(unit)\n        elif unit in must_off:\n            unit['u_i'] = 0\n        else:\n            unit['u_i'] = unit['u_i_0']\n            if unit['u_i_0'] == 1:\n                committed_units.append(unit)\n    \n    # Step 3: Compute feasible power ranges\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            unit['feas_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['feas_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['feas_min'] = unit['p_min_i']\n            unit['feas_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Adjust commitment\n    # Calculate current total min/max\n    total_min = sum(unit['feas_min'] for unit in committed_units)\n    total_max = sum(unit['feas_max'] for unit in committed_units)\n    \n    # Under-committed case\n    if total_max < current_load:\n        available = [u for u in units if u['u_i'] == 0 and u not in must_off and u not in must_on]\n        metrics = []\n        for unit in available:\n            min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n            metrics.append((min_cost + unit['s_i']) / unit['p_min_i'])\n        sorted_avail = [u for _, u in sorted(zip(metrics, available), key=lambda x: x[0])]\n        \n        for unit in sorted_avail:\n            if total_max >= current_load:\n                break\n            unit['u_i'] = 1\n            unit['feas_min'] = unit['p_min_i']\n            unit['feas_max'] = min(unit['p_max_i'], unit['p_start_i'])\n            committed_units.append(unit)\n            total_min += unit['feas_min']\n            total_max += unit['feas_max']\n    \n    # Over-committed case\n    elif total_min > current_load:\n        non_must_on = [u for u in committed_units if u not in must_on]\n        min_costs = []\n        for unit in non_must_on:\n            min_cost = unit['a_i'] + unit['b_i']*unit['feas_min'] + unit['c_i']*(unit['feas_min']**2)\n            min_costs.append(min_cost)\n        sorted_non_must = [u for _, u in sorted(zip(min_costs, non_must_on), reverse=True)]\n        \n        for unit in sorted_non_must:\n            if total_min <= current_load:\n                break\n            unit['u_i'] = 0\n            committed_units.remove(unit)\n            total_min -= unit['feas_min']\n            total_max -= unit['feas_max']\n    \n    # Adequate case\n    else:\n        non_must_on = [u for u in committed_units if u not in must_on]\n        min_costs = []\n        for unit in non_must_on:\n            min_cost = unit['a_i'] + unit['b_i']*unit['feas_min'] + unit['c_i']*(unit['feas_min']**2)\n            min_costs.append(min_cost)\n        sorted_non_must = [u for _, u in sorted(zip(min_costs, non_must_on), reverse=True)]\n        \n        for unit in sorted_non_must:\n            new_total_min = total_min - unit['feas_min']\n            new_total_max = total_max - unit['feas_max']\n            if new_total_min <= current_load <= new_total_max and new_total_min <= next_load <= new_total_max:\n                unit['u_i'] = 0\n                committed_units.remove(unit)\n                total_min = new_total_min\n                total_max = new_total_max\n    \n    # Update committed units if changes occurred\n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    # Step 5: Economic dispatch using lambda iteration\n    if not committed_units:\n        schedules = np.zeros((2, len(units)))\n        for i, unit in enumerate(units):\n            schedules[0, i] = unit['u_i']\n            schedules[1, i] = 0.0\n        return schedules\n    \n    # Set initial lambda bounds\n    lambda_low = min(u['b_i'] + 2*u['c_i']*u['feas_min'] for u in committed_units)\n    lambda_high = max(u['b_i'] + 2*u['c_i']*u['feas_max'] for u in committed_units)\n    \n    # Lambda iteration with bisection\n    max_iter = 1000\n    tol = 0.01\n    n_units = len(committed_units)\n    p_outputs = [u['feas_min'] for u in committed_units]\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        total_p = 0.0\n        for idx, unit in enumerate(committed_units):\n            p_val = (lambda_mid - unit['b_i']) / (2.0 * unit['c_i'])\n            p_clamped = max(unit['feas_min'], min(unit['feas_max'], p_val))\n            p_outputs[idx] = p_clamped\n            total_p += p_clamped\n        \n        if abs(total_p - current_load) < tol:\n            break\n        elif total_p < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Handle residual load using greedy adjustment\n    residual = current_load - sum(p_outputs)\n    while abs(residual) > tol:\n        if residual > 0:\n            marginals = []\n            for idx, unit in enumerate(committed_units):\n                if p_outputs[idx] < unit['feas_max']:\n                    mc = unit['b_i'] + 2*unit['c_i']*p_outputs[idx]\n                    marginals.append((mc, idx))\n            if not marginals:\n                break\n            min_marginal = min(marginals, key=lambda x: x[0])\n            idx = min_marginal[1]\n            unit = committed_units[idx]\n            delta = min(residual, unit['feas_max'] - p_outputs[idx])\n            p_outputs[idx] += delta\n            residual -= delta\n        else:\n            marginals = []\n            for idx, unit in enumerate(committed_units):\n                if p_outputs[idx] > unit['feas_min']:\n                    mc = unit['b_i'] + 2*unit['c_i']*p_outputs[idx]\n                    marginals.append((mc, idx))\n            if not marginals:\n                break\n            max_marginal = max(marginals, key=lambda x: x[0])\n            idx = max_marginal[1]\n            unit = committed_units[idx]\n            delta = min(-residual, p_outputs[idx] - unit['feas_min'])\n            p_outputs[idx] -= delta\n            residual += delta\n    \n    # Assign final outputs\n    for idx, unit in enumerate(committed_units):\n        unit['p_i'] = p_outputs[idx]\n    for unit in units:\n        if unit not in committed_units:\n            unit['p_i'] = 0.0\n    \n    # Create output array\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0022701099,
          "gap_price_rate": 0.0083693391,
          "fitness": 0.0053197245
     },
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "refined_ramp_forecast_rolling",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown capacity) and must-off units (offline with insufficient min-down time)  \n2. Initialize commitment: set must-on units to online, must-off to offline, others retain previous state  \n3. Compute feasible power ranges considering ramp/startup/shutdown constraints  \n4. Adjust commitment:  \n   - Under-committed: activate offline units by lowest (startup cost + min-power cost)/min-power metric  \n   - Over-committed: decommit non-must-on units by highest min-power cost  \n   - Adequate: decommit non-must-on units by highest min-power cost only if system adequacy holds for current and next period  \n5. Perform economic dispatch:  \n   - Start at min feasible power for committed units  \n   - Distribute residual load via greedy incremental approach on smallest marginal cost  \n   - Strictly enforce ramp constraints during dispatch  \n6. Return commitment states and power outputs  \n\n",
          "code": "import numpy as np  \n\ndef refined_ramp_forecast_rolling(units_info, load):  \n    n = len(units_info)  \n    current_load = load[0]  \n    next_load = load[1]  \n    \n    # Initialize states  \n    u = np.zeros(n, dtype=int)  \n    p = np.zeros(n)  \n    min_feasible = np.zeros(n)  \n    max_feasible = np.zeros(n)  \n    must_on = []  \n    must_off = []  \n\n    # Identify must-on and must-off units  \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        \n        if u_i0 == 1:  # Previously online  \n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):  \n                must_on.append(i)  \n        else:  # Previously offline  \n            if -t_i0 < unit['t_off_min_i']:  \n                must_off.append(i)  \n\n    # Initial commitment  \n    for i in range(n):  \n        if i in must_on:  \n            u[i] = 1  \n        elif i in must_off:  \n            u[i] = 0  \n        else:  \n            u[i] = units_info[i]['u_i_0']  \n\n    # Calculate feasible power ranges  \n    for i, unit in enumerate(units_info):  \n        p_min = unit['p_min_i']  \n        p_max = unit['p_max_i']  \n        p_i0 = unit['p_i_0']  \n        u_i0 = unit['u_i_0']  \n        \n        if u[i] == 1:  # Currently committed  \n            if u_i0 == 1:  # Was online  \n                min_feasible[i] = max(p_min, p_i0 - unit['p_down_i'])  \n                max_feasible[i] = min(p_max, p_i0 + unit['p_up_i'])  \n            else:  # Was offline, now turning on  \n                min_feasible[i] = p_min  \n                max_feasible[i] = min(p_max, unit['p_start_i'], unit['p_up_i'])  \n        else:  # Currently decommitted  \n            min_feasible[i] = 0  \n            max_feasible[i] = 0  \n\n    # Compute current total min/max generation  \n    total_min = sum(min_feasible)  \n    total_max = sum(max_feasible)  \n\n    # Adjust commitment states  \n    flexible = [i for i in range(n) if i not in must_on and i not in must_off]  \n    online_flex = [i for i in flexible if u[i] == 1]  \n    offline_flex = [i for i in flexible if u[i] == 0]  \n    \n    # Case 1: Under-committed  \n    if total_max < current_load:  \n        # Calculate activation metrics  \n        metrics = []  \n        for i in offline_flex:  \n            min_p = units_info[i]['p_min_i']  \n            cost = units_info[i]['a_i'] + units_info[i]['b_i']*min_p + units_info[i]['c_i']*min_p**2  \n            metrics.append((i, (units_info[i]['s_i'] + cost) / min_p))  \n        metrics.sort(key=lambda x: x[1])  \n        \n        # Activate units by best metric  \n        for idx, _ in metrics:  \n            if total_max >= current_load:  \n                break  \n            u[idx] = 1  \n            min_feasible[idx] = units_info[idx]['p_min_i']  \n            max_feasible[idx] = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'], units_info[idx]['p_up_i'])  \n            total_min += min_feasible[idx]  \n            total_max += max_feasible[idx]  \n\n    # Case 2: Over-committed  \n    elif total_min > current_load:  \n        # Calculate min-power operating costs  \n        costs = []  \n        for i in online_flex:  \n            min_p = min_feasible[i]  \n            costs.append((i, units_info[i]['a_i'] + units_info[i]['b_i']*min_p + units_info[i]['c_i']*min_p**2))  \n        costs.sort(key=lambda x: x[1], reverse=True)  \n        \n        # Decommit units by highest cost  \n        for idx, _ in costs:  \n            if total_min <= current_load:  \n                break  \n            u[idx] = 0  \n            total_min -= min_feasible[idx]  \n            total_max -= max_feasible[idx]  \n            min_feasible[idx] = max_feasible[idx] = 0  \n\n    # Case 3: Adequate  \n    else:  \n        # Calculate min-power operating costs  \n        costs = []  \n        for i in online_flex:  \n            min_p = min_feasible[i]  \n            costs.append((i, units_info[i]['a_i'] + units_info[i]['b_i']*min_p + units_info[i]['c_i']*min_p**2))  \n        costs.sort(key=lambda x: x[1], reverse=True)  \n        \n        # Decommit units if adequate for current AND next period  \n        for idx, _ in costs:  \n            new_total_min = total_min - min_feasible[idx]  \n            new_total_max = total_max - max_feasible[idx]  \n            if new_total_min <= current_load and new_total_max >= next_load:  \n                u[idx] = 0  \n                total_min = new_total_min  \n                total_max = new_total_max  \n                min_feasible[idx] = max_feasible[idx] = 0  \n\n    # Initialize power outputs at min feasible  \n    for i in range(n):  \n        p[i] = min_feasible[i] if u[i] == 1 else 0  \n    \n    # Distribute residual load  \n    residual = current_load - total_min  \n    while residual > 1e-6:  \n        best_unit = None  \n        best_mc = float('inf')  \n        \n        # Find unit with minimum marginal cost  \n        for i in range(n):  \n            if u[i] == 1 and p[i] < max_feasible[i] - 1e-6:  \n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]  \n                if marginal_cost < best_mc:  \n                    best_mc = marginal_cost  \n                    best_unit = i  \n        \n        if best_unit is None:  \n            break  \n        \n        # Calculate max increase respecting ramp constraints  \n        headroom = min(  \n            residual,  \n            max_feasible[best_unit] - p[best_unit]  \n        )  \n        p[best_unit] += headroom  \n        residual -= headroom  \n\n    return np.array([u, p])  ",
          "from": "crossover",
          "gap_power_rate": 0.0032036377,
          "gap_price_rate": 0.0090109442,
          "fitness": 0.006107291
     },
     {
          "name": "rolling_commitment",
          "algorithm": "**  \n1. **Identify must-on/must-off units:** Must-on units are currently online and violate minimum up-time or shutdown ramp constraints; must-off units are offline and violate minimum down-time.  \n2. **Initialize commitment:** Set must-on units to committed (1), must-off units to decommitted (0), and flexible units to their previous state.  \n3. **Compute feasible power ranges:** For committed units, account for min/max power, ramp rates, and startup/shutdown constraints.  \n4. **Adjust commitment:**  \n   - **Over-committed (total min > load):** Decommit non-must-on units with the highest operating cost at minimum output until feasible.  \n   - **Under-committed (total max < load):** Commit available offline units with the best cost-effectiveness metric (startup cost + min-power cost)/min-power.  \n   - **Adequate (load within [total min, total max]):** Decommit expensive non-must-on units if adequacy persists.  \n5. **Lambda economic dispatch:** For committed units, minimize production costs using lambda iteration with bisection for optimal load distribution.  \n6. **Greedy residual adjustment:** Address small load deviations by adjusting outputs of units with the lowest/highest marginal costs.  \n7. **Output schedules:** Return commitment states and power outputs.  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u = [0] * n\n    p_output = [0.0] * n\n    min_power = [0.0] * n\n    max_power = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        elif t_i0 < 0 and -t_i0 < unit['t_off_min_i']:\n            must_off[i] = True\n    \n    # Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Set feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_power[i] = unit['p_min_i']\n                max_power[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            else:\n                min_power[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_power[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_power[i], max_power[i] = 0.0, 0.0\n    \n    total_min = sum(min_power)\n    total_max = sum(max_power)\n    \n    # Adjust commitment\n    candidate_off = []\n    for i in range(n):\n        if u[i] == 1 and not must_on[i]:\n            if units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                candidate_off.append(i)\n    \n    candidate_on = [i for i in range(n) if u[i] == 0 and not must_off[i]]\n    \n    # Over-committed\n    while total_min > current_load and candidate_off:\n        cost_list = []\n        for i in candidate_off:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_power[i] + unit['c_i'] * min_power[i]**2\n            cost_list.append((i, cost))\n        cost_list.sort(key=lambda x: x[1], reverse=True)\n        idx = cost_list[0][0]\n        u[idx] = 0\n        candidate_off.remove(idx)\n        total_min -= min_power[idx]\n        total_max -= max_power[idx]\n        min_power[idx], max_power[idx] = 0.0, 0.0\n    \n    # Under-committed\n    while total_max < current_load and candidate_on:\n        metric_list = []\n        for i in candidate_on:\n            unit = units_info[i]\n            op_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            metric = (unit['s_i'] + op_cost) / unit['p_min_i']\n            metric_list.append((i, metric))\n        metric_list.sort(key=lambda x: x[1])\n        idx = metric_list[0][0]\n        u[idx] = 1\n        candidate_on.remove(idx)\n        min_val = units_info[idx]['p_min_i']\n        max_val = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'], units_info[idx]['p_up_i'])\n        min_power[idx], max_power[idx] = min_val, max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Adequate: Decommission expensive non-must-on units\n    candidate_off_adequate = []\n    for i in range(n):\n        if u[i] == 1 and not must_on[i]:\n            if units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                candidate_off_adequate.append(i)\n    cost_list_adequate = []\n    for i in candidate_off_adequate:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_power[i] + unit['c_i'] * min_power[i]**2\n        cost_list_adequate.append((i, cost))\n    cost_list_adequate.sort(key=lambda x: x[1], reverse=True)\n    for i, _ in cost_list_adequate:\n        new_min = total_min - min_power[i]\n        new_max = total_max - max_power[i]\n        if new_min <= current_load and new_max >= current_load:\n            u[i] = 0\n            total_min, total_max = new_min, new_max\n            min_power[i], max_power[i] = 0.0, 0.0\n    \n    # Dispatch using lambda iteration\n    committed_indices = [i for i in range(n) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p_output])\n    \n    b_list = []; c_list = []; min_list = []; max_list = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b_list.append(unit['b_i'])\n        c_list.append(unit['c_i'])\n        min_list.append(min_power[i])\n        max_list.append(max_power[i])\n    \n    # Lambda iteration setup\n    low = min(b + 2*c*min_val for (b,c,min_val) in zip(b_list, c_list, min_list))\n    high = max(b + 2*c*max_val for (b,c,max_val) in zip(b_list, c_list, max_list))\n    tol_lambda = 1e-5\n    max_iter = 1000\n    p_temp = [0.0] * len(committed_indices)\n    total_power = 0.0\n    \n    # Bisection method for lambda\n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        total_power = 0.0\n        for idx, (b, c, min_val, max_val) in enumerate(zip(b_list, c_list, min_list, max_list)):\n            if c == 0:\n                p_i = min_val if mid < b else max_val\n            else:\n                p_star = (mid - b) / (2 * c)\n                p_i = max(min_val, min(max_val, p_star))\n            p_temp[idx] = p_i\n            total_power += p_i\n        \n        diff = total_power - current_load\n        if abs(diff) < tol_lambda:\n            break\n        low = mid if diff < 0 else low\n        high = mid if diff >= 0 else high\n    \n    # Assign dispatch results\n    for idx, i in enumerate(committed_indices):\n        p_output[i] = p_temp[idx]\n    \n    # Greedy residual adjustment\n    residual = current_load - sum(p_output)\n    if abs(residual) > 1e-5:\n        committed_units = [(i, p_output[i], units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i]) \n                          for i in committed_indices]\n        if residual > 0:\n            candidates = [(i, mc, max_power[i] - p_output[i]) \n                          for i, p, mc in committed_units if p_output[i] < max_power[i]]\n            if candidates:\n                i, _, headroom = min(candidates, key=lambda x: x[1])\n                inc = min(residual, headroom)\n                p_output[i] += inc\n        else:\n            candidates = [(i, mc, p_output[i] - min_power[i])\n                          for i, p, mc in committed_units if p_output[i] > min_power[i]]\n            if candidates:\n                i, _, headroom = max(candidates, key=lambda x: x[1])\n                dec = min(-residual, headroom)\n                p_output[i] -= dec\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0051590988,
          "gap_price_rate": 0.0085132484,
          "fitness": 0.0068361736
     },
     {
          "name": "hybrid_refined_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef hybrid_refined_rolling_commitment(units_info, load):\n    n = len(units_info)\n    load_current = load[0]  # current load to be allocated\n    \n    must_on = []    # indices of units that must remain on\n    must_off = []   # indices of units that must remain off\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:  # was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    u_i = [0] * n\n    for i in must_on:\n        u_i[i] = 1\n    for i in must_off:\n        u_i[i] = 0\n    for i in range(n):\n        if i not in must_on and i not in must_off:\n            u_i[i] = units_info[i]['u_i_0']  # previous state\n    \n    # Compute feasible power ranges for committed units\n    current_p_min = [0] * n\n    current_p_max = [0] * n\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 0:  # just started\n                current_p_min[i] = unit['p_min_i']\n                current_p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # was online\n                current_p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                current_p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            current_p_min[i] = 0\n            current_p_max[i] = 0\n    \n    total_min = sum(current_p_min)\n    total_max = sum(current_p_max)\n    \n    # Adjustment for under-committed system\n    if total_max < load_current:\n        candidate_off = []\n        for i in range(n):\n            if u_i[i] == 0 and i not in must_off:  # offline & not must-off\n                candidate_off.append(i)\n        \n        metrics = []\n        for i in candidate_off:\n            cost_min = units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + units_info[i]['c_i'] * (units_info[i]['p_min_i']**2)\n            metric_val = (units_info[i]['s_i'] + cost_min) / units_info[i]['p_min_i']\n            metrics.append(metric_val)\n        \n        sorted_indices = np.argsort(metrics)\n        candidate_off_sorted = [candidate_off[idx] for idx in sorted_indices]\n        \n        for i in candidate_off_sorted:\n            if total_max >= load_current:\n                break\n            u_i[i] = 1\n            if units_info[i]['u_i_0'] == 0:  # just started\n                p_min_val = units_info[i]['p_min_i']\n                p_max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            else:  # was on\n                p_min_val = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                p_max_val = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            current_p_min[i] = p_min_val\n            current_p_max[i] = p_max_val\n            total_min += p_min_val\n            total_max += p_max_val\n            \n            if total_min > load_current:\n                candidate_non_must_on = [j for j in range(n) if u_i[j] == 1 and j not in must_on]\n                cost_list = []\n                for j in candidate_non_must_on:\n                    cost_val = units_info[j]['a_i'] + units_info[j]['b_i'] * current_p_min[j] + units_info[j]['c_i'] * (current_p_min[j]**2)\n                    cost_list.append((cost_val, j))\n                candidate_non_must_on_sorted = [j for _, j in sorted(cost_list, reverse=True, key=lambda x: x[0])]\n                \n                for j in candidate_non_must_on_sorted:\n                    if total_min <= load_current:\n                        break\n                    u_i[j] = 0\n                    total_min -= current_p_min[j]\n                    total_max -= current_p_max[j]\n                    current_p_min[j] = 0\n                    current_p_max[j] = 0\n    \n    # Adjustment for over-committed system\n    if total_min > load_current:\n        candidate_non_must_on = [i for i in range(n) if u_i[i] == 1 and i not in must_on]\n        cost_list = []\n        for i in candidate_non_must_on:\n            cost_val = units_info[i]['a_i'] + units_info[i]['b_i'] * current_p_min[i] + units_info[i]['c_i'] * (current_p_min[i]**2)\n            cost_list.append((cost_val, i))\n        candidate_non_must_on_sorted = [i for _, i in sorted(cost_list, reverse=True, key=lambda x: x[0])]\n        \n        for i in candidate_non_must_on_sorted:\n            if total_min <= load_current:\n                break\n            u_i[i] = 0\n            total_min -= current_p_min[i]\n            total_max -= current_p_max[i]\n            current_p_min[i] = 0\n            current_p_max[i] = 0\n    \n    # Deactivate expensive non-essential units in adequate system\n    candidate_non_must_on = [i for i in range(n) if u_i[i] == 1 and i not in must_on]\n    if candidate_non_must_on:\n        cost_list = []\n        for i in candidate_non_must_on:\n            cost_val = units_info[i]['a_i'] + units_info[i]['b_i'] * current_p_min[i] + units_info[i]['c_i'] * (current_p_min[i]**2)\n            cost_list.append((cost_val, i))\n        candidate_non_must_on_sorted = [i for _, i in sorted(cost_list, reverse=True, key=lambda x: x[0])]\n        \n        removal_list = []\n        for i in candidate_non_must_on_sorted:\n            new_min = total_min - current_p_min[i]\n            new_max = total_max - current_p_max[i]\n            if new_min <= load_current <= new_max:\n                removal_list.append(i)\n                total_min = new_min\n                total_max = new_max\n            if total_min > total_max:\n                break\n        for i in removal_list:\n            u_i[i] = 0\n            current_p_min[i] = 0\n            current_p_max[i] = 0\n    \n    # Initialize power outputs to minimum feasible values\n    p_i = [0] * n\n    for i in range(n):\n        if u_i[i] == 1:\n            p_i[i] = current_p_min[i]\n    \n    residual = load_current - sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5:  # tolerance\n        candidate_units = [i for i in range(n) if u_i[i] == 1 and p_i[i] < current_p_max[i] - 1e-5]\n        if not candidate_units:\n            break\n        \n        mc_list = []\n        for i in candidate_units:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n            mc_list.append(marginal_cost)\n        min_mc_idx = np.argmin(mc_list)\n        i_min = candidate_units[min_mc_idx]\n        max_inc = current_p_max[i_min] - p_i[i_min]\n        inc = min(residual, max_inc)\n        p_i[i_min] += inc\n        residual -= inc\n    \n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.0086286729,
          "fitness": 0.0068754583
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "enhanced_adaptive_with_forecast",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown ramp) and must-off units (offline with insufficient min-down time)  \n2. Initialize commitment: must-on units committed, must-off units decommitted, flexible units retain previous state  \n3. Compute feasible power ranges considering ramp/startup/shutdown constraints  \n4. Adjust commitment iteratively:  \n   - Under-committed: Activate units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: Decommit non-must-on units by highest min-power cost  \n   - Adequate: Decommit units only if savings exceed next-period startup risk (using forecast)  \n5. Perform economic dispatch using lambda iteration with bisection  \n6. Handle residual load with marginal cost-based greedy adjustment  \n7. Return final commitment states and power outputs  \n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_with_forecast(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    units = units_info\n    n_units = len(units)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    status_changed = np.zeros(n_units, dtype=bool)\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units):\n        t_i_0 = unit['t_i_0']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Was online\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Initialize commitment\n    for i, unit in enumerate(units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = unit['u_i_0']\n        status_changed[i] = (u[i] != unit['u_i_0'])\n    \n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units):\n        if u[i] == 1:  # Committed\n            if unit['u_i_0'] == 1:  # Was online\n                p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                p_min[i] = unit['p_min_i']\n                p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Decommitted\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    # Calculate current min/max capacities\n    total_min = sum(p_min[i] for i in range(n_units))\n    total_max = sum(p_max[i] for i in range(n_units))\n    \n    # Step 4: Adjust commitment\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    non_must_on = [i for i in committed_indices if i not in must_on]\n    \n    # Under-committed\n    while total_max < current_load:\n        candidates = []\n        for i, unit in enumerate(units):\n            if u[i] == 0 and i not in must_off:  # Offline and flexible\n                # Startup cost + min power cost\n                cost_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n                metric = (unit['s_i'] + cost_min) / unit['p_min_i']\n                candidates.append((metric, i))\n        \n        if not candidates:\n            break\n            \n        _, best_i = min(candidates)\n        u[best_i] = 1\n        status_changed[best_i] = True\n        \n        # Update power ranges for activated unit\n        unit = units[best_i]\n        p_min[best_i] = unit['p_min_i']\n        p_max[best_i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min[best_i]\n        total_max += p_max[best_i]\n    \n    # Over-committed\n    while total_min > current_load and non_must_on:\n        # Get costs at minimum power\n        cost_at_min = []\n        for i in non_must_on:\n            unit = units[i]\n            cost = unit['a_i'] + unit['b_i'] * p_min[i] + unit['c_i'] * p_min[i] ** 2\n            cost_at_min.append((cost, i))\n        \n        cost_at_min.sort(reverse=True)\n        _, worst_i = cost_at_min[0]\n        \n        # Update totals and commit status\n        total_min -= p_min[worst_i]\n        total_max -= p_max[worst_i]\n        u[worst_i] = 0\n        status_changed[worst_i] = (units[worst_i]['u_i_0'] == 1)\n        non_must_on.remove(worst_i)\n        p_min[worst_i] = p_max[worst_i] = 0\n    \n    # Adequate case with forecast awareness\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    non_must_on = [i for i in committed_indices if i not in must_on]\n    non_must_on_costs = []\n    \n    for i in non_must_on:\n        unit = units[i]\n        cost = unit['a_i'] + unit['b_i'] * p_min[i] + unit['c_i'] * p_min[i] ** 2\n        non_must_on_costs.append((cost, i))\n    \n    non_must_on_costs.sort(reverse=True)\n    \n    for cost, i in non_must_on_costs:\n        # Check system adequacy without unit i\n        new_min = total_min - p_min[i]\n        new_max = total_max - p_max[i]\n        \n        # Check if unit would be needed next period\n        cost_saving = cost\n        startup_penalty = units[i]['s_i']\n        need_next_period = (new_max < next_load)\n        \n        # Turn off if adequate and (no next-period need OR saving exceeds startup)\n        if new_min <= current_load <= new_max and (not need_next_period or cost_saving > startup_penalty):\n            u[i] = 0\n            status_changed[i] = (units[i]['u_i_0'] == 1)\n            total_min = new_min\n            total_max = new_max\n            p_min[i] = p_max[i] = 0\n    \n    # Step 5: Economic dispatch using Lambda iteration\n    committed_units = [i for i in range(n_units) if u[i] == 1]\n    \n    # Initialize all units at minimum power\n    for i in committed_units:\n        p[i] = p_min[i]\n    \n    # Residual load after min-power allocation\n    residual = current_load - sum(p[i] for i in committed_units)\n    \n    # Bisection parameters\n    tol = 0.01\n    lambda_low = 0\n    lambda_high = 10000\n    \n    # Lambda bisection\n    while abs(residual) > tol and lambda_high - lambda_low > tol:\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_output = 0\n        \n        # Calculate outputs for all units at current lambda\n        for i in committed_units:\n            unit = units[i]\n            if unit['c_i'] > 0:\n                p_desired = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            else:  # Linear cost function\n                p_desired = p_max[i] if lambda_mid >= unit['b_i'] else p_min[i]\n            \n            # Respect power limits\n            p_i = max(p_min[i], min(p_max[i], p_desired))\n            total_output += p_i\n        \n        # Update bisection bounds\n        if total_output < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        residual = current_load - total_output\n    \n    # Set power outputs\n    for i in committed_units:\n        unit = units[i]\n        if unit['c_i'] > 0:\n            p_desired = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        else:\n            p_desired = p_max[i] if lambda_mid >= unit['b_i'] else p_min[i]\n        p[i] = max(p_min[i], min(p_max[i], p_desired))\n    \n    # Step 6: Handle residual with greedy adjustment\n    residual = current_load - sum(p)\n    \n    while abs(residual) > tol:\n        adjustments = []\n        if residual > 0:  # Need more power\n            for i in committed_units:\n                if p[i] < p_max[i]:\n                    margin = p_max[i] - p[i]\n                    marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    adjustments.append((marginal_cost, margin, i))\n            adjustments.sort()\n        else:  # Need less power\n            for i in committed_units:\n                if p[i] > p_min[i]:\n                    margin = p[i] - p_min[i]\n                    marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    adjustments.append((marginal_cost, margin, i))\n            adjustments.sort(reverse=True)\n        \n        if not adjustments:\n            break\n        \n        # Find unit with maximum adjustable margin\n        _, max_adjust, best_i = adjustments[0]\n        adjustment = min(abs(residual), max_adjust)\n        if residual > 0:\n            p[best_i] += adjustment\n            residual -= adjustment\n        else:\n            p[best_i] -= adjustment\n            residual += adjustment\n    \n    # Final schedule\n    schedules = np.array([u.tolist(), p.tolist()])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0050012153,
          "gap_price_rate": 0.0092115206,
          "fitness": 0.0071063679
     },
     {
          "name": "lambda_priority_rolling_commitment",
          "algorithm": "1. Identify must-on units (currently online with insufficient min-up time or exceeding shutdown capacity) and must-off units (currently offline with insufficient min-down time)  \n2. Initialize commitment: set must-on to 1, must-off to 0, others retain previous state  \n3. Calculate feasible power ranges for committed units considering ramp/startup constraints  \n4. Adjust commitment iteratively:  \n   - For under-committed systems (insufficient max capacity), activate units by cost-effectiveness metric: (startup_cost + min_power_cost)/min_power  \n   - For over-committed systems (excess min capacity), deactivate non-must-on units by highest min_power_cost  \n   - For adequate systems, deactivate expensive non-must-on units while maintaining system adequacy  \n5. Perform constrained economic dispatch via lambda iteration with bisection  \n6. Resolve residual load with greedy adjustment based on marginal costs  \n7. Return final commitment states and power outputs  \n\n",
          "code": "import numpy as np\n\ndef lambda_priority_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_current = [0] * n_units\n    p_current = [0.0] * n_units\n    p_min_current = [0.0] * n_units\n    p_max_current = [0.0] * n_units\n\n    # Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i, unit in enumerate(units_info):\n        if i in must_on:\n            u_current[i] = 1\n        elif i in must_off:\n            u_current[i] = 0\n        else:\n            u_current[i] = unit['u_i_0']\n            \n        if u_current[i] == 1:\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            u_i0 = unit['u_i_0']\n            p_i0 = unit['p_i_0']\n            \n            if u_i0 == 1:\n                p_min_current[i] = max(p_min, p_i0 - unit['p_down_i'])\n                p_max_current[i] = min(p_max, p_i0 + unit['p_up_i'])\n            else:\n                p_min_current[i] = p_min\n                p_max_current[i] = min(p_max, unit['p_start_i'])\n        else:\n            p_min_current[i] = 0\n            p_max_current[i] = 0\n\n    # Compute total min/max capacity\n    total_min = sum(p_min_current)\n    total_max = sum(p_max_current)\n    \n    # Adjust under-committed state\n    if total_max < current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_current[i] == 0 and i not in must_off:\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_p = unit['p_min_i']\n                min_cost = a_i + b_i * min_p + c_i * min_p**2\n                metric = (s_i + min_cost) / min_p\n                candidates.append((metric, i))\n        \n        candidates.sort(key=lambda x: x[0])\n        for _, idx in candidates:\n            if total_max >= current_load:\n                break\n                \n            p_min_here = units_info[idx]['p_min_i']\n            p_max_here = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            \n            u_current[idx] = 1\n            p_min_current[idx] = p_min_here\n            p_max_current[idx] = p_max_here\n            total_min += p_min_here\n            total_max += p_max_here\n    \n    # Adjust over-committed state\n    if total_min > current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_current[i] == 1 and i not in must_on:\n                min_p = p_min_current[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_cost = a_i + b_i * min_p + c_i * min_p**2\n                candidates.append((min_cost, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, idx in candidates:\n            if total_min <= current_load:\n                break\n                \n            total_min -= p_min_current[idx]\n            total_max -= p_max_current[idx]\n            u_current[idx] = 0\n            p_min_current[idx] = 0\n            p_max_current[idx] = 0\n            p_current[idx] = 0\n    \n    # Deactivate expensive units in adequate state\n    if total_min <= current_load <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_current[i] == 1 and i not in must_on:\n                min_p = p_min_current[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                min_cost = a_i + b_i * min_p + c_i * min_p**2\n                candidates.append((min_cost, i, p_min_current[i], p_max_current[i]))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, p_min_here, p_max_here in candidates:\n            new_min = total_min - p_min_here\n            new_max = total_max - p_max_here\n            if new_min <= current_load <= new_max:\n                total_min = new_min\n                total_max = new_max\n                u_current[idx] = 0\n                p_min_current[idx] = 0\n                p_max_current[idx] = 0\n                p_current[idx] = 0\n    \n    # Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if u_current[i] == 1]\n    if committed_indices:\n        # Find lambda bounds\n        lambd_low = min(unit['b_i'] + 2*unit['c_i']*p_min_current[i] for i, unit in enumerate(units_info) if i in committed_indices)\n        lambd_high = max(unit['b_i'] + 2*unit['c_i']*p_max_current[i] for i, unit in enumerate(units_info) if i in committed_indices)\n        \n        # Bisection loop\n        for _ in range(100):\n            lambd_mid = (lambd_low + lambd_high) / 2\n            total_output = 0.0\n            for idx in committed_indices:\n                unit = units_info[idx]\n                if unit['c_i'] != 0:\n                    p_val = (lambd_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = p_max_current[idx] if lambd_mid > unit['b_i'] else p_min_current[idx]\n                \n                p_val = max(p_min_current[idx], min(p_max_current[idx], p_val))\n                p_current[idx] = p_val\n                total_output += p_val\n            \n            if abs(total_output - current_load) < 0.1:\n                break\n                \n            if total_output < current_load:\n                lambd_low = lambd_mid\n            else:\n                lambd_high = lambd_mid\n        \n        # Residual adjustment\n        residual = current_load - total_output\n        if residual > 0:\n            candidates = []\n            for idx in committed_indices:\n                if p_current[idx] < p_max_current[idx]:\n                    marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_current[idx]\n                    candidates.append((marginal_cost, idx))\n            candidates.sort(key=lambda x: x[0])\n            for mc, idx in candidates:\n                avail = p_max_current[idx] - p_current[idx]\n                if avail > residual:\n                    p_current[idx] += residual\n                    residual = 0\n                else:\n                    p_current[idx] += avail\n                    residual -= avail\n                if residual <= 1e-3:\n                    break\n        elif residual < 0:\n            residual = abs(residual)\n            candidates = []\n            for idx in committed_indices:\n                if p_current[idx] > p_min_current[idx]:\n                    marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_current[idx]\n                    candidates.append((-marginal_cost, idx))\n            candidates.sort(key=lambda x: x[0])\n            for _, idx in candidates:\n                avail = p_current[idx] - p_min_current[idx]\n                if avail > residual:\n                    p_current[idx] -= residual\n                    residual = 0\n                else:\n                    p_current[idx] -= avail\n                    residual -= avail\n                if residual <= 1e-3:\n                    break\n\n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_current[i] == 0:\n            p_current[i] = 0.0\n\n    return np.array([u_current, p_current], dtype=np.float64)",
          "from": "crossover",
          "gap_power_rate": 0.0049946815,
          "gap_price_rate": 0.009261831,
          "fitness": 0.0071282563
     },
     {
          "name": "hybrid_lambda_enhanced_commitment",
          "algorithm": "1. Identify must-on units (insufficient min-up time or previous output exceeding shutdown ramp) and must-off units (insufficient min-down time). 2. Initialize commitment: set must-on units to 1, must-off units to 0, others retain previous state. 3. For committed units, compute current feasible power ranges considering ramp/startup constraints. 4. Adjust commitment iteratively: a) Under-committed: activate units by lowest (startup cost + min-power cost)/min-power metric b) Over-committed: decommit units by highest min-power cost c) Adequate: decommission expensive non-must-on units while maintaining adequacy. 5. Perform economic dispatch via lambda iteration within feasible ranges. 6. Resolve residual load with constrained greedy adjustment. 7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef hybrid_lambda_enhanced_commitment(units_info, load):\n    # Extract current load\n    load_current = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    p_min_current = np.zeros(n_units)\n    p_max_current = np.zeros(n_units)\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        # Must-on conditions\n        if (unit['u_i_0'] == 1) and ((unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif (unit['u_i_0'] == 0) and (unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(i)\n    \n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u_arr[i] = 1\n        elif i in must_off:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n    \n    # Step 3: Compute feasible power ranges for committed units\n    def calc_feasible_ranges():\n        for i, unit in enumerate(units_info):\n            if u_arr[i] == 1:\n                if unit['u_i_0'] == 1:  # Previously online\n                    p_min_current[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    p_max_current[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:  # Starting up\n                    p_min_current[i] = unit['p_min_i']\n                    p_max_current[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n        return p_min_current.copy(), p_max_current.copy()\n    \n    p_min_current, p_max_current = calc_feasible_ranges()\n    \n    # Step 4: Adjust commitment states\n    total_min = np.sum(p_min_current)\n    total_max = np.sum(p_max_current)\n    load_current = load[0]\n    \n    # Case a: Under-committed (total_max < load_current)\n    if total_max < load_current:\n        # Find candidate offline units (not must-off)\n        candidate_on = [i for i in range(n_units) if u_arr[i] == 0 and i not in must_off]\n        while total_max < load_current and candidate_on:\n            # Calculate cost-effectiveness metric\n            metrics = []\n            for i in candidate_on:\n                unit = units_info[i]\n                min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n                metric = (unit['s_i'] + min_cost) / unit['p_min_i']\n                metrics.append((metric, i))\n            \n            # Activate most cost-effective unit\n            metrics.sort(key=lambda x: x[0])\n            activate_idx = metrics[0][1]\n            u_arr[activate_idx] = 1\n            # Update feasible ranges\n            p_min_current[activate_idx] = units_info[activate_idx]['p_min_i']\n            p_max_current[activate_idx] = min(units_info[activate_idx]['p_max_i'], units_info[activate_idx]['p_start_i'])\n            # Recompute total min/max\n            total_min += p_min_current[activate_idx]\n            total_max += p_max_current[activate_idx]\n            # Remove activated unit from candidates\n            candidate_on.remove(activate_idx)\n    \n    # Case b: Over-committed (total_min > load_current)\n    if total_min > load_current:\n        # Find candidate units to turn off (non-must-on)\n        candidate_off = [i for i in range(n_units) if u_arr[i] == 1 and i not in must_on]\n        # Sort by highest min-power operating cost\n        candidate_off.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + units_info[i]['c_i']*units_info[i]['p_min_i']**2, \n                          reverse=True)\n        \n        for i in candidate_off:\n            if total_min <= load_current:\n                break\n            # Decommit unit\n            u_arr[i] = 0\n            p_min_current[i] = 0\n            p_max_current[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= units_info[i]['p_start_i'] if units_info[i]['u_i_0'] == 0 else units_info[i]['p_max_i']\n    \n    # Case c: Adequate system\n    if total_min <= load_current <= total_max:\n        # Find candidate non-must-on units to turn off\n        candidate_off = [i for i in range(n_units) if u_arr[i] == 1 and i not in must_on]\n        # Sort by highest min-power cost\n        candidate_off.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + units_info[i]['c_i']*units_info[i]['p_min_i']**2, \n                          reverse=True)\n        \n        for i in candidate_off:\n            new_total_max = total_max - p_max_current[i]\n            if new_total_max >= load_current:\n                # Decommit unit\n                u_arr[i] = 0\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n                total_min -= units_info[i]['p_min_i']\n                total_max = new_total_max\n    \n    # Recalculate feasible ranges after commitment adjustments\n    p_min_current, p_max_current = calc_feasible_ranges()\n    committed_indices = [i for i in range(n_units) if u_arr[i] == 1]\n    \n    # Step 5: Economic dispatch via lambda iteration\n    if committed_indices:\n        # Set initial output to min\n        for i in committed_indices:\n            p_arr[i] = p_min_current[i]\n        residual = load_current - np.sum(p_arr)\n        \n        # Lambda iteration setup\n        if abs(residual) > 1e-4:\n            b_vals = np.array([units_info[i]['b_i'] for i in committed_indices])\n            c_vals = np.array([units_info[i]['c_i'] for i in committed_indices])\n            p_mins = np.array([p_min_current[i] for i in committed_indices])\n            p_maxs = np.array([p_max_current[i] for i in committed_indices])\n            \n            # Bounds for lambda\n            low = np.min(2 * c_vals * p_mins + b_vals)\n            high = np.max(2 * c_vals * p_maxs + b_vals)\n            lambda_mid = (low + high) / 2\n            tolerance_lambda = 0.1  # MW tolerance\n            max_iter = 1000\n            \n            # Lambda iteration\n            for _ in range(max_iter):\n                p_dispatch = []\n                for idx, i in enumerate(committed_indices):\n                    if c_vals[idx] == 0:\n                        if lambda_mid < b_vals[idx]:\n                            p_dispatch.append(p_mins[idx])\n                        else:\n                            p_dispatch.append(p_maxs[idx])\n                    else:\n                        # Calculate unconstrained dispatch\n                        p_unc = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx])\n                        # Enforce constraints\n                        p_val = max(p_mins[idx], min(p_maxs[idx], p_unc))\n                        p_dispatch.append(p_val)\n                \n                total_gen = np.sum(p_dispatch)\n                gen_diff = total_gen - load_current\n                \n                if abs(gen_diff) < tolerance_lambda:\n                    for j, i in enumerate(committed_indices):\n                        p_arr[i] = p_dispatch[j]\n                    residual = load_current - total_gen\n                    break\n                \n                if gen_diff < 0:\n                    low = lambda_mid\n                else:\n                    high = lambda_mid\n                lambda_mid = (low + high) / 2\n            else:\n                # Fallback to greedy dispatch if not converged\n                p_dispatch = np.clip(p_dispatch, p_mins, p_maxs)\n                for j, i in enumerate(committed_indices):\n                    p_arr[i] = p_dispatch[j]\n                residual = load_current - np.sum(p_dispatch)\n            \n            # Step 6: Greedy residual adjustment\n            tolerance_greedy = 1e-4\n            if residual > tolerance_greedy:\n                # Increase generation from cheapest units\n                candidates = [i for i in committed_indices if p_arr[i] < p_max_current[i]]\n                if candidates:\n                    marginal_costs = [2 * units_info[i]['c_i'] * p_arr[i] + units_info[i]['b_i'] for i in candidates]\n                    sorted_indices = np.argsort(marginal_costs)\n                    \n                    for idx in sorted_indices:\n                        i = candidates[idx]\n                        increment = min(residual, p_max_current[i] - p_arr[i])\n                        p_arr[i] += increment\n                        residual -= increment\n                        if residual < tolerance_greedy:\n                            break\n            \n            elif residual < -tolerance_greedy:\n                # Decrease generation from most expensive units\n                candidates = [i for i in committed_indices if p_arr[i] > p_min_current[i]]\n                if candidates:\n                    marginal_costs = [2 * units_info[i]['c_i'] * p_arr[i] + units_info[i]['b_i'] for i in candidates]\n                    sorted_indices = np.argsort(marginal_costs)[::-1]\n                    \n                    for idx in sorted_indices:\n                        i = candidates[idx]\n                        decrement = min(-residual, p_arr[i] - p_min_current[i])\n                        p_arr[i] -= decrement\n                        residual += decrement\n                        if residual > -tolerance_greedy:\n                            break\n    \n    # Prepare output\n    schedules = np.vstack((u_arr, p_arr))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049947392,
          "gap_price_rate": 0.0092618964,
          "fitness": 0.0071283178
     }
]