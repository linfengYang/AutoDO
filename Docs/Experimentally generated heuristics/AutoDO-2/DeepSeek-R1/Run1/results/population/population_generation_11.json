[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)  \n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to their previous state  \n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints  \n4. Compute total min/max generation and adjust commitment:  \n   - Under-committed: activate flexible units by lowest (startup cost + min-power cost)/min-power  \n   - Over-committed: decommit non-must-on units by highest min-power cost until min-gen \u2264 load  \n   - Adequate: decommit non-must-on units by highest min-power cost if system adequacy holds  \n5. Perform constrained economic dispatch:  \n   - Set initial output to minimum feasible power for committed units  \n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)  \n6. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_rolling_commitment(units_info, load):  \n    # Extract current load  \n    load_current = load[0]  \n    n = len(units_info)  \n      \n    # Extract unit parameters  \n    a = [u['a_i'] for u in units_info]  \n    b = [u['b_i'] for u in units_info]  \n    c = [u['c_i'] for u in units_info]  \n    p_min = [u['p_min_i'] for u in units_info]  \n    p_max = [u['p_max_i'] for u in units_info]  \n    p_up = [u['p_up_i'] for u in units_info]  \n    p_down = [u['p_down_i'] for u in units_info]  \n    p_start = [u['p_start_i'] for u in units_info]  \n    p_shut = [u['p_shut_i'] for u in units_info]  \n    t_on_min = [u['t_on_min_i'] for u in units_info]  \n    t_off_min = [u['t_off_min_i'] for u in units_info]  \n    s = [u['s_i'] for u in units_info]  \n    u0 = [u['u_i_0'] for u in units_info]  \n    t0 = [u['t_i_0'] for u in units_info]  \n    p0 = [u['p_i_0'] for u in units_info]  \n      \n    # Step 1: Identify must-on and must-off units  \n    must_on = [False] * n  \n    must_off = [False] * n  \n    for i in range(n):  \n        if u0[i] == 1:  # If online in previous period  \n            time_on = max(t0[i], 0)  \n            if time_on < t_on_min[i] or p0[i] > p_shut[i]:  \n                must_on[i] = True  \n        else:  # If offline in previous period  \n            time_off = abs(min(t0[i], 0))  \n            if time_off < t_off_min[i]:  \n                must_off[i] = True  \n      \n    # Step 2: Initialize commitment  \n    committed = [False] * n  \n    L = [0.0] * n  # Min feasible output  \n    U = [0.0] * n  # Max feasible output  \n      \n    # Initialize must-on and must-off units  \n    for i in range(n):  \n        if must_on[i]:  \n            committed[i] = True  \n        elif must_off[i]:  \n            committed[i] = False  \n        else:  \n            committed[i] = u0[i]  # Flexible units retain previous state  \n      \n    # Step 3: Calculate initial feasible power ranges  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Starting in this period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n        else:  # Off in this period  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    # Calculate total min and max generation  \n    total_min = sum(L)  \n    total_max = sum(U)  \n      \n    # Step 4: Adjust commitment based on system adequacy  \n    candidate_on = []  \n    candidate_off = []  \n    for i in range(n):  \n        if not committed[i] and not must_off[i] and not must_on[i]:  \n            # Calculate average cost for candidate to start  \n            avg_cost = (s[i] + a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)) / p_min[i]  \n            candidate_on.append((i, avg_cost))  \n        if committed[i] and not must_on[i]:  \n            # Calculate cost at min power  \n            cost_at_min = a[i] + b[i]*p_min[i] + c[i]*(p_min[i]**2)  \n            candidate_off.append((i, cost_at_min))  \n      \n    candidate_on.sort(key=lambda x: x[1])  \n    candidate_off.sort(key=lambda x: x[1], reverse=True)  \n      \n    # 4.1 Under-committed: activate cheapest units  \n    if total_max < load_current and candidate_on:  \n        for i, avg_cost in candidate_on:  \n            if total_max >= load_current:  \n                break  \n            committed[i] = True  \n            L[i] = p_min[i]  \n            U[i] = min(p_max[i], p_start[i])  \n            total_min += p_min[i]  \n            total_max += min(p_max[i], p_start[i])  \n      \n    # 4.2 Over-committed: decommit expensive non-must-on units  \n    if total_min > load_current and candidate_off:  \n        changed = True  \n        while changed and candidate_off and total_min > load_current:  \n            changed = False  \n            for idx, (i, cost) in enumerate(candidate_off):  \n                new_total_min = total_min - L[i]  \n                new_total_max = total_max - U[i]  \n                if new_total_max >= load_current:  \n                    committed[i] = False  \n                    L[i] = 0.0  \n                    U[i] = 0.0  \n                    total_min = new_total_min  \n                    total_max = new_total_max  \n                    candidate_off.pop(idx)  \n                    changed = True  \n                    break  \n      \n    # 4.3 Adequate: decommit expensive non-essential units  \n    if total_min <= load_current <= total_max and candidate_off:  \n        for i, cost in candidate_off:  \n            if total_max - U[i] >= load_current:  \n                committed[i] = False  \n                L[i] = 0.0  \n                U[i] = 0.0  \n                total_min -= p_min[i]  \n                total_max -= min(p_max[i], p_start[i] if u0[i]==0 else p_max[i])  \n      \n    # Step 5: Economic dispatch  \n    p_dispatch = [0.0] * n  \n    total_gen = 0.0  \n      \n    # Recompute feasible ranges based on final commitment  \n    for i in range(n):  \n        if committed[i]:  \n            if u0[i] == 1:  # Continuously online  \n                L[i] = max(p_min[i], p0[i] - p_down[i])  \n                U[i] = min(p_max[i], p0[i] + p_up[i])  \n            else:  # Started in current period  \n                L[i] = p_min[i]  \n                U[i] = min(p_max[i], p_start[i])  \n            p_dispatch[i] = L[i]  \n            total_gen += L[i]  \n        else:  \n            p_dispatch[i] = 0.0  \n            L[i] = 0.0  \n            U[i] = 0.0  \n      \n    remaining = load_current - total_gen  \n    committed_idx = [i for i in range(n) if committed[i]]  \n      \n    # Distribute residual load  \n    while remaining > 1e-6 and committed_idx:  \n        best_i = None  \n        min_marginal = float('inf')  \n        for i in committed_idx:  \n            if p_dispatch[i] < U[i] - 1e-6:  # Headroom available  \n                marginal = b[i] + 2*c[i]*p_dispatch[i]  \n                if marginal < min_marginal:  \n                    min_marginal = marginal  \n                    best_i = i  \n                      \n        if best_i is None:  \n            break  \n              \n        headroom = U[best_i] - p_dispatch[best_i]  \n        increment = min(remaining, headroom)  \n        p_dispatch[best_i] += increment  \n        remaining -= increment  \n      \n    # Step 6: Prepare output  \n    schedules = np.zeros((2, n))  \n    for i in range(n):  \n        schedules[0, i] = 1 if p_dispatch[i] > 1e-6 else 0  \n        schedules[1, i] = p_dispatch[i]  \n          \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 0.0025476301,
          "gap_price_rate": 0.0091512208,
          "fitness": 0.0058494254
     },
     {
          "name": "rolling_commitment",
          "algorithm": "**  \n1. **Identify must-on/must-off units:** Must-on units are currently online and violate minimum up-time or shutdown ramp constraints; must-off units are offline and violate minimum down-time.  \n2. **Initialize commitment:** Set must-on units to committed (1), must-off units to decommitted (0), and flexible units to their previous state.  \n3. **Compute feasible power ranges:** For committed units, account for min/max power, ramp rates, and startup/shutdown constraints.  \n4. **Adjust commitment:**  \n   - **Over-committed (total min > load):** Decommit non-must-on units with the highest operating cost at minimum output until feasible.  \n   - **Under-committed (total max < load):** Commit available offline units with the best cost-effectiveness metric (startup cost + min-power cost)/min-power.  \n   - **Adequate (load within [total min, total max]):** Decommit expensive non-must-on units if adequacy persists.  \n5. **Lambda economic dispatch:** For committed units, minimize production costs using lambda iteration with bisection for optimal load distribution.  \n6. **Greedy residual adjustment:** Address small load deviations by adjusting outputs of units with the lowest/highest marginal costs.  \n7. **Output schedules:** Return commitment states and power outputs.  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u = [0] * n\n    p_output = [0.0] * n\n    min_power = [0.0] * n\n    max_power = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        elif t_i0 < 0 and -t_i0 < unit['t_off_min_i']:\n            must_off[i] = True\n    \n    # Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Set feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_power[i] = unit['p_min_i']\n                max_power[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            else:\n                min_power[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_power[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_power[i], max_power[i] = 0.0, 0.0\n    \n    total_min = sum(min_power)\n    total_max = sum(max_power)\n    \n    # Adjust commitment\n    candidate_off = []\n    for i in range(n):\n        if u[i] == 1 and not must_on[i]:\n            if units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                candidate_off.append(i)\n    \n    candidate_on = [i for i in range(n) if u[i] == 0 and not must_off[i]]\n    \n    # Over-committed\n    while total_min > current_load and candidate_off:\n        cost_list = []\n        for i in candidate_off:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_power[i] + unit['c_i'] * min_power[i]**2\n            cost_list.append((i, cost))\n        cost_list.sort(key=lambda x: x[1], reverse=True)\n        idx = cost_list[0][0]\n        u[idx] = 0\n        candidate_off.remove(idx)\n        total_min -= min_power[idx]\n        total_max -= max_power[idx]\n        min_power[idx], max_power[idx] = 0.0, 0.0\n    \n    # Under-committed\n    while total_max < current_load and candidate_on:\n        metric_list = []\n        for i in candidate_on:\n            unit = units_info[i]\n            op_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            metric = (unit['s_i'] + op_cost) / unit['p_min_i']\n            metric_list.append((i, metric))\n        metric_list.sort(key=lambda x: x[1])\n        idx = metric_list[0][0]\n        u[idx] = 1\n        candidate_on.remove(idx)\n        min_val = units_info[idx]['p_min_i']\n        max_val = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'], units_info[idx]['p_up_i'])\n        min_power[idx], max_power[idx] = min_val, max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Adequate: Decommission expensive non-must-on units\n    candidate_off_adequate = []\n    for i in range(n):\n        if u[i] == 1 and not must_on[i]:\n            if units_info[i]['u_i_0'] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:\n                candidate_off_adequate.append(i)\n    cost_list_adequate = []\n    for i in candidate_off_adequate:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_power[i] + unit['c_i'] * min_power[i]**2\n        cost_list_adequate.append((i, cost))\n    cost_list_adequate.sort(key=lambda x: x[1], reverse=True)\n    for i, _ in cost_list_adequate:\n        new_min = total_min - min_power[i]\n        new_max = total_max - max_power[i]\n        if new_min <= current_load and new_max >= current_load:\n            u[i] = 0\n            total_min, total_max = new_min, new_max\n            min_power[i], max_power[i] = 0.0, 0.0\n    \n    # Dispatch using lambda iteration\n    committed_indices = [i for i in range(n) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p_output])\n    \n    b_list = []; c_list = []; min_list = []; max_list = []\n    for i in committed_indices:\n        unit = units_info[i]\n        b_list.append(unit['b_i'])\n        c_list.append(unit['c_i'])\n        min_list.append(min_power[i])\n        max_list.append(max_power[i])\n    \n    # Lambda iteration setup\n    low = min(b + 2*c*min_val for (b,c,min_val) in zip(b_list, c_list, min_list))\n    high = max(b + 2*c*max_val for (b,c,max_val) in zip(b_list, c_list, max_list))\n    tol_lambda = 1e-5\n    max_iter = 1000\n    p_temp = [0.0] * len(committed_indices)\n    total_power = 0.0\n    \n    # Bisection method for lambda\n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        total_power = 0.0\n        for idx, (b, c, min_val, max_val) in enumerate(zip(b_list, c_list, min_list, max_list)):\n            if c == 0:\n                p_i = min_val if mid < b else max_val\n            else:\n                p_star = (mid - b) / (2 * c)\n                p_i = max(min_val, min(max_val, p_star))\n            p_temp[idx] = p_i\n            total_power += p_i\n        \n        diff = total_power - current_load\n        if abs(diff) < tol_lambda:\n            break\n        low = mid if diff < 0 else low\n        high = mid if diff >= 0 else high\n    \n    # Assign dispatch results\n    for idx, i in enumerate(committed_indices):\n        p_output[i] = p_temp[idx]\n    \n    # Greedy residual adjustment\n    residual = current_load - sum(p_output)\n    if abs(residual) > 1e-5:\n        committed_units = [(i, p_output[i], units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i]) \n                          for i in committed_indices]\n        if residual > 0:\n            candidates = [(i, mc, max_power[i] - p_output[i]) \n                          for i, p, mc in committed_units if p_output[i] < max_power[i]]\n            if candidates:\n                i, _, headroom = min(candidates, key=lambda x: x[1])\n                inc = min(residual, headroom)\n                p_output[i] += inc\n        else:\n            candidates = [(i, mc, p_output[i] - min_power[i])\n                          for i, p, mc in committed_units if p_output[i] > min_power[i]]\n            if candidates:\n                i, _, headroom = max(candidates, key=lambda x: x[1])\n                dec = min(-residual, headroom)\n                p_output[i] -= dec\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0051590988,
          "gap_price_rate": 0.0085132484,
          "fitness": 0.0068361736
     },
     {
          "name": "greedy_ramp_commit_dispatch",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output exceeding shutdown capacity) and must-off units (offline with insufficient min-down time)\n2. Initialize commitment state to must-on, must-off, or previous state for flexible units\n3. Compute feasible power ranges for committed units considering min/max outputs, ramps, and start/shutdown constraints\n4. Adjust commitment:\n   - Under-committed: Activate offline units by lowest (startup cost + min-power operating cost)/min-power metric\n   - Over-committed: Deactivate non-must-on units by highest min-power operating cost until feasible\n   - Adequate: Deactivate expensive non-must-on units if system adequacy holds\n5. Dispatch power:\n   - Set committed units to min power output\n   - Greedily allocate residual load to units with smallest marginal cost while respecting max output limits\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef greedy_ramp_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n                \n    u_i = [1 if i in must_on else (0 if i in must_off else unit['u_i_0']) \n           for i, unit in enumerate(units_info)]\n    \n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_p)\n    total_max = sum(max_p)\n    \n    # Under-committed: Activate units\n    if total_max < current_load:\n        available = [i for i in range(n_units) if u_i[i] == 0 and i not in must_off]\n        metrics = []\n        for i in available:\n            unit = units_info[i]\n            min_base = unit['p_min_i']\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i']*min_base + unit['c_i']*min_base**2\n            metric = cost / min_base\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for _, i in metrics:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            min_p[i] = unit_i = units_info[i]\n            min_base = unit_i['p_min_i']\n            max_start = min(unit_i['p_max_i'], unit_i['p_start_i'])\n            min_p[i] = min_base\n            max_p[i] = max_start\n            total_min += min_base\n            total_max += max_start\n    \n    # Over-committed: Deactivate units\n    if total_min > current_load:\n        non_must_on = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        op_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_p[i] + unit['c_i'] * min_p[i]**2\n            op_costs.append((cost, i))\n        op_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost_val, i in op_costs:\n            if total_min <= current_load:\n                break\n            u_i[i] = 0\n            total_min -= min_p[i]\n            total_max -= max_p[i]\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    # Adequate: Deactivate expensive units\n    if total_min <= current_load <= total_max:\n        non_must_on = [i for i in range(n_units) if u_i[i] == 1 and i not in must_on]\n        op_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_p[i] + unit['c_i'] * min_p[i]**2\n            op_costs.append((cost, i))\n        op_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost_val, i in op_costs:\n            new_total_min = total_min - min_p[i]\n            new_total_max = total_max - max_p[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p[i] = 0\n                max_p[i] = 0\n    \n    # Power dispatch\n    p_i = [min_p[i] if u_i[i] == 1 else 0.0 for i in range(n_units)]\n    residual = current_load - sum(p_i)\n    tol = 1e-6\n    \n    while residual > tol:\n        min_mc = float('inf')\n        candidate = -1\n        for i in range(n_units):\n            if u_i[i] == 1 and p_i[i] < max_p[i] - tol:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n        if candidate == -1:\n            break\n        add = min(residual, max_p[candidate] - p_i[candidate])\n        p_i[candidate] += add\n        residual -= add\n    \n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.0086286729,
          "fitness": 0.0068754583
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": "1. Identify must-on units (online and below min-up time or previous output > shutdown ramp) and must-off units (offline and below min-down time)\n2. Initialize commitment: must-on to committed, must-off to off, flexible units keep previous state\n3. Compute feasible power ranges for committed units considering ramp and startup/shutdown constraints\n4. Classify commitment case: under-committed (total max < load), over-committed (total min > load), or adequate\n5. Under-committed: Activate available units by lowest (startup cost + min-power cost)/min-power metric\n6. Over-committed: Decommit non-must-on units by highest min-power operating cost until min-gen \u2264 load\n7. Adequate: Decommit expensive non-must-on units if system adequacy holds\n8. Dispatch:\n   - Start at min-power for all committed units\n   - Distribute residual load to units with smallest marginal cost (b_i + 2c_i*p_i)\n   - Respect ramp constraints during dispatch\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    load_current = load[0]  # Current load to meet\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    min_p_i = [0.0] * n_units\n    max_p_i = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n\n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = units_info[i]['u_i_0']\n\n    # Step 3: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:  # Was online\n                min_p_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                min_p_i[i] = unit['p_min_i']\n                max_p_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p_i[i] = 0.0\n            max_p_i[i] = 0.0\n\n    total_min = sum(min_p_i)\n    total_max = sum(max_p_i)\n\n    # Step 4: Classify and adjust commitment\n    # Case 1: Under-committed\n    if total_max < load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 0 and not must_off[i]:\n                p_min = unit['p_min_i']\n                if p_min > 0:\n                    startup_metric = (unit['s_i'] + unit['a_i'] + \n                                     unit['b_i'] * p_min + \n                                     unit['c_i'] * p_min**2) / p_min\n                else:\n                    startup_metric = float('inf')\n                candidates.append((startup_metric, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx in candidates:\n            if total_max >= load_current:\n                break\n            u_i[idx] = 1\n            unit = units_info[idx]\n            min_p_i[idx] = unit['p_min_i']\n            max_p_i[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_p_i[idx]\n            total_max += max_p_i[idx]\n    \n    # Case 2: Over-committed\n    elif total_min > load_current:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_min <= load_current:\n                break\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 7: Optimize adequate commitment\n    if total_min <= load_current <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u_i[i] == 1 and not must_on[i]:\n                min_cost = (unit['a_i'] + unit['b_i'] * min_p_i[i] + \n                            unit['c_i'] * min_p_i[i]**2)\n                candidates.append((min_cost, i))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx in candidates:\n            if total_max - max_p_i[idx] < load_current:\n                continue\n            u_i[idx] = 0\n            total_min -= min_p_i[idx]\n            total_max -= max_p_i[idx]\n            min_p_i[idx] = 0.0\n            max_p_i[idx] = 0.0\n    \n    # Step 8: Economic dispatch\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    total_power = sum(min_p_i[i] for i in committed_indices)\n    residual = load_current - total_power\n    \n    # Assign initial output to min power\n    for i in committed_indices:\n        p_i[i] = min_p_i[i]\n    \n    # Distribute residual load\n    while residual > 1e-6:\n        min_mc = float('inf')\n        unit_idx = -1\n        for i in committed_indices:\n            if p_i[i] >= max_p_i[i] - 1e-6:\n                continue\n            marginal_cost = (units_info[i]['b_i'] + \n                            2 * units_info[i]['c_i'] * p_i[i])\n            if marginal_cost < min_mc:\n                min_mc = marginal_cost\n                unit_idx = i\n        \n        if unit_idx == -1:  # No unit can increase output\n            break\n            \n        increment = min(\n            residual, \n            max_p_i[unit_idx] - p_i[unit_idx],\n            units_info[unit_idx]['p_up_i']  # Respect ramp up constraint\n        )\n        p_i[unit_idx] += increment\n        residual -= increment\n    \n    # Set non-committed units to 0\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.005227771,
          "gap_price_rate": 0.0087560923,
          "fitness": 0.0069919316
     },
     {
          "name": "hybrid_lambda_enhanced_commitment",
          "algorithm": "1. Identify must-on units (insufficient min-up time or previous output exceeding shutdown ramp) and must-off units (insufficient min-down time). 2. Initialize commitment: set must-on units to 1, must-off units to 0, others retain previous state. 3. For committed units, compute current feasible power ranges considering ramp/startup constraints. 4. Adjust commitment iteratively: a) Under-committed: activate units by lowest (startup cost + min-power cost)/min-power metric b) Over-committed: decommit units by highest min-power cost c) Adequate: decommission expensive non-must-on units while maintaining adequacy. 5. Perform economic dispatch via lambda iteration within feasible ranges. 6. Resolve residual load with constrained greedy adjustment. 7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef hybrid_lambda_enhanced_commitment(units_info, load):\n    # Extract current load\n    load_current = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    p_min_current = np.zeros(n_units)\n    p_max_current = np.zeros(n_units)\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        # Must-on conditions\n        if (unit['u_i_0'] == 1) and ((unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        # Must-off conditions\n        elif (unit['u_i_0'] == 0) and (unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(i)\n    \n    # Step 2: Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u_arr[i] = 1\n        elif i in must_off:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n    \n    # Step 3: Compute feasible power ranges for committed units\n    def calc_feasible_ranges():\n        for i, unit in enumerate(units_info):\n            if u_arr[i] == 1:\n                if unit['u_i_0'] == 1:  # Previously online\n                    p_min_current[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    p_max_current[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:  # Starting up\n                    p_min_current[i] = unit['p_min_i']\n                    p_max_current[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n        return p_min_current.copy(), p_max_current.copy()\n    \n    p_min_current, p_max_current = calc_feasible_ranges()\n    \n    # Step 4: Adjust commitment states\n    total_min = np.sum(p_min_current)\n    total_max = np.sum(p_max_current)\n    load_current = load[0]\n    \n    # Case a: Under-committed (total_max < load_current)\n    if total_max < load_current:\n        # Find candidate offline units (not must-off)\n        candidate_on = [i for i in range(n_units) if u_arr[i] == 0 and i not in must_off]\n        while total_max < load_current and candidate_on:\n            # Calculate cost-effectiveness metric\n            metrics = []\n            for i in candidate_on:\n                unit = units_info[i]\n                min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n                metric = (unit['s_i'] + min_cost) / unit['p_min_i']\n                metrics.append((metric, i))\n            \n            # Activate most cost-effective unit\n            metrics.sort(key=lambda x: x[0])\n            activate_idx = metrics[0][1]\n            u_arr[activate_idx] = 1\n            # Update feasible ranges\n            p_min_current[activate_idx] = units_info[activate_idx]['p_min_i']\n            p_max_current[activate_idx] = min(units_info[activate_idx]['p_max_i'], units_info[activate_idx]['p_start_i'])\n            # Recompute total min/max\n            total_min += p_min_current[activate_idx]\n            total_max += p_max_current[activate_idx]\n            # Remove activated unit from candidates\n            candidate_on.remove(activate_idx)\n    \n    # Case b: Over-committed (total_min > load_current)\n    if total_min > load_current:\n        # Find candidate units to turn off (non-must-on)\n        candidate_off = [i for i in range(n_units) if u_arr[i] == 1 and i not in must_on]\n        # Sort by highest min-power operating cost\n        candidate_off.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + units_info[i]['c_i']*units_info[i]['p_min_i']**2, \n                          reverse=True)\n        \n        for i in candidate_off:\n            if total_min <= load_current:\n                break\n            # Decommit unit\n            u_arr[i] = 0\n            p_min_current[i] = 0\n            p_max_current[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= units_info[i]['p_start_i'] if units_info[i]['u_i_0'] == 0 else units_info[i]['p_max_i']\n    \n    # Case c: Adequate system\n    if total_min <= load_current <= total_max:\n        # Find candidate non-must-on units to turn off\n        candidate_off = [i for i in range(n_units) if u_arr[i] == 1 and i not in must_on]\n        # Sort by highest min-power cost\n        candidate_off.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + units_info[i]['c_i']*units_info[i]['p_min_i']**2, \n                          reverse=True)\n        \n        for i in candidate_off:\n            new_total_max = total_max - p_max_current[i]\n            if new_total_max >= load_current:\n                # Decommit unit\n                u_arr[i] = 0\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n                total_min -= units_info[i]['p_min_i']\n                total_max = new_total_max\n    \n    # Recalculate feasible ranges after commitment adjustments\n    p_min_current, p_max_current = calc_feasible_ranges()\n    committed_indices = [i for i in range(n_units) if u_arr[i] == 1]\n    \n    # Step 5: Economic dispatch via lambda iteration\n    if committed_indices:\n        # Set initial output to min\n        for i in committed_indices:\n            p_arr[i] = p_min_current[i]\n        residual = load_current - np.sum(p_arr)\n        \n        # Lambda iteration setup\n        if abs(residual) > 1e-4:\n            b_vals = np.array([units_info[i]['b_i'] for i in committed_indices])\n            c_vals = np.array([units_info[i]['c_i'] for i in committed_indices])\n            p_mins = np.array([p_min_current[i] for i in committed_indices])\n            p_maxs = np.array([p_max_current[i] for i in committed_indices])\n            \n            # Bounds for lambda\n            low = np.min(2 * c_vals * p_mins + b_vals)\n            high = np.max(2 * c_vals * p_maxs + b_vals)\n            lambda_mid = (low + high) / 2\n            tolerance_lambda = 0.1  # MW tolerance\n            max_iter = 1000\n            \n            # Lambda iteration\n            for _ in range(max_iter):\n                p_dispatch = []\n                for idx, i in enumerate(committed_indices):\n                    if c_vals[idx] == 0:\n                        if lambda_mid < b_vals[idx]:\n                            p_dispatch.append(p_mins[idx])\n                        else:\n                            p_dispatch.append(p_maxs[idx])\n                    else:\n                        # Calculate unconstrained dispatch\n                        p_unc = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx])\n                        # Enforce constraints\n                        p_val = max(p_mins[idx], min(p_maxs[idx], p_unc))\n                        p_dispatch.append(p_val)\n                \n                total_gen = np.sum(p_dispatch)\n                gen_diff = total_gen - load_current\n                \n                if abs(gen_diff) < tolerance_lambda:\n                    for j, i in enumerate(committed_indices):\n                        p_arr[i] = p_dispatch[j]\n                    residual = load_current - total_gen\n                    break\n                \n                if gen_diff < 0:\n                    low = lambda_mid\n                else:\n                    high = lambda_mid\n                lambda_mid = (low + high) / 2\n            else:\n                # Fallback to greedy dispatch if not converged\n                p_dispatch = np.clip(p_dispatch, p_mins, p_maxs)\n                for j, i in enumerate(committed_indices):\n                    p_arr[i] = p_dispatch[j]\n                residual = load_current - np.sum(p_dispatch)\n            \n            # Step 6: Greedy residual adjustment\n            tolerance_greedy = 1e-4\n            if residual > tolerance_greedy:\n                # Increase generation from cheapest units\n                candidates = [i for i in committed_indices if p_arr[i] < p_max_current[i]]\n                if candidates:\n                    marginal_costs = [2 * units_info[i]['c_i'] * p_arr[i] + units_info[i]['b_i'] for i in candidates]\n                    sorted_indices = np.argsort(marginal_costs)\n                    \n                    for idx in sorted_indices:\n                        i = candidates[idx]\n                        increment = min(residual, p_max_current[i] - p_arr[i])\n                        p_arr[i] += increment\n                        residual -= increment\n                        if residual < tolerance_greedy:\n                            break\n            \n            elif residual < -tolerance_greedy:\n                # Decrease generation from most expensive units\n                candidates = [i for i in committed_indices if p_arr[i] > p_min_current[i]]\n                if candidates:\n                    marginal_costs = [2 * units_info[i]['c_i'] * p_arr[i] + units_info[i]['b_i'] for i in candidates]\n                    sorted_indices = np.argsort(marginal_costs)[::-1]\n                    \n                    for idx in sorted_indices:\n                        i = candidates[idx]\n                        decrement = min(-residual, p_arr[i] - p_min_current[i])\n                        p_arr[i] -= decrement\n                        residual += decrement\n                        if residual > -tolerance_greedy:\n                            break\n    \n    # Prepare output\n    schedules = np.vstack((u_arr, p_arr))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049947392,
          "gap_price_rate": 0.0092618964,
          "fitness": 0.0071283178
     },
     {
          "name": "combined_lambda_adaptive_rolling",
          "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown ramp) and must-off units (offline with insufficient min-down time).\n2. Initialize commitment: set must-on to committed, must-off to off, and flexible units to previous state.\n3. Calculate feasible power ranges for committed units considering ramp and startup/shutdown constraints.\n4. Adjust commitment:\n   a. Under-committed: activate offline units using (startup cost + min-power production cost)/min-power metric\n   b. Over-committed: decommit non-must-on units by highest min-power operating cost\n   c. Adequate: decommission expensive non-must-on units while maintaining system adequacy\n5. Perform economic dispatch using lambda iteration with bisection\n6. Adjust residual load via greedy method based on marginal costs\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef combined_lambda_adaptive_rolling(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:  # Was online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < t_off_min_i:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate feasible power ranges for committed units\n    feasible_min = [0.0] * n_units\n    feasible_max = [0.0] * n_units\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            u_i_0 = unit['u_i_0']\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            if u_i_0 == 1:  # Was online\n                feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n                feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n            else:  # Starting up\n                feasible_min[i] = p_min_i\n                feasible_max[i] = min(p_max_i, p_start_i)\n    \n    # Calculate total min/max generation\n    total_min = sum(feasible_min)\n    total_max = sum(feasible_max)\n    \n    # Adjust commitment for under-committed case\n    if total_max < current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 0 and i not in must_off:\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                cost_at_min = a_i + b_i * p_min_i + c_i * p_min_i**2\n                metric = (s_i + cost_at_min) / p_min_i\n                candidates.append((metric, i))\n        \n        candidates.sort(key=lambda x: x[0])\n        for metric, i in candidates:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            p_min_i = units_info[i]['p_min_i']\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += p_min_i\n            total_max += feasible_max[i]\n    \n    # Adjust commitment for over-committed case\n    if total_min > current_load:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and i not in must_on:\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                cost_at_min = a_i + b_i * feasible_min[i] + c_i * feasible_min[i]**2\n                candidates.append((cost_at_min, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in candidates:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n    \n    # Adjust commitment for adequate case\n    if total_min <= current_load <= total_max:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and i not in must_on:\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                cost_at_min = a_i + b_i * feasible_min[i] + c_i * feasible_min[i]**2\n                candidates.append((cost_at_min, i, feasible_min[i], feasible_max[i]))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for cost, i, fmin, fmax in candidates:\n            new_total_min = total_min - fmin\n            new_total_max = total_max - fmax\n            if new_total_min <= current_load <= new_total_max:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                feasible_min[i] = 0\n                feasible_max[i] = 0\n    \n    # Economic dispatch using lambda iteration\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    for i in committed_indices:\n        p[i] = feasible_min[i]\n    total_gen = sum(p)\n    \n    if abs(total_gen - current_load) > 1e-6 and committed_indices:\n        # Lambda iteration setup\n        lambda_low = 0\n        lambda_high = 0\n        for i in committed_indices:\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            marginal_min = b_i + 2 * c_i * feasible_min[i]\n            marginal_max = b_i + 2 * c_i * feasible_max[i]\n            lambda_high = max(lambda_high, marginal_max)\n        lambda_high += 1  # Ensure initial high value\n        \n        # Bisection method\n        max_iter = 100\n        tol = 0.1\n        for _ in range(max_iter):\n            lam = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_opt = (lam - b_i) / (2 * c_i) if c_i > 0 else feasible_max[i]\n                p_i = max(feasible_min[i], min(p_opt, feasible_max[i]))\n                p[i] = p_i\n                total_gen += p_i\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lam\n            else:\n                lambda_high = lam\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > 1e-3 and committed_indices:\n            if residual > 0:  # Under generation\n                candidates = []\n                for i in committed_indices:\n                    if p[i] < feasible_max[i]:\n                        unit = units_info[i]\n                        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                        candidates.append((marginal_cost, i))\n                candidates.sort(key=lambda x: x[0])\n                for mc, i in candidates:\n                    if residual <= 0:\n                        break\n                    max_additional = feasible_max[i] - p[i]\n                    to_add = min(max_additional, residual)\n                    p[i] += to_add\n                    residual -= to_add\n            else:  # Over generation\n                residual = abs(residual)\n                candidates = []\n                for i in committed_indices:\n                    if p[i] > feasible_min[i]:\n                        unit = units_info[i]\n                        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                        candidates.append((marginal_cost, i))\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                for mc, i in candidates:\n                    if residual <= 0:\n                        break\n                    max_reduction = p[i] - feasible_min[i]\n                    to_reduce = min(max_reduction, residual)\n                    p[i] -= to_reduce\n                    residual -= to_reduce\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0049947449,
          "gap_price_rate": 0.0092619052,
          "fitness": 0.0071283251
     },
     {
          "name": "refined_lambda_commitment_dispatch",
          "algorithm": "1. Identify must-on units (currently online units failing min-up time or shutdown ramp constraints) and must-off units (offline units failing min-down time).\n2. Initialize commitment: set must-on units to 'on', must-off units to 'off', others retain previous state.\n3. Calculate feasible power ranges for committed units considering ramp rates, startup/shutdown constraints.\n4. Iteratively adjust commitment:\n   a. For under-committed systems (insufficient max capacity), activate most cost-effective offline units.\n   b. For over-committed systems (excess min capacity), decommit highest-cost non-must-on units.\n   c. Decommission expensive non-must-on units if adequacy holds.\n5. Perform lambda iteration for economic dispatch respecting output constraints.\n6. Handle residual load after dispatch via greedy adjustment.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_lambda_commitment_dispatch(units_info, load):\n    load_current = load[0]  # current load to meet\n    \n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min and t_i0 > 0) or p_i0 > p_shut:\n                must_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    u = [0] * n_units\n    for i in range(n_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Initialize min and max power outputs\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            min_outputs[i] = max_outputs[i] = 0.0\n            continue\n            \n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_i0 = unit['p_i_0']\n        \n        if unit['u_i_0'] == 1 and u[i] == 1:  # remains on\n            min_outputs[i] = max(p_min, p_i0 - p_down)\n            max_outputs[i] = min(p_max, p_i0 + p_up)\n        elif unit['u_i_0'] == 0 and u[i] == 1:  # starting up\n            min_outputs[i] = p_min\n            max_outputs[i] = min(p_max, p_start)\n        elif unit['u_i_0'] == 1 and u[i] == 0:  # shutting down\n            min_outputs[i] = max_outputs[i] = 0.0\n        else:  # remains off\n            min_outputs[i] = max_outputs[i] = 0.0\n    \n    total_min = np.sum(min_outputs)\n    total_max = np.sum(max_outputs)\n    \n    # Adjust commitment iteratively\n    max_iter = n_units\n    iter_count = 0\n    \n    while iter_count < max_iter:\n        iter_count += 1\n        \n        if total_max < load_current:  # Under-committed\n            available_offline = [i for i in range(n_units) \n                                if u[i] == 0 and i not in must_off]\n            if not available_offline:\n                break\n                \n            metrics = []\n            for i in available_offline:\n                unit = units_info[i]\n                p_min_candidate = unit['p_min_i']\n                cost = unit['a_i'] + unit['b_i'] * p_min_candidate + unit['c_i'] * p_min_candidate**2 + unit['s_i']\n                metrics.append((cost / p_min_candidate, i))\n            \n            if not metrics:\n                break\n            metrics.sort(key=lambda x: x[0])\n            candidate = metrics[0][1]\n            u[candidate] = 1\n            unit_candidate = units_info[candidate]\n            min_candidate = unit_candidate['p_min_i']\n            max_candidate = min(unit_candidate['p_max_i'], unit_candidate['p_start_i'])\n            min_outputs[candidate] = min_candidate\n            max_outputs[candidate] = max_candidate\n            total_min += min_candidate\n            total_max += max_candidate\n            \n        elif total_min > load_current:  # Over-committed\n            decommitable = [i for i in range(n_units) \n                           if u[i] == 1 and i not in must_on]\n            if not decommitable:\n                break\n                \n            metrics = []\n            for i in decommitable:\n                cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2\n                metrics.append((cost, i))\n            \n            metrics.sort(key=lambda x: x[0], reverse=True)\n            candidate = metrics[0][1]\n            u[candidate] = 0\n            removed_min = min_outputs[candidate]\n            removed_max = max_outputs[candidate]\n            min_outputs[candidate] = 0.0\n            max_outputs[candidate] = 0.0\n            total_min -= removed_min\n            total_max -= removed_max\n            \n        else:  # Adequate\n            break\n    \n    # Greedy decommitment for expensive non-must-on units\n    decommitable = [i for i in range(n_units) \n                   if u[i] == 1 and i not in must_on]\n    if decommitable:\n        metrics = []\n        for i in decommitable:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2\n            metrics.append((cost, i))\n        \n        metrics.sort(key=lambda x: x[0], reverse=True)\n        for cost, i in metrics:\n            new_total_min = total_min - min_outputs[i]\n            new_total_max = total_max - max_outputs[i]\n            if new_total_min <= load_current <= new_total_max:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_outputs[i] = 0.0\n                max_outputs[i] = 0.0\n    \n    # Commit if none are committed but load exists (emergency)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices and abs(load_current) > 1e-6:\n        candidate = np.argmin([unit['p_min_i'] for unit in units_info])\n        u[candidate] = 1\n        min_outputs[candidate] = units_info[candidate]['p_min_i']\n        max_outputs[candidate] = min(units_info[candidate]['p_max_i'], units_info[candidate]['p_start_i'])\n        committed_indices = [candidate]\n        total_min = min_outputs[candidate]\n        total_max = max_outputs[candidate]\n    \n    # Lambda iteration for economic dispatch\n    p = min_outputs.copy()\n    if committed_indices and abs(total_max - total_min) > 1e-6:\n        # Calculate lambda bounds\n        lam_low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_outputs[i] for i in committed_indices) - 1.0\n        lam_high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_outputs[i] for i in committed_indices) + 1.0\n        \n        # Bisection for optimal lambda\n        for _ in range(100):\n            if abs(lam_high - lam_low) < 1e-6:\n                break\n            lam_mid = (lam_low + lam_high) / 2.0\n            total_mid = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                marginal_low = unit['b_i'] + 2 * unit['c_i'] * min_outputs[i]\n                marginal_high = unit['b_i'] + 2 * unit['c_i'] * max_outputs[i]\n                if lam_mid < marginal_low:\n                    p_i = min_outputs[i]\n                elif lam_mid > marginal_high:\n                    p_i = max_outputs[i]\n                else:\n                    p_i = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_outputs[i], min(p_i, max_outputs[i]))\n                total_mid += p_i\n            \n            if total_mid < load_current:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n        \n        # Calculate final dispatch with optimal lambda\n        lam = (lam_low + lam_high) / 2\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_low = unit['b_i'] + 2 * unit['c_i'] * min_outputs[i]\n            marginal_high = unit['b_i'] + 2 * unit['c_i'] * max_outputs[i]\n            if lam < marginal_low:\n                p_i = min_outputs[i]\n            elif lam > marginal_high:\n                p_i = max_outputs[i]\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(min_outputs[i], min(p_i, max_outputs[i]))\n            p[i] = p_i\n        \n        total_output = np.sum(p)\n        residual = load_current - total_output\n        \n        # Residual load adjustment\n        if residual > 1e-6:  # Under generation\n            candidates = [i for i in committed_indices if p[i] < max_outputs[i] - 1e-6]\n            candidates.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n            for i in candidates:\n                avail = max_outputs[i] - p[i]\n                to_add = min(avail, residual)\n                p[i] += to_add\n                residual -= to_add\n                if residual <= 1e-6:\n                    break\n        elif residual < -1e-6:  # Over generation\n            residual = abs(residual)\n            candidates = [i for i in committed_indices if p[i] > min_outputs[i] + 1e-6]\n            candidates.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n            for i in candidates:\n                avail = p[i] - min_outputs[i]\n                to_remove = min(avail, residual)\n                p[i] -= to_remove\n                residual -= to_remove\n                if residual <= 1e-6:\n                    break\n    \n    # Format output\n    schedules = np.zeros((2, n_units))\n    schedules[0] = u\n    schedules[1] = p\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0049947365,
          "gap_price_rate": 0.0092619258,
          "fitness": 0.0071283312
     },
     {
          "name": "hybrid_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-on units (units that must remain on due to insufficient min-up time or violation of shutdown ramp constraint) and must-off units (units that must remain off due to insufficient min-down time)\n2. Initialize commitment: set must-on units to on, must-off units to off, and flexible units to their previous state\n3. Calculate feasible power ranges for committed units considering ramp constraints and startup/shutdown limits\n4. Adjust commitment based on system adequacy:\n   - Under-committed: activate flexible units sorted by lowest (startup cost + min-power cost)/min-power\n   - Over-committed: decommit non-must-on units sorted by highest min-power operating cost\n   - Adequate: decommit non-must-on units sorted by highest min-power cost if system remains adequate\n5. Perform constrained economic dispatch using lambda iteration for committed units:\n   - Solve optimal dispatch via bisection on system lambda\n   - Adjust any residual load using greedy merit-order based on marginal costs\n6. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    min_bound = [0.0] * n\n    max_bound = [0.0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    current_load = load[0]\n    \n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    # Step 2: Initialize commitment states\n    for i in range(n):\n        if must_on[i]:\n            u_arr[i] = 1\n        elif must_off[i]:\n            u_arr[i] = 0\n        else:\n            u_arr[i] = units_info[i]['u_i_0']\n\n    # Step 3: Calculate feasible power ranges for committed units\n    for i, unit in enumerate(units_info):\n        if u_arr[i] == 1:\n            if unit['u_i_0'] == 0:\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n\n    # Step 4: Adjust commitment based on system adequacy\n    total_min = sum(min_bound[i] for i in range(n) if u_arr[i] == 1)\n    total_max = sum(max_bound[i] for i in range(n) if u_arr[i] == 1)\n    \n    # Case A: Under-committed\n    if total_max < current_load:\n        flexible_off = [i for i in range(n) if not must_on[i] and not must_off[i] and u_arr[i] == 0]\n        metrics = []\n        for i in flexible_off:\n            unit = units_info[i]\n            startup_cost = unit['s_i']\n            min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            metric = (startup_cost + min_cost) / unit['p_min_i']\n            metrics.append((metric, i))\n        metrics.sort(key=lambda x: x[0])\n        \n        for metric, i in metrics:\n            if total_max >= current_load:\n                break\n            u_arr[i] = 1\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Case B: Over-committed\n    if total_min > current_load:\n        non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n        costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n            costs.append((cost, i))\n        costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in costs:\n            if total_min <= current_load:\n                break\n            u_arr[i] = 0\n            total_min -= min_bound[i]\n            total_max -= max_bound[i]\n            min_bound[i] = 0\n            max_bound[i] = 0\n    \n    # Case C: Adequate - decommit expensive non-must-on units\n    non_must_on = [i for i in range(n) if u_arr[i] == 1 and not must_on[i]]\n    costs = []\n    for i in non_must_on:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_bound[i] + unit['c_i'] * (min_bound[i] ** 2)\n        costs.append((cost, i))\n    costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in costs:\n        new_min = total_min - min_bound[i]\n        new_max = total_max - max_bound[i]\n        if new_min <= current_load <= new_max:\n            u_arr[i] = 0\n            total_min = new_min\n            total_max = new_max\n            min_bound[i] = 0\n            max_bound[i] = 0\n\n    # Step 5: Economic dispatch for committed units\n    committed_indices = [i for i in range(n) if u_arr[i] == 1]\n    l_dispatch = [min_bound[i] for i in committed_indices]\n    u_dispatch = [max_bound[i] for i in committed_indices]\n    b_dispatch = [units_info[i]['b_i'] for i in committed_indices]\n    c_dispatch = [units_info[i]['c_i'] for i in committed_indices]\n    p_dispatch = l_dispatch[:] if committed_indices else []\n    residual = current_load - sum(p_dispatch)\n    \n    # Lambda iteration for dispatch\n    if committed_indices:\n        tol = 0.001\n        max_iter = 1000\n        low_lambda = float('inf')\n        high_lambda = float('-inf')\n        \n        for i in range(len(committed_indices)):\n            mc_low = b_dispatch[i] + 2 * c_dispatch[i] * l_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            mc_high = b_dispatch[i] + 2 * c_dispatch[i] * u_dispatch[i] if c_dispatch[i] != 0 else b_dispatch[i]\n            if mc_low < low_lambda:\n                low_lambda = mc_low\n            if mc_high > high_lambda:\n                high_lambda = mc_high\n        \n        lambda_low = min(low_lambda - 1.0, 0)\n        lambda_high = high_lambda + 1.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in range(len(committed_indices)):\n                if c_dispatch[i] == 0:\n                    if lambda_mid < b_dispatch[i]:\n                        p_dispatch[i] = l_dispatch[i]\n                    elif lambda_mid > b_dispatch[i]:\n                        p_dispatch[i] = u_dispatch[i]\n                    else:\n                        p_dispatch[i] = l_dispatch[i]\n                else:\n                    p = (lambda_mid - b_dispatch[i]) / (2.0 * c_dispatch[i])\n                    p_dispatch[i] = min(u_dispatch[i], max(l_dispatch[i], p))\n                total_gen += p_dispatch[i]\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Adjust residual load\n        residual = current_load - total_gen\n        if abs(residual) > tol:\n            # Residual >0: distribute to units with cheapest marginal cost\n            if residual > 0:\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] < u_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    min_mc = min(mc_list, key=lambda x: x[0])\n                    i = min_mc[1]\n                    add = min(residual, u_dispatch[i] - p_dispatch[i])\n                    p_dispatch[i] += add\n                    residual -= add\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] < u_dispatch[j]]\n            # Residual <0: reduce from units with highest marginal cost\n            else:\n                residual = abs(residual)\n                candidates = [i for i in range(len(committed_indices)) if p_dispatch[i] > l_dispatch[i]]\n                while residual > tol and candidates:\n                    mc_list = []\n                    for i in candidates:\n                        if c_dispatch[i] == 0:\n                            mc = b_dispatch[i]\n                        else:\n                            mc = b_dispatch[i] + 2 * c_dispatch[i] * p_dispatch[i]\n                        mc_list.append((mc, i))\n                    max_mc = max(mc_list, key=lambda x: x[0])\n                    i = max_mc[1]\n                    reduce_by = min(residual, p_dispatch[i] - l_dispatch[i])\n                    p_dispatch[i] -= reduce_by\n                    residual -= reduce_by\n                    candidates = [j for j in range(len(committed_indices)) if p_dispatch[j] > l_dispatch[j]]\n        \n        # Assign dispatched power to output array\n        for idx, p_val in zip(committed_indices, p_dispatch):\n            p_arr[idx] = p_val\n    \n    # Build return array\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = u_arr[i]\n        schedules[1, i] = p_arr[i]\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0049948693,
          "gap_price_rate": 0.0092619027,
          "fitness": 0.007128386
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
          "from": null,
          "gap_power_rate": 0.0049958756,
          "gap_price_rate": 0.0092621039,
          "fitness": 0.0071289898
     }
]