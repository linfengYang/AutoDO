{
     "name": "commit_units_by_priority_list",
     "algorithm": "1. Determine forced commitment and decommitment based on min up/down times and shutdown capacity\n  2. Initialize unit states (u_i) considering forced status and previous states\n  3. Compute min/max power for each unit considering ramp limits and start/shutdown constraints\n  4. While current max capacity is insufficient, turn on available units by startup cost priority\n  5. While current min capacity exceeds load, turn off non-forced expensive units if feasible\n  6. Perform economic dispatch using lambda iteration for committed units\n  7. Return schedules\n\n",
     "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on[i] = True\n            forced_off[i] = False\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                forced_off[i] = True\n            else:\n                forced_off[i] = False\n    \n    u = [0] * n_units\n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    for i, unit in enumerate(units_info):\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1 and u[i] == 1:\n            min_p[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_p[i] = min(p_max_i, p_i_0 + p_up_i)\n        elif u_i_0 == 0 and u[i] == 1:\n            min_p[i] = p_min_i\n            max_p[i] = min(p_max_i, p_start_i)\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    total_min = sum(min_p[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(max_p[i] for i in range(n_units) if u[i] == 1)\n    \n    if total_max < current_load:\n        candidate_indices = [i for i in range(n_units) if u[i] == 0 and not forced_off[i]]\n        candidate_priority = []\n        \n        for i in candidate_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                s_i = 0\n            else:\n                min_p_i = unit['p_min_i']\n                max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n                s_i = unit['s_i']\n            \n            cost_at_min = unit['a_i'] + unit['b_i'] * min_p_i + unit['c_i'] * min_p_i**2\n            total_cost = cost_at_min + s_i\n            priority = total_cost / min_p_i if min_p_i > 0 else float('inf')\n            candidate_priority.append((priority, i, min_p_i, max_p_i))\n        \n        candidate_priority.sort(key=lambda x: x[0])\n        for _, i, min_p_i, max_p_i in candidate_priority:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            total_min += min_p_i\n            total_max += max_p_i\n    \n    candidate_decommit = []\n    for i in range(n_units):\n        if u[i] == 1 and not forced_on[i]:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2\n            candidate_decommit.append((cost_at_min, i))\n    \n    candidate_decommit.sort(key=lambda x: x[0], reverse=True)\n    for _, i in candidate_decommit:\n        test_total_min = total_min - min_p[i]\n        test_total_max = total_max - max_p[i]\n        if test_total_min <= current_load <= test_total_max:\n            u[i] = 0\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = test_total_min\n            total_max = test_total_max\n    \n    committed_units = []\n    indices_map = []\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            committed_units.append({\n                'a_i': unit['a_i'],\n                'b_i': unit['b_i'],\n                'c_i': unit['c_i'],\n                'min_p': min_p[i],\n                'max_p': max_p[i]\n            })\n            indices_map.append(i)\n    \n    p_out = [0] * n_units\n    if committed_units:\n        dispatch_vals = economic_dispatch(committed_units, current_load)\n        for idx, val in enumerate(dispatch_vals):\n            p_out[indices_map[idx]] = val\n    \n    schedules = np.array([u, p_out])\n    return schedules\n\ndef economic_dispatch(units, total_load):\n    n_units = len(units)\n    if n_units == 0:\n        return []\n    if n_units == 1:\n        unit = units[0]\n        p_val = max(unit['min_p'], min(unit['max_p'], total_load))\n        return [p_val]\n    \n    lamb_low = float('inf')\n    lamb_high = -float('inf')\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i > 0:\n            deriv_min = 2 * c_i * min_p + b_i\n            deriv_max = 2 * c_i * max_p + b_i\n        else:\n            deriv_min = b_i\n            deriv_max = b_i\n        lamb_low = min(lamb_low, deriv_min)\n        lamb_high = max(lamb_high, deriv_max)\n    \n    tol = 0.01\n    max_iter = 1000\n    iter_count = 0\n    lambda_mid = (lamb_low + lamb_high) / 2\n    while iter_count < max_iter:\n        total_power = 0\n        for unit in units:\n            c_i, b_i = unit['c_i'], unit['b_i']\n            min_p, max_p = unit['min_p'], unit['max_p']\n            if c_i == 0:\n                if b_i < lambda_mid:\n                    p_i = max_p\n                else:\n                    p_i = min_p\n            else:\n                p_i = (lambda_mid - b_i) / (2 * c_i)\n                p_i = max(min_p, min(max_p, p_i))\n            total_power += p_i\n        \n        if abs(total_power - total_load) < tol:\n            break\n        if total_power < total_load:\n            lamb_low = lambda_mid\n        else:\n            lamb_high = lambda_mid\n        lambda_mid = (lamb_low + lamb_high) / 2\n        iter_count += 1\n    \n    p_vals = []\n    for unit in units:\n        c_i, b_i = unit['c_i'], unit['b_i']\n        min_p, max_p = unit['min_p'], unit['max_p']\n        if c_i == 0:\n            if b_i < lambda_mid:\n                p_i = max_p\n            else:\n                p_i = min_p\n        else:\n            p_i = (lambda_mid - b_i) / (2 * c_i)\n            p_i = max(min_p, min(max_p, p_i))\n        p_vals.append(p_i)\n    \n    return p_vals",
     "from": null,
     "gap_power_rate": 0.0049958756,
     "gap_price_rate": 0.0092621039,
     "fitness": 0.0071289898
}