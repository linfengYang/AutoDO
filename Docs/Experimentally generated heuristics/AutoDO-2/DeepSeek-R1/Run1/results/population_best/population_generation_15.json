{
     "name": "solve_ruc",
     "algorithm": "1. Identify must-on units (online with insufficient min-up time or previous output > shutdown capacity) and must-off units (offline with insufficient min-down time)  \n2. Initialize commitment states: must-on units committed (1), must-off units decommitted (0), others retain previous state  \n3. Compute feasible power ranges for committed units considering ramp rates, startup, and shutdown constraints  \n4. Adjust commitment iteratively:  \n   a. Under-committed (total max < load): Activate available units by best metric (startup cost + min-power cost)/min-power  \n   b. Over-committed (total min > load): Decommit non-must-on units by highest min-power cost until feasible  \n   c. Adequate: Decommission non-must-on units by highest min-power cost only if both current and forecasted loads remain within feasible ranges post-decommission  \n5. Perform economic dispatch using lambda iteration with bisection on marginal costs within constrained power ranges  \n6. Adjust residual load via greedy approach using marginal cost-based prioritization  \n7. Return commitment states and power outputs for all units  \n\n",
     "code": "import numpy as np\n\ndef solve_ruc(units_info, load):\n    units = units_info\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Step 1: Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(unit)\n    \n    # Step 2: Initialize commitment states\n    committed_units = []\n    for unit in units:\n        if unit in must_on:\n            unit['u_i'] = 1\n            committed_units.append(unit)\n        elif unit in must_off:\n            unit['u_i'] = 0\n        else:\n            unit['u_i'] = unit['u_i_0']\n            if unit['u_i_0'] == 1:\n                committed_units.append(unit)\n    \n    # Step 3: Compute feasible power ranges\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            unit['feas_min'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['feas_max'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['feas_min'] = unit['p_min_i']\n            unit['feas_max'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Adjust commitment\n    # Calculate current total min/max\n    total_min = sum(unit['feas_min'] for unit in committed_units)\n    total_max = sum(unit['feas_max'] for unit in committed_units)\n    \n    # Under-committed case\n    if total_max < current_load:\n        available = [u for u in units if u['u_i'] == 0 and u not in must_off and u not in must_on]\n        metrics = []\n        for unit in available:\n            min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n            metrics.append((min_cost + unit['s_i']) / unit['p_min_i'])\n        sorted_avail = [u for _, u in sorted(zip(metrics, available), key=lambda x: x[0])]\n        \n        for unit in sorted_avail:\n            if total_max >= current_load:\n                break\n            unit['u_i'] = 1\n            unit['feas_min'] = unit['p_min_i']\n            unit['feas_max'] = min(unit['p_max_i'], unit['p_start_i'])\n            committed_units.append(unit)\n            total_min += unit['feas_min']\n            total_max += unit['feas_max']\n    \n    # Over-committed case\n    elif total_min > current_load:\n        non_must_on = [u for u in committed_units if u not in must_on]\n        min_costs = []\n        for unit in non_must_on:\n            min_cost = unit['a_i'] + unit['b_i']*unit['feas_min'] + unit['c_i']*(unit['feas_min']**2)\n            min_costs.append(min_cost)\n        sorted_non_must = [u for _, u in sorted(zip(min_costs, non_must_on), reverse=True)]\n        \n        for unit in sorted_non_must:\n            if total_min <= current_load:\n                break\n            unit['u_i'] = 0\n            committed_units.remove(unit)\n            total_min -= unit['feas_min']\n            total_max -= unit['feas_max']\n    \n    # Adequate case\n    else:\n        non_must_on = [u for u in committed_units if u not in must_on]\n        min_costs = []\n        for unit in non_must_on:\n            min_cost = unit['a_i'] + unit['b_i']*unit['feas_min'] + unit['c_i']*(unit['feas_min']**2)\n            min_costs.append(min_cost)\n        sorted_non_must = [u for _, u in sorted(zip(min_costs, non_must_on), reverse=True)]\n        \n        for unit in sorted_non_must:\n            new_total_min = total_min - unit['feas_min']\n            new_total_max = total_max - unit['feas_max']\n            if new_total_min <= current_load <= new_total_max and new_total_min <= next_load <= new_total_max:\n                unit['u_i'] = 0\n                committed_units.remove(unit)\n                total_min = new_total_min\n                total_max = new_total_max\n    \n    # Update committed units if changes occurred\n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    # Step 5: Economic dispatch using lambda iteration\n    if not committed_units:\n        schedules = np.zeros((2, len(units)))\n        for i, unit in enumerate(units):\n            schedules[0, i] = unit['u_i']\n            schedules[1, i] = 0.0\n        return schedules\n    \n    # Set initial lambda bounds\n    lambda_low = min(u['b_i'] + 2*u['c_i']*u['feas_min'] for u in committed_units)\n    lambda_high = max(u['b_i'] + 2*u['c_i']*u['feas_max'] for u in committed_units)\n    \n    # Lambda iteration with bisection\n    max_iter = 1000\n    tol = 0.01\n    n_units = len(committed_units)\n    p_outputs = [u['feas_min'] for u in committed_units]\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        total_p = 0.0\n        for idx, unit in enumerate(committed_units):\n            p_val = (lambda_mid - unit['b_i']) / (2.0 * unit['c_i'])\n            p_clamped = max(unit['feas_min'], min(unit['feas_max'], p_val))\n            p_outputs[idx] = p_clamped\n            total_p += p_clamped\n        \n        if abs(total_p - current_load) < tol:\n            break\n        elif total_p < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Handle residual load using greedy adjustment\n    residual = current_load - sum(p_outputs)\n    while abs(residual) > tol:\n        if residual > 0:\n            marginals = []\n            for idx, unit in enumerate(committed_units):\n                if p_outputs[idx] < unit['feas_max']:\n                    mc = unit['b_i'] + 2*unit['c_i']*p_outputs[idx]\n                    marginals.append((mc, idx))\n            if not marginals:\n                break\n            min_marginal = min(marginals, key=lambda x: x[0])\n            idx = min_marginal[1]\n            unit = committed_units[idx]\n            delta = min(residual, unit['feas_max'] - p_outputs[idx])\n            p_outputs[idx] += delta\n            residual -= delta\n        else:\n            marginals = []\n            for idx, unit in enumerate(committed_units):\n                if p_outputs[idx] > unit['feas_min']:\n                    mc = unit['b_i'] + 2*unit['c_i']*p_outputs[idx]\n                    marginals.append((mc, idx))\n            if not marginals:\n                break\n            max_marginal = max(marginals, key=lambda x: x[0])\n            idx = max_marginal[1]\n            unit = committed_units[idx]\n            delta = min(-residual, p_outputs[idx] - unit['feas_min'])\n            p_outputs[idx] -= delta\n            residual += delta\n    \n    # Assign final outputs\n    for idx, unit in enumerate(committed_units):\n        unit['p_i'] = p_outputs[idx]\n    for unit in units:\n        if unit not in committed_units:\n            unit['p_i'] = 0.0\n    \n    # Create output array\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0022701099,
     "gap_price_rate": 0.0083693391,
     "fitness": 0.0053197245
}