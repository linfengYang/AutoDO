{
     "name": "enhanced_hybrid_rolling_commitment",
     "algorithm": null,
     "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    units = units_info.copy()\n    current_load = load[0]\n    forecast_load = load[1]\n    required_capacity = max(current_load, forecast_load) * 1.1\n    \n    must_on_units = []\n    must_off_units = []\n    flexible_units = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on_units.append(unit)\n                continue\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off_units.append(unit)\n                continue\n        flexible_units.append(unit)\n    \n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n        \n    for unit in must_on_units:\n        unit['u_i'] = 1\n        \n    total_capacity = sum(unit['p_max_i'] for unit in must_on_units)\n    \n    def calculate_cost(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible_units.sort(key=calculate_cost)\n    \n    for unit in flexible_units:\n        if total_capacity < required_capacity:\n            unit['u_i'] = 1\n            total_capacity += unit['p_max_i']\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n            \n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        \n    total_min = sum(unit['lb'] for unit in committed_units)\n    total_max = sum(unit['ub'] for unit in committed_units)\n    \n    if total_min > current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        excess = total_min - current_load\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['lb'], reverse=True):\n            reduction = min(excess, unit['p_i'] - unit['lb'])\n            unit['p_i'] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n    elif total_max < current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['ub']\n        deficit = current_load - total_max\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['ub']):\n            addition = min(deficit, unit['ub'] - unit['p_i'])\n            unit['p_i'] += addition\n            deficit -= addition\n            if deficit <= 0:\n                break\n    else:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        remaining = current_load - total_min\n        \n        while remaining > 0:\n            candidates = []\n            for unit in committed_units:\n                if unit['p_i'] < unit['ub']:\n                    inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((inc_cost, unit))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            best_unit = candidates[0][1]\n            add_cap = min(remaining, best_unit['ub'] - best_unit['p_i'])\n            best_unit['p_i'] += add_cap\n            remaining -= add_cap\n            \n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0.0\n            \n    u_i_list = [unit['u_i'] for unit in units]\n    p_i_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_i_list, p_i_list])",
     "from": "crossover",
     "gap_power_rate": 0.0022,
     "gap_price_rate": 0.01212,
     "fitness": 0.00716
}