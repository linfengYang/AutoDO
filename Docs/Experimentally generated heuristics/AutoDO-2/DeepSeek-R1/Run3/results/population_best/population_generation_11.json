{
     "name": "refined_rolling_commitment_heuristic_v4",
     "algorithm": null,
     "code": "import numpy as np\n\ndef refined_rolling_commitment_heuristic_v4(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            max_avail = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * max_avail + unit['c_i'] * max_avail**2) / max_avail\n        else:\n            max_avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_per_mw = (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n        flex_costs.append((i, cost_per_mw))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                if total_capacity + max_out >= current_load or forecast_load > total_capacity:\n                    u[i] = 1\n                    total_capacity += max_out\n                    \n    elif need_less:\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:\n                unit = units_info[i]\n                if forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    remaining_load = current_load\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    while abs(remaining_load) > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                min_p = unit['p_min_i']\n                \n            if remaining_load > 0 and current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n            elif remaining_load < 0 and current_p > min_p:\n                dec_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if dec_cost < best_cost:\n                    best_cost = dec_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            min_p = unit['p_min_i']\n            \n        if remaining_load > 0:\n            addable = min(remaining_load, max_p - p[best_index])\n            p[best_index] += addable\n            remaining_load -= addable\n        else:\n            reducible = min(-remaining_load, p[best_index] - min_p)\n            p[best_index] -= reducible\n            remaining_load += reducible\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n        else:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                p[i] = min(p[i], unit['p_start_i'])\n            elif u[i] == 0 and unit['u_i_0'] == 1:\n                p[i] = min(p[i], unit['p_shut_i'])\n    \n    return np.array([u, p])\n",
     "from": "mutation",
     "gap_power_rate": 0.00311,
     "gap_price_rate": 0.00806,
     "fitness": 0.00558
}