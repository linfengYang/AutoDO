{
     "name": "enhanced_rolling_commitment_heuristic",
     "algorithm": null,
     "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays for commitment and output\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units based on constraints\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    # Calculate available capacity from must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    # Determine need for flexible units\n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    # Prioritize flexible units based on composite cost metric\n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                   unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        flex_costs.append((i, avg_cost))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    # Commit flexible units if needed\n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:  # If off, consider turning on\n                u[i] = 1\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                total_capacity += max_out\n                \n    elif need_less:\n        # Consider turning off flexible units\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:  # If on, consider turning off\n                unit = units_info[i]\n                # Check if cost of running at min is less than startup cost\n                cost_run = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i'] ** 2)\n                if cost_run >= unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    # Economic dispatch for committed units\n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    # Initialize outputs to minimum possible\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    # Distribute remaining load based on incremental cost\n    while remaining_load > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate maximum possible output\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        addable = min(remaining_load, max_p - p[best_index])\n        p[best_index] += addable\n        remaining_load -= addable\n    \n    # Ensure feasibility for next period\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            p[i] = min(p[i], unit['p_start_i'])\n        if unit['u_i_0'] == 1 and u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
     "from": "crossover",
     "gap_power_rate": 0.00447,
     "gap_price_rate": 0.01366,
     "fitness": 0.00907
}