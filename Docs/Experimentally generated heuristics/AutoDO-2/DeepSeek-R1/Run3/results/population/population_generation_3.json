[
     {
          "name": "enhanced_rolling_commitment_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays for commitment and output\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units based on constraints\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    # Calculate available capacity from must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    # Determine need for flexible units\n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    # Prioritize flexible units based on composite cost metric\n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                   unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        flex_costs.append((i, avg_cost))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    # Commit flexible units if needed\n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:  # If off, consider turning on\n                u[i] = 1\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                total_capacity += max_out\n                \n    elif need_less:\n        # Consider turning off flexible units\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:  # If on, consider turning off\n                unit = units_info[i]\n                # Check if cost of running at min is less than startup cost\n                cost_run = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i'] ** 2)\n                if cost_run >= unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    # Economic dispatch for committed units\n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    # Initialize outputs to minimum possible\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    # Distribute remaining load based on incremental cost\n    while remaining_load > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate maximum possible output\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        addable = min(remaining_load, max_p - p[best_index])\n        p[best_index] += addable\n        remaining_load -= addable\n    \n    # Ensure feasibility for next period\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            p[i] = min(p[i], unit['p_start_i'])\n        if unit['u_i_0'] == 1 and u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00447,
          "gap_price_rate": 0.01366,
          "fitness": 0.00907
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_run = [False] * n_units\n    candidate_on = []\n    candidate_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                candidate_off.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_on.append(i)\n    \n    def avg_cost(unit, include_startup):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max ** 2\n        if include_startup:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_on_sorted = sorted(\n        [(i, avg_cost(units_info[i], True)) for i in candidate_on],\n        key=lambda x: x[1]\n    )\n    \n    committed = must_run[:]\n    total_max = 0.0\n    max_outputs = [0.0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_outputs[i]\n    \n    for i, _ in candidate_on_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_outputs[i]\n        committed[i] = True\n    \n    non_must_run = [i for i in range(n_units) if committed[i] and not must_run[i]]\n    non_must_run_sorted = sorted(\n        [(i, avg_cost(units_info[i], False)) for i in non_must_run],\n        key=lambda x: x[1],\n        reverse=True\n    )\n    \n    for i, _ in non_must_run_sorted:\n        temp_max = total_max - max_outputs[i]\n        if temp_max >= current_load:\n            committed[i] = False\n            total_max = temp_max\n            max_outputs[i] = 0.0\n    \n    p_outputs = [0.0] * n_units\n    total_min = 0.0\n    min_outputs = [0.0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_outputs[i] = unit['p_min_i']\n            p_outputs[i] = min_outputs[i]\n            total_min += min_outputs[i]\n    \n    if total_min > current_load:\n        for i in range(n_units):\n            if committed[i]:\n                p_outputs[i] = min_outputs[i]\n    else:\n        dispatch_units = []\n        for i in range(n_units):\n            if committed[i]:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    high_bound = min(unit['p_max_i'], unit['p_start_i'])\n                dispatch_units.append({\n                    'index': i,\n                    'b': unit['b_i'],\n                    'c': unit['c_i'],\n                    'current': p_outputs[i],\n                    'high': high_bound,\n                    'ic': 0.0\n                })\n        \n        remaining_load = current_load - total_min\n        while remaining_load > 1e-6 and dispatch_units:\n            for u in dispatch_units:\n                u['ic'] = u['b'] + 2 * u['c'] * u['current']\n            dispatch_units.sort(key=lambda x: x['ic'])\n            \n            updated = False\n            for u in dispatch_units:\n                if u['current'] < u['high']:\n                    increase = min(remaining_load, u['high'] - u['current'])\n                    u['current'] += increase\n                    remaining_load -= increase\n                    updated = True\n                    break\n            \n            if not updated:\n                break\n        \n        for u in dispatch_units:\n            p_outputs[u['index']] = u['current']\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n    \n    return schedules\n",
          "from": "mutation",
          "gap_power_rate": 0.00685,
          "gap_price_rate": 0.01195,
          "fitness": 0.0094
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "commit_units_rolling_heuristic_improved",
          "algorithm": "This improved heuristic considers both current and forecasted loads when making commitment decisions. It first identifies must-run/must-off units based on physical constraints, then commits additional units sorted by average full-load cost (including startup costs for offline units). It uses a two-stage approach: first ensuring sufficient capacity for current load, then checking forecasted load needs. Economic dispatch is performed using incremental cost sorting with capacity limits adjusted for ramp constraints.\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic_improved(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current and forecast capacity\n    total_min_current = 0\n    total_max_current = 0\n    total_max_forecast = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p_current = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n    \n    # Sort offline units by average cost\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + \n        (units[i]['s_i'] if units[i]['u_i_0'] == 0 else 0)\n    ) / units[i]['p_max_i'])\n    \n    # Commit for current load\n    idx = 0\n    while total_max_current < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        unit = units[i]\n        u[i] = 1\n        min_p = unit['p_min_i']\n        max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n        online_units.append(i)\n        idx += 1\n    \n    # Commit for forecasted load\n    while idx < len(offline_units_sorted) and total_max_forecast < forecast_load:\n        i = offline_units_sorted[idx]\n        unit = units[i]\n        u[i] = 1\n        min_p = unit['p_min_i']\n        max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit excess units\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min_current > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min_current - min_p >= current_load:\n            u[i] = 0\n            total_min_current -= min_p\n            total_max_current -= (min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) \n                                if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i']))\n            total_max_forecast -= unit['p_max_i']\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    new_inc_cost = (units[committed_indices[idx]]['b_i'] + \n                                  2 * units[committed_indices[idx]]['c_i'] * allocations[idx])\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00517,
          "gap_price_rate": 0.01585,
          "fitness": 0.01051
     },
     {
          "name": "enhanced_rolling_commitment_heuristic_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units based on constraints\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_run.append(i)\n        elif unit['u_i_0'] == 0 and unit['t_i_0'] > -unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initial commitment\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Calculate available capacity\n    total_max = sum(unit['p_max_i'] for i, unit in enumerate(units_info) if u[i] == 1)\n    total_min = sum(unit['p_min_i'] for i, unit in enumerate(units_info) if u[i] == 1)\n    \n    # Adjust commitment based on forecast\n    if total_max < max(current_load, forecast_load):\n        candidates = [i for i in flexible if u[i] == 0]\n        # Sort by cost-effectiveness including startup cost\n        candidates.sort(key=lambda i: (units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_max_i'] + \n                                     units_info[i]['s_i']/max(units_info[i]['p_max_i'], 1e-6)))\n        for i in candidates:\n            if total_max >= max(current_load, forecast_load):\n                break\n            u[i] = 1\n            total_max += units_info[i]['p_max_i']\n            total_min += units_info[i]['p_min_i']\n    \n    if total_min > min(current_load, forecast_load):\n        candidates = [i for i in flexible if u[i] == 1]\n        # Sort by decreasing cost savings\n        candidates.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_min_i'], reverse=True)\n        for i in candidates:\n            if total_min <= min(current_load, forecast_load):\n                break\n            u[i] = 0\n            total_max -= units_info[i]['p_max_i']\n            total_min -= units_info[i]['p_min_i']\n    \n    # Calculate output limits with ramp constraints\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_output[i] = unit['p_min_i']\n                max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_output[i] = 0\n            max_output[i] = 0\n    \n    # Initialize outputs\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_output[i]\n    \n    # Dispatch remaining load\n    remaining_load = current_load - sum(p)\n    committed = [i for i in range(n_units) if u[i] == 1 and p[i] < max_output[i]]\n    # Sort by incremental cost\n    committed.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i])\n    \n    for i in committed:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, max_output[i] - p[i])\n        p[i] += allocatable\n        remaining_load -= allocatable\n    \n    return np.array([u, p])\n",
          "from": "mutation",
          "gap_power_rate": 0.00769,
          "gap_price_rate": 0.01437,
          "fitness": 0.01103
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_feasible = []\n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        lower_bound = max(p_min, p_i0 - p_down)\n        upper_bound = min(p_max, p_i0 + p_up)\n        must_run_feasible.append((lower_bound, upper_bound))\n        u[i] = 1\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    total_must_run_min = sum([feasible[0] for feasible in must_run_feasible])\n    total_must_run_max = sum([feasible[1] for feasible in must_run_feasible])\n    \n    if current_load > total_must_run_max:\n        flexible_units_info = []\n        for i in flexible:\n            if units_info[i]['u_i_0'] == 0:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i']\n                flexible_units_info.append((i, inc_cost, 'off'))\n        flexible_units_info.sort(key=lambda x: x[1])\n        \n        total_capacity = total_must_run_max\n        for (i, inc_cost, status) in flexible_units_info:\n            if total_capacity >= current_load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            p_i0 = unit['p_i_0']\n            p_up = unit['p_up_i']\n            upper_bound = min(p_max, p_start, p_i0 + p_up)\n            total_capacity += upper_bound\n    elif current_load < total_must_run_min:\n        for idx, i in enumerate(must_run):\n            p[i] = must_run_feasible[idx][0]\n        for i in flexible:\n            if units_info[i]['u_i_0'] == 1:\n                u[i] = 0\n                p[i] = 0\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    feasible_ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            lower_bound = p_min\n            upper_bound = min(p_max, unit['p_start_i'], p_i0 + p_up)\n        else:\n            lower_bound = max(p_min, p_i0 - p_down)\n            upper_bound = min(p_max, p_i0 + p_up)\n        feasible_ranges.append((lower_bound, upper_bound))\n    \n    total_output = 0\n    for idx, i in enumerate(committed_indices):\n        p[i] = feasible_ranges[idx][0]\n        total_output += p[i]\n    \n    while total_output < current_load and any(p[i] < feasible_ranges[idx][1] for idx, i in enumerate(committed_indices)):\n        min_inc_cost = float('inf')\n        candidate_index = None\n        for idx, i in enumerate(committed_indices):\n            if p[i] < feasible_ranges[idx][1]:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if inc_cost < min_inc_cost:\n                    min_inc_cost = inc_cost\n                    candidate_index = (idx, i)\n        if candidate_index is None:\n            break\n        idx, i = candidate_index\n        deficit = current_load - total_output\n        available_increase = feasible_ranges[idx][1] - p[i]\n        increase = min(deficit, available_increase)\n        p[i] += increase\n        total_output += increase\n    \n    while total_output > current_load and any(p[i] > feasible_ranges[idx][0] for idx, i in enumerate(committed_indices)):\n        max_inc_cost = -float('inf')\n        candidate_index = None\n        for idx, i in enumerate(committed_indices):\n            if p[i] > feasible_ranges[idx][0]:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if inc_cost > max_inc_cost:\n                    max_inc_cost = inc_cost\n                    candidate_index = (idx, i)\n        if candidate_index is None:\n            break\n        idx, i = candidate_index\n        surplus = total_output - current_load\n        available_decrease = p[i] - feasible_ranges[idx][0]\n        decrease = min(surplus, available_decrease)\n        p[i] -= decrease\n        total_output -= decrease\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00927,
          "gap_price_rate": 0.01393,
          "fitness": 0.0116
     },
     {
          "name": "enhanced_rolling_commitment_heuristic_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    avg_cost = []\n    for unit in units_info:\n        full_load_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i'] ** 2\n        if unit['u_i_0'] == 0:\n            full_load_cost += unit['s_i']\n        avg_cost.append(full_load_cost / unit['p_max_i'])\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n                \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        if must_off[i]:\n            u[i] = 0\n            \n    max_output = [0] * n_units\n    min_output = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n                min_output[i] = unit['p_min_i']\n                \n    total_max = sum(max_output)\n    required = max(current_load, forecast_load)\n    \n    candidate_units = []\n    for i in range(n_units):\n        if not must_run[i] and not must_off[i] and u[i] == 0:\n            candidate_units.append(i)\n            \n    candidate_units.sort(key=lambda i: avg_cost[i])\n    \n    for i in candidate_units:\n        if total_max >= required:\n            break\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        max_output[i] = max_i\n        total_max += max_i\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            min_i = unit['p_min_i']\n        min_output[i] = min_i\n        \n    total_min = sum(min_output)\n    if total_min > current_load:\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n    else:\n        remaining = current_load - total_min\n        for i in range(n_units):\n            if u[i] == 1:\n                p[i] = min_output[i]\n                \n        committed_indices = [i for i in range(n_units) if u[i] == 1]\n        while remaining > 0:\n            min_inc = float('inf')\n            best_i = None\n            for i in committed_indices:\n                if p[i] < max_output[i]:\n                    inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if inc_cost < min_inc:\n                        min_inc = inc_cost\n                        best_i = i\n            if best_i is None:\n                break\n                \n            increase = min(remaining, max_output[best_i] - p[best_i])\n            p[best_i] += increase\n            remaining -= increase\n            \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00212,
          "gap_price_rate": 0.02163,
          "fitness": 0.01188
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": "This refined heuristic first classifies units into must-on, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints. It then commits must-on units and sorts flexible units by average cost at minimum output. The algorithm commits flexible units until total maximum capacity meets current load while considering forecasted load for next period. Finally, it performs economic dispatch using incremental cost sorting with continuous updates to respect output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_on.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_on:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n        \n    total_min = sum(unit['p_min_i'] for unit in must_on)\n    total_max = sum(unit['p_max_i'] for unit in must_on)\n    \n    def cost_per_mw(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_per_mw)\n    \n    committed = must_on.copy()\n    for unit in flexible:\n        if total_max >= current_load and total_max >= next_load:\n            break\n        unit['u_i'] = 1\n        committed.append(unit)\n        total_max += unit['p_max_i']\n    \n    ranges = []\n    for unit in committed:\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((low, high))\n    \n    total_low = sum(low for low, high in ranges)\n    total_high = sum(high for low, high in ranges)\n    \n    p_values = [low for low, high in ranges]\n    \n    if current_load > total_high:\n        p_values = [high for low, high in ranges]\n    elif current_load < total_low:\n        p_values = [low for low, high in ranges]\n    else:\n        current_total = total_low\n        inc_units = []\n        for i, unit in enumerate(committed):\n            inc_units.append({\n                'idx': i,\n                'p': p_values[i],\n                'low': ranges[i][0],\n                'high': ranges[i][1],\n                'b': unit['b_i'],\n                'c': unit['c_i']\n            })\n        \n        while abs(current_total - current_load) > 1e-5 and current_total < current_load:\n            min_inc = float('inf')\n            best_idx = None\n            for u in inc_units:\n                if u['p'] < u['high']:\n                    inc_cost = u['b'] + 2 * u['c'] * u['p']\n                    if inc_cost < min_inc:\n                        min_inc = inc_cost\n                        best_idx = u['idx']\n            if best_idx is None:\n                break\n                \n            u = inc_units[best_idx]\n            max_add = min(u['high'] - u['p'], current_load - current_total)\n            u['p'] += max_add\n            current_total += max_add\n    \n        for u in inc_units:\n            p_values[u['idx']] = u['p']\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = p_values[i]\n    \n    for unit in must_off:\n        unit['p_i'] = 0\n    for unit in flexible:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_list, p_list])\n",
          "from": "mutation",
          "gap_power_rate": 0.00872,
          "gap_price_rate": 0.01545,
          "fitness": 0.01209
     }
]