[
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "commit_units_rolling_heuristic_improved",
          "algorithm": "This improved heuristic considers both current and forecasted loads when making commitment decisions. It first identifies must-run/must-off units based on physical constraints, then commits additional units sorted by average full-load cost (including startup costs for offline units). It uses a two-stage approach: first ensuring sufficient capacity for current load, then checking forecasted load needs. Economic dispatch is performed using incremental cost sorting with capacity limits adjusted for ramp constraints.\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic_improved(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current and forecast capacity\n    total_min_current = 0\n    total_max_current = 0\n    total_max_forecast = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p_current = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n    \n    # Sort offline units by average cost\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + \n        (units[i]['s_i'] if units[i]['u_i_0'] == 0 else 0)\n    ) / units[i]['p_max_i'])\n    \n    # Commit for current load\n    idx = 0\n    while total_max_current < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        unit = units[i]\n        u[i] = 1\n        min_p = unit['p_min_i']\n        max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n        online_units.append(i)\n        idx += 1\n    \n    # Commit for forecasted load\n    while idx < len(offline_units_sorted) and total_max_forecast < forecast_load:\n        i = offline_units_sorted[idx]\n        unit = units[i]\n        u[i] = 1\n        min_p = unit['p_min_i']\n        max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit excess units\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min_current > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min_current - min_p >= current_load:\n            u[i] = 0\n            total_min_current -= min_p\n            total_max_current -= (min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) \n                                if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i']))\n            total_max_forecast -= unit['p_max_i']\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    new_inc_cost = (units[committed_indices[idx]]['b_i'] + \n                                  2 * units[committed_indices[idx]]['c_i'] * allocations[idx])\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00517,
          "gap_price_rate": 0.01585,
          "fitness": 0.01051
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_feasible = []\n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        lower_bound = max(p_min, p_i0 - p_down)\n        upper_bound = min(p_max, p_i0 + p_up)\n        must_run_feasible.append((lower_bound, upper_bound))\n        u[i] = 1\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    total_must_run_min = sum([feasible[0] for feasible in must_run_feasible])\n    total_must_run_max = sum([feasible[1] for feasible in must_run_feasible])\n    \n    if current_load > total_must_run_max:\n        flexible_units_info = []\n        for i in flexible:\n            if units_info[i]['u_i_0'] == 0:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i']\n                flexible_units_info.append((i, inc_cost, 'off'))\n        flexible_units_info.sort(key=lambda x: x[1])\n        \n        total_capacity = total_must_run_max\n        for (i, inc_cost, status) in flexible_units_info:\n            if total_capacity >= current_load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            p_i0 = unit['p_i_0']\n            p_up = unit['p_up_i']\n            upper_bound = min(p_max, p_start, p_i0 + p_up)\n            total_capacity += upper_bound\n    elif current_load < total_must_run_min:\n        for idx, i in enumerate(must_run):\n            p[i] = must_run_feasible[idx][0]\n        for i in flexible:\n            if units_info[i]['u_i_0'] == 1:\n                u[i] = 0\n                p[i] = 0\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    feasible_ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            lower_bound = p_min\n            upper_bound = min(p_max, unit['p_start_i'], p_i0 + p_up)\n        else:\n            lower_bound = max(p_min, p_i0 - p_down)\n            upper_bound = min(p_max, p_i0 + p_up)\n        feasible_ranges.append((lower_bound, upper_bound))\n    \n    total_output = 0\n    for idx, i in enumerate(committed_indices):\n        p[i] = feasible_ranges[idx][0]\n        total_output += p[i]\n    \n    while total_output < current_load and any(p[i] < feasible_ranges[idx][1] for idx, i in enumerate(committed_indices)):\n        min_inc_cost = float('inf')\n        candidate_index = None\n        for idx, i in enumerate(committed_indices):\n            if p[i] < feasible_ranges[idx][1]:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if inc_cost < min_inc_cost:\n                    min_inc_cost = inc_cost\n                    candidate_index = (idx, i)\n        if candidate_index is None:\n            break\n        idx, i = candidate_index\n        deficit = current_load - total_output\n        available_increase = feasible_ranges[idx][1] - p[i]\n        increase = min(deficit, available_increase)\n        p[i] += increase\n        total_output += increase\n    \n    while total_output > current_load and any(p[i] > feasible_ranges[idx][0] for idx, i in enumerate(committed_indices)):\n        max_inc_cost = -float('inf')\n        candidate_index = None\n        for idx, i in enumerate(committed_indices):\n            if p[i] > feasible_ranges[idx][0]:\n                inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if inc_cost > max_inc_cost:\n                    max_inc_cost = inc_cost\n                    candidate_index = (idx, i)\n        if candidate_index is None:\n            break\n        idx, i = candidate_index\n        surplus = total_output - current_load\n        available_decrease = p[i] - feasible_ranges[idx][0]\n        decrease = min(surplus, available_decrease)\n        p[i] -= decrease\n        total_output -= decrease\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00927,
          "gap_price_rate": 0.01393,
          "fitness": 0.0116
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": "This refined heuristic first classifies units into must-on, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints. It then commits must-on units and sorts flexible units by average cost at minimum output. The algorithm commits flexible units until total maximum capacity meets current load while considering forecasted load for next period. Finally, it performs economic dispatch using incremental cost sorting with continuous updates to respect output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_on.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_on:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n        \n    total_min = sum(unit['p_min_i'] for unit in must_on)\n    total_max = sum(unit['p_max_i'] for unit in must_on)\n    \n    def cost_per_mw(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_per_mw)\n    \n    committed = must_on.copy()\n    for unit in flexible:\n        if total_max >= current_load and total_max >= next_load:\n            break\n        unit['u_i'] = 1\n        committed.append(unit)\n        total_max += unit['p_max_i']\n    \n    ranges = []\n    for unit in committed:\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((low, high))\n    \n    total_low = sum(low for low, high in ranges)\n    total_high = sum(high for low, high in ranges)\n    \n    p_values = [low for low, high in ranges]\n    \n    if current_load > total_high:\n        p_values = [high for low, high in ranges]\n    elif current_load < total_low:\n        p_values = [low for low, high in ranges]\n    else:\n        current_total = total_low\n        inc_units = []\n        for i, unit in enumerate(committed):\n            inc_units.append({\n                'idx': i,\n                'p': p_values[i],\n                'low': ranges[i][0],\n                'high': ranges[i][1],\n                'b': unit['b_i'],\n                'c': unit['c_i']\n            })\n        \n        while abs(current_total - current_load) > 1e-5 and current_total < current_load:\n            min_inc = float('inf')\n            best_idx = None\n            for u in inc_units:\n                if u['p'] < u['high']:\n                    inc_cost = u['b'] + 2 * u['c'] * u['p']\n                    if inc_cost < min_inc:\n                        min_inc = inc_cost\n                        best_idx = u['idx']\n            if best_idx is None:\n                break\n                \n            u = inc_units[best_idx]\n            max_add = min(u['high'] - u['p'], current_load - current_total)\n            u['p'] += max_add\n            current_total += max_add\n    \n        for u in inc_units:\n            p_values[u['idx']] = u['p']\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = p_values[i]\n    \n    for unit in must_off:\n        unit['p_i'] = 0\n    for unit in flexible:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_list, p_list])\n",
          "from": "mutation",
          "gap_power_rate": 0.00872,
          "gap_price_rate": 0.01545,
          "fitness": 0.01209
     },
     {
          "name": "novel_rolling_commitment_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef novel_rolling_commitment_heuristic(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    current_load, next_load = load\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for unit in must_off:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    total_min = sum(unit.get('min_p', 0) for unit in must_run)\n    total_max = sum(unit.get('max_p', 0) for unit in must_run)\n    \n    for unit in flexible:\n        cost_per_mw = ((unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + \n                       unit['a_i'] + unit['s_i'] / unit['t_on_min_i']) / unit['p_min_i'])\n        lookahead_penalty = max(0, next_load - total_max) / current_load\n        unit['priority'] = cost_per_mw * (1 + lookahead_penalty)\n    \n    flexible.sort(key=lambda x: x['priority'])\n    \n    for unit in flexible:\n        if total_max < current_load:\n            unit['u_i'] = 1\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            unit['min_p'] = min_p\n            unit['max_p'] = max_p\n            total_min += min_p\n            total_max += max_p\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    committed = [u for u in must_run + flexible if u['u_i'] == 1]\n    for unit in committed:\n        unit['p_i'] = unit['min_p']\n    \n    remaining = current_load - sum(u['p_i'] for u in committed)\n    committed.sort(key=lambda x: 2 * x['c_i'] * x['p_i'] + x['b_i'])\n    \n    for unit in committed:\n        if remaining <= 0:\n            break\n        allocatable = min(unit['max_p'] - unit['p_i'], remaining)\n        unit['p_i'] += allocatable\n        remaining -= allocatable\n    \n    u_list = [unit.get('u_i', 0) for unit in units]\n    p_list = [unit.get('p_i', 0) for unit in units]\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.00672,
          "gap_price_rate": 0.01925,
          "fitness": 0.01298
     },
     {
          "name": "novel_heuristic_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef novel_heuristic_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_run.append(i)\n        elif unit['u_i_0'] == 0 and unit['t_i_0'] > -unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in flexible:\n        u[i] = units_info[i]['u_i_0']\n    \n    total_max = sum(unit['p_max_i'] for i, unit in enumerate(units_info) if u[i] == 1)\n    total_min = sum(unit['p_min_i'] for i, unit in enumerate(units_info) if u[i] == 1)\n    \n    if total_max < current_load:\n        flexible_off = [i for i in flexible if u[i] == 0]\n        flexible_off.sort(key=lambda i: (units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_max_i'] + \n                                        units_info[i]['s_i']/units_info[i]['p_max_i']))\n        for i in flexible_off:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            total_max += units_info[i]['p_max_i']\n            total_min += units_info[i]['p_min_i']\n    \n    if total_min > current_load:\n        flexible_on = [i for i in flexible if u[i] == 1]\n        flexible_on.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_min_i'], reverse=True)\n        for i in flexible_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= units_info[i]['p_min_i']\n    \n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                min_output[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                min_output[i] = units_info[i]['p_min_i']\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            min_output[i] = 0\n            max_output[i] = 0\n    \n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = min_output[i]\n    \n    remaining_load = current_load - sum(p)\n    committed_indices = [i for i in range(n_units) if u[i] == 1 and p[i] < max_output[i]]\n    committed_indices.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i])\n    \n    for i in committed_indices:\n        if remaining_load <= 0:\n            break\n        available = max_output[i] - p[i]\n        if remaining_load <= available:\n            p[i] += remaining_load\n            break\n        else:\n            p[i] = max_output[i]\n            remaining_load -= available\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.01988,
          "gap_price_rate": 0.02874,
          "fitness": 0.02431
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n  2. Initialize commitment states for must-run (on), must-off (off), and flexible (maintain current state)\n  3. Adjust commitment for flexible units if needed: turn on additional units by full-load average cost if undercommitted, turn off flexible units by average cost if overcommitted\n  4. Perform constrained economic dispatch using incremental cost sorting to allocate load within ramp and output limits\n  5. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    min_up = [u['t_on_min_i'] for u in units_info]\n    min_down = [u['t_off_min_i'] for u in units_info]\n    startup_cost = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    \n    # Initialize arrays\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    # Classify units\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if abs(t_prev[i]) < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    for i in range(n_units):\n        if must_run[i]:\n            u_current[i] = 1\n        elif must_off[i]:\n            u_current[i] = 0\n        else:\n            u_current[i] = u_prev[i]\n    \n    # Calculate available capacity for committed units\n    min_outputs = [0] * n_units\n    max_outputs = [0] * n_units\n    for i in range(n_units):\n        if u_current[i] == 1:\n            if u_prev[i] == 1:\n                min_outputs[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_outputs[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_outputs[i] = p_min[i]\n                max_outputs[i] = min(p_max[i], p_start[i])\n        else:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    total_min = sum(min_outputs)\n    total_max = sum(max_outputs)\n    \n    # Adjust commitment if needed\n    committed_indices = [i for i in range(n_units) if u_current[i] == 1]\n    flexible_off = [i for i in range(n_units) if not must_run[i] and not must_off[i] and u_current[i] == 0]\n    flexible_on = [i for i in range(n_units) if not must_run[i] and u_current[i] == 1]\n    \n    # Under-commitment case\n    if total_max < current_load:\n        # Sort by full-load average cost including startup\n        costs = []\n        for i in flexible_off:\n            avg_cost = (a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2) + startup_cost[i]) / p_max[i]\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1])\n        \n        for i, _ in costs:\n            if total_max >= current_load:\n                break\n            u_current[i] = 1\n            min_outputs[i] = p_min[i]\n            max_outputs[i] = min(p_max[i], p_start[i])\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            flexible_on.append(i)\n    \n    # Over-commitment case\n    if total_min > current_load:\n        # Sort by average cost at min output\n        costs = []\n        for i in flexible_on:\n            cost_val = a[i] + b[i]*min_outputs[i] + c[i]*(min_outputs[i]**2)\n            avg_cost = cost_val / min_outputs[i] if min_outputs[i] > 0 else float('inf')\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in costs:\n            if total_min <= current_load:\n                break\n            u_current[i] = 0\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    # Economic dispatch\n    committed_idx = [i for i in range(n_units) if u_current[i] == 1]\n    # Set initial output to min\n    for i in committed_idx:\n        p_current[i] = min_outputs[i]\n    \n    remaining_load = current_load - sum(min_outputs)\n    # Calculate incremental costs\n    inc_costs = []\n    for i in committed_idx:\n        inc_cost = b[i] + 2*c[i]*min_outputs[i]\n        inc_costs.append((i, inc_cost))\n    inc_costs.sort(key=lambda x: x[1])\n    \n    # Distribute remaining load\n    for i, _ in inc_costs:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, max_outputs[i] - min_outputs[i])\n        p_current[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Format output\n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.0515,
          "fitness": 0.02584
     },
     {
          "name": "novel_heuristic_commitment",
          "algorithm": "This heuristic first identifies must-on and must-off units based on minimum up/down times and shutdown ramp constraints. Then, it sorts flexible units by average cost at minimum output (including startup cost if applicable) and commits flexible units until total maximum capacity meets the load. Finally, it performs economic dispatch using incremental cost sorting while respecting output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef novel_heuristic_commitment(units_info, load):\n    current_load = load[0]\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_on.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_on:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n        \n    total_min = sum(unit['p_min_i'] for unit in must_on)\n    total_max = sum(unit['p_max_i'] for unit in must_on)\n    \n    def cost_per_mw(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_per_mw)\n    \n    committed = must_on.copy()\n    for unit in flexible:\n        if total_max >= current_load:\n            break\n        unit['u_i'] = 1\n        committed.append(unit)\n        total_max += unit['p_max_i']\n    \n    ranges = []\n    for unit in committed:\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((low, high))\n    \n    total_low = sum(low for low, high in ranges)\n    total_high = sum(high for low, high in ranges)\n    \n    p_values = [low for low, high in ranges]\n    \n    if current_load > total_high:\n        p_values = [high for low, high in ranges]\n    elif current_load < total_low:\n        p_values = [low for low, high in ranges]\n    else:\n        current_total = total_low\n        inc_units = []\n        for i, unit in enumerate(committed):\n            inc_units.append({\n                'idx': i,\n                'p': p_values[i],\n                'low': ranges[i][0],\n                'high': ranges[i][1],\n                'b': unit['b_i'],\n                'c': unit['c_i']\n            })\n        \n        while current_total < current_load:\n            min_inc = float('inf')\n            best_idx = None\n            for u in inc_units:\n                if u['p'] < u['high']:\n                    inc_cost = u['b'] + 2 * u['c'] * u['p']\n                    if inc_cost < min_inc:\n                        min_inc = inc_cost\n                        best_idx = u['idx']\n            if best_idx is None:\n                break\n                \n            u = inc_units[best_idx]\n            max_add = min(u['high'] - u['p'], current_load - current_total)\n            u['p'] += max_add\n            current_total += max_add\n    \n        for u in inc_units:\n            p_values[u['idx']] = u['p']\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = p_values[i]\n    \n    for unit in must_off:\n        unit['p_i'] = 0\n    for unit in flexible:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.02545,
          "gap_price_rate": 0.02724,
          "fitness": 0.02635
     }
]