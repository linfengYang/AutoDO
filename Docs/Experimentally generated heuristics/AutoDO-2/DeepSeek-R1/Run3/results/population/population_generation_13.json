[
     {
          "name": "refined_rolling_commitment_heuristic_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_commitment_heuristic_v4(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            max_avail = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * max_avail + unit['c_i'] * max_avail**2) / max_avail\n        else:\n            max_avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_per_mw = (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n        flex_costs.append((i, cost_per_mw))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                if total_capacity + max_out >= current_load or forecast_load > total_capacity:\n                    u[i] = 1\n                    total_capacity += max_out\n                    \n    elif need_less:\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:\n                unit = units_info[i]\n                if forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    remaining_load = current_load\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    while abs(remaining_load) > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                min_p = unit['p_min_i']\n                \n            if remaining_load > 0 and current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n            elif remaining_load < 0 and current_p > min_p:\n                dec_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if dec_cost < best_cost:\n                    best_cost = dec_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            min_p = unit['p_min_i']\n            \n        if remaining_load > 0:\n            addable = min(remaining_load, max_p - p[best_index])\n            p[best_index] += addable\n            remaining_load -= addable\n        else:\n            reducible = min(-remaining_load, p[best_index] - min_p)\n            p[best_index] -= reducible\n            remaining_load += reducible\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n        else:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                p[i] = min(p[i], unit['p_start_i'])\n            elif u[i] == 0 and unit['u_i_0'] == 1:\n                p[i] = min(p[i], unit['p_shut_i'])\n    \n    return np.array([u, p])\n",
          "from": "mutation",
          "gap_power_rate": 0.00311,
          "gap_price_rate": 0.00806,
          "fitness": 0.00558
     },
     {
          "name": "refined_rolling_commitment_heuristic_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_commitment_heuristic_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        max_avail = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * max_avail + unit['c_i'] * max_avail**2) / max_avail if max_avail > 0 else float('inf')\n        flex_costs.append((i, cost_per_mw))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                if total_capacity + max_out >= current_load or forecast_load > total_capacity + max_out:\n                    u[i] = 1\n                    total_capacity += max_out\n                    \n    elif need_less:\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:\n                unit = units_info[i]\n                cost_run = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n                if cost_run > unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    while abs(remaining_load) > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                \n            if remaining_load > 0 and current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n            elif remaining_load < 0 and current_p > unit['p_min_i']:\n                dec_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if dec_cost < best_cost:\n                    best_cost = dec_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            \n        if remaining_load > 0:\n            addable = min(remaining_load, max_p - p[best_index])\n            p[best_index] += addable\n            remaining_load -= addable\n        else:\n            reducible = min(-remaining_load, p[best_index] - unit['p_min_i'])\n            p[best_index] -= reducible\n            remaining_load += reducible\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n        else:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                p[i] = min(p[i], unit['p_start_i'])\n            if u[i] == 0 and unit['u_i_0'] == 1:\n                p[i] = min(p[i], unit['p_shut_i'])\n    \n    return np.array([u, p])\n",
          "from": "mutation",
          "gap_power_rate": 0.00362,
          "gap_price_rate": 0.0081,
          "fitness": 0.00586
     },
     {
          "name": "refined_rolling_commitment_heuristic_v5",
          "algorithm": "1. Classify units into must-on, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Commit must-on units and turn off must-off units\n3. Sort flexible units by full-load cost efficiency (including startup costs when applicable)\n4. Commit flexible units until meeting required capacity (110% of max(current, forecasted load))\n5. Perform economic dispatch using incremental costs while respecting ramp constraints\n6. Adjust power outputs to precisely match load using cost-based prioritization\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_heuristic_v5(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    current_load, forecast_load = load\n    required_capacity = max(current_load, forecast_load) * 1.1\n    \n    must_on_units = []\n    must_off_units = []\n    flexible_units = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_units.append(unit)\n                continue\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_units.append(unit)\n                continue\n        flexible_units.append(unit)\n    \n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n        \n    for unit in must_on_units:\n        unit['u_i'] = 1\n        \n    total_capacity = sum(unit['p_max_i'] for unit in must_on_units)\n    \n    def full_load_cost(unit):\n        base_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        return (base_cost + startup_cost) / unit['p_max_i']\n    \n    flexible_units.sort(key=full_load_cost)\n    \n    for unit in flexible_units:\n        if total_capacity < required_capacity:\n            unit['u_i'] = 1\n            total_capacity += unit['p_max_i']\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n            \n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        \n    total_min = sum(unit['lb'] for unit in committed_units)\n    total_max = sum(unit['ub'] for unit in committed_units)\n    \n    if total_min > current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        excess = total_min - current_load\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['lb'], reverse=True):\n            reduction = min(excess, unit['p_i'] - unit['lb'])\n            unit['p_i'] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n    elif total_max < current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['ub']\n        deficit = current_load - total_max\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['ub']):\n            addition = min(deficit, unit['ub'] - unit['p_i'])\n            unit['p_i'] += addition\n            deficit -= addition\n            if deficit <= 0:\n                break\n    else:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        remaining = current_load - total_min\n        \n        while remaining > 0:\n            candidates = []\n            for unit in committed_units:\n                if unit['p_i'] < unit['ub']:\n                    inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((inc_cost, unit))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            best_unit = candidates[0][1]\n            add_cap = min(remaining, best_unit['ub'] - best_unit['p_i'])\n            best_unit['p_i'] += add_cap\n            remaining -= add_cap\n            \n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0.0\n            \n    u_i_list = [unit['u_i'] for unit in units]\n    p_i_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_i_list, p_i_list])\n",
          "from": "mutation",
          "gap_power_rate": 0.00241,
          "gap_price_rate": 0.01023,
          "fitness": 0.00632
     },
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    units = units_info.copy()\n    current_load = load[0]\n    forecast_load = load[1]\n    required_capacity = max(current_load, forecast_load) * 1.1\n    \n    must_on_units = []\n    must_off_units = []\n    flexible_units = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on_units.append(unit)\n                continue\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off_units.append(unit)\n                continue\n        flexible_units.append(unit)\n    \n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n        \n    for unit in must_on_units:\n        unit['u_i'] = 1\n        \n    total_capacity = sum(unit['p_max_i'] for unit in must_on_units)\n    \n    def calculate_cost(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible_units.sort(key=calculate_cost)\n    \n    for unit in flexible_units:\n        if total_capacity < required_capacity:\n            unit['u_i'] = 1\n            total_capacity += unit['p_max_i']\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n            \n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        \n    total_min = sum(unit['lb'] for unit in committed_units)\n    total_max = sum(unit['ub'] for unit in committed_units)\n    \n    if total_min > current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        excess = total_min - current_load\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['lb'], reverse=True):\n            reduction = min(excess, unit['p_i'] - unit['lb'])\n            unit['p_i'] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n    elif total_max < current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['ub']\n        deficit = current_load - total_max\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['ub']):\n            addition = min(deficit, unit['ub'] - unit['p_i'])\n            unit['p_i'] += addition\n            deficit -= addition\n            if deficit <= 0:\n                break\n    else:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        remaining = current_load - total_min\n        \n        while remaining > 0:\n            candidates = []\n            for unit in committed_units:\n                if unit['p_i'] < unit['ub']:\n                    inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((inc_cost, unit))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            best_unit = candidates[0][1]\n            add_cap = min(remaining, best_unit['ub'] - best_unit['p_i'])\n            best_unit['p_i'] += add_cap\n            remaining -= add_cap\n            \n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0.0\n            \n    u_i_list = [unit['u_i'] for unit in units]\n    p_i_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_i_list, p_i_list])",
          "from": "crossover",
          "gap_power_rate": 0.0022,
          "gap_price_rate": 0.01212,
          "fitness": 0.00716
     },
     {
          "name": "enhanced_rolling_unit_commitment_v5",
          "algorithm": "1. Identify must-run units considering minimum up/down times and shutdown constraints\n2. Calculate adjusted minimum/maximum outputs considering ramp limits and startup/shutdown constraints\n3. Sort candidate units by incremental cost including startup considerations\n4. Commit units ensuring minimum outputs don't exceed load while meeting current demand\n5. Check next period's load forecast and commit additional units if needed for ramp capability\n6. Perform economic dispatch using incremental cost sorting with proper ramp constraint handling\n7. Ensure final solution meets all physical constraints and minimizes total cost\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_unit_commitment_v5(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Initialize arrays\n    must_run = np.zeros(n_units, dtype=bool)\n    committed = np.zeros(n_units, dtype=bool)\n    p_outputs = np.zeros(n_units)\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    # Calculate min and max outputs for each unit considering ramp constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check must-run conditions\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n                committed[i] = True\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n            # Check if unit can be started\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                committed[i] = False\n            else:\n                # Unit cannot be started due to minimum down time\n                min_outputs[i] = 0\n                max_outputs[i] = 0\n\n    # Calculate current capacity from must-run units\n    total_min = np.sum(min_outputs[must_run])\n    total_max = np.sum(max_outputs[must_run])\n    \n    # Create candidate list of non-must-run units that can be committed\n    candidate_list = []\n    for i in range(n_units):\n        if not must_run[i] and min_outputs[i] > 0:\n            # Calculate average cost including startup if needed\n            unit = units_info[i]\n            avg_cost = (unit['a_i'] + unit['b_i'] * max_outputs[i] + \n                       unit['c_i'] * max_outputs[i]**2)\n            if unit['u_i_0'] == 0:\n                avg_cost += unit['s_i']\n            avg_cost /= max_outputs[i]\n            candidate_list.append((i, avg_cost))\n    \n    # Sort candidates by average cost\n    candidate_list.sort(key=lambda x: x[1])\n    \n    # Commit units until we meet demand\n    for idx, (i, cost) in enumerate(candidate_list):\n        if total_max >= current_load:\n            break\n        if total_min + min_outputs[i] <= current_load:\n            committed[i] = True\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    # Check next period's load requirements\n    next_max = 0\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                next_max += min(unit['p_max_i'], max_outputs[i] + unit['p_up_i'])\n            else:\n                next_max += min(unit['p_max_i'], unit['p_start_i'] + unit['p_up_i'])\n    \n    # Commit additional unit if needed for next period\n    if next_max < next_load:\n        for i, cost in candidate_list:\n            if not committed[i]:\n                committed[i] = True\n                break\n    \n    # Initialize outputs at minimum levels for committed units\n    for i in range(n_units):\n        if committed[i]:\n            p_outputs[i] = min_outputs[i]\n        else:\n            p_outputs[i] = 0\n    \n    # Economic dispatch using incremental cost\n    total_output = np.sum(p_outputs)\n    remaining_load = current_load - total_output\n    \n    # Create dispatch list with incremental costs\n    dispatch_list = []\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_outputs[i]\n            dispatch_list.append({\n                'idx': i,\n                'inc_cost': inc_cost,\n                'current': p_outputs[i],\n                'max': max_outputs[i]\n            })\n    \n    # Dispatch remaining load by increasing output of cheapest units\n    while remaining_load > 1e-6 and dispatch_list:\n        dispatch_list.sort(key=lambda x: x['inc_cost'])\n        \n        for unit_dispatch in dispatch_list:\n            i = unit_dispatch['idx']\n            available = unit_dispatch['max'] - unit_dispatch['current']\n            if available > 1e-6:\n                unit = units_info[i]\n                # Calculate maximum possible increase considering ramp constraints\n                if unit['u_i_0'] == 1:\n                    ramp_avail = unit['p_up_i'] - (unit_dispatch['current'] - unit['p_i_0'])\n                    available = min(available, ramp_avail)\n                \n                increment = min(remaining_load, available)\n                if increment > 1e-6:\n                    p_outputs[i] += increment\n                    remaining_load -= increment\n                    unit_dispatch['current'] += increment\n                    unit_dispatch['inc_cost'] = unit['b_i'] + 2 * unit['c_i'] * p_outputs[i]\n                    break\n        else:\n            break\n    \n    # Format output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01016,
          "fitness": 0.00738
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    \n    # Classify units and determine must-run units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Calculate average costs for flexible units\n    avg_costs = []\n    flexible_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            min_output = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * min_output + \n                   unit['c_i'] * min_output**2 + \n                   (unit['s_i'] if unit['u_i_0'] == 0 else 0))\n            avg_cost = cost / min_output\n            avg_costs.append(avg_cost)\n            flexible_units.append(i)\n    \n    # Sort flexible units by average cost\n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible_units))]\n    \n    # Commit must-run units\n    committed = list(np.where(must_run)[0])\n    total_capacity = sum(units_info[i]['p_max_i'] for i in committed)\n    \n    # Commit flexible units until capacity meets load + reserve\n    reserve_margin = current_load * 0.1\n    for unit_idx in flexible_sorted:\n        if total_capacity < current_load + reserve_margin:\n            committed.append(unit_idx)\n            total_capacity += units_info[unit_idx]['p_max_i']\n        else:\n            break\n    \n    # Check forecast load and adjust commitment\n    forecast_capacity = total_capacity\n    for unit_idx in flexible_sorted:\n        if unit_idx not in committed and forecast_capacity < forecast_load:\n            committed.append(unit_idx)\n            forecast_capacity += units_info[unit_idx]['p_max_i']\n    \n    # Initialize committed units\n    for i in committed:\n        u_i[i] = 1\n    \n    # Economic dispatch with ramp constraints\n    remaining_load = current_load\n    inc_costs = []\n    \n    # Calculate output bounds considering ramp constraints\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Set initial output to minimum\n        p_i[i] = p_min\n        remaining_load -= p_min\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_min\n        inc_costs.append((inc_cost, i, p_min, p_max))\n    \n    # Sort by incremental cost\n    inc_costs.sort(key=lambda x: x[0])\n    \n    # Distribute remaining load\n    idx = 0\n    while remaining_load > 1e-6 and idx < len(inc_costs):\n        _, unit_idx, current_p, p_max = inc_costs[idx]\n        available = p_max - current_p\n        if available > remaining_load:\n            p_i[unit_idx] += remaining_load\n            remaining_load = 0\n        else:\n            p_i[unit_idx] = p_max\n            remaining_load -= available\n        idx += 1\n    \n    # Validate constraints\n    for i in committed:\n        unit = units_info[i]\n        # Ensure output within bounds\n        p_i[i] = np.clip(p_i[i], unit['p_min_i'], unit['p_max_i'])\n        # Ensure ramp constraints\n        if unit['u_i_0'] == 1:\n            ramp_down_limit = unit['p_i_0'] - unit['p_down_i']\n            ramp_up_limit = unit['p_i_0'] + unit['p_up_i']\n            p_i[i] = np.clip(p_i[i], ramp_down_limit, ramp_up_limit)\n        else:\n            p_i[i] = min(p_i[i], unit['p_start_i'])\n    \n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.00525,
          "gap_price_rate": 0.0097,
          "fitness": 0.00747
     },
     {
          "name": "enhanced_rolling_commitment_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays for commitment and output\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units based on constraints\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    # Calculate available capacity from must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    # Determine need for flexible units\n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    # Prioritize flexible units based on composite cost metric\n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                   unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        flex_costs.append((i, avg_cost))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    # Commit flexible units if needed\n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:  # If off, consider turning on\n                u[i] = 1\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                total_capacity += max_out\n                \n    elif need_less:\n        # Consider turning off flexible units\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:  # If on, consider turning off\n                unit = units_info[i]\n                # Check if cost of running at min is less than startup cost\n                cost_run = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i'] ** 2)\n                if cost_run >= unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    # Economic dispatch for committed units\n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    # Initialize outputs to minimum possible\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    # Distribute remaining load based on incremental cost\n    while remaining_load > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate maximum possible output\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        addable = min(remaining_load, max_p - p[best_index])\n        p[best_index] += addable\n        remaining_load -= addable\n    \n    # Ensure feasibility for next period\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            p[i] = min(p[i], unit['p_start_i'])\n        if unit['u_i_0'] == 1 and u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00447,
          "gap_price_rate": 0.01366,
          "fitness": 0.00907
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "hybrid_rolling_unit_commitment",
          "algorithm": "This hybrid algorithm combines unit classification based on constraints with a cost-based commitment considering both current and forecasted loads. It first identifies must-on and must-off units based on minimum up/down times and shutdown ramp constraints. Flexible units are then sorted by average cost at minimum output (including startup cost for offline units) and committed until total capacity meets the maximum of current and forecasted load plus a reserve margin. Economic dispatch is performed using incremental cost sorting with continuous adjustments to respect output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_unit_commitment(units_info, load):\n    current_load, forecast_load = load\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Classify units based on constraints\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_on.append(i)\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize commitment and outputs\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Commit must-on units\n    for idx in must_on:\n        u[idx] = 1\n        # Set initial output considering ramp constraints\n        unit = units[idx]\n        if unit['u_i_0'] == 0:  # Starting up\n            p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n        else:\n            p[idx] = max(unit['p_min_i'], min(unit['p_max_i'], unit['p_i_0']))\n            p[idx] = max(p[idx], unit['p_i_0'] - unit['p_down_i'])\n            p[idx] = min(p[idx], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Calculate required capacity with reserve margin\n    reserve_margin = 0.1 * current_load\n    required_capacity = max(current_load, forecast_load) + reserve_margin\n    \n    # Commit flexible units based on cost\n    flexible_costs = []\n    for idx in flexible:\n        unit = units[idx]\n        if unit['u_i_0'] == 0:\n            # Include startup cost\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                       unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                       unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        flexible_costs.append((idx, avg_cost))\n    \n    # Sort by average cost\n    flexible_costs.sort(key=lambda x: x[1])\n    \n    # Commit until capacity requirement is met\n    total_capacity = sum(units[i]['p_max_i'] for i in must_on)\n    for idx, _ in flexible_costs:\n        if total_capacity >= required_capacity:\n            break\n        u[idx] = 1\n        total_capacity += units[idx]['p_max_i']\n    \n    # Economic dispatch using incremental cost sorting\n    committed_idxs = must_on + [idx for idx, _ in flexible_costs if u[idx] == 1]\n    \n    # Initialize outputs for committed units\n    for idx in committed_idxs:\n        unit = units[idx]\n        if u[idx] == 1:\n            if unit['u_i_0'] == 0:  # Starting up\n                p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                p[idx] = max(unit['p_min_i'], min(unit['p_max_i'], unit['p_i_0']))\n                p[idx] = max(p[idx], unit['p_i_0'] - unit['p_down_i'])\n                p[idx] = min(p[idx], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Adjust outputs iteratively\n    while abs(deficit) > 1e-5:\n        if deficit > 0:\n            # Find unit with smallest incremental cost that can increase\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] < unit['p_max_i']:\n                    # Check ramp up constraint\n                    if unit['u_i_0'] == 1:\n                        ramp_limit = unit['p_i_0'] + unit['p_up_i']\n                    else:\n                        ramp_limit = unit['p_start_i']\n                    if p[idx] < min(unit['p_max_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost))\n            if not candidates:\n                break\n            idx = min(candidates, key=lambda x: x[1])[0]\n            unit = units[idx]\n            max_increase = min(unit['p_max_i'] - p[idx], deficit)\n            if unit['u_i_0'] == 1:\n                max_increase = min(max_increase, unit['p_i_0'] + unit['p_up_i'] - p[idx])\n            else:\n                max_increase = min(max_increase, unit['p_start_i'] - p[idx])\n            p[idx] += max_increase\n            deficit -= max_increase\n        else:\n            # Find unit with largest incremental cost that can decrease\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] > unit['p_min_i']:\n                    # Check ramp down constraint\n                    if unit['u_i_0'] == 1:\n                        ramp_limit = unit['p_i_0'] - unit['p_down_i']\n                    else:\n                        ramp_limit = unit['p_min_i']\n                    if p[idx] > max(unit['p_min_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost))\n            if not candidates:\n                break\n            idx = max(candidates, key=lambda x: x[1])[0]\n            unit = units[idx]\n            max_decrease = min(p[idx] - unit['p_min_i'], -deficit)\n            if unit['u_i_0'] == 1:\n                max_decrease = min(max_decrease, p[idx] - (unit['p_i_0'] - unit['p_down_i']))\n            else:\n                max_decrease = min(max_decrease, p[idx] - unit['p_min_i'])\n            p[idx] -= max_decrease\n            deficit += max_decrease\n    \n    # Ensure must-off units are off\n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00206,
          "gap_price_rate": 0.01625,
          "fitness": 0.00915
     },
     {
          "name": "enhanced_rolling_commitment_v6",
          "algorithm": "This enhanced algorithm improves unit classification by more accurately handling must-on/must-off conditions and startup/shutdown constraints. It uses a two-stage economic dispatch with priority-based load allocation and refined ramp constraint handling. The algorithm first enforces strict must-on/must-off conditions, then commits additional units based on forecast-aware cost efficiency. Economic dispatch is performed using incremental cost sorting with continuous adjustments that respect all operational constraints, including improved handling of startup/shutdown ramp limits.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v6(units_info, load):\n    current_load, forecast_load = load\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Classify units based on enhanced constraint analysis\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Enhanced must-on conditions\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i']:\n                must_on.append(i)\n            elif p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n        # Enhanced must-off conditions\n        if u_i0 == 0:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            # Additional condition: cannot start if output would exceed startup ramp\n            elif unit['p_start_i'] < unit['p_min_i']:\n                must_off.append(i)\n        # Flexible units (not must-on or must-off)\n        if i not in must_on and i not in must_off:\n            flexible.append(i)\n    \n    # Initialize commitment and outputs\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Commit must-on units with enhanced output initialization\n    for idx in must_on:\n        u[idx] = 1\n        unit = units[idx]\n        if unit['u_i_0'] == 0:  # Starting up\n            p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            p[idx] = max(p[idx], unit['p_min_i'])\n        else:\n            # Respect ramp constraints from previous output\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p[idx] = max(p_low, min(p_high, unit['p_i_0']))\n    \n    # Calculate required capacity with forecast-aware reserve\n    reserve_margin = 0.1 * max(current_load, forecast_load)\n    required_capacity = max(current_load, forecast_load) + reserve_margin\n    \n    # Commit flexible units based on enhanced cost criteria\n    flexible_costs = []\n    for idx in flexible:\n        unit = units[idx]\n        # Calculate effective minimum output considering startup constraints\n        eff_min = max(unit['p_min_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else unit['p_min_i']\n        # Calculate average cost including startup if applicable\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i'] * eff_min + \n                       unit['c_i'] * eff_min**2 + unit['s_i']) / eff_min\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * eff_min + \n                       unit['c_i'] * eff_min**2) / eff_min\n        flexible_costs.append((idx, avg_cost))\n    \n    # Sort by average cost and commit until capacity requirement met\n    flexible_costs.sort(key=lambda x: x[1])\n    total_capacity = sum(units[i]['p_max_i'] for i in must_on)\n    for idx, _ in flexible_costs:\n        if total_capacity >= required_capacity:\n            break\n        u[idx] = 1\n        total_capacity += units[idx]['p_max_i']\n        # Initialize output for newly committed unit\n        unit = units[idx]\n        if unit['u_i_0'] == 0:\n            p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            p[idx] = max(p[idx], unit['p_min_i'])\n        else:\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p[idx] = max(p_low, min(p_high, unit['p_i_0']))\n    \n    # Perform two-stage economic dispatch\n    committed_idxs = [i for i in range(n_units) if u[i] == 1]\n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Stage 1: Priority-based load adjustment\n    inc_costs = []\n    for idx in committed_idxs:\n        unit = units[idx]\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n        inc_costs.append((idx, inc_cost))\n    \n    # Sort by incremental cost for load increases\n    inc_costs.sort(key=lambda x: x[1])\n    \n    # Adjust load based on priority\n    if deficit > 0:\n        for idx, _ in inc_costs:\n            if deficit <= 0:\n                break\n            unit = units[idx]\n            max_increase = min(unit['p_max_i'] - p[idx], deficit)\n            # Apply ramp constraints\n            if unit['u_i_0'] == 1:\n                max_increase = min(max_increase, unit['p_i_0'] + unit['p_up_i'] - p[idx])\n            else:\n                max_increase = min(max_increase, unit['p_start_i'] - p[idx])\n            if max_increase > 0:\n                p[idx] += max_increase\n                deficit -= max_increase\n    else:\n        # Sort by incremental cost descending for load decreases\n        inc_costs.sort(key=lambda x: x[1], reverse=True)\n        for idx, _ in inc_costs:\n            if deficit >= 0:\n                break\n            unit = units[idx]\n            max_decrease = min(p[idx] - unit['p_min_i'], -deficit)\n            # Apply ramp constraints\n            if unit['u_i_0'] == 1:\n                max_decrease = min(max_decrease, p[idx] - (unit['p_i_0'] - unit['p_down_i']))\n            if max_decrease > 0:\n                p[idx] -= max_decrease\n                deficit += max_decrease\n    \n    # Stage 2: Fine-tuning to minimize error\n    max_iter = 100\n    tolerance = 1e-5\n    for _ in range(max_iter):\n        if abs(deficit) < tolerance:\n            break\n        if deficit > 0:\n            # Find unit with smallest incremental cost that can increase\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] < unit['p_max_i']:\n                    ramp_limit = unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i']\n                    if p[idx] < min(unit['p_max_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost, min(unit['p_max_i'], ramp_limit) - p[idx]))\n            if not candidates:\n                break\n            idx, _, max_inc = min(candidates, key=lambda x: x[1])\n            adjustment = min(deficit, max_inc)\n            p[idx] += adjustment\n            deficit -= adjustment\n        else:\n            # Find unit with largest incremental cost that can decrease\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] > unit['p_min_i']:\n                    ramp_limit = unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] == 1 else unit['p_min_i']\n                    if p[idx] > max(unit['p_min_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost, p[idx] - max(unit['p_min_i'], ramp_limit)))\n            if not candidates:\n                break\n            idx, _, max_dec = max(candidates, key=lambda x: x[1])\n            adjustment = min(-deficit, max_dec)\n            p[idx] -= adjustment\n            deficit += adjustment\n    \n    # Ensure must-off units are off\n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    return np.array([u, p])\n",
          "from": "mutation",
          "gap_power_rate": 0.00206,
          "gap_price_rate": 0.01628,
          "fitness": 0.00917
     }
]