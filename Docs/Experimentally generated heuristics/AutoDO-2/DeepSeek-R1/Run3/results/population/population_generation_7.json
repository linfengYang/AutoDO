[
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    units = units_info.copy()\n    current_load = load[0]\n    forecast_load = load[1]\n    required_capacity = max(current_load, forecast_load) * 1.1\n    \n    must_on_units = []\n    must_off_units = []\n    flexible_units = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on_units.append(unit)\n                continue\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off_units.append(unit)\n                continue\n        flexible_units.append(unit)\n    \n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n        \n    for unit in must_on_units:\n        unit['u_i'] = 1\n        \n    total_capacity = sum(unit['p_max_i'] for unit in must_on_units)\n    \n    def calculate_cost(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible_units.sort(key=calculate_cost)\n    \n    for unit in flexible_units:\n        if total_capacity < required_capacity:\n            unit['u_i'] = 1\n            total_capacity += unit['p_max_i']\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n            \n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        \n    total_min = sum(unit['lb'] for unit in committed_units)\n    total_max = sum(unit['ub'] for unit in committed_units)\n    \n    if total_min > current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        excess = total_min - current_load\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['lb'], reverse=True):\n            reduction = min(excess, unit['p_i'] - unit['lb'])\n            unit['p_i'] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n    elif total_max < current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['ub']\n        deficit = current_load - total_max\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['ub']):\n            addition = min(deficit, unit['ub'] - unit['p_i'])\n            unit['p_i'] += addition\n            deficit -= addition\n            if deficit <= 0:\n                break\n    else:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        remaining = current_load - total_min\n        \n        while remaining > 0:\n            candidates = []\n            for unit in committed_units:\n                if unit['p_i'] < unit['ub']:\n                    inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((inc_cost, unit))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            best_unit = candidates[0][1]\n            add_cap = min(remaining, best_unit['ub'] - best_unit['p_i'])\n            best_unit['p_i'] += add_cap\n            remaining -= add_cap\n            \n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0.0\n            \n    u_i_list = [unit['u_i'] for unit in units]\n    p_i_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_i_list, p_i_list])",
          "from": "crossover",
          "gap_power_rate": 0.0022,
          "gap_price_rate": 0.01212,
          "fitness": 0.00716
     },
     {
          "name": "enhanced_rolling_commitment_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays for commitment and output\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units based on constraints\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    # Calculate available capacity from must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    # Determine need for flexible units\n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    # Prioritize flexible units based on composite cost metric\n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                   unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        flex_costs.append((i, avg_cost))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    # Commit flexible units if needed\n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:  # If off, consider turning on\n                u[i] = 1\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                total_capacity += max_out\n                \n    elif need_less:\n        # Consider turning off flexible units\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:  # If on, consider turning off\n                unit = units_info[i]\n                # Check if cost of running at min is less than startup cost\n                cost_run = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i'] ** 2)\n                if cost_run >= unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    # Economic dispatch for committed units\n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    # Initialize outputs to minimum possible\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    # Distribute remaining load based on incremental cost\n    while remaining_load > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate maximum possible output\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        addable = min(remaining_load, max_p - p[best_index])\n        p[best_index] += addable\n        remaining_load -= addable\n    \n    # Ensure feasibility for next period\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            p[i] = min(p[i], unit['p_start_i'])\n        if unit['u_i_0'] == 1 and u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00447,
          "gap_price_rate": 0.01366,
          "fitness": 0.00907
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "hybrid_rolling_unit_commitment",
          "algorithm": "This hybrid algorithm combines unit classification based on constraints with a cost-based commitment considering both current and forecasted loads. It first identifies must-on and must-off units based on minimum up/down times and shutdown ramp constraints. Flexible units are then sorted by average cost at minimum output (including startup cost for offline units) and committed until total capacity meets the maximum of current and forecasted load plus a reserve margin. Economic dispatch is performed using incremental cost sorting with continuous adjustments to respect output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_unit_commitment(units_info, load):\n    current_load, forecast_load = load\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Classify units based on constraints\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_on.append(i)\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize commitment and outputs\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Commit must-on units\n    for idx in must_on:\n        u[idx] = 1\n        # Set initial output considering ramp constraints\n        unit = units[idx]\n        if unit['u_i_0'] == 0:  # Starting up\n            p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n        else:\n            p[idx] = max(unit['p_min_i'], min(unit['p_max_i'], unit['p_i_0']))\n            p[idx] = max(p[idx], unit['p_i_0'] - unit['p_down_i'])\n            p[idx] = min(p[idx], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Calculate required capacity with reserve margin\n    reserve_margin = 0.1 * current_load\n    required_capacity = max(current_load, forecast_load) + reserve_margin\n    \n    # Commit flexible units based on cost\n    flexible_costs = []\n    for idx in flexible:\n        unit = units[idx]\n        if unit['u_i_0'] == 0:\n            # Include startup cost\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                       unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                       unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        flexible_costs.append((idx, avg_cost))\n    \n    # Sort by average cost\n    flexible_costs.sort(key=lambda x: x[1])\n    \n    # Commit until capacity requirement is met\n    total_capacity = sum(units[i]['p_max_i'] for i in must_on)\n    for idx, _ in flexible_costs:\n        if total_capacity >= required_capacity:\n            break\n        u[idx] = 1\n        total_capacity += units[idx]['p_max_i']\n    \n    # Economic dispatch using incremental cost sorting\n    committed_idxs = must_on + [idx for idx, _ in flexible_costs if u[idx] == 1]\n    \n    # Initialize outputs for committed units\n    for idx in committed_idxs:\n        unit = units[idx]\n        if u[idx] == 1:\n            if unit['u_i_0'] == 0:  # Starting up\n                p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                p[idx] = max(unit['p_min_i'], min(unit['p_max_i'], unit['p_i_0']))\n                p[idx] = max(p[idx], unit['p_i_0'] - unit['p_down_i'])\n                p[idx] = min(p[idx], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Adjust outputs iteratively\n    while abs(deficit) > 1e-5:\n        if deficit > 0:\n            # Find unit with smallest incremental cost that can increase\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] < unit['p_max_i']:\n                    # Check ramp up constraint\n                    if unit['u_i_0'] == 1:\n                        ramp_limit = unit['p_i_0'] + unit['p_up_i']\n                    else:\n                        ramp_limit = unit['p_start_i']\n                    if p[idx] < min(unit['p_max_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost))\n            if not candidates:\n                break\n            idx = min(candidates, key=lambda x: x[1])[0]\n            unit = units[idx]\n            max_increase = min(unit['p_max_i'] - p[idx], deficit)\n            if unit['u_i_0'] == 1:\n                max_increase = min(max_increase, unit['p_i_0'] + unit['p_up_i'] - p[idx])\n            else:\n                max_increase = min(max_increase, unit['p_start_i'] - p[idx])\n            p[idx] += max_increase\n            deficit -= max_increase\n        else:\n            # Find unit with largest incremental cost that can decrease\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] > unit['p_min_i']:\n                    # Check ramp down constraint\n                    if unit['u_i_0'] == 1:\n                        ramp_limit = unit['p_i_0'] - unit['p_down_i']\n                    else:\n                        ramp_limit = unit['p_min_i']\n                    if p[idx] > max(unit['p_min_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost))\n            if not candidates:\n                break\n            idx = max(candidates, key=lambda x: x[1])[0]\n            unit = units[idx]\n            max_decrease = min(p[idx] - unit['p_min_i'], -deficit)\n            if unit['u_i_0'] == 1:\n                max_decrease = min(max_decrease, p[idx] - (unit['p_i_0'] - unit['p_down_i']))\n            else:\n                max_decrease = min(max_decrease, p[idx] - unit['p_min_i'])\n            p[idx] -= max_decrease\n            deficit += max_decrease\n    \n    # Ensure must-off units are off\n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00206,
          "gap_price_rate": 0.01625,
          "fitness": 0.00915
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_run = [False] * n_units\n    candidate_on = []\n    candidate_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                candidate_off.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_on.append(i)\n    \n    def avg_cost(unit, include_startup):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max ** 2\n        if include_startup:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_on_sorted = sorted(\n        [(i, avg_cost(units_info[i], True)) for i in candidate_on],\n        key=lambda x: x[1]\n    )\n    \n    committed = must_run[:]\n    total_max = 0.0\n    max_outputs = [0.0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_outputs[i]\n    \n    for i, _ in candidate_on_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_outputs[i]\n        committed[i] = True\n    \n    non_must_run = [i for i in range(n_units) if committed[i] and not must_run[i]]\n    non_must_run_sorted = sorted(\n        [(i, avg_cost(units_info[i], False)) for i in non_must_run],\n        key=lambda x: x[1],\n        reverse=True\n    )\n    \n    for i, _ in non_must_run_sorted:\n        temp_max = total_max - max_outputs[i]\n        if temp_max >= current_load:\n            committed[i] = False\n            total_max = temp_max\n            max_outputs[i] = 0.0\n    \n    p_outputs = [0.0] * n_units\n    total_min = 0.0\n    min_outputs = [0.0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_outputs[i] = unit['p_min_i']\n            p_outputs[i] = min_outputs[i]\n            total_min += min_outputs[i]\n    \n    if total_min > current_load:\n        for i in range(n_units):\n            if committed[i]:\n                p_outputs[i] = min_outputs[i]\n    else:\n        dispatch_units = []\n        for i in range(n_units):\n            if committed[i]:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    high_bound = min(unit['p_max_i'], unit['p_start_i'])\n                dispatch_units.append({\n                    'index': i,\n                    'b': unit['b_i'],\n                    'c': unit['c_i'],\n                    'current': p_outputs[i],\n                    'high': high_bound,\n                    'ic': 0.0\n                })\n        \n        remaining_load = current_load - total_min\n        while remaining_load > 1e-6 and dispatch_units:\n            for u in dispatch_units:\n                u['ic'] = u['b'] + 2 * u['c'] * u['current']\n            dispatch_units.sort(key=lambda x: x['ic'])\n            \n            updated = False\n            for u in dispatch_units:\n                if u['current'] < u['high']:\n                    increase = min(remaining_load, u['high'] - u['current'])\n                    u['current'] += increase\n                    remaining_load -= increase\n                    updated = True\n                    break\n            \n            if not updated:\n                break\n        \n        for u in dispatch_units:\n            p_outputs[u['index']] = u['current']\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n    \n    return schedules\n",
          "from": "mutation",
          "gap_power_rate": 0.00685,
          "gap_price_rate": 0.01195,
          "fitness": 0.0094
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "refined_rolling_unit_commitment_v3",
          "algorithm": "1. Identify must-run units based on minimum up/down time and shutdown constraints\n2. Sort candidate units by average cost including startup costs\n3. Commit units until total maximum capacity meets current load while ensuring minimum outputs don't exceed load\n4. Check next period's load forecast and commit additional units if needed for ramp capability\n5. Perform economic dispatch using incremental cost sorting with ramp constraints\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    must_run = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max ** 2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        cost_val = avg_cost(unit, is_off)\n        candidate_list.append((i, cost_val))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_run[:]\n    total_min = 0\n    total_max = 0\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_i\n            total_max += max_i\n\n    for idx, (i, _) in enumerate(candidate_list):\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                new_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                new_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                new_min = unit['p_min_i']\n                new_max = min(unit['p_max_i'], unit['p_start_i'])\n            if total_min + new_min <= current_load:\n                committed[i] = True\n                total_min += new_min\n                total_max += new_max\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_next = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_next = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_next = total_max - max_next + min(unit['p_max_i'], max_next + unit['p_up_i'])\n    if total_max_next < next_load:\n        for i, _ in candidate_list:\n            if not committed[i]:\n                committed[i] = True\n                break\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_outputs[i] = unit['p_min_i']\n\n    total_p = sum(p_outputs)\n    dispatch_units = []\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bnd = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bnd = min(unit['p_max_i'], unit['p_start_i'])\n            dispatch_units.append({\n                'idx': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'low': p_outputs[i],\n                'high': high_bnd,\n                'current': p_outputs[i]\n            })\n\n    while total_p < current_load and dispatch_units:\n        for u in dispatch_units:\n            u['inc_cost'] = u['b'] + 2 * u['c'] * u['current']\n        dispatch_units.sort(key=lambda x: x['inc_cost'])\n        updated = False\n        for u in dispatch_units:\n            if u['current'] < u['high']:\n                inc = min(current_load - total_p, u['high'] - u['current'])\n                u['current'] += inc\n                total_p += inc\n                updated = True\n                break\n        if not updated:\n            break\n\n    for u in dispatch_units:\n        p_outputs[u['idx']] = u['current']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00534,
          "gap_price_rate": 0.01425,
          "fitness": 0.00979
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "commit_units_rolling_heuristic_improved",
          "algorithm": "This improved heuristic considers both current and forecasted loads when making commitment decisions. It first identifies must-run/must-off units based on physical constraints, then commits additional units sorted by average full-load cost (including startup costs for offline units). It uses a two-stage approach: first ensuring sufficient capacity for current load, then checking forecasted load needs. Economic dispatch is performed using incremental cost sorting with capacity limits adjusted for ramp constraints.\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic_improved(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current and forecast capacity\n    total_min_current = 0\n    total_max_current = 0\n    total_max_forecast = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p_current = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n    \n    # Sort offline units by average cost\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + \n        (units[i]['s_i'] if units[i]['u_i_0'] == 0 else 0)\n    ) / units[i]['p_max_i'])\n    \n    # Commit for current load\n    idx = 0\n    while total_max_current < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        unit = units[i]\n        u[i] = 1\n        min_p = unit['p_min_i']\n        max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n        online_units.append(i)\n        idx += 1\n    \n    # Commit for forecasted load\n    while idx < len(offline_units_sorted) and total_max_forecast < forecast_load:\n        i = offline_units_sorted[idx]\n        unit = units[i]\n        u[i] = 1\n        min_p = unit['p_min_i']\n        max_p_current = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += min_p\n        total_max_current += max_p_current\n        total_max_forecast += unit['p_max_i']\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit excess units\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min_current > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min_current - min_p >= current_load:\n            u[i] = 0\n            total_min_current -= min_p\n            total_max_current -= (min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) \n                                if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i']))\n            total_max_forecast -= unit['p_max_i']\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    new_inc_cost = (units[committed_indices[idx]]['b_i'] + \n                                  2 * units[committed_indices[idx]]['c_i'] * allocations[idx])\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00517,
          "gap_price_rate": 0.01585,
          "fitness": 0.01051
     },
     {
          "name": "refined_rolling_unit_commitment_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp limits\n             2. Compute feasible output ranges for must-run units considering ramp constraints\n             3. Use forecasted load to activate additional flexible units if needed for future demand\n             4. Dispatch load using merit order based on incremental costs within feasible ranges\n             5. Handle over-generation by setting outputs to minimum feasible values when load is below capacity\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    flexible_activated = []\n    if current_load > total_max:\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    elif current_load >= total_min and forecast_load > total_max:\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            costs.append((unit['p_min_i'], i))\n        costs.sort(key=lambda x: x[0])\n        for p_min, i in costs:\n            if current_load >= total_min + p_min:\n                flexible_activated.append(i)\n                break\n    \n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.01616,
          "fitness": 0.0108
     }
]