[
     {
          "name": "refined_rolling_commitment_heuristic_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_commitment_heuristic_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        max_avail = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * max_avail + unit['c_i'] * max_avail**2) / max_avail if max_avail > 0 else float('inf')\n        flex_costs.append((i, cost_per_mw))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                if total_capacity + max_out >= current_load or forecast_load > total_capacity + max_out:\n                    u[i] = 1\n                    total_capacity += max_out\n                    \n    elif need_less:\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:\n                unit = units_info[i]\n                cost_run = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n                if cost_run > unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    while abs(remaining_load) > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                \n            if remaining_load > 0 and current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n            elif remaining_load < 0 and current_p > unit['p_min_i']:\n                dec_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if dec_cost < best_cost:\n                    best_cost = dec_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            \n        if remaining_load > 0:\n            addable = min(remaining_load, max_p - p[best_index])\n            p[best_index] += addable\n            remaining_load -= addable\n        else:\n            reducible = min(-remaining_load, p[best_index] - unit['p_min_i'])\n            p[best_index] -= reducible\n            remaining_load += reducible\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n        else:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                p[i] = min(p[i], unit['p_start_i'])\n            if u[i] == 0 and unit['u_i_0'] == 1:\n                p[i] = min(p[i], unit['p_shut_i'])\n    \n    return np.array([u, p])\n",
          "from": "mutation",
          "gap_power_rate": 0.00362,
          "gap_price_rate": 0.0081,
          "fitness": 0.00586
     },
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    units = units_info.copy()\n    current_load = load[0]\n    forecast_load = load[1]\n    required_capacity = max(current_load, forecast_load) * 1.1\n    \n    must_on_units = []\n    must_off_units = []\n    flexible_units = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on_units.append(unit)\n                continue\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off_units.append(unit)\n                continue\n        flexible_units.append(unit)\n    \n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n        \n    for unit in must_on_units:\n        unit['u_i'] = 1\n        \n    total_capacity = sum(unit['p_max_i'] for unit in must_on_units)\n    \n    def calculate_cost(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible_units.sort(key=calculate_cost)\n    \n    for unit in flexible_units:\n        if total_capacity < required_capacity:\n            unit['u_i'] = 1\n            total_capacity += unit['p_max_i']\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n            \n    committed_units = [u for u in units if u['u_i'] == 1]\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        \n    total_min = sum(unit['lb'] for unit in committed_units)\n    total_max = sum(unit['ub'] for unit in committed_units)\n    \n    if total_min > current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        excess = total_min - current_load\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['lb'], reverse=True):\n            reduction = min(excess, unit['p_i'] - unit['lb'])\n            unit['p_i'] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n    elif total_max < current_load:\n        for unit in committed_units:\n            unit['p_i'] = unit['ub']\n        deficit = current_load - total_max\n        for unit in sorted(committed_units, key=lambda x: x['b_i'] + 2*x['c_i']*x['ub']):\n            addition = min(deficit, unit['ub'] - unit['p_i'])\n            unit['p_i'] += addition\n            deficit -= addition\n            if deficit <= 0:\n                break\n    else:\n        for unit in committed_units:\n            unit['p_i'] = unit['lb']\n        remaining = current_load - total_min\n        \n        while remaining > 0:\n            candidates = []\n            for unit in committed_units:\n                if unit['p_i'] < unit['ub']:\n                    inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((inc_cost, unit))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            best_unit = candidates[0][1]\n            add_cap = min(remaining, best_unit['ub'] - best_unit['p_i'])\n            best_unit['p_i'] += add_cap\n            remaining -= add_cap\n            \n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0.0\n            \n    u_i_list = [unit['u_i'] for unit in units]\n    p_i_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_i_list, p_i_list])",
          "from": "crossover",
          "gap_power_rate": 0.0022,
          "gap_price_rate": 0.01212,
          "fitness": 0.00716
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    \n    # Classify units and determine must-run units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Calculate average costs for flexible units\n    avg_costs = []\n    flexible_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            min_output = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * min_output + \n                   unit['c_i'] * min_output**2 + \n                   (unit['s_i'] if unit['u_i_0'] == 0 else 0))\n            avg_cost = cost / min_output\n            avg_costs.append(avg_cost)\n            flexible_units.append(i)\n    \n    # Sort flexible units by average cost\n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible_units))]\n    \n    # Commit must-run units\n    committed = list(np.where(must_run)[0])\n    total_capacity = sum(units_info[i]['p_max_i'] for i in committed)\n    \n    # Commit flexible units until capacity meets load + reserve\n    reserve_margin = current_load * 0.1\n    for unit_idx in flexible_sorted:\n        if total_capacity < current_load + reserve_margin:\n            committed.append(unit_idx)\n            total_capacity += units_info[unit_idx]['p_max_i']\n        else:\n            break\n    \n    # Check forecast load and adjust commitment\n    forecast_capacity = total_capacity\n    for unit_idx in flexible_sorted:\n        if unit_idx not in committed and forecast_capacity < forecast_load:\n            committed.append(unit_idx)\n            forecast_capacity += units_info[unit_idx]['p_max_i']\n    \n    # Initialize committed units\n    for i in committed:\n        u_i[i] = 1\n    \n    # Economic dispatch with ramp constraints\n    remaining_load = current_load\n    inc_costs = []\n    \n    # Calculate output bounds considering ramp constraints\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Set initial output to minimum\n        p_i[i] = p_min\n        remaining_load -= p_min\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_min\n        inc_costs.append((inc_cost, i, p_min, p_max))\n    \n    # Sort by incremental cost\n    inc_costs.sort(key=lambda x: x[0])\n    \n    # Distribute remaining load\n    idx = 0\n    while remaining_load > 1e-6 and idx < len(inc_costs):\n        _, unit_idx, current_p, p_max = inc_costs[idx]\n        available = p_max - current_p\n        if available > remaining_load:\n            p_i[unit_idx] += remaining_load\n            remaining_load = 0\n        else:\n            p_i[unit_idx] = p_max\n            remaining_load -= available\n        idx += 1\n    \n    # Validate constraints\n    for i in committed:\n        unit = units_info[i]\n        # Ensure output within bounds\n        p_i[i] = np.clip(p_i[i], unit['p_min_i'], unit['p_max_i'])\n        # Ensure ramp constraints\n        if unit['u_i_0'] == 1:\n            ramp_down_limit = unit['p_i_0'] - unit['p_down_i']\n            ramp_up_limit = unit['p_i_0'] + unit['p_up_i']\n            p_i[i] = np.clip(p_i[i], ramp_down_limit, ramp_up_limit)\n        else:\n            p_i[i] = min(p_i[i], unit['p_start_i'])\n    \n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.00525,
          "gap_price_rate": 0.0097,
          "fitness": 0.00747
     },
     {
          "name": "enhanced_rolling_commitment_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays for commitment and output\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units based on constraints\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    # Calculate available capacity from must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    # Determine need for flexible units\n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    # Prioritize flexible units based on composite cost metric\n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                   unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        flex_costs.append((i, avg_cost))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    # Commit flexible units if needed\n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:  # If off, consider turning on\n                u[i] = 1\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                total_capacity += max_out\n                \n    elif need_less:\n        # Consider turning off flexible units\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:  # If on, consider turning off\n                unit = units_info[i]\n                # Check if cost of running at min is less than startup cost\n                cost_run = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i'] ** 2)\n                if cost_run >= unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    # Economic dispatch for committed units\n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    # Initialize outputs to minimum possible\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    # Distribute remaining load based on incremental cost\n    while remaining_load > 1e-6:\n        best_cost = float('inf')\n        best_index = -1\n        for i in committed_indices:\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate maximum possible output\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                if inc_cost < best_cost:\n                    best_cost = inc_cost\n                    best_index = i\n        \n        if best_index == -1:\n            break\n            \n        unit = units_info[best_index]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        addable = min(remaining_load, max_p - p[best_index])\n        p[best_index] += addable\n        remaining_load -= addable\n    \n    # Ensure feasibility for next period\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0 and u[i] == 1:\n            p[i] = min(p[i], unit['p_start_i'])\n        if unit['u_i_0'] == 1 and u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00447,
          "gap_price_rate": 0.01366,
          "fitness": 0.00907
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "hybrid_rolling_unit_commitment",
          "algorithm": "This hybrid algorithm combines unit classification based on constraints with a cost-based commitment considering both current and forecasted loads. It first identifies must-on and must-off units based on minimum up/down times and shutdown ramp constraints. Flexible units are then sorted by average cost at minimum output (including startup cost for offline units) and committed until total capacity meets the maximum of current and forecasted load plus a reserve margin. Economic dispatch is performed using incremental cost sorting with continuous adjustments to respect output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_unit_commitment(units_info, load):\n    current_load, forecast_load = load\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Classify units based on constraints\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_on.append(i)\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize commitment and outputs\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Commit must-on units\n    for idx in must_on:\n        u[idx] = 1\n        # Set initial output considering ramp constraints\n        unit = units[idx]\n        if unit['u_i_0'] == 0:  # Starting up\n            p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n        else:\n            p[idx] = max(unit['p_min_i'], min(unit['p_max_i'], unit['p_i_0']))\n            p[idx] = max(p[idx], unit['p_i_0'] - unit['p_down_i'])\n            p[idx] = min(p[idx], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Calculate required capacity with reserve margin\n    reserve_margin = 0.1 * current_load\n    required_capacity = max(current_load, forecast_load) + reserve_margin\n    \n    # Commit flexible units based on cost\n    flexible_costs = []\n    for idx in flexible:\n        unit = units[idx]\n        if unit['u_i_0'] == 0:\n            # Include startup cost\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                       unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                       unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        flexible_costs.append((idx, avg_cost))\n    \n    # Sort by average cost\n    flexible_costs.sort(key=lambda x: x[1])\n    \n    # Commit until capacity requirement is met\n    total_capacity = sum(units[i]['p_max_i'] for i in must_on)\n    for idx, _ in flexible_costs:\n        if total_capacity >= required_capacity:\n            break\n        u[idx] = 1\n        total_capacity += units[idx]['p_max_i']\n    \n    # Economic dispatch using incremental cost sorting\n    committed_idxs = must_on + [idx for idx, _ in flexible_costs if u[idx] == 1]\n    \n    # Initialize outputs for committed units\n    for idx in committed_idxs:\n        unit = units[idx]\n        if u[idx] == 1:\n            if unit['u_i_0'] == 0:  # Starting up\n                p[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                p[idx] = max(unit['p_min_i'], min(unit['p_max_i'], unit['p_i_0']))\n                p[idx] = max(p[idx], unit['p_i_0'] - unit['p_down_i'])\n                p[idx] = min(p[idx], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Adjust outputs iteratively\n    while abs(deficit) > 1e-5:\n        if deficit > 0:\n            # Find unit with smallest incremental cost that can increase\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] < unit['p_max_i']:\n                    # Check ramp up constraint\n                    if unit['u_i_0'] == 1:\n                        ramp_limit = unit['p_i_0'] + unit['p_up_i']\n                    else:\n                        ramp_limit = unit['p_start_i']\n                    if p[idx] < min(unit['p_max_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost))\n            if not candidates:\n                break\n            idx = min(candidates, key=lambda x: x[1])[0]\n            unit = units[idx]\n            max_increase = min(unit['p_max_i'] - p[idx], deficit)\n            if unit['u_i_0'] == 1:\n                max_increase = min(max_increase, unit['p_i_0'] + unit['p_up_i'] - p[idx])\n            else:\n                max_increase = min(max_increase, unit['p_start_i'] - p[idx])\n            p[idx] += max_increase\n            deficit -= max_increase\n        else:\n            # Find unit with largest incremental cost that can decrease\n            candidates = []\n            for idx in committed_idxs:\n                unit = units[idx]\n                if p[idx] > unit['p_min_i']:\n                    # Check ramp down constraint\n                    if unit['u_i_0'] == 1:\n                        ramp_limit = unit['p_i_0'] - unit['p_down_i']\n                    else:\n                        ramp_limit = unit['p_min_i']\n                    if p[idx] > max(unit['p_min_i'], ramp_limit):\n                        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n                        candidates.append((idx, inc_cost))\n            if not candidates:\n                break\n            idx = max(candidates, key=lambda x: x[1])[0]\n            unit = units[idx]\n            max_decrease = min(p[idx] - unit['p_min_i'], -deficit)\n            if unit['u_i_0'] == 1:\n                max_decrease = min(max_decrease, p[idx] - (unit['p_i_0'] - unit['p_down_i']))\n            else:\n                max_decrease = min(max_decrease, p[idx] - unit['p_min_i'])\n            p[idx] -= max_decrease\n            deficit += max_decrease\n    \n    # Ensure must-off units are off\n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00206,
          "gap_price_rate": 0.01625,
          "fitness": 0.00915
     },
     {
          "name": "refined_rolling_commitment_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on current state and constraints\n2. Calculate must-run unit capacity considering ramp limits and startup/shutdown constraints\n3. Prioritize flexible units using enhanced cost metric including startup costs\n4. Adjust unit commitments based on current load and forecasted load\n5. Perform economic dispatch using incremental cost with ramp rate constraints\n6. Ensure output limits and startup/shutdown ramp constraints are satisfied\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_heuristic_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    need_more = current_load > total_max_must\n    need_less = current_load < total_min_must and len(flexible) > 0\n    \n    flex_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                          unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                          unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_max_i']\n        flex_costs.append((i, cost_per_mw))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    if need_more:\n        total_capacity = total_max_must\n        for i, _ in flex_costs:\n            if total_capacity >= current_load:\n                break\n            if u[i] == 0:\n                u[i] = 1\n                unit = units_info[i]\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                total_capacity += max_out\n                \n    elif need_less:\n        total_capacity = total_min_must\n        for i, _ in reversed(flex_costs):\n            if total_capacity <= current_load:\n                break\n            if u[i] == 1:\n                unit = units_info[i]\n                cost_run = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i'] ** 2)\n                if cost_run >= unit['s_i'] and forecast_load <= total_capacity - unit['p_min_i']:\n                    u[i] = 0\n                    total_capacity -= unit['p_min_i']\n    \n    committed_indices = must_run + [i for i in flexible if u[i] == 1]\n    remaining_load = current_load\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n        remaining_load -= p[i]\n    \n    while abs(remaining_load) > 1e-6:\n        if remaining_load > 0:\n            best_cost = float('inf')\n            best_index = -1\n            for i in committed_indices:\n                unit = units_info[i]\n                current_p = p[i]\n                if unit['u_i_0'] == 1:\n                    max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    max_p = min(unit['p_max_i'], unit['p_start_i'])\n                if current_p < max_p:\n                    inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                    if inc_cost < best_cost:\n                        best_cost = inc_cost\n                        best_index = i\n            if best_index == -1:\n                break\n            unit = units_info[best_index]\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            addable = min(remaining_load, max_p - p[best_index])\n            p[best_index] += addable\n            remaining_load -= addable\n        else:\n            best_saving = float('inf')\n            best_index = -1\n            for i in committed_indices:\n                unit = units_info[i]\n                current_p = p[i]\n                if unit['u_i_0'] == 1:\n                    min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    min_p = unit['p_min_i']\n                if current_p > min_p:\n                    dec_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                    if dec_cost < best_saving:\n                        best_saving = dec_cost\n                        best_index = i\n            if best_index == -1:\n                break\n            unit = units_info[best_index]\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_p = unit['p_min_i']\n            reducible = min(-remaining_load, p[best_index] - min_p)\n            p[best_index] -= reducible\n            remaining_load += reducible\n    \n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                p[i] = min(p[i], unit['p_start_i'])\n            p[i] = max(p[i], unit['p_min_i'])\n            p[i] = min(p[i], unit['p_max_i'])\n        else:\n            p[i] = 0\n    \n    return np.array([u, p])\n",
          "from": "mutation",
          "gap_power_rate": 0.00447,
          "gap_price_rate": 0.01395,
          "fitness": 0.00921
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_run = [False] * n_units\n    candidate_on = []\n    candidate_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                candidate_off.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_on.append(i)\n    \n    def avg_cost(unit, include_startup):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max ** 2\n        if include_startup:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_on_sorted = sorted(\n        [(i, avg_cost(units_info[i], True)) for i in candidate_on],\n        key=lambda x: x[1]\n    )\n    \n    committed = must_run[:]\n    total_max = 0.0\n    max_outputs = [0.0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_outputs[i]\n    \n    for i, _ in candidate_on_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_outputs[i]\n        committed[i] = True\n    \n    non_must_run = [i for i in range(n_units) if committed[i] and not must_run[i]]\n    non_must_run_sorted = sorted(\n        [(i, avg_cost(units_info[i], False)) for i in non_must_run],\n        key=lambda x: x[1],\n        reverse=True\n    )\n    \n    for i, _ in non_must_run_sorted:\n        temp_max = total_max - max_outputs[i]\n        if temp_max >= current_load:\n            committed[i] = False\n            total_max = temp_max\n            max_outputs[i] = 0.0\n    \n    p_outputs = [0.0] * n_units\n    total_min = 0.0\n    min_outputs = [0.0] * n_units\n    \n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_outputs[i] = unit['p_min_i']\n            p_outputs[i] = min_outputs[i]\n            total_min += min_outputs[i]\n    \n    if total_min > current_load:\n        for i in range(n_units):\n            if committed[i]:\n                p_outputs[i] = min_outputs[i]\n    else:\n        dispatch_units = []\n        for i in range(n_units):\n            if committed[i]:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    high_bound = min(unit['p_max_i'], unit['p_start_i'])\n                dispatch_units.append({\n                    'index': i,\n                    'b': unit['b_i'],\n                    'c': unit['c_i'],\n                    'current': p_outputs[i],\n                    'high': high_bound,\n                    'ic': 0.0\n                })\n        \n        remaining_load = current_load - total_min\n        while remaining_load > 1e-6 and dispatch_units:\n            for u in dispatch_units:\n                u['ic'] = u['b'] + 2 * u['c'] * u['current']\n            dispatch_units.sort(key=lambda x: x['ic'])\n            \n            updated = False\n            for u in dispatch_units:\n                if u['current'] < u['high']:\n                    increase = min(remaining_load, u['high'] - u['current'])\n                    u['current'] += increase\n                    remaining_load -= increase\n                    updated = True\n                    break\n            \n            if not updated:\n                break\n        \n        for u in dispatch_units:\n            p_outputs[u['index']] = u['current']\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n    \n    return schedules\n",
          "from": "mutation",
          "gap_power_rate": 0.00685,
          "gap_price_rate": 0.01195,
          "fitness": 0.0094
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "refined_rolling_unit_commitment_v3",
          "algorithm": "1. Identify must-run units based on minimum up/down time and shutdown constraints\n2. Sort candidate units by average cost including startup costs\n3. Commit units until total maximum capacity meets current load while ensuring minimum outputs don't exceed load\n4. Check next period's load forecast and commit additional units if needed for ramp capability\n5. Perform economic dispatch using incremental cost sorting with ramp constraints\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment_v3(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    must_run = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max ** 2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        cost_val = avg_cost(unit, is_off)\n        candidate_list.append((i, cost_val))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_run[:]\n    total_min = 0\n    total_max = 0\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += min_i\n            total_max += max_i\n\n    for idx, (i, _) in enumerate(candidate_list):\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                new_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                new_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                new_min = unit['p_min_i']\n                new_max = min(unit['p_max_i'], unit['p_start_i'])\n            if total_min + new_min <= current_load:\n                committed[i] = True\n                total_min += new_min\n                total_max += new_max\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_next = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_next = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_next = total_max - max_next + min(unit['p_max_i'], max_next + unit['p_up_i'])\n    if total_max_next < next_load:\n        for i, _ in candidate_list:\n            if not committed[i]:\n                committed[i] = True\n                break\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_outputs[i] = unit['p_min_i']\n\n    total_p = sum(p_outputs)\n    dispatch_units = []\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bnd = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bnd = min(unit['p_max_i'], unit['p_start_i'])\n            dispatch_units.append({\n                'idx': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'low': p_outputs[i],\n                'high': high_bnd,\n                'current': p_outputs[i]\n            })\n\n    while total_p < current_load and dispatch_units:\n        for u in dispatch_units:\n            u['inc_cost'] = u['b'] + 2 * u['c'] * u['current']\n        dispatch_units.sort(key=lambda x: x['inc_cost'])\n        updated = False\n        for u in dispatch_units:\n            if u['current'] < u['high']:\n                inc = min(current_load - total_p, u['high'] - u['current'])\n                u['current'] += inc\n                total_p += inc\n                updated = True\n                break\n        if not updated:\n            break\n\n    for u in dispatch_units:\n        p_outputs[u['idx']] = u['current']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00534,
          "gap_price_rate": 0.01425,
          "fitness": 0.00979
     }
]