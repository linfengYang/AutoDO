{
     "name": "novel_rolling_uc_heuristic",
     "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints.\n3. Sort flexible units by average cost per MW at minimum output (including startup costs if applicable).\n4. Commit flexible units in cost order until total available capacity meets or exceeds current load.\n5. Dispatch load by setting committed units to their minimum output, then allocating remaining load based on marginal cost order.\n",
     "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_min = np.zeros(n_units)\n    current_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n            current_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            current_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n            current_min[i] = p_min_i\n            current_max[i] = min(p_max_i, p_start_i)\n        \n        if must_off[i]:\n            current_min[i] = 0\n            current_max[i] = 0\n\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_per_mw = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        else:\n            total_cost = unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        cost_per_mw.append(total_cost / current_min[i] if current_min[i] > 0 else float('inf'))\n    \n    sorted_flexible = [i for _, i in sorted(zip(cost_per_mw, flexible_units))]\n    committed = must_run.copy()\n    total_max = np.sum(current_max[must_run])\n    \n    for i in sorted_flexible:\n        if total_max >= load[0]:\n            break\n        committed[i] = True\n        total_max += current_max[i]\n    \n    p_output = np.zeros(n_units)\n    for i in range(n_units):\n        if committed[i]:\n            p_output[i] = current_min[i]\n        else:\n            p_output[i] = 0\n            \n    remaining = load[0] - np.sum(p_output)\n    committed_indices = [i for i in range(n_units) if committed[i] and p_output[i] < current_max[i]]\n    \n    step = 1.0\n    while remaining > 0 and committed_indices:\n        marginal_costs = []\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_output[i])\n        idx_min = np.argmin(marginal_costs)\n        unit_idx = committed_indices[idx_min]\n        increase = min(step, current_max[unit_idx] - p_output[unit_idx], remaining)\n        p_output[unit_idx] += increase\n        remaining -= increase\n        if p_output[unit_idx] >= current_max[unit_idx]:\n            committed_indices.pop(idx_min)\n            \n    u_output = committed.astype(int)\n    schedules = np.array([u_output, p_output])\n    return schedules",
     "from": null,
     "gap_power_rate": 0.0054284293,
     "gap_price_rate": 0.0087959181,
     "fitness": 0.0071121737
}