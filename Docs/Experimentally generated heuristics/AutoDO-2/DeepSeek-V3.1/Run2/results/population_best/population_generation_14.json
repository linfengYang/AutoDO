{
     "name": "enhanced_commit_units_heuristic_v2",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n\n",
     "code": "import numpy as np\nimport copy\n\ndef enhanced_commit_units_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    units = copy.deepcopy(units_info)\n    n_units = len(units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        # Check must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(unit)\n            unit['u_i'] = 1\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Check must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(unit)\n            unit['u_i'] = 0\n            unit['min_p'] = 0\n            unit['max_p'] = 0\n        else:\n            flexible.append(unit)\n    \n    # Compute effective costs and feasible ranges for flexible units\n    for unit in flexible:\n        if unit['u_i_0'] == 1:\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2) / unit['min_p']\n        else:\n            unit['min_p'] = unit['p_min_i']\n            unit['max_p'] = min(unit['p_max_i'], unit['p_start_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2 + unit['s_i']) / unit['min_p']\n    \n    # Commit units\n    committed = must_run.copy()\n    total_min = sum(unit['min_p'] for unit in committed)\n    total_max = sum(unit['max_p'] for unit in committed)\n    \n    # Sort flexible units by effective cost\n    flexible_sorted = sorted(flexible, key=lambda x: x['effective_cost'])\n    \n    # Commit flexible units until load is met\n    for unit in flexible_sorted:\n        if total_max >= current_load:\n            break\n        if unit['u_i_0'] == 0 and forecast_load > total_max:\n            unit['u_i'] = 1\n            committed.append(unit)\n            total_min += unit['min_p']\n            total_max += unit['max_p']\n    \n    # Economic dispatch\n    for unit in committed:\n        unit['p_i'] = unit['min_p']\n    \n    remaining_load = current_load - total_min\n    units_available = [u for u in committed if u['p_i'] < u['max_p']]\n    \n    while remaining_load > 0 and units_available:\n        # Find unit with lowest marginal cost\n        best_unit = min(units_available, \n                       key=lambda u: u['b_i'] + 2 * u['c_i'] * u['p_i'])\n        # Calculate available capacity\n        available = min(best_unit['max_p'] - best_unit['p_i'], remaining_load)\n        best_unit['p_i'] += available\n        remaining_load -= available\n        if best_unit['p_i'] >= best_unit['max_p']:\n            units_available.remove(best_unit)\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for idx, unit in enumerate(units):\n        schedules[0, idx] = unit.get('u_i', 0)\n        schedules[1, idx] = unit.get('p_i', 0)\n    \n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.003641132,
     "gap_price_rate": 0.0047652342,
     "fitness": 0.0042031831
}