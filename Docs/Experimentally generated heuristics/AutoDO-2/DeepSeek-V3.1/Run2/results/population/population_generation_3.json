[
     {
          "name": "enhanced_commit_units_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n\n",
          "code": "import numpy as np\nimport copy\n\ndef enhanced_commit_units_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    units = copy.deepcopy(units_info)\n    n_units = len(units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        # Check must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(unit)\n            unit['u_i'] = 1\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Check must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(unit)\n            unit['u_i'] = 0\n            unit['min_p'] = 0\n            unit['max_p'] = 0\n        else:\n            flexible.append(unit)\n    \n    # Compute effective costs and feasible ranges for flexible units\n    for unit in flexible:\n        if unit['u_i_0'] == 1:\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2) / unit['min_p']\n        else:\n            unit['min_p'] = unit['p_min_i']\n            unit['max_p'] = min(unit['p_max_i'], unit['p_start_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2 + unit['s_i']) / unit['min_p']\n    \n    # Commit units\n    committed = must_run.copy()\n    total_min = sum(unit['min_p'] for unit in committed)\n    total_max = sum(unit['max_p'] for unit in committed)\n    \n    # Sort flexible units by effective cost\n    flexible_sorted = sorted(flexible, key=lambda x: x['effective_cost'])\n    \n    # Commit flexible units until load is met\n    for unit in flexible_sorted:\n        if total_max >= current_load:\n            break\n        if unit['u_i_0'] == 0 and forecast_load > total_max:\n            unit['u_i'] = 1\n            committed.append(unit)\n            total_min += unit['min_p']\n            total_max += unit['max_p']\n    \n    # Economic dispatch\n    for unit in committed:\n        unit['p_i'] = unit['min_p']\n    \n    remaining_load = current_load - total_min\n    units_available = [u for u in committed if u['p_i'] < u['max_p']]\n    \n    while remaining_load > 0 and units_available:\n        # Find unit with lowest marginal cost\n        best_unit = min(units_available, \n                       key=lambda u: u['b_i'] + 2 * u['c_i'] * u['p_i'])\n        # Calculate available capacity\n        available = min(best_unit['max_p'] - best_unit['p_i'], remaining_load)\n        best_unit['p_i'] += available\n        remaining_load -= available\n        if best_unit['p_i'] >= best_unit['max_p']:\n            units_available.remove(best_unit)\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for idx, unit in enumerate(units):\n        schedules[0, idx] = unit.get('u_i', 0)\n        schedules[1, idx] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.003641132,
          "gap_price_rate": 0.0047652342,
          "fitness": 0.0042031831
     },
     {
          "name": "novel_rolling_uc_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints.\n3. Sort flexible units by average cost per MW at minimum output (including startup costs if applicable).\n4. Commit flexible units in cost order until total available capacity meets or exceeds current load.\n5. Dispatch load by setting committed units to their minimum output, then allocating remaining load based on marginal cost order.\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_min = np.zeros(n_units)\n    current_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n            current_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            current_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n            current_min[i] = p_min_i\n            current_max[i] = min(p_max_i, p_start_i)\n        \n        if must_off[i]:\n            current_min[i] = 0\n            current_max[i] = 0\n\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_per_mw = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        else:\n            total_cost = unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        cost_per_mw.append(total_cost / current_min[i] if current_min[i] > 0 else float('inf'))\n    \n    sorted_flexible = [i for _, i in sorted(zip(cost_per_mw, flexible_units))]\n    committed = must_run.copy()\n    total_max = np.sum(current_max[must_run])\n    \n    for i in sorted_flexible:\n        if total_max >= load[0]:\n            break\n        committed[i] = True\n        total_max += current_max[i]\n    \n    p_output = np.zeros(n_units)\n    for i in range(n_units):\n        if committed[i]:\n            p_output[i] = current_min[i]\n        else:\n            p_output[i] = 0\n            \n    remaining = load[0] - np.sum(p_output)\n    committed_indices = [i for i in range(n_units) if committed[i] and p_output[i] < current_max[i]]\n    \n    step = 1.0\n    while remaining > 0 and committed_indices:\n        marginal_costs = []\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_output[i])\n        idx_min = np.argmin(marginal_costs)\n        unit_idx = committed_indices[idx_min]\n        increase = min(step, current_max[unit_idx] - p_output[unit_idx], remaining)\n        p_output[unit_idx] += increase\n        remaining -= increase\n        if p_output[unit_idx] >= current_max[unit_idx]:\n            committed_indices.pop(idx_min)\n            \n    u_output = committed.astype(int)\n    schedules = np.array([u_output, p_output])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054284293,
          "gap_price_rate": 0.0087959181,
          "fitness": 0.0071121737
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets load\n5. Perform economic dispatch by setting committed units to minimum output, then allocating remaining load based on marginal cost\n6. Adjust outputs to respect all constraints including ramp rates and min/max limits\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = [0] * n_units\n    feasible_max = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < t_on_min or p0 > p_shut):\n            must_run.append(i)\n            min_p = max(p_min, p0 - p_down)\n            max_p = min(p_max, p0 + p_up)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n        elif u0 == 0 and abs(t0) < t_off_min:\n            must_off.append(i)\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n        else:\n            flexible.append(i)\n            if u0 == 1:\n                min_p = max(p_min, p0 - p_down)\n                max_p = min(p_max, p0 + p_up)\n            else:\n                min_p = p_min\n                max_p = min(p_max, p_start)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n\n    committed = set()\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        committed.add(i)\n        schedules[0, i] = 1\n        schedules[1, i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        else:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        effective_costs.append((cost, i))\n    \n    effective_costs.sort(key=lambda x: x[0])\n    \n    for cost, i in effective_costs:\n        if total_max >= current_load:\n            break\n        if i not in committed and i not in must_off:\n            committed.add(i)\n            schedules[0, i] = 1\n            schedules[1, i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n    \n    current_total = total_min\n    remaining_load = current_load - current_total\n    \n    adjustable_units = [i for i in committed if feasible_max[i] > feasible_min[i]]\n    \n    if remaining_load > 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for mc, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            available = feasible_max[i] - schedules[1, i]\n            to_add = min(remaining_load, available)\n            schedules[1, i] += to_add\n            remaining_load -= to_add\n            \n    elif remaining_load < 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for mc, i in marginal_costs:\n            if remaining_load >= 0:\n                break\n            available = schedules[1, i] - feasible_min[i]\n            to_reduce = min(-remaining_load, available)\n            schedules[1, i] -= to_reduce\n            remaining_load += to_reduce\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Compute feasible power ranges considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost (including startup if applicable) for flexible units at min output\n4. Commit must-run units first, then flexible units by effective cost until load is met\n5. Adjust commitment using forecasted load to minimize future startup costs\n6. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n7. Ensure all constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    flexible = [False] * n_units\n    p_min_feasible = [0.0] * n_units\n    p_max_feasible = [0.0] * n_units\n    effective_cost = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off[i] = True\n        else:\n            flexible[i] = True\n            \n        # Step 2: Compute feasible power ranges\n        if must_run[i] or (flexible[i] and u_i0 == 1):\n            p_min_feasible[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        elif flexible[i] and u_i0 == 0:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min_feasible[i], p_max_feasible[i] = 0, 0\n            \n        # Step 3: Calculate effective cost\n        if flexible[i]:\n            if u_i0 == 0:\n                cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min_feasible[i] + \n                        unit['c_i'] * p_min_feasible[i] ** 2)\n            else:\n                cost = (unit['a_i'] + unit['b_i'] * p_min_feasible[i] + \n                        unit['c_i'] * p_min_feasible[i] ** 2)\n            effective_cost[i] = cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n    \n    # Step 4: Initial commitment\n    committed = must_run[:]\n    total_capacity = sum(p_max_feasible[i] for i in range(n_units) if committed[i])\n    \n    # Commit flexible units by cost\n    flexible_indices = [i for i in range(n_units) if flexible[i]]\n    flexible_indices.sort(key=lambda i: effective_cost[i])\n    \n    for i in flexible_indices:\n        if total_capacity < current_load and not must_off[i]:\n            committed[i] = True\n            total_capacity += p_max_feasible[i]\n    \n    # Step 5: Adjust for forecasted load\n    forecast_capacity = total_capacity + sum(\n        min(unit['p_up_i'], unit['p_max_i'] - p_max_feasible[i]) \n        for i, unit in enumerate(units_info) if committed[i]\n    )\n    \n    if forecast_capacity < forecast_load:\n        for i in flexible_indices:\n            if not committed[i] and not must_off[i]:\n                committed[i] = True\n                break\n    \n    # Step 6: Economic dispatch\n    # Set initial outputs to min feasible\n    p_outputs = [p_min_feasible[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = current_load - sum(p_outputs)\n    \n    # Create priority list for dispatch\n    dispatch_order = [i for i in range(n_units) if committed[i]]\n    dispatch_order.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i])\n    \n    # Allocate remaining load\n    for i in dispatch_order:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, p_max_feasible[i] - p_outputs[i])\n        p_outputs[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Step 7: Constraint satisfaction check\n    for i in range(n_units):\n        if committed[i]:\n            # Ensure within feasible range\n            p_outputs[i] = max(p_min_feasible[i], min(p_max_feasible[i], p_outputs[i]))\n            # Ensure ramp constraints\n            if units_info[i]['u_i_0'] == 1:\n                p_outputs[i] = min(p_outputs[i], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                p_outputs[i] = max(p_outputs[i], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n    \n    # Prepare output\n    schedules[0, :] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1, :] = p_outputs\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0059278578,
          "gap_price_rate": 0.0112066471,
          "fitness": 0.0085672524
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v3",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v3(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Determine must-run/must-off status\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            min_p[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            if -t0 < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if i in must_off:\n            min_p[i] = 0\n            max_p[i] = 0\n\n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_p[i] + \n                   unit['c_i']*min_p[i]**2) / min_p[i]\n        else:\n            cost = (unit['a_i'] + unit['b_i']*min_p[i] + \n                   unit['c_i']*min_p[i]**2) / min_p[i]\n        costs.append((cost, i))\n    \n    costs.sort(key=lambda x: x[0])\n    flexible_sorted = [i for _, i in costs]\n\n    # Initial commitment\n    committed = set(must_run)\n    total_min = sum(min_p[i] for i in committed)\n    total_max = sum(max_p[i] for i in committed)\n    \n    # Commit flexible units\n    for i in flexible_sorted:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            break\n\n    # Adjust commitment based on forecast\n    if forecast_load > total_max * 0.9:\n        for i in flexible_sorted:\n            if i not in committed and total_max + max_p[i] >= forecast_load:\n                committed.add(i)\n                break\n    elif forecast_load < total_min * 1.1:\n        for i in reversed(flexible_sorted):\n            if i in committed and total_min - min_p[i] <= forecast_load:\n                committed.remove(i)\n                break\n\n    # Economic dispatch\n    for i in committed:\n        p[i] = min_p[i]\n    \n    remaining = current_load - sum(p)\n    committed_list = list(committed)\n    \n    # Allocate remaining load\n    while abs(remaining) > 1e-5:\n        if remaining > 0:\n            # Find unit with lowest marginal cost\n            marginal_costs = []\n            for i in committed_list:\n                if p[i] < max_p[i]:\n                    mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort()\n            i = marginal_costs[0][1]\n            add = min(remaining, max_p[i] - p[i])\n            p[i] += add\n            remaining -= add\n        else:\n            # Find unit with highest marginal cost\n            marginal_costs = []\n            for i in committed_list:\n                if p[i] > min_p[i]:\n                    mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(reverse=True)\n            i = marginal_costs[0][1]\n            reduce = min(-remaining, p[i] - min_p[i])\n            p[i] -= reduce\n            remaining += reduce\n\n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n\n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0059642692,
          "gap_price_rate": 0.0129901629,
          "fitness": 0.009477216
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load: if forecast exceeds current capacity, commit additional flexible units; if forecast is lower, consider deactivating flexible units\n6. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n7. Ensure all physical constraints are satisfied through iterative refinement\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        # Determine must-run and must-off status\n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(p_max_i, p_start_i, p_up_i)\n    \n    # Calculate effective costs for flexible units\n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        s_i, u_i_0 = unit['s_i'], unit['u_i_0']\n        p_min_i = feasible_min[i]\n        \n        if u_i_0 == 0:\n            cost = (s_i + a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i\n        else:\n            cost = (a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i\n        effective_costs.append((i, cost))\n    \n    # Sort flexible units by effective cost\n    effective_costs.sort(key=lambda x: x[1])\n    sorted_flexible = [x[0] for x in effective_costs]\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_min = sum(feasible_min[i] for i in committed)\n    total_max = sum(feasible_max[i] for i in committed)\n    \n    # Commit flexible units until load is met\n    for i in sorted_flexible:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Adjust commitment based on forecast\n    if forecast_load > total_max:\n        for i in sorted_flexible:\n            if i not in committed and forecast_load > total_max:\n                committed.add(i)\n                total_min += feasible_min[i]\n                total_max += feasible_max[i]\n            else:\n                break\n    elif forecast_load < total_min:\n        for i in reversed(sorted_flexible):\n            if i in committed and forecast_load < total_min - feasible_min[i]:\n                committed.remove(i)\n                total_min -= feasible_min[i]\n                total_max -= feasible_max[i]\n            else:\n                break\n    \n    # Initialize outputs\n    for i in committed:\n        u[i] = 1\n        p[i] = feasible_min[i]\n    \n    # Economic dispatch\n    remaining = current_load - sum(p)\n    marginal_costs = []\n    for i in committed:\n        unit = units_info[i]\n        b_i, c_i = unit['b_i'], unit['c_i']\n        marginal_cost = b_i + 2 * c_i * p[i]\n        marginal_costs.append((i, marginal_cost))\n    \n    while remaining > 0:\n        marginal_costs.sort(key=lambda x: x[1])\n        updated = False\n        for i, mc in marginal_costs:\n            if p[i] < feasible_max[i]:\n                delta = min(remaining, feasible_max[i] - p[i])\n                p[i] += delta\n                remaining -= delta\n                unit = units_info[i]\n                b_i, c_i = unit['b_i'], unit['c_i']\n                new_mc = b_i + 2 * c_i * p[i]\n                # Update marginal cost\n                idx = next((idx for idx, (idx_i, _) in enumerate(marginal_costs) if idx_i == i), None)\n                if idx is not None:\n                    marginal_costs[idx] = (i, new_mc)\n                updated = True\n                if remaining <= 0:\n                    break\n        if not updated:\n            break\n    \n    # Ensure must-off units are off\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.003515163,
          "gap_price_rate": 0.0161216978,
          "fitness": 0.0098184304
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, flexible-on, and must-off based on min up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Prioritize flexible units using adaptive cost metric combining marginal cost and flexibility penalty\n4. Commit units using forecast-aware strategy to minimize unnecessary startups\n5. Perform constrained economic dispatch using iterative water-filling with ramp constraints\n6. Validate and adjust schedule to ensure all physical constraints are satisfied\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run.append(i)\n        # Check must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if i in must_off:\n            p_min[i] = 0\n            p_max[i] = 0\n            continue\n            \n        base_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        base_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        # Startup constraints\n        if unit['u_i_0'] == 0:\n            base_max = min(base_max, unit['p_start_i'])\n        \n        # Shutdown constraints\n        if i not in must_run and forecast_load < current_load:\n            base_max = min(base_max, unit['p_shut_i'])\n            \n        p_min[i] = base_min\n        p_max[i] = base_max\n    \n    # Adaptive cost calculation\n    def calculate_cost(unit_idx, forecast_aware=False):\n        unit = units_info[unit_idx]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min[unit_idx]\n        \n        if unit['u_i_0'] == 0:\n            startup_cost = unit['s_i'] / max(1, p_min[unit_idx])\n        else:\n            startup_cost = 0\n            \n        flexibility_penalty = 0\n        if forecast_aware:\n            ramp_range = unit['p_up_i'] + unit['p_down_i']\n            flexibility_penalty = (1 - ramp_range/unit['p_max_i']) * 0.1\n            \n        return marginal_cost + startup_cost + flexibility_penalty\n    \n    # Commit units\n    committed = set(must_run)\n    total_capacity = sum(p_max[i] for i in committed)\n    \n    # Sort flexible units by adaptive cost\n    flexible_sorted = sorted(flexible, key=lambda i: calculate_cost(i, True))\n    \n    for i in flexible_sorted:\n        if total_capacity < current_load:\n            committed.add(i)\n            total_capacity += p_max[i]\n        elif total_capacity - p_max[i] >= current_load and i in committed:\n            committed.remove(i)\n            total_capacity -= p_max[i]\n    \n    # Economic dispatch\n    remaining_load = current_load\n    for i in committed:\n        schedules[0][i] = 1\n        schedules[1][i] = p_min[i]\n        remaining_load -= p_min[i]\n    \n    # Water-filling allocation\n    while abs(remaining_load) > 1e-6:\n        # Find unit with smallest marginal cost that can adjust\n        best_unit = None\n        best_marginal_cost = float('inf')\n        \n        for i in committed:\n            unit = units_info[i]\n            current_p = schedules[1][i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0 and current_p < p_max[i] and marginal_cost < best_marginal_cost:\n                best_unit = i\n                best_marginal_cost = marginal_cost\n            elif remaining_load < 0 and current_p > p_min[i] and -marginal_cost < best_marginal_cost:\n                best_unit = i\n                best_marginal_cost = -marginal_cost\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = schedules[1][best_unit]\n        max_adjust = min(remaining_load, p_max[best_unit] - current_p) if remaining_load > 0 \\\n                   else max(remaining_load, p_min[best_unit] - current_p)\n        \n        schedules[1][best_unit] += max_adjust\n        remaining_load -= max_adjust\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0063009957,
          "gap_price_rate": 0.0138955959,
          "fitness": 0.0100982958
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v4",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using min up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Compute adaptive cost metric combining marginal cost and flexibility penalty for flexible units\n4. Commit must-run units first, then flexible units using forecast-aware strategy\n5. Perform constrained economic dispatch using iterative water-filling with ramp constraints\n6. Validate and adjust outputs to ensure all physical constraints are satisfied\n7. Use look-ahead strategy with forecasted load to optimize unit commitments\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v4(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Calculate feasible ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if must_run[i] or (flexible[i] and unit['u_i_0'] == 1):\n            p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif flexible[i] and unit['u_i_0'] == 0:\n            p_min[i] = unit['p_min_i']\n            p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    # Calculate adaptive cost metric\n    cost_metric = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if flexible[i]:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min[i]\n            flexibility_penalty = (p_max[i] - p_min[i]) / unit['p_up_i'] if unit['p_up_i'] > 0 else 0\n            cost_metric[i] = marginal_cost + flexibility_penalty\n            if unit['u_i_0'] == 0:\n                cost_metric[i] += unit['s_i'] / p_min[i] if p_min[i] > 0 else float('inf')\n    \n    # Commit units\n    committed = must_run.copy()\n    flexible_indices = np.where(flexible)[0]\n    cost_order = np.argsort(cost_metric[flexible_indices])\n    \n    total_capacity = np.sum(p_max[committed])\n    for idx in cost_order:\n        i = flexible_indices[idx]\n        if total_capacity < current_load or (forecast_load > total_capacity and not committed[i]):\n            committed[i] = True\n            total_capacity += p_max[i]\n    \n    # Economic dispatch\n    p[committed] = p_min[committed]\n    remaining_load = current_load - np.sum(p[committed])\n    \n    while remaining_load > 1e-6:\n        marginal_costs = []\n        for i in np.where(committed)[0]:\n            if p[i] < p_max[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                marginal_costs.append((marginal_cost, i))\n        if not marginal_costs:\n            break\n        marginal_costs.sort()\n        cheapest_i = marginal_costs[0][1]\n        add_load = min(remaining_load, p_max[cheapest_i] - p[cheapest_i])\n        p[cheapest_i] += add_load\n        remaining_load -= add_load\n    \n    # Adjust for constraints\n    for i in np.where(committed)[0]:\n        if units_info[i]['u_i_0'] == 1:\n            ramp_limit = units_info[i]['p_i_0'] + units_info[i]['p_up_i']\n            p[i] = min(p[i], ramp_limit)\n        p[i] = max(p_min[i], min(p_max[i], p[i]))\n    \n    u[committed] = 1\n    schedules = np.vstack([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0021979319,
          "gap_price_rate": 0.0181246396,
          "fitness": 0.0101612858
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v4",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v4(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Check minimum up/down time constraints\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n                continue\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n                continue\n        \n        # Check shutdown ramp constraint\n        if unit['u_i_0'] == 1 and unit['p_i_0'] > unit['p_shut_i']:\n            must_run.append(i)\n        else:\n            flexible.append(i)\n    \n    # Step 2: Compute feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if i in must_off:\n            p_min_feasible[i] = 0\n            p_max_feasible[i] = 0\n            continue\n            \n        # Base min/max\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        \n        # Ramp constraints\n        if unit['u_i_0'] == 1:\n            p_min = max(p_min, unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(p_max, unit['p_i_0'] + unit['p_up_i'])\n        else:\n            # Startup ramp limit\n            p_max = min(p_max, unit['p_start_i'])\n        \n        p_min_feasible[i] = p_min\n        p_max_feasible[i] = p_max\n    \n    # Step 3: Calculate effective costs\n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            # Include startup cost\n            cost_per_mw = (unit['s_i'] + unit['b_i'] * p_min_feasible[i] + \n                          unit['c_i'] * p_min_feasible[i]**2) / p_min_feasible[i]\n        else:\n            cost_per_mw = (unit['b_i'] * p_min_feasible[i] + \n                          unit['c_i'] * p_min_feasible[i]**2) / p_min_feasible[i]\n        effective_costs.append((i, cost_per_mw))\n    \n    # Sort by effective cost\n    flexible_sorted = sorted(effective_costs, key=lambda x: x[1])\n    \n    # Step 4 & 5: Commit units\n    total_capacity = 0\n    committed = set(must_run)\n    \n    # Add must-run units capacity\n    for i in must_run:\n        total_capacity += p_max_feasible[i]\n    \n    # Commit flexible units considering forecast\n    for i, _ in flexible_sorted:\n        if total_capacity >= current_load and total_capacity >= forecast_load:\n            break\n        committed.add(i)\n        total_capacity += p_max_feasible[i]\n    \n    # Step 6: Economic dispatch\n    # Set to minimum output first\n    for i in committed:\n        p[i] = p_min_feasible[i]\n    \n    remaining_load = current_load - sum(p)\n    \n    # Allocate remaining load based on marginal cost\n    while remaining_load > 1e-6:\n        marginal_costs = []\n        for i in committed:\n            if p[i] < p_max_feasible[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                marginal_costs.append((i, marginal_cost))\n        \n        if not marginal_costs:\n            break\n            \n        # Find unit with lowest marginal cost\n        i, min_cost = min(marginal_costs, key=lambda x: x[1])\n        \n        # Calculate available capacity\n        available = p_max_feasible[i] - p[i]\n        add_load = min(remaining_load, available)\n        p[i] += add_load\n        remaining_load -= add_load\n    \n    # Step 7: Validate and adjust constraints\n    for i in committed:\n        unit = units_info[i]\n        # Ensure ramp constraints\n        if unit['u_i_0'] == 1:\n            ramp_down_limit = unit['p_i_0'] - unit['p_down_i']\n            ramp_up_limit = unit['p_i_0'] + unit['p_up_i']\n            p[i] = max(min(p[i], ramp_up_limit), ramp_down_limit)\n        \n        # Ensure min/max constraints\n        p[i] = max(min(p[i], p_max_feasible[i]), p_min_feasible[i])\n        u[i] = 1\n    \n    # Set must-off units to zero\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0021979319,
          "gap_price_rate": 0.0181921888,
          "fitness": 0.0101950604
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v4",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using min up/down times and shutdown ramp constraints. 2. Compute current feasible power ranges incorporating ramp limits, startup/shutdown constraints, and current state. 3. Calculate effective cost per MW for flexible units including startup costs where applicable. 4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load. 5. Use forecast-aware adjustment: if forecast exceeds current capacity, pre-commit additional flexible units; if forecast is lower, consider deactivating flexible units. 6. Perform economic dispatch using iterative water-filling with ramp-aware allocation and marginal cost sorting. 7. Validate and refine schedule through constraint satisfaction checks.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v4(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Extract unit parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    min_up = [u['t_on_min_i'] for u in units_info]\n    min_down = [u['t_off_min_i'] for u in units_info]\n    startup_cost = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_prev[i]) < min_down[i]:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Compute feasible ranges\n    min_feasible = [0] * n_units\n    max_feasible = [0] * n_units\n    for i in range(n_units):\n        if i in must_run or i in flexible:\n            if u_prev[i] == 1:\n                min_feasible[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_feasible[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_feasible[i] = p_min[i]\n                max_feasible[i] = min(p_max[i], p_start[i])\n        else:\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n    \n    # Calculate effective costs for flexible units\n    effective_cost = []\n    for i in flexible:\n        if u_prev[i] == 0:\n            cost = (startup_cost[i] + a[i] + b[i] * min_feasible[i] + c[i] * min_feasible[i]**2) / min_feasible[i]\n        else:\n            cost = (a[i] + b[i] * min_feasible[i] + c[i] * min_feasible[i]**2) / min_feasible[i]\n        effective_cost.append((cost, i))\n    effective_cost.sort(key=lambda x: x[0])\n    flexible_sorted = [i for _, i in effective_cost]\n    \n    # Initial commitment\n    committed = set(must_run)\n    total_min = sum(min_feasible[i] for i in committed)\n    total_max = sum(max_feasible[i] for i in committed)\n    \n    for i in flexible_sorted:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_feasible[i]\n            total_max += max_feasible[i]\n        else:\n            break\n    \n    # Forecast-aware adjustment\n    if forecast_load > total_max and len(committed) < len(must_run) + len(flexible):\n        for i in flexible_sorted:\n            if i not in committed:\n                committed.add(i)\n                total_min += min_feasible[i]\n                total_max += max_feasible[i]\n                if total_max >= forecast_load:\n                    break\n    elif forecast_load < total_min:\n        for i in reversed(flexible_sorted):\n            if i in committed and i not in must_run:\n                if total_max - max_feasible[i] >= current_load:\n                    committed.remove(i)\n                    total_min -= min_feasible[i]\n                    total_max -= max_feasible[i]\n                if total_min <= forecast_load:\n                    break\n    \n    # Economic dispatch\n    p_out = [0] * n_units\n    for i in committed:\n        p_out[i] = min_feasible[i]\n    remaining = current_load - sum(p_out)\n    \n    # Water-filling allocation\n    while abs(remaining) > 1e-6:\n        marginal_costs = []\n        for i in committed:\n            if remaining > 0 and p_out[i] < max_feasible[i]:\n                mc = b[i] + 2 * c[i] * p_out[i]\n                marginal_costs.append((mc, i))\n            elif remaining < 0 and p_out[i] > min_feasible[i]:\n                mc = b[i] + 2 * c[i] * p_out[i]\n                marginal_costs.append((mc, i))\n        \n        if not marginal_costs:\n            break\n            \n        if remaining > 0:\n            marginal_costs.sort(key=lambda x: x[0])\n            i = marginal_costs[0][1]\n            add = min(remaining, max_feasible[i] - p_out[i])\n            p_out[i] += add\n            remaining -= add\n        else:\n            marginal_costs.sort(key=lambda x: -x[0])\n            i = marginal_costs[0][1]\n            reduce = min(-remaining, p_out[i] - min_feasible[i])\n            p_out[i] -= reduce\n            remaining += reduce\n    \n    # Build output\n    for i in range(n_units):\n        schedules[0, i] = 1 if i in committed else 0\n        schedules[1, i] = p_out[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0018740438,
          "gap_price_rate": 0.0185386497,
          "fitness": 0.0102063467
     }
]