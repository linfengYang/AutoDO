[
     {
          "name": "enhanced_commit_units_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n\n",
          "code": "import numpy as np\nimport copy\n\ndef enhanced_commit_units_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    units = copy.deepcopy(units_info)\n    n_units = len(units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        # Check must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(unit)\n            unit['u_i'] = 1\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Check must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(unit)\n            unit['u_i'] = 0\n            unit['min_p'] = 0\n            unit['max_p'] = 0\n        else:\n            flexible.append(unit)\n    \n    # Compute effective costs and feasible ranges for flexible units\n    for unit in flexible:\n        if unit['u_i_0'] == 1:\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2) / unit['min_p']\n        else:\n            unit['min_p'] = unit['p_min_i']\n            unit['max_p'] = min(unit['p_max_i'], unit['p_start_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2 + unit['s_i']) / unit['min_p']\n    \n    # Commit units\n    committed = must_run.copy()\n    total_min = sum(unit['min_p'] for unit in committed)\n    total_max = sum(unit['max_p'] for unit in committed)\n    \n    # Sort flexible units by effective cost\n    flexible_sorted = sorted(flexible, key=lambda x: x['effective_cost'])\n    \n    # Commit flexible units until load is met\n    for unit in flexible_sorted:\n        if total_max >= current_load:\n            break\n        if unit['u_i_0'] == 0 and forecast_load > total_max:\n            unit['u_i'] = 1\n            committed.append(unit)\n            total_min += unit['min_p']\n            total_max += unit['max_p']\n    \n    # Economic dispatch\n    for unit in committed:\n        unit['p_i'] = unit['min_p']\n    \n    remaining_load = current_load - total_min\n    units_available = [u for u in committed if u['p_i'] < u['max_p']]\n    \n    while remaining_load > 0 and units_available:\n        # Find unit with lowest marginal cost\n        best_unit = min(units_available, \n                       key=lambda u: u['b_i'] + 2 * u['c_i'] * u['p_i'])\n        # Calculate available capacity\n        available = min(best_unit['max_p'] - best_unit['p_i'], remaining_load)\n        best_unit['p_i'] += available\n        remaining_load -= available\n        if best_unit['p_i'] >= best_unit['max_p']:\n            units_available.remove(best_unit)\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for idx, unit in enumerate(units):\n        schedules[0, idx] = unit.get('u_i', 0)\n        schedules[1, idx] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.003641132,
          "gap_price_rate": 0.0047652342,
          "fitness": 0.0042031831
     },
     {
          "name": "enhanced_forecast_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute dynamic feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Calculate adaptive cost metric combining marginal cost and forecast-adjusted startup costs\n4. Commit must-run units first, then flexible units in cost order until capacity meets current load\n5. Use forecast-aware adjustment to pre-commit additional units if forecasted load significantly exceeds current capacity\n6. Perform economic dispatch using iterative water-filling with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n\n",
          "code": "import numpy as np\n\ndef enhanced_forecast_rolling_uc_heuristic(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    current_load, forecast_load = load\n    n_units = len(units)\n    \n    # Classify units and compute feasible ranges\n    for unit in units:\n        # Determine must-run status\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                unit['must_run'] = True\n            else:\n                unit['must_run'] = False\n        else:\n            unit['must_run'] = False\n        \n        # Determine must-off status\n        if unit['u_i_0'] == 0:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                unit['must_off'] = True\n            else:\n                unit['must_off'] = False\n        else:\n            unit['must_off'] = False\n        \n        unit['flexible'] = not (unit['must_run'] or unit['must_off'])\n        \n        # Compute feasible power range\n        if unit['must_off']:\n            unit['min_feasible'] = 0\n            unit['max_feasible'] = 0\n        else:\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            unit['min_feasible'] = min_p\n            unit['max_feasible'] = max_p\n\n    # Calculate effective costs\n    for unit in units:\n        if unit['flexible']:\n            if unit['u_i_0'] == 0:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['min_feasible'] + unit['c_i'] * unit['min_feasible'] ** 2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * unit['min_feasible'] + unit['c_i'] * unit['min_feasible'] ** 2\n            unit['effective_cost'] = cost / unit['min_feasible'] if unit['min_feasible'] > 0 else float('inf')\n        else:\n            unit['effective_cost'] = float('inf')\n\n    # Commit units\n    committed_units = []\n    total_capacity = 0\n    \n    # Commit must-run units\n    for unit in units:\n        if unit['must_run']:\n            committed_units.append(unit)\n            total_capacity += unit['max_feasible']\n            unit['u_i'] = 1\n\n    # Commit flexible units by cost\n    flexible_units = [u for u in units if u['flexible']]\n    flexible_units.sort(key=lambda x: x['effective_cost'])\n    \n    for unit in flexible_units:\n        if total_capacity >= current_load:\n            break\n        if not unit['must_off']:\n            committed_units.append(unit)\n            total_capacity += unit['max_feasible']\n            unit['u_i'] = 1\n\n    # Forecast-aware adjustment\n    if forecast_load > total_capacity * 1.1:\n        for unit in flexible_units:\n            if unit['u_i'] == 0 and not unit['must_off']:\n                committed_units.append(unit)\n                total_capacity += unit['max_feasible']\n                unit['u_i'] = 1\n                break\n\n    # Economic dispatch\n    total_min = sum(unit['min_feasible'] for unit in committed_units)\n    remaining_load = current_load - total_min\n    \n    for unit in committed_units:\n        unit['p_i'] = unit['min_feasible']\n    \n    if remaining_load > 0:\n        # Allocate remaining load based on marginal cost\n        step = 0.1\n        while remaining_load > 0:\n            best_unit = None\n            best_mc = float('inf')\n            for unit in committed_units:\n                if unit['p_i'] < unit['max_feasible']:\n                    mc = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = unit\n            \n            if best_unit is None:\n                break\n                \n            allocation = min(step, best_unit['max_feasible'] - best_unit['p_i'], remaining_load)\n            best_unit['p_i'] += allocation\n            remaining_load -= allocation\n\n    # Ensure non-committed units are off\n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0\n\n    # Prepare output\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0052973368,
          "gap_price_rate": 0.0079675597,
          "fitness": 0.0066324483
     },
     {
          "name": "hybrid_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute dynamic feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Calculate adaptive cost metric combining marginal cost and forecast-adjusted startup costs\n4. Commit must-run units first, then flexible units using dual-stage cost ordering\n5. Perform predictive economic dispatch using water-filling with ramp-aware allocation\n6. Validate and refine schedule through iterative constraint satisfaction checks\n7. Implement forecast-aware adjustment using look-ahead strategy\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_uc_heuristic(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power range\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check must-run conditions\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            # Check must-off conditions\n            if (unit['t_i_0'] > -unit['t_off_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = p_min\n        feasible_max[i] = p_max\n    \n    # Calculate adaptive cost metric\n    cost_metric = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            # Include startup cost adjusted by forecast\n            forecast_factor = 1.0 if forecast_load > current_load else 0.5\n            startup_cost = unit['s_i'] * forecast_factor\n            base_cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + \n                         unit['c_i'] * feasible_min[i]**2)\n            cost_metric.append((i, (startup_cost + base_cost) / feasible_min[i]))\n        else:\n            marginal_cost = (unit['b_i'] + 2 * unit['c_i'] * feasible_min[i])\n            cost_metric.append((i, marginal_cost))\n    \n    # Sort by cost metric\n    cost_metric.sort(key=lambda x: x[1])\n    flexible_sorted = [x[0] for x in cost_metric]\n    \n    # Commit units\n    committed = set(must_run)\n    total_capacity = sum(feasible_max[i] for i in committed)\n    \n    for i in flexible_sorted:\n        if total_capacity < current_load:\n            committed.add(i)\n            total_capacity += feasible_max[i]\n        else:\n            break\n    \n    # Economic dispatch\n    remaining_load = current_load\n    for i in committed:\n        p[i] = feasible_min[i]\n        remaining_load -= p[i]\n    \n    # Water-filling allocation\n    while remaining_load > 1e-6:\n        best_unit = None\n        best_marginal_cost = float('inf')\n        for i in committed:\n            if p[i] < feasible_max[i]:\n                marginal_cost = (units_info[i]['b_i'] + \n                                2 * units_info[i]['c_i'] * p[i])\n                if marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        max_increase = min(remaining_load, \n                          feasible_max[best_unit] - p[best_unit],\n                          units_info[best_unit]['p_up_i'])\n        p[best_unit] += max_increase\n        remaining_load -= max_increase\n    \n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n    \n    # Validate constraints\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            assert p[i] <= unit['p_start_i'], \"Startup ramp violation\"\n        if p[i] < feasible_min[i] or p[i] > feasible_max[i]:\n            p[i] = np.clip(p[i], feasible_min[i], feasible_max[i])\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0051767579,
          "gap_price_rate": 0.0088352377,
          "fitness": 0.0070059978
     },
     {
          "name": "novel_rolling_uc_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints.\n3. Sort flexible units by average cost per MW at minimum output (including startup costs if applicable).\n4. Commit flexible units in cost order until total available capacity meets or exceeds current load.\n5. Dispatch load by setting committed units to their minimum output, then allocating remaining load based on marginal cost order.\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_min = np.zeros(n_units)\n    current_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n            current_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            current_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n            current_min[i] = p_min_i\n            current_max[i] = min(p_max_i, p_start_i)\n        \n        if must_off[i]:\n            current_min[i] = 0\n            current_max[i] = 0\n\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_per_mw = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        else:\n            total_cost = unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        cost_per_mw.append(total_cost / current_min[i] if current_min[i] > 0 else float('inf'))\n    \n    sorted_flexible = [i for _, i in sorted(zip(cost_per_mw, flexible_units))]\n    committed = must_run.copy()\n    total_max = np.sum(current_max[must_run])\n    \n    for i in sorted_flexible:\n        if total_max >= load[0]:\n            break\n        committed[i] = True\n        total_max += current_max[i]\n    \n    p_output = np.zeros(n_units)\n    for i in range(n_units):\n        if committed[i]:\n            p_output[i] = current_min[i]\n        else:\n            p_output[i] = 0\n            \n    remaining = load[0] - np.sum(p_output)\n    committed_indices = [i for i in range(n_units) if committed[i] and p_output[i] < current_max[i]]\n    \n    step = 1.0\n    while remaining > 0 and committed_indices:\n        marginal_costs = []\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_output[i])\n        idx_min = np.argmin(marginal_costs)\n        unit_idx = committed_indices[idx_min]\n        increase = min(step, current_max[unit_idx] - p_output[unit_idx], remaining)\n        p_output[unit_idx] += increase\n        remaining -= increase\n        if p_output[unit_idx] >= current_max[unit_idx]:\n            committed_indices.pop(idx_min)\n            \n    u_output = committed.astype(int)\n    schedules = np.array([u_output, p_output])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054284293,
          "gap_price_rate": 0.0087959181,
          "fitness": 0.0071121737
     },
     {
          "name": "enhanced_novel_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute dynamic feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Calculate adaptive cost metric combining marginal cost and forecast-adjusted startup costs\n4. Commit must-run units first, then flexible units using dual-stage cost ordering with forecast-aware adjustment\n5. Perform constrained economic dispatch using predictive water-filling with ramp-aware allocation\n6. Validate and refine schedule through iterative constraint satisfaction checks\n7. Implement look-ahead strategy using forecasted load to optimize unit commitments\n",
          "code": "import numpy as np\n\ndef enhanced_novel_rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Determine must-run/must-off status\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                u[i] = 1\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n                u[i] = 0\n            else:\n                flexible.append(i)\n        \n        # Compute feasible power ranges\n        if u[i] == 1 or i in flexible:\n            if unit['u_i_0'] == 1:\n                feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                feasible_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                feasible_min[i] = unit['p_min_i']\n                feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n\n    # Calculate adaptive costs\n    cost_metric = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            # Include startup cost amortized over forecast period\n            startup_cost = unit['s_i'] / max(1, forecast_load - current_load)\n            cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + \n                   unit['c_i'] * feasible_min[i]**2 + startup_cost) / feasible_min[i]\n        else:\n            cost = (unit['b_i'] + 2 * unit['c_i'] * feasible_min[i])\n        cost_metric.append((i, cost))\n    \n    # Sort by cost and commit flexible units\n    cost_metric.sort(key=lambda x: x[1])\n    total_capacity = sum(feasible_max[i] for i in must_run)\n    for i, _ in cost_metric:\n        if total_capacity < current_load:\n            u[i] = 1\n            total_capacity += feasible_max[i]\n        else:\n            break\n\n    # Economic dispatch with water-filling\n    committed = must_run + [i for i, _ in cost_metric if u[i] == 1]\n    base_load = sum(feasible_min[i] for i in committed)\n    remaining_load = current_load - base_load\n    \n    # Sort by marginal cost\n    marginal_costs = []\n    for i in committed:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        marginal_costs.append((i, marginal_cost))\n    marginal_costs.sort(key=lambda x: x[1])\n    \n    # Allocate remaining load\n    for i, _ in marginal_costs:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, feasible_max[i] - feasible_min[i])\n        p[i] = feasible_min[i] + allocatable\n        remaining_load -= allocatable\n    \n    # Constraint satisfaction check\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            ramp_limit = unit['p_i_0'] + unit['p_up_i'] if u[i] == 1 else 0\n            p[i] = min(p[i], ramp_limit)\n        p[i] = max(feasible_min[i], min(p[i], feasible_max[i]))\n    \n    # Ensure load balance\n    total_output = sum(p)\n    if total_output < current_load:\n        # Distribute deficit proportionally\n        for i in committed:\n            if feasible_max[i] > p[i]:\n                add_load = min(feasible_max[i] - p[i], current_load - total_output)\n                p[i] += add_load\n                total_output += add_load\n                if total_output >= current_load:\n                    break\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0057266399,
          "gap_price_rate": 0.0091521351,
          "fitness": 0.0074393875
     },
     {
          "name": "enhanced_novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced constraint checks including minimum up/down times, shutdown ramp limits, and forecast-aware conditions\n2. Compute dynamic feasible power ranges incorporating startup/shutdown ramp limits, current state, and forecasted load requirements with enhanced ramp rate handling\n3. Calculate adaptive cost metric combining marginal cost and forecast-adjusted startup costs with improved cost normalization\n4. Commit must-run units first, then flexible units using dual-stage cost ordering with forecast-aware adjustment\n5. Perform constrained economic dispatch using predictive water-filling with enhanced ramp-aware allocation and marginal cost balancing\n6. Validate and refine schedule through iterative constraint satisfaction checks and forecast-informed adjustments\n7. Implement look-ahead strategy using forecasted load to optimize unit commitments and minimize future costs\n\n",
          "code": "import numpy as np\n\ndef enhanced_novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        if u_i0 == 0:\n            high_bound = min(high_bound, p_start)\n        min_output[i] = low_bound\n        max_output[i] = high_bound\n        \n    total_must_run_cap = sum(max_output[i] for i in must_run)\n    flexible_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        u_i0 = unit['u_i_0']\n        min_p = max(min_output[i], 1e-5)\n        \n        cost_at_min = a + b * min_p + c * min_p**2\n        if u_i0 == 0:\n            if forecast_load > total_must_run_cap + max_output[i]:\n                cost_at_min += s / 2\n            else:\n                cost_at_min += s\n        cost_per_mw = cost_at_min / min_p\n        flexible_costs.append((i, cost_per_mw))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    total_cap = total_must_run_cap\n    \n    for i, _ in flexible_costs:\n        if total_cap >= current_load:\n            break\n        committed.append(i)\n        total_cap += max_output[i]\n    \n    if forecast_load > total_cap * 1.1:\n        for i, _ in flexible_costs:\n            if i not in committed:\n                committed.append(i)\n                break\n                \n    for i in committed:\n        u[i] = 1\n        p[i] = min_output[i]\n        \n    remaining_load = current_load - sum(p[i] for i in committed)\n    \n    while remaining_load > 1e-6:\n        best_unit = None\n        best_marginal_cost = float('inf')\n        for i in committed:\n            if p[i] < max_output[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = i\n        if best_unit is None:\n            break\n            \n        increase = min(remaining_load, max_output[best_unit] - p[best_unit])\n        p[best_unit] += increase\n        remaining_load -= increase\n        \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0059660516,
          "gap_price_rate": 0.0096700789,
          "fitness": 0.0078180652
     },
     {
          "name": "enhanced_forecast_aware_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute dynamic feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Calculate adaptive cost metric combining marginal cost and forecast-adjusted startup costs\n4. Commit must-run units first, then flexible units using dual-stage cost ordering with forecast-aware adjustment\n5. Perform constrained economic dispatch using predictive water-filling with ramp-aware allocation\n6. Validate and refine schedule through iterative constraint satisfaction checks\n7. Implement look-ahead strategy using forecasted load to optimize unit commitments\n\n",
          "code": "import numpy as np\n\ndef enhanced_forecast_aware_heuristic(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    effective_cost = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        u0, p0, t0 = unit['u_i_0'], unit['p_i_0'], unit['t_i_0']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_up, p_down = unit['p_up_i'], unit['p_down_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        min_up, min_down = unit['t_on_min_i'], unit['t_off_min_i']\n        startup_cost = unit['s_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            min_output[i] = max(p_min, p0 - p_down)\n            max_output[i] = min(p_max, p0 + p_up)\n            effective_cost[i] = (a + b * p_min + c * p_min**2) / p_min\n        else:\n            if abs(t0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            min_output[i] = p_min\n            max_output[i] = min(p_max, p_start)\n            effective_cost[i] = (startup_cost + a + b * p_min + c * p_min**2) / p_min\n        \n        marginal_cost[i] = b + 2 * c * p_min\n    \n    committed = set(must_run)\n    flexible_sorted = sorted(flexible, key=lambda i: effective_cost[i])\n    \n    total_min = sum(min_output[i] for i in committed)\n    total_max = sum(max_output[i] for i in committed)\n    \n    for i in flexible_sorted:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_output[i]\n            total_max += max_output[i]\n        else:\n            break\n    \n    if total_min > current_load:\n        expensive_units = sorted(committed - set(must_run), key=lambda i: effective_cost[i], reverse=True)\n        for i in expensive_units:\n            if total_min - min_output[i] <= current_load:\n                committed.remove(i)\n                total_min -= min_output[i]\n                total_max -= max_output[i]\n                break\n    \n    if total_max < forecast_load:\n        for i in flexible_sorted:\n            if i not in committed and total_max + max_output[i] >= forecast_load:\n                committed.add(i)\n                break\n    \n    for i in committed:\n        u[i] = 1\n        p[i] = min_output[i]\n    \n    remaining_load = current_load - sum(p)\n    units_by_marginal = sorted(committed, key=lambda i: marginal_cost[i])\n    \n    for i in units_by_marginal:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, max_output[i] - p[i])\n        p[i] += allocatable\n        remaining_load -= allocatable\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0057383207,
          "gap_price_rate": 0.0104369407,
          "fitness": 0.0080876307
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v3",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute dynamic feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Calculate adaptive cost metric combining marginal cost, flexibility penalty, and forecast-adjusted startup costs\n4. Commit must-run units first, then flexible units using dual-stage cost ordering with forecast-aware adjustment\n5. Perform constrained economic dispatch using predictive water-filling with ramp-aware allocation\n6. Validate and refine schedule through iterative constraint satisfaction checks\n7. Implement look-ahead strategy using forecasted load to optimize unit commitments\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v3(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run[i] = True\n            min_p[i] = max(p_min, p0 - p_down)\n            max_p[i] = min(p_max, p0 + p_up)\n        else:\n            if abs(t0) < min_down:\n                must_off[i] = True\n            min_p[i] = p_min\n            max_p[i] = min(p_max, p_start)\n        \n        if must_off[i]:\n            min_p[i] = 0\n            max_p[i] = 0\n\n    u[must_run] = 1\n    flexible_mask = ~(must_run | must_off)\n    flexible_indices = np.where(flexible_mask)[0]\n    \n    effective_costs = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        min_up_time = unit['t_on_min_i']\n        p_min_val = min_p[i]\n        \n        if units_info[i]['u_i_0'] == 0:\n            forecast_factor = max(1, forecast_load / current_load) if current_load > 0 else 1\n            amortized_s = s * forecast_factor / min_up_time\n            total_cost = a + b * p_min_val + c * p_min_val**2 + amortized_s\n        else:\n            total_cost = a + b * p_min_val + c * p_min_val**2\n            \n        effective_cost = total_cost / p_min_val if p_min_val > 0 else float('inf')\n        effective_costs.append((i, effective_cost))\n    \n    effective_costs.sort(key=lambda x: x[1])\n    total_min = np.sum(min_p[u == 1])\n    total_max = np.sum(max_p[u == 1])\n    \n    for i, _ in effective_costs:\n        if total_max >= current_load:\n            break\n        if total_min + min_p[i] <= current_load or total_max < current_load:\n            u[i] = 1\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    if forecast_load > current_load and total_max < forecast_load:\n        for i, _ in effective_costs:\n            if u[i] == 0 and total_max + max_p[i] >= forecast_load:\n                u[i] = 1\n                total_max += max_p[i]\n                break\n    \n    p[u == 1] = min_p[u == 1]\n    rem = current_load - np.sum(p)\n    \n    committed_indices = np.where(u == 1)[0]\n    while rem > 0:\n        marginal_costs = []\n        for i in committed_indices:\n            if p[i] >= max_p[i]:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginal_costs.append((i, marginal_cost))\n        \n        if not marginal_costs:\n            break\n            \n        marginal_costs.sort(key=lambda x: x[1])\n        i, min_mc = marginal_costs[0]\n        increase = min(rem, max_p[i] - p[i])\n        p[i] += increase\n        rem -= increase\n    \n    while rem < 0:\n        marginal_costs = []\n        for i in committed_indices:\n            if p[i] <= min_p[i]:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginal_costs.append((i, marginal_cost))\n        \n        if not marginal_costs:\n            break\n            \n        marginal_costs.sort(key=lambda x: x[1], reverse=True)\n        i, max_mc = marginal_costs[0]\n        decrease = min(-rem, p[i] - min_p[i])\n        p[i] -= decrease\n        rem += decrease\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0061842974,
          "gap_price_rate": 0.0102074686,
          "fitness": 0.008195883
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets load\n5. Perform economic dispatch by setting committed units to minimum output, then allocating remaining load based on marginal cost\n6. Adjust outputs to respect all constraints including ramp rates and min/max limits\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = [0] * n_units\n    feasible_max = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < t_on_min or p0 > p_shut):\n            must_run.append(i)\n            min_p = max(p_min, p0 - p_down)\n            max_p = min(p_max, p0 + p_up)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n        elif u0 == 0 and abs(t0) < t_off_min:\n            must_off.append(i)\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n        else:\n            flexible.append(i)\n            if u0 == 1:\n                min_p = max(p_min, p0 - p_down)\n                max_p = min(p_max, p0 + p_up)\n            else:\n                min_p = p_min\n                max_p = min(p_max, p_start)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n\n    committed = set()\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        committed.add(i)\n        schedules[0, i] = 1\n        schedules[1, i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        else:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        effective_costs.append((cost, i))\n    \n    effective_costs.sort(key=lambda x: x[0])\n    \n    for cost, i in effective_costs:\n        if total_max >= current_load:\n            break\n        if i not in committed and i not in must_off:\n            committed.add(i)\n            schedules[0, i] = 1\n            schedules[1, i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n    \n    current_total = total_min\n    remaining_load = current_load - current_total\n    \n    adjustable_units = [i for i in committed if feasible_max[i] > feasible_min[i]]\n    \n    if remaining_load > 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for mc, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            available = feasible_max[i] - schedules[1, i]\n            to_add = min(remaining_load, available)\n            schedules[1, i] += to_add\n            remaining_load -= to_add\n            \n    elif remaining_load < 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for mc, i in marginal_costs:\n            if remaining_load >= 0:\n                break\n            available = schedules[1, i] - feasible_min[i]\n            to_reduce = min(-remaining_load, available)\n            schedules[1, i] -= to_reduce\n            remaining_load += to_reduce\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v6",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced constraints including min up/down times, shutdown ramp limits, and forecast-aware conditions with improved startup cost amortization\n2. Calculate dynamic feasible power ranges incorporating startup/shutdown ramp limits, current state, and forecasted load requirements with enhanced ramp rate handling\n3. Compute adaptive cost metric combining marginal cost, flexibility penalty, and forecast-adjusted startup costs with improved cost normalization\n4. Commit must-run units first, then flexible units using dual-stage cost ordering with forecast-aware adjustment and look-ahead commitment strategy\n5. Perform constrained economic dispatch using predictive water-filling with enhanced ramp-aware allocation and marginal cost balancing\n6. Validate and refine schedule through iterative constraint satisfaction checks and forecast-informed adjustments with priority on must-run units\n7. Implement enhanced look-ahead strategy using forecasted load to optimize unit commitments and minimize future costs with improved cost-benefit analysis\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v6(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    categories = np.full(n_units, 'flexible')  # must-run, must-off, flexible\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    effective_cost = np.zeros(n_units)\n    \n    # Step 1: Classify units and calculate feasible ranges\n    for i, unit in enumerate(units_info):\n        # Determine must-run and must-off units\n        if unit['u_i_0'] == 1:  # currently on\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                categories[i] = 'must-run'\n            else:\n                categories[i] = 'flexible'\n        else:  # currently off\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                categories[i] = 'must-off'\n            else:\n                categories[i] = 'flexible'\n        \n        # Calculate feasible power range\n        if categories[i] == 'must-off':\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n        else:\n            if unit['u_i_0'] == 1:\n                ramp_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ramp_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ramp_min = unit['p_min_i']\n                ramp_max = min(unit['p_max_i'], unit['p_start_i'])\n            feasible_min[i] = ramp_min\n            feasible_max[i] = ramp_max\n    \n    # Step 2: Calculate effective costs\n    for i, unit in enumerate(units_info):\n        if categories[i] == 'must-off':\n            effective_cost[i] = float('inf')\n        else:\n            # Calculate normalized startup cost\n            startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n            normalized_startup = startup_cost / max(1, unit['t_on_min_i'])\n            \n            # Calculate production cost at minimum output\n            min_output_cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + \n                             unit['c_i'] * feasible_min[i] ** 2)\n            \n            # Combine costs with flexibility penalty\n            flexibility_penalty = 0.1 * (feasible_max[i] - feasible_min[i]) / max(1, feasible_max[i])\n            effective_cost[i] = (normalized_startup + min_output_cost) / max(1, feasible_min[i]) + flexibility_penalty\n    \n    # Step 3: Commit units\n    committed_units = []\n    total_capacity = 0\n    \n    # Commit must-run units first\n    for i in range(n_units):\n        if categories[i] == 'must-run':\n            u[i] = 1\n            p[i] = feasible_min[i]\n            total_capacity += feasible_max[i]\n            committed_units.append(i)\n    \n    # Sort flexible units by effective cost\n    flexible_indices = [i for i in range(n_units) if categories[i] == 'flexible']\n    flexible_indices.sort(key=lambda i: effective_cost[i])\n    \n    # Commit flexible units until load is met, considering forecast\n    for i in flexible_indices:\n        if total_capacity < max(current_load, forecast_load * 0.95):\n            u[i] = 1\n            p[i] = feasible_min[i]\n            total_capacity += feasible_max[i]\n            committed_units.append(i)\n    \n    # Step 4: Economic dispatch\n    remaining_load = current_load - sum(p)\n    \n    # Sort committed units by marginal cost\n    committed_units.sort(key=lambda i: 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i'])\n    \n    # Allocate remaining load\n    for i in committed_units:\n        if remaining_load <= 0:\n            break\n        \n        available = min(feasible_max[i] - p[i], remaining_load)\n        p[i] += available\n        remaining_load -= available\n    \n    # Step 5: Constraint satisfaction check\n    for i in committed_units:\n        # Ensure output within feasible range\n        p[i] = np.clip(p[i], feasible_min[i], feasible_max[i])\n    \n    # Ensure load balance\n    total_output = sum(p)\n    if abs(total_output - current_load) > 1e-6:\n        # Adjust output proportionally\n        ratio = current_load / total_output\n        for i in committed_units:\n            p[i] *= ratio\n            p[i] = np.clip(p[i], feasible_min[i], feasible_max[i])\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0031556157,
          "gap_price_rate": 0.0132660366,
          "fitness": 0.0082108262
     }
]