[
     {
          "name": "novel_rolling_uc_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints.\n3. Sort flexible units by average cost per MW at minimum output (including startup costs if applicable).\n4. Commit flexible units in cost order until total available capacity meets or exceeds current load.\n5. Dispatch load by setting committed units to their minimum output, then allocating remaining load based on marginal cost order.\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_min = np.zeros(n_units)\n    current_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n            current_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            current_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n            current_min[i] = p_min_i\n            current_max[i] = min(p_max_i, p_start_i)\n        \n        if must_off[i]:\n            current_min[i] = 0\n            current_max[i] = 0\n\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_per_mw = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        else:\n            total_cost = unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        cost_per_mw.append(total_cost / current_min[i] if current_min[i] > 0 else float('inf'))\n    \n    sorted_flexible = [i for _, i in sorted(zip(cost_per_mw, flexible_units))]\n    committed = must_run.copy()\n    total_max = np.sum(current_max[must_run])\n    \n    for i in sorted_flexible:\n        if total_max >= load[0]:\n            break\n        committed[i] = True\n        total_max += current_max[i]\n    \n    p_output = np.zeros(n_units)\n    for i in range(n_units):\n        if committed[i]:\n            p_output[i] = current_min[i]\n        else:\n            p_output[i] = 0\n            \n    remaining = load[0] - np.sum(p_output)\n    committed_indices = [i for i in range(n_units) if committed[i] and p_output[i] < current_max[i]]\n    \n    step = 1.0\n    while remaining > 0 and committed_indices:\n        marginal_costs = []\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_output[i])\n        idx_min = np.argmin(marginal_costs)\n        unit_idx = committed_indices[idx_min]\n        increase = min(step, current_max[unit_idx] - p_output[unit_idx], remaining)\n        p_output[unit_idx] += increase\n        remaining -= increase\n        if p_output[unit_idx] >= current_max[unit_idx]:\n            committed_indices.pop(idx_min)\n            \n    u_output = committed.astype(int)\n    schedules = np.array([u_output, p_output])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054284293,
          "gap_price_rate": 0.0087959181,
          "fitness": 0.0071121737
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets load\n5. Perform economic dispatch by setting committed units to minimum output, then allocating remaining load based on marginal cost\n6. Adjust outputs to respect all constraints including ramp rates and min/max limits\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = [0] * n_units\n    feasible_max = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < t_on_min or p0 > p_shut):\n            must_run.append(i)\n            min_p = max(p_min, p0 - p_down)\n            max_p = min(p_max, p0 + p_up)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n        elif u0 == 0 and abs(t0) < t_off_min:\n            must_off.append(i)\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n        else:\n            flexible.append(i)\n            if u0 == 1:\n                min_p = max(p_min, p0 - p_down)\n                max_p = min(p_max, p0 + p_up)\n            else:\n                min_p = p_min\n                max_p = min(p_max, p_start)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n\n    committed = set()\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        committed.add(i)\n        schedules[0, i] = 1\n        schedules[1, i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        else:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        effective_costs.append((cost, i))\n    \n    effective_costs.sort(key=lambda x: x[0])\n    \n    for cost, i in effective_costs:\n        if total_max >= current_load:\n            break\n        if i not in committed and i not in must_off:\n            committed.add(i)\n            schedules[0, i] = 1\n            schedules[1, i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n    \n    current_total = total_min\n    remaining_load = current_load - current_total\n    \n    adjustable_units = [i for i in committed if feasible_max[i] > feasible_min[i]]\n    \n    if remaining_load > 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for mc, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            available = feasible_max[i] - schedules[1, i]\n            to_add = min(remaining_load, available)\n            schedules[1, i] += to_add\n            remaining_load -= to_add\n            \n    elif remaining_load < 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for mc, i in marginal_costs:\n            if remaining_load >= 0:\n                break\n            available = schedules[1, i] - feasible_min[i]\n            to_reduce = min(-remaining_load, available)\n            schedules[1, i] -= to_reduce\n            remaining_load += to_reduce\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Compute feasible power ranges considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost (including startup if applicable) for flexible units at min output\n4. Commit must-run units first, then flexible units by effective cost until load is met\n5. Adjust commitment using forecasted load to minimize future startup costs\n6. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n7. Ensure all constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    flexible = [False] * n_units\n    p_min_feasible = [0.0] * n_units\n    p_max_feasible = [0.0] * n_units\n    effective_cost = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off[i] = True\n        else:\n            flexible[i] = True\n            \n        # Step 2: Compute feasible power ranges\n        if must_run[i] or (flexible[i] and u_i0 == 1):\n            p_min_feasible[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        elif flexible[i] and u_i0 == 0:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min_feasible[i], p_max_feasible[i] = 0, 0\n            \n        # Step 3: Calculate effective cost\n        if flexible[i]:\n            if u_i0 == 0:\n                cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min_feasible[i] + \n                        unit['c_i'] * p_min_feasible[i] ** 2)\n            else:\n                cost = (unit['a_i'] + unit['b_i'] * p_min_feasible[i] + \n                        unit['c_i'] * p_min_feasible[i] ** 2)\n            effective_cost[i] = cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n    \n    # Step 4: Initial commitment\n    committed = must_run[:]\n    total_capacity = sum(p_max_feasible[i] for i in range(n_units) if committed[i])\n    \n    # Commit flexible units by cost\n    flexible_indices = [i for i in range(n_units) if flexible[i]]\n    flexible_indices.sort(key=lambda i: effective_cost[i])\n    \n    for i in flexible_indices:\n        if total_capacity < current_load and not must_off[i]:\n            committed[i] = True\n            total_capacity += p_max_feasible[i]\n    \n    # Step 5: Adjust for forecasted load\n    forecast_capacity = total_capacity + sum(\n        min(unit['p_up_i'], unit['p_max_i'] - p_max_feasible[i]) \n        for i, unit in enumerate(units_info) if committed[i]\n    )\n    \n    if forecast_capacity < forecast_load:\n        for i in flexible_indices:\n            if not committed[i] and not must_off[i]:\n                committed[i] = True\n                break\n    \n    # Step 6: Economic dispatch\n    # Set initial outputs to min feasible\n    p_outputs = [p_min_feasible[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = current_load - sum(p_outputs)\n    \n    # Create priority list for dispatch\n    dispatch_order = [i for i in range(n_units) if committed[i]]\n    dispatch_order.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i])\n    \n    # Allocate remaining load\n    for i in dispatch_order:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, p_max_feasible[i] - p_outputs[i])\n        p_outputs[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Step 7: Constraint satisfaction check\n    for i in range(n_units):\n        if committed[i]:\n            # Ensure within feasible range\n            p_outputs[i] = max(p_min_feasible[i], min(p_max_feasible[i], p_outputs[i]))\n            # Ensure ramp constraints\n            if units_info[i]['u_i_0'] == 1:\n                p_outputs[i] = min(p_outputs[i], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                p_outputs[i] = max(p_outputs[i], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n    \n    # Prepare output\n    schedules[0, :] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1, :] = p_outputs\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0059278578,
          "gap_price_rate": 0.0112066471,
          "fitness": 0.0085672524
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v3",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v3(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Determine must-run/must-off status\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            min_p[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            if -t0 < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if i in must_off:\n            min_p[i] = 0\n            max_p[i] = 0\n\n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_p[i] + \n                   unit['c_i']*min_p[i]**2) / min_p[i]\n        else:\n            cost = (unit['a_i'] + unit['b_i']*min_p[i] + \n                   unit['c_i']*min_p[i]**2) / min_p[i]\n        costs.append((cost, i))\n    \n    costs.sort(key=lambda x: x[0])\n    flexible_sorted = [i for _, i in costs]\n\n    # Initial commitment\n    committed = set(must_run)\n    total_min = sum(min_p[i] for i in committed)\n    total_max = sum(max_p[i] for i in committed)\n    \n    # Commit flexible units\n    for i in flexible_sorted:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            break\n\n    # Adjust commitment based on forecast\n    if forecast_load > total_max * 0.9:\n        for i in flexible_sorted:\n            if i not in committed and total_max + max_p[i] >= forecast_load:\n                committed.add(i)\n                break\n    elif forecast_load < total_min * 1.1:\n        for i in reversed(flexible_sorted):\n            if i in committed and total_min - min_p[i] <= forecast_load:\n                committed.remove(i)\n                break\n\n    # Economic dispatch\n    for i in committed:\n        p[i] = min_p[i]\n    \n    remaining = current_load - sum(p)\n    committed_list = list(committed)\n    \n    # Allocate remaining load\n    while abs(remaining) > 1e-5:\n        if remaining > 0:\n            # Find unit with lowest marginal cost\n            marginal_costs = []\n            for i in committed_list:\n                if p[i] < max_p[i]:\n                    mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort()\n            i = marginal_costs[0][1]\n            add = min(remaining, max_p[i] - p[i])\n            p[i] += add\n            remaining -= add\n        else:\n            # Find unit with highest marginal cost\n            marginal_costs = []\n            for i in committed_list:\n                if p[i] > min_p[i]:\n                    mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(reverse=True)\n            i = marginal_costs[0][1]\n            reduce = min(-remaining, p[i] - min_p[i])\n            p[i] -= reduce\n            remaining += reduce\n\n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n\n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0059642692,
          "gap_price_rate": 0.0129901629,
          "fitness": 0.009477216
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load: if forecast exceeds current capacity, commit additional flexible units; if forecast is lower, consider deactivating flexible units\n6. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n7. Ensure all physical constraints are satisfied through iterative refinement\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        # Determine must-run and must-off status\n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(p_max_i, p_start_i, p_up_i)\n    \n    # Calculate effective costs for flexible units\n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        s_i, u_i_0 = unit['s_i'], unit['u_i_0']\n        p_min_i = feasible_min[i]\n        \n        if u_i_0 == 0:\n            cost = (s_i + a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i\n        else:\n            cost = (a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i\n        effective_costs.append((i, cost))\n    \n    # Sort flexible units by effective cost\n    effective_costs.sort(key=lambda x: x[1])\n    sorted_flexible = [x[0] for x in effective_costs]\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_min = sum(feasible_min[i] for i in committed)\n    total_max = sum(feasible_max[i] for i in committed)\n    \n    # Commit flexible units until load is met\n    for i in sorted_flexible:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Adjust commitment based on forecast\n    if forecast_load > total_max:\n        for i in sorted_flexible:\n            if i not in committed and forecast_load > total_max:\n                committed.add(i)\n                total_min += feasible_min[i]\n                total_max += feasible_max[i]\n            else:\n                break\n    elif forecast_load < total_min:\n        for i in reversed(sorted_flexible):\n            if i in committed and forecast_load < total_min - feasible_min[i]:\n                committed.remove(i)\n                total_min -= feasible_min[i]\n                total_max -= feasible_max[i]\n            else:\n                break\n    \n    # Initialize outputs\n    for i in committed:\n        u[i] = 1\n        p[i] = feasible_min[i]\n    \n    # Economic dispatch\n    remaining = current_load - sum(p)\n    marginal_costs = []\n    for i in committed:\n        unit = units_info[i]\n        b_i, c_i = unit['b_i'], unit['c_i']\n        marginal_cost = b_i + 2 * c_i * p[i]\n        marginal_costs.append((i, marginal_cost))\n    \n    while remaining > 0:\n        marginal_costs.sort(key=lambda x: x[1])\n        updated = False\n        for i, mc in marginal_costs:\n            if p[i] < feasible_max[i]:\n                delta = min(remaining, feasible_max[i] - p[i])\n                p[i] += delta\n                remaining -= delta\n                unit = units_info[i]\n                b_i, c_i = unit['b_i'], unit['c_i']\n                new_mc = b_i + 2 * c_i * p[i]\n                # Update marginal cost\n                idx = next((idx for idx, (idx_i, _) in enumerate(marginal_costs) if idx_i == i), None)\n                if idx is not None:\n                    marginal_costs[idx] = (i, new_mc)\n                updated = True\n                if remaining <= 0:\n                    break\n        if not updated:\n            break\n    \n    # Ensure must-off units are off\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.003515163,
          "gap_price_rate": 0.0161216978,
          "fitness": 0.0098184304
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, flexible-on, and must-off based on min up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges incorporating startup/shutdown ramp limits and current state\n3. Prioritize flexible units using adaptive cost metric combining marginal cost and flexibility penalty\n4. Commit units using forecast-aware strategy to minimize unnecessary startups\n5. Perform constrained economic dispatch using iterative water-filling with ramp constraints\n6. Validate and adjust schedule to ensure all physical constraints are satisfied\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run.append(i)\n        # Check must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if i in must_off:\n            p_min[i] = 0\n            p_max[i] = 0\n            continue\n            \n        base_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        base_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        # Startup constraints\n        if unit['u_i_0'] == 0:\n            base_max = min(base_max, unit['p_start_i'])\n        \n        # Shutdown constraints\n        if i not in must_run and forecast_load < current_load:\n            base_max = min(base_max, unit['p_shut_i'])\n            \n        p_min[i] = base_min\n        p_max[i] = base_max\n    \n    # Adaptive cost calculation\n    def calculate_cost(unit_idx, forecast_aware=False):\n        unit = units_info[unit_idx]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min[unit_idx]\n        \n        if unit['u_i_0'] == 0:\n            startup_cost = unit['s_i'] / max(1, p_min[unit_idx])\n        else:\n            startup_cost = 0\n            \n        flexibility_penalty = 0\n        if forecast_aware:\n            ramp_range = unit['p_up_i'] + unit['p_down_i']\n            flexibility_penalty = (1 - ramp_range/unit['p_max_i']) * 0.1\n            \n        return marginal_cost + startup_cost + flexibility_penalty\n    \n    # Commit units\n    committed = set(must_run)\n    total_capacity = sum(p_max[i] for i in committed)\n    \n    # Sort flexible units by adaptive cost\n    flexible_sorted = sorted(flexible, key=lambda i: calculate_cost(i, True))\n    \n    for i in flexible_sorted:\n        if total_capacity < current_load:\n            committed.add(i)\n            total_capacity += p_max[i]\n        elif total_capacity - p_max[i] >= current_load and i in committed:\n            committed.remove(i)\n            total_capacity -= p_max[i]\n    \n    # Economic dispatch\n    remaining_load = current_load\n    for i in committed:\n        schedules[0][i] = 1\n        schedules[1][i] = p_min[i]\n        remaining_load -= p_min[i]\n    \n    # Water-filling allocation\n    while abs(remaining_load) > 1e-6:\n        # Find unit with smallest marginal cost that can adjust\n        best_unit = None\n        best_marginal_cost = float('inf')\n        \n        for i in committed:\n            unit = units_info[i]\n            current_p = schedules[1][i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0 and current_p < p_max[i] and marginal_cost < best_marginal_cost:\n                best_unit = i\n                best_marginal_cost = marginal_cost\n            elif remaining_load < 0 and current_p > p_min[i] and -marginal_cost < best_marginal_cost:\n                best_unit = i\n                best_marginal_cost = -marginal_cost\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = schedules[1][best_unit]\n        max_adjust = min(remaining_load, p_max[best_unit] - current_p) if remaining_load > 0 \\\n                   else max(remaining_load, p_min[best_unit] - current_p)\n        \n        schedules[1][best_unit] += max_adjust\n        remaining_load -= max_adjust\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0063009957,
          "gap_price_rate": 0.0138955959,
          "fitness": 0.0100982958
     },
     {
          "name": "novel_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Prioritize flexible units using effective cost per MW (including startup costs if applicable)\n4. Adjust commitment based on current load and forecasted load:\n   - If load exceeds must-run capacity, activate flexible units by cost priority\n   - If load is below must-run minimum, deactivate flexible units by cost priority\n   - Consider forecasted load to minimize unnecessary state changes\n5. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize arrays for unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u_prev = np.array([unit['u_i_0'] for unit in units_info])\n    t_prev = np.array([unit['t_i_0'] for unit in units_info])\n    p_prev = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Classify units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if abs(t_prev[i]) < min_down[i]:\n                must_off[i] = True\n    \n    # Calculate feasible power ranges\n    p_low = np.zeros(n_units)\n    p_high = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            p_low[i] = max(p_min[i], p_prev[i] - p_down[i])\n            p_high[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            p_low[i] = p_min[i]\n            p_high[i] = min(p_max[i], p_start[i])\n    \n    # Calculate effective costs\n    effective_cost = np.zeros(n_units)\n    for i in range(n_units):\n        if u_prev[i] == 0 and not must_off[i]:\n            effective_cost[i] = (a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2 + startup_cost[i]) / p_min[i]\n        else:\n            effective_cost[i] = (a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2) / p_min[i]\n    \n    # Initial commitment\n    u_current = np.copy(u_prev)\n    u_current[must_run] = 1\n    u_current[must_off] = 0\n    \n    # Adjust commitment based on load\n    total_min = np.sum(p_low[u_current == 1])\n    total_max = np.sum(p_high[u_current == 1])\n    \n    if current_load > total_max:\n        # Need to activate more units\n        flexible = ~(must_run | must_off)\n        candidates = np.where(flexible & (u_current == 0))[0]\n        if len(candidates) > 0:\n            idx = candidates[np.argsort(effective_cost[candidates])]\n            for i in idx:\n                if total_max >= current_load:\n                    break\n                u_current[i] = 1\n                total_max += p_high[i]\n    elif current_load < total_min:\n        # Need to deactivate units\n        flexible = ~(must_run | must_off)\n        candidates = np.where(flexible & (u_current == 1))[0]\n        if len(candidates) > 0:\n            idx = candidates[np.argsort(-effective_cost[candidates])]\n            for i in idx:\n                if total_min <= current_load:\n                    break\n                u_current[i] = 0\n                total_min -= p_low[i]\n    \n    # Economic dispatch\n    p_current = np.zeros(n_units)\n    committed = np.where(u_current == 1)[0]\n    \n    # Set to minimum first\n    for i in committed:\n        p_current[i] = p_low[i]\n    \n    remaining_load = current_load - np.sum(p_current[committed])\n    \n    # Allocate remaining load based on marginal cost\n    while remaining_load > 1e-6 and len(committed) > 0:\n        marginal_costs = b[committed] + 2 * c[committed] * p_current[committed]\n        idx = np.argmin(marginal_costs)\n        unit_idx = committed[idx]\n        available = p_high[unit_idx] - p_current[unit_idx]\n        add_load = min(remaining_load, available)\n        p_current[unit_idx] += add_load\n        remaining_load -= add_load\n        if available <= add_load:\n            committed = np.delete(committed, idx)\n    \n    # Reduce excess generation\n    while remaining_load < -1e-6 and len(committed) > 0:\n        marginal_costs = b[committed] + 2 * c[committed] * p_current[committed]\n        idx = np.argmax(marginal_costs)\n        unit_idx = committed[idx]\n        reducible = p_current[unit_idx] - p_low[unit_idx]\n        reduce_load = min(-remaining_load, reducible)\n        p_current[unit_idx] -= reduce_load\n        remaining_load += reduce_load\n        if reducible <= reduce_load:\n            committed = np.delete(committed, idx)\n    \n    schedules[0] = u_current\n    schedules[1] = p_current\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into forced-on, forced-off, and free based on minimum up/down times and shutdown ramp constraints\n2. Calculate total available capacity from committed units considering ramp limits\n3. If load exceeds capacity, activate free units by ascending marginal cost at minimum output\n4. If load is below minimum generation, deactivate free units by descending marginal cost\n5. Perform economic dispatch using water-filling algorithm to allocate load optimally\n6. Ensure output respects unit constraints including ramp rates and min/max limits\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    forced_on = np.zeros(n_units, dtype=bool)\n    forced_off = np.zeros(n_units, dtype=bool)\n    \n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n            else:\n                forced_off[i] = False\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n            else:\n                forced_on[i] = False\n    \n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_outputs[i] = unit['p_min_i']\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    total_min = np.sum(min_outputs[u == 1])\n    total_max = np.sum(max_outputs[u == 1])\n    \n    free_indices = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if current_load > total_max:\n        off_free = [i for i in free_indices if u[i] == 0]\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'] for i in off_free]\n        sorted_off = [x for _, x in sorted(zip(marginal_costs, off_free))]\n        \n        for i in sorted_off:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_outputs[i] = units_info[i]['p_min_i']\n            max_outputs[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    elif current_load < total_min:\n        on_free = [i for i in free_indices if u[i] == 1]\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_outputs[i] for i in on_free]\n        sorted_on = [x for _, x in sorted(zip(marginal_costs, on_free), reverse=True)]\n        \n        for i in sorted_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    committed = np.where(u == 1)[0]\n    if len(committed) == 0:\n        return np.array([u, p])\n    \n    min_vals = min_outputs[committed]\n    max_vals = max_outputs[committed]\n    b_vals = [units_info[i]['b_i'] for i in committed]\n    c_vals = [units_info[i]['c_i'] for i in committed]\n    \n    allocations = min_vals.copy()\n    remaining = current_load - np.sum(allocations)\n    \n    while remaining > 1e-6:\n        marginal_costs = [b + 2 * c * alloc for b, c, alloc in zip(b_vals, c_vals, allocations)]\n        min_marginal = float('inf')\n        best_index = -1\n        for i, (mc, alloc) in enumerate(zip(marginal_costs, allocations)):\n            if alloc < max_vals[i] and mc < min_marginal:\n                min_marginal = mc\n                best_index = i\n        \n        if best_index == -1:\n            break\n            \n        max_add = max_vals[best_index] - allocations[best_index]\n        add = min(remaining, max_add)\n        allocations[best_index] += add\n        remaining -= add\n    \n    for i, idx in enumerate(committed):\n        p[idx] = allocations[i]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0375214362,
          "fitness": 0.0187965642
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, available, and unavailable based on current state and constraints\n2. Calculate feasible power ranges considering ramp limits and min up/down times\n3. Prioritize units using effective cost per MW (including startup costs)\n4. Commit units until load is met, considering must-run units first\n5. Dispatch load economically among committed units using marginal cost sorting\n6. Adjust commitment based on forecasted load to minimize future costs\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    min_out = np.zeros(n_units)\n    max_out = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    available = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_up = unit['p_up_i']\n        ramp_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run[i] = True\n            min_out[i] = max(p_min, p0 - ramp_down)\n            max_out[i] = min(p_max, p0 + ramp_up)\n            available[i] = True\n        else:\n            if abs(t0) >= min_down:\n                min_out[i] = p_min\n                max_out[i] = min(p_max, p_start)\n                available[i] = True\n            else:\n                min_out[i] = 0\n                max_out[i] = 0\n    \n    committed = np.where(must_run)[0].tolist()\n    total_min = sum(min_out[committed])\n    total_max = sum(max_out[committed])\n    \n    if total_min > current_load:\n        for i in committed:\n            p[i] = min_out[i]\n            u[i] = 1\n        remaining = current_load - total_min\n        idx = np.argsort([units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i] for i in committed])\n        for i in idx:\n            reducible = p[committed[i]] - min_out[committed[i]]\n            if reducible >= -remaining:\n                p[committed[i]] += remaining\n                break\n            else:\n                remaining += reducible\n                p[committed[i]] = min_out[committed[i]]\n        return np.array([u, p])\n    \n    candidate_units = [i for i in range(n_units) if available[i] and not must_run[i]]\n    cost_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['b_i']*min_out[i] + unit['c_i']*min_out[i]**2) / min_out[i]\n        else:\n            cost = unit['b_i'] + 2*unit['c_i']*min_out[i]\n        cost_list.append((cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    for cost, i in cost_list:\n        if total_max >= current_load:\n            break\n        committed.append(i)\n        total_max += max_out[i]\n    \n    for i in committed:\n        p[i] = min_out[i]\n        u[i] = 1\n    \n    remaining_load = current_load - sum(p)\n    while remaining_load > 1e-6:\n        marginal_costs = []\n        for i in committed:\n            if p[i] < max_out[i]:\n                mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                marginal_costs.append((mc, i))\n        if not marginal_costs:\n            break\n        marginal_costs.sort(key=lambda x: x[0])\n        best_unit = marginal_costs[0][1]\n        add_cap = min(remaining_load, max_out[best_unit] - p[best_unit])\n        p[best_unit] += add_cap\n        remaining_load -= add_cap\n    \n    if forecast_load > current_load and total_max < forecast_load:\n        for cost, i in cost_list:\n            if i not in committed:\n                committed.append(i)\n                u[i] = 1\n                p[i] = min_out[i]\n                total_max += max_out[i]\n                if total_max >= forecast_load:\n                    break\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0120057296,
          "gap_price_rate": 0.025759297,
          "fitness": 0.0188825133
     },
     {
          "name": "commit_units_rolling_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on current state and constraints\n2. Form preliminary commitment from must-run and currently online flexible units\n3. Adjust commitment based on load demand:\n   - If insufficient capacity, activate flexible offline units by cost priority\n   - If excess capacity, deactivate flexible online units by cost priority\n4. Perform economic dispatch using incremental cost sorting\n5. Adjust outputs to respect ramp limits and min/max constraints\n6. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute average cost at max output\n    avg_costs = []\n    for unit in units_info:\n        max_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i'] ** 2\n        avg_costs.append(max_cost / unit['p_max_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Preliminary commitment\n    committed = set(must_run)\n    for i in flexible:\n        if units_info[i]['u_i_0'] == 1:\n            committed.add(i)\n    \n    # Check capacity and adjust commitment\n    total_min = sum(units_info[i]['p_min_i'] for i in committed)\n    total_max = sum(units_info[i]['p_max_i'] for i in committed)\n    current_load = load[0]\n    \n    # Add units if needed\n    if total_max < current_load:\n        offline_flexible = [i for i in flexible if units_info[i]['u_i_0'] == 0 and i not in must_off]\n        offline_flexible.sort(key=lambda i: avg_costs[i])\n        for i in offline_flexible:\n            committed.add(i)\n            total_max += units_info[i]['p_max_i']\n            if total_max >= current_load:\n                break\n    \n    # Remove units if possible\n    if total_min > current_load:\n        online_flexible = [i for i in flexible if units_info[i]['u_i_0'] == 1 and i not in must_run]\n        online_flexible.sort(key=lambda i: avg_costs[i], reverse=True)\n        for i in online_flexible:\n            if i in committed:\n                committed.remove(i)\n                total_min -= units_info[i]['p_min_i']\n                if total_min <= current_load:\n                    break\n    \n    # Economic dispatch\n    committed = list(committed)\n    # Initialize outputs\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        p[i] = low\n    \n    total_p = sum(p)\n    remaining = current_load - total_p\n    \n    # Distribute remaining load\n    if remaining > 0:\n        incr_costs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high = min(unit['p_max_i'], unit['p_start_i'])\n            incr_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            incr_costs.append((i, incr_cost, high - p[i]))\n        \n        incr_costs.sort(key=lambda x: x[1])\n        for i, _, capacity in incr_costs:\n            if remaining <= 0:\n                break\n            alloc = min(remaining, capacity)\n            p[i] += alloc\n            remaining -= alloc\n    \n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0239962972,
          "gap_price_rate": 0.0161415843,
          "fitness": 0.0200689407
     }
]