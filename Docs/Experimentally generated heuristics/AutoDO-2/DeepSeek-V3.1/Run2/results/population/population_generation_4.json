[
     {
          "name": "enhanced_commit_units_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n\n",
          "code": "import numpy as np\nimport copy\n\ndef enhanced_commit_units_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    units = copy.deepcopy(units_info)\n    n_units = len(units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        # Check must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(unit)\n            unit['u_i'] = 1\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        # Check must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              abs(unit['t_i_0']) < unit['t_off_min_i']):\n            must_off.append(unit)\n            unit['u_i'] = 0\n            unit['min_p'] = 0\n            unit['max_p'] = 0\n        else:\n            flexible.append(unit)\n    \n    # Compute effective costs and feasible ranges for flexible units\n    for unit in flexible:\n        if unit['u_i_0'] == 1:\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2) / unit['min_p']\n        else:\n            unit['min_p'] = unit['p_min_i']\n            unit['max_p'] = min(unit['p_max_i'], unit['p_start_i'])\n            unit['effective_cost'] = (unit['a_i'] + unit['b_i'] * unit['min_p'] + \n                                     unit['c_i'] * unit['min_p'] ** 2 + unit['s_i']) / unit['min_p']\n    \n    # Commit units\n    committed = must_run.copy()\n    total_min = sum(unit['min_p'] for unit in committed)\n    total_max = sum(unit['max_p'] for unit in committed)\n    \n    # Sort flexible units by effective cost\n    flexible_sorted = sorted(flexible, key=lambda x: x['effective_cost'])\n    \n    # Commit flexible units until load is met\n    for unit in flexible_sorted:\n        if total_max >= current_load:\n            break\n        if unit['u_i_0'] == 0 and forecast_load > total_max:\n            unit['u_i'] = 1\n            committed.append(unit)\n            total_min += unit['min_p']\n            total_max += unit['max_p']\n    \n    # Economic dispatch\n    for unit in committed:\n        unit['p_i'] = unit['min_p']\n    \n    remaining_load = current_load - total_min\n    units_available = [u for u in committed if u['p_i'] < u['max_p']]\n    \n    while remaining_load > 0 and units_available:\n        # Find unit with lowest marginal cost\n        best_unit = min(units_available, \n                       key=lambda u: u['b_i'] + 2 * u['c_i'] * u['p_i'])\n        # Calculate available capacity\n        available = min(best_unit['max_p'] - best_unit['p_i'], remaining_load)\n        best_unit['p_i'] += available\n        remaining_load -= available\n        if best_unit['p_i'] >= best_unit['max_p']:\n            units_available.remove(best_unit)\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for idx, unit in enumerate(units):\n        schedules[0, idx] = unit.get('u_i', 0)\n        schedules[1, idx] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.003641132,
          "gap_price_rate": 0.0047652342,
          "fitness": 0.0042031831
     },
     {
          "name": "novel_rolling_uc_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints.\n3. Sort flexible units by average cost per MW at minimum output (including startup costs if applicable).\n4. Commit flexible units in cost order until total available capacity meets or exceeds current load.\n5. Dispatch load by setting committed units to their minimum output, then allocating remaining load based on marginal cost order.\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_min = np.zeros(n_units)\n    current_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n            current_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            current_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n            current_min[i] = p_min_i\n            current_max[i] = min(p_max_i, p_start_i)\n        \n        if must_off[i]:\n            current_min[i] = 0\n            current_max[i] = 0\n\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_per_mw = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        else:\n            total_cost = unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        cost_per_mw.append(total_cost / current_min[i] if current_min[i] > 0 else float('inf'))\n    \n    sorted_flexible = [i for _, i in sorted(zip(cost_per_mw, flexible_units))]\n    committed = must_run.copy()\n    total_max = np.sum(current_max[must_run])\n    \n    for i in sorted_flexible:\n        if total_max >= load[0]:\n            break\n        committed[i] = True\n        total_max += current_max[i]\n    \n    p_output = np.zeros(n_units)\n    for i in range(n_units):\n        if committed[i]:\n            p_output[i] = current_min[i]\n        else:\n            p_output[i] = 0\n            \n    remaining = load[0] - np.sum(p_output)\n    committed_indices = [i for i in range(n_units) if committed[i] and p_output[i] < current_max[i]]\n    \n    step = 1.0\n    while remaining > 0 and committed_indices:\n        marginal_costs = []\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_output[i])\n        idx_min = np.argmin(marginal_costs)\n        unit_idx = committed_indices[idx_min]\n        increase = min(step, current_max[unit_idx] - p_output[unit_idx], remaining)\n        p_output[unit_idx] += increase\n        remaining -= increase\n        if p_output[unit_idx] >= current_max[unit_idx]:\n            committed_indices.pop(idx_min)\n            \n    u_output = committed.astype(int)\n    schedules = np.array([u_output, p_output])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054284293,
          "gap_price_rate": 0.0087959181,
          "fitness": 0.0071121737
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets load\n5. Perform economic dispatch by setting committed units to minimum output, then allocating remaining load based on marginal cost\n6. Adjust outputs to respect all constraints including ramp rates and min/max limits\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = [0] * n_units\n    feasible_max = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < t_on_min or p0 > p_shut):\n            must_run.append(i)\n            min_p = max(p_min, p0 - p_down)\n            max_p = min(p_max, p0 + p_up)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n        elif u0 == 0 and abs(t0) < t_off_min:\n            must_off.append(i)\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n        else:\n            flexible.append(i)\n            if u0 == 1:\n                min_p = max(p_min, p0 - p_down)\n                max_p = min(p_max, p0 + p_up)\n            else:\n                min_p = p_min\n                max_p = min(p_max, p_start)\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n\n    committed = set()\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        committed.add(i)\n        schedules[0, i] = 1\n        schedules[1, i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost = (unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        else:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        effective_costs.append((cost, i))\n    \n    effective_costs.sort(key=lambda x: x[0])\n    \n    for cost, i in effective_costs:\n        if total_max >= current_load:\n            break\n        if i not in committed and i not in must_off:\n            committed.add(i)\n            schedules[0, i] = 1\n            schedules[1, i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n    \n    current_total = total_min\n    remaining_load = current_load - current_total\n    \n    adjustable_units = [i for i in committed if feasible_max[i] > feasible_min[i]]\n    \n    if remaining_load > 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for mc, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            available = feasible_max[i] - schedules[1, i]\n            to_add = min(remaining_load, available)\n            schedules[1, i] += to_add\n            remaining_load -= to_add\n            \n    elif remaining_load < 0:\n        marginal_costs = []\n        for i in adjustable_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for mc, i in marginal_costs:\n            if remaining_load >= 0:\n                break\n            available = schedules[1, i] - feasible_min[i]\n            to_reduce = min(-remaining_load, available)\n            schedules[1, i] -= to_reduce\n            remaining_load += to_reduce\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "novel_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Compute feasible power ranges considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost (including startup if applicable) for flexible units at min output\n4. Commit must-run units first, then flexible units by effective cost until load is met\n5. Adjust commitment using forecasted load to minimize future startup costs\n6. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n7. Ensure all constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    flexible = [False] * n_units\n    p_min_feasible = [0.0] * n_units\n    p_max_feasible = [0.0] * n_units\n    effective_cost = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off[i] = True\n        else:\n            flexible[i] = True\n            \n        # Step 2: Compute feasible power ranges\n        if must_run[i] or (flexible[i] and u_i0 == 1):\n            p_min_feasible[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        elif flexible[i] and u_i0 == 0:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min_feasible[i], p_max_feasible[i] = 0, 0\n            \n        # Step 3: Calculate effective cost\n        if flexible[i]:\n            if u_i0 == 0:\n                cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min_feasible[i] + \n                        unit['c_i'] * p_min_feasible[i] ** 2)\n            else:\n                cost = (unit['a_i'] + unit['b_i'] * p_min_feasible[i] + \n                        unit['c_i'] * p_min_feasible[i] ** 2)\n            effective_cost[i] = cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n    \n    # Step 4: Initial commitment\n    committed = must_run[:]\n    total_capacity = sum(p_max_feasible[i] for i in range(n_units) if committed[i])\n    \n    # Commit flexible units by cost\n    flexible_indices = [i for i in range(n_units) if flexible[i]]\n    flexible_indices.sort(key=lambda i: effective_cost[i])\n    \n    for i in flexible_indices:\n        if total_capacity < current_load and not must_off[i]:\n            committed[i] = True\n            total_capacity += p_max_feasible[i]\n    \n    # Step 5: Adjust for forecasted load\n    forecast_capacity = total_capacity + sum(\n        min(unit['p_up_i'], unit['p_max_i'] - p_max_feasible[i]) \n        for i, unit in enumerate(units_info) if committed[i]\n    )\n    \n    if forecast_capacity < forecast_load:\n        for i in flexible_indices:\n            if not committed[i] and not must_off[i]:\n                committed[i] = True\n                break\n    \n    # Step 6: Economic dispatch\n    # Set initial outputs to min feasible\n    p_outputs = [p_min_feasible[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = current_load - sum(p_outputs)\n    \n    # Create priority list for dispatch\n    dispatch_order = [i for i in range(n_units) if committed[i]]\n    dispatch_order.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i])\n    \n    # Allocate remaining load\n    for i in dispatch_order:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, p_max_feasible[i] - p_outputs[i])\n        p_outputs[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Step 7: Constraint satisfaction check\n    for i in range(n_units):\n        if committed[i]:\n            # Ensure within feasible range\n            p_outputs[i] = max(p_min_feasible[i], min(p_max_feasible[i], p_outputs[i]))\n            # Ensure ramp constraints\n            if units_info[i]['u_i_0'] == 1:\n                p_outputs[i] = min(p_outputs[i], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                p_outputs[i] = max(p_outputs[i], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n    \n    # Prepare output\n    schedules[0, :] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1, :] = p_outputs\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0059278578,
          "gap_price_rate": 0.0112066471,
          "fitness": 0.0085672524
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v5",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Use forecast-aware adjustment: if forecast exceeds current capacity, pre-commit additional flexible units; if forecast is lower, consider deactivating flexible units\n6. Perform economic dispatch using iterative water-filling with ramp-aware allocation and marginal cost sorting\n7. Validate and refine schedule through constraint satisfaction checks and cost optimization\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v5(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    effective_cost = np.full(n_units, np.inf)\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 2: Compute feasible power ranges\n    for i, unit in enumerate(units_info):\n        if i in must_off:\n            feasible_min[i] = 0\n            feasible_max[i] = 0\n        else:\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            feasible_min[i] = min_p\n            feasible_max[i] = max_p\n    \n    # Step 3: Calculate effective cost for flexible units\n    for i in flexible:\n        unit = units_info[i]\n        min_p = feasible_min[i]\n        if min_p > 0:\n            if unit['u_i_0'] == 0:\n                cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2 + unit['s_i']\n            else:\n                cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            effective_cost[i] = cost / min_p\n    \n    # Step 4: Commit units\n    committed = set(must_run)\n    total_capacity = sum(feasible_max[i] for i in committed)\n    \n    # Commit flexible units by effective cost\n    sorted_flexible = sorted([i for i in flexible if effective_cost[i] < np.inf], \n                            key=lambda x: effective_cost[x])\n    \n    for i in sorted_flexible:\n        if total_capacity >= current_load:\n            break\n        committed.add(i)\n        total_capacity += feasible_max[i]\n    \n    # Step 5: Forecast-aware adjustment\n    if forecast_load > total_capacity:\n        for i in sorted_flexible:\n            if i not in committed:\n                committed.add(i)\n                total_capacity += feasible_max[i]\n                break\n    elif forecast_load < total_capacity * 0.8:\n        flexible_committed = [i for i in committed if i in flexible]\n        if flexible_committed:\n            sorted_by_cost = sorted(flexible_committed, key=lambda x: effective_cost[x], reverse=True)\n            for i in sorted_by_cost:\n                if total_capacity - feasible_max[i] >= current_load:\n                    committed.remove(i)\n                    total_capacity -= feasible_max[i]\n                    break\n    \n    # Ensure min output constraint\n    total_min = sum(feasible_min[i] for i in committed)\n    if total_min > current_load:\n        flexible_committed = [i for i in committed if i in flexible]\n        sorted_by_cost = sorted(flexible_committed, key=lambda x: effective_cost[x], reverse=True)\n        for i in sorted_by_cost:\n            if total_min - feasible_min[i] <= current_load:\n                committed.remove(i)\n                total_min -= feasible_min[i]\n                break\n    \n    # Step 6: Economic dispatch\n    for i in committed:\n        p[i] = feasible_min[i]\n    \n    remaining_load = current_load - sum(p)\n    marginal_costs = []\n    for i in committed:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n        marginal_costs.append((i, marginal_cost))\n    \n    while remaining_load > 0:\n        marginal_costs.sort(key=lambda x: x[1])\n        updated = False\n        for i, mc in marginal_costs:\n            if p[i] < feasible_max[i]:\n                increase = min(remaining_load, feasible_max[i] - p[i])\n                p[i] += increase\n                remaining_load -= increase\n                updated = True\n                # Update marginal cost\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                marginal_costs = [(idx, cost if idx != i else new_mc) for idx, cost in marginal_costs]\n                break\n        if not updated:\n            break\n    \n    # Step 7: Validate and adjust constraints\n    for i in committed:\n        unit = units_info[i]\n        # Ensure ramp constraints\n        if unit['u_i_0'] == 1:\n            p[i] = min(p[i], unit['p_i_0'] + unit['p_up_i'])\n            p[i] = max(p[i], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = min(p[i], unit['p_start_i'])\n        # Ensure min/max limits\n        p[i] = max(unit['p_min_i'], min(unit['p_max_i'], p[i]))\n    \n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0058932085,
          "gap_price_rate": 0.0119148627,
          "fitness": 0.0089040356
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v3",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load to minimize unnecessary state changes\n6. Perform economic dispatch using iterative marginal cost sorting with ramp-aware allocation\n7. Validate and adjust outputs to ensure all physical constraints are satisfied\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v3(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Determine must-run/must-off status\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            min_p[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            if -t0 < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if i in must_off:\n            min_p[i] = 0\n            max_p[i] = 0\n\n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_p[i] + \n                   unit['c_i']*min_p[i]**2) / min_p[i]\n        else:\n            cost = (unit['a_i'] + unit['b_i']*min_p[i] + \n                   unit['c_i']*min_p[i]**2) / min_p[i]\n        costs.append((cost, i))\n    \n    costs.sort(key=lambda x: x[0])\n    flexible_sorted = [i for _, i in costs]\n\n    # Initial commitment\n    committed = set(must_run)\n    total_min = sum(min_p[i] for i in committed)\n    total_max = sum(max_p[i] for i in committed)\n    \n    # Commit flexible units\n    for i in flexible_sorted:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            break\n\n    # Adjust commitment based on forecast\n    if forecast_load > total_max * 0.9:\n        for i in flexible_sorted:\n            if i not in committed and total_max + max_p[i] >= forecast_load:\n                committed.add(i)\n                break\n    elif forecast_load < total_min * 1.1:\n        for i in reversed(flexible_sorted):\n            if i in committed and total_min - min_p[i] <= forecast_load:\n                committed.remove(i)\n                break\n\n    # Economic dispatch\n    for i in committed:\n        p[i] = min_p[i]\n    \n    remaining = current_load - sum(p)\n    committed_list = list(committed)\n    \n    # Allocate remaining load\n    while abs(remaining) > 1e-5:\n        if remaining > 0:\n            # Find unit with lowest marginal cost\n            marginal_costs = []\n            for i in committed_list:\n                if p[i] < max_p[i]:\n                    mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort()\n            i = marginal_costs[0][1]\n            add = min(remaining, max_p[i] - p[i])\n            p[i] += add\n            remaining -= add\n        else:\n            # Find unit with highest marginal cost\n            marginal_costs = []\n            for i in committed_list:\n                if p[i] > min_p[i]:\n                    mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(reverse=True)\n            i = marginal_costs[0][1]\n            reduce = min(-remaining, p[i] - min_p[i])\n            p[i] -= reduce\n            remaining += reduce\n\n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n\n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0059642692,
          "gap_price_rate": 0.0129901629,
          "fitness": 0.009477216
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v5",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced constraints including min up/down times, shutdown ramp limits, and forecast-aware conditions\n2. Calculate dynamic feasible power ranges incorporating startup/shutdown ramp limits, current state, and forecasted load requirements\n3. Compute adaptive cost metric combining marginal cost, flexibility penalty, and forecast-adjusted startup costs\n4. Commit must-run units first, then flexible units using dual-stage cost ordering with forecast-aware adjustment\n5. Perform constrained economic dispatch using predictive water-filling with ramp-aware allocation and marginal cost balancing\n6. Validate and refine schedule through iterative constraint satisfaction checks and forecast-informed adjustments\n7. Implement look-ahead strategy using forecasted load to optimize unit commitments and minimize future costs\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v5(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    t_0 = np.array([u['t_i_0'] for u in units_info])\n    \n    # Initialize output arrays\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    \n    # Classify units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            if t_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if t_0[i] > -t_off_min[i]:\n                must_off[i] = True\n                \n    flexible = ~(must_run | must_off)\n    \n    # Calculate feasible ranges\n    p_min_feasible = np.copy(p_min)\n    p_max_feasible = np.copy(p_max)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            p_min_feasible[i] = max(p_min[i], p_i_0[i] - p_down[i])\n            p_max_feasible[i] = min(p_max[i], p_i_0[i] + p_up[i])\n        else:\n            p_max_feasible[i] = min(p_max[i], p_start[i])\n    \n    # Calculate cost metrics\n    cost_metric = np.full(n_units, np.inf)\n    for i in range(n_units):\n        if flexible[i]:\n            if u_i_0[i] == 0:\n                cost_metric[i] = (s[i] + a[i] + b[i] * p_min_feasible[i] + \n                                 c[i] * p_min_feasible[i]**2) / p_min_feasible[i]\n            else:\n                cost_metric[i] = (a[i] + b[i] * p_min_feasible[i] + \n                                 c[i] * p_min_feasible[i]**2) / p_min_feasible[i]\n    \n    # Commit must-run units\n    u_i[must_run] = 1\n    p_i[must_run] = p_min_feasible[must_run]\n    \n    # Commit flexible units by cost order\n    flex_indices = np.where(flexible)[0]\n    sorted_flex = flex_indices[np.argsort(cost_metric[flex_indices])]\n    \n    total_capacity = np.sum(p_max_feasible[u_i == 1])\n    for i in sorted_flex:\n        if total_capacity < current_load:\n            u_i[i] = 1\n            p_i[i] = p_min_feasible[i]\n            total_capacity += p_max_feasible[i]\n    \n    # Forecast-aware adjustment\n    current_capacity = np.sum(p_max_feasible[u_i == 1])\n    if forecast_load > current_capacity:\n        for i in sorted_flex:\n            if u_i[i] == 0:\n                u_i[i] = 1\n                p_i[i] = p_min_feasible[i]\n                current_capacity += p_max_feasible[i]\n                if current_capacity >= forecast_load:\n                    break\n    else:\n        committed_flex = [i for i in sorted_flex if u_i[i] == 1 and not must_run[i]]\n        committed_flex_sorted = committed_flex[::-1]  # Most expensive first\n        for i in committed_flex_sorted:\n            if current_capacity - p_max_feasible[i] >= current_load:\n                u_i[i] = 0\n                p_i[i] = 0\n                current_capacity -= p_max_feasible[i]\n    \n    # Economic dispatch\n    committed = np.where(u_i == 1)[0]\n    total_min = np.sum(p_min_feasible[committed])\n    remaining_load = current_load - total_min\n    \n    if remaining_load > 0:\n        # Allocate based on marginal cost\n        while remaining_load > 1e-6:\n            min_mc = np.inf\n            candidate = -1\n            for i in committed:\n                if p_i[i] < p_max_feasible[i]:\n                    mc = b[i] + 2 * c[i] * p_i[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            \n            if candidate == -1:\n                break\n                \n            alloc = min(remaining_load, p_max_feasible[candidate] - p_i[candidate])\n            p_i[candidate] += alloc\n            remaining_load -= alloc\n    \n    # Ensure must-off units are off\n    u_i[must_off] = 0\n    p_i[must_off] = 0\n    \n    return np.vstack((u_i, p_i))",
          "from": "crossover",
          "gap_power_rate": 0.0016299555,
          "gap_price_rate": 0.0177437711,
          "fitness": 0.0096868633
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units (including startup costs for offline units)\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load: if forecast exceeds current capacity, commit additional flexible units; if forecast is lower, consider deactivating flexible units\n6. Perform economic dispatch using marginal cost sorting with ramp-aware allocation\n7. Ensure all physical constraints are satisfied through iterative refinement\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v2(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        # Determine must-run and must-off status\n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(p_max_i, p_start_i, p_up_i)\n    \n    # Calculate effective costs for flexible units\n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        s_i, u_i_0 = unit['s_i'], unit['u_i_0']\n        p_min_i = feasible_min[i]\n        \n        if u_i_0 == 0:\n            cost = (s_i + a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i\n        else:\n            cost = (a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i\n        effective_costs.append((i, cost))\n    \n    # Sort flexible units by effective cost\n    effective_costs.sort(key=lambda x: x[1])\n    sorted_flexible = [x[0] for x in effective_costs]\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_min = sum(feasible_min[i] for i in committed)\n    total_max = sum(feasible_max[i] for i in committed)\n    \n    # Commit flexible units until load is met\n    for i in sorted_flexible:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Adjust commitment based on forecast\n    if forecast_load > total_max:\n        for i in sorted_flexible:\n            if i not in committed and forecast_load > total_max:\n                committed.add(i)\n                total_min += feasible_min[i]\n                total_max += feasible_max[i]\n            else:\n                break\n    elif forecast_load < total_min:\n        for i in reversed(sorted_flexible):\n            if i in committed and forecast_load < total_min - feasible_min[i]:\n                committed.remove(i)\n                total_min -= feasible_min[i]\n                total_max -= feasible_max[i]\n            else:\n                break\n    \n    # Initialize outputs\n    for i in committed:\n        u[i] = 1\n        p[i] = feasible_min[i]\n    \n    # Economic dispatch\n    remaining = current_load - sum(p)\n    marginal_costs = []\n    for i in committed:\n        unit = units_info[i]\n        b_i, c_i = unit['b_i'], unit['c_i']\n        marginal_cost = b_i + 2 * c_i * p[i]\n        marginal_costs.append((i, marginal_cost))\n    \n    while remaining > 0:\n        marginal_costs.sort(key=lambda x: x[1])\n        updated = False\n        for i, mc in marginal_costs:\n            if p[i] < feasible_max[i]:\n                delta = min(remaining, feasible_max[i] - p[i])\n                p[i] += delta\n                remaining -= delta\n                unit = units_info[i]\n                b_i, c_i = unit['b_i'], unit['c_i']\n                new_mc = b_i + 2 * c_i * p[i]\n                # Update marginal cost\n                idx = next((idx for idx, (idx_i, _) in enumerate(marginal_costs) if idx_i == i), None)\n                if idx is not None:\n                    marginal_costs[idx] = (i, new_mc)\n                updated = True\n                if remaining <= 0:\n                    break\n        if not updated:\n            break\n    \n    # Ensure must-off units are off\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.003515163,
          "gap_price_rate": 0.0161216978,
          "fitness": 0.0098184304
     },
     {
          "name": "refined_rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on min up/down times and shutdown ramp constraints\n2. Compute current feasible power ranges incorporating ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Use forecast-aware adjustment with look-ahead strategy: if forecast exceeds current capacity, pre-commit additional flexible units; if forecast is lower, consider deactivating high-cost flexible units\n6. Perform economic dispatch using iterative water-filling with ramp-aware allocation and marginal cost sorting\n7. Validate and refine schedule through constraint satisfaction checks with priority on must-run units\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_uc_heuristic(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    \n    # Initialize schedules\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Determine feasible power range\n        if unit['u_i_0'] == 1:  # Previously on\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check must-run conditions\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously off\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            # Check must-off conditions\n            if (unit['t_i_0'] > -unit['t_off_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        feasible_min[i] = min_p\n        feasible_max[i] = max_p\n    \n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:  # Offline unit needs startup cost\n            cost_per_mw = (unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2 + unit['s_i']) / feasible_min[i]\n        else:\n            cost_per_mw = (unit['b_i'] * feasible_min[i] + unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n        costs.append((i, cost_per_mw))\n    \n    # Sort flexible units by cost\n    costs.sort(key=lambda x: x[1])\n    flexible_sorted = [x[0] for x in costs]\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_capacity = sum(feasible_max[i] for i in committed)\n    \n    # Commit flexible units until load met\n    for i in flexible_sorted:\n        if total_capacity < current_load:\n            committed.add(i)\n            total_capacity += feasible_max[i]\n    \n    # Forecast-aware adjustment\n    if forecast_load > total_capacity:\n        # Pre-commit additional units for forecast\n        for i in flexible_sorted:\n            if i not in committed and total_capacity < forecast_load:\n                committed.add(i)\n                total_capacity += feasible_max[i]\n    else:\n        # Consider deactivating high-cost units\n        for i in reversed(flexible_sorted):\n            if (i in committed and i not in must_run and\n                total_capacity - feasible_max[i] >= current_load):\n                committed.remove(i)\n                total_capacity -= feasible_max[i]\n    \n    # Economic dispatch\n    # Set initial output to minimum\n    for i in committed:\n        p[i] = feasible_min[i]\n    remaining_load = current_load - sum(p)\n    \n    # Allocate remaining load based on marginal cost\n    while remaining_load > 1e-6:\n        best_unit = None\n        best_marginal_cost = float('inf')\n        \n        for i in committed:\n            if p[i] < feasible_max[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                if marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        # Calculate available capacity\n        available = feasible_max[best_unit] - p[best_unit]\n        allocate = min(remaining_load, available)\n        p[best_unit] += allocate\n        remaining_load -= allocate\n    \n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0017851481,
          "gap_price_rate": 0.0181652427,
          "fitness": 0.0099751954
     },
     {
          "name": "enhanced_rolling_uc_heuristic_v5",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Calculate effective cost per MW for flexible units including startup costs where applicable, with improved amortization over minimum up-time\n4. Commit must-run units first, then flexible units in effective cost order until capacity meets current load\n5. Adjust commitment using forecasted load with look-ahead strategy: pre-commit additional units if forecast exceeds capacity, consider decommitment if forecast is significantly lower\n6. Perform economic dispatch using iterative water-filling with ramp-aware allocation and marginal cost balancing\n7. Validate and refine schedule through constraint satisfaction checks with focus on shutdown ramp constraints\n8. Implement adaptive cost adjustment based on unit flexibility and forecast uncertainty\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic_v5(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Extract unit parameters\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    min_up = np.array([u['t_on_min_i'] for u in units_info])\n    min_down = np.array([u['t_off_min_i'] for u in units_info])\n    startup_cost = np.array([u['s_i'] for u in units_info])\n    u_prev = np.array([u['u_i_0'] for u in units_info])\n    t_prev = np.array([u['t_i_0'] for u in units_info])\n    p_prev = np.array([u['p_i_0'] for u in units_info])\n    \n    # Initialize outputs\n    u_current = np.zeros(n_units)\n    p_current = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -t_prev[i] < min_down[i]:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 2: Compute feasible power ranges\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            min_feasible[i] = max(p_min[i], p_prev[i] - p_down[i])\n            max_feasible[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            min_feasible[i] = p_min[i]\n            max_feasible[i] = min(p_max[i], p_start[i])\n    \n    # Step 3: Calculate effective costs\n    effective_cost = np.full(n_units, np.inf)\n    \n    for i in flexible:\n        if u_prev[i] == 1:\n            base_cost = a[i] + b[i] * min_feasible[i] + c[i] * min_feasible[i]**2\n            effective_cost[i] = base_cost / min_feasible[i]\n        else:\n            amortization = max(1, min_up[i])\n            total_cost = a[i] + b[i] * min_feasible[i] + c[i] * min_feasible[i]**2 + startup_cost[i] / amortization\n            effective_cost[i] = total_cost / min_feasible[i]\n    \n    # Step 4: Commit units\n    committed = set(must_run)\n    total_capacity = sum(max_feasible[i] for i in committed)\n    \n    # Commit flexible units by cost\n    sorted_flexible = sorted(flexible, key=lambda i: effective_cost[i])\n    for i in sorted_flexible:\n        if total_capacity < current_load:\n            committed.add(i)\n            total_capacity += max_feasible[i]\n    \n    # Adjust based on forecast\n    if forecast_load > total_capacity:\n        for i in sorted_flexible:\n            if i not in committed and i not in must_off:\n                committed.add(i)\n                total_capacity += max_feasible[i]\n                if total_capacity >= forecast_load:\n                    break\n    \n    # Step 5: Economic dispatch\n    # Initialize at minimum feasible\n    for i in committed:\n        p_current[i] = min_feasible[i]\n        u_current[i] = 1\n    \n    total_power = sum(p_current)\n    remaining_load = current_load - total_power\n    \n    # Water-filling allocation\n    while remaining_load > 1e-5:\n        best_unit = None\n        best_marginal = float('inf')\n        \n        for i in committed:\n            if p_current[i] < max_feasible[i]:\n                marginal = b[i] + 2 * c[i] * p_current[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n        \n        max_increase = min(max_feasible[best_unit] - p_current[best_unit], \n                          p_up[best_unit] if u_prev[best_unit] == 1 else p_start[best_unit],\n                          remaining_load)\n        p_current[best_unit] += max_increase\n        remaining_load -= max_increase\n    \n    # Step 6: Constraint validation and refinement\n    # Ensure shutdown ramp constraints\n    for i in range(n_units):\n        if u_prev[i] == 1 and u_current[i] == 0 and p_prev[i] > p_shut[i]:\n            u_current[i] = 1\n            p_current[i] = max(p_min[i], p_prev[i] - p_down[i])\n    \n    # Ensure minimum generation\n    for i in committed:\n        if u_current[i] == 1 and p_current[i] < p_min[i]:\n            p_current[i] = p_min[i]\n    \n    # Format output\n    schedules = np.vstack([u_current, p_current])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0017709216,
          "gap_price_rate": 0.0184232544,
          "fitness": 0.010097088
     }
]