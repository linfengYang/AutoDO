[
     {
          "name": "novel_rolling_uc_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Compute feasible power ranges for each unit considering ramp limits and startup/shutdown constraints.\n3. Sort flexible units by average cost per MW at minimum output (including startup costs if applicable).\n4. Commit flexible units in cost order until total available capacity meets or exceeds current load.\n5. Dispatch load by setting committed units to their minimum output, then allocating remaining load based on marginal cost order.\n",
          "code": "import numpy as np\n\ndef novel_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_min = np.zeros(n_units)\n    current_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n            current_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            current_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off[i] = True\n            current_min[i] = p_min_i\n            current_max[i] = min(p_max_i, p_start_i)\n        \n        if must_off[i]:\n            current_min[i] = 0\n            current_max[i] = 0\n\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_per_mw = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        else:\n            total_cost = unit['a_i'] + unit['b_i']*current_min[i] + unit['c_i']*current_min[i]**2\n        cost_per_mw.append(total_cost / current_min[i] if current_min[i] > 0 else float('inf'))\n    \n    sorted_flexible = [i for _, i in sorted(zip(cost_per_mw, flexible_units))]\n    committed = must_run.copy()\n    total_max = np.sum(current_max[must_run])\n    \n    for i in sorted_flexible:\n        if total_max >= load[0]:\n            break\n        committed[i] = True\n        total_max += current_max[i]\n    \n    p_output = np.zeros(n_units)\n    for i in range(n_units):\n        if committed[i]:\n            p_output[i] = current_min[i]\n        else:\n            p_output[i] = 0\n            \n    remaining = load[0] - np.sum(p_output)\n    committed_indices = [i for i in range(n_units) if committed[i] and p_output[i] < current_max[i]]\n    \n    step = 1.0\n    while remaining > 0 and committed_indices:\n        marginal_costs = []\n        for i in committed_indices:\n            unit = units_info[i]\n            marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_output[i])\n        idx_min = np.argmin(marginal_costs)\n        unit_idx = committed_indices[idx_min]\n        increase = min(step, current_max[unit_idx] - p_output[unit_idx], remaining)\n        p_output[unit_idx] += increase\n        remaining -= increase\n        if p_output[unit_idx] >= current_max[unit_idx]:\n            committed_indices.pop(idx_min)\n            \n    u_output = committed.astype(int)\n    schedules = np.array([u_output, p_output])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054284293,
          "gap_price_rate": 0.0087959181,
          "fitness": 0.0071121737
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into forced-on, forced-off, and free based on minimum up/down times and shutdown ramp constraints\n2. Calculate total available capacity from committed units considering ramp limits\n3. If load exceeds capacity, activate free units by ascending marginal cost at minimum output\n4. If load is below minimum generation, deactivate free units by descending marginal cost\n5. Perform economic dispatch using water-filling algorithm to allocate load optimally\n6. Ensure output respects unit constraints including ramp rates and min/max limits\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    forced_on = np.zeros(n_units, dtype=bool)\n    forced_off = np.zeros(n_units, dtype=bool)\n    \n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n            else:\n                forced_off[i] = False\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n            else:\n                forced_on[i] = False\n    \n    for i in range(n_units):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_outputs[i] = unit['p_min_i']\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    total_min = np.sum(min_outputs[u == 1])\n    total_max = np.sum(max_outputs[u == 1])\n    \n    free_indices = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if current_load > total_max:\n        off_free = [i for i in free_indices if u[i] == 0]\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'] for i in off_free]\n        sorted_off = [x for _, x in sorted(zip(marginal_costs, off_free))]\n        \n        for i in sorted_off:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            min_outputs[i] = units_info[i]['p_min_i']\n            max_outputs[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    elif current_load < total_min:\n        on_free = [i for i in free_indices if u[i] == 1]\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_outputs[i] for i in on_free]\n        sorted_on = [x for _, x in sorted(zip(marginal_costs, on_free), reverse=True)]\n        \n        for i in sorted_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    committed = np.where(u == 1)[0]\n    if len(committed) == 0:\n        return np.array([u, p])\n    \n    min_vals = min_outputs[committed]\n    max_vals = max_outputs[committed]\n    b_vals = [units_info[i]['b_i'] for i in committed]\n    c_vals = [units_info[i]['c_i'] for i in committed]\n    \n    allocations = min_vals.copy()\n    remaining = current_load - np.sum(allocations)\n    \n    while remaining > 1e-6:\n        marginal_costs = [b + 2 * c * alloc for b, c, alloc in zip(b_vals, c_vals, allocations)]\n        min_marginal = float('inf')\n        best_index = -1\n        for i, (mc, alloc) in enumerate(zip(marginal_costs, allocations)):\n            if alloc < max_vals[i] and mc < min_marginal:\n                min_marginal = mc\n                best_index = i\n        \n        if best_index == -1:\n            break\n            \n        max_add = max_vals[best_index] - allocations[best_index]\n        add = min(remaining, max_add)\n        allocations[best_index] += add\n        remaining -= add\n    \n    for i, idx in enumerate(committed):\n        p[idx] = allocations[i]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0375214362,
          "fitness": 0.0187965642
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, available, and unavailable based on current state and constraints\n2. Calculate feasible power ranges considering ramp limits and min up/down times\n3. Prioritize units using effective cost per MW (including startup costs)\n4. Commit units until load is met, considering must-run units first\n5. Dispatch load economically among committed units using marginal cost sorting\n6. Adjust commitment based on forecasted load to minimize future costs\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    min_out = np.zeros(n_units)\n    max_out = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    available = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_up = unit['p_up_i']\n        ramp_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run[i] = True\n            min_out[i] = max(p_min, p0 - ramp_down)\n            max_out[i] = min(p_max, p0 + ramp_up)\n            available[i] = True\n        else:\n            if abs(t0) >= min_down:\n                min_out[i] = p_min\n                max_out[i] = min(p_max, p_start)\n                available[i] = True\n            else:\n                min_out[i] = 0\n                max_out[i] = 0\n    \n    committed = np.where(must_run)[0].tolist()\n    total_min = sum(min_out[committed])\n    total_max = sum(max_out[committed])\n    \n    if total_min > current_load:\n        for i in committed:\n            p[i] = min_out[i]\n            u[i] = 1\n        remaining = current_load - total_min\n        idx = np.argsort([units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i] for i in committed])\n        for i in idx:\n            reducible = p[committed[i]] - min_out[committed[i]]\n            if reducible >= -remaining:\n                p[committed[i]] += remaining\n                break\n            else:\n                remaining += reducible\n                p[committed[i]] = min_out[committed[i]]\n        return np.array([u, p])\n    \n    candidate_units = [i for i in range(n_units) if available[i] and not must_run[i]]\n    cost_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['b_i']*min_out[i] + unit['c_i']*min_out[i]**2) / min_out[i]\n        else:\n            cost = unit['b_i'] + 2*unit['c_i']*min_out[i]\n        cost_list.append((cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    for cost, i in cost_list:\n        if total_max >= current_load:\n            break\n        committed.append(i)\n        total_max += max_out[i]\n    \n    for i in committed:\n        p[i] = min_out[i]\n        u[i] = 1\n    \n    remaining_load = current_load - sum(p)\n    while remaining_load > 1e-6:\n        marginal_costs = []\n        for i in committed:\n            if p[i] < max_out[i]:\n                mc = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                marginal_costs.append((mc, i))\n        if not marginal_costs:\n            break\n        marginal_costs.sort(key=lambda x: x[0])\n        best_unit = marginal_costs[0][1]\n        add_cap = min(remaining_load, max_out[best_unit] - p[best_unit])\n        p[best_unit] += add_cap\n        remaining_load -= add_cap\n    \n    if forecast_load > current_load and total_max < forecast_load:\n        for cost, i in cost_list:\n            if i not in committed:\n                committed.append(i)\n                u[i] = 1\n                p[i] = min_out[i]\n                total_max += max_out[i]\n                if total_max >= forecast_load:\n                    break\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0120057296,
          "gap_price_rate": 0.025759297,
          "fitness": 0.0188825133
     },
     {
          "name": "commit_units_rolling_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on current state and constraints\n2. Form preliminary commitment from must-run and currently online flexible units\n3. Adjust commitment based on load demand:\n   - If insufficient capacity, activate flexible offline units by cost priority\n   - If excess capacity, deactivate flexible online units by cost priority\n4. Perform economic dispatch using incremental cost sorting\n5. Adjust outputs to respect ramp limits and min/max constraints\n6. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute average cost at max output\n    avg_costs = []\n    for unit in units_info:\n        max_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i'] ** 2\n        avg_costs.append(max_cost / unit['p_max_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Preliminary commitment\n    committed = set(must_run)\n    for i in flexible:\n        if units_info[i]['u_i_0'] == 1:\n            committed.add(i)\n    \n    # Check capacity and adjust commitment\n    total_min = sum(units_info[i]['p_min_i'] for i in committed)\n    total_max = sum(units_info[i]['p_max_i'] for i in committed)\n    current_load = load[0]\n    \n    # Add units if needed\n    if total_max < current_load:\n        offline_flexible = [i for i in flexible if units_info[i]['u_i_0'] == 0 and i not in must_off]\n        offline_flexible.sort(key=lambda i: avg_costs[i])\n        for i in offline_flexible:\n            committed.add(i)\n            total_max += units_info[i]['p_max_i']\n            if total_max >= current_load:\n                break\n    \n    # Remove units if possible\n    if total_min > current_load:\n        online_flexible = [i for i in flexible if units_info[i]['u_i_0'] == 1 and i not in must_run]\n        online_flexible.sort(key=lambda i: avg_costs[i], reverse=True)\n        for i in online_flexible:\n            if i in committed:\n                committed.remove(i)\n                total_min -= units_info[i]['p_min_i']\n                if total_min <= current_load:\n                    break\n    \n    # Economic dispatch\n    committed = list(committed)\n    # Initialize outputs\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        p[i] = low\n    \n    total_p = sum(p)\n    remaining = current_load - total_p\n    \n    # Distribute remaining load\n    if remaining > 0:\n        incr_costs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high = min(unit['p_max_i'], unit['p_start_i'])\n            incr_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            incr_costs.append((i, incr_cost, high - p[i]))\n        \n        incr_costs.sort(key=lambda x: x[1])\n        for i, _, capacity in incr_costs:\n            if remaining <= 0:\n                break\n            alloc = min(remaining, capacity)\n            p[i] += alloc\n            remaining -= alloc\n    \n    # Set commitment states\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0239962972,
          "gap_price_rate": 0.0161415843,
          "fitness": 0.0200689407
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and adjustable based on minimum up/down times and shutdown ramp constraints\n2. Calculate total available generation from must-run units considering ramp limits\n3. If must-run generation exceeds load, reduce output starting from highest cost units\n4. If must-run generation is insufficient, commit adjustable units by ascending marginal cost\n5. Dispatch load economically across committed units using marginal cost sorting\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units and determine must-run commitments\n    must_run_indices = []\n    must_off_indices = []\n    adjustable_indices = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run_indices.append(i)\n            else:\n                adjustable_indices.append(i)\n        else:  # Previously offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                adjustable_indices.append(i)\n    \n    # Calculate must-run generation capacity\n    must_run_p_min = 0\n    must_run_p_max = 0\n    for i in must_run_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        must_run_p_min += p_min\n        must_run_p_max += p_max\n    \n    # Handle excess must-run generation\n    if must_run_p_min > current_load:\n        # Reduce output from highest cost units first\n        excess = must_run_p_min - current_load\n        sorted_must_run = sorted(must_run_indices, \n            key=lambda i: units[i]['b_i'] + 2*units[i]['c_i']*units[i]['p_i_0'], reverse=True)\n        \n        for i in sorted_must_run:\n            if excess <= 0:\n                break\n            unit = units[i]\n            reduction = min(excess, unit['p_i_0'] - unit['p_min_i'])\n            units[i]['p_i'] = unit['p_i_0'] - reduction\n            excess -= reduction\n            schedules[0][i] = 1\n            schedules[1][i] = units[i]['p_i']\n        return schedules\n    \n    # Commit adjustable units if needed\n    remaining_load = current_load - must_run_p_min\n    committed_adjustable = []\n    \n    if remaining_load > 0:\n        # Sort adjustable units by marginal cost at max output\n        sorted_adjustable = sorted(adjustable_indices,\n            key=lambda i: units[i]['b_i'] + 2*units[i]['c_i']*units[i]['p_max_i'])\n        \n        for i in sorted_adjustable:\n            if remaining_load <= 0:\n                break\n            unit = units[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if p_max >= unit['p_min_i']:\n                committed_adjustable.append(i)\n                remaining_load -= max(0, p_max - unit['p_min_i'])\n    \n    # Economic dispatch\n    all_committed = must_run_indices + committed_adjustable\n    total_min = sum(max(units[i]['p_min_i'], units[i]['p_i_0'] - units[i]['p_down_i']) \n                 if units[i]['u_i_0'] == 1 else units[i]['p_min_i'] for i in all_committed)\n    remaining = current_load - total_min\n    \n    # Sort committed units by marginal cost\n    cost_sorted = sorted(all_committed,\n        key=lambda i: units[i]['b_i'] + 2*units[i]['c_i']*units[i]['p_min_i'])\n    \n    # Dispatch load to units\n    for i in cost_sorted:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p_min = unit['p_min_i']\n        \n        allocation = min(remaining, p_max - p_min)\n        units[i]['p_i'] = p_min + allocation\n        remaining -= allocation\n        schedules[0][i] = 1\n        schedules[1][i] = units[i]['p_i']\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0929958182,
          "fitness": 0.0465379723
     },
     {
          "name": "commit_units_by_adaptive_merit_order",
          "algorithm": "1. Identify must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Calculate remaining load after must-run unit allocation\n  3. Create merit order list for flexible units using adaptive cost function combining incremental cost and flexibility metrics\n  4. Commit units from merit order until remaining load is covered\n  5. Perform economic dispatch using constrained quadratic programming\n  6. Adjust for ramp limits and startup/shutdown constraints\n  7. Return commitment and generation schedule\n\n",
          "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef commit_units_by_adaptive_merit_order(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    \n    # Identify must-run units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n                u[i] = 1\n                p[i] = max(unit['p_min_i'], \n                          unit['p_i_0'] - unit['p_down_i'])\n    \n    # Calculate remaining load\n    allocated = np.sum(p)\n    remaining_load = current_load - allocated\n    \n    # Create merit order for flexible units\n    merit_order = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and unit['t_i_0'] <= -unit['t_off_min_i']:\n            # Adaptive cost metric\n            base_cost = unit['b_i'] + 2*unit['c_i']*unit['p_max_i']\n            flexibility = (unit['p_up_i'] + unit['p_down_i']) / unit['p_max_i']\n            merit_score = base_cost * (1 - 0.1*flexibility)\n            merit_order.append((i, merit_score))\n    \n    # Sort by merit score\n    merit_order.sort(key=lambda x: x[1])\n    \n    # Commit units until load is met\n    for idx, _ in merit_order:\n        if remaining_load <= 0:\n            break\n        unit = units_info[idx]\n        u[idx] = 1\n        p_max = min(unit['p_max_i'],\n                   unit['p_start_i'] if unit['u_i_0'] == 0 else unit['p_i_0'] + unit['p_up_i'])\n        p_alloc = min(remaining_load, p_max)\n        p[idx] = max(unit['p_min_i'], p_alloc)\n        remaining_load -= p_alloc\n    \n    # Economic dispatch for committed units\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    \n    def cost_function(p_vec):\n        total = 0\n        for i, idx in enumerate(committed_idx):\n            unit = units_info[idx]\n            total += (unit['a_i'] * u[idx] + \n                     unit['b_i'] * p_vec[i] + \n                     unit['c_i'] * p_vec[i]**2)\n            if unit['u_i_0'] == 0 and u[idx] == 1:\n                total += unit['s_i']\n        return total\n    \n    # Constraints\n    bounds = []\n    constraints = []\n    initial_guess = []\n    \n    for idx in committed_idx:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            p_min = max(p_min, unit['p_i_0'] - unit['p_down_i'])\n        p_max = unit['p_max_i']\n        if unit['u_i_0'] == 1:\n            p_max = min(p_max, unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_max = min(p_max, unit['p_start_i'])\n        bounds.append((p_min, p_max))\n        initial_guess.append((p_min + p_max)/2)\n    \n    constraints.append({'type': 'eq', \n                       'fun': lambda x: np.sum(x) - current_load})\n    \n    # Solve optimization\n    res = minimize(cost_function, initial_guess,\n                  bounds=bounds, constraints=constraints,\n                  method='SLSQP')\n    \n    # Update output values\n    for i, idx in enumerate(committed_idx):\n        p[idx] = res.x[i]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0967706495,
          "gap_price_rate": 0.0884069012,
          "fitness": 0.0925887754
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Initialize schedules array with default values (u_i=0, p_i=0)\n2. Identify must-run units based on min up/down times and shutdown ramp constraints\n3. Calculate power bounds for each unit considering ramp limits and startup/shutdown constraints\n4. Sort available units by marginal cost (b_i + 2*c_i*p_min_i) for priority commitment\n5. Commit must-run units first, then additional units by priority until load is met\n6. Perform economic dispatch using Lagrangian relaxation with ramp constraints\n7. Adjust commitments considering forecasted load to minimize unnecessary startups\n8. Ensure all constraints are satisfied before returning final schedule\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize unit states\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    marginal_cost = np.zeros(num_units)\n    \n    # Calculate power bounds and marginal costs\n    for i, unit in enumerate(units_info):\n        # Must-run conditions\n        min_up_violation = unit['u_i_0'] == 1 and unit['t_i_0'] < unit['t_on_min_i']\n        shutdown_ramp_violation = unit['u_i_0'] == 1 and unit['p_i_0'] > unit['p_shut_i']\n        must_run = min_up_violation or shutdown_ramp_violation\n        \n        # Power bounds calculation\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * min_p[i]\n        \n        # Commit must-run units\n        if must_run:\n            u[i] = 1\n            p[i] = min_p[i]\n    \n    # Calculate remaining load\n    committed_power = np.sum(p)\n    remaining_load = current_load - committed_power\n    \n    # Commit additional units by priority\n    priority_order = np.argsort(marginal_cost)\n    for i in priority_order:\n        if remaining_load <= 0:\n            break\n        if u[i] == 0 and remaining_load > 0:\n            available_power = max_p[i] - min_p[i]\n            if available_power > 0:\n                u[i] = 1\n                p[i] = min_p[i] + min(available_power, remaining_load)\n                remaining_load -= (p[i] - min_p[i])\n    \n    # Economic dispatch with ramp constraints\n    lambda_val = 0\n    tolerance = 1e-3\n    max_iterations = 100\n    \n    for _ in range(max_iterations):\n        total_power = 0\n        for i in range(num_units):\n            if u[i] == 1:\n                # Calculate optimal power for current lambda\n                p_opt = (lambda_val - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                # Apply constraints\n                p[i] = np.clip(p_opt, min_p[i], max_p[i])\n                total_power += p[i]\n        \n        # Update lambda\n        error = total_power - current_load\n        if abs(error) < tolerance:\n            break\n        lambda_val -= error / np.sum([1/(2*unit['c_i']) for i, unit in enumerate(units_info) if u[i] == 1])\n    \n    # Adjust for forecasted load\n    if forecast_load < current_load:\n        for i in range(num_units):\n            if u[i] == 1 and p[i] > min_p[i] and not (units_info[i]['u_i_0'] == 1 and units_info[i]['t_i_0'] < units_info[i]['t_on_min_i']):\n                reducible = p[i] - min_p[i]\n                if reducible >= (current_load - forecast_load):\n                    p[i] -= (current_load - forecast_load)\n                    break\n    \n    # Ensure load balance\n    total_output = np.sum(p)\n    if abs(total_output - current_load) > tolerance:\n        # Distribute imbalance proportionally\n        imbalance = current_load - total_output\n        for i in range(num_units):\n            if u[i] == 1:\n                p[i] += imbalance * (max_p[i] - min_p[i]) / np.sum([max_p[j] - min_p[j] for j in range(num_units) if u[j] == 1])\n                p[i] = np.clip(p[i], min_p[i], max_p[i])\n    \n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": null,
          "gap_power_rate": 0.2143888051,
          "gap_price_rate": 0.2113234415,
          "fitness": 0.2128561233
     }
]