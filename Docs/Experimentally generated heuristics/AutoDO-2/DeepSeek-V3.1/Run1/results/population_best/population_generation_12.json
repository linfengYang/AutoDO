{
     "name": "improved_rolling_commitment",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecast to avoid unnecessary startups\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits and startup/shutdown constraints\n3. If must-run capacity is insufficient for current load, commit flexible units using two-period cost analysis with startup cost amortization over current and forecasted loads, sorted by ascending average cost\n4. Perform economic dispatch using iterative marginal cost-based allocation within feasible output ranges while respecting all ramp constraints\n5. Adjust outputs proportionally to exactly match current load while maintaining all unit constraints\n6. Validate and enforce minimum up/down times and ramp limits during commitment decisions\n\n",
     "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Determine must-run status\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        # Compute feasible output range\n        if u0 == 1:\n            feasible_min[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize must-run units\n    total_min = 0\n    total_max = 0\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    # Initialize must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    # Commit flexible units if needed\n    if total_min > current_load:\n        # Reduce must-run outputs if possible\n        deficit = total_min - current_load\n        for i in must_run:\n            if deficit <= 0:\n                break\n            reducible = p[i] - feasible_min[i]\n            reduction = min(deficit, reducible)\n            p[i] -= reduction\n            deficit -= reduction\n    elif total_max < current_load:\n        # Commit flexible units based on two-period cost\n        flex_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if u[i] == 0:  # Offline unit\n                # Two-period cost with startup amortization\n                cost_per_mw = (2*unit['a_i'] + unit['b_i']*feasible_max[i] + \n                              unit['c_i']*feasible_max[i]**2 + unit['s_i']) / (2*feasible_max[i])\n            else:  # Online unit\n                cost_per_mw = (unit['a_i'] + unit['b_i']*feasible_max[i] + \n                              unit['c_i']*feasible_max[i]**2) / feasible_max[i]\n            flex_costs.append((i, cost_per_mw))\n        \n        # Sort by cost and commit\n        flex_costs.sort(key=lambda x: x[1])\n        for i, cost in flex_costs:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            p[i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n    \n    # Economic dispatch for committed units\n    committed = [i for i in range(n_units) if u[i] == 1]\n    current_total = sum(p[i] for i in committed)\n    remaining = current_load - current_total\n    \n    if remaining > 0:\n        # Allocate remaining load based on marginal cost\n        units_sorted = sorted(committed, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n        for i in units_sorted:\n            if remaining <= 0:\n                break\n            available = feasible_max[i] - p[i]\n            allocate = min(remaining, available)\n            p[i] += allocate\n            remaining -= allocate\n    elif remaining < 0:\n        # Reduce output based on marginal cost (reverse order)\n        units_sorted = sorted(committed, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'], reverse=True)\n        for i in units_sorted:\n            if remaining >= 0:\n                break\n            reducible = p[i] - feasible_min[i]\n            reduction = min(-remaining, reducible)\n            p[i] -= reduction\n            remaining += reduction\n    \n    # Ensure exact load matching with proportional adjustment\n    current_total = sum(p[i] for i in committed)\n    if abs(current_total - current_load) > 1e-6:\n        ratio = current_load / current_total if current_total > 0 else 0\n        for i in committed:\n            new_p = p[i] * ratio\n            new_p = max(feasible_min[i], min(feasible_max[i], new_p))\n            p[i] = new_p\n    \n    return np.array([u, p])",
     "from": "mutation",
     "gap_power_rate": 0.00525,
     "gap_price_rate": 0.00871,
     "fitness": 0.00698
}