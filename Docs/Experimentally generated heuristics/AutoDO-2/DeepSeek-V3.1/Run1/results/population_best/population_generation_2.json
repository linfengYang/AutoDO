{
     "name": "refined_rolling_commitment",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits\n3. If must-run capacity is insufficient, commit flexible units in ascending order of average cost at maximum output (including startup costs for offline units)\n4. Perform economic dispatch using incremental cost-based load allocation within feasible output ranges\n5. Adjust outputs iteratively to match current load while respecting all constraints\n6. Ensure must-off units remain decommitted with zero output\n\n",
     "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Precompute feasible output ranges\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            unit['min_feasible'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['min_feasible'] = unit['p_min_i']\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Initialize must-run units\n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['p_i'] = unit['min_feasible']\n    \n    total_capacity = sum(unit['max_feasible'] for unit in must_run)\n    \n    # Commit flexible units if needed\n    if total_capacity < current_load:\n        for unit in flexible:\n            if unit['u_i_0'] == 1:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            else:\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            unit['avg_cost'] = avg_cost\n        \n        flexible.sort(key=lambda x: x['avg_cost'])\n        \n        for unit in flexible:\n            if total_capacity >= current_load:\n                break\n            unit['u_i'] = 1\n            unit['p_i'] = unit['min_feasible']\n            total_capacity += unit['max_feasible']\n    \n    # Economic dispatch\n    committed = [u for u in must_run + flexible if u.get('u_i', 0) == 1]\n    total_output = sum(unit['p_i'] for unit in committed)\n    remaining_load = current_load - total_output\n    \n    while abs(remaining_load) > 1e-6:\n        # Calculate incremental costs\n        for unit in committed:\n            unit['inc_cost'] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n        \n        if remaining_load > 0:\n            # Find unit with lowest incremental cost that can increase output\n            candidate = min([u for u in committed if u['p_i'] < u['max_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_increase = min(remaining_load, candidate['max_feasible'] - candidate['p_i'])\n                candidate['p_i'] += max_increase\n                remaining_load -= max_increase\n            else:\n                break\n        else:\n            # Find unit with highest incremental cost that can decrease output\n            candidate = max([u for u in committed if u['p_i'] > u['min_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_decrease = min(-remaining_load, candidate['p_i'] - candidate['min_feasible'])\n                candidate['p_i'] -= max_decrease\n                remaining_load += max_decrease\n            else:\n                break\n    \n    # Set must-off and non-committed units\n    for unit in must_off + flexible:\n        if unit.get('u_i', 0) == 0:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Prepare output\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit.get('u_i', 0)\n        schedules[1, i] = unit.get('p_i', 0)\n    \n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.00565,
     "gap_price_rate": 0.00847,
     "fitness": 0.00706
}