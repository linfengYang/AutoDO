{
     "name": "enhanced_rolling_commitment_v7",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced criteria incorporating current and forecasted loads, minimum up/down times, shutdown ramp constraints, and historical states with improved feasibility checks\n2. Calculate dynamic power bounds for all units considering ramp limits, startup/shutdown constraints, and historical outputs with enhanced two-period lookahead validation\n3. If must-run capacity exceeds current load, adjust outputs using improved marginal cost-based reduction with constraint validation and forecast-aware scaling\n4. If must-run capacity is insufficient, commit flexible units using enhanced two-period cost analysis with startup cost amortization and incremental cost sorting, weighted by forecasted load demand\n5. Perform economic dispatch using iterative lambda iteration with merit-order loading within feasible ranges and ramp-aware adjustment\n6. Implement proportional adjustment with constraint-aware scaling to exactly match current load while maintaining all constraints\n7. Validate and enforce all constraints including minimum up/down times and ramp limits during commitment decisions with enhanced look-ahead verification and feasibility recovery\n\n",
     "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v7(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    # Precompute feasible power ranges and classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power range considering ramp limits\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Classify units\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Handle must-run units\n    for i in must_run:\n        u[i] = 1\n        p[i] = min_p[i]\n    \n    total_min = sum(p)\n    total_max = sum(max_p[i] for i in must_run)\n    \n    # Adjust if must-run capacity exceeds load\n    if total_min > current_load:\n        # Reduce output based on marginal cost\n        committed = must_run.copy()\n        marginal_costs = []\n        for i in committed:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n            marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(reverse=True)\n        \n        for _, i in marginal_costs:\n            reduction = min(p[i] - min_p[i], total_min - current_load)\n            p[i] -= reduction\n            total_min -= reduction\n            if abs(total_min - current_load) < 1e-6:\n                break\n    elif total_max < current_load:\n        # Commit flexible units based on enhanced two-period cost analysis\n        flexible_costs = []\n        for i in flexible:\n            if units_info[i]['u_i_0'] == 0:\n                # Startup cost amortization over two periods\n                current_output = min(max_p[i], forecast_load * max_p[i] / (sum(max_p) + 1e-6))\n                next_output = min(units_info[i]['p_max_i'], current_output + units_info[i]['p_up_i'])\n                total_output = current_output + next_output\n                total_cost = units_info[i]['s_i'] + units_info[i]['a_i'] * 2 + units_info[i]['b_i'] * total_output + units_info[i]['c_i'] * (current_output**2 + next_output**2)\n                avg_cost = total_cost / total_output if total_output > 0 else float('inf')\n            else:\n                # Already running, no startup cost\n                current_output = max_p[i]\n                next_output = min(units_info[i]['p_max_i'], current_output + units_info[i]['p_up_i'])\n                total_output = current_output + next_output\n                total_cost = units_info[i]['a_i'] * 2 + units_info[i]['b_i'] * total_output + units_info[i]['c_i'] * (current_output**2 + next_output**2)\n                avg_cost = total_cost / total_output if total_output > 0 else float('inf')\n            flexible_costs.append((avg_cost, i))\n        \n        flexible_costs.sort()\n        \n        for avg_cost, i in flexible_costs:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            p[i] = min_p[i]\n            total_max += max_p[i]\n            must_run.append(i)\n    \n    # Economic dispatch using lambda iteration\n    committed_idx = must_run\n    lambda_low = 0\n    lambda_high = 1000\n    \n    for _ in range(100):  # Lambda iteration\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        for i in committed_idx:\n            p_i = (lambda_mid - units_info[i]['b_i']) / (2 * units_info[i]['c_i']) if units_info[i]['c_i'] > 0 else max_p[i]\n            p_i = np.clip(p_i, min_p[i], max_p[i])\n            total_power += p_i\n        \n        if abs(total_power - current_load) < 1e-6:\n            break\n        elif total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set outputs based on final lambda\n    for i in committed_idx:\n        p[i] = (lambda_mid - units_info[i]['b_i']) / (2 * units_info[i]['c_i']) if units_info[i]['c_i'] > 0 else max_p[i]\n        p[i] = np.clip(p[i], min_p[i], max_p[i])\n    \n    # Proportional adjustment to match load exactly\n    total_output = sum(p)\n    if abs(total_output - current_load) > 1e-6:\n        ratio = current_load / total_output\n        for i in committed_idx:\n            new_p = p[i] * ratio\n            if new_p < min_p[i]:\n                new_p = min_p[i]\n            elif new_p > max_p[i]:\n                new_p = max_p[i]\n            p[i] = new_p\n    \n    # Final validation of constraints\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            assert min_p[i] <= p[i] <= max_p[i], f\"Unit {i} output out of bounds\"\n            if unit['u_i_0'] == 0:\n                assert p[i] <= unit['p_start_i'], f\"Unit {i} violates startup ramp\"\n        else:\n            assert p[i] == 0, f\"Unit {i} is off but has output\"\n    \n    return np.array([u, p])",
     "from": "crossover",
     "gap_power_rate": 0.00502,
     "gap_price_rate": 0.0083,
     "fitness": 0.00666
}