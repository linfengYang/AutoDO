[
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecast to avoid unnecessary startups\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits and startup/shutdown constraints\n3. If must-run capacity is insufficient for current load, commit flexible units using two-period cost analysis with startup cost amortization over current and forecasted loads, sorted by ascending average cost\n4. Perform economic dispatch using iterative marginal cost-based allocation within feasible output ranges while respecting all ramp constraints\n5. Adjust outputs proportionally to exactly match current load while maintaining all unit constraints\n6. Validate and enforce minimum up/down times and ramp limits during commitment decisions\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and compute feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Determine must-run status\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        # Compute feasible output range\n        if u0 == 1:\n            feasible_min[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize must-run units\n    total_min = 0\n    total_max = 0\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    # Initialize must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    # Commit flexible units if needed\n    if total_min > current_load:\n        # Reduce must-run outputs if possible\n        deficit = total_min - current_load\n        for i in must_run:\n            if deficit <= 0:\n                break\n            reducible = p[i] - feasible_min[i]\n            reduction = min(deficit, reducible)\n            p[i] -= reduction\n            deficit -= reduction\n    elif total_max < current_load:\n        # Commit flexible units based on two-period cost\n        flex_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if u[i] == 0:  # Offline unit\n                # Two-period cost with startup amortization\n                cost_per_mw = (2*unit['a_i'] + unit['b_i']*feasible_max[i] + \n                              unit['c_i']*feasible_max[i]**2 + unit['s_i']) / (2*feasible_max[i])\n            else:  # Online unit\n                cost_per_mw = (unit['a_i'] + unit['b_i']*feasible_max[i] + \n                              unit['c_i']*feasible_max[i]**2) / feasible_max[i]\n            flex_costs.append((i, cost_per_mw))\n        \n        # Sort by cost and commit\n        flex_costs.sort(key=lambda x: x[1])\n        for i, cost in flex_costs:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            p[i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n    \n    # Economic dispatch for committed units\n    committed = [i for i in range(n_units) if u[i] == 1]\n    current_total = sum(p[i] for i in committed)\n    remaining = current_load - current_total\n    \n    if remaining > 0:\n        # Allocate remaining load based on marginal cost\n        units_sorted = sorted(committed, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n        for i in units_sorted:\n            if remaining <= 0:\n                break\n            available = feasible_max[i] - p[i]\n            allocate = min(remaining, available)\n            p[i] += allocate\n            remaining -= allocate\n    elif remaining < 0:\n        # Reduce output based on marginal cost (reverse order)\n        units_sorted = sorted(committed, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'], reverse=True)\n        for i in units_sorted:\n            if remaining >= 0:\n                break\n            reducible = p[i] - feasible_min[i]\n            reduction = min(-remaining, reducible)\n            p[i] -= reduction\n            remaining += reduction\n    \n    # Ensure exact load matching with proportional adjustment\n    current_total = sum(p[i] for i in committed)\n    if abs(current_total - current_load) > 1e-6:\n        ratio = current_load / current_total if current_total > 0 else 0\n        for i in committed:\n            new_p = p[i] * ratio\n            new_p = max(feasible_min[i], min(feasible_max[i], new_p))\n            p[i] = new_p\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00525,
          "gap_price_rate": 0.00871,
          "fitness": 0.00698
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits\n3. If must-run capacity is insufficient, commit flexible units in ascending order of average cost at maximum output (including startup costs for offline units)\n4. Perform economic dispatch using incremental cost-based load allocation within feasible output ranges\n5. Adjust outputs iteratively to match current load while respecting all constraints\n6. Ensure must-off units remain decommitted with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Precompute feasible output ranges\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            unit['min_feasible'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['min_feasible'] = unit['p_min_i']\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Initialize must-run units\n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['p_i'] = unit['min_feasible']\n    \n    total_capacity = sum(unit['max_feasible'] for unit in must_run)\n    \n    # Commit flexible units if needed\n    if total_capacity < current_load:\n        for unit in flexible:\n            if unit['u_i_0'] == 1:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            else:\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            unit['avg_cost'] = avg_cost\n        \n        flexible.sort(key=lambda x: x['avg_cost'])\n        \n        for unit in flexible:\n            if total_capacity >= current_load:\n                break\n            unit['u_i'] = 1\n            unit['p_i'] = unit['min_feasible']\n            total_capacity += unit['max_feasible']\n    \n    # Economic dispatch\n    committed = [u for u in must_run + flexible if u.get('u_i', 0) == 1]\n    total_output = sum(unit['p_i'] for unit in committed)\n    remaining_load = current_load - total_output\n    \n    while abs(remaining_load) > 1e-6:\n        # Calculate incremental costs\n        for unit in committed:\n            unit['inc_cost'] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n        \n        if remaining_load > 0:\n            # Find unit with lowest incremental cost that can increase output\n            candidate = min([u for u in committed if u['p_i'] < u['max_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_increase = min(remaining_load, candidate['max_feasible'] - candidate['p_i'])\n                candidate['p_i'] += max_increase\n                remaining_load -= max_increase\n            else:\n                break\n        else:\n            # Find unit with highest incremental cost that can decrease output\n            candidate = max([u for u in committed if u['p_i'] > u['min_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_decrease = min(-remaining_load, candidate['p_i'] - candidate['min_feasible'])\n                candidate['p_i'] -= max_decrease\n                remaining_load += max_decrease\n            else:\n                break\n    \n    # Set must-off and non-committed units\n    for unit in must_off + flexible:\n        if unit.get('u_i', 0) == 0:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Prepare output\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit.get('u_i', 0)\n        schedules[1, i] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00565,
          "gap_price_rate": 0.00847,
          "fitness": 0.00706
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Commit must-run units and set to minimum feasible output considering ramp limits\n3. Sort flexible units by average cost per MW at maximum output (including startup cost if applicable)\n4. Commit flexible units in cost order until total maximum capacity meets load\n5. Perform economic dispatch using incremental cost-based allocation within ramp constraints\n6. Adjust outputs iteratively to match load while respecting unit constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    low_bounds = [0] * n\n    high_bounds = [0] * n\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            low_bounds[i] = unit['p_min_i']\n            high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    committed = [False] * n\n    for i in range(n):\n        if must_on[i]:\n            committed[i] = True\n            u[i] = 1\n            p[i] = low_bounds[i]\n        elif must_off[i]:\n            committed[i] = False\n        else:\n            committed[i] = False\n\n    total_max_must = sum(high_bounds[i] for i in range(n) if must_on[i])\n    flexible_units = [i for i in range(n) if not must_on[i] and not must_off[i]]\n    \n    cost_list = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        cost_list.append((cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    current_max = total_max_must\n    for cost, idx in cost_list:\n        if current_max >= load[0]:\n            break\n        committed[idx] = True\n        u[idx] = 1\n        p[idx] = low_bounds[idx]\n        current_max += high_bounds[idx]\n\n    committed_indices = [i for i in range(n) if committed[i]]\n    current_outputs = [p[i] for i in committed_indices]\n    available = [high_bounds[i] - p[i] for i in committed_indices]\n    total_output = sum(current_outputs)\n    deficit = load[0] - total_output\n\n    while deficit > 0 and any(available):\n        min_marginal = float('inf')\n        candidate = -1\n        for pos, i in enumerate(committed_indices):\n            if available[pos] <= 0:\n                continue\n            unit = units_info[i]\n            marg = unit['b_i'] + 2 * unit['c_i'] * current_outputs[pos]\n            if marg < min_marginal:\n                min_marginal = marg\n                candidate = pos\n        if candidate == -1:\n            break\n        increment = min(1.0, available[candidate], deficit)\n        current_outputs[candidate] += increment\n        available[candidate] -= increment\n        deficit -= increment\n\n    for idx, i in enumerate(committed_indices):\n        p[i] = current_outputs[idx]\n\n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.0092,
          "fitness": 0.00739
     },
     {
          "name": "commit_units_improved_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown constraints\n2. Calculate feasible power ranges for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds load, reduce outputs starting with highest marginal cost units\n4. If must-run capacity is insufficient, commit flexible units by ascending average cost (including startup cost)\n5. Perform economic dispatch using incremental cost sorting with ramp-aware adjustment\n6. Ensure exact load matching through iterative proportional adjustment within feasible ranges\n7. Validate and enforce all constraints including startup/shutdown ramp limits\n\n",
          "code": "import numpy as np\n\ndef commit_units_improved_priority(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate must-run capacity\n    total_min_must = 0\n    total_max_must = 0\n    must_run_outputs = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_outputs.append((i, p_min, p_max))\n        total_min_must += p_min\n        total_max_must += p_max\n    \n    # Handle must-run surplus\n    if total_min_must > current_load:\n        deficit = total_min_must - current_load\n        # Sort must-run units by marginal cost descending\n        must_run_sorted = sorted(must_run_outputs, \n                                key=lambda x: units_info[x[0]]['b_i'] + 2*units_info[x[0]]['c_i']*x[1],\n                                reverse=True)\n        \n        for i, p_min, p_max in must_run_sorted:\n            unit = units_info[i]\n            reducible = p_min - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            reduction = min(deficit, reducible)\n            p[i] = p_min - reduction\n            u[i] = 1\n            deficit -= reduction\n            if deficit <= 0:\n                break\n        return np.array([u, p])\n    \n    # Commit flexible units if needed\n    if total_max_must < current_load:\n        deficit = current_load - total_max_must\n        flexible_costs = []\n        \n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                # Include startup cost\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                           unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            else:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                           unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            flexible_costs.append((i, avg_cost))\n        \n        # Sort by average cost\n        flexible_sorted = sorted(flexible_costs, key=lambda x: x[1])\n        \n        for i, cost in flexible_sorted:\n            if deficit <= 0:\n                break\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                p_max = min(p_max, unit['p_start_i'])\n            deficit -= max(0, p_max - (unit['p_i_0'] if unit['u_i_0'] == 1 else 0))\n            u[i] = 1\n    \n    # Economic dispatch\n    committed = must_run + [i for i in flexible if u[i] == 1]\n    # Set initial outputs\n    for i in committed:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        if unit['u_i_0'] == 0:\n            p_min = unit['p_min_i']\n        p[i] = p_min\n        u[i] = 1\n    \n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Adjust outputs\n    while abs(deficit) > 1e-6:\n        # Calculate marginal costs\n        margins = []\n        for i in committed:\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                p_max = min(p_max, unit['p_start_i'])\n            if deficit > 0 and p[i] < p_max:\n                margin = unit['b_i'] + 2*unit['c_i']*p[i]\n                margins.append((i, margin))\n            elif deficit < 0 and p[i] > max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']):\n                margin = unit['b_i'] + 2*unit['c_i']*p[i]\n                margins.append((i, margin))\n        \n        if not margins:\n            break\n            \n        if deficit > 0:\n            i = min(margins, key=lambda x: x[1])[0]\n            p_max = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            if units_info[i]['u_i_0'] == 0:\n                p_max = min(p_max, units_info[i]['p_start_i'])\n            increase = min(deficit, p_max - p[i])\n            p[i] += increase\n            deficit -= increase\n        else:\n            i = max(margins, key=lambda x: x[1])[0]\n            p_min = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            decrease = min(-deficit, p[i] - p_min)\n            p[i] -= decrease\n            deficit += decrease\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00605,
          "gap_price_rate": 0.01044,
          "fitness": 0.00824
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced on, forced off, and flexible based on min up/down times and shutdown ramp constraints.\n2. Compute total available capacity from forced-on units considering ramp limits.\n3. If load exceeds forced-on capacity, commit flexible units by ascending order of average cost at minimum output until load is met.\n4. For committed units, set initial output to lower bounds (considering min output and ramp-down limits).\n5. Distribute remaining load to units by ascending marginal cost while respecting ramp-up and max output limits.\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < toff_min:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_min_forced = 0\n    total_max_forced = 0\n    for i in forced_on:\n        unit = units_info[i]\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pdown = unit['p_down_i']\n        pup = unit['p_up_i']\n        lower = max(pmin, p0 - pdown)\n        upper = min(pmax, p0 + pup)\n        total_min_forced += lower\n        total_max_forced += upper\n    \n    online = list(forced_on)\n    if current_load > total_max_forced:\n        def avg_cost(i):\n            u = units_info[i]\n            return (u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2 + u['s_i']) / u['p_min_i']\n        flexible.sort(key=avg_cost)\n        for i in flexible:\n            if total_max_forced >= current_load:\n                break\n            unit = units_info[i]\n            total_max_forced += min(unit['p_max_i'], unit['p_start_i'])\n            online.append(i)\n    \n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    for i in online:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p0 = unit['p_i_0']\n            lower_bounds[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            upper_bounds[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            lower_bounds[i] = unit['p_min_i']\n            upper_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in online:\n        p[i] = lower_bounds[i]\n    total_output = np.sum(p)\n    \n    remaining = current_load - total_output\n    while remaining > 0:\n        candidates = [i for i in online if p[i] < upper_bounds[i]]\n        if not candidates:\n            break\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n        best_idx = candidates[np.argmin(marginal_costs)]\n        increment = min(remaining, upper_bounds[best_idx] - p[best_idx])\n        p[best_idx] += increment\n        remaining -= increment\n    \n    for i in online:\n        u[i] = 1\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00614,
          "gap_price_rate": 0.01074,
          "fitness": 0.00844
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecast\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits and startup/shutdown constraints\n3. If must-run capacity is insufficient for current load, commit flexible units in ascending order of two-period average cost (including startup costs amortized over current and forecasted load)\n4. Perform economic dispatch using iterative marginal cost-based allocation within feasible output ranges, respecting all ramp constraints\n5. Adjust outputs proportionally to exactly match current load while maintaining all unit constraints\n6. Validate commitments against next period forecast to avoid unnecessary startups or shutdowns\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    \n    # Precompute feasible ranges and classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        # Calculate feasible output range\n        if u_i_0 == 1:\n            min_feasible[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_feasible[i] = min(p_max_i, p_i_0 + p_up_i)\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            min_feasible[i] = p_min_i\n            max_feasible[i] = min(p_max_i, p_start_i)\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate marginal cost\n        marginal_cost[i] = b_i + 2 * c_i * p_i_0\n    \n    # Set must-run units\n    for i in must_run:\n        u[i] = 1\n        p[i] = min_feasible[i]\n    \n    # Set must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    # Calculate current capacity\n    total_min = np.sum(p[must_run])\n    total_max = np.sum(max_feasible[must_run])\n    \n    # Commit flexible units if needed\n    if current_load > total_max:\n        # Calculate average costs including startup\n        avg_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if units_info[i]['u_i_0'] == 0:\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                        unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            else:\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                        unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n            avg_costs.append((i, cost))\n        \n        # Sort by average cost\n        avg_costs.sort(key=lambda x: x[1])\n        \n        # Commit units until load is met\n        for i, _ in avg_costs:\n            if current_load <= total_max:\n                break\n            u[i] = 1\n            p[i] = min_feasible[i]\n            total_max += max_feasible[i]\n            total_min += min_feasible[i]\n    \n    # Economic dispatch\n    committed = np.where(u == 1)[0]\n    total_output = np.sum(p)\n    \n    # Adjust outputs to match load\n    if total_output < current_load:\n        # Distribute remaining load by marginal cost\n        remaining = current_load - total_output\n        while remaining > 1e-6:\n            # Find unit with lowest marginal cost that can increase output\n            best_unit = None\n            best_cost = float('inf')\n            for i in committed:\n                if p[i] < max_feasible[i]:\n                    cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            # Increase output\n            max_increase = max_feasible[best_unit] - p[best_unit]\n            increase = min(remaining, max_increase)\n            p[best_unit] += increase\n            remaining -= increase\n    \n    elif total_output > current_load:\n        # Reduce output by marginal cost\n        remaining = total_output - current_load\n        while remaining > 1e-6:\n            # Find unit with highest marginal cost that can decrease output\n            best_unit = None\n            best_cost = -float('inf')\n            for i in committed:\n                if p[i] > min_feasible[i]:\n                    cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if cost > best_cost:\n                        best_cost = cost\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            # Decrease output\n            max_decrease = p[best_unit] - min_feasible[best_unit]\n            decrease = min(remaining, max_decrease)\n            p[best_unit] -= decrease\n            remaining -= decrease\n    \n    # Update schedules\n    schedules[0] = u\n    schedules[1] = p\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "enhanced_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecast\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits and startup/shutdown constraints\n3. If must-run capacity is insufficient for current load, commit flexible units using two-period cost analysis with startup cost amortization over current and forecasted loads, sorted by ascending average cost\n4. Perform economic dispatch using iterative marginal cost-based allocation within feasible output ranges while respecting all ramp constraints\n5. Adjust outputs proportionally to exactly match current load while maintaining all unit constraints\n6. Validate and enforce minimum up/down times and ramp limits during commitment decisions\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v4(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    next_load = load[1]\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_i0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        min_output = max(p_min_i, p_i0 - p_down_i)\n        u[i] = 1\n        p[i] = min_output\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    cost_list = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        s_i = unit['s_i']\n        p_max_i = unit['p_max_i']\n        u_i0 = unit['u_i_0']\n        \n        if u_i0 == 0:\n            total_output = min(p_max_i, current_load) + min(p_max_i, next_load)\n            if total_output == 0:\n                avg_cost = float('inf')\n            else:\n                total_cost = s_i + b_i * total_output + c_i * (min(p_max_i, current_load)**2 + min(p_max_i, next_load)**2)\n                avg_cost = total_cost / total_output\n        else:\n            total_output = min(p_max_i, current_load) + min(p_max_i, next_load)\n            if total_output == 0:\n                avg_cost = float('inf')\n            else:\n                total_cost = b_i * total_output + c_i * (min(p_max_i, current_load)**2 + min(p_max_i, next_load)**2)\n                avg_cost = total_cost / total_output\n        cost_list.append((avg_cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    \n    total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_max_i = unit['p_max_i']\n        max_output = min(p_max_i, p_i0 + p_up_i)\n        total_max += max_output\n    \n    committed_flexible = []\n    for avg_cost, idx in cost_list:\n        unit = units_info[idx]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            max_output = min(p_max_i, p_i0 + p_up_i)\n        else:\n            max_output = min(p_max_i, p_start_i)\n        \n        if total_max + max_output >= current_load:\n            committed_flexible.append(idx)\n            total_max += max_output\n            break\n        else:\n            committed_flexible.append(idx)\n            total_max += max_output\n    \n    for i in committed_flexible:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i0 == 1:\n            min_output = max(p_min_i, p_i0 - p_down_i)\n        else:\n            min_output = p_min_i\n        \n        u[i] = 1\n        p[i] = min_output\n    \n    committed_indices = must_run + committed_flexible\n    total_output = np.sum(p[committed_indices])\n    remaining_load = current_load - total_output\n    \n    if remaining_load > 0:\n        units_to_adjust = []\n        for i in committed_indices:\n            unit = units_info[i]\n            u_i0 = unit['u_i_0']\n            p_i0 = unit['p_i_0']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            p_start_i = unit['p_start_i']\n            current_p = p[i]\n            \n            if u_i0 == 1:\n                max_output = min(p_max_i, p_i0 + p_up_i)\n            else:\n                max_output = min(p_max_i, p_start_i)\n            \n            if current_p < max_output:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                units_to_adjust.append((marginal_cost, i, current_p, max_output))\n        \n        units_to_adjust.sort(key=lambda x: x[0])\n        for mc, i, current_p, max_output in units_to_adjust:\n            if remaining_load <= 0:\n                break\n            add_amount = min(remaining_load, max_output - current_p)\n            p[i] += add_amount\n            remaining_load -= add_amount\n    \n    elif remaining_load < 0:\n        remaining_load = abs(remaining_load)\n        units_to_adjust = []\n        for i in committed_indices:\n            unit = units_info[i]\n            u_i0 = unit['u_i_0']\n            p_i0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_down_i = unit['p_down_i']\n            current_p = p[i]\n            \n            if u_i0 == 1:\n                min_output = max(p_min_i, p_i0 - p_down_i)\n            else:\n                min_output = p_min_i\n            \n            if current_p > min_output:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                units_to_adjust.append((marginal_cost, i, current_p, min_output))\n        \n        units_to_adjust.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, current_p, min_output in units_to_adjust:\n            if remaining_load <= 0:\n                break\n            reduce_amount = min(remaining_load, current_p - min_output)\n            p[i] -= reduce_amount\n            remaining_load -= reduce_amount\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00688,
          "gap_price_rate": 0.01941,
          "fitness": 0.01315
     },
     {
          "name": "commit_units_rolling_improved",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on min up/down times and shutdown ramp constraints\n2. Compute power bounds for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds load, adjust outputs downward using marginal cost order\n4. If must-run capacity is insufficient, commit flexible units by ascending full-load average cost (including startup cost if applicable)\n5. Perform economic dispatch using Lagrangian relaxation with merit order loading\n6. Adjust commitments based on next period forecast using look-ahead startup logic\n7. Ensure all constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_improved(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    avg_cost = np.zeros(n_units)\n    \n    # Precompute unit constraints and costs\n    for i, unit in enumerate(units_info):\n        # Calculate feasible output range\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate costs\n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n        avg_cost[i] = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                      unit['c_i'] * unit['p_max_i']**2 + \n                      (unit['s_i'] if unit['u_i_0'] == 0 else 0)) / unit['p_max_i']\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        elif (unit['u_i_0'] == 0 and \n              (unit['t_i_0'] > -unit['t_off_min_i'] or \n               current_load < unit['p_min_i'])):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize must-run units\n    total_min_capacity = 0\n    total_max_capacity = 0\n    \n    for i in must_run:\n        u[i] = 1\n        p[i] = min_p[i]\n        total_min_capacity += min_p[i]\n        total_max_capacity += max_p[i]\n    \n    # Handle insufficient capacity\n    if total_max_capacity < current_load:\n        # Commit flexible units by average cost\n        flexible.sort(key=lambda i: avg_cost[i])\n        for i in flexible:\n            if total_max_capacity >= current_load:\n                break\n            if units_info[i]['u_i_0'] == 0 and current_load >= units_info[i]['p_min_i']:\n                u[i] = 1\n                p[i] = min_p[i]\n                total_min_capacity += min_p[i]\n                total_max_capacity += max_p[i]\n    \n    # Economic dispatch\n    load_remaining = current_load - total_min_capacity\n    units_to_adjust = [i for i in range(n_units) if u[i] == 1]\n    \n    while load_remaining > 1e-6:\n        # Find unit with minimum marginal cost that can increase output\n        candidate = None\n        min_marginal = float('inf')\n        for i in units_to_adjust:\n            if p[i] < max_p[i] and marginal_cost[i] < min_marginal:\n                min_marginal = marginal_cost[i]\n                candidate = i\n        \n        if candidate is None:\n            break\n        \n        # Calculate possible increase\n        increase = min(max_p[candidate] - p[candidate], \n                      units_info[candidate]['p_up_i'],\n                      load_remaining)\n        p[candidate] += increase\n        load_remaining -= increase\n        marginal_cost[candidate] = (units_info[candidate]['b_i'] + \n                                  2 * units_info[candidate]['c_i'] * p[candidate])\n    \n    # Look-ahead for next period\n    if next_load > current_load * 1.1:\n        # Consider starting additional units\n        for i in flexible:\n            if (u[i] == 0 and next_load >= units_info[i]['p_min_i'] and\n                units_info[i]['t_i_0'] <= -units_info[i]['t_off_min_i']):\n                u[i] = 1\n                p[i] = min_p[i]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.01363,
          "gap_price_rate": 0.01565,
          "fitness": 0.01464
     },
     {
          "name": "refined_adaptive_priority_with_ed_optimized",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced criteria incorporating current and forecasted loads, minimum up/down times, and shutdown ramp constraints\n2. Calculate dynamic power bounds for must-run units considering ramp limits, startup/shutdown constraints, and historical outputs\n3. If must-run capacity exceeds current load, adjust outputs using marginal cost-based reduction with constraint validation\n4. If must-run capacity is insufficient, commit flexible units using improved two-period cost analysis with startup cost amortization and incremental cost sorting\n5. Perform economic dispatch using iterative lambda iteration with merit-order loading within feasible ranges\n6. Implement proportional adjustment with constraint-aware scaling to exactly match current load\n7. Validate and enforce all constraints including minimum up/down times and ramp limits during commitment decisions\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_priority_with_ed_optimized(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    avg_cost = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power bounds\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate costs\n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n        avg_cost[i] = (unit['a_i'] + unit['b_i'] * max_p[i] + unit['c_i'] * max_p[i]**2 + \n                      (unit['s_i'] if unit['u_i_0'] == 0 else 0)) / max_p[i]\n        \n        # Classification\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        elif (unit['u_i_0'] == 0 and \n              unit['t_i_0'] > -unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Handle must-run units\n    total_min_must = sum(min_p[i] for i in must_run)\n    total_max_must = sum(max_p[i] for i in must_run)\n    \n    # Adjust if must-run capacity exceeds load\n    if total_min_must > current_load:\n        # Reduce output based on marginal cost\n        excess = total_min_must - current_load\n        must_run_sorted = sorted(must_run, key=lambda i: marginal_cost[i], reverse=True)\n        \n        for i in must_run_sorted:\n            reducible = min_p[i] - units_info[i]['p_min_i']\n            reduction = min(excess, reducible)\n            min_p[i] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n    \n    # Commit flexible units if needed\n    if total_max_must < current_load:\n        needed = current_load - total_max_must\n        # Calculate two-period cost for flexible units\n        flex_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            # Amortize startup cost over two periods\n            startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n            two_period_cost = (startup_cost + \n                              unit['a_i'] * 2 + \n                              unit['b_i'] * (max_p[i] + min(max_p[i], forecast_load)) +\n                              unit['c_i'] * (max_p[i]**2 + min(max_p[i], forecast_load)**2))\n            flex_costs.append((i, two_period_cost))\n        \n        # Sort by two-period cost and commit\n        flex_costs.sort(key=lambda x: x[1])\n        for i, _ in flex_costs:\n            if needed <= 0:\n                break\n            u[i] = 1\n            commit_capacity = min(needed, max_p[i] - min_p[i])\n            p[i] = min_p[i] + commit_capacity\n            needed -= commit_capacity\n    \n    # Economic dispatch using lambda iteration\n    committed = must_run + [i for i in flexible if u[i] == 1]\n    total_output = sum(p[i] for i in committed)\n    \n    # Lambda iteration for economic dispatch\n    lambda_val = np.mean([marginal_cost[i] for i in committed])\n    for _ in range(100):  # Maximum iterations\n        total_dispatch = 0\n        for i in committed:\n            p_dispatch = (lambda_val - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            p_dispatch = np.clip(p_dispatch, min_p[i], max_p[i])\n            p[i] = p_dispatch\n            total_dispatch += p_dispatch\n        \n        if abs(total_dispatch - current_load) < 1e-6:\n            break\n        \n        lambda_val += (current_load - total_dispatch) / sum(1/(2*units_info[i]['c_i']) for i in committed)\n    \n    # Proportional adjustment for exact match\n    total_output = sum(p[i] for i in committed)\n    if abs(total_output - current_load) > 1e-6:\n        ratio = current_load / total_output\n        for i in committed:\n            new_p = p[i] * ratio\n            p[i] = np.clip(new_p, min_p[i], max_p[i])\n    \n    # Final validation\n    for i in committed:\n        unit = units_info[i]\n        # Enforce ramp constraints\n        if unit['u_i_0'] == 1:\n            p[i] = np.clip(p[i], \n                          unit['p_i_0'] - unit['p_down_i'],\n                          unit['p_i_0'] + unit['p_up_i'])\n        # Enforce minimum output\n        p[i] = max(p[i], unit['p_min_i'])\n    \n    # Build output array\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if i in committed else 0\n        schedules[1, i] = p[i] if i in committed else 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00204,
          "gap_price_rate": 0.03035,
          "fitness": 0.01619
     }
]