[
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Commit must-run units and set to minimum feasible output considering ramp limits\n3. Sort flexible units by average cost per MW at maximum output (including startup cost if applicable)\n4. Commit flexible units in cost order until total maximum capacity meets load\n5. Perform economic dispatch using incremental cost-based allocation within ramp constraints\n6. Adjust outputs iteratively to match load while respecting unit constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    low_bounds = [0] * n\n    high_bounds = [0] * n\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            low_bounds[i] = unit['p_min_i']\n            high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    committed = [False] * n\n    for i in range(n):\n        if must_on[i]:\n            committed[i] = True\n            u[i] = 1\n            p[i] = low_bounds[i]\n        elif must_off[i]:\n            committed[i] = False\n        else:\n            committed[i] = False\n\n    total_max_must = sum(high_bounds[i] for i in range(n) if must_on[i])\n    flexible_units = [i for i in range(n) if not must_on[i] and not must_off[i]]\n    \n    cost_list = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        cost_list.append((cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    current_max = total_max_must\n    for cost, idx in cost_list:\n        if current_max >= load[0]:\n            break\n        committed[idx] = True\n        u[idx] = 1\n        p[idx] = low_bounds[idx]\n        current_max += high_bounds[idx]\n\n    committed_indices = [i for i in range(n) if committed[i]]\n    current_outputs = [p[i] for i in committed_indices]\n    available = [high_bounds[i] - p[i] for i in committed_indices]\n    total_output = sum(current_outputs)\n    deficit = load[0] - total_output\n\n    while deficit > 0 and any(available):\n        min_marginal = float('inf')\n        candidate = -1\n        for pos, i in enumerate(committed_indices):\n            if available[pos] <= 0:\n                continue\n            unit = units_info[i]\n            marg = unit['b_i'] + 2 * unit['c_i'] * current_outputs[pos]\n            if marg < min_marginal:\n                min_marginal = marg\n                candidate = pos\n        if candidate == -1:\n            break\n        increment = min(1.0, available[candidate], deficit)\n        current_outputs[candidate] += increment\n        available[candidate] -= increment\n        deficit -= increment\n\n    for idx, i in enumerate(committed_indices):\n        p[i] = current_outputs[idx]\n\n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.0092,
          "fitness": 0.00739
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced on, forced off, and flexible based on min up/down times and shutdown ramp constraints.\n2. Compute total available capacity from forced-on units considering ramp limits.\n3. If load exceeds forced-on capacity, commit flexible units by ascending order of average cost at minimum output until load is met.\n4. For committed units, set initial output to lower bounds (considering min output and ramp-down limits).\n5. Distribute remaining load to units by ascending marginal cost while respecting ramp-up and max output limits.\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < toff_min:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_min_forced = 0\n    total_max_forced = 0\n    for i in forced_on:\n        unit = units_info[i]\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pdown = unit['p_down_i']\n        pup = unit['p_up_i']\n        lower = max(pmin, p0 - pdown)\n        upper = min(pmax, p0 + pup)\n        total_min_forced += lower\n        total_max_forced += upper\n    \n    online = list(forced_on)\n    if current_load > total_max_forced:\n        def avg_cost(i):\n            u = units_info[i]\n            return (u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2 + u['s_i']) / u['p_min_i']\n        flexible.sort(key=avg_cost)\n        for i in flexible:\n            if total_max_forced >= current_load:\n                break\n            unit = units_info[i]\n            total_max_forced += min(unit['p_max_i'], unit['p_start_i'])\n            online.append(i)\n    \n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    for i in online:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p0 = unit['p_i_0']\n            lower_bounds[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            upper_bounds[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            lower_bounds[i] = unit['p_min_i']\n            upper_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in online:\n        p[i] = lower_bounds[i]\n    total_output = np.sum(p)\n    \n    remaining = current_load - total_output\n    while remaining > 0:\n        candidates = [i for i in online if p[i] < upper_bounds[i]]\n        if not candidates:\n            break\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n        best_idx = candidates[np.argmin(marginal_costs)]\n        increment = min(remaining, upper_bounds[best_idx] - p[best_idx])\n        p[best_idx] += increment\n        remaining -= increment\n    \n    for i in online:\n        u[i] = 1\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00614,
          "gap_price_rate": 0.01074,
          "fitness": 0.00844
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down-time and shutdown capacity constraints.\n2. Calculate power bounds for must-run units considering ramp limits and previous output.\n3. If must-run units exceed current load, adjust their outputs downward within feasible limits.\n4. If must-run units are insufficient, activate flexible units by ascending marginal cost order until load is met.\n5. Adjust unit outputs to exactly match load using proportional distribution within feasible ranges.\n6. Ensure all constraints (ramp, min/max output) are satisfied during allocation.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                flexible.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible.append(idx)\n    \n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    total_min = 0\n    total_max = 0\n    for idx in must_run:\n        u[idx] = 1\n        p_min = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n        p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n        p[idx] = p_min\n        total_min += p_min\n        total_max += p_max\n    \n    remaining_load = current_load - total_min\n    if remaining_load < 0:\n        for idx in must_run:\n            p_min = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            reduction = min(p_min - units_info[idx]['p_min_i'], -remaining_load / len(must_run))\n            p[idx] = p_min - reduction\n            remaining_load += reduction\n            if remaining_load >= 0:\n                break\n    \n    flexible_costs = []\n    for idx in flexible:\n        marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * units_info[idx]['p_max_i']\n        flexible_costs.append((idx, marginal_cost))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    \n    for idx, _ in flexible_costs:\n        if remaining_load <= 0:\n            u[idx] = 0\n            p[idx] = 0\n        else:\n            u[idx] = 1\n            p_min = units_info[idx]['p_min_i']\n            if units_info[idx]['u_i_0'] == 0:\n                p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            else:\n                p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            if remaining_load > p_max - p_min:\n                p[idx] = p_max\n                remaining_load -= (p_max - p_min)\n            else:\n                p[idx] = p_min + remaining_load\n                remaining_load = 0\n    \n    if remaining_load > 0:\n        for idx in must_run:\n            p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            addl = min(p_max - p[idx], remaining_load)\n            p[idx] += addl\n            remaining_load -= addl\n            if remaining_load <= 0:\n                break\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0619,
          "gap_price_rate": 0.16292,
          "fitness": 0.11241
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Initialize schedules with previous states and validate must-run units based on minimum up/down times and shutdown constraints\n2. Calculate power deficits/surpluses considering ramp limits and operational constraints\n3. Sort units by marginal cost (b_i + 2*c_i*p_i) for economic dispatch\n4. Handle power deficit by starting additional units in order of increasing marginal cost\n5. Handle power surplus by shutting down units in order of decreasing marginal cost\n6. Adjust commitment based on next period forecast using look-ahead startup logic\n7. Perform final economic dispatch to meet load exactly while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.array([unit['u_i_0'] for unit in units_info])\n    p = np.array([unit['p_i_0'] for unit in units_info])\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Calculate must-run units\n    must_run = np.zeros(n_units, dtype=bool)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_run[i] = True\n    \n    # Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min[i] = unit['p_min_i']\n            p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Economic dispatch for currently online units\n    committed = u.copy()\n    total_min = np.sum(p_min[u == 1])\n    total_max = np.sum(p_max[u == 1])\n    \n    # Handle deficit\n    if total_max < current_load:\n        deficit = current_load - total_max\n        marginal_costs = []\n        for i in range(n_units):\n            if u[i] == 0 and not must_run[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n                marginal_costs.append((i, mc))\n        marginal_costs.sort(key=lambda x: x[1])\n        \n        for i, mc in marginal_costs:\n            if deficit <= 0:\n                break\n            committed[i] = 1\n            p_min[i] = units_info[i]['p_min_i']\n            p_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            deficit -= p_max[i]\n    \n    # Handle surplus\n    if total_min > current_load:\n        surplus = total_min - current_load\n        marginal_costs = []\n        for i in range(n_units):\n            if u[i] == 1 and not must_run[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n                marginal_costs.append((i, mc))\n        marginal_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, mc in marginal_costs:\n            if surplus <= 0:\n                break\n            if p_min[i] <= units_info[i]['p_shut_i']:\n                committed[i] = 0\n                surplus -= p_min[i]\n    \n    # Look-ahead for next period\n    next_max = 0\n    for i in range(n_units):\n        if committed[i] == 1:\n            next_max += min(units_info[i]['p_max_i'], p_max[i] + units_info[i]['p_up_i'])\n    \n    if next_max < next_load:\n        marginal_costs = []\n        for i in range(n_units):\n            if committed[i] == 0 and not must_run[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n                marginal_costs.append((i, mc))\n        marginal_costs.sort(key=lambda x: x[1])\n        \n        for i, mc in marginal_costs:\n            if next_max >= next_load:\n                break\n            committed[i] = 1\n            next_max += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'] + units_info[i]['p_up_i'])\n    \n    # Final economic dispatch\n    p_out = np.zeros(n_units)\n    available = committed.copy()\n    remaining_load = current_load\n    \n    # Assign minimum power to must-run units\n    for i in range(n_units):\n        if must_run[i] and available[i]:\n            p_out[i] = p_min[i]\n            remaining_load -= p_out[i]\n            available[i] = False\n    \n    # Dispatch remaining load by marginal cost\n    while remaining_load > 1e-6:\n        best_mc = float('inf')\n        best_idx = -1\n        for i in range(n_units):\n            if available[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                if mc < best_mc and p_out[i] < p_max[i]:\n                    best_mc = mc\n                    best_idx = i\n        \n        if best_idx == -1:\n            break\n            \n        delta = min(remaining_load, p_max[best_idx] - p_out[best_idx])\n        p_out[best_idx] += delta\n        remaining_load -= delta\n        \n        if abs(p_out[best_idx] - p_max[best_idx]) < 1e-6:\n            available[best_idx] = False\n    \n    schedules = np.vstack([committed, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.38943,
          "gap_price_rate": 0.22312,
          "fitness": 0.30627
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If load exceeds must-run capacity, commit additional units by ascending marginal cost\n4. Adjust unit outputs to meet load while respecting all constraints\n5. Perform economic dispatch using merit order loading\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    must_run = np.zeros(num_units, dtype=bool)\n    can_run = np.ones(num_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                can_run[i] = False\n    \n    committed = np.where(must_run)[0]\n    available = np.where(can_run & ~must_run)[0]\n    \n    total_min = 0\n    total_max = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    remaining_load = current_load - total_min\n    if remaining_load > 0:\n        marginal_costs = []\n        for i in available:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n            marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for _, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p_avail = p_max - unit['p_min_i']\n            if p_avail > 0:\n                p_add = min(remaining_load, p_avail)\n                remaining_load -= p_add\n                committed = np.append(committed, i)\n    \n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        p[i] = p_min\n        total_output += p_min\n        u[i] = 1\n    \n    remaining_load = current_load - total_output\n    if remaining_load > 0:\n        marginal_costs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            if p[i] < p_max:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for _, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p_avail = p_max - p[i]\n            p_add = min(remaining_load, p_avail)\n            p[i] += p_add\n            remaining_load -= p_add\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.32373,
          "gap_price_rate": 0.33606,
          "fitness": 0.32989
     }
]