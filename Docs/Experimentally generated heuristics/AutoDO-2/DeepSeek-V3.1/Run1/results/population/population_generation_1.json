[
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits\n3. If must-run capacity is insufficient, commit flexible units in ascending order of average cost at maximum output (including startup costs for offline units)\n4. Perform economic dispatch using incremental cost-based load allocation within feasible output ranges\n5. Adjust outputs iteratively to match current load while respecting all constraints\n6. Ensure must-off units remain decommitted with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Precompute feasible output ranges\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            unit['min_feasible'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['min_feasible'] = unit['p_min_i']\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Initialize must-run units\n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['p_i'] = unit['min_feasible']\n    \n    total_capacity = sum(unit['max_feasible'] for unit in must_run)\n    \n    # Commit flexible units if needed\n    if total_capacity < current_load:\n        for unit in flexible:\n            if unit['u_i_0'] == 1:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            else:\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            unit['avg_cost'] = avg_cost\n        \n        flexible.sort(key=lambda x: x['avg_cost'])\n        \n        for unit in flexible:\n            if total_capacity >= current_load:\n                break\n            unit['u_i'] = 1\n            unit['p_i'] = unit['min_feasible']\n            total_capacity += unit['max_feasible']\n    \n    # Economic dispatch\n    committed = [u for u in must_run + flexible if u.get('u_i', 0) == 1]\n    total_output = sum(unit['p_i'] for unit in committed)\n    remaining_load = current_load - total_output\n    \n    while abs(remaining_load) > 1e-6:\n        # Calculate incremental costs\n        for unit in committed:\n            unit['inc_cost'] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n        \n        if remaining_load > 0:\n            # Find unit with lowest incremental cost that can increase output\n            candidate = min([u for u in committed if u['p_i'] < u['max_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_increase = min(remaining_load, candidate['max_feasible'] - candidate['p_i'])\n                candidate['p_i'] += max_increase\n                remaining_load -= max_increase\n            else:\n                break\n        else:\n            # Find unit with highest incremental cost that can decrease output\n            candidate = max([u for u in committed if u['p_i'] > u['min_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_decrease = min(-remaining_load, candidate['p_i'] - candidate['min_feasible'])\n                candidate['p_i'] -= max_decrease\n                remaining_load += max_decrease\n            else:\n                break\n    \n    # Set must-off and non-committed units\n    for unit in must_off + flexible:\n        if unit.get('u_i', 0) == 0:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Prepare output\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit.get('u_i', 0)\n        schedules[1, i] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00565,
          "gap_price_rate": 0.00847,
          "fitness": 0.00706
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Commit must-run units and set to minimum feasible output considering ramp limits\n3. Sort flexible units by average cost per MW at maximum output (including startup cost if applicable)\n4. Commit flexible units in cost order until total maximum capacity meets load\n5. Perform economic dispatch using incremental cost-based allocation within ramp constraints\n6. Adjust outputs iteratively to match load while respecting unit constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    low_bounds = [0] * n\n    high_bounds = [0] * n\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            low_bounds[i] = unit['p_min_i']\n            high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    committed = [False] * n\n    for i in range(n):\n        if must_on[i]:\n            committed[i] = True\n            u[i] = 1\n            p[i] = low_bounds[i]\n        elif must_off[i]:\n            committed[i] = False\n        else:\n            committed[i] = False\n\n    total_max_must = sum(high_bounds[i] for i in range(n) if must_on[i])\n    flexible_units = [i for i in range(n) if not must_on[i] and not must_off[i]]\n    \n    cost_list = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        cost_list.append((cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    current_max = total_max_must\n    for cost, idx in cost_list:\n        if current_max >= load[0]:\n            break\n        committed[idx] = True\n        u[idx] = 1\n        p[idx] = low_bounds[idx]\n        current_max += high_bounds[idx]\n\n    committed_indices = [i for i in range(n) if committed[i]]\n    current_outputs = [p[i] for i in committed_indices]\n    available = [high_bounds[i] - p[i] for i in committed_indices]\n    total_output = sum(current_outputs)\n    deficit = load[0] - total_output\n\n    while deficit > 0 and any(available):\n        min_marginal = float('inf')\n        candidate = -1\n        for pos, i in enumerate(committed_indices):\n            if available[pos] <= 0:\n                continue\n            unit = units_info[i]\n            marg = unit['b_i'] + 2 * unit['c_i'] * current_outputs[pos]\n            if marg < min_marginal:\n                min_marginal = marg\n                candidate = pos\n        if candidate == -1:\n            break\n        increment = min(1.0, available[candidate], deficit)\n        current_outputs[candidate] += increment\n        available[candidate] -= increment\n        deficit -= increment\n\n    for idx, i in enumerate(committed_indices):\n        p[i] = current_outputs[idx]\n\n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.0092,
          "fitness": 0.00739
     },
     {
          "name": "commit_units_improved_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown constraints\n2. Calculate feasible power ranges for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds load, reduce outputs starting with highest marginal cost units\n4. If must-run capacity is insufficient, commit flexible units by ascending average cost (including startup cost)\n5. Perform economic dispatch using incremental cost sorting with ramp-aware adjustment\n6. Ensure exact load matching through iterative proportional adjustment within feasible ranges\n7. Validate and enforce all constraints including startup/shutdown ramp limits\n\n",
          "code": "import numpy as np\n\ndef commit_units_improved_priority(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate must-run capacity\n    total_min_must = 0\n    total_max_must = 0\n    must_run_outputs = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_outputs.append((i, p_min, p_max))\n        total_min_must += p_min\n        total_max_must += p_max\n    \n    # Handle must-run surplus\n    if total_min_must > current_load:\n        deficit = total_min_must - current_load\n        # Sort must-run units by marginal cost descending\n        must_run_sorted = sorted(must_run_outputs, \n                                key=lambda x: units_info[x[0]]['b_i'] + 2*units_info[x[0]]['c_i']*x[1],\n                                reverse=True)\n        \n        for i, p_min, p_max in must_run_sorted:\n            unit = units_info[i]\n            reducible = p_min - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            reduction = min(deficit, reducible)\n            p[i] = p_min - reduction\n            u[i] = 1\n            deficit -= reduction\n            if deficit <= 0:\n                break\n        return np.array([u, p])\n    \n    # Commit flexible units if needed\n    if total_max_must < current_load:\n        deficit = current_load - total_max_must\n        flexible_costs = []\n        \n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                # Include startup cost\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                           unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            else:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                           unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            flexible_costs.append((i, avg_cost))\n        \n        # Sort by average cost\n        flexible_sorted = sorted(flexible_costs, key=lambda x: x[1])\n        \n        for i, cost in flexible_sorted:\n            if deficit <= 0:\n                break\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                p_max = min(p_max, unit['p_start_i'])\n            deficit -= max(0, p_max - (unit['p_i_0'] if unit['u_i_0'] == 1 else 0))\n            u[i] = 1\n    \n    # Economic dispatch\n    committed = must_run + [i for i in flexible if u[i] == 1]\n    # Set initial outputs\n    for i in committed:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        if unit['u_i_0'] == 0:\n            p_min = unit['p_min_i']\n        p[i] = p_min\n        u[i] = 1\n    \n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Adjust outputs\n    while abs(deficit) > 1e-6:\n        # Calculate marginal costs\n        margins = []\n        for i in committed:\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                p_max = min(p_max, unit['p_start_i'])\n            if deficit > 0 and p[i] < p_max:\n                margin = unit['b_i'] + 2*unit['c_i']*p[i]\n                margins.append((i, margin))\n            elif deficit < 0 and p[i] > max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']):\n                margin = unit['b_i'] + 2*unit['c_i']*p[i]\n                margins.append((i, margin))\n        \n        if not margins:\n            break\n            \n        if deficit > 0:\n            i = min(margins, key=lambda x: x[1])[0]\n            p_max = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            if units_info[i]['u_i_0'] == 0:\n                p_max = min(p_max, units_info[i]['p_start_i'])\n            increase = min(deficit, p_max - p[i])\n            p[i] += increase\n            deficit -= increase\n        else:\n            i = max(margins, key=lambda x: x[1])[0]\n            p_min = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            decrease = min(-deficit, p[i] - p_min)\n            p[i] -= decrease\n            deficit += decrease\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00605,
          "gap_price_rate": 0.01044,
          "fitness": 0.00824
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced on, forced off, and flexible based on min up/down times and shutdown ramp constraints.\n2. Compute total available capacity from forced-on units considering ramp limits.\n3. If load exceeds forced-on capacity, commit flexible units by ascending order of average cost at minimum output until load is met.\n4. For committed units, set initial output to lower bounds (considering min output and ramp-down limits).\n5. Distribute remaining load to units by ascending marginal cost while respecting ramp-up and max output limits.\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < toff_min:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_min_forced = 0\n    total_max_forced = 0\n    for i in forced_on:\n        unit = units_info[i]\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pdown = unit['p_down_i']\n        pup = unit['p_up_i']\n        lower = max(pmin, p0 - pdown)\n        upper = min(pmax, p0 + pup)\n        total_min_forced += lower\n        total_max_forced += upper\n    \n    online = list(forced_on)\n    if current_load > total_max_forced:\n        def avg_cost(i):\n            u = units_info[i]\n            return (u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2 + u['s_i']) / u['p_min_i']\n        flexible.sort(key=avg_cost)\n        for i in flexible:\n            if total_max_forced >= current_load:\n                break\n            unit = units_info[i]\n            total_max_forced += min(unit['p_max_i'], unit['p_start_i'])\n            online.append(i)\n    \n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    for i in online:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p0 = unit['p_i_0']\n            lower_bounds[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            upper_bounds[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            lower_bounds[i] = unit['p_min_i']\n            upper_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in online:\n        p[i] = lower_bounds[i]\n    total_output = np.sum(p)\n    \n    remaining = current_load - total_output\n    while remaining > 0:\n        candidates = [i for i in online if p[i] < upper_bounds[i]]\n        if not candidates:\n            break\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n        best_idx = candidates[np.argmin(marginal_costs)]\n        increment = min(remaining, upper_bounds[best_idx] - p[best_idx])\n        p[best_idx] += increment\n        remaining -= increment\n    \n    for i in online:\n        u[i] = 1\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00614,
          "gap_price_rate": 0.01074,
          "fitness": 0.00844
     },
     {
          "name": "commit_units_rolling_improved",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on min up/down times and shutdown ramp constraints\n2. Compute power bounds for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds load, adjust outputs downward using marginal cost order\n4. If must-run capacity is insufficient, commit flexible units by ascending full-load average cost (including startup cost if applicable)\n5. Perform economic dispatch using Lagrangian relaxation with merit order loading\n6. Adjust commitments based on next period forecast using look-ahead startup logic\n7. Ensure all constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_improved(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    avg_cost = np.zeros(n_units)\n    \n    # Precompute unit constraints and costs\n    for i, unit in enumerate(units_info):\n        # Calculate feasible output range\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate costs\n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n        avg_cost[i] = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                      unit['c_i'] * unit['p_max_i']**2 + \n                      (unit['s_i'] if unit['u_i_0'] == 0 else 0)) / unit['p_max_i']\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        elif (unit['u_i_0'] == 0 and \n              (unit['t_i_0'] > -unit['t_off_min_i'] or \n               current_load < unit['p_min_i'])):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize must-run units\n    total_min_capacity = 0\n    total_max_capacity = 0\n    \n    for i in must_run:\n        u[i] = 1\n        p[i] = min_p[i]\n        total_min_capacity += min_p[i]\n        total_max_capacity += max_p[i]\n    \n    # Handle insufficient capacity\n    if total_max_capacity < current_load:\n        # Commit flexible units by average cost\n        flexible.sort(key=lambda i: avg_cost[i])\n        for i in flexible:\n            if total_max_capacity >= current_load:\n                break\n            if units_info[i]['u_i_0'] == 0 and current_load >= units_info[i]['p_min_i']:\n                u[i] = 1\n                p[i] = min_p[i]\n                total_min_capacity += min_p[i]\n                total_max_capacity += max_p[i]\n    \n    # Economic dispatch\n    load_remaining = current_load - total_min_capacity\n    units_to_adjust = [i for i in range(n_units) if u[i] == 1]\n    \n    while load_remaining > 1e-6:\n        # Find unit with minimum marginal cost that can increase output\n        candidate = None\n        min_marginal = float('inf')\n        for i in units_to_adjust:\n            if p[i] < max_p[i] and marginal_cost[i] < min_marginal:\n                min_marginal = marginal_cost[i]\n                candidate = i\n        \n        if candidate is None:\n            break\n        \n        # Calculate possible increase\n        increase = min(max_p[candidate] - p[candidate], \n                      units_info[candidate]['p_up_i'],\n                      load_remaining)\n        p[candidate] += increase\n        load_remaining -= increase\n        marginal_cost[candidate] = (units_info[candidate]['b_i'] + \n                                  2 * units_info[candidate]['c_i'] * p[candidate])\n    \n    # Look-ahead for next period\n    if next_load > current_load * 1.1:\n        # Consider starting additional units\n        for i in flexible:\n            if (u[i] == 0 and next_load >= units_info[i]['p_min_i'] and\n                units_info[i]['t_i_0'] <= -units_info[i]['t_off_min_i']):\n                u[i] = 1\n                p[i] = min_p[i]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.01363,
          "gap_price_rate": 0.01565,
          "fitness": 0.01464
     },
     {
          "name": "commit_units_rolling_heuristic_refined",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown constraints\n2. Set must-run units to minimum feasible output considering ramp limits\n3. If must-run capacity is insufficient, commit flexible units by ascending average cost at max output\n4. Perform economic dispatch using merit order loading with marginal costs\n5. Adjust outputs iteratively to match load while respecting all constraints\n6. Use next period forecast to avoid unnecessary commitments\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic_refined(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, t_i_0, p_i_0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1 and (t_i_0 < t_on_min_i or p_i_0 > p_shut_i):\n            must_run.append(i)\n        elif u_i_0 == 0 and abs(t_i_0) < t_off_min_i:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n            \n    for i in must_run:\n        unit = units_info[i]\n        u[i] = 1\n        p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p[i] = p_low\n        \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    total_output = np.sum(p)\n    remaining_load = current_load - total_output\n    \n    if remaining_load > 0:\n        avg_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + \n                        unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            else:\n                cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + \n                        unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            avg_costs.append((cost, i))\n        \n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, i in avg_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            u[i] = 1\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n            p_add = min(remaining_load, p_high - p_low)\n            p[i] = p_low + p_add\n            remaining_load -= p_add\n            \n    total_output = np.sum(p)\n    remaining_load = current_load - total_output\n    \n    if abs(remaining_load) > 1e-6:\n        marginal_costs = []\n        for i in range(n_units):\n            if u[i] == 1:\n                unit = units_info[i]\n                mc = unit['b_i'] + 2*unit['c_i']*p[i]\n                marginal_costs.append((mc, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        if remaining_load > 0:\n            for mc, i in marginal_costs:\n                unit = units_info[i]\n                p_avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - p[i] if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i']) - p[i]\n                p_add = min(remaining_load, p_avail)\n                p[i] += p_add\n                remaining_load -= p_add\n                if remaining_load <= 0:\n                    break\n        else:\n            for mc, i in reversed(marginal_costs):\n                unit = units_info[i]\n                p_reduce = p[i] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_sub = min(-remaining_load, p_reduce)\n                p[i] -= p_sub\n                remaining_load += p_sub\n                if remaining_load >= 0:\n                    break\n                    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 6e-05,
          "gap_price_rate": 0.09892,
          "fitness": 0.04949
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down-time and shutdown capacity constraints.\n2. Calculate power bounds for must-run units considering ramp limits and previous output.\n3. If must-run units exceed current load, adjust their outputs downward within feasible limits.\n4. If must-run units are insufficient, activate flexible units by ascending marginal cost order until load is met.\n5. Adjust unit outputs to exactly match load using proportional distribution within feasible ranges.\n6. Ensure all constraints (ramp, min/max output) are satisfied during allocation.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                flexible.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible.append(idx)\n    \n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    total_min = 0\n    total_max = 0\n    for idx in must_run:\n        u[idx] = 1\n        p_min = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n        p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n        p[idx] = p_min\n        total_min += p_min\n        total_max += p_max\n    \n    remaining_load = current_load - total_min\n    if remaining_load < 0:\n        for idx in must_run:\n            p_min = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            reduction = min(p_min - units_info[idx]['p_min_i'], -remaining_load / len(must_run))\n            p[idx] = p_min - reduction\n            remaining_load += reduction\n            if remaining_load >= 0:\n                break\n    \n    flexible_costs = []\n    for idx in flexible:\n        marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * units_info[idx]['p_max_i']\n        flexible_costs.append((idx, marginal_cost))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    \n    for idx, _ in flexible_costs:\n        if remaining_load <= 0:\n            u[idx] = 0\n            p[idx] = 0\n        else:\n            u[idx] = 1\n            p_min = units_info[idx]['p_min_i']\n            if units_info[idx]['u_i_0'] == 0:\n                p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            else:\n                p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            if remaining_load > p_max - p_min:\n                p[idx] = p_max\n                remaining_load -= (p_max - p_min)\n            else:\n                p[idx] = p_min + remaining_load\n                remaining_load = 0\n    \n    if remaining_load > 0:\n        for idx in must_run:\n            p_max = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            addl = min(p_max - p[idx], remaining_load)\n            p[idx] += addl\n            remaining_load -= addl\n            if remaining_load <= 0:\n                break\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0619,
          "gap_price_rate": 0.16292,
          "fitness": 0.11241
     },
     {
          "name": "commit_units_rolling_heuristic_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints, considering both current and next period forecast\n2. Commit must-run units and set to minimum feasible output considering ramp limits and startup/shutdown constraints\n3. Sort flexible units by two-period average cost (including startup cost amortized over current and forecasted load)\n4. Commit flexible units in cost order until total capacity meets maximum of current and forecasted load\n5. Perform economic dispatch using merit order loading with incremental cost-based allocation within ramp constraints\n6. Adjust outputs iteratively to match current load exactly while respecting all unit constraints\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic_v2(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Check must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        # Check must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              -unit['t_i_0'] < unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Set must-run units\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        u[i] = 1\n        p[i] = min_p[i]\n    \n    # Calculate must-run capacity\n    must_run_capacity = np.sum(p[must_run])\n    \n    # Commit flexible units if needed\n    if must_run_capacity < current_load:\n        # Calculate two-period average cost\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            avg_cost = (unit['s_i'] + 2*unit['a_i'] + \n                       unit['b_i']*unit['p_max_i'] + \n                       unit['c_i']*unit['p_max_i']**2) / (2 * unit['p_max_i'])\n            costs.append((i, avg_cost))\n        \n        # Sort by average cost\n        costs.sort(key=lambda x: x[1])\n        \n        # Commit until capacity meets max load\n        total_capacity = must_run_capacity\n        for i, _ in costs:\n            if total_capacity >= max(current_load, forecast_load):\n                break\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_capacity += max_p[i]\n            u[i] = 1\n            min_p[i] = unit['p_min_i']\n            p[i] = min_p[i]\n            flexible.remove(i)\n    \n    # Economic dispatch\n    committed = must_run + [i for i in flexible if u[i] == 1]\n    total_min = np.sum(p[committed])\n    remaining_load = current_load - total_min\n    \n    if remaining_load > 0:\n        # Calculate marginal costs\n        marginal_costs = []\n        for i in committed:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*p[i]\n            available = max_p[i] - p[i]\n            marginal_costs.append((i, marginal_cost, available))\n        \n        # Sort by marginal cost\n        marginal_costs.sort(key=lambda x: x[1])\n        \n        # Allocate remaining load\n        for i, mc, available in marginal_costs:\n            if remaining_load <= 0:\n                break\n            allocation = min(available, remaining_load)\n            p[i] += allocation\n            remaining_load -= allocation\n    \n    # Ensure exact load matching\n    total_output = np.sum(p[committed])\n    if abs(total_output - current_load) > 1e-6:\n        # Adjust outputs proportionally\n        ratio = current_load / total_output\n        for i in committed:\n            p[i] *= ratio\n            p[i] = np.clip(p[i], min_p[i], max_p[i])\n    \n    return np.vstack([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.09883,
          "gap_price_rate": 0.16001,
          "fitness": 0.12942
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Initialize schedules with previous states and validate must-run units based on minimum up/down times and shutdown constraints\n2. Calculate power deficits/surpluses considering ramp limits and operational constraints\n3. Sort units by marginal cost (b_i + 2*c_i*p_i) for economic dispatch\n4. Handle power deficit by starting additional units in order of increasing marginal cost\n5. Handle power surplus by shutting down units in order of decreasing marginal cost\n6. Adjust commitment based on next period forecast using look-ahead startup logic\n7. Perform final economic dispatch to meet load exactly while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.array([unit['u_i_0'] for unit in units_info])\n    p = np.array([unit['p_i_0'] for unit in units_info])\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Calculate must-run units\n    must_run = np.zeros(n_units, dtype=bool)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_run[i] = True\n    \n    # Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min[i] = unit['p_min_i']\n            p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Economic dispatch for currently online units\n    committed = u.copy()\n    total_min = np.sum(p_min[u == 1])\n    total_max = np.sum(p_max[u == 1])\n    \n    # Handle deficit\n    if total_max < current_load:\n        deficit = current_load - total_max\n        marginal_costs = []\n        for i in range(n_units):\n            if u[i] == 0 and not must_run[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n                marginal_costs.append((i, mc))\n        marginal_costs.sort(key=lambda x: x[1])\n        \n        for i, mc in marginal_costs:\n            if deficit <= 0:\n                break\n            committed[i] = 1\n            p_min[i] = units_info[i]['p_min_i']\n            p_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            deficit -= p_max[i]\n    \n    # Handle surplus\n    if total_min > current_load:\n        surplus = total_min - current_load\n        marginal_costs = []\n        for i in range(n_units):\n            if u[i] == 1 and not must_run[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n                marginal_costs.append((i, mc))\n        marginal_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, mc in marginal_costs:\n            if surplus <= 0:\n                break\n            if p_min[i] <= units_info[i]['p_shut_i']:\n                committed[i] = 0\n                surplus -= p_min[i]\n    \n    # Look-ahead for next period\n    next_max = 0\n    for i in range(n_units):\n        if committed[i] == 1:\n            next_max += min(units_info[i]['p_max_i'], p_max[i] + units_info[i]['p_up_i'])\n    \n    if next_max < next_load:\n        marginal_costs = []\n        for i in range(n_units):\n            if committed[i] == 0 and not must_run[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n                marginal_costs.append((i, mc))\n        marginal_costs.sort(key=lambda x: x[1])\n        \n        for i, mc in marginal_costs:\n            if next_max >= next_load:\n                break\n            committed[i] = 1\n            next_max += min(units_info[i]['p_max_i'], units_info[i]['p_start_i'] + units_info[i]['p_up_i'])\n    \n    # Final economic dispatch\n    p_out = np.zeros(n_units)\n    available = committed.copy()\n    remaining_load = current_load\n    \n    # Assign minimum power to must-run units\n    for i in range(n_units):\n        if must_run[i] and available[i]:\n            p_out[i] = p_min[i]\n            remaining_load -= p_out[i]\n            available[i] = False\n    \n    # Dispatch remaining load by marginal cost\n    while remaining_load > 1e-6:\n        best_mc = float('inf')\n        best_idx = -1\n        for i in range(n_units):\n            if available[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                if mc < best_mc and p_out[i] < p_max[i]:\n                    best_mc = mc\n                    best_idx = i\n        \n        if best_idx == -1:\n            break\n            \n        delta = min(remaining_load, p_max[best_idx] - p_out[best_idx])\n        p_out[best_idx] += delta\n        remaining_load -= delta\n        \n        if abs(p_out[best_idx] - p_max[best_idx]) < 1e-6:\n            available[best_idx] = False\n    \n    schedules = np.vstack([committed, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.38943,
          "gap_price_rate": 0.22312,
          "fitness": 0.30627
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If load exceeds must-run capacity, commit additional units by ascending marginal cost\n4. Adjust unit outputs to meet load while respecting all constraints\n5. Perform economic dispatch using merit order loading\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    must_run = np.zeros(num_units, dtype=bool)\n    can_run = np.ones(num_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                can_run[i] = False\n    \n    committed = np.where(must_run)[0]\n    available = np.where(can_run & ~must_run)[0]\n    \n    total_min = 0\n    total_max = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    remaining_load = current_load - total_min\n    if remaining_load > 0:\n        marginal_costs = []\n        for i in available:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n            marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for _, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p_avail = p_max - unit['p_min_i']\n            if p_avail > 0:\n                p_add = min(remaining_load, p_avail)\n                remaining_load -= p_add\n                committed = np.append(committed, i)\n    \n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        p[i] = p_min\n        total_output += p_min\n        u[i] = 1\n    \n    remaining_load = current_load - total_output\n    if remaining_load > 0:\n        marginal_costs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            if p[i] < p_max:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for _, i in marginal_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p_avail = p_max - p[i]\n            p_add = min(remaining_load, p_avail)\n            p[i] += p_add\n            remaining_load -= p_add\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.32373,
          "gap_price_rate": 0.33606,
          "fitness": 0.32989
     }
]