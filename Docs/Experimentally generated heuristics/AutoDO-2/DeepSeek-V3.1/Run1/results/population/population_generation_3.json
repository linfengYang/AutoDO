[
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits\n3. If must-run capacity is insufficient, commit flexible units in ascending order of average cost at maximum output (including startup costs for offline units)\n4. Perform economic dispatch using incremental cost-based load allocation within feasible output ranges\n5. Adjust outputs iteratively to match current load while respecting all constraints\n6. Ensure must-off units remain decommitted with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Precompute feasible output ranges\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            unit['min_feasible'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['min_feasible'] = unit['p_min_i']\n            unit['max_feasible'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    # Initialize must-run units\n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['p_i'] = unit['min_feasible']\n    \n    total_capacity = sum(unit['max_feasible'] for unit in must_run)\n    \n    # Commit flexible units if needed\n    if total_capacity < current_load:\n        for unit in flexible:\n            if unit['u_i_0'] == 1:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            else:\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['max_feasible'] + \n                           unit['c_i']*unit['max_feasible']**2) / unit['max_feasible']\n            unit['avg_cost'] = avg_cost\n        \n        flexible.sort(key=lambda x: x['avg_cost'])\n        \n        for unit in flexible:\n            if total_capacity >= current_load:\n                break\n            unit['u_i'] = 1\n            unit['p_i'] = unit['min_feasible']\n            total_capacity += unit['max_feasible']\n    \n    # Economic dispatch\n    committed = [u for u in must_run + flexible if u.get('u_i', 0) == 1]\n    total_output = sum(unit['p_i'] for unit in committed)\n    remaining_load = current_load - total_output\n    \n    while abs(remaining_load) > 1e-6:\n        # Calculate incremental costs\n        for unit in committed:\n            unit['inc_cost'] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n        \n        if remaining_load > 0:\n            # Find unit with lowest incremental cost that can increase output\n            candidate = min([u for u in committed if u['p_i'] < u['max_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_increase = min(remaining_load, candidate['max_feasible'] - candidate['p_i'])\n                candidate['p_i'] += max_increase\n                remaining_load -= max_increase\n            else:\n                break\n        else:\n            # Find unit with highest incremental cost that can decrease output\n            candidate = max([u for u in committed if u['p_i'] > u['min_feasible']], \n                           key=lambda x: x['inc_cost'], default=None)\n            if candidate:\n                max_decrease = min(-remaining_load, candidate['p_i'] - candidate['min_feasible'])\n                candidate['p_i'] -= max_decrease\n                remaining_load += max_decrease\n            else:\n                break\n    \n    # Set must-off and non-committed units\n    for unit in must_off + flexible:\n        if unit.get('u_i', 0) == 0:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Prepare output\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit.get('u_i', 0)\n        schedules[1, i] = unit.get('p_i', 0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00565,
          "gap_price_rate": 0.00847,
          "fitness": 0.00706
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n2. Commit must-run units and set to minimum feasible output considering ramp limits\n3. Sort flexible units by average cost per MW at maximum output (including startup cost if applicable)\n4. Commit flexible units in cost order until total maximum capacity meets load\n5. Perform economic dispatch using incremental cost-based allocation within ramp constraints\n6. Adjust outputs iteratively to match load while respecting unit constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    low_bounds = [0] * n\n    high_bounds = [0] * n\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            low_bounds[i] = unit['p_min_i']\n            high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n\n    committed = [False] * n\n    for i in range(n):\n        if must_on[i]:\n            committed[i] = True\n            u[i] = 1\n            p[i] = low_bounds[i]\n        elif must_off[i]:\n            committed[i] = False\n        else:\n            committed[i] = False\n\n    total_max_must = sum(high_bounds[i] for i in range(n) if must_on[i])\n    flexible_units = [i for i in range(n) if not must_on[i] and not must_off[i]]\n    \n    cost_list = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        cost_list.append((cost, i))\n    \n    cost_list.sort(key=lambda x: x[0])\n    current_max = total_max_must\n    for cost, idx in cost_list:\n        if current_max >= load[0]:\n            break\n        committed[idx] = True\n        u[idx] = 1\n        p[idx] = low_bounds[idx]\n        current_max += high_bounds[idx]\n\n    committed_indices = [i for i in range(n) if committed[i]]\n    current_outputs = [p[i] for i in committed_indices]\n    available = [high_bounds[i] - p[i] for i in committed_indices]\n    total_output = sum(current_outputs)\n    deficit = load[0] - total_output\n\n    while deficit > 0 and any(available):\n        min_marginal = float('inf')\n        candidate = -1\n        for pos, i in enumerate(committed_indices):\n            if available[pos] <= 0:\n                continue\n            unit = units_info[i]\n            marg = unit['b_i'] + 2 * unit['c_i'] * current_outputs[pos]\n            if marg < min_marginal:\n                min_marginal = marg\n                candidate = pos\n        if candidate == -1:\n            break\n        increment = min(1.0, available[candidate], deficit)\n        current_outputs[candidate] += increment\n        available[candidate] -= increment\n        deficit -= increment\n\n    for idx, i in enumerate(committed_indices):\n        p[i] = current_outputs[idx]\n\n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.0092,
          "fitness": 0.00739
     },
     {
          "name": "commit_units_improved_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown constraints\n2. Calculate feasible power ranges for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds load, reduce outputs starting with highest marginal cost units\n4. If must-run capacity is insufficient, commit flexible units by ascending average cost (including startup cost)\n5. Perform economic dispatch using incremental cost sorting with ramp-aware adjustment\n6. Ensure exact load matching through iterative proportional adjustment within feasible ranges\n7. Validate and enforce all constraints including startup/shutdown ramp limits\n\n",
          "code": "import numpy as np\n\ndef commit_units_improved_priority(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate must-run capacity\n    total_min_must = 0\n    total_max_must = 0\n    must_run_outputs = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_outputs.append((i, p_min, p_max))\n        total_min_must += p_min\n        total_max_must += p_max\n    \n    # Handle must-run surplus\n    if total_min_must > current_load:\n        deficit = total_min_must - current_load\n        # Sort must-run units by marginal cost descending\n        must_run_sorted = sorted(must_run_outputs, \n                                key=lambda x: units_info[x[0]]['b_i'] + 2*units_info[x[0]]['c_i']*x[1],\n                                reverse=True)\n        \n        for i, p_min, p_max in must_run_sorted:\n            unit = units_info[i]\n            reducible = p_min - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            reduction = min(deficit, reducible)\n            p[i] = p_min - reduction\n            u[i] = 1\n            deficit -= reduction\n            if deficit <= 0:\n                break\n        return np.array([u, p])\n    \n    # Commit flexible units if needed\n    if total_max_must < current_load:\n        deficit = current_load - total_max_must\n        flexible_costs = []\n        \n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                # Include startup cost\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                           unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            else:\n                avg_cost = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                           unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n            flexible_costs.append((i, avg_cost))\n        \n        # Sort by average cost\n        flexible_sorted = sorted(flexible_costs, key=lambda x: x[1])\n        \n        for i, cost in flexible_sorted:\n            if deficit <= 0:\n                break\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                p_max = min(p_max, unit['p_start_i'])\n            deficit -= max(0, p_max - (unit['p_i_0'] if unit['u_i_0'] == 1 else 0))\n            u[i] = 1\n    \n    # Economic dispatch\n    committed = must_run + [i for i in flexible if u[i] == 1]\n    # Set initial outputs\n    for i in committed:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        if unit['u_i_0'] == 0:\n            p_min = unit['p_min_i']\n        p[i] = p_min\n        u[i] = 1\n    \n    total_output = sum(p)\n    deficit = current_load - total_output\n    \n    # Adjust outputs\n    while abs(deficit) > 1e-6:\n        # Calculate marginal costs\n        margins = []\n        for i in committed:\n            unit = units_info[i]\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:\n                p_max = min(p_max, unit['p_start_i'])\n            if deficit > 0 and p[i] < p_max:\n                margin = unit['b_i'] + 2*unit['c_i']*p[i]\n                margins.append((i, margin))\n            elif deficit < 0 and p[i] > max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']):\n                margin = unit['b_i'] + 2*unit['c_i']*p[i]\n                margins.append((i, margin))\n        \n        if not margins:\n            break\n            \n        if deficit > 0:\n            i = min(margins, key=lambda x: x[1])[0]\n            p_max = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            if units_info[i]['u_i_0'] == 0:\n                p_max = min(p_max, units_info[i]['p_start_i'])\n            increase = min(deficit, p_max - p[i])\n            p[i] += increase\n            deficit -= increase\n        else:\n            i = max(margins, key=lambda x: x[1])[0]\n            p_min = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            decrease = min(-deficit, p[i] - p_min)\n            p[i] -= decrease\n            deficit += decrease\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00605,
          "gap_price_rate": 0.01044,
          "fitness": 0.00824
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced on, forced off, and flexible based on min up/down times and shutdown ramp constraints.\n2. Compute total available capacity from forced-on units considering ramp limits.\n3. If load exceeds forced-on capacity, commit flexible units by ascending order of average cost at minimum output until load is met.\n4. For committed units, set initial output to lower bounds (considering min output and ramp-down limits).\n5. Distribute remaining load to units by ascending marginal cost while respecting ramp-up and max output limits.\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < toff_min:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_min_forced = 0\n    total_max_forced = 0\n    for i in forced_on:\n        unit = units_info[i]\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pdown = unit['p_down_i']\n        pup = unit['p_up_i']\n        lower = max(pmin, p0 - pdown)\n        upper = min(pmax, p0 + pup)\n        total_min_forced += lower\n        total_max_forced += upper\n    \n    online = list(forced_on)\n    if current_load > total_max_forced:\n        def avg_cost(i):\n            u = units_info[i]\n            return (u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2 + u['s_i']) / u['p_min_i']\n        flexible.sort(key=avg_cost)\n        for i in flexible:\n            if total_max_forced >= current_load:\n                break\n            unit = units_info[i]\n            total_max_forced += min(unit['p_max_i'], unit['p_start_i'])\n            online.append(i)\n    \n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    for i in online:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p0 = unit['p_i_0']\n            lower_bounds[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            upper_bounds[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            lower_bounds[i] = unit['p_min_i']\n            upper_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in online:\n        p[i] = lower_bounds[i]\n    total_output = np.sum(p)\n    \n    remaining = current_load - total_output\n    while remaining > 0:\n        candidates = [i for i in online if p[i] < upper_bounds[i]]\n        if not candidates:\n            break\n        marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n        best_idx = candidates[np.argmin(marginal_costs)]\n        increment = min(remaining, upper_bounds[best_idx] - p[best_idx])\n        p[best_idx] += increment\n        remaining -= increment\n    \n    for i in online:\n        u[i] = 1\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00614,
          "gap_price_rate": 0.01074,
          "fitness": 0.00844
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecast\n2. For must-run units, set commitment to 1 and initialize outputs to minimum feasible levels considering ramp limits and startup/shutdown constraints\n3. If must-run capacity is insufficient for current load, commit flexible units in ascending order of two-period average cost (including startup costs amortized over current and forecasted load)\n4. Perform economic dispatch using iterative marginal cost-based allocation within feasible output ranges, respecting all ramp constraints\n5. Adjust outputs proportionally to exactly match current load while maintaining all unit constraints\n6. Validate commitments against next period forecast to avoid unnecessary startups or shutdowns\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize unit states\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    \n    # Precompute feasible ranges and classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        \n        # Calculate feasible output range\n        if u_i_0 == 1:\n            min_feasible[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_feasible[i] = min(p_max_i, p_i_0 + p_up_i)\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            min_feasible[i] = p_min_i\n            max_feasible[i] = min(p_max_i, p_start_i)\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate marginal cost\n        marginal_cost[i] = b_i + 2 * c_i * p_i_0\n    \n    # Set must-run units\n    for i in must_run:\n        u[i] = 1\n        p[i] = min_feasible[i]\n    \n    # Set must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    # Calculate current capacity\n    total_min = np.sum(p[must_run])\n    total_max = np.sum(max_feasible[must_run])\n    \n    # Commit flexible units if needed\n    if current_load > total_max:\n        # Calculate average costs including startup\n        avg_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if units_info[i]['u_i_0'] == 0:\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                        unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            else:\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                        unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n            avg_costs.append((i, cost))\n        \n        # Sort by average cost\n        avg_costs.sort(key=lambda x: x[1])\n        \n        # Commit units until load is met\n        for i, _ in avg_costs:\n            if current_load <= total_max:\n                break\n            u[i] = 1\n            p[i] = min_feasible[i]\n            total_max += max_feasible[i]\n            total_min += min_feasible[i]\n    \n    # Economic dispatch\n    committed = np.where(u == 1)[0]\n    total_output = np.sum(p)\n    \n    # Adjust outputs to match load\n    if total_output < current_load:\n        # Distribute remaining load by marginal cost\n        remaining = current_load - total_output\n        while remaining > 1e-6:\n            # Find unit with lowest marginal cost that can increase output\n            best_unit = None\n            best_cost = float('inf')\n            for i in committed:\n                if p[i] < max_feasible[i]:\n                    cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            # Increase output\n            max_increase = max_feasible[best_unit] - p[best_unit]\n            increase = min(remaining, max_increase)\n            p[best_unit] += increase\n            remaining -= increase\n    \n    elif total_output > current_load:\n        # Reduce output by marginal cost\n        remaining = total_output - current_load\n        while remaining > 1e-6:\n            # Find unit with highest marginal cost that can decrease output\n            best_unit = None\n            best_cost = -float('inf')\n            for i in committed:\n                if p[i] > min_feasible[i]:\n                    cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if cost > best_cost:\n                        best_cost = cost\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            # Decrease output\n            max_decrease = p[best_unit] - min_feasible[best_unit]\n            decrease = min(remaining, max_decrease)\n            p[best_unit] -= decrease\n            remaining -= decrease\n    \n    # Update schedules\n    schedules[0] = u\n    schedules[1] = p\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "commit_units_rolling_improved",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on min up/down times and shutdown ramp constraints\n2. Compute power bounds for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds load, adjust outputs downward using marginal cost order\n4. If must-run capacity is insufficient, commit flexible units by ascending full-load average cost (including startup cost if applicable)\n5. Perform economic dispatch using Lagrangian relaxation with merit order loading\n6. Adjust commitments based on next period forecast using look-ahead startup logic\n7. Ensure all constraints are satisfied through iterative refinement\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_improved(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    avg_cost = np.zeros(n_units)\n    \n    # Precompute unit constraints and costs\n    for i, unit in enumerate(units_info):\n        # Calculate feasible output range\n        if unit['u_i_0'] == 1:\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate costs\n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n        avg_cost[i] = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                      unit['c_i'] * unit['p_max_i']**2 + \n                      (unit['s_i'] if unit['u_i_0'] == 0 else 0)) / unit['p_max_i']\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        elif (unit['u_i_0'] == 0 and \n              (unit['t_i_0'] > -unit['t_off_min_i'] or \n               current_load < unit['p_min_i'])):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize must-run units\n    total_min_capacity = 0\n    total_max_capacity = 0\n    \n    for i in must_run:\n        u[i] = 1\n        p[i] = min_p[i]\n        total_min_capacity += min_p[i]\n        total_max_capacity += max_p[i]\n    \n    # Handle insufficient capacity\n    if total_max_capacity < current_load:\n        # Commit flexible units by average cost\n        flexible.sort(key=lambda i: avg_cost[i])\n        for i in flexible:\n            if total_max_capacity >= current_load:\n                break\n            if units_info[i]['u_i_0'] == 0 and current_load >= units_info[i]['p_min_i']:\n                u[i] = 1\n                p[i] = min_p[i]\n                total_min_capacity += min_p[i]\n                total_max_capacity += max_p[i]\n    \n    # Economic dispatch\n    load_remaining = current_load - total_min_capacity\n    units_to_adjust = [i for i in range(n_units) if u[i] == 1]\n    \n    while load_remaining > 1e-6:\n        # Find unit with minimum marginal cost that can increase output\n        candidate = None\n        min_marginal = float('inf')\n        for i in units_to_adjust:\n            if p[i] < max_p[i] and marginal_cost[i] < min_marginal:\n                min_marginal = marginal_cost[i]\n                candidate = i\n        \n        if candidate is None:\n            break\n        \n        # Calculate possible increase\n        increase = min(max_p[candidate] - p[candidate], \n                      units_info[candidate]['p_up_i'],\n                      load_remaining)\n        p[candidate] += increase\n        load_remaining -= increase\n        marginal_cost[candidate] = (units_info[candidate]['b_i'] + \n                                  2 * units_info[candidate]['c_i'] * p[candidate])\n    \n    # Look-ahead for next period\n    if next_load > current_load * 1.1:\n        # Consider starting additional units\n        for i in flexible:\n            if (u[i] == 0 and next_load >= units_info[i]['p_min_i'] and\n                units_info[i]['t_i_0'] <= -units_info[i]['t_off_min_i']):\n                u[i] = 1\n                p[i] = min_p[i]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.01363,
          "gap_price_rate": 0.01565,
          "fitness": 0.01464
     },
     {
          "name": "refined_adaptive_priority_with_ed",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecasted load\n2. Calculate feasible power bounds for must-run units considering ramp limits, startup/shutdown constraints, and previous outputs\n3. If must-run capacity exceeds current load, adjust outputs downward using marginal cost order while respecting constraints\n4. If must-run capacity is insufficient, commit flexible units using two-period cost analysis with startup cost amortization and incremental cost\u6392\u5e8f\n5. Perform economic dispatch using iterative merit-order loading with incremental cost-based allocation within feasible ranges\n6. Adjust outputs using proportional distribution to exactly match current load while maintaining all constraints\n7. Validate and enforce minimum up/down times and ramp limits during commitment decisions\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_priority_with_ed(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Extract unit parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    min_up = [u['t_on_min_i'] for u in units_info]\n    min_down = [u['t_off_min_i'] for u in units_info]\n    startup_cost = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    # Classify units\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n            elif current_load + next_load > p_max[i] * 0.8:\n                must_run[i] = True\n        else:\n            if t_prev[i] > -min_down[i]:\n                must_off[i] = True\n            elif current_load + next_load < p_min[i] * 1.2:\n                must_off[i] = True\n    \n    # Set must-run and must-off units\n    u[must_run] = 1\n    u[must_off] = 0\n    \n    # Calculate feasible ranges\n    p_low = np.zeros(n_units)\n    p_high = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if u_prev[i] == 1:\n                p_low[i] = max(p_min[i], p_prev[i] - p_down[i])\n                p_high[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                p_low[i] = p_min[i]\n                p_high[i] = min(p_max[i], p_start[i])\n        else:\n            p_low[i] = 0\n            p_high[i] = 0\n    \n    # Check must-run capacity\n    total_min = np.sum(p_low[must_run])\n    total_max = np.sum(p_high[must_run])\n    \n    if total_min > current_load:\n        # Reduce must-run units\n        excess = total_min - current_load\n        committed = np.where(must_run)[0]\n        marginal_costs = [b[i] + 2*c[i]*p_low[i] for i in committed]\n        order = np.argsort(marginal_costs)[::-1]\n        \n        for idx in order:\n            reducible = p_low[idx] - max(p_min[idx], p_prev[idx] - p_down[idx])\n            reduction = min(excess, reducible)\n            p_low[idx] -= reduction\n            excess -= reduction\n            if excess <= 0:\n                break\n                \n    elif total_max < current_load:\n        # Commit flexible units\n        flexible = ~(must_run | must_off)\n        candidates = np.where(flexible)[0]\n        \n        # Calculate two-period cost efficiency\n        cost_eff = []\n        for i in candidates:\n            if u_prev[i] == 0:\n                avg_cost = (startup_cost[i] + a[i] + b[i]*p_max[i] + c[i]*p_max[i]**2) / p_max[i]\n            else:\n                avg_cost = (a[i] + b[i]*p_max[i] + c[i]*p_max[i]**2) / p_max[i]\n            cost_eff.append(avg_cost)\n        \n        # Commit by cost efficiency\n        order = np.argsort(cost_eff)\n        for idx in order:\n            i = candidates[idx]\n            u[i] = 1\n            p_low[i] = p_min[i]\n            p_high[i] = min(p_max[i], p_start[i]) if u_prev[i] == 0 else min(p_max[i], p_prev[i] + p_up[i])\n            total_max += p_high[i]\n            if total_max >= current_load:\n                break\n    \n    # Economic dispatch\n    committed = np.where(u == 1)[0]\n    total_min = np.sum(p_low[committed])\n    total_max = np.sum(p_high[committed])\n    \n    if current_load <= total_min:\n        p[committed] = p_low[committed]\n    elif current_load >= total_max:\n        p[committed] = p_high[committed]\n    else:\n        # Merit-order loading\n        remaining = current_load - total_min\n        inc_costs = []\n        for i in committed:\n            inc_costs.append(b[i] + 2*c[i]*p_low[i])\n        order = np.argsort(inc_costs)\n        \n        for idx in order:\n            i = committed[idx]\n            allocatable = p_high[i] - p_low[i]\n            if remaining <= allocatable:\n                p[i] = p_low[i] + remaining\n                break\n            else:\n                p[i] = p_high[i]\n                remaining -= allocatable\n    \n    # Ensure exact load matching\n    total_p = np.sum(p)\n    if abs(total_p - current_load) > 1e-6:\n        ratio = current_load / total_p\n        for i in committed:\n            new_p = p[i] * ratio\n            if new_p < p_low[i]:\n                p[i] = p_low[i]\n            elif new_p > p_high[i]:\n                p[i] = p_high[i]\n            else:\n                p[i] = new_p\n    \n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00439,
          "gap_price_rate": 0.03894,
          "fitness": 0.02167
     },
     {
          "name": "enhanced_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints, considering both current and next period forecast\n2. Compute feasible power bounds for must-run units considering ramp limits, startup/shutdown constraints, and previous outputs\n3. If must-run capacity exceeds current load, adjust outputs downward using marginal cost order while respecting all constraints\n4. If must-run capacity is insufficient, commit flexible units using two-period cost analysis with startup cost amortization over current and forecasted loads\n5. Perform economic dispatch using iterative marginal cost-based allocation within feasible output ranges\n6. Adjust outputs proportionally to exactly match current load while maintaining all unit constraints\n7. Validate commitments against next period forecast to minimize unnecessary startups/shutdowns\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    categories = ['flexible'] * n_units\n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    \n    # Classify units and compute bounds\n    for i, unit in enumerate(units_info):\n        # Check must-run conditions\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            categories[i] = 'must-run'\n            u[i] = 1\n        # Check must-off conditions\n        elif unit['u_i_0'] == 0 and unit['t_i_0'] > -unit['t_off_min_i']:\n            categories[i] = 'must-off'\n            u[i] = 0\n            p[i] = 0\n        # Flexible units\n        else:\n            u[i] = unit['u_i_0']  # Maintain current state initially\n            \n        # Compute feasible bounds\n        if u[i] == 1:\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['u_i_0'] == 0:  # Just started\n                ub[i] = min(ub[i], unit['p_start_i'])\n        else:\n            lb[i] = 0\n            ub[i] = 0\n    \n    # Calculate must-run capacity\n    must_run_idx = [i for i, cat in enumerate(categories) if cat == 'must-run']\n    total_must_run_max = sum(ub[i] for i in must_run_idx)\n    \n    # Commit flexible units if needed\n    if total_must_run_max < current_load:\n        flexible_idx = [i for i, cat in enumerate(categories) if cat == 'flexible' and u[i] == 0]\n        # Calculate two-period average cost\n        costs = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            avg_output = (current_load + forecast_load) / 2\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * avg_output + unit['c_i'] * avg_output**2 + unit['s_i']) / avg_output\n            costs.append((i, cost_per_mw))\n        # Sort by cost and commit\n        costs.sort(key=lambda x: x[1])\n        for i, _ in costs:\n            if total_must_run_max < current_load:\n                u[i] = 1\n                unit = units_info[i]\n                lb[i] = unit['p_min_i']\n                ub[i] = min(unit['p_max_i'], unit['p_start_i'])\n                total_must_run_max += ub[i]\n            else:\n                break\n    \n    # Economic dispatch\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    # Set initial output to lower bounds\n    for i in committed_idx:\n        p[i] = lb[i]\n    total_output = sum(p[i] for i in committed_idx)\n    \n    # Adjust outputs to match load\n    if total_output < current_load:\n        # Distribute load increase by marginal cost\n        marginals = []\n        for i in committed_idx:\n            unit = units_info[i]\n            marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginals.append((i, marginal))\n        marginals.sort(key=lambda x: x[1])\n        \n        for i, _ in marginals:\n            if total_output >= current_load:\n                break\n            available = ub[i] - p[i]\n            needed = current_load - total_output\n            add = min(available, needed)\n            p[i] += add\n            total_output += add\n    else:\n        # Distribute load decrease by marginal cost (reverse order)\n        marginals = []\n        for i in committed_idx:\n            unit = units_info[i]\n            marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginals.append((i, marginal))\n        marginals.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in marginals:\n            if total_output <= current_load:\n                break\n            reduction = p[i] - lb[i]\n            needed = total_output - current_load\n            deduct = min(reduction, needed)\n            p[i] -= deduct\n            total_output -= deduct\n    \n    # Ensure must-off units are off\n    for i, cat in enumerate(categories):\n        if cat == 'must-off':\n            u[i] = 0\n            p[i] = 0\n            \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 7e-05,
          "gap_price_rate": 0.07629,
          "fitness": 0.03818
     },
     {
          "name": "commit_units_adaptive_priority_refined",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown capacity constraints, considering both current and next period forecast\n2. Calculate feasible power bounds for must-run units considering ramp limits and previous outputs\n3. If must-run capacity exceeds current load, adjust outputs downward starting with highest marginal cost units\n4. If must-run capacity is insufficient, commit flexible units using two-period cost analysis (current + forecast) with startup cost amortization\n5. Perform economic dispatch using incremental cost-based merit order loading within feasible ranges\n6. Adjust outputs iteratively to match current load exactly while respecting all constraints\n7. Validate and enforce minimum up/down times and ramp limits during commitment decisions\n\n",
          "code": "import numpy as np\n\ndef commit_units_adaptive_priority_refined(units_info, load):\n    current_load = load[0]\n    next_forecast = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        u[i] = 1\n        p[i] = p_min\n    \n    total_min = sum(p[i] for i in must_run)\n    total_max = sum(p_max for i in must_run)\n    \n    if total_min >= current_load:\n        excess = total_min - current_load\n        sorted_units = sorted(must_run, key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i], reverse=True)\n        for i in sorted_units:\n            unit = units_info[i]\n            reducible = p[i] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            reduction = min(excess, reducible)\n            p[i] -= reduction\n            excess -= reduction\n            if excess <= 1e-6:\n                break\n    else:\n        deficit = current_load - total_min\n        flexible_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost = (unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2) / p_max\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n                cost = (unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2 + unit['s_i']) / p_max\n            flexible_costs.append((i, cost))\n        \n        flexible_costs.sort(key=lambda x: x[1])\n        committed_flexible = []\n        for i, _ in flexible_costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if deficit > 0 or total_max + p_max < max(current_load, next_forecast):\n                u[i] = 1\n                if unit['u_i_0'] == 1:\n                    p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p[i] = unit['p_min_i']\n                deficit -= p[i]\n                total_max += p_max\n                committed_flexible.append(i)\n        \n        all_committed = must_run + committed_flexible\n        total_output = sum(p[i] for i in all_committed)\n        remaining_load = current_load - total_output\n        \n        if remaining_load > 0:\n            marginal_costs = []\n            for i in all_committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if p[i] < p_max:\n                    mc = unit['b_i'] + 2*unit['c_i']*p[i]\n                    marginal_costs.append((i, mc))\n            \n            marginal_costs.sort(key=lambda x: x[1])\n            for i, mc in marginal_costs:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    available = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - p[i]\n                else:\n                    available = min(unit['p_max_i'], unit['p_start_i']) - p[i]\n                allocation = min(remaining_load, available)\n                p[i] += allocation\n                remaining_load -= allocation\n                if remaining_load <= 1e-6:\n                    break\n        \n        elif remaining_load < 0:\n            remaining_load = abs(remaining_load)\n            marginal_costs = []\n            for i in all_committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_min = unit['p_min_i']\n                if p[i] > p_min:\n                    mc = unit['b_i'] + 2*unit['c_i']*p[i]\n                    marginal_costs.append((i, mc))\n            \n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            for i, mc in marginal_costs:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    reducible = p[i] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    reducible = p[i] - unit['p_min_i']\n                reduction = min(remaining_load, reducible)\n                p[i] -= reduction\n                remaining_load -= reduction\n                if remaining_load <= 1e-6:\n                    break\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.09239,
          "fitness": 0.04623
     },
     {
          "name": "commit_units_rolling_heuristic_refined",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown constraints\n2. Set must-run units to minimum feasible output considering ramp limits\n3. If must-run capacity is insufficient, commit flexible units by ascending average cost at max output\n4. Perform economic dispatch using merit order loading with marginal costs\n5. Adjust outputs iteratively to match load while respecting all constraints\n6. Use next period forecast to avoid unnecessary commitments\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic_refined(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, t_i_0, p_i_0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1 and (t_i_0 < t_on_min_i or p_i_0 > p_shut_i):\n            must_run.append(i)\n        elif u_i_0 == 0 and abs(t_i_0) < t_off_min_i:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n            \n    for i in must_run:\n        unit = units_info[i]\n        u[i] = 1\n        p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p[i] = p_low\n        \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    total_output = np.sum(p)\n    remaining_load = current_load - total_output\n    \n    if remaining_load > 0:\n        avg_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + \n                        unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            else:\n                cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + \n                        unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            avg_costs.append((cost, i))\n        \n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, i in avg_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            u[i] = 1\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n            p_add = min(remaining_load, p_high - p_low)\n            p[i] = p_low + p_add\n            remaining_load -= p_add\n            \n    total_output = np.sum(p)\n    remaining_load = current_load - total_output\n    \n    if abs(remaining_load) > 1e-6:\n        marginal_costs = []\n        for i in range(n_units):\n            if u[i] == 1:\n                unit = units_info[i]\n                mc = unit['b_i'] + 2*unit['c_i']*p[i]\n                marginal_costs.append((mc, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        if remaining_load > 0:\n            for mc, i in marginal_costs:\n                unit = units_info[i]\n                p_avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - p[i] if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i']) - p[i]\n                p_add = min(remaining_load, p_avail)\n                p[i] += p_add\n                remaining_load -= p_add\n                if remaining_load <= 0:\n                    break\n        else:\n            for mc, i in reversed(marginal_costs):\n                unit = units_info[i]\n                p_reduce = p[i] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_sub = min(-remaining_load, p_reduce)\n                p[i] -= p_sub\n                remaining_load += p_sub\n                if remaining_load >= 0:\n                    break\n                    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 6e-05,
          "gap_price_rate": 0.09892,
          "fitness": 0.04949
     }
]