[
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints, with enhanced forecast-aware adjustment\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If current load exceeds must-run capacity, commit flexible units by two-period effective cost including startup costs and forecasted load\n4. Perform economic dispatch using marginal cost sorting within feasible output ranges\n5. Fine-tune outputs using proportional adjustment based on ramp capabilities\n6. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, p_start_i)\n        \n        must_run_min += min_out\n        must_run_max += max_out\n    \n    if current_load <= must_run_min:\n        for i in must_run:\n            unit = units_info[i]\n            u_i_0 = unit['u_i_0']\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_down_i = unit['p_down_i']\n            \n            if u_i_0 == 1:\n                p[i] = max(p_min_i, p_i_0 - p_down_i)\n            else:\n                p[i] = p_min_i\n            u[i] = 1\n        for i in flexible + must_off:\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    adjusted_load = (current_load + next_load) / 2\n    flexible_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        s_i = unit['s_i']\n        \n        mid_i = (p_min_i + p_max_i) / 2\n        cost_current = a_i + b_i * mid_i + c_i * mid_i ** 2\n        cost_next = a_i + b_i * mid_i + c_i * mid_i ** 2\n        total_cost = cost_current + cost_next + s_i * (1 - u_i_0)\n        effective_cost = total_cost / (2 * mid_i)\n        flexible_costs.append((i, effective_cost))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    committed_flexible = []\n    total_capacity = must_run_max\n    for i, _ in flexible_costs:\n        unit = units_info[i]\n        p_max_i = unit['p_max_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        \n        max_out = p_max_i if u_i_0 == 1 else min(p_max_i, p_start_i)\n        if total_capacity < adjusted_load:\n            committed_flexible.append(i)\n            total_capacity += max_out\n        else:\n            break\n    \n    committed_units = must_run + committed_flexible\n    for i in committed_units:\n        u[i] = 1\n    \n    min_outs = []\n    max_outs = []\n    for i in committed_units:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, p_start_i)\n        \n        min_outs.append(min_out)\n        max_outs.append(max_out)\n    \n    total_min = sum(min_outs)\n    total_max = sum(max_outs)\n    \n    if current_load < total_min:\n        for idx, i in enumerate(committed_units):\n            p[i] = min_outs[idx]\n        for i in set(range(n_units)) - set(committed_units):\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    if current_load > total_max:\n        for idx, i in enumerate(committed_units):\n            p[i] = max_outs[idx]\n        for i in set(range(n_units)) - set(committed_units):\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    margins = [current_load - total_min, total_max - current_load]\n    if margins[0] <= margins[1]:\n        p_vals = min_outs.copy()\n        remaining = current_load - total_min\n        unit_indices = list(range(len(committed_units)))\n        while remaining > 0:\n            best_cost = float('inf')\n            best_idx = None\n            for idx in unit_indices:\n                i = committed_units[idx]\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                current_p = p_vals[idx]\n                if current_p < max_outs[idx]:\n                    marginal_cost = b_i + 2 * c_i * current_p\n                    if marginal_cost < best_cost:\n                        best_cost = marginal_cost\n                        best_idx = idx\n            if best_idx is None:\n                break\n            i = committed_units[best_idx]\n            unit = units_info[i]\n            p_up_i = unit['p_up_i']\n            available = min(max_outs[best_idx] - p_vals[best_idx], p_up_i)\n            add = min(available, remaining)\n            p_vals[best_idx] += add\n            remaining -= add\n            if p_vals[best_idx] >= max_outs[best_idx]:\n                unit_indices.remove(best_idx)\n        for idx, i in enumerate(committed_units):\n            p[i] = p_vals[idx]\n    else:\n        p_vals = max_outs.copy()\n        excess = total_max - current_load\n        unit_indices = list(range(len(committed_units)))\n        while excess > 0:\n            worst_cost = -float('inf')\n            worst_idx = None\n            for idx in unit_indices:\n                i = committed_units[idx]\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                current_p = p_vals[idx]\n                if current_p > min_outs[idx]:\n                    marginal_cost = b_i + 2 * c_i * current_p\n                    if marginal_cost > worst_cost:\n                        worst_cost = marginal_cost\n                        worst_idx = idx\n            if worst_idx is None:\n                break\n            i = committed_units[worst_idx]\n            unit = units_info[i]\n            p_down_i = unit['p_down_i']\n            reduce_by = min(p_vals[worst_idx] - min_outs[worst_idx], p_down_i, excess)\n            p_vals[worst_idx] -= reduce_by\n            excess -= reduce_by\n            if p_vals[worst_idx] <= min_outs[worst_idx]:\n                unit_indices.remove(worst_idx)\n        for idx, i in enumerate(committed_units):\n            p[i] = p_vals[idx]\n    \n    for i in set(range(n_units)) - set(committed_units):\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0019652318,
          "gap_price_rate": 0.0086160879,
          "fitness": 0.0052906598
     },
     {
          "name": "enhanced_forecast_aware_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced forecast-aware minimum up/down time constraints with two-period lookahead and shutdown ramp constraints\n2. Calculate must-run output range considering ramp constraints, previous states, and forecasted load for flexibility adjustment\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units using two-period effective cost with startup costs and forecast-aware output estimation\n5. Perform economic dispatch using adaptive lambda iteration with ramp-constrained feasible ranges\n6. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n7. Handle infeasible cases by forecast-aware generation optimization with priority-based constraint relaxation\n\n",
          "code": "import numpy as np\n\ndef enhanced_forecast_aware_commitment(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, t_i_0, p_i_0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        low = max(p_min_i, p_i_0 - p_down_i)\n        high = min(p_max_i, p_i_0 + p_up_i)\n        must_run_min += low\n        must_run_max += high\n    \n    if current_load <= must_run_min:\n        for i in must_run:\n            unit = units_info[i]\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_down_i = unit['p_down_i']\n            p[i] = max(p_min_i, p_i_0 - p_down_i)\n            u[i] = 1\n        for i in flexible + must_off:\n            u[i] = 0\n            p[i] = 0\n    else:\n        committed = set(must_run)\n        if current_load > must_run_max:\n            flex_costs = []\n            for i in flexible:\n                unit = units_info[i]\n                a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n                s_i = unit['s_i']\n                p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n                avg_p = (p_min_i + p_max_i) / 2\n                if unit['u_i_0'] == 0:\n                    cost_per_mw = (s_i/2 + a_i + b_i*avg_p + c_i*avg_p**2) / avg_p\n                else:\n                    cost_per_mw = (a_i + b_i*avg_p + c_i*avg_p**2) / avg_p\n                flex_costs.append((cost_per_mw, i))\n            \n            flex_costs.sort(key=lambda x: x[0])\n            additional_capacity = 0\n            for cost, i in flex_costs:\n                if additional_capacity + must_run_max >= current_load:\n                    break\n                unit = units_info[i]\n                p_i_0 = unit['p_i_0']\n                p_max_i = unit['p_max_i']\n                p_up_i = unit['p_up_i']\n                p_start_i = unit['p_start_i']\n                if unit['u_i_0'] == 0:\n                    high = min(p_max_i, p_start_i)\n                else:\n                    high = min(p_max_i, p_i_0 + p_up_i)\n                additional_capacity += high\n                committed.add(i)\n        \n        low_bounds = []\n        high_bounds = []\n        b_vec = []\n        c_vec = []\n        committed_list = list(committed)\n        for i in committed_list:\n            unit = units_info[i]\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            if unit['u_i_0'] == 0:\n                low = p_min_i\n                high = min(p_max_i, p_start_i)\n            else:\n                low = max(p_min_i, p_i_0 - p_down_i)\n                high = min(p_max_i, p_i_0 + p_up_i)\n            \n            low_bounds.append(low)\n            high_bounds.append(high)\n            b_vec.append(unit['b_i'])\n            c_vec.append(unit['c_i'])\n        \n        low_bounds = np.array(low_bounds)\n        high_bounds = np.array(high_bounds)\n        b_vec = np.array(b_vec)\n        c_vec = np.array(c_vec)\n        \n        lambda_low = min(b_vec + 2 * c_vec * low_bounds)\n        lambda_high = max(b_vec + 2 * c_vec * high_bounds)\n        \n        for _ in range(50):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_alloc = (lambda_mid - b_vec) / (2 * c_vec)\n            p_alloc = np.clip(p_alloc, low_bounds, high_bounds)\n            total_p = np.sum(p_alloc)\n            \n            if abs(total_p - current_load) < 1e-5:\n                break\n            elif total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        for idx, i in enumerate(committed_list):\n            p[i] = p_alloc[idx]\n            u[i] = 1\n        \n        total_output = np.sum(p)\n        if abs(total_output - current_load) > 1e-5:\n            diff = current_load - total_output\n            flexible_units = [i for i in committed_list if high_bounds[committed_list.index(i)] - p[i] > 1e-5 or p[i] - low_bounds[committed_list.index(i)] > 1e-5]\n            if not flexible_units:\n                flexible_units = committed_list\n            \n            while abs(diff) > 1e-5 and flexible_units:\n                adjustment = diff / len(flexible_units)\n                new_diff = 0\n                to_remove = []\n                for i in flexible_units:\n                    idx = committed_list.index(i)\n                    new_p = p[i] + adjustment\n                    if new_p < low_bounds[idx]:\n                        new_p = low_bounds[idx]\n                    elif new_p > high_bounds[idx]:\n                        new_p = high_bounds[idx]\n                    actual_adjustment = new_p - p[i]\n                    p[i] = new_p\n                    new_diff += actual_adjustment\n                    if abs(actual_adjustment - adjustment) > 1e-5:\n                        to_remove.append(i)\n                \n                for i in to_remove:\n                    flexible_units.remove(i)\n                diff -= new_diff\n        \n        for i in range(n_units):\n            if i not in committed:\n                u[i] = 0\n                p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0052930892,
          "gap_price_rate": 0.0078677213,
          "fitness": 0.0065804053
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced forecast-aware minimum up/down time and shutdown ramp constraints with two-period lookahead\n2. Calculate must-run output range with ramp constraints and previous states, incorporating forecasted load for flexibility adjustment\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units using three-period effective cost with startup costs and forecast-aware output estimation\n5. Perform economic dispatch using adaptive lambda iteration with ramp-constrained feasible ranges and forecast-aware load distribution\n6. Fine-tune outputs using constrained gradient-based adjustment to exactly match load while respecting all constraints\n7. Handle infeasible cases by forecast-aware generation optimization with priority-based constraint relaxation\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if abs(t0) < toff_min:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            p0 = unit['p_i_0']\n            pmin = unit['p_min_i']\n            pmax = unit['p_max_i']\n            pdown = unit['p_down_i']\n            pup = unit['p_up_i']\n            low = max(pmin, p0 - pdown)\n            high = min(pmax, p0 + pup)\n            must_run_min += low\n            must_run_max += high\n    \n    if current_load <= must_run_min:\n        for i, unit in enumerate(units_info):\n            if must_run[i]:\n                p0 = unit['p_i_0']\n                pmin = unit['p_min_i']\n                pdown = unit['p_down_i']\n                p[i] = max(pmin, p0 - pdown)\n                u[i] = 1\n        return np.array([u, p])\n    \n    required = current_load - must_run_max\n    if required > 0:\n        flex_units = []\n        for i, unit in enumerate(units_info):\n            if flexible[i] and not must_off[i]:\n                flex_units.append((i, unit))\n        \n        costs = []\n        for idx, unit in flex_units:\n            a = unit['a_i']\n            b_val = unit['b_i']\n            c_val = unit['c_i']\n            s = unit['s_i']\n            pmin = unit['p_min_i']\n            pmax = unit['p_max_i']\n            pstart = unit['p_start_i']\n            u0 = unit['u_i_0']\n            p0 = unit['p_i_0']\n            pup = unit['p_up_i']\n            pdown = unit['p_down_i']\n            \n            if u0 == 1:\n                low_curr = max(pmin, p0 - pdown)\n                high_curr = min(pmax, p0 + pup)\n                mid_curr = (low_curr + high_curr) / 2\n                cost_curr = a + b_val * mid_curr + c_val * mid_curr ** 2\n                mid_next = (pmin + pmax) / 2\n                cost_next = a + b_val * mid_next + c_val * mid_next ** 2\n                total_energy = mid_curr + mid_next\n                effective_cost = (cost_curr + cost_next) / total_energy\n            else:\n                low_curr = pmin\n                high_curr = min(pmax, pstart)\n                mid_curr = (low_curr + high_curr) / 2\n                cost_curr = a + b_val * mid_curr + c_val * mid_curr ** 2\n                mid_next = (pmin + pmax) / 2\n                cost_next = a + b_val * mid_next + c_val * mid_next ** 2\n                total_energy = mid_curr + mid_next\n                effective_cost = (s + cost_curr + cost_next) / total_energy\n            costs.append((idx, effective_cost))\n        \n        costs.sort(key=lambda x: x[1])\n        committed_flex = []\n        total_added = 0\n        for idx, _ in costs:\n            unit = units_info[idx]\n            u0 = unit['u_i_0']\n            p0 = unit['p_i_0']\n            pmax = unit['p_max_i']\n            pup = unit['p_up_i']\n            pstart = unit['p_start_i']\n            if u0 == 1:\n                avail = min(pmax, p0 + pup)\n            else:\n                avail = min(pmax, pstart)\n            if total_added < required:\n                committed_flex.append(idx)\n                total_added += avail\n            else:\n                break\n        \n        committed_indices = list(np.where(must_run)[0]) + committed_flex\n    else:\n        committed_indices = list(np.where(must_run)[0])\n    \n    low_bounds = []\n    high_bounds = []\n    b_vals = []\n    c_vals = []\n    committed_units = [units_info[i] for i in committed_indices]\n    \n    for unit in committed_units:\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        \n        if u0 == 1:\n            low = max(pmin, p0 - pdown)\n            high = min(pmax, p0 + pup)\n        else:\n            low = pmin\n            high = min(pmax, pstart)\n        low_bounds.append(low)\n        high_bounds.append(high)\n        b_vals.append(unit['b_i'])\n        c_vals.append(unit['c_i'])\n    \n    low_bounds = np.array(low_bounds)\n    high_bounds = np.array(high_bounds)\n    b_vals = np.array(b_vals)\n    c_vals = np.array(c_vals)\n    \n    lambda_low = np.min(b_vals + 2 * c_vals * low_bounds)\n    lambda_high = np.max(b_vals + 2 * c_vals * high_bounds)\n    \n    tol = 1e-5\n    max_iter = 100\n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_dispatch = (lambda_mid - b_vals) / (2 * c_vals)\n        p_dispatch = np.clip(p_dispatch, low_bounds, high_bounds)\n        total_gen = np.sum(p_dispatch)\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    for idx, p_val in zip(committed_indices, p_dispatch):\n        p[idx] = p_val\n        u[idx] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0050066465,
          "gap_price_rate": 0.0085241179,
          "fitness": 0.0067653822
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp limits\n2. Calculate total output range from must-run units\n3. If load is below must-run minimum, set must-run units to minimum output\n4. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs\n5. Perform economic dispatch among committed units using marginal cost sorting\n6. Adjust outputs to meet load exactly while respecting ramp constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    \n    allowable_min = np.zeros(n_units)\n    allowable_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            allowable_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            allowable_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            allowable_min[i] = unit['p_min_i']\n            allowable_max[i] = unit['p_start_i']\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    total_min = np.sum(allowable_min[must_run])\n    total_max = np.sum(allowable_max[must_run])\n    \n    if current_load <= total_min:\n        u[must_run] = 1\n        p[must_run] = allowable_min[must_run]\n    else:\n        u[must_run] = 1\n        p[must_run] = allowable_max[must_run]\n        remaining_load = current_load - total_max\n        \n        flexible_idx = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n        cost_rates = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            cost_rates.append((cost / allowable_max[i], i))\n        \n        cost_rates.sort(key=lambda x: x[0])\n        for _, idx in cost_rates:\n            if remaining_load <= 0:\n                break\n            u[idx] = 1\n            alloc = min(remaining_load, allowable_max[idx])\n            p[idx] = alloc\n            remaining_load -= alloc\n\n    committed = np.where(u == 1)[0]\n    for i in committed:\n        p[i] = allowable_min[i]\n    \n    total_output = np.sum(p)\n    while abs(total_output - current_load) > 1e-6:\n        if total_output < current_load:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < allowable_max[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(current_load - total_output, allowable_max[candidate] - p[candidate])\n            p[candidate] += increase\n            total_output += increase\n        else:\n            candidate = -1\n            max_mc = -float('inf')\n            for i in committed:\n                if p[i] > allowable_min[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            decrease = min(total_output - current_load, p[candidate] - allowable_min[candidate])\n            p[candidate] -= decrease\n            total_output -= decrease\n\n    return np.vstack((u, p))",
          "from": null,
          "gap_power_rate": 0.0056459616,
          "gap_price_rate": 0.00847472,
          "fitness": 0.0070603408
     },
     {
          "name": "enhanced_rolling_commitment_v4",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using forecast-aware minimum up/down time constraints with two-period lookahead and shutdown ramp constraints\n2. Calculate must-run output range considering ramp constraints, previous states, and forecasted load for flexibility adjustment\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units using three-period effective cost with startup costs and forecast-aware output estimation\n5. Perform economic dispatch using adaptive lambda iteration with ramp-constrained feasible ranges and forecast-aware load distribution\n6. Fine-tune outputs using constrained gradient-based adjustment to exactly match load while respecting all constraints\n7. Handle infeasible cases by forecast-aware generation optimization with priority-based constraint relaxation\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v4(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -t_i0 < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_i0 = unit['p_i_0']\n        \n        min_out = max(p_min, p_i0 - p_down)\n        max_out = min(p_max, p_i0 + p_up)\n        must_run_min += min_out\n        must_run_max += max_out\n    \n    if current_load <= must_run_min:\n        for i in must_run:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_down = unit['p_down_i']\n            p_i0 = unit['p_i_0']\n            p[i] = max(p_min, p_i0 - p_down)\n            u[i] = 1\n        return np.array([u, p])\n    \n    committed = set(must_run)\n    remaining_load = current_load - must_run_max\n    \n    if remaining_load > 0:\n        flexible_costs = []\n        for i in flexible:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            s = unit['s_i']\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            p_up = unit['p_up_i']\n            u_i0 = unit['u_i_0']\n            p_i0 = unit['p_i_0']\n            \n            if u_i0 == 1:\n                max_out = min(p_max, p_i0 + p_up)\n                min_out = max(p_min, p_i0 - p_down)\n            else:\n                max_out = min(p_max, p_start)\n                min_out = p_min\n            \n            mid_out = (min_out + max_out) / 2\n            cost_per_mw = (a + b * mid_out + c * mid_out**2) / mid_out\n            if u_i0 == 0:\n                cost_per_mw += s / (2 * mid_out)\n            \n            flexible_costs.append((cost_per_mw, i, max_out))\n        \n        flexible_costs.sort(key=lambda x: x[0])\n        \n        for cost, i, max_out in flexible_costs:\n            if remaining_load <= 0:\n                break\n            committed.add(i)\n            remaining_load -= max_out\n    \n    committed = list(committed)\n    min_limits = []\n    max_limits = []\n    b_coeffs = []\n    c_coeffs = []\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        \n        if u_i0 == 1:\n            min_out = max(p_min, p_i0 - p_down)\n            max_out = min(p_max, p_i0 + p_up)\n        else:\n            min_out = p_min\n            max_out = min(p_max, p_start)\n        \n        min_limits.append(min_out)\n        max_limits.append(max_out)\n        b_coeffs.append(unit['b_i'])\n        c_coeffs.append(unit['c_i'])\n    \n    low = min([b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits)])\n    high = max([b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits)])\n    \n    for _ in range(100):\n        lambda_val = (low + high) / 2\n        total_p = 0\n        for i in range(len(committed)):\n            b = b_coeffs[i]\n            c = c_coeffs[i]\n            p_val = (lambda_val - b) / (2 * c)\n            p_val = np.clip(p_val, min_limits[i], max_limits[i])\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-5:\n            break\n        elif total_p < current_load:\n            low = lambda_val\n        else:\n            high = lambda_val\n    \n    for i, idx in enumerate(committed):\n        b = b_coeffs[i]\n        c = c_coeffs[i]\n        p_val = (lambda_val - b) / (2 * c)\n        p_val = np.clip(p_val, min_limits[i], max_limits[i])\n        p[idx] = p_val\n        u[idx] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.005468458,
          "gap_price_rate": 0.0087490178,
          "fitness": 0.0071087379
     },
     {
          "name": "novel_enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced forecast-aware minimum up/down time and shutdown ramp constraints with two-period lookahead\n2. Calculate must-run output range with ramp constraints and previous states, incorporating forecasted load for flexibility adjustment\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units using three-period effective cost with startup costs and forecast-aware output estimation\n5. Perform economic dispatch using adaptive lambda iteration with ramp-constrained feasible ranges and forecast-aware load distribution\n6. Fine-tune outputs using constrained gradient-based adjustment to exactly match load while respecting all constraints\n7. Handle infeasible cases by forecast-aware generation optimization with priority-based constraint relaxation\n\n",
          "code": "import numpy as np\n\ndef novel_enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    \n    # Initialize arrays for commitment and output\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible output range based on previous state and ramp limits\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check must-run conditions\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n            # Check must-off conditions\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        min_outputs[i] = min_output\n        max_outputs[i] = max_output\n    \n    # Calculate must-run capacity\n    must_run_min = sum(min_outputs[i] for i in must_run)\n    must_run_max = sum(max_outputs[i] for i in must_run)\n    \n    # Case 1: Load below must-run minimum\n    if current_load <= must_run_min:\n        for i in must_run:\n            u[i] = 1\n            p[i] = min_outputs[i]\n        for i in flexible + must_off:\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    # Case 2: Load within must-run capacity\n    if current_load <= must_run_max:\n        for i in must_run:\n            u[i] = 1\n        for i in flexible + must_off:\n            u[i] = 0\n            p[i] = 0\n        \n        # Economic dispatch for must-run units\n        committed_indices = must_run\n        total_output = must_run_min\n        p_temp = np.array([min_outputs[i] for i in committed_indices])\n        \n        # Adaptive lambda iteration\n        lambda_low = 0\n        lambda_high = 10000  # Sufficiently high initial value\n        \n        for _ in range(100):  # Maximum iterations\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                p_target = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_temp[idx] = np.clip(p_target, min_outputs[i], max_outputs[i])\n                total_gen += p_temp[idx]\n            \n            if abs(total_gen - current_load) < 1e-5:\n                break\n            elif total_gen < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Assign optimized outputs\n        for idx, i in enumerate(committed_indices):\n            p[i] = p_temp[idx]\n        \n        return np.array([u, p])\n    \n    # Case 3: Load exceeds must-run capacity\n    # Commit flexible units based on three-period effective cost\n    flexible_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        # Estimate output over three periods\n        avg_output = (min_outputs[i] + max_outputs[i]) / 2\n        cost_per_mw = (unit['a_i'] + unit['b_i'] * avg_output + \n                      unit['c_i'] * avg_output**2 + unit['s_i'] / 3) / avg_output\n        flexible_costs.append((i, cost_per_mw))\n    \n    # Sort by cost and commit until capacity meets load\n    flexible_costs.sort(key=lambda x: x[1])\n    committed_flexible = []\n    total_capacity = must_run_max\n    \n    for i, cost in flexible_costs:\n        if total_capacity >= current_load:\n            break\n        committed_flexible.append(i)\n        total_capacity += max_outputs[i]\n    \n    # Update commitment status\n    for i in must_run:\n        u[i] = 1\n    for i in committed_flexible:\n        u[i] = 1\n    for i in set(flexible) - set(committed_flexible) | set(must_off):\n        u[i] = 0\n        p[i] = 0\n    \n    # Economic dispatch for all committed units\n    committed_indices = must_run + committed_flexible\n    total_min = sum(min_outputs[i] for i in committed_indices)\n    total_max = sum(max_outputs[i] for i in committed_indices)\n    \n    if current_load <= total_min:\n        for i in committed_indices:\n            p[i] = min_outputs[i]\n        return np.array([u, p])\n    if current_load >= total_max:\n        for i in committed_indices:\n            p[i] = max_outputs[i]\n        return np.array([u, p])\n    \n    # Adaptive lambda iteration with ramp constraints\n    lambda_low = 0\n    lambda_high = 10000\n    p_temp = np.array([min_outputs[i] for i in committed_indices])\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        for idx, i in enumerate(committed_indices):\n            unit = units_info[i]\n            p_target = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_temp[idx] = np.clip(p_target, min_outputs[i], max_outputs[i])\n            total_gen += p_temp[idx]\n        \n        if abs(total_gen - current_load) < 1e-5:\n            break\n        elif total_gen < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Fine-tuning with gradient-based adjustment\n    error = current_load - total_gen\n    while abs(error) > 1e-5:\n        # Calculate marginal costs\n        marginal_costs = []\n        for idx, i in enumerate(committed_indices):\n            unit = units_info[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * p_temp[idx]\n            marginal_costs.append((idx, mc))\n        \n        # Sort by marginal cost\n        if error > 0:\n            # Need to increase output: select units with lowest marginal cost\n            marginal_costs.sort(key=lambda x: x[1])\n        else:\n            # Need to decrease output: select units with highest marginal cost\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        # Adjust output of most suitable unit\n        adjusted = False\n        for idx, mc in marginal_costs:\n            i = committed_indices[idx]\n            if error > 0 and p_temp[idx] < max_outputs[i]:\n                adjustment = min(error, max_outputs[i] - p_temp[idx])\n                p_temp[idx] += adjustment\n                error -= adjustment\n                adjusted = True\n                break\n            elif error < 0 and p_temp[idx] > min_outputs[i]:\n                adjustment = max(error, min_outputs[i] - p_temp[idx])\n                p_temp[idx] += adjustment\n                error -= adjustment\n                adjusted = True\n                break\n        \n        if not adjusted:\n            break\n    \n    # Assign final outputs\n    for idx, i in enumerate(committed_indices):\n        p[i] = p_temp[idx]\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0054684581,
          "gap_price_rate": 0.0089641999,
          "fitness": 0.007216329
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using forecast-aware minimum up/down time and shutdown ramp constraints with two-period lookahead\n2. Calculate must-run output range considering ramp constraints and previous states, incorporating forecasted load for flexibility adjustment\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units using three-period effective cost with startup costs and forecast-aware output estimation\n5. Perform economic dispatch using adaptive lambda iteration with ramp-constrained feasible ranges and forecast-aware load distribution\n6. Fine-tune outputs using constrained gradient-based adjustment to exactly match load while respecting all constraints\n7. Handle infeasible cases by forecast-aware generation optimization with priority-based constraint relaxation\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    current_load, forecast_load = load\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if (u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])):\n            must_run.append(i)\n        # Must-off conditions\n        elif (u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Calculate must-run output range\n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_min += p_min\n        must_run_max += p_max\n    \n    # Handle load scenarios\n    if current_load <= must_run_min:\n        for i in must_run:\n            unit = units_info[i]\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            schedules[0,i] = 1\n            schedules[1,i] = p_min\n        return schedules\n    \n    # Commit flexible units\n    flexible_units = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            # Calculate effective cost including startup\n            avg_output = (unit['p_min_i'] + min(unit['p_max_i'], unit['p_start_i'])) / 2\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*avg_output + unit['c_i']*avg_output**2) / avg_output\n        else:\n            avg_output = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_per_mw = (unit['a_i'] + unit['b_i']*avg_output + unit['c_i']*avg_output**2) / avg_output\n        flexible_units.append((i, cost_per_mw))\n    \n    flexible_units.sort(key=lambda x: x[1])\n    committed = must_run.copy()\n    total_max = must_run_max\n    \n    for i, _ in flexible_units:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        total_max += p_max\n        committed.append(i)\n    \n    # Economic dispatch\n    lambda_low = 0\n    lambda_high = 10000\n    tolerance = 1e-5\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        for i in committed:\n            unit = units_info[i]\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            \n            p_dispatch = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_max\n            p_dispatch = np.clip(p_dispatch, p_min, p_max)\n            total_gen += p_dispatch\n        \n        if abs(total_gen - current_load) < tolerance:\n            break\n        elif total_gen < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Fine-tuning\n    total_gen = 0\n    for i in committed:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_dispatch = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_max\n        p_dispatch = np.clip(p_dispatch, p_min, p_max)\n        schedules[0,i] = 1\n        schedules[1,i] = p_dispatch\n        total_gen += p_dispatch\n    \n    # Adjust for exact load matching\n    diff = current_load - total_gen\n    while abs(diff) > tolerance:\n        adjustments = []\n        for i in committed:\n            unit = units_info[i]\n            p_current = schedules[1,i]\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            \n            if diff > 0 and p_current < p_max:\n                adjustments.append((i, unit['b_i'] + 2*unit['c_i']*p_current))\n            elif diff < 0 and p_current > p_min:\n                adjustments.append((i, -(unit['b_i'] + 2*unit['c_i']*p_current)))\n        \n        if not adjustments:\n            break\n            \n        adjustments.sort(key=lambda x: x[1])\n        unit_idx = adjustments[0][0]\n        p_current = schedules[1,unit_idx]\n        unit = units_info[unit_idx]\n        \n        if diff > 0:\n            p_new = min(p_current + min(diff, unit['p_up_i']), unit['p_max_i'])\n        else:\n            p_new = max(p_current - min(-diff, unit['p_down_i']), unit['p_min_i'])\n        \n        schedules[1,unit_idx] = p_new\n        diff = current_load - np.sum(schedules[1])\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0092832754,
          "fitness": 0.0073559065
     },
     {
          "name": "enhanced_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints, with forecast-aware adjustment for flexible unit commitment\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units by two-period effective cost (including startup costs and forecasted load)\n5. Perform economic dispatch using iterative lambda adjustment within feasible output ranges\n6. Handle infeasible cases by setting outputs to minimum or maximum feasible values\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < toff_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_must_min = 0\n    total_must_max = 0\n    must_ranges = []\n    for i in must_run:\n        unit = units_info[i]\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        \n        p_low = max(pmin, p0 - pdown)\n        p_high = min(pmax, p0 + pup)\n        total_must_min += p_low\n        total_must_max += p_high\n        must_ranges.append((p_low, p_high))\n    \n    if current_load <= total_must_min:\n        schedules = np.zeros((2, n_units))\n        for idx, i in enumerate(must_run):\n            schedules[0, i] = 1\n            schedules[1, i] = must_ranges[idx][0]\n        return schedules\n    \n    flex_info = []\n    for i in flexible:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        \n        if u0 == 1:\n            p_low = max(pmin, p0 - pdown)\n            p_high = min(pmax, p0 + pup)\n        else:\n            p_low = pmin\n            p_high = min(pmax, pstart)\n        \n        p_avg = (current_load + forecast_load) / 2\n        p_avg = max(pmin, min(pmax, p_avg))\n        \n        if u0 == 0:\n            cost = (s + 2*a + 2*b*p_avg + 2*c*p_avg**2) / (2*p_avg) if p_avg > 0 else float('inf')\n        else:\n            cost = (a + b*p_avg + c*p_avg**2) / p_avg if p_avg > 0 else float('inf')\n        \n        flex_info.append((i, cost, p_low, p_high))\n    \n    flex_info.sort(key=lambda x: x[1])\n    committed_flex = []\n    total_cap = total_must_max\n    for unit_info in flex_info:\n        if total_cap >= current_load:\n            break\n        committed_flex.append(unit_info[0])\n        total_cap += unit_info[3]\n    \n    committed_units = must_run + committed_flex\n    p_mins = []\n    p_maxs = []\n    a_list = []\n    b_list = []\n    c_list = []\n    \n    for i in committed_units:\n        unit = units_info[i]\n        if i in must_run:\n            idx = must_run.index(i)\n            p_mins.append(must_ranges[idx][0])\n            p_maxs.append(must_ranges[idx][1])\n        else:\n            for info in flex_info:\n                if info[0] == i:\n                    p_mins.append(info[2])\n                    p_maxs.append(info[3])\n                    break\n        a_list.append(unit['a_i'])\n        b_list.append(unit['b_i'])\n        c_list.append(unit['c_i'])\n    \n    total_min = sum(p_mins)\n    total_max = sum(p_maxs)\n    \n    if current_load <= total_min:\n        p_out = p_mins\n    elif current_load >= total_max:\n        p_out = p_maxs\n    else:\n        low_lam = min(b_list[i] + 2*c_list[i]*p_mins[i] for i in range(len(committed_units)))\n        high_lam = max(b_list[i] + 2*c_list[i]*p_maxs[i] for i in range(len(committed_units)))\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i in range(len(committed_units)):\n                if c_list[i] == 0:\n                    p_val = p_maxs[i] if mid_lam >= b_list[i] else p_mins[i]\n                else:\n                    p_val = (mid_lam - b_list[i]) / (2 * c_list[i])\n                    p_val = max(p_mins[i], min(p_maxs[i], p_val))\n                total_p += p_val\n            \n            if total_p < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        p_out = []\n        for i in range(len(committed_units)):\n            if c_list[i] == 0:\n                p_val = p_maxs[i] if mid_lam >= b_list[i] else p_mins[i]\n            else:\n                p_val = (mid_lam - b_list[i]) / (2 * c_list[i])\n                p_val = max(p_mins[i], min(p_maxs[i], p_val))\n            p_out.append(p_val)\n    \n    schedules = np.zeros((2, n_units))\n    for i, unit_id in enumerate(committed_units):\n        schedules[0, unit_id] = 1\n        schedules[1, unit_id] = p_out[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0055738226,
          "gap_price_rate": 0.009205764,
          "fitness": 0.0073897933
     },
     {
          "name": "enhanced_forecast_aware_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced forecast-aware minimum up/down time constraints with two-period lookahead and shutdown ramp constraints\n2. Calculate must-run output range considering ramp constraints, previous states, and forecasted load for flexibility adjustment\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units using two-period effective cost with startup costs and forecast-aware output estimation\n5. Perform economic dispatch using adaptive lambda iteration with ramp-constrained feasible ranges\n6. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n7. Handle infeasible cases by forecast-aware generation optimization with priority-based constraint relaxation\n",
          "code": "import numpy as np\n\ndef enhanced_forecast_aware_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        low = max(p_min, p_i0 - p_down)\n        high = min(p_max, p_i0 + p_up)\n        must_run_min += low\n        must_run_max += high\n    \n    if current_load <= must_run_min:\n        for i in range(n_units):\n            if i in must_run:\n                unit = units_info[i]\n                p_min = unit['p_min_i']\n                p_i0 = unit['p_i_0']\n                p_down = unit['p_down_i']\n                p_i = max(p_min, p_i0 - p_down)\n                schedules[0,i] = 1\n                schedules[1,i] = p_i\n            else:\n                schedules[0,i] = 0\n                schedules[1,i] = 0\n        return schedules\n    \n    flexible_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        p_max = unit['p_max_i']\n        u_i0 = unit['u_i_0']\n        \n        if u_i0 == 0:\n            effective_cost = (s + a + b * p_max + c * p_max ** 2) / p_max\n        else:\n            effective_cost = (a + b * p_max + c * p_max ** 2) / p_max\n        \n        flexible_costs.append((effective_cost, i))\n    \n    flexible_costs.sort(key=lambda x: x[0])\n    \n    committed = must_run.copy()\n    total_max = must_run_max\n    for cost, i in flexible_costs:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_max = unit['p_max_i']\n        p_start = unit['p_start_i']\n        p_i0 = unit['p_i_0']\n        p_up = unit['p_up_i']\n        \n        if u_i0 == 0:\n            p_add = min(p_max, p_start)\n        else:\n            p_add = min(p_max, p_i0 + p_up)\n        \n        total_max += p_add\n        committed.append(i)\n    \n    low_bound = np.zeros(len(committed))\n    high_bound = np.zeros(len(committed))\n    b = np.zeros(len(committed))\n    c = np.zeros(len(committed))\n    \n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        \n        if u_i0 == 0:\n            low_b = p_min\n            high_b = min(p_max, p_start)\n        else:\n            low_b = max(p_min, p_i0 - p_down)\n            high_b = min(p_max, p_i0 + p_up)\n        \n        low_bound[idx] = low_b\n        high_bound[idx] = high_b\n        b[idx] = unit['b_i']\n        c[idx] = unit['c_i']\n    \n    total_low = np.sum(low_bound)\n    total_high = np.sum(high_bound)\n    \n    if current_load < total_low:\n        p_alloc = low_bound\n    elif current_load > total_high:\n        p_alloc = high_bound\n    else:\n        lambda_low = np.min(b + 2 * c * low_bound)\n        lambda_high = np.max(b + 2 * c * high_bound)\n        tolerance = 1e-6\n        while lambda_high - lambda_low > tolerance:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_mid = np.zeros(len(committed))\n            for idx in range(len(committed)):\n                p_val = (lambda_mid - b[idx]) / (2 * c[idx])\n                p_mid[idx] = np.clip(p_val, low_bound[idx], high_bound[idx])\n            total_mid = np.sum(p_mid)\n            if total_mid < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        p_alloc = p_mid\n    \n    for idx, i in enumerate(committed):\n        schedules[0,i] = 1\n        schedules[1,i] = p_alloc[idx]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.005573883,
          "gap_price_rate": 0.0092057709,
          "fitness": 0.0073898269
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate total feasible output range from must-run units considering ramp limits and startup/shutdown constraints\n3. If current load is below must-run minimum, set must-run units to minimum output and keep flexible units off\n4. If load exceeds must-run capacity, commit flexible units by effective average cost at midpoint output (including startup costs for offline units)\n5. Perform economic dispatch using marginal cost sorting with ramp-aware output adjustment\n6. Fine-tune outputs to exactly match load using bisection adjustment while respecting all constraints\n7. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and determine feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Determine must-run status\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                continue\n        # Determine must-off status\n        if unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n            continue\n        flexible.append(i)\n    \n    # Calculate feasible ranges for all units\n    for i in range(n_units):\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Handle must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        u[i] = 1\n        total_min_must += feasible_min[i]\n        total_max_must += feasible_max[i]\n    \n    # Check if load can be met with must-run units only\n    if current_load <= total_max_must:\n        # Distribute load to must-run units using economic dispatch\n        committed = must_run.copy()\n        remaining_load = current_load\n        # Set initial outputs to minimum\n        for i in committed:\n            p[i] = feasible_min[i]\n            remaining_load -= p[i]\n        \n        # Economic dispatch using marginal cost sorting\n        while remaining_load > 1e-6:\n            best_unit = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_add = feasible_max[best_unit] - p[best_unit]\n            add = min(remaining_load, max_add)\n            p[best_unit] += add\n            remaining_load -= add\n        \n        return np.array([u, p])\n    \n    # Commit flexible units based on effective average cost\n    flex_costs = []\n    for i in flexible:\n        unit = units[i]\n        mid_point = (feasible_min[i] + feasible_max[i]) / 2\n        if unit['u_i_0'] == 0:\n            eff_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * mid_point + \n                       unit['c_i'] * mid_point**2) / mid_point\n        else:\n            eff_cost = (unit['a_i'] + unit['b_i'] * mid_point + \n                       unit['c_i'] * mid_point**2) / mid_point\n        flex_costs.append((eff_cost, i))\n    \n    flex_costs.sort(key=lambda x: x[0])\n    committed = must_run.copy()\n    total_max = total_max_must\n    \n    # Commit flexible units until capacity meets load\n    for cost, i in flex_costs:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        committed.append(i)\n        total_max += feasible_max[i]\n    \n    # Economic dispatch\n    remaining_load = current_load\n    # Set initial outputs to minimum\n    for i in committed:\n        p[i] = feasible_min[i]\n        remaining_load -= p[i]\n    \n    # Adjust outputs using marginal cost sorting\n    while abs(remaining_load) > 1e-6:\n        if remaining_load > 0:\n            # Find unit with lowest marginal cost that can increase\n            best_unit = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_add = feasible_max[best_unit] - p[best_unit]\n            add = min(remaining_load, max_add)\n            p[best_unit] += add\n            remaining_load -= add\n        else:\n            # Find unit with highest marginal cost that can decrease\n            best_unit = None\n            best_mc = -float('inf')\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc > best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_sub = p[best_unit] - feasible_min[best_unit]\n            sub = min(-remaining_load, max_sub)\n            p[best_unit] -= sub\n            remaining_load += sub\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0060965326,
          "gap_price_rate": 0.0089137153,
          "fitness": 0.007505124
     }
]