[
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp limits\n2. Calculate total output range from must-run units\n3. If load is below must-run minimum, set must-run units to minimum output\n4. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs\n5. Perform economic dispatch among committed units using marginal cost sorting\n6. Adjust outputs to meet load exactly while respecting ramp constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    \n    allowable_min = np.zeros(n_units)\n    allowable_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            allowable_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            allowable_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            allowable_min[i] = unit['p_min_i']\n            allowable_max[i] = unit['p_start_i']\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    total_min = np.sum(allowable_min[must_run])\n    total_max = np.sum(allowable_max[must_run])\n    \n    if current_load <= total_min:\n        u[must_run] = 1\n        p[must_run] = allowable_min[must_run]\n    else:\n        u[must_run] = 1\n        p[must_run] = allowable_max[must_run]\n        remaining_load = current_load - total_max\n        \n        flexible_idx = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n        cost_rates = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            cost_rates.append((cost / allowable_max[i], i))\n        \n        cost_rates.sort(key=lambda x: x[0])\n        for _, idx in cost_rates:\n            if remaining_load <= 0:\n                break\n            u[idx] = 1\n            alloc = min(remaining_load, allowable_max[idx])\n            p[idx] = alloc\n            remaining_load -= alloc\n\n    committed = np.where(u == 1)[0]\n    for i in committed:\n        p[i] = allowable_min[i]\n    \n    total_output = np.sum(p)\n    while abs(total_output - current_load) > 1e-6:\n        if total_output < current_load:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < allowable_max[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(current_load - total_output, allowable_max[candidate] - p[candidate])\n            p[candidate] += increase\n            total_output += increase\n        else:\n            candidate = -1\n            max_mc = -float('inf')\n            for i in committed:\n                if p[i] > allowable_min[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            decrease = min(total_output - current_load, p[candidate] - allowable_min[candidate])\n            p[candidate] -= decrease\n            total_output -= decrease\n\n    return np.vstack((u, p))",
          "from": null,
          "gap_power_rate": 0.0056459616,
          "gap_price_rate": 0.00847472,
          "fitness": 0.0070603408
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-on and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Sort flexible units by average cost per MW at minimum output (including startup cost).\n3. Commit must-on units and flexible units until the total maximum available power meets the load.\n4. Perform economic dispatch among committed units using marginal cost merit order within feasible ranges determined by ramp constraints.\n5. Adjust power outputs to meet the load as closely as possible.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible = [i for i in range(n_units) if i not in must_on and i not in must_off]\n    avg_costs = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        cost = s_i + a_i + b_i * p_min_i + c_i * p_min_i**2\n        avg_cost = cost / p_min_i\n        avg_costs.append(avg_cost)\n    \n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible))]\n    current_load = load[0]\n    total_max_must_on = 0\n    \n    for i in must_on:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_max_i = unit['p_max_i']\n        max_p = min(p_max_i, p_i0 + p_up_i)\n        total_max_must_on += max_p\n    \n    committed = must_on[:]\n    total_max = total_max_must_on\n    \n    for i in flexible_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_i0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_max_i = unit['p_max_i']\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_p = min(p_max_i, p_start_i)\n        total_max += max_p\n        committed.append(i)\n    \n    min_max_ranges = []\n    committed_units_info = []\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            min_p = max(p_min_i, p_i0 - p_down_i)\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            min_p = p_min_i\n            max_p = min(p_max_i, p_start_i)\n        \n        min_max_ranges.append((min_p, max_p))\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        committed_units_info.append([i, min_p, max_p, a_i, b_i, c_i])\n    \n    p_outputs = [min_p for min_p, _ in min_max_ranges]\n    total_output = sum(p_outputs)\n    \n    for idx, unit_info in enumerate(committed_units_info):\n        i, p, max_p, a, b, c = unit_info\n        committed_units_info[idx] = [i, p, max_p, a, b, c]\n    \n    while total_output < current_load:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, (i, p, max_p, a, b, c) in enumerate(committed_units_info):\n            if p < max_p:\n                marginal = b + 2 * c * p\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = idx\n        \n        if best_idx is None:\n            break\n        \n        i, p, max_p, a, b, c = committed_units_info[best_idx]\n        increase = min(current_load - total_output, max_p - p)\n        new_p = p + increase\n        committed_units_info[best_idx] = [i, new_p, max_p, a, b, c]\n        total_output += increase\n    \n    schedules = np.zeros((2, n_units))\n    for (i, p, max_p, a, b, c) in committed_units_info:\n        schedules[0, i] = 1\n        schedules[1, i] = p\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0105126155,
          "fitness": 0.0083271523
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Commit must-run units and calculate their total feasible output range.\n3. Sort available units by average cost per MW at maximum output (including startup cost if offline).\n4. Commit additional cheapest units until total maximum capacity meets load.\n5. Perform economic dispatch using feasible output ranges and marginal cost sorting.\n6. Adjust outputs to exactly match load while respecting constraints.\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = [0] * n_units\n    p = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run[i] = True\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off[i] = True\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            \n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            p_max = unit['p_max_i']\n            s = unit['s_i']\n            u_i0 = unit['u_i_0']\n            \n            if u_i0 == 0:\n                total_cost = a + b * p_max + c * p_max**2 + s\n            else:\n                total_cost = a + b * p_max + c * p_max**2\n            avg_cost = total_cost / p_max\n            available_units.append((i, avg_cost, u_i0))\n            \n    available_units.sort(key=lambda x: x[1])\n    \n    total_max_must_run = 0\n    for i in range(n_units):\n        if must_run[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                UB = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_must_run += UB\n            \n    total_max = total_max_must_run\n    for idx, _, u_i0 in available_units:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        unit = units_info[idx]\n        if u_i0 == 1:\n            UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            UB = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += UB\n        \n    LB_arr = [0] * n_units\n    UB_arr = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                LB_arr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                UB_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                LB_arr[i] = unit['p_min_i']\n                UB_arr[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p[i] = 0\n            \n    total_output = sum(LB_arr)\n    remaining_load = current_load - total_output\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    units_with_capacity = []\n    for i in committed_indices:\n        if LB_arr[i] < UB_arr[i]:\n            units_with_capacity.append(i)\n            \n    units_with_capacity.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * LB_arr[i])\n    \n    for i in units_with_capacity:\n        if remaining_load <= 0:\n            break\n        available = UB_arr[i] - LB_arr[i]\n        if remaining_load <= available:\n            p[i] = LB_arr[i] + remaining_load\n            remaining_load = 0\n        else:\n            p[i] = UB_arr[i]\n            remaining_load -= available\n            \n    for i in committed_indices:\n        if p[i] == 0:\n            p[i] = LB_arr[i]\n            \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0066823052,
          "gap_price_rate": 0.0112014253,
          "fitness": 0.0089418652
     },
     {
          "name": "commit_units_rolling_improved",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Set must-run units to online and must-off units to offline\n3. Calculate total feasible output range from must-run units considering ramp constraints\n4. If load is below must-run minimum, set must-run units to minimum output\n5. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs and ramp limits\n6. Perform economic dispatch using marginal cost sorting with feasible output ranges\n7. Adjust outputs iteratively to meet load exactly while respecting all constraints\n8. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_improved(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = np.zeros(n_units)\n    p_schedule = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u_schedule[i] = 1\n    for i in must_off:\n        u_schedule[i] = 0\n        p_schedule[i] = 0\n\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += low\n        total_max_must += high\n\n    if current_load <= total_min_must:\n        for i in must_run:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_schedule[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_schedule[i] = unit['p_min_i']\n        return np.array([u_schedule, p_schedule])\n\n    scores = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n            score = cost / unit['p_max_i']\n        else:\n            cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n            score = cost / unit['p_max_i']\n        scores.append(score)\n    \n    sorted_flex = [x for _, x in sorted(zip(scores, flexible))]\n    total_max = total_max_must\n    committed_flex = []\n    for i in sorted_flex:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += high_i\n        u_schedule[i] = 1\n        committed_flex.append(i)\n        if total_max >= current_load:\n            break\n\n    committed = must_run + committed_flex\n    low_list = []\n    high_list = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_list.append(low_i)\n        high_list.append(high_i)\n    \n    total_low = sum(low_list)\n    total_high = sum(high_list)\n    \n    if current_load <= total_low:\n        for idx, i in enumerate(committed):\n            p_schedule[i] = low_list[idx]\n        return np.array([u_schedule, p_schedule])\n    \n    if current_load >= total_high:\n        for idx, i in enumerate(committed):\n            p_schedule[i] = high_list[idx]\n        return np.array([u_schedule, p_schedule])\n    \n    current_outs = low_list[:]\n    remaining = current_load - total_low\n    \n    while remaining > 1e-5:\n        min_marginal = float('inf')\n        candidate = None\n        for idx, i in enumerate(committed):\n            if current_outs[idx] < high_list[idx]:\n                unit = units_info[i]\n                marginal = unit['b_i'] + 2 * unit['c_i'] * current_outs[idx]\n                if marginal < min_marginal:\n                    min_marginal = marginal\n                    candidate = idx\n        if candidate is None:\n            break\n        increase = min(remaining, high_list[candidate] - current_outs[candidate])\n        current_outs[candidate] += increase\n        remaining -= increase\n    \n    for idx, i in enumerate(committed):\n        p_schedule[i] = current_outs[idx]\n    \n    return np.array([u_schedule, p_schedule])",
          "from": "mutation",
          "gap_power_rate": 0.0078042165,
          "gap_price_rate": 0.019561841,
          "fitness": 0.0136830287
     },
     {
          "name": "commit_units_improved_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate cost-effectiveness for flexible units using average production cost at midpoint output including startup costs\n3. Commit must-run units and flexible units in cost-effectiveness order until load is met\n4. Perform economic dispatch using marginal cost sorting with ramp-aware output adjustment\n5. Fine-tune outputs to exactly match load while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_improved_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    cost_effectiveness = []\n    for i in flexible:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_mid = (p_min + p_max) / 2\n        u0 = unit['u_i_0']\n        \n        if u0 == 0:\n            cost = (s + a + b * p_mid + c * p_mid**2) / p_mid\n        else:\n            cost = (a + b * p_mid + c * p_mid**2) / p_mid\n        cost_effectiveness.append((i, cost))\n    \n    cost_effectiveness.sort(key=lambda x: x[1])\n    flexible_sorted = [x[0] for x in cost_effectiveness]\n    \n    committed = must_run.copy()\n    total_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        total_capacity += unit['p_max_i']\n    \n    for i in flexible_sorted:\n        if total_capacity >= current_load:\n            break\n        unit = units_info[i]\n        total_capacity += unit['p_max_i']\n        committed.append(i)\n    \n    for i in range(n_units):\n        schedules[0, i] = 1 if i in committed else 0\n    \n    feasible_ranges = []\n    for i in committed:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        \n        if u0 == 1:\n            low = max(p_min, p0 - ramp_down)\n            high = min(p_max, p0 + ramp_up)\n        else:\n            low = p_min\n            high = min(p_max, p_start)\n        feasible_ranges.append((low, high))\n    \n    p_values = [low for low, high in feasible_ranges]\n    total_output = sum(p_values)\n    remaining = current_load - total_output\n    \n    units_dispatch = []\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        units_dispatch.append({\n            'index': i,\n            'b': unit['b_i'],\n            'c': unit['c_i'],\n            'current_p': p_values[idx],\n            'low': feasible_ranges[idx][0],\n            'high': feasible_ranges[idx][1]\n        })\n    \n    def marginal_cost(unit, p):\n        return unit['b'] + 2 * unit['c'] * p\n    \n    while abs(remaining) > 1e-5:\n        if remaining > 0:\n            candidate = None\n            min_mc = float('inf')\n            for unit in units_dispatch:\n                if unit['current_p'] < unit['high']:\n                    mc = marginal_cost(unit, unit['current_p'])\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = unit\n            if not candidate:\n                break\n            increase = min(1.0, candidate['high'] - candidate['current_p'], remaining)\n            candidate['current_p'] += increase\n            remaining -= increase\n        else:\n            candidate = None\n            max_mc = -float('inf')\n            for unit in units_dispatch:\n                if unit['current_p'] > unit['low']:\n                    mc = marginal_cost(unit, unit['current_p'])\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = unit\n            if not candidate:\n                break\n            decrease = min(1.0, candidate['current_p'] - candidate['low'], -remaining)\n            candidate['current_p'] -= decrease\n            remaining += decrease\n    \n    for unit in units_dispatch:\n        i = unit['index']\n        schedules[1, i] = unit['current_p']\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0299800984,
          "gap_price_rate": 0.0343227297,
          "fitness": 0.032151414
     },
     {
          "name": "commit_units_improved_heuristic",
          "algorithm": "1. Identify must-run and must-off units based on minimum up/down times and shutdown ramp constraints\n2. Calculate total must-run output range and handle underload scenarios\n3. Sort flexible units by effective average cost at minimum output including startup costs\n4. Commit flexible units in cost order until load can be met\n5. Perform economic dispatch using marginal cost sorting within feasible ranges\n6. Fine-tune outputs to exactly match load while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_improved_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute feasible ranges and constraints\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        # Determine feasible output range\n        if unit['u_i_0'] == 1:  # Previously online\n            feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check must-run conditions\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n        else:  # Previously offline\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n            # Check must-off conditions\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Commit must-run units at minimum output\n    total_min_must_run = 0\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            p[i] = feasible_min[i]\n            total_min_must_run += feasible_min[i]\n    \n    # Handle underload case\n    if current_load <= total_min_must_run:\n        return np.array([u, p])\n    \n    # Calculate remaining load after must-run units\n    remaining_load = current_load - total_min_must_run\n    \n    # Create priority list for flexible units\n    flexible_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            # Calculate effective average cost at minimum output\n            if unit['u_i_0'] == 0:\n                avg_cost = (unit['s_i'] + unit['b_i'] * feasible_min[i] + \n                           unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n            else:\n                avg_cost = (unit['b_i'] * feasible_min[i] + \n                           unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n            flexible_units.append((i, avg_cost, feasible_max[i]))\n    \n    # Sort by average cost\n    flexible_units.sort(key=lambda x: x[1])\n    \n    # Commit flexible units until load can be met\n    total_available = total_min_must_run\n    committed_units = [i for i in range(n_units) if must_run[i]]\n    \n    for i, _, max_p in flexible_units:\n        if total_available < current_load:\n            u[i] = 1\n            committed_units.append(i)\n            total_available += max_p\n        else:\n            break\n    \n    # Perform economic dispatch\n    remaining_load = current_load\n    marginal_costs = []\n    \n    # Calculate initial allocation at minimum output\n    for i in committed_units:\n        p[i] = feasible_min[i]\n        remaining_load -= feasible_min[i]\n        marginal_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n        marginal_costs.append((i, marginal_cost, feasible_min[i], feasible_max[i]))\n    \n    # Sort by marginal cost for incremental allocation\n    marginal_costs.sort(key=lambda x: x[1])\n    \n    # Allocate remaining load\n    for i, mc, min_p, max_p in marginal_costs:\n        if remaining_load <= 0:\n            break\n        additional = min(remaining_load, max_p - min_p)\n        p[i] += additional\n        remaining_load -= additional\n    \n    # Fine-tune to exactly match load\n    if remaining_load != 0:\n        # Adjust using marginal cost order\n        if remaining_load > 0:\n            # Increase output of cheapest units\n            for i, mc, min_p, max_p in marginal_costs:\n                if remaining_load <= 0:\n                    break\n                additional = min(remaining_load, max_p - p[i])\n                p[i] += additional\n                remaining_load -= additional\n        else:\n            # Decrease output of most expensive units\n            marginal_costs.sort(key=lambda x: -x[1])\n            for i, mc, min_p, max_p in marginal_costs:\n                if remaining_load >= 0:\n                    break\n                reduction = min(-remaining_load, p[i] - min_p)\n                p[i] -= reduction\n                remaining_load += reduction\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0844137609,
          "fitness": 0.0422469437
     },
     {
          "name": "improved_rolling_priority_list_with_ed",
          "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Classify remaining units into must-off and flexible categories\n3. Sort flexible units by effective average cost (considering startup costs and current state)\n4. Commit flexible units in cost order until capacity meets load plus reserve margin\n5. Perform economic dispatch using iterative lambda adjustment with ramp constraints\n6. Fine-tune outputs using marginal cost sorting to exactly match load\n7. Validate and adjust for minimum runtime constraints\n",
          "code": "import numpy as np\n\ndef improved_rolling_priority_list_with_ed(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize outputs\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute feasible ranges and costs\n    for i, unit in enumerate(units):\n        # Calculate feasible min/max considering ramp constraints\n        if unit['u_i_0'] == 1:  # previously on\n            p_min_feasible = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # previously off\n            p_min_feasible = unit['p_min_i']\n            p_max_feasible = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit['p_min_feasible'] = p_min_feasible\n        unit['p_max_feasible'] = p_max_feasible\n        \n        # Calculate effective average cost\n        if unit['u_i_0'] == 0:  # include startup cost if off\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                        unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                        unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        unit['avg_cost'] = avg_cost\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        # Check minimum uptime constraint\n        if unit['u_i_0'] == 1 and unit['t_i_0'] < unit['t_on_min_i']:\n            must_run.append(i)\n            continue\n            \n        # Check minimum downtime constraint\n        if unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n            continue\n            \n        # Check shutdown ramp constraint\n        if (unit['u_i_0'] == 1 and \n            unit['p_i_0'] > unit['p_shut_i']):\n            must_run.append(i)\n            continue\n            \n        flexible.append(i)\n    \n    # Commit must-run units at minimum feasible output\n    total_output = 0\n    for i in must_run:\n        u[i] = 1\n        p[i] = units[i]['p_min_feasible']\n        total_output += p[i]\n    \n    # Sort flexible units by average cost\n    flexible_sorted = sorted(flexible, key=lambda i: units[i]['avg_cost'])\n    \n    # Commit flexible units until load is met\n    for i in flexible_sorted:\n        if total_output >= current_load:\n            break\n            \n        if i in must_off:\n            continue\n            \n        u[i] = 1\n        p[i] = units[i]['p_min_feasible']\n        total_output += p[i]\n    \n    # Economic dispatch using lambda iteration\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    lambda_low = 0\n    lambda_high = 10000  # sufficiently high value\n    \n    for _ in range(100):  # lambda iteration\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        \n        for i in committed_idx:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_dispatch = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else unit['p_max_feasible']\n            \n            # Constrain by feasible limits\n            p_dispatch = np.clip(p_dispatch, unit['p_min_feasible'], unit['p_max_feasible'])\n            total_gen += p_dispatch\n        \n        if total_gen < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        if abs(total_gen - current_load) < 1e-5:\n            break\n    \n    # Set outputs based on final lambda\n    for i in committed_idx:\n        unit = units[i]\n        p_dispatch = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else unit['p_max_feasible']\n        p[i] = np.clip(p_dispatch, unit['p_min_feasible'], unit['p_max_feasible'])\n    \n    # Fine-tune to exactly match load\n    total_output = sum(p[i] for i in committed_idx)\n    imbalance = current_load - total_output\n    \n    while abs(imbalance) > 1e-5:\n        # Sort by marginal cost (ascending for deficit, descending for surplus)\n        if imbalance > 0:\n            candidates = sorted(committed_idx, \n                               key=lambda i: units[i]['b_i'] + 2*units[i]['c_i']*p[i])\n        else:\n            candidates = sorted(committed_idx, \n                               key=lambda i: units[i]['b_i'] + 2*units[i]['c_i']*p[i], \n                               reverse=True)\n        \n        adjusted = False\n        for i in candidates:\n            unit = units[i]\n            if imbalance > 0 and p[i] < unit['p_max_feasible']:\n                max_adjust = min(imbalance, unit['p_max_feasible'] - p[i])\n                p[i] += max_adjust\n                imbalance -= max_adjust\n                adjusted = True\n            elif imbalance < 0 and p[i] > unit['p_min_feasible']:\n                max_adjust = min(-imbalance, p[i] - unit['p_min_feasible'])\n                p[i] -= max_adjust\n                imbalance += max_adjust\n                adjusted = True\n            \n            if abs(imbalance) < 1e-5:\n                break\n        \n        if not adjusted:\n            break\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 8.01277e-05,
          "gap_price_rate": 0.0916788383,
          "fitness": 0.045879483
     },
     {
          "name": "commit_units_by_priority_list_with_ramping",
          "algorithm": "1. Determine must-run units based on minimum uptime/downtime constraints and previous output relative to shutdown capacity\n2. Form priority list of non-must-run units sorted by average production cost at midpoint capacity\n3. Commit must-run units at minimum capacity\n4. Commit units from priority list until load is met, respecting ramp constraints\n5. Adjust generation levels using economic dispatch within feasible ranges\n6. Handle infeasible cases by maximizing generation or accepting over-generation\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list_with_ramping(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    must_run = np.zeros(num_units, dtype=bool)\n    must_off = np.zeros(num_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run[i] = True\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    priority_list = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            mid_point = (unit['p_min_i'] + unit['p_max_i']) / 2\n            avg_cost = (unit['b_i'] + unit['c_i'] * mid_point) / mid_point\n            priority_list.append((avg_cost, i))\n    \n    priority_list.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    feasible_ranges = []\n    \n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            u[i] = 1\n            p[i] = lb\n            total_min += lb\n            total_max += ub\n            feasible_ranges.append((i, lb, ub))\n        else:\n            feasible_ranges.append((i, 0, 0))\n    \n    remaining_load = current_load - total_min\n    for _, idx in priority_list:\n        if remaining_load <= 0:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if lb <= remaining_load:\n            u[idx] = 1\n            p[idx] = lb\n            total_min += lb\n            total_max += ub\n            feasible_ranges[idx] = (idx, lb, ub)\n            remaining_load -= lb\n    \n    committed_units = [i for i in range(num_units) if u[i] == 1]\n    incremental_costs = []\n    for i in committed_units:\n        unit = units_info[i]\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n        incremental_costs.append((inc_cost, i))\n    \n    incremental_costs.sort(key=lambda x: x[0])\n    \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        for _, idx in incremental_costs:\n            if remaining <= 0:\n                break\n            _, lb, ub = feasible_ranges[idx]\n            addable = min(ub - p[idx], remaining)\n            p[idx] += addable\n            remaining -= addable\n    \n    if remaining < 0:\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        remaining = abs(remaining)\n        for _, idx in incremental_costs:\n            if remaining <= 0:\n                break\n            _, lb, ub = feasible_ranges[idx]\n            reducible = min(p[idx] - lb, remaining)\n            p[idx] -= reducible\n            remaining -= reducible\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0923868685,
          "fitness": 0.0462334975
     },
     {
          "name": "improved_adaptive_merit_order",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate effective marginal cost for flexible units considering startup costs and current state\n3. Commit must-run units at their feasible minimum output\n4. Fill remaining load using flexible units sorted by effective marginal cost\n5. Perform economic dispatch using incremental cost sorting within feasible ramp ranges\n6. Adjust outputs to exactly match load while respecting all constraints\n7. Verify minimum up/down times are satisfied for all units\n",
          "code": "import numpy as np\n\ndef improved_adaptive_merit_order(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible output range based on ramp constraints\n        if unit['u_i_0'] == 1:  # Previously online\n            feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            # Check must-run conditions\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously offline\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Check must-off conditions\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate marginal cost (derivative of cost function)\n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n    \n    # Commit must-run units\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]\n    \n    # Calculate remaining load\n    committed_power = np.sum(p)\n    remaining_load = current_load - committed_power\n    \n    # If remaining load is negative, adjust must-run units down\n    if remaining_load < 0:\n        for i in must_run:\n            adjust_amount = min(p[i] - feasible_min[i], -remaining_load)\n            p[i] -= adjust_amount\n            remaining_load += adjust_amount\n            if remaining_load >= 0:\n                break\n    \n    # Sort flexible units by effective marginal cost\n    flexible_costs = []\n    for i in flexible:\n        effective_cost = marginal_cost[i]\n        if units_info[i]['u_i_0'] == 0:  # Include startup cost if offline\n            effective_cost += units_info[i]['s_i'] / feasible_max[i]\n        flexible_costs.append((i, effective_cost))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    \n    # Commit flexible units until load is met\n    for i, _ in flexible_costs:\n        if remaining_load <= 0:\n            break\n            \n        if remaining_load > feasible_min[i]:\n            u[i] = 1\n            p[i] = min(remaining_load, feasible_max[i])\n            remaining_load -= p[i]\n    \n    # Perform economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    # Calculate total generation and remaining load\n    total_gen = np.sum(p)\n    remaining_load = current_load - total_gen\n    \n    # Adjust generation using marginal cost order\n    while abs(remaining_load) > 1e-6:\n        # Find units that can adjust\n        adjustable_units = []\n        for i in committed_indices:\n            if remaining_load > 0 and p[i] < feasible_max[i]:\n                adjustable_units.append((i, marginal_cost[i]))\n            elif remaining_load < 0 and p[i] > feasible_min[i]:\n                adjustable_units.append((i, marginal_cost[i]))\n        \n        if not adjustable_units:\n            break\n            \n        # Sort by marginal cost (ascending for increase, descending for decrease)\n        if remaining_load > 0:\n            adjustable_units.sort(key=lambda x: x[1])\n        else:\n            adjustable_units.sort(key=lambda x: x[1], reverse=True)\n        \n        # Adjust most economical unit\n        i = adjustable_units[0][0]\n        if remaining_load > 0:\n            adjust_amount = min(remaining_load, feasible_max[i] - p[i])\n        else:\n            adjust_amount = max(remaining_load, feasible_min[i] - p[i])\n        \n        p[i] += adjust_amount\n        remaining_load -= adjust_amount\n    \n    # Ensure outputs are within limits\n    for i in committed_indices:\n        p[i] = np.clip(p[i], feasible_min[i], feasible_max[i])\n    \n    # Form output array\n    schedules = np.vstack([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 5.58777e-05,
          "gap_price_rate": 0.0977805121,
          "fitness": 0.0489181949
     },
     {
          "name": "rolling_priority_list_with_ed",
          "algorithm": "1. Determine must-run units based on min up/down times and shutdown ramp constraints\n2. Classify remaining units into must-off and free units\n3. Sort free units by average cost at maximum output\n4. Commit free units in cost order until capacity meets load\n5. Perform economic dispatch considering ramp constraints\n6. Adjust generation to exactly match load using marginal cost order\n\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_with_ed(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        # Check min up/down constraints\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n                continue\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n                continue\n        \n        # Check shutdown ramp constraint\n        if unit['u_i_0'] == 1 and unit['p_i_0'] > unit['p_shut_i']:\n            must_run.append(i)\n        else:\n            free_units.append(i)\n    \n    # Sort free units by average cost at p_max\n    def cost_per_mw(i):\n        unit = units_info[i]\n        return (unit['a_i'] + unit['b_i']*unit['p_max_i'] + \n                unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n    \n    free_units.sort(key=cost_per_mw)\n    \n    # Commit must-run units\n    total_capacity = 0\n    for i in must_run:\n        u[i] = 1\n        unit = units_info[i]\n        # Set initial output considering ramp constraints\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        p[i] = p_min\n        total_capacity += p_min\n    \n    # Commit free units until we meet load\n    for i in free_units:\n        if total_capacity >= current_load:\n            break\n        u[i] = 1\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], \n                   unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i'])\n        p[i] = min(p_max, current_load - total_capacity + unit['p_min_i'])\n        total_capacity += p[i]\n    \n    # Economic dispatch\n    remaining_load = current_load - total_capacity\n    while abs(remaining_load) > 1e-6:\n        # Find unit with lowest marginal cost for increasing generation\n        best_unit = None\n        best_marginal_cost = float('inf')\n        for i in range(n_units):\n            if u[i] == 0:\n                continue\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate available headroom\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n                if marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = i\n        \n        # Find unit with highest marginal cost for decreasing generation\n        worst_unit = None\n        worst_marginal_cost = -float('inf')\n        for i in range(n_units):\n            if u[i] == 0:\n                continue\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate available footroom\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_p = unit['p_min_i']\n            if current_p > min_p:\n                marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n                if marginal_cost > worst_marginal_cost:\n                    worst_marginal_cost = marginal_cost\n                    worst_unit = i\n        \n        # Adjust generation\n        if remaining_load > 0 and best_unit is not None:\n            unit = units_info[best_unit]\n            max_increase = min(remaining_load, \n                              min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i']) - p[best_unit])\n            p[best_unit] += max_increase\n            remaining_load -= max_increase\n        elif remaining_load < 0 and worst_unit is not None:\n            unit = units_info[worst_unit]\n            max_decrease = min(abs(remaining_load), \n                              p[worst_unit] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] == 1 else unit['p_min_i']))\n            p[worst_unit] -= max_decrease\n            remaining_load += max_decrease\n        else:\n            break\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 5.58777e-05,
          "gap_price_rate": 0.0984342045,
          "fitness": 0.0492450411
     }
]