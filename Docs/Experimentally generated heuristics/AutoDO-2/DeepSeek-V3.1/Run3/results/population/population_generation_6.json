[
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints, with enhanced forecast-aware adjustment\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If current load exceeds must-run capacity, commit flexible units by two-period effective cost including startup costs and forecasted load\n4. Perform economic dispatch using marginal cost sorting within feasible output ranges\n5. Fine-tune outputs using proportional adjustment based on ramp capabilities\n6. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, p_start_i)\n        \n        must_run_min += min_out\n        must_run_max += max_out\n    \n    if current_load <= must_run_min:\n        for i in must_run:\n            unit = units_info[i]\n            u_i_0 = unit['u_i_0']\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_down_i = unit['p_down_i']\n            \n            if u_i_0 == 1:\n                p[i] = max(p_min_i, p_i_0 - p_down_i)\n            else:\n                p[i] = p_min_i\n            u[i] = 1\n        for i in flexible + must_off:\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    adjusted_load = (current_load + next_load) / 2\n    flexible_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        s_i = unit['s_i']\n        \n        mid_i = (p_min_i + p_max_i) / 2\n        cost_current = a_i + b_i * mid_i + c_i * mid_i ** 2\n        cost_next = a_i + b_i * mid_i + c_i * mid_i ** 2\n        total_cost = cost_current + cost_next + s_i * (1 - u_i_0)\n        effective_cost = total_cost / (2 * mid_i)\n        flexible_costs.append((i, effective_cost))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    committed_flexible = []\n    total_capacity = must_run_max\n    for i, _ in flexible_costs:\n        unit = units_info[i]\n        p_max_i = unit['p_max_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        \n        max_out = p_max_i if u_i_0 == 1 else min(p_max_i, p_start_i)\n        if total_capacity < adjusted_load:\n            committed_flexible.append(i)\n            total_capacity += max_out\n        else:\n            break\n    \n    committed_units = must_run + committed_flexible\n    for i in committed_units:\n        u[i] = 1\n    \n    min_outs = []\n    max_outs = []\n    for i in committed_units:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, p_start_i)\n        \n        min_outs.append(min_out)\n        max_outs.append(max_out)\n    \n    total_min = sum(min_outs)\n    total_max = sum(max_outs)\n    \n    if current_load < total_min:\n        for idx, i in enumerate(committed_units):\n            p[i] = min_outs[idx]\n        for i in set(range(n_units)) - set(committed_units):\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    if current_load > total_max:\n        for idx, i in enumerate(committed_units):\n            p[i] = max_outs[idx]\n        for i in set(range(n_units)) - set(committed_units):\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    margins = [current_load - total_min, total_max - current_load]\n    if margins[0] <= margins[1]:\n        p_vals = min_outs.copy()\n        remaining = current_load - total_min\n        unit_indices = list(range(len(committed_units)))\n        while remaining > 0:\n            best_cost = float('inf')\n            best_idx = None\n            for idx in unit_indices:\n                i = committed_units[idx]\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                current_p = p_vals[idx]\n                if current_p < max_outs[idx]:\n                    marginal_cost = b_i + 2 * c_i * current_p\n                    if marginal_cost < best_cost:\n                        best_cost = marginal_cost\n                        best_idx = idx\n            if best_idx is None:\n                break\n            i = committed_units[best_idx]\n            unit = units_info[i]\n            p_up_i = unit['p_up_i']\n            available = min(max_outs[best_idx] - p_vals[best_idx], p_up_i)\n            add = min(available, remaining)\n            p_vals[best_idx] += add\n            remaining -= add\n            if p_vals[best_idx] >= max_outs[best_idx]:\n                unit_indices.remove(best_idx)\n        for idx, i in enumerate(committed_units):\n            p[i] = p_vals[idx]\n    else:\n        p_vals = max_outs.copy()\n        excess = total_max - current_load\n        unit_indices = list(range(len(committed_units)))\n        while excess > 0:\n            worst_cost = -float('inf')\n            worst_idx = None\n            for idx in unit_indices:\n                i = committed_units[idx]\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                current_p = p_vals[idx]\n                if current_p > min_outs[idx]:\n                    marginal_cost = b_i + 2 * c_i * current_p\n                    if marginal_cost > worst_cost:\n                        worst_cost = marginal_cost\n                        worst_idx = idx\n            if worst_idx is None:\n                break\n            i = committed_units[worst_idx]\n            unit = units_info[i]\n            p_down_i = unit['p_down_i']\n            reduce_by = min(p_vals[worst_idx] - min_outs[worst_idx], p_down_i, excess)\n            p_vals[worst_idx] -= reduce_by\n            excess -= reduce_by\n            if p_vals[worst_idx] <= min_outs[worst_idx]:\n                unit_indices.remove(worst_idx)\n        for idx, i in enumerate(committed_units):\n            p[i] = p_vals[idx]\n    \n    for i in set(range(n_units)) - set(committed_units):\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0019652318,
          "gap_price_rate": 0.0086160879,
          "fitness": 0.0052906598
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp limits\n2. Calculate total output range from must-run units\n3. If load is below must-run minimum, set must-run units to minimum output\n4. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs\n5. Perform economic dispatch among committed units using marginal cost sorting\n6. Adjust outputs to meet load exactly while respecting ramp constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    \n    allowable_min = np.zeros(n_units)\n    allowable_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            allowable_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            allowable_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            allowable_min[i] = unit['p_min_i']\n            allowable_max[i] = unit['p_start_i']\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    total_min = np.sum(allowable_min[must_run])\n    total_max = np.sum(allowable_max[must_run])\n    \n    if current_load <= total_min:\n        u[must_run] = 1\n        p[must_run] = allowable_min[must_run]\n    else:\n        u[must_run] = 1\n        p[must_run] = allowable_max[must_run]\n        remaining_load = current_load - total_max\n        \n        flexible_idx = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n        cost_rates = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            cost_rates.append((cost / allowable_max[i], i))\n        \n        cost_rates.sort(key=lambda x: x[0])\n        for _, idx in cost_rates:\n            if remaining_load <= 0:\n                break\n            u[idx] = 1\n            alloc = min(remaining_load, allowable_max[idx])\n            p[idx] = alloc\n            remaining_load -= alloc\n\n    committed = np.where(u == 1)[0]\n    for i in committed:\n        p[i] = allowable_min[i]\n    \n    total_output = np.sum(p)\n    while abs(total_output - current_load) > 1e-6:\n        if total_output < current_load:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < allowable_max[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(current_load - total_output, allowable_max[candidate] - p[candidate])\n            p[candidate] += increase\n            total_output += increase\n        else:\n            candidate = -1\n            max_mc = -float('inf')\n            for i in committed:\n                if p[i] > allowable_min[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            decrease = min(total_output - current_load, p[candidate] - allowable_min[candidate])\n            p[candidate] -= decrease\n            total_output -= decrease\n\n    return np.vstack((u, p))",
          "from": null,
          "gap_power_rate": 0.0056459616,
          "gap_price_rate": 0.00847472,
          "fitness": 0.0070603408
     },
     {
          "name": "enhanced_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints, with forecast-aware adjustment for flexible unit commitment\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units by two-period effective cost (including startup costs and forecasted load)\n5. Perform economic dispatch using iterative lambda adjustment within feasible output ranges\n6. Handle infeasible cases by setting outputs to minimum or maximum feasible values\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < toff_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_must_min = 0\n    total_must_max = 0\n    must_ranges = []\n    for i in must_run:\n        unit = units_info[i]\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        \n        p_low = max(pmin, p0 - pdown)\n        p_high = min(pmax, p0 + pup)\n        total_must_min += p_low\n        total_must_max += p_high\n        must_ranges.append((p_low, p_high))\n    \n    if current_load <= total_must_min:\n        schedules = np.zeros((2, n_units))\n        for idx, i in enumerate(must_run):\n            schedules[0, i] = 1\n            schedules[1, i] = must_ranges[idx][0]\n        return schedules\n    \n    flex_info = []\n    for i in flexible:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        \n        if u0 == 1:\n            p_low = max(pmin, p0 - pdown)\n            p_high = min(pmax, p0 + pup)\n        else:\n            p_low = pmin\n            p_high = min(pmax, pstart)\n        \n        p_avg = (current_load + forecast_load) / 2\n        p_avg = max(pmin, min(pmax, p_avg))\n        \n        if u0 == 0:\n            cost = (s + 2*a + 2*b*p_avg + 2*c*p_avg**2) / (2*p_avg) if p_avg > 0 else float('inf')\n        else:\n            cost = (a + b*p_avg + c*p_avg**2) / p_avg if p_avg > 0 else float('inf')\n        \n        flex_info.append((i, cost, p_low, p_high))\n    \n    flex_info.sort(key=lambda x: x[1])\n    committed_flex = []\n    total_cap = total_must_max\n    for unit_info in flex_info:\n        if total_cap >= current_load:\n            break\n        committed_flex.append(unit_info[0])\n        total_cap += unit_info[3]\n    \n    committed_units = must_run + committed_flex\n    p_mins = []\n    p_maxs = []\n    a_list = []\n    b_list = []\n    c_list = []\n    \n    for i in committed_units:\n        unit = units_info[i]\n        if i in must_run:\n            idx = must_run.index(i)\n            p_mins.append(must_ranges[idx][0])\n            p_maxs.append(must_ranges[idx][1])\n        else:\n            for info in flex_info:\n                if info[0] == i:\n                    p_mins.append(info[2])\n                    p_maxs.append(info[3])\n                    break\n        a_list.append(unit['a_i'])\n        b_list.append(unit['b_i'])\n        c_list.append(unit['c_i'])\n    \n    total_min = sum(p_mins)\n    total_max = sum(p_maxs)\n    \n    if current_load <= total_min:\n        p_out = p_mins\n    elif current_load >= total_max:\n        p_out = p_maxs\n    else:\n        low_lam = min(b_list[i] + 2*c_list[i]*p_mins[i] for i in range(len(committed_units)))\n        high_lam = max(b_list[i] + 2*c_list[i]*p_maxs[i] for i in range(len(committed_units)))\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i in range(len(committed_units)):\n                if c_list[i] == 0:\n                    p_val = p_maxs[i] if mid_lam >= b_list[i] else p_mins[i]\n                else:\n                    p_val = (mid_lam - b_list[i]) / (2 * c_list[i])\n                    p_val = max(p_mins[i], min(p_maxs[i], p_val))\n                total_p += p_val\n            \n            if total_p < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        p_out = []\n        for i in range(len(committed_units)):\n            if c_list[i] == 0:\n                p_val = p_maxs[i] if mid_lam >= b_list[i] else p_mins[i]\n            else:\n                p_val = (mid_lam - b_list[i]) / (2 * c_list[i])\n                p_val = max(p_mins[i], min(p_maxs[i], p_val))\n            p_out.append(p_val)\n    \n    schedules = np.zeros((2, n_units))\n    for i, unit_id in enumerate(committed_units):\n        schedules[0, unit_id] = 1\n        schedules[1, unit_id] = p_out[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0055738226,
          "gap_price_rate": 0.009205764,
          "fitness": 0.0073897933
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate total feasible output range from must-run units considering ramp limits and startup/shutdown constraints\n3. If current load is below must-run minimum, set must-run units to minimum output and keep flexible units off\n4. If load exceeds must-run capacity, commit flexible units by effective average cost at midpoint output (including startup costs for offline units)\n5. Perform economic dispatch using marginal cost sorting with ramp-aware output adjustment\n6. Fine-tune outputs to exactly match load using bisection adjustment while respecting all constraints\n7. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and determine feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Determine must-run status\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                continue\n        # Determine must-off status\n        if unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n            continue\n        flexible.append(i)\n    \n    # Calculate feasible ranges for all units\n    for i in range(n_units):\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Handle must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        u[i] = 1\n        total_min_must += feasible_min[i]\n        total_max_must += feasible_max[i]\n    \n    # Check if load can be met with must-run units only\n    if current_load <= total_max_must:\n        # Distribute load to must-run units using economic dispatch\n        committed = must_run.copy()\n        remaining_load = current_load\n        # Set initial outputs to minimum\n        for i in committed:\n            p[i] = feasible_min[i]\n            remaining_load -= p[i]\n        \n        # Economic dispatch using marginal cost sorting\n        while remaining_load > 1e-6:\n            best_unit = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_add = feasible_max[best_unit] - p[best_unit]\n            add = min(remaining_load, max_add)\n            p[best_unit] += add\n            remaining_load -= add\n        \n        return np.array([u, p])\n    \n    # Commit flexible units based on effective average cost\n    flex_costs = []\n    for i in flexible:\n        unit = units[i]\n        mid_point = (feasible_min[i] + feasible_max[i]) / 2\n        if unit['u_i_0'] == 0:\n            eff_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * mid_point + \n                       unit['c_i'] * mid_point**2) / mid_point\n        else:\n            eff_cost = (unit['a_i'] + unit['b_i'] * mid_point + \n                       unit['c_i'] * mid_point**2) / mid_point\n        flex_costs.append((eff_cost, i))\n    \n    flex_costs.sort(key=lambda x: x[0])\n    committed = must_run.copy()\n    total_max = total_max_must\n    \n    # Commit flexible units until capacity meets load\n    for cost, i in flex_costs:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        committed.append(i)\n        total_max += feasible_max[i]\n    \n    # Economic dispatch\n    remaining_load = current_load\n    # Set initial outputs to minimum\n    for i in committed:\n        p[i] = feasible_min[i]\n        remaining_load -= p[i]\n    \n    # Adjust outputs using marginal cost sorting\n    while abs(remaining_load) > 1e-6:\n        if remaining_load > 0:\n            # Find unit with lowest marginal cost that can increase\n            best_unit = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_add = feasible_max[best_unit] - p[best_unit]\n            add = min(remaining_load, max_add)\n            p[best_unit] += add\n            remaining_load -= add\n        else:\n            # Find unit with highest marginal cost that can decrease\n            best_unit = None\n            best_mc = -float('inf')\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc > best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_sub = p[best_unit] - feasible_min[best_unit]\n            sub = min(-remaining_load, max_sub)\n            p[best_unit] -= sub\n            remaining_load += sub\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0060965326,
          "gap_price_rate": 0.0089137153,
          "fitness": 0.007505124
     },
     {
          "name": "optimized_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using enhanced forecast-aware minimum up/down time and shutdown ramp constraints\n2. Calculate must-run output range with ramp constraints and previous states, incorporating forecasted load for flexibility adjustment\n3. If current load exceeds must-run capacity, commit flexible units using two-period effective cost with startup costs and forecast-aware output estimation\n4. Perform economic dispatch using iterative lambda adjustment within ramp-constrained feasible ranges\n5. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n6. Handle infeasible cases by forecast-aware generation maximization within constraints\n",
          "code": "import numpy as np\n\ndef optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(unit)\n        elif (unit['u_i_0'] == 0 and \n              -unit['t_i_0'] < unit['t_off_min_i']):\n            must_off.append(unit)\n        else:\n            flexible.append(unit)\n    \n    total_min_must = 0\n    total_max_must = 0\n    for unit in must_run:\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += min_out\n        total_max_must += max_out\n    \n    committed_units = must_run[:]\n    if current_load <= total_min_must:\n        for unit in must_run:\n            if unit['u_i_0'] == 1:\n                unit['p_i'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                unit['p_i'] = unit['p_min_i']\n            unit['u_i'] = 1\n        for unit in flexible + must_off:\n            unit['p_i'] = 0\n            unit['u_i'] = 0\n    else:\n        if current_load > total_max_must:\n            effective_costs = []\n            for unit in flexible:\n                if unit['u_i_0'] == 0:\n                    p1 = min(unit['p_max_i'], unit['p_start_i'])\n                    p2 = min(unit['p_max_i'], (forecast_load - total_max_must) / len(flexible))\n                    cost = (unit['s_i'] + 2*unit['a_i'] + unit['b_i']*(p1+p2) + \n                            unit['c_i']*(p1**2 + p2**2)) / (p1+p2)\n                else:\n                    p1 = unit['p_i_0'] + unit['p_up_i']\n                    p2 = min(unit['p_max_i'], (forecast_load - total_max_must) / len(flexible))\n                    cost = (2*unit['a_i'] + unit['b_i']*(p1+p2) + \n                            unit['c_i']*(p1**2 + p2**2)) / (p1+p2)\n                effective_costs.append((cost, unit))\n            \n            effective_costs.sort(key=lambda x: x[0])\n            for _, unit in effective_costs:\n                if total_max_must < current_load:\n                    committed_units.append(unit)\n                    if unit['u_i_0'] == 1:\n                        max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:\n                        max_add = min(unit['p_max_i'], unit['p_start_i'])\n                    total_max_must += max_add\n                else:\n                    break\n        \n        low_lambda = 0\n        high_lambda = 10000\n        tol = 1e-6\n        for _ in range(100):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_gen = 0\n            for unit in committed_units:\n                if unit['u_i_0'] == 1:\n                    low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    low_bound = unit['p_min_i']\n                    high_bound = min(unit['p_max_i'], unit['p_start_i'])\n                \n                p = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p = np.clip(p, low_bound, high_bound)\n                total_gen += p\n            \n            if total_gen < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            \n            if abs(high_lambda - low_lambda) < tol:\n                break\n        \n        for unit in committed_units:\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_bound = unit['p_min_i']\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            \n            p = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n            unit['p_i'] = np.clip(p, low_bound, high_bound)\n            unit['u_i'] = 1\n        \n        total_output = sum(unit['p_i'] for unit in committed_units)\n        diff = current_load - total_output\n        max_iter = 100\n        iter_count = 0\n        \n        while abs(diff) > 1e-6 and iter_count < max_iter:\n            adjust_units = []\n            for unit in committed_units:\n                if unit['u_i_0'] == 1:\n                    low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    low_bound = unit['p_min_i']\n                    high_bound = min(unit['p_max_i'], unit['p_start_i'])\n                \n                if diff > 0:\n                    room = high_bound - unit['p_i']\n                else:\n                    room = unit['p_i'] - low_bound\n                \n                if room > 0:\n                    adjust_units.append((unit, room))\n            \n            if not adjust_units:\n                break\n            \n            total_room = sum(room for _, room in adjust_units)\n            for unit, room in adjust_units:\n                adjustment = diff * (room / total_room)\n                unit['p_i'] += adjustment\n                if unit['u_i_0'] == 1:\n                    low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    low_bound = unit['p_min_i']\n                    high_bound = min(unit['p_max_i'], unit['p_start_i'])\n                unit['p_i'] = np.clip(unit['p_i'], low_bound, high_bound)\n            \n            total_output = sum(unit['p_i'] for unit in committed_units)\n            diff = current_load - total_output\n            iter_count += 1\n        \n        for unit in must_off:\n            unit['p_i'] = 0\n            unit['u_i'] = 0\n        \n        for unit in flexible:\n            if unit not in committed_units:\n                unit['p_i'] = 0\n                unit['u_i'] = 0\n    \n    schedules = np.zeros((2, n_units))\n    for i, unit in enumerate(units_info):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0013099003,
          "gap_price_rate": 0.0150723785,
          "fitness": 0.0081911394
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-on and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Sort flexible units by average cost per MW at minimum output (including startup cost).\n3. Commit must-on units and flexible units until the total maximum available power meets the load.\n4. Perform economic dispatch among committed units using marginal cost merit order within feasible ranges determined by ramp constraints.\n5. Adjust power outputs to meet the load as closely as possible.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible = [i for i in range(n_units) if i not in must_on and i not in must_off]\n    avg_costs = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        cost = s_i + a_i + b_i * p_min_i + c_i * p_min_i**2\n        avg_cost = cost / p_min_i\n        avg_costs.append(avg_cost)\n    \n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible))]\n    current_load = load[0]\n    total_max_must_on = 0\n    \n    for i in must_on:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_max_i = unit['p_max_i']\n        max_p = min(p_max_i, p_i0 + p_up_i)\n        total_max_must_on += max_p\n    \n    committed = must_on[:]\n    total_max = total_max_must_on\n    \n    for i in flexible_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_i0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_max_i = unit['p_max_i']\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_p = min(p_max_i, p_start_i)\n        total_max += max_p\n        committed.append(i)\n    \n    min_max_ranges = []\n    committed_units_info = []\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            min_p = max(p_min_i, p_i0 - p_down_i)\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            min_p = p_min_i\n            max_p = min(p_max_i, p_start_i)\n        \n        min_max_ranges.append((min_p, max_p))\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        committed_units_info.append([i, min_p, max_p, a_i, b_i, c_i])\n    \n    p_outputs = [min_p for min_p, _ in min_max_ranges]\n    total_output = sum(p_outputs)\n    \n    for idx, unit_info in enumerate(committed_units_info):\n        i, p, max_p, a, b, c = unit_info\n        committed_units_info[idx] = [i, p, max_p, a, b, c]\n    \n    while total_output < current_load:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, (i, p, max_p, a, b, c) in enumerate(committed_units_info):\n            if p < max_p:\n                marginal = b + 2 * c * p\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = idx\n        \n        if best_idx is None:\n            break\n        \n        i, p, max_p, a, b, c = committed_units_info[best_idx]\n        increase = min(current_load - total_output, max_p - p)\n        new_p = p + increase\n        committed_units_info[best_idx] = [i, new_p, max_p, a, b, c]\n        total_output += increase\n    \n    schedules = np.zeros((2, n_units))\n    for (i, p, max_p, a, b, c) in committed_units_info:\n        schedules[0, i] = 1\n        schedules[1, i] = p\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0105126155,
          "fitness": 0.0083271523
     },
     {
          "name": "hybrid_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using min up/down times and shutdown ramp constraints, considering forecasted load for commitment decisions\n2. Calculate must-run total output range considering ramp constraints and previous states\n3. If current load \u2264 must-run min, set must-run to min output and keep others off\n4. If load > must-run max, commit flexible units by effective average cost at forecast-adjusted output levels including startup costs\n5. Perform economic dispatch using marginal cost sorting within ramp-constrained feasible ranges\n6. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n7. Handle infeasible cases by adjusting commitments and maximizing generation within constraints\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u_i0 == 1 and (t_i0 < min_up or p_i0 > p_shut):\n            must_run.append(i)\n            u[i] = 1\n            min_feasible[i] = max(p_min, p_i0 - p_down)\n            max_feasible[i] = min(p_max, p_i0 + p_up)\n        elif u_i0 == 0 and abs(t_i0) < min_down:\n            must_off.append(i)\n            u[i] = 0\n            p[i] = 0\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n        else:\n            flexible.append(i)\n            if u_i0 == 1:\n                min_feasible[i] = max(p_min, p_i0 - p_down)\n                max_feasible[i] = min(p_max, p_i0 + p_up)\n            else:\n                min_feasible[i] = p_min\n                max_feasible[i] = min(p_max, p_start)\n    \n    total_min_must = sum(min_feasible[i] for i in must_run)\n    total_max_must = sum(max_feasible[i] for i in must_run)\n    \n    if current_load <= total_min_must:\n        for i in must_run:\n            p[i] = min_feasible[i]\n        return np.array([u, p])\n    \n    if current_load <= total_max_must:\n        committed = must_run\n        for i in committed:\n            p[i] = min_feasible[i]\n        remaining = current_load - sum(p[i] for i in committed)\n        units_sorted = sorted(committed, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n        for i in units_sorted:\n            if remaining <= 0:\n                break\n            available = max_feasible[i] - p[i]\n            if available > 0:\n                add = min(remaining, available)\n                p[i] += add\n                remaining -= add\n        return np.array([u, p])\n    \n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        expected_p = (current_load + forecast_load) / 2\n        expected_p = max(unit['p_min_i'], min(unit['p_max_i'], expected_p))\n        startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n        cost = (startup_cost + unit['b_i'] * expected_p + unit['c_i'] * expected_p**2) / expected_p\n        costs.append((i, cost))\n    \n    costs.sort(key=lambda x: x[1])\n    total_max = total_max_must\n    committed = must_run.copy()\n    \n    for i, _ in costs:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        committed.append(i)\n        total_max += max_feasible[i]\n    \n    for i in committed:\n        p[i] = min_feasible[i]\n    \n    remaining = current_load - sum(p[i] for i in committed)\n    if remaining < 0:\n        return np.array([u, p])\n    \n    units_sorted = sorted(committed, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n    for i in units_sorted:\n        if remaining <= 0:\n            break\n        available = max_feasible[i] - p[i]\n        if available > 0:\n            add = min(remaining, available)\n            p[i] += add\n            remaining -= add\n    \n    if remaining > 0:\n        low = 0\n        high = sum(max_feasible[i] for i in committed) - sum(min_feasible[i] for i in committed)\n        for _ in range(20):\n            mid = (low + high) / 2\n            total_output = 0\n            for i in committed:\n                additional = min(mid, max_feasible[i] - min_feasible[i])\n                total_output += min_feasible[i] + additional\n            if total_output < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        for i in committed:\n            additional = min(high, max_feasible[i] - min_feasible[i])\n            p[i] = min_feasible[i] + additional\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0062422093,
          "gap_price_rate": 0.0107972871,
          "fitness": 0.0085197482
     },
     {
          "name": "refined_enhanced_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints, with forecast-aware adjustment\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If current load \u2264 must-run minimum, set must-run units to minimum output and keep others off\n4. If load exceeds must-run capacity, commit flexible units by two-period effective cost including startup costs and forecasted load\n5. Perform economic dispatch using marginal cost sorting within feasible output ranges\n6. Fine-tune outputs using ramp-aware proportional adjustment to exactly match load\n7. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    total_min_must = 0\n    total_max_must = 0\n    must_run_ranges = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_i0 = unit['p_i_0']\n        \n        min_out = max(p_min, p_i0 - p_up)\n        max_out = min(p_max, p_i0 + p_up)\n        total_min_must += min_out\n        total_max_must += max_out\n        must_run_ranges.append((min_out, max_out))\n    \n    if current_load <= total_min_must:\n        for idx, i in enumerate(must_run):\n            u[i] = 1\n            p[i] = must_run_ranges[idx][0]\n        return np.array([u, p])\n    \n    committed = set(must_run)\n    flex_costs = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        p_max = unit['p_max_i']\n        u_i0 = unit['u_i_0']\n        \n        effective_cost = (s * (1 - u_i0) + 2*a + b*2*p_max + c*2*p_max**2) / (2*p_max)\n        flex_costs.append((i, effective_cost))\n    \n    flex_costs.sort(key=lambda x: x[1])\n    \n    total_max = total_max_must\n    for i, _ in flex_costs:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_out = unit['p_start_i']\n        total_max += max_out\n        committed.add(i)\n    \n    committed = list(committed)\n    ranges = []\n    for i in committed:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        if unit['u_i_0'] == 1:\n            min_out = max(p_min, p_i0 - p_down)\n            max_out = min(p_max, p_i0 + p_up)\n        else:\n            min_out = p_min\n            max_out = unit['p_start_i']\n        ranges.append((i, min_out, max_out))\n    \n    total_min = sum(min_out for _, min_out, _ in ranges)\n    total_max = sum(max_out for _, _, max_out in ranges)\n    \n    if current_load < total_min:\n        for i, min_out, _ in ranges:\n            u[i] = 1\n            p[i] = min_out\n        return np.array([u, p])\n    \n    if current_load > total_max:\n        for i, _, max_out in ranges:\n            u[i] = 1\n            p[i] = max_out\n        return np.array([u, p])\n    \n    remaining = current_load - total_min\n    unit_list = []\n    for i, min_out, max_out in ranges:\n        marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*min_out\n        unit_list.append((i, min_out, max_out, marginal))\n    \n    unit_list.sort(key=lambda x: x[3])\n    \n    for idx, (i, min_out, max_out, _) in enumerate(unit_list):\n        allocatable = max_out - min_out\n        if remaining <= allocatable:\n            p[i] = min_out + remaining\n            remaining = 0\n        else:\n            p[i] = max_out\n            remaining -= allocatable\n    \n    if abs(remaining) > 1e-6:\n        total_ramp = 0\n        ramp_weights = []\n        for i, min_out, max_out, _ in unit_list:\n            if p[i] < max_out:\n                ramp_up = units_info[i]['p_up_i']\n                weight = ramp_up\n            elif p[i] > min_out:\n                ramp_down = units_info[i]['p_down_i']\n                weight = ramp_down\n            else:\n                weight = 0\n            total_ramp += weight\n            ramp_weights.append(weight)\n        \n        if total_ramp > 0:\n            for idx, (i, min_out, max_out, _) in enumerate(unit_list):\n                adjustment = remaining * ramp_weights[idx] / total_ramp\n                new_p = p[i] + adjustment\n                p[i] = np.clip(new_p, min_out, max_out)\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0066823052,
          "gap_price_rate": 0.0110546795,
          "fitness": 0.0088684923
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using min up/down times and shutdown ramp constraints\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If load < must-run min, set must-run to min output and keep others off\n4. If load > must-run max, commit flexible units by effective average cost at midpoint output including startup costs\n5. Perform economic dispatch using marginal cost sorting within feasible ranges\n6. Adjust outputs iteratively to exactly match load while respecting all constraints\n7. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Calculate must-run output range\n    must_run_min = 0\n    must_run_max = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            must_run_min += p_min\n            must_run_max += p_max\n    \n    # Handle low load case\n    if current_load <= must_run_min:\n        for i, unit in enumerate(units_info):\n            if must_run[i]:\n                if unit['u_i_0'] == 1:\n                    p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p[i] = unit['p_min_i']\n                u[i] = 1\n        return np.array([u, p])\n    \n    # Commit flexible units if needed\n    if current_load > must_run_max:\n        # Calculate effective costs\n        costs = []\n        for i, unit in enumerate(units_info):\n            if flexible[i] and not must_off[i]:\n                p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                avg_cost = (unit['a_i'] + unit['b_i'] * p_mid + \n                           unit['c_i'] * p_mid**2 + startup_cost) / p_mid\n                costs.append((avg_cost, i))\n        \n        # Sort by cost and commit\n        costs.sort(key=lambda x: x[0])\n        total_max = must_run_max\n        for cost, idx in costs:\n            if total_max >= current_load:\n                break\n            u[idx] = 1\n            if units_info[idx]['u_i_0'] == 1:\n                p_max = min(units_info[idx]['p_max_i'], \n                           units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            else:\n                p_max = min(units_info[idx]['p_max_i'], \n                           units_info[idx]['p_start_i'])\n            total_max += p_max\n    \n    # Economic dispatch\n    committed_idxs = [i for i in range(n_units) if must_run[i] or u[i] == 1]\n    \n    # Initialize outputs\n    for i in committed_idxs:\n        if must_run[i] or u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                p[i] = max(units_info[i]['p_min_i'], \n                          units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            else:\n                p[i] = units_info[i]['p_min_i']\n            u[i] = 1\n    \n    remaining_load = current_load - sum(p)\n    \n    # Merit order dispatch\n    while abs(remaining_load) > 1e-6:\n        # Calculate marginal costs\n        margins = []\n        for i in committed_idxs:\n            if remaining_load > 0:\n                if units_info[i]['u_i_0'] == 1:\n                    p_max = min(units_info[i]['p_max_i'], \n                               units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    p_max = min(units_info[i]['p_max_i'], \n                               units_info[i]['p_start_i'])\n                if p[i] < p_max:\n                    margin = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    margins.append((margin, i, 1))\n            else:\n                p_min = max(units_info[i]['p_min_i'], \n                           units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                if p[i] > p_min:\n                    margin = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    margins.append((margin, i, -1))\n        \n        if not margins:\n            break\n        \n        # Sort by marginal cost\n        if remaining_load > 0:\n            margins.sort(key=lambda x: x[0])\n        else:\n            margins.sort(key=lambda x: x[0], reverse=True)\n        \n        # Adjust most economical unit\n        margin, idx, direction = margins[0]\n        if direction == 1:\n            p_max = min(units_info[idx]['p_max_i'], \n                       units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            delta = min(remaining_load, p_max - p[idx])\n        else:\n            p_min = max(units_info[idx]['p_min_i'], \n                       units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            delta = max(remaining_load, p_min - p[idx])\n        \n        p[idx] += delta\n        remaining_load -= delta\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0060421123,
          "gap_price_rate": 0.0117916361,
          "fitness": 0.0089168742
     }
]