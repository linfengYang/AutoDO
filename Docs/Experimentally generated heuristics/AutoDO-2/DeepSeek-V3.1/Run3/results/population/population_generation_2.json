[
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp limits\n2. Calculate total output range from must-run units\n3. If load is below must-run minimum, set must-run units to minimum output\n4. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs\n5. Perform economic dispatch among committed units using marginal cost sorting\n6. Adjust outputs to meet load exactly while respecting ramp constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    \n    allowable_min = np.zeros(n_units)\n    allowable_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            allowable_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            allowable_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            allowable_min[i] = unit['p_min_i']\n            allowable_max[i] = unit['p_start_i']\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    total_min = np.sum(allowable_min[must_run])\n    total_max = np.sum(allowable_max[must_run])\n    \n    if current_load <= total_min:\n        u[must_run] = 1\n        p[must_run] = allowable_min[must_run]\n    else:\n        u[must_run] = 1\n        p[must_run] = allowable_max[must_run]\n        remaining_load = current_load - total_max\n        \n        flexible_idx = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n        cost_rates = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            cost_rates.append((cost / allowable_max[i], i))\n        \n        cost_rates.sort(key=lambda x: x[0])\n        for _, idx in cost_rates:\n            if remaining_load <= 0:\n                break\n            u[idx] = 1\n            alloc = min(remaining_load, allowable_max[idx])\n            p[idx] = alloc\n            remaining_load -= alloc\n\n    committed = np.where(u == 1)[0]\n    for i in committed:\n        p[i] = allowable_min[i]\n    \n    total_output = np.sum(p)\n    while abs(total_output - current_load) > 1e-6:\n        if total_output < current_load:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < allowable_max[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(current_load - total_output, allowable_max[candidate] - p[candidate])\n            p[candidate] += increase\n            total_output += increase\n        else:\n            candidate = -1\n            max_mc = -float('inf')\n            for i in committed:\n                if p[i] > allowable_min[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            decrease = min(total_output - current_load, p[candidate] - allowable_min[candidate])\n            p[candidate] -= decrease\n            total_output -= decrease\n\n    return np.vstack((u, p))",
          "from": null,
          "gap_power_rate": 0.0056459616,
          "gap_price_rate": 0.00847472,
          "fitness": 0.0070603408
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate total feasible output range from must-run units considering ramp limits and startup/shutdown constraints\n3. If current load is below must-run minimum, set must-run units to minimum output and keep flexible units off\n4. If load exceeds must-run capacity, commit flexible units by effective average cost at midpoint output (including startup costs for offline units)\n5. Perform economic dispatch using marginal cost sorting with ramp-aware output adjustment\n6. Fine-tune outputs to exactly match load using bisection adjustment while respecting all constraints\n7. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and determine feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Determine must-run status\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                continue\n        # Determine must-off status\n        if unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n            continue\n        flexible.append(i)\n    \n    # Calculate feasible ranges for all units\n    for i in range(n_units):\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Handle must-run units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        u[i] = 1\n        total_min_must += feasible_min[i]\n        total_max_must += feasible_max[i]\n    \n    # Check if load can be met with must-run units only\n    if current_load <= total_max_must:\n        # Distribute load to must-run units using economic dispatch\n        committed = must_run.copy()\n        remaining_load = current_load\n        # Set initial outputs to minimum\n        for i in committed:\n            p[i] = feasible_min[i]\n            remaining_load -= p[i]\n        \n        # Economic dispatch using marginal cost sorting\n        while remaining_load > 1e-6:\n            best_unit = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_add = feasible_max[best_unit] - p[best_unit]\n            add = min(remaining_load, max_add)\n            p[best_unit] += add\n            remaining_load -= add\n        \n        return np.array([u, p])\n    \n    # Commit flexible units based on effective average cost\n    flex_costs = []\n    for i in flexible:\n        unit = units[i]\n        mid_point = (feasible_min[i] + feasible_max[i]) / 2\n        if unit['u_i_0'] == 0:\n            eff_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * mid_point + \n                       unit['c_i'] * mid_point**2) / mid_point\n        else:\n            eff_cost = (unit['a_i'] + unit['b_i'] * mid_point + \n                       unit['c_i'] * mid_point**2) / mid_point\n        flex_costs.append((eff_cost, i))\n    \n    flex_costs.sort(key=lambda x: x[0])\n    committed = must_run.copy()\n    total_max = total_max_must\n    \n    # Commit flexible units until capacity meets load\n    for cost, i in flex_costs:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        committed.append(i)\n        total_max += feasible_max[i]\n    \n    # Economic dispatch\n    remaining_load = current_load\n    # Set initial outputs to minimum\n    for i in committed:\n        p[i] = feasible_min[i]\n        remaining_load -= p[i]\n    \n    # Adjust outputs using marginal cost sorting\n    while abs(remaining_load) > 1e-6:\n        if remaining_load > 0:\n            # Find unit with lowest marginal cost that can increase\n            best_unit = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_add = feasible_max[best_unit] - p[best_unit]\n            add = min(remaining_load, max_add)\n            p[best_unit] += add\n            remaining_load -= add\n        else:\n            # Find unit with highest marginal cost that can decrease\n            best_unit = None\n            best_mc = -float('inf')\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    mc = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    if mc > best_mc:\n                        best_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            max_sub = p[best_unit] - feasible_min[best_unit]\n            sub = min(-remaining_load, max_sub)\n            p[best_unit] -= sub\n            remaining_load += sub\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0060965326,
          "gap_price_rate": 0.0089137153,
          "fitness": 0.007505124
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-on and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Sort flexible units by average cost per MW at minimum output (including startup cost).\n3. Commit must-on units and flexible units until the total maximum available power meets the load.\n4. Perform economic dispatch among committed units using marginal cost merit order within feasible ranges determined by ramp constraints.\n5. Adjust power outputs to meet the load as closely as possible.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible = [i for i in range(n_units) if i not in must_on and i not in must_off]\n    avg_costs = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        cost = s_i + a_i + b_i * p_min_i + c_i * p_min_i**2\n        avg_cost = cost / p_min_i\n        avg_costs.append(avg_cost)\n    \n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible))]\n    current_load = load[0]\n    total_max_must_on = 0\n    \n    for i in must_on:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_max_i = unit['p_max_i']\n        max_p = min(p_max_i, p_i0 + p_up_i)\n        total_max_must_on += max_p\n    \n    committed = must_on[:]\n    total_max = total_max_must_on\n    \n    for i in flexible_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_i0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_max_i = unit['p_max_i']\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_p = min(p_max_i, p_start_i)\n        total_max += max_p\n        committed.append(i)\n    \n    min_max_ranges = []\n    committed_units_info = []\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            min_p = max(p_min_i, p_i0 - p_down_i)\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            min_p = p_min_i\n            max_p = min(p_max_i, p_start_i)\n        \n        min_max_ranges.append((min_p, max_p))\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        committed_units_info.append([i, min_p, max_p, a_i, b_i, c_i])\n    \n    p_outputs = [min_p for min_p, _ in min_max_ranges]\n    total_output = sum(p_outputs)\n    \n    for idx, unit_info in enumerate(committed_units_info):\n        i, p, max_p, a, b, c = unit_info\n        committed_units_info[idx] = [i, p, max_p, a, b, c]\n    \n    while total_output < current_load:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, (i, p, max_p, a, b, c) in enumerate(committed_units_info):\n            if p < max_p:\n                marginal = b + 2 * c * p\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = idx\n        \n        if best_idx is None:\n            break\n        \n        i, p, max_p, a, b, c = committed_units_info[best_idx]\n        increase = min(current_load - total_output, max_p - p)\n        new_p = p + increase\n        committed_units_info[best_idx] = [i, new_p, max_p, a, b, c]\n        total_output += increase\n    \n    schedules = np.zeros((2, n_units))\n    for (i, p, max_p, a, b, c) in committed_units_info:\n        schedules[0, i] = 1\n        schedules[1, i] = p\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0105126155,
          "fitness": 0.0083271523
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using min up/down times and shutdown ramp constraints\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If load < must-run min, set must-run to min output and keep others off\n4. If load > must-run max, commit flexible units by effective average cost at midpoint output including startup costs\n5. Perform economic dispatch using marginal cost sorting within feasible ranges\n6. Adjust outputs iteratively to exactly match load while respecting all constraints\n7. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Calculate must-run output range\n    must_run_min = 0\n    must_run_max = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            must_run_min += p_min\n            must_run_max += p_max\n    \n    # Handle low load case\n    if current_load <= must_run_min:\n        for i, unit in enumerate(units_info):\n            if must_run[i]:\n                if unit['u_i_0'] == 1:\n                    p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p[i] = unit['p_min_i']\n                u[i] = 1\n        return np.array([u, p])\n    \n    # Commit flexible units if needed\n    if current_load > must_run_max:\n        # Calculate effective costs\n        costs = []\n        for i, unit in enumerate(units_info):\n            if flexible[i] and not must_off[i]:\n                p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n                startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n                avg_cost = (unit['a_i'] + unit['b_i'] * p_mid + \n                           unit['c_i'] * p_mid**2 + startup_cost) / p_mid\n                costs.append((avg_cost, i))\n        \n        # Sort by cost and commit\n        costs.sort(key=lambda x: x[0])\n        total_max = must_run_max\n        for cost, idx in costs:\n            if total_max >= current_load:\n                break\n            u[idx] = 1\n            if units_info[idx]['u_i_0'] == 1:\n                p_max = min(units_info[idx]['p_max_i'], \n                           units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            else:\n                p_max = min(units_info[idx]['p_max_i'], \n                           units_info[idx]['p_start_i'])\n            total_max += p_max\n    \n    # Economic dispatch\n    committed_idxs = [i for i in range(n_units) if must_run[i] or u[i] == 1]\n    \n    # Initialize outputs\n    for i in committed_idxs:\n        if must_run[i] or u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                p[i] = max(units_info[i]['p_min_i'], \n                          units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            else:\n                p[i] = units_info[i]['p_min_i']\n            u[i] = 1\n    \n    remaining_load = current_load - sum(p)\n    \n    # Merit order dispatch\n    while abs(remaining_load) > 1e-6:\n        # Calculate marginal costs\n        margins = []\n        for i in committed_idxs:\n            if remaining_load > 0:\n                if units_info[i]['u_i_0'] == 1:\n                    p_max = min(units_info[i]['p_max_i'], \n                               units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    p_max = min(units_info[i]['p_max_i'], \n                               units_info[i]['p_start_i'])\n                if p[i] < p_max:\n                    margin = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    margins.append((margin, i, 1))\n            else:\n                p_min = max(units_info[i]['p_min_i'], \n                           units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                if p[i] > p_min:\n                    margin = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    margins.append((margin, i, -1))\n        \n        if not margins:\n            break\n        \n        # Sort by marginal cost\n        if remaining_load > 0:\n            margins.sort(key=lambda x: x[0])\n        else:\n            margins.sort(key=lambda x: x[0], reverse=True)\n        \n        # Adjust most economical unit\n        margin, idx, direction = margins[0]\n        if direction == 1:\n            p_max = min(units_info[idx]['p_max_i'], \n                       units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            delta = min(remaining_load, p_max - p[idx])\n        else:\n            p_min = max(units_info[idx]['p_min_i'], \n                       units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            delta = max(remaining_load, p_min - p[idx])\n        \n        p[idx] += delta\n        remaining_load -= delta\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0060421123,
          "gap_price_rate": 0.0117916361,
          "fitness": 0.0089168742
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Commit must-run units and calculate their total feasible output range.\n3. Sort available units by average cost per MW at maximum output (including startup cost if offline).\n4. Commit additional cheapest units until total maximum capacity meets load.\n5. Perform economic dispatch using feasible output ranges and marginal cost sorting.\n6. Adjust outputs to exactly match load while respecting constraints.\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = [0] * n_units\n    p = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run[i] = True\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off[i] = True\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            \n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            p_max = unit['p_max_i']\n            s = unit['s_i']\n            u_i0 = unit['u_i_0']\n            \n            if u_i0 == 0:\n                total_cost = a + b * p_max + c * p_max**2 + s\n            else:\n                total_cost = a + b * p_max + c * p_max**2\n            avg_cost = total_cost / p_max\n            available_units.append((i, avg_cost, u_i0))\n            \n    available_units.sort(key=lambda x: x[1])\n    \n    total_max_must_run = 0\n    for i in range(n_units):\n        if must_run[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                UB = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_must_run += UB\n            \n    total_max = total_max_must_run\n    for idx, _, u_i0 in available_units:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        unit = units_info[idx]\n        if u_i0 == 1:\n            UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            UB = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += UB\n        \n    LB_arr = [0] * n_units\n    UB_arr = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                LB_arr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                UB_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                LB_arr[i] = unit['p_min_i']\n                UB_arr[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p[i] = 0\n            \n    total_output = sum(LB_arr)\n    remaining_load = current_load - total_output\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    units_with_capacity = []\n    for i in committed_indices:\n        if LB_arr[i] < UB_arr[i]:\n            units_with_capacity.append(i)\n            \n    units_with_capacity.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * LB_arr[i])\n    \n    for i in units_with_capacity:\n        if remaining_load <= 0:\n            break\n        available = UB_arr[i] - LB_arr[i]\n        if remaining_load <= available:\n            p[i] = LB_arr[i] + remaining_load\n            remaining_load = 0\n        else:\n            p[i] = UB_arr[i]\n            remaining_load -= available\n            \n    for i in committed_indices:\n        if p[i] == 0:\n            p[i] = LB_arr[i]\n            \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0066823052,
          "gap_price_rate": 0.0112014253,
          "fitness": 0.0089418652
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Set must-run units to online and must-off units to offline\n3. Calculate total feasible output range from must-run units considering ramp constraints\n4. If load is below must-run minimum, set must-run units to minimum output and return\n5. Sort flexible units by effective average cost at midpoint output including startup costs\n6. Commit flexible units in cost order until capacity meets load, respecting ramp constraints\n7. Perform economic dispatch using marginal cost sorting within feasible output ranges\n8. Fine-tune outputs to exactly match load while respecting all constraints\n9. Handle infeasible cases by adjusting commitments and outputs\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run.append(i)\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min = 0\n    total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n        \n    if current_load <= total_min:\n        for i in must_run:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p[i] = unit['p_min_i']\n        return np.array([u, p])\n    \n    def avg_cost(i):\n        unit = units_info[i]\n        p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n        if unit['u_i_0'] == 0:\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * p_mid**2) / p_mid\n        else:\n            return (unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * p_mid**2) / p_mid\n            \n    flexible.sort(key=avg_cost)\n    \n    committed = must_run.copy()\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_p\n        committed.append(i)\n        u[i] = 1\n        if total_max >= current_load:\n            break\n            \n    min_outs = []\n    max_outs = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        min_outs.append(min_out)\n        max_outs.append(max_out)\n        \n    total_min = sum(min_outs)\n    total_max = sum(max_outs)\n    \n    if current_load <= total_min:\n        for idx, i in enumerate(committed):\n            p[i] = min_outs[idx]\n        return np.array([u, p])\n        \n    if current_load >= total_max:\n        for idx, i in enumerate(committed):\n            p[i] = max_outs[idx]\n        return np.array([u, p])\n        \n    remaining = current_load - total_min\n    outputs = min_outs.copy()\n    \n    marginal_costs = []\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        marginal_costs.append(2 * unit['c_i'] * outputs[idx] + unit['b_i'])\n        \n    while remaining > 0:\n        min_mc = float('inf')\n        min_idx = -1\n        for idx, i in enumerate(committed):\n            if outputs[idx] < max_outs[idx] and marginal_costs[idx] < min_mc:\n                min_mc = marginal_costs[idx]\n                min_idx = idx\n                \n        if min_idx == -1:\n            break\n            \n        unit = units_info[committed[min_idx]]\n        increase = min(remaining, max_outs[min_idx] - outputs[min_idx])\n        outputs[min_idx] += increase\n        remaining -= increase\n        marginal_costs[min_idx] = 2 * unit['c_i'] * outputs[min_idx] + unit['b_i']\n        \n    for idx, i in enumerate(committed):\n        p[i] = outputs[idx]\n        \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0073687584,
          "gap_price_rate": 0.0185538627,
          "fitness": 0.0129613106
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories considering minimum up/down times and shutdown ramp constraints\n2. Calculate must-run total output range and handle underload scenarios by adjusting must-run units\n3. Sort flexible units by effective average cost at forecast-aware output levels including startup costs\n4. Commit flexible units iteratively while ensuring total minimum generation doesn't exceed load\n5. Perform economic dispatch using marginal cost sorting within ramp-constrained feasible ranges\n6. Fine-tune outputs to exactly match load using balanced adjustment between over- and under-generation\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, t_i_0, p_i_0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_up_i, p_down_i = unit['p_up_i'], unit['p_down_i']\n        p_start_i, p_shut_i = unit['p_start_i'], unit['p_shut_i']\n        t_on_min_i, t_off_min_i = unit['t_on_min_i'], unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n                continue\n        else:\n            if t_i_0 > -t_off_min_i:\n                must_off.append(i)\n                continue\n                \n        flexible.append(i)\n    \n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += low\n        total_max_must += high\n    \n    if current_load <= total_min_must:\n        remaining_load = current_load\n        for i in must_run:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low = unit['p_min_i']\n            p[i] = low\n            remaining_load -= low\n        return np.array([u, p])\n    \n    flexible_units = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i, b_i, c_i = unit['a_i'], unit['b_i'], unit['c_i']\n        u_i_0, p_i_0 = unit['u_i_0'], unit['p_i_0']\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        s_i = unit['s_i']\n        \n        mid_output = (p_min_i + p_max_i) / 2\n        if forecast_load > current_load:\n            effective_output = mid_output * 2\n        else:\n            effective_output = mid_output\n            \n        if u_i_0 == 0:\n            cost_per_mw = (s_i + a_i + b_i * effective_output + c_i * effective_output**2) / effective_output\n        else:\n            cost_per_mw = (a_i + b_i * effective_output + c_i * effective_output**2) / effective_output\n            \n        flexible_units.append((i, cost_per_mw))\n    \n    flexible_units.sort(key=lambda x: x[1])\n    \n    total_max = total_max_must\n    total_min = total_min_must\n    committed_flexible = []\n    \n    for i, _ in flexible_units:\n        unit = units_info[i]\n        p_min_i, p_max_i = unit['p_min_i'], unit['p_max_i']\n        p_start_i = unit['p_start_i']\n        \n        if unit['u_i_0'] == 1:\n            unit_min = max(p_min_i, unit['p_i_0'] - unit['p_down_i'])\n            unit_max = min(p_max_i, unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit_min = p_min_i\n            unit_max = min(p_max_i, p_start_i)\n        \n        if total_min + unit_min > current_load:\n            continue\n            \n        total_min += unit_min\n        total_max += unit_max\n        u[i] = 1\n        committed_flexible.append(i)\n        \n        if total_max >= current_load:\n            break\n    \n    committed_units = must_run + committed_flexible\n    ranges = []\n    for i in committed_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((low, high))\n    \n    total_low = sum(low for low, high in ranges)\n    total_high = sum(high for low, high in ranges)\n    \n    if total_low > current_load:\n        for idx, i in enumerate(committed_units):\n            p[i] = ranges[idx][0]\n        return np.array([u, p])\n    \n    if total_high < current_load:\n        for idx, i in enumerate(committed_units):\n            p[i] = ranges[idx][1]\n        return np.array([u, p])\n    \n    allocations = [low for low, high in ranges]\n    remaining = current_load - total_low\n    \n    unit_costs = []\n    for idx, i in enumerate(committed_units):\n        unit = units_info[i]\n        low, high = ranges[idx]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n        unit_costs.append((idx, marginal_cost, low, high))\n    \n    while remaining > 0:\n        unit_costs.sort(key=lambda x: x[1])\n        for j in range(len(unit_costs)):\n            idx, cost, low, high = unit_costs[j]\n            i = committed_units[idx]\n            unit = units_info[i]\n            current_alloc = allocations[idx]\n            if current_alloc < high:\n                increase = min(remaining, high - current_alloc)\n                allocations[idx] += increase\n                remaining -= increase\n                new_marginal = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n                unit_costs[j] = (idx, new_marginal, low, high)\n                if remaining == 0:\n                    break\n    \n    for idx, i in enumerate(committed_units):\n        p[i] = allocations[idx]\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0075872624,
          "gap_price_rate": 0.0191500927,
          "fitness": 0.0133686776
     },
     {
          "name": "commit_units_rolling_improved",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Set must-run units to online and must-off units to offline\n3. Calculate total feasible output range from must-run units considering ramp constraints\n4. If load is below must-run minimum, set must-run units to minimum output\n5. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs and ramp limits\n6. Perform economic dispatch using marginal cost sorting with feasible output ranges\n7. Adjust outputs iteratively to meet load exactly while respecting all constraints\n8. Handle infeasible cases by maximizing generation within constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_improved(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_schedule = np.zeros(n_units)\n    p_schedule = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u_schedule[i] = 1\n    for i in must_off:\n        u_schedule[i] = 0\n        p_schedule[i] = 0\n\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_must += low\n        total_max_must += high\n\n    if current_load <= total_min_must:\n        for i in must_run:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_schedule[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_schedule[i] = unit['p_min_i']\n        return np.array([u_schedule, p_schedule])\n\n    scores = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n            score = cost / unit['p_max_i']\n        else:\n            cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n            score = cost / unit['p_max_i']\n        scores.append(score)\n    \n    sorted_flex = [x for _, x in sorted(zip(scores, flexible))]\n    total_max = total_max_must\n    committed_flex = []\n    for i in sorted_flex:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += high_i\n        u_schedule[i] = 1\n        committed_flex.append(i)\n        if total_max >= current_load:\n            break\n\n    committed = must_run + committed_flex\n    low_list = []\n    high_list = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_list.append(low_i)\n        high_list.append(high_i)\n    \n    total_low = sum(low_list)\n    total_high = sum(high_list)\n    \n    if current_load <= total_low:\n        for idx, i in enumerate(committed):\n            p_schedule[i] = low_list[idx]\n        return np.array([u_schedule, p_schedule])\n    \n    if current_load >= total_high:\n        for idx, i in enumerate(committed):\n            p_schedule[i] = high_list[idx]\n        return np.array([u_schedule, p_schedule])\n    \n    current_outs = low_list[:]\n    remaining = current_load - total_low\n    \n    while remaining > 1e-5:\n        min_marginal = float('inf')\n        candidate = None\n        for idx, i in enumerate(committed):\n            if current_outs[idx] < high_list[idx]:\n                unit = units_info[i]\n                marginal = unit['b_i'] + 2 * unit['c_i'] * current_outs[idx]\n                if marginal < min_marginal:\n                    min_marginal = marginal\n                    candidate = idx\n        if candidate is None:\n            break\n        increase = min(remaining, high_list[candidate] - current_outs[candidate])\n        current_outs[candidate] += increase\n        remaining -= increase\n    \n    for idx, i in enumerate(committed):\n        p_schedule[i] = current_outs[idx]\n    \n    return np.array([u_schedule, p_schedule])",
          "from": "mutation",
          "gap_power_rate": 0.0078042165,
          "gap_price_rate": 0.019561841,
          "fitness": 0.0136830287
     },
     {
          "name": "enhanced_rolling_priority_ed",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories considering minimum up/down times, shutdown ramp constraints, and current state\n2. Calculate feasible output ranges for must-run units using ramp limits and startup/shutdown constraints\n3. If must-run units' minimum output exceeds load, set them to minimum output and adjust using marginal cost sorting\n4. Sort flexible units by effective average cost (including startup costs if offline) at midpoint output\n5. Commit flexible units in cost order until total maximum capacity meets load with dynamic reserve margin\n6. Perform economic dispatch using iterative lambda adjustment with ramp-aware feasible ranges\n7. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n8. Validate minimum runtime constraints and adjust commitments if necessary\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_priority_ed(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate must-run output ranges\n    must_run_outputs = []\n    for i in must_run:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        must_run_outputs.append((p_min, p_max))\n    \n    total_must_run_min = sum([p_min for p_min, _ in must_run_outputs])\n    total_must_run_max = sum([p_max for _, p_max in must_run_outputs])\n    \n    # Handle must-run overgeneration\n    if total_must_run_min > current_load:\n        for idx, i in enumerate(must_run):\n            p_min, _ = must_run_outputs[idx]\n            p[i] = p_min\n            u[i] = 1\n        remaining_load = current_load - total_must_run_min\n        # Adjust using marginal cost sorting\n        committed = must_run.copy()\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n            marginal_costs.append((i, marginal_cost))\n        marginal_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in marginal_costs:\n            if remaining_load >= 0:\n                break\n            unit = units[i]\n            reduction = min(-remaining_load, p[i] - must_run_outputs[must_run.index(i)][0])\n            p[i] -= reduction\n            remaining_load += reduction\n        return np.array([u, p])\n    \n    # Sort flexible units by effective average cost\n    def effective_cost(i):\n        unit = units[i]\n        mid_output = (unit['p_min_i'] + unit['p_max_i']) / 2\n        if unit['u_i_0'] == 0:\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * mid_output + unit['c_i'] * mid_output**2) / mid_output\n        return (unit['a_i'] + unit['b_i'] * mid_output + unit['c_i'] * mid_output**2) / mid_output\n    \n    flexible.sort(key=effective_cost)\n    \n    # Commit flexible units\n    committed = must_run.copy()\n    total_max = total_must_run_max\n    reserve_margin = current_load * 0.1  # 10% reserve\n    for i in flexible:\n        if total_max >= current_load + reserve_margin:\n            break\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += p_max\n        committed.append(i)\n    \n    # Economic dispatch with iterative lambda adjustment\n    lower_bound = 0\n    upper_bound = 0\n    for i in committed:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bound += p_min\n        upper_bound += p_max\n    \n    if current_load < lower_bound:\n        lambda_val = 1e10\n    elif current_load > upper_bound:\n        lambda_val = -1e10\n    else:\n        lambda_low = min(2*unit['c_i']*unit['p_min_i'] + unit['b_i'] for unit in units)\n        lambda_high = max(2*unit['c_i']*unit['p_max_i'] + unit['b_i'] for unit in units)\n        lambda_val = (lambda_low + lambda_high) / 2\n        for _ in range(100):\n            total_p = 0\n            for i in committed:\n                unit = units[i]\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_min = unit['p_min_i']\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                p_i = (lambda_val - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_max\n                p_i = np.clip(p_i, p_min, p_max)\n                total_p += p_i\n            if abs(total_p - current_load) < 1e-6:\n                break\n            elif total_p < current_load:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            lambda_val = (lambda_low + lambda_high) / 2\n    \n    # Fine-tune with bisection\n    for i in committed:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        p_i = (lambda_val - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_max\n        p[i] = np.clip(p_i, p_min, p_max)\n        u[i] = 1\n    \n    total_p = sum(p)\n    if abs(total_p - current_load) > 1e-6:\n        # Adjust outputs proportionally\n        ratio = current_load / total_p\n        for i in committed:\n            unit = units[i]\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p[i] = np.clip(p[i] * ratio, p_min, p_max)\n    \n    # Validate minimum runtime\n    for i in committed:\n        unit = units[i]\n        if unit['u_i_0'] == 0 and unit['t_on_min_i'] > 1:\n            # Check if we can maintain minimum up time\n            if current_load < unit['p_min_i']:\n                u[i] = 0\n                p[i] = 0\n                # Redistribute load\n                remaining_load = current_load - sum(p)\n                if remaining_load > 0:\n                    for j in committed:\n                        if j != i and u[j] == 1:\n                            unit_j = units[j]\n                            p_max = min(unit_j['p_max_i'], unit_j['p_i_0'] + unit_j['p_up_i'])\n                            if p[j] < p_max:\n                                add = min(remaining_load, p_max - p[j])\n                                p[j] += add\n                                remaining_load -= add\n                                if remaining_load <= 0:\n                                    break\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0222438493,
          "gap_price_rate": 0.0311117157,
          "fitness": 0.0266777825
     }
]