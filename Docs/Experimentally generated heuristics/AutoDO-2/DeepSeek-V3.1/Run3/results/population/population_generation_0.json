[
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp limits\n2. Calculate total output range from must-run units\n3. If load is below must-run minimum, set must-run units to minimum output\n4. If load exceeds must-run maximum, commit flexible units by economic priority considering startup costs\n5. Perform economic dispatch among committed units using marginal cost sorting\n6. Adjust outputs to meet load exactly while respecting ramp constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    \n    allowable_min = np.zeros(n_units)\n    allowable_max = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            allowable_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            allowable_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            allowable_min[i] = unit['p_min_i']\n            allowable_max[i] = unit['p_start_i']\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n\n    total_min = np.sum(allowable_min[must_run])\n    total_max = np.sum(allowable_max[must_run])\n    \n    if current_load <= total_min:\n        u[must_run] = 1\n        p[must_run] = allowable_min[must_run]\n    else:\n        u[must_run] = 1\n        p[must_run] = allowable_max[must_run]\n        remaining_load = current_load - total_max\n        \n        flexible_idx = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n        cost_rates = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * allowable_max[i] + unit['c_i'] * allowable_max[i]**2\n            cost_rates.append((cost / allowable_max[i], i))\n        \n        cost_rates.sort(key=lambda x: x[0])\n        for _, idx in cost_rates:\n            if remaining_load <= 0:\n                break\n            u[idx] = 1\n            alloc = min(remaining_load, allowable_max[idx])\n            p[idx] = alloc\n            remaining_load -= alloc\n\n    committed = np.where(u == 1)[0]\n    for i in committed:\n        p[i] = allowable_min[i]\n    \n    total_output = np.sum(p)\n    while abs(total_output - current_load) > 1e-6:\n        if total_output < current_load:\n            candidate = -1\n            min_mc = float('inf')\n            for i in committed:\n                if p[i] < allowable_max[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            increase = min(current_load - total_output, allowable_max[candidate] - p[candidate])\n            p[candidate] += increase\n            total_output += increase\n        else:\n            candidate = -1\n            max_mc = -float('inf')\n            for i in committed:\n                if p[i] > allowable_min[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate == -1:\n                break\n            decrease = min(total_output - current_load, p[candidate] - allowable_min[candidate])\n            p[candidate] -= decrease\n            total_output -= decrease\n\n    return np.vstack((u, p))",
          "from": null,
          "gap_power_rate": 0.0056459616,
          "gap_price_rate": 0.00847472,
          "fitness": 0.0070603408
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-on and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Sort flexible units by average cost per MW at minimum output (including startup cost).\n3. Commit must-on units and flexible units until the total maximum available power meets the load.\n4. Perform economic dispatch among committed units using marginal cost merit order within feasible ranges determined by ramp constraints.\n5. Adjust power outputs to meet the load as closely as possible.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible = [i for i in range(n_units) if i not in must_on and i not in must_off]\n    avg_costs = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        cost = s_i + a_i + b_i * p_min_i + c_i * p_min_i**2\n        avg_cost = cost / p_min_i\n        avg_costs.append(avg_cost)\n    \n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible))]\n    current_load = load[0]\n    total_max_must_on = 0\n    \n    for i in must_on:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_max_i = unit['p_max_i']\n        max_p = min(p_max_i, p_i0 + p_up_i)\n        total_max_must_on += max_p\n    \n    committed = must_on[:]\n    total_max = total_max_must_on\n    \n    for i in flexible_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_i0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_max_i = unit['p_max_i']\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_p = min(p_max_i, p_start_i)\n        total_max += max_p\n        committed.append(i)\n    \n    min_max_ranges = []\n    committed_units_info = []\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            min_p = max(p_min_i, p_i0 - p_down_i)\n            max_p = min(p_max_i, p_i0 + p_up_i)\n        else:\n            min_p = p_min_i\n            max_p = min(p_max_i, p_start_i)\n        \n        min_max_ranges.append((min_p, max_p))\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        committed_units_info.append([i, min_p, max_p, a_i, b_i, c_i])\n    \n    p_outputs = [min_p for min_p, _ in min_max_ranges]\n    total_output = sum(p_outputs)\n    \n    for idx, unit_info in enumerate(committed_units_info):\n        i, p, max_p, a, b, c = unit_info\n        committed_units_info[idx] = [i, p, max_p, a, b, c]\n    \n    while total_output < current_load:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, (i, p, max_p, a, b, c) in enumerate(committed_units_info):\n            if p < max_p:\n                marginal = b + 2 * c * p\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = idx\n        \n        if best_idx is None:\n            break\n        \n        i, p, max_p, a, b, c = committed_units_info[best_idx]\n        increase = min(current_load - total_output, max_p - p)\n        new_p = p + increase\n        committed_units_info[best_idx] = [i, new_p, max_p, a, b, c]\n        total_output += increase\n    \n    schedules = np.zeros((2, n_units))\n    for (i, p, max_p, a, b, c) in committed_units_info:\n        schedules[0, i] = 1\n        schedules[1, i] = p\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0105126155,
          "fitness": 0.0083271523
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown ramp constraints.\n2. Commit must-run units and calculate their total feasible output range.\n3. Sort available units by average cost per MW at maximum output (including startup cost if offline).\n4. Commit additional cheapest units until total maximum capacity meets load.\n5. Perform economic dispatch using feasible output ranges and marginal cost sorting.\n6. Adjust outputs to exactly match load while respecting constraints.\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u = [0] * n_units\n    p = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                must_run[i] = True\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off[i] = True\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            \n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            p_max = unit['p_max_i']\n            s = unit['s_i']\n            u_i0 = unit['u_i_0']\n            \n            if u_i0 == 0:\n                total_cost = a + b * p_max + c * p_max**2 + s\n            else:\n                total_cost = a + b * p_max + c * p_max**2\n            avg_cost = total_cost / p_max\n            available_units.append((i, avg_cost, u_i0))\n            \n    available_units.sort(key=lambda x: x[1])\n    \n    total_max_must_run = 0\n    for i in range(n_units):\n        if must_run[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                UB = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_must_run += UB\n            \n    total_max = total_max_must_run\n    for idx, _, u_i0 in available_units:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        unit = units_info[idx]\n        if u_i0 == 1:\n            UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            UB = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += UB\n        \n    LB_arr = [0] * n_units\n    UB_arr = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                LB_arr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                UB_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                LB_arr[i] = unit['p_min_i']\n                UB_arr[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p[i] = 0\n            \n    total_output = sum(LB_arr)\n    remaining_load = current_load - total_output\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    units_with_capacity = []\n    for i in committed_indices:\n        if LB_arr[i] < UB_arr[i]:\n            units_with_capacity.append(i)\n            \n    units_with_capacity.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * LB_arr[i])\n    \n    for i in units_with_capacity:\n        if remaining_load <= 0:\n            break\n        available = UB_arr[i] - LB_arr[i]\n        if remaining_load <= available:\n            p[i] = LB_arr[i] + remaining_load\n            remaining_load = 0\n        else:\n            p[i] = UB_arr[i]\n            remaining_load -= available\n            \n    for i in committed_indices:\n        if p[i] == 0:\n            p[i] = LB_arr[i]\n            \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0066823052,
          "gap_price_rate": 0.0112014253,
          "fitness": 0.0089418652
     },
     {
          "name": "commit_units_by_priority_list_with_ramping",
          "algorithm": "1. Determine must-run units based on minimum uptime/downtime constraints and previous output relative to shutdown capacity\n2. Form priority list of non-must-run units sorted by average production cost at midpoint capacity\n3. Commit must-run units at minimum capacity\n4. Commit units from priority list until load is met, respecting ramp constraints\n5. Adjust generation levels using economic dispatch within feasible ranges\n6. Handle infeasible cases by maximizing generation or accepting over-generation\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list_with_ramping(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    must_run = np.zeros(num_units, dtype=bool)\n    must_off = np.zeros(num_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run[i] = True\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    priority_list = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            mid_point = (unit['p_min_i'] + unit['p_max_i']) / 2\n            avg_cost = (unit['b_i'] + unit['c_i'] * mid_point) / mid_point\n            priority_list.append((avg_cost, i))\n    \n    priority_list.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    feasible_ranges = []\n    \n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            u[i] = 1\n            p[i] = lb\n            total_min += lb\n            total_max += ub\n            feasible_ranges.append((i, lb, ub))\n        else:\n            feasible_ranges.append((i, 0, 0))\n    \n    remaining_load = current_load - total_min\n    for _, idx in priority_list:\n        if remaining_load <= 0:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if lb <= remaining_load:\n            u[idx] = 1\n            p[idx] = lb\n            total_min += lb\n            total_max += ub\n            feasible_ranges[idx] = (idx, lb, ub)\n            remaining_load -= lb\n    \n    committed_units = [i for i in range(num_units) if u[i] == 1]\n    incremental_costs = []\n    for i in committed_units:\n        unit = units_info[i]\n        inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n        incremental_costs.append((inc_cost, i))\n    \n    incremental_costs.sort(key=lambda x: x[0])\n    \n    remaining = current_load - sum(p)\n    if remaining > 0:\n        for _, idx in incremental_costs:\n            if remaining <= 0:\n                break\n            _, lb, ub = feasible_ranges[idx]\n            addable = min(ub - p[idx], remaining)\n            p[idx] += addable\n            remaining -= addable\n    \n    if remaining < 0:\n        incremental_costs.sort(key=lambda x: x[0], reverse=True)\n        remaining = abs(remaining)\n        for _, idx in incremental_costs:\n            if remaining <= 0:\n                break\n            _, lb, ub = feasible_ranges[idx]\n            reducible = min(p[idx] - lb, remaining)\n            p[idx] -= reducible\n            remaining -= reducible\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0923868685,
          "fitness": 0.0462334975
     },
     {
          "name": "rolling_priority_list_with_ed",
          "algorithm": "1. Determine must-run units based on min up/down times and shutdown ramp constraints\n2. Classify remaining units into must-off and free units\n3. Sort free units by average cost at maximum output\n4. Commit free units in cost order until capacity meets load\n5. Perform economic dispatch considering ramp constraints\n6. Adjust generation to exactly match load using marginal cost order\n\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_with_ed(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        # Check min up/down constraints\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n                continue\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n                continue\n        \n        # Check shutdown ramp constraint\n        if unit['u_i_0'] == 1 and unit['p_i_0'] > unit['p_shut_i']:\n            must_run.append(i)\n        else:\n            free_units.append(i)\n    \n    # Sort free units by average cost at p_max\n    def cost_per_mw(i):\n        unit = units_info[i]\n        return (unit['a_i'] + unit['b_i']*unit['p_max_i'] + \n                unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n    \n    free_units.sort(key=cost_per_mw)\n    \n    # Commit must-run units\n    total_capacity = 0\n    for i in must_run:\n        u[i] = 1\n        unit = units_info[i]\n        # Set initial output considering ramp constraints\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        p[i] = p_min\n        total_capacity += p_min\n    \n    # Commit free units until we meet load\n    for i in free_units:\n        if total_capacity >= current_load:\n            break\n        u[i] = 1\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], \n                   unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i'])\n        p[i] = min(p_max, current_load - total_capacity + unit['p_min_i'])\n        total_capacity += p[i]\n    \n    # Economic dispatch\n    remaining_load = current_load - total_capacity\n    while abs(remaining_load) > 1e-6:\n        # Find unit with lowest marginal cost for increasing generation\n        best_unit = None\n        best_marginal_cost = float('inf')\n        for i in range(n_units):\n            if u[i] == 0:\n                continue\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate available headroom\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n            if current_p < max_p:\n                marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n                if marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = i\n        \n        # Find unit with highest marginal cost for decreasing generation\n        worst_unit = None\n        worst_marginal_cost = -float('inf')\n        for i in range(n_units):\n            if u[i] == 0:\n                continue\n            unit = units_info[i]\n            current_p = p[i]\n            # Calculate available footroom\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_p = unit['p_min_i']\n            if current_p > min_p:\n                marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n                if marginal_cost > worst_marginal_cost:\n                    worst_marginal_cost = marginal_cost\n                    worst_unit = i\n        \n        # Adjust generation\n        if remaining_load > 0 and best_unit is not None:\n            unit = units_info[best_unit]\n            max_increase = min(remaining_load, \n                              min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i']) - p[best_unit])\n            p[best_unit] += max_increase\n            remaining_load -= max_increase\n        elif remaining_load < 0 and worst_unit is not None:\n            unit = units_info[worst_unit]\n            max_decrease = min(abs(remaining_load), \n                              p[worst_unit] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] == 1 else unit['p_min_i']))\n            p[worst_unit] -= max_decrease\n            remaining_load += max_decrease\n        else:\n            break\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 5.58777e-05,
          "gap_price_rate": 0.0984342045,
          "fitness": 0.0492450411
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units based on minimum up/down time and shutdown ramp constraints\n2. Set must-run units to online with output respecting ramp limits\n3. Sort remaining units by marginal cost at minimum output\n4. Commit units in merit order until total capacity meets load\n5. Perform economic dispatch using lambda iteration to balance load\n6. Adjust for units that cannot be dispatched optimally\n7. Return commitment and output schedules\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_schedule = np.zeros(n_units)\n    p_schedule = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    committed = []\n    for i in must_run:\n        unit = units_info[i]\n        u_schedule[i] = 1\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        p_schedule[i] = p_min\n        committed.append({'idx': i, 'p_min': p_min, 'p_max': p_max, \n                         'b': unit['b_i'], 'c': unit['c_i']})\n    \n    marginal_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        mc = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        marginal_costs.append((mc, i))\n    marginal_costs.sort(key=lambda x: x[0])\n    \n    total_capacity = sum(unit['p_max'] for unit in committed)\n    for mc, i in marginal_costs:\n        if total_capacity >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        u_schedule[i] = 1\n        p_schedule[i] = p_min\n        committed.append({'idx': i, 'p_min': p_min, 'p_max': p_max, \n                         'b': unit['b_i'], 'c': unit['c_i']})\n        total_capacity += p_max\n    \n    total_min = sum(unit['p_min'] for unit in committed)\n    total_max = sum(unit['p_max'] for unit in committed)\n    \n    if current_load < total_min:\n        for unit in reversed(committed):\n            if unit['idx'] in must_run:\n                continue\n            excess = total_min - current_load\n            reduction = min(excess, unit['p_min'])\n            p_schedule[unit['idx']] -= reduction\n            total_min -= reduction\n            if abs(total_min - current_load) < 1e-5:\n                break\n    elif current_load > total_max:\n        for unit in committed:\n            if unit['idx'] in must_run:\n                continue\n            deficit = current_load - total_max\n            addition = min(deficit, unit['p_max'] - unit['p_min'])\n            p_schedule[unit['idx']] += addition\n            total_max += addition\n            if abs(total_max - current_load) < 1e-5:\n                break\n    else:\n        low = min(unit['b'] + 2*unit['c']*unit['p_min'] for unit in committed)\n        high = max(unit['b'] + 2*unit['c']*unit['p_max'] for unit in committed)\n        \n        for _ in range(100):\n            lam = (low + high) / 2\n            total_output = 0\n            for unit in committed:\n                p = (lam - unit['b']) / (2 * unit['c'])\n                p = np.clip(p, unit['p_min'], unit['p_max'])\n                total_output += p\n            \n            if abs(total_output - current_load) < 1e-5:\n                for unit in committed:\n                    p = (lam - unit['b']) / (2 * unit['c'])\n                    p = np.clip(p, unit['p_min'], unit['p_max'])\n                    p_schedule[unit['idx']] = p\n                break\n            elif total_output < current_load:\n                low = lam\n            else:\n                high = lam\n    \n    return np.array([u_schedule, p_schedule])",
          "from": null,
          "gap_power_rate": 0.1858225534,
          "gap_price_rate": 0.138725401,
          "fitness": 0.1622739772
     },
     {
          "name": "commit_units_by_adaptive_merit_order",
          "algorithm": "1. Classify units into must-run, available, and unavailable based on current state and constraints\n2. Calculate merit order using effective marginal cost considering startup costs\n3. Commit must-run units at minimum power\n4. Fill remaining load using available units in merit order\n5. Perform economic dispatch using lambda iteration on committed units\n6. Adjust for ramp limits and minimum runtime constraints\n7. Verify solution meets load and constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_merit_order(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Classify units and calculate effective marginal costs\n    must_run = []\n    available = []\n    marginal_costs = []\n    \n    for i, unit in enumerate(units_info):\n        # Check minimum up/down time constraints\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                available.append(i)\n        else:\n            if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                available.append(i)\n        \n        # Calculate effective marginal cost including startup cost\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_output\n        if unit['u_i_0'] == 0:\n            marginal_cost += unit['s_i'] / min_output\n        marginal_costs.append(marginal_cost)\n    \n    # Commit must-run units\n    total_output = 0\n    for i in must_run:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        schedules[0][i] = 1\n        schedules[1][i] = min_output\n        total_output += min_output\n    \n    # Sort available units by marginal cost\n    available.sort(key=lambda i: marginal_costs[i])\n    \n    # Commit additional units until load is met\n    remaining_load = current_load - total_output\n    for i in available:\n        if remaining_load <= 0:\n            break\n            \n        unit = units_info[i]\n        max_possible = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        if unit['u_i_0'] == 0:\n            max_possible = min(max_possible, unit['p_start_i'])\n        \n        if max_possible > unit['p_min_i']:\n            schedules[0][i] = 1\n            additional = min(remaining_load, max_possible - unit['p_min_i'])\n            schedules[1][i] = unit['p_min_i'] + additional\n            total_output += additional\n            remaining_load -= additional\n    \n    # Economic dispatch using lambda iteration\n    committed = [i for i in range(num_units) if schedules[0][i] == 1]\n    lambda_val = sum(unit['b_i'] for i in committed) / len(committed)\n    \n    for _ in range(100):  # Lambda iteration\n        total_gen = 0\n        for i in committed:\n            unit = units_info[i]\n            p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n            p = max(unit['p_i_0'] - unit['p_down_i'], \n                   min(unit['p_i_0'] + unit['p_up_i'], p))\n            schedules[1][i] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < 1e-3:\n            break\n        lambda_val += (current_load - total_gen) * 0.01\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.2191064575,
          "gap_price_rate": 0.2112447872,
          "fitness": 0.2151756224
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Set must-run units to on and must-off units to off\n3. For flexible units, calculate cost-effectiveness scores considering marginal production costs and startup costs\n4. Sort flexible units by cost-effectiveness and commit until load is met\n5. Perform economic dispatch considering ramp constraints to fine-tune power allocations\n6. Adjust commitments if load isn't met while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = [False] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    # Classify units based on constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitments\n    for i in range(n_units):\n        if must_run[i]:\n            committed[i] = True\n        if must_off[i]:\n            committed[i] = False\n    \n    # Calculate cost-effectiveness for flexible units\n    flex_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i]:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            effectiveness = marginal_cost + (unit['s_i'] / unit['p_min_i'] if not unit['u_i_0'] else 0)\n            flex_units.append((i, effectiveness))\n    \n    # Sort and commit flexible units\n    flex_units.sort(key=lambda x: x[1])\n    total_capacity = 0\n    for i, unit in enumerate(units_info):\n        if committed[i]:\n            total_capacity += unit['p_max_i']\n    \n    for idx, _ in flex_units:\n        if total_capacity < current_load:\n            committed[idx] = True\n            total_capacity += units_info[idx]['p_max_i']\n        else:\n            break\n    \n    # Economic dispatch with ramp constraints\n    total_output = 0\n    p_outputs = [0] * n_units\n    \n    # Set initial outputs based on constraints\n    for i, unit in enumerate(units_info):\n        if committed[i]:\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            p_outputs[i] = p_min\n            total_output += p_min\n    \n    # Distribute remaining load\n    remaining_load = current_load - total_output\n    while remaining_load > 1e-6:\n        best_unit = None\n        best_marginal = float('inf')\n        for i, unit in enumerate(units_info):\n            if committed[i]:\n                if unit['u_i_0'] == 1:\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if p_outputs[i] < p_max:\n                    marginal = unit['b_i'] + 2 * unit['c_i'] * p_outputs[i]\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n        if best_unit is None:\n            break\n        \n        unit = units_info[best_unit]\n        if unit['u_i_0'] == 1:\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        add_cap = min(remaining_load, p_max - p_outputs[best_unit])\n        p_outputs[best_unit] += add_cap\n        remaining_load -= add_cap\n    \n    # Reduce excess generation\n    excess = total_output + sum(p_outputs) - current_load\n    while excess > 1e-6:\n        worst_unit = None\n        worst_marginal = -float('inf')\n        for i, unit in enumerate(units_info):\n            if committed[i] and p_outputs[i] > 0:\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_min = unit['p_min_i']\n                if p_outputs[i] > p_min:\n                    marginal = unit['b_i'] + 2 * unit['c_i'] * p_outputs[i]\n                    if marginal > worst_marginal:\n                        worst_marginal = marginal\n                        worst_unit = i\n        if worst_unit is None:\n            break\n        \n        unit = units_info[worst_unit]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        \n        reduce_cap = min(excess, p_outputs[worst_unit] - p_min)\n        p_outputs[worst_unit] -= reduce_cap\n        excess -= reduce_cap\n    \n    # Prepare output\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.4404246101,
          "gap_price_rate": 0.3908649457,
          "fitness": 0.4156447779
     }
]