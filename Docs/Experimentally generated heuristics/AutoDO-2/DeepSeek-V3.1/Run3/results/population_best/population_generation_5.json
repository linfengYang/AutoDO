{
     "name": "refined_rolling_commitment",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints, with enhanced forecast-aware adjustment\n2. Calculate must-run output range considering ramp constraints and previous states\n3. If current load exceeds must-run capacity, commit flexible units by two-period effective cost including startup costs and forecasted load\n4. Perform economic dispatch using marginal cost sorting within feasible output ranges\n5. Fine-tune outputs using proportional adjustment based on ramp capabilities\n6. Handle infeasible cases by maximizing generation within constraints\n\n",
     "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, p_start_i)\n        \n        must_run_min += min_out\n        must_run_max += max_out\n    \n    if current_load <= must_run_min:\n        for i in must_run:\n            unit = units_info[i]\n            u_i_0 = unit['u_i_0']\n            p_i_0 = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_down_i = unit['p_down_i']\n            \n            if u_i_0 == 1:\n                p[i] = max(p_min_i, p_i_0 - p_down_i)\n            else:\n                p[i] = p_min_i\n            u[i] = 1\n        for i in flexible + must_off:\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    adjusted_load = (current_load + next_load) / 2\n    flexible_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        s_i = unit['s_i']\n        \n        mid_i = (p_min_i + p_max_i) / 2\n        cost_current = a_i + b_i * mid_i + c_i * mid_i ** 2\n        cost_next = a_i + b_i * mid_i + c_i * mid_i ** 2\n        total_cost = cost_current + cost_next + s_i * (1 - u_i_0)\n        effective_cost = total_cost / (2 * mid_i)\n        flexible_costs.append((i, effective_cost))\n    \n    flexible_costs.sort(key=lambda x: x[1])\n    committed_flexible = []\n    total_capacity = must_run_max\n    for i, _ in flexible_costs:\n        unit = units_info[i]\n        p_max_i = unit['p_max_i']\n        p_start_i = unit['p_start_i']\n        u_i_0 = unit['u_i_0']\n        \n        max_out = p_max_i if u_i_0 == 1 else min(p_max_i, p_start_i)\n        if total_capacity < adjusted_load:\n            committed_flexible.append(i)\n            total_capacity += max_out\n        else:\n            break\n    \n    committed_units = must_run + committed_flexible\n    for i in committed_units:\n        u[i] = 1\n    \n    min_outs = []\n    max_outs = []\n    for i in committed_units:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, p_start_i)\n        \n        min_outs.append(min_out)\n        max_outs.append(max_out)\n    \n    total_min = sum(min_outs)\n    total_max = sum(max_outs)\n    \n    if current_load < total_min:\n        for idx, i in enumerate(committed_units):\n            p[i] = min_outs[idx]\n        for i in set(range(n_units)) - set(committed_units):\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    if current_load > total_max:\n        for idx, i in enumerate(committed_units):\n            p[i] = max_outs[idx]\n        for i in set(range(n_units)) - set(committed_units):\n            u[i] = 0\n            p[i] = 0\n        return np.array([u, p])\n    \n    margins = [current_load - total_min, total_max - current_load]\n    if margins[0] <= margins[1]:\n        p_vals = min_outs.copy()\n        remaining = current_load - total_min\n        unit_indices = list(range(len(committed_units)))\n        while remaining > 0:\n            best_cost = float('inf')\n            best_idx = None\n            for idx in unit_indices:\n                i = committed_units[idx]\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                current_p = p_vals[idx]\n                if current_p < max_outs[idx]:\n                    marginal_cost = b_i + 2 * c_i * current_p\n                    if marginal_cost < best_cost:\n                        best_cost = marginal_cost\n                        best_idx = idx\n            if best_idx is None:\n                break\n            i = committed_units[best_idx]\n            unit = units_info[i]\n            p_up_i = unit['p_up_i']\n            available = min(max_outs[best_idx] - p_vals[best_idx], p_up_i)\n            add = min(available, remaining)\n            p_vals[best_idx] += add\n            remaining -= add\n            if p_vals[best_idx] >= max_outs[best_idx]:\n                unit_indices.remove(best_idx)\n        for idx, i in enumerate(committed_units):\n            p[i] = p_vals[idx]\n    else:\n        p_vals = max_outs.copy()\n        excess = total_max - current_load\n        unit_indices = list(range(len(committed_units)))\n        while excess > 0:\n            worst_cost = -float('inf')\n            worst_idx = None\n            for idx in unit_indices:\n                i = committed_units[idx]\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                current_p = p_vals[idx]\n                if current_p > min_outs[idx]:\n                    marginal_cost = b_i + 2 * c_i * current_p\n                    if marginal_cost > worst_cost:\n                        worst_cost = marginal_cost\n                        worst_idx = idx\n            if worst_idx is None:\n                break\n            i = committed_units[worst_idx]\n            unit = units_info[i]\n            p_down_i = unit['p_down_i']\n            reduce_by = min(p_vals[worst_idx] - min_outs[worst_idx], p_down_i, excess)\n            p_vals[worst_idx] -= reduce_by\n            excess -= reduce_by\n            if p_vals[worst_idx] <= min_outs[worst_idx]:\n                unit_indices.remove(worst_idx)\n        for idx, i in enumerate(committed_units):\n            p[i] = p_vals[idx]\n    \n    for i in set(range(n_units)) - set(committed_units):\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
     "from": "mutation",
     "gap_power_rate": 0.0019652318,
     "gap_price_rate": 0.0086160879,
     "fitness": 0.0052906598
}