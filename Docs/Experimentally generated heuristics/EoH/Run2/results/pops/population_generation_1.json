[
     {
          "algorithm": "This algorithm modifies the existing lookahead approach by introducing staged commitment prioritization and adaptive thresholds. The key steps are:\n1. Classify units into must-run, must-off, free online, and free offline based on current state and constraints.\n2. Commit must-run and free online units, calculating their feasible power ranges while considering ramp constraints.\n3. Implement two-stage commitment of free offline units:\n   - Stage 1: Commit units based on current-load deficiency, prioritizing startup+min-gen cost per MW.\n   - Stage 2: If next-period capacity is insufficient, commit additional units based on two-period cost efficiency.\n4. Perform adaptive decommitment of expensive free online units only when both periods' requirements are securely met.\n5. Conduct economic dispatch by allocating minimum feasible outputs then distributing residual load to lowest marginal cost units.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on + free_online)\n    \n    # Initialize lb, ub arrays and capacity totals\n    lb = [0.0] * len(units_info)\n    ub = [0.0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    # Set initial lb/ub for committed units considering ramp constraints\n    for idx in committed:\n        unit = units_info[idx]\n        lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n        total_max_next += unit['p_max_i']\n    \n    # Stage 1: Commit free offline units for current load deficiency\n    if total_max_current < current_load:\n        candidates = []\n        for idx in free_offline:\n            if idx in committed:\n                continue\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            cost_current = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            efficiency = (unit['s_i'] + cost_current) / min_p\n            candidates.append((idx, efficiency, min_p, min(unit['p_max_i'], unit['p_start_i'])))\n        \n        candidates.sort(key=lambda x: x[1])\n        for candidate in candidates:\n            if total_max_current >= current_load:\n                break\n            idx, _, min_p, max_p = candidate\n            unit = units_info[idx]\n            committed.add(idx)\n            lb[idx] = min_p\n            ub[idx] = max_p\n            total_min_current += min_p\n            total_max_current += max_p\n            total_max_next += unit['p_max_i']\n    \n    # Stage 2: Commit free offline units for next-period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for idx in free_offline:\n            if idx in committed:\n                continue\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            cost_two_periods = 2 * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)\n            efficiency = (unit['s_i'] + cost_two_periods) / (2 * min_p)\n            candidates.append((idx, efficiency, min_p, min(unit['p_max_i'], unit['p_start_i']), unit['p_max_i']))\n        \n        candidates.sort(key=lambda x: x[1])\n        for candidate in candidates:\n            if total_max_next >= next_load:\n                break\n            idx, _, min_p, max_p, max_next = candidate\n            committed.add(idx)\n            lb[idx] = min_p\n            ub[idx] = max_p\n            total_min_current += min_p\n            total_max_current += max_p\n            total_max_next += max_next\n    \n    # Decommit expensive free online units if capacity margins allow\n    decommit_candidates = []\n    for idx in free_online:\n        if idx in committed and idx not in must_on:\n            unit = units_info[idx]\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * lb[idx] + unit['c_i'] * lb[idx]**2) / lb[idx]\n            decommit_candidates.append((idx, cost_per_mw, lb[idx], ub[idx], unit['p_max_i']))\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    for candidate in decommit_candidates:\n        idx, _, min_p, max_p, max_next = candidate\n        new_min = total_min_current - min_p\n        new_max_curr = total_max_current - max_p\n        new_max_next = total_max_next - max_next\n        \n        if (new_min <= current_load and \n            new_max_curr >= current_load and \n            new_max_next >= next_load):\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max_curr\n            total_max_next = new_max_next\n    \n    # Initialize outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    # Set outputs for must-off units\n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    # Set committed units to minimum output\n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            capacity = ub[idx] - p_out[idx]\n            allocation = min(capacity, residual)\n            p_out[idx] += allocation\n            residual -= allocation\n            if residual <= 1e-8:\n                break\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00694,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm employs a lookahead strategy that considers both current and next-period forecasted loads to optimize unit commitment decisions over two consecutive periods, reducing costly startups and shutdowns. The main steps are:\n1. Classify units into must-run, must-off, free online, and free offline based on current state and constraints.\n2. Commit must-run units and existing free online units, calculating their feasible power ranges.\n3. Assess total required capacity by considering current load and next-period forecast. Commit free offline units in ascending order of a two-period cost efficiency ratio (startup cost plus two periods of production at minimum output per MW) to jointly meet current and next-period loads.\n4. Optimize commitment by decommitting expensive free online units if feasible without violating current load requirements or next-period capacity constraints.\n5. Perform economic dispatch by allocating minimum feasible outputs initially and distributing residual load to units with the lowest marginal cost.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on) | set(free_online)\n    \n    # Compute current bounds\n    lb = [0] * len(units_info)\n    ub = [0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0  # For next period's capacity\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[idx] = unit['p_min_i']\n            ub[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n        total_max_next += unit['p_max_i']\n    \n    # Add free_offline units for two-period requirements\n    candidates = []\n    for idx in free_offline:\n        unit = units_info[idx]\n        min_output = unit['p_min_i']\n        production_cost = 2 * (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2)\n        efficiency_ratio = (unit['s_i'] + production_cost) / (2 * min_output)\n        max_output = min(unit['p_max_i'], unit['p_start_i'])\n        candidates.append((idx, efficiency_ratio, min_output, max_output, unit['p_max_i']))\n    \n    candidates.sort(key=lambda x: x[1])\n    \n    for idx, _, min_p, max_p, max_next in candidates:\n        # Check if already sufficient for both periods\n        if total_max_current >= current_load and total_max_next >= next_load:\n            break\n        # Add candidate to committed set\n        committed.add(idx)\n        lb[idx] = min_p\n        ub[idx] = max_p\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n    \n    # Optimize by decommitting expensive free_online units\n    decommit_candidates = []\n    for idx in free_online:\n        if idx not in must_on and idx in committed:\n            unit = units_info[idx]\n            unit_min = lb[idx]\n            unit_max_next = unit['p_max_i']\n            decommit_candidates.append(\n                (idx, (unit['a_i'] + unit['b_i'] * unit_min + unit['c_i'] * unit_min**2) / unit_min,\n                 lb[idx], ub[idx], unit['p_max_i'])\n            )\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    \n    for idx, _, min_p, max_p, max_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p\n        new_max_next = total_max_next - max_next\n        # Check feasibility for both periods after decommitment\n        if (new_min <= current_load and \n            new_max_current >= current_load and \n            new_max_next >= next_load):\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Initialize power outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    # Set must-off units to off\n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    # Set committed units to lb\n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            unit = units_info[idx]\n            available = ub[idx] - p_out[idx]\n            allocate = min(available, residual)\n            p_out[idx] += allocate\n            residual -= allocate\n            if residual <= 1e-6:\n                break\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "objective": 0.00699,
          "other_inf": null
     },
     {
          "algorithm": "The proposed algorithm is a priority-list method enhanced with constraints handling for the rolling unit commitment. First, units are classified as fixed-on, fixed-off, or flexible based on their state and constraints (minimum up/down times and shutdown ramp). Fixed-on units must run; fixed-off units cannot. For flexible units, the algorithm calculates feasible output ranges considering ramp limits. Units are prioritized by full-load average cost (FLAC), which includes startup costs for offline units. The algorithm commits flexible units in ascending FLAC order until the cumulative capacity meets the load. Total output is set to the closest feasible value (minimum output, maximum capacity, or exact load). Economic dispatch allocates this output by starting all committed units at their minimum output and distributing remaining power by ascending marginal cost at minimum output.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    min_bound = [0.0] * n_units\n    max_bound = [0.0] * n_units\n    \n    # Classify units\n    fixed_on = []\n    fixed_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                fixed_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                fixed_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Compute bounds for fixed_on units\n    total_min_fixed = 0.0\n    total_max_fixed = 0.0\n    for i in fixed_on:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        min_b = max(p_min_i, p_i_0 - p_down_i)\n        max_b = min(p_max_i, p_i_0 + p_up_i)\n        min_bound[i] = min_b\n        max_bound[i] = max_b\n        total_min_fixed += min_b\n        total_max_fixed += max_b\n    \n    # Compute bounds and FLAC for feasible flexible units\n    flexible_list = []\n    total_min = total_min_fixed\n    total_max = total_max_fixed\n    \n    for i in flexible:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if unit['u_i_0'] == 1:\n            min_b = max(p_min_i, p_i_0 - p_down_i)\n            max_b = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_b = p_min_i\n            max_b = min(p_max_i, p_start_i)\n        \n        if min_b <= max_b:\n            min_bound[i] = min_b\n            max_bound[i] = max_b\n            capacity = max_b\n            if unit['u_i_0'] == 1:\n                flac = (unit['a_i'] + unit['b_i'] * capacity + unit['c_i'] * capacity**2) / capacity\n            else:\n                flac = (unit['a_i'] + unit['b_i'] * capacity + unit['c_i'] * capacity**2 + unit['s_i']) / capacity\n            flexible_list.append((i, min_b, max_b, flac))\n    \n    # Sort by FLAC\n    flexible_list.sort(key=lambda x: x[3])\n    \n    # Commit flexible units until load is covered\n    committed_flexible = []\n    for i, min_b, max_b, _ in flexible_list:\n        if total_max >= current_load:\n            break\n        total_min += min_b\n        total_max += max_b\n        committed_flexible.append((i, min_b, max_b))\n    \n    # Set total output\n    total_output = current_load\n    if current_load < total_min:\n        total_output = total_min\n    elif current_load > total_max:\n        total_output = total_max\n    \n    # Get all committed units and their bounds\n    committed_units = fixed_on + [i for i,_,_ in committed_flexible]\n    min_bounds = [min_bound[i] for i in committed_units]\n    max_bounds = [max_bound[i] for i in committed_units]\n    \n    # Set all committed units to minimum output first\n    p_committed = min_bounds[:]\n    remaining = total_output - sum(min_bounds)\n    \n    # Distribute remaining power by marginal cost\n    if remaining > 0:\n        candidates = []\n        for idx, i in enumerate(committed_units):\n            headroom = max_bounds[idx] - min_bounds[idx]\n            if headroom > 0:\n                unit = units_info[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_bounds[idx]\n                candidates.append((idx, headroom, marginal_cost))\n        candidates.sort(key=lambda x: x[2])\n        for idx, headroom, _ in candidates:\n            if remaining <= 0:\n                break\n            add_power = min(remaining, headroom)\n            p_committed[idx] += add_power\n            remaining -= add_power\n    \n    # Update u and p\n    for idx, i in enumerate(committed_units):\n        u[i] = 1\n        p[i] = p_committed[idx]\n    \n    return np.array([u, p])",
          "objective": 0.00706,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the cost metric for flexible unit commitment to avoid overfitting. It removes speculative next-period savings and uses a consistent cost per minimum power for both commitment and decommitment. Key steps:\n1. Compute feasible power ranges for each unit\n2. Classify units into must-on, must-off, and flexible based on operational constraints\n3. Set must-on/must-off unit outputs\n4. Calculate remaining load capacity\n5. Commit flexible units sorted by increasing cost per minimum power\n6. Decommit overprovisioned units sorted by decreasing cost per minimum power\n7. Perform economic dispatch for final commitment using lambda iteration\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible min/max outputs\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Must-off units\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate remaining load and capacity bounds\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    \n    # Flexible unit commitment decision\n    flex_min = [p_min_feasible[i] for i in flexible]\n    flex_max = [p_max_feasible[i] for i in flexible]\n    \n    # Calculate cost per min power for flexible units\n    cost_metrics = []\n    for idx, i in enumerate(flexible):\n        unit = units_info[i]\n        min_p = flex_min[idx]\n        cost = unit['s_i'] * (1 - unit['u_i_0']) + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n        metrics = cost / min_p\n        cost_metrics.append(metrics)\n    \n    # Sort by cost per min power (lowest first)\n    flex_sorted = sorted(zip(flexible, cost_metrics), key=lambda x: x[1])\n    flexible_indices = [idx for idx, _ in flex_sorted]\n    \n    # Commit flexible units in priority order\n    committed_flex = []\n    for i in flexible_indices:\n        if total_max < current_load:\n            u_out[i] = 1\n            p_out[i] = flex_min[flexible.index(i)]\n            committed_flex.append(i)\n            total_min += flex_min[flexible.index(i)]\n            total_max += flex_max[flexible.index(i)]\n    \n    # Decommitment if overprovisioned\n    if total_min > current_load:\n        # Calculate cost per min power for committed flexible units\n        savings = []\n        for i in committed_flex:\n            min_p = p_min_feasible[i]\n            cost = (units_info[i]['s_i'] * (1 - units_info[i]['u_i_0']) + \n                    units_info[i]['a_i'] + \n                    units_info[i]['b_i'] * min_p + \n                    units_info[i]['c_i'] * min_p**2)\n            metric = cost / min_p\n            savings.append(metric)\n        \n        # Sort by descending cost per min power (most expensive first)\n        to_decommit = sorted(zip(committed_flex, savings), key=lambda x: -x[1])\n        \n        # Decommit expensive units until meeting load\n        for i, _ in to_decommit:\n            if total_min - p_min_feasible[i] >= current_load:\n                u_out[i] = 0\n                p_out[i] = 0\n                total_min -= p_min_feasible[i]\n                total_max -= flex_max[flexible.index(i)]\n                if total_min <= current_load:\n                    break\n    \n    # Economic dispatch for committed units\n    committed_indices = must_on + [i for i in committed_flex if u_out[i] == 1]\n    b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n    c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n    min_limits = [p_min_feasible[i] for i in committed_indices]\n    max_limits = [p_max_feasible[i] for i in committed_indices]\n    \n    if committed_indices:\n        # Lambda iteration method\n        lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n        lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n        \n        for _ in range(100):  # Limited iterations\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_indices):\n                p_val = (lambda_mid - b_coeffs[i]) / (2 * c_coeffs[i])\n                p_out[idx] = max(min_limits[i], min(max_limits[i], p_val))\n                total_p += p_out[idx]\n            \n            if abs(total_p - current_load) < 0.01:\n                break\n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00711,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a \"Two-Stage Lookahead Heuristic\" that uses a rolling framework with next-period forecast to optimize unit commitment. In the first stage, it commits units based on a combined cost metric considering both current and next period. The second stage performs dynamic decommitment and economic dispatch to minimize costs while respecting constraints. Key steps:\n1. Precompute feasible power bounds considering ramp constraints\n2. Classify units into must-run, must-off, and flexible categories\n3. Commit flexible units using combined cost per MW (current production cost plus next-period savings if kept on)\n4. If overcommitted, decommit most expensive units based on incremental savings\n5. Perform economic dispatch using marginal cost optimization with bisection method\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible min/max outputs\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Must-off units\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate remaining load and capacity bounds\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    \n    # Flexible unit commitment decision\n    flex_min = [p_min_feasible[i] for i in flexible]\n    flex_max = [p_max_feasible[i] for i in flexible]\n    \n    # Calculate combined cost metric for flexible units\n    cost_metrics = []\n    for idx, i in enumerate(flexible):\n        unit = units_info[i]\n        min_p = flex_min[idx]\n        \n        # Current period cost (with startup if not running)\n        current_cost = unit['s_i'] * (1 - unit['u_i_0']) + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n        \n        # Next period potential savings if kept running\n        next_period_savings = unit['s_i'] if next_load >= min_p else 0\n        metrics = (current_cost - next_period_savings) / min_p\n        cost_metrics.append(metrics)\n    \n    # Sort by combined cost metric (lowest first)\n    flex_sorted = sorted(zip(flexible, cost_metrics), key=lambda x: x[1])\n    \n    # Commit flexible units in priority order\n    committed_flex = []\n    for i, metric in flex_sorted:\n        if total_max < current_load:\n            u_out[i] = 1\n            p_out[i] = flex_min[flexible.index(i)]\n            committed_flex.append(i)\n            total_min += flex_min[flexible.index(i)]\n            total_max += flex_max[flexible.index(i)]\n    \n    # Decommitment if overprovisioned\n    if total_min > current_load:\n        # Calculate savings from decommitting units\n        savings = []\n        for i in committed_flex:\n            if units_info[i]['u_i_0'] == 0:  # Avoid turning off units that were off\n                savings.append(0)\n            else:\n                min_p = p_min_feasible[i]\n                saving = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p + \n                          units_info[i]['c_i'] * min_p**2) / min_p\n                savings.append(saving)\n        \n        # Sort by descending savings (most expensive first)\n        to_decommit = sorted(zip(committed_flex, savings), key=lambda x: -x[1])\n        \n        # Decommit expensive units until meeting load\n        for i, saving in to_decommit:\n            if total_min - p_min_feasible[i] >= current_load:\n                u_out[i] = 0\n                p_out[i] = 0\n                total_min -= p_min_feasible[i]\n                total_max -= flex_max[flexible.index(i)]\n                if total_min <= current_load:\n                    break\n    \n    # Economic dispatch for committed units\n    committed_indices = must_on + [i for i in committed_flex if u_out[i] == 1]\n    b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n    c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n    min_limits = [p_min_feasible[i] for i in committed_indices]\n    max_limits = [p_max_feasible[i] for i in committed_indices]\n    \n    if committed_indices:\n        # Lambda iteration method\n        lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n        lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n        \n        for _ in range(100):  # Limited iterations\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_indices):\n                p_val = (lambda_mid - b_coeffs[i]) / (2 * c_coeffs[i])\n                p_out[idx] = max(min_limits[i], min(max_limits[i], p_val))\n                total_p += p_out[idx]\n            \n            if abs(total_p - current_load) < 0.01:\n                break\n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00723,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a \"Ramp-Aware and Flexibility-Enhanced Heuristic\" that improves unit commitment decisions by prioritizing flexible and efficient units. Key modifications from the original include:\n1. Enhanced scoring: Combines marginal cost at minimum output, normalized ramp capability, and efficiency at midpoint loading\n2. Dynamic ramp calculation: Precisely computes next-period ramp limits based on current commitment decisions\n3. Improved efficiency: Incorporates operational efficiency at 50% loading in scoring\n4. Flexible prioritization: Increases weight on operational flexibility during commitment decisions\n\nMain steps:\n1. Precompute feasible power bounds considering ramp constraints\n2. Classify units into must-run, must-off, and flexible categories\n3. Compute new efficiency-flexibility score for flexible units:\n   - Marginal cost at minimum output (b_i + 2*c_i*p_min_feasible)\n   - Normalized next-period ramp capability (ramp_range_next / max_system_ramp)\n   - Efficiency at 50% loading (cost_per_MW at midpoint)\n4. Commit flexible units in ascending order of new efficiency-flexibility score\n5. Decommit most expensive units if overprovisioned (using current incremental cost)\n6. Perform economic dispatch via lambda iteration for committed units\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible min/max outputs\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Must-off units\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate remaining load and capacity bounds\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    \n    # Compute system-wide maximum ramp range\n    max_ramp_range = max(unit['p_max_i'] - unit['p_min_i'] for unit in units_info)\n    \n    # Calculate new efficiency-flexibility score for flexible units\n    cost_metrics = []\n    for idx, i in enumerate(flexible):\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        \n        # Marginal cost at minimum output\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        \n        # Efficiency at 50% loading\n        mid_point = 0.5 * (unit['p_min_i'] + unit['p_max_i'])\n        efficiency = (unit['a_i'] + unit['b_i'] * mid_point + unit['c_i'] * mid_point**2) / mid_point\n        \n        # Next-period ramp capability\n        if unit['u_i_0'] == 0:\n            min_next = unit['p_min_i']\n            max_next = min(unit['p_max_i'], min_p + unit['p_up_i'])\n        else:\n            min_next = max(unit['p_min_i'], min_p - unit['p_down_i'])\n            max_next = min(unit['p_max_i'], min_p + unit['p_up_i'])\n        ramp_range = max_next - min_next\n        \n        # Normalized ramp capability\n        ramp_flexibility = 1.0 - ramp_range / max_ramp_range\n        \n        # Combined score with weights\n        score = 0.4 * marginal_cost + 0.4 * efficiency + 0.2 * ramp_flexibility\n        cost_metrics.append(score)\n    \n    # Sort by combined score (lowest first)\n    flex_sorted = sorted(zip(flexible, cost_metrics), key=lambda x: x[1])\n    \n    # Commit flexible units in priority order\n    committed_flex = []\n    for i, metric in flex_sorted:\n        if total_max < current_load:\n            u_out[i] = 1\n            p_out[i] = p_min_feasible[i]\n            committed_flex.append(i)\n            total_min += p_min_feasible[i]\n            total_max += p_max_feasible[i]\n    \n    # Decommitment if overprovisioned\n    if total_min > current_load:\n        # Calculate savings from decommitting units\n        savings = []\n        for i in committed_flex:\n            if units_info[i]['u_i_0'] == 0:\n                savings.append(0)\n            else:\n                min_p = p_min_feasible[i]\n                saving = (units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_p)\n                savings.append(saving)\n        \n        # Sort by descending savings (most expensive first)\n        to_decommit = sorted(zip(committed_flex, savings), key=lambda x: -x[1])\n        \n        # Decommit expensive units until meeting load\n        for i, saving in to_decommit:\n            if total_min - p_min_feasible[i] >= current_load:\n                u_out[i] = 0\n                p_out[i] = 0\n                total_min -= p_min_feasible[i]\n                total_max -= p_max_feasible[i]\n                if total_min <= current_load:\n                    break\n    \n    # Economic dispatch for committed units\n    committed_indices = must_on + [i for i in committed_flex if u_out[i] == 1]\n    b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n    c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n    min_limits = [p_min_feasible[i] for i in committed_indices]\n    max_limits = [p_max_feasible[i] for i in committed_indices]\n    \n    if committed_indices:\n        # Lambda iteration method\n        lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n        lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n        \n        for _ in range(100):  # Limited iterations\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i, idx in enumerate(committed_indices):\n                p_val = (lambda_mid - b_coeffs[i]) / (2 * c_coeffs[i])\n                p_out[idx] = max(min_limits[i], min(max_limits[i], p_val))\n                total_p += p_out[idx]\n            \n            if abs(total_p - current_load) < 0.01:\n                break\n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.0074,
          "other_inf": null
     },
     {
          "algorithm": "Priority-based Dynamic Lookahead Heuristic\nMain Steps:\n1. Precompute feasible power ranges based on ramp constraints and current state\n2. Classify units into must-run, must-off, and adjustable categories\n3. Compute priority scores combining production efficiency, startup amortization, and lookahead savings\n4. Commit units in priority order until system capacity meets forecasted demand\n5. Adjust commitments if over-provisioned by decommitting units in reverse priority order\n6. Perform economic dispatch using lambda iteration on committed units\n7. Apply power limits to respect min/max output constraints\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible min/max outputs\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    adjustable = []\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                adjustable.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                adjustable.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Set must-off units\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate committed capacity\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    committed = must_on.copy()\n    \n    # Calculate priority scores for adjustable units\n    priorities = []\n    for i in adjustable:\n        min_p = p_min_feasible[i]\n        base_cost = units_info[i]['b_i'] * min_p + units_info[i]['c_i'] * min_p**2\n        startup_factor = units_info[i]['s_i'] * (1 - units_info[i]['u_i_0']) / min_p\n        lookahead = 0\n        if next_load >= min_p and units_info[i]['u_i_0'] == 0:\n            lookahead = units_info[i]['s_i'] / min_p\n        priority_score = base_cost / min_p + startup_factor - lookahead\n        priorities.append(priority_score)\n    \n    # Sort by priority\n    priority_order = sorted(zip(adjustable, priorities), key=lambda x: x[1])\n    adjust_units = [idx for idx, _ in priority_order]\n    \n    # Commit adjustable units until total capacity meets load\n    for i in adjust_units:\n        if total_max < current_load:\n            u_out[i] = 1\n            committed.append(i)\n            total_min += p_min_feasible[i]\n            total_max += p_max_feasible[i]\n    \n    # Decommitment if overcommitted\n    if total_min > current_load:\n        # Create decommit list (reverse priority order)\n        decommit_candidates = committed.copy()\n        decommit_candidates = [i for i in decommit_candidates if i not in must_on]\n        decommit_priority = sorted(decommit_candidates, key=lambda i: priorities[adjustable.index(i)], reverse=True)\n        \n        for i in decommit_priority:\n            if total_min - p_min_feasible[i] <= current_load:\n                break\n            u_out[i] = 0\n            committed.remove(i)\n            total_min -= p_min_feasible[i]\n            total_max -= p_max_feasible[i]\n    \n    # Economic dispatch\n    b_coeffs = []\n    c_coeffs = []\n    min_limits = []\n    max_limits = []\n    for i in committed:\n        b_coeffs.append(units_info[i]['b_i'])\n        c_coeffs.append(units_info[i]['c_i'])\n        min_limits.append(p_min_feasible[i])\n        max_limits.append(p_max_feasible[i])\n    \n    if committed:\n        # Lambda iteration\n        lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n        lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n        \n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for idx, i in enumerate(committed):\n                p_val = (lambda_mid - b_coeffs[idx]) / (2 * c_coeffs[idx])\n                p_val = max(min_limits[idx], min(max_limits[idx], p_val))\n                p_out[i] = p_val\n                total_p += p_val\n            \n            if abs(total_p - current_load) < 0.01:\n                break\n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00759,
          "other_inf": null
     },
     {
          "algorithm": "** Constraint-Respecting Heuristic with Forecast-Aware Commitment and Bidirectional Ramp Penalization\n\n1. **Identify Critical Units:** Determine must-on/must-off units using min up/down times and ramp constraints. Must-on units are forcibly committed (considering previous state, min runtime, and shutdown limits). Must-off units are deactivated.\n\n2. **Flexible Unit Assessment:** For non-critical units:\n   - Calculate base cost as marginal cost at minimum output\n   - Apply bidirectionally adaptive penalty:\n     - If next load > current: Penalize low ramp-up capability to prevent future insufficiency\n     - If next load < current: Penalize high min-up time to avoid over-commitment\n   - Sort units by penalty-adjusted cost\n\n3. **Sequential Commitment:** Commit sorted flexible units until cumulative maximum output meets demand. For each unit:\n   - Respect startup/shutdown ramp limits for previously offline units\n   - Enforce continuous ramp constraints for previously online units\n   - Set initial output to minimum feasible level\n\n4. **Economic Dispatch:** Allocate residual load to committed units:\n   - Prioritize units with lowest incremental cost (b_i + 2*c_i*p_i)\n   - Respect individual unit ramp rates and output limits\n   - Distribute load via greedy merit-order adjustment\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n = len(units_info)\n    u_current = [0] * n\n    p_current = [0.0] * n\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_limit = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < min_up) or (p_i0 > shut_limit):\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < min_down:\n                must_off.append(i)\n    \n    # Set must-on/must-off states\n    for i in must_on:\n        u_current[i] = 1\n    for i in must_off:\n        u_current[i] = 0\n        p_current[i] = 0.0\n    \n    # Initialize bounds and totals\n    total_min = 0.0\n    total_max = 0.0\n    min_bounds = [0.0] * n\n    max_bounds = [0.0] * n\n    \n    # Compute bounds for must-on units\n    for i in must_on:\n        unit = units_info[i]\n        prev_state = unit['u_i_0']\n        prev_output = unit['p_i_0']\n        \n        if prev_state == 1:  # Was online\n            min_bounds[i] = max(unit['p_min_i'], prev_output - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], prev_output + unit['p_up_i'])\n        else:  # Must start now\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_current[i] = min_bounds[i]\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n    \n    # Identify flexible units\n    flexible_idx = [i for i in range(n) if i not in must_on and i not in must_off]\n    penalty_factors = []\n    \n    # Calculate penalty-adjusted costs for flexible units\n    for i in flexible_idx:\n        unit = units_info[i]\n        base_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        \n        if next_load > current_load:  # Penalize low ramp-up capability\n            penalty = 1.0 / (unit['p_up_i'] + 1e-9) * 10000\n        else:  # Penalize high min-up time\n            penalty = unit['t_on_min_i'] * 10000\n        \n        penalty_factors.append((i, base_cost + penalty))\n    \n    # Sort by adjusted cost\n    penalty_factors.sort(key=lambda x: x[1])\n    flexible_sorted = [idx for idx, _ in penalty_factors]\n    \n    # Commit flexible units in sorted order\n    for i in flexible_sorted:\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[i]\n        prev_state = unit['u_i_0']\n        prev_output = unit['p_i_0']\n        \n        if prev_state == 1:  # Was online\n            min_bounds[i] = max(unit['p_min_i'], prev_output - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], prev_output + unit['p_up_i'])\n        else:  # Starting now\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        u_current[i] = 1\n        p_current[i] = min_bounds[i]\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n    \n    # Economic dispatch\n    committed = [i for i in range(n) if u_current[i] == 1]\n    total_output = sum(p_current[i] for i in committed)\n    residual = current_load - total_output\n    \n    if residual > 0:\n        current_outputs = p_current.copy()\n        active_units = committed.copy()\n        \n        while residual > 0 and active_units:\n            best_unit = None\n            min_mc = float('inf')\n            \n            # Find unit with lowest incremental cost\n            for i in active_units:\n                if current_outputs[i] < max_bounds[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_outputs[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            # Calculate maximum possible increase\n            inc = min(max_bounds[best_unit] - current_outputs[best_unit], residual)\n            current_outputs[best_unit] += inc\n            residual -= inc\n            \n            # Deactivate if output capped\n            if abs(current_outputs[best_unit] - max_bounds[best_unit]) < 1e-6:\n                active_units.remove(best_unit)\n        \n        # Update final outputs\n        for i in committed:\n            p_current[i] = current_outputs[i]\n    \n    schedules = np.array([u_current, p_current], dtype=float)\n    return schedules",
          "objective": 0.00768,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm focuses on scheduling for the current period only, removing reliance on the next period's forecast to improve generalization. It classifies units based on commitment constraints, initializes committed sets with online units, then adjusts commitment based solely on current load demands. Free offline units are added based on per-unit efficiency (startup cost + production cost at min output), and expensive free online units are decommitted if feasible for the current load. Power is initialized to lower bounds, then residual load is dispatched using marginal cost.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on) | set(free_online)\n    \n    # Compute current bounds\n    lb = [0] * len(units_info)\n    ub = [0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[idx] = unit['p_min_i']\n            ub[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n    \n    # Add free_offline units\n    candidates = []\n    for idx in free_offline:\n        unit = units_info[idx]\n        min_output = unit['p_min_i']\n        production_cost = unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2\n        efficiency_ratio = (unit['s_i'] + production_cost) / min_output\n        max_output = min(unit['p_max_i'], unit['p_start_i'])\n        candidates.append((idx, efficiency_ratio, min_output, max_output))\n    \n    candidates.sort(key=lambda x: x[1])\n    \n    for idx, _, min_p, max_p in candidates:\n        if total_max_current >= current_load:\n            break\n        committed.add(idx)\n        lb[idx] = min_p\n        ub[idx] = max_p\n        total_min_current += min_p\n        total_max_current += max_p\n    \n    # Decommit expensive free_online units\n    decommit_candidates = []\n    for idx in free_online:\n        if idx not in must_on and idx in committed:\n            unit = units_info[idx]\n            unit_min = lb[idx]\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * unit_min + unit['c_i'] * unit_min**2) / unit_min\n            decommit_candidates.append((idx, cost_per_mw, lb[idx], ub[idx]))\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    \n    for idx, _, min_p, max_p in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max = total_max_current - max_p\n        if new_min <= current_load and new_max >= current_load:\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max\n    \n    # Initialize power outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    # Set must-off units to off\n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    # Set committed units to lb\n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            unit = units_info[idx]\n            available = ub[idx] - p_out[idx]\n            allocate = min(available, residual)\n            p_out[idx] += allocate\n            residual -= allocate\n            if residual <= 1e-6:\n                break\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "objective": 0.00776,
          "other_inf": null
     },
     {
          "algorithm": "Modified heuristic with normalized penalty factors. Key steps: 1) Identify must-on/must-off units based on min up/down times and shutdown limits. 2) Precompute normalization factors for cost, ramp rates, and min-up times among flexible units. 3) Calculate dynamic penalty-adjusted cost: base marginal cost + penalty terms normalized by their respective maxima. For next load > current: emphasize ramp-up capability; for next load <= current: emphasize min-up time. 4) Commit units by sorted penalty-adjusted cost until demand coverage. 5) Economic dispatch via incremental cost merit order.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n = len(units_info)\n    u_current = [0] * n\n    p_current = [0.0] * n\n    must_on = []\n    must_off = []\n    \n    # Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_limit = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < min_up) or (p_i0 > shut_limit):\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < min_down:\n                must_off.append(i)\n    \n    # Set must-on/must-off states\n    for i in must_on:\n        u_current[i] = 1\n    for i in must_off:\n        u_current[i] = 0\n        p_current[i] = 0.0\n    \n    # Initialize bounds and totals\n    total_min = 0.0\n    total_max = 0.0\n    min_bounds = [0.0] * n\n    max_bounds = [0.0] * n\n    \n    # Compute bounds for must-on units\n    for i in must_on:\n        unit = units_info[i]\n        prev_state = unit['u_i_0']\n        prev_output = unit['p_i_0']\n        \n        if prev_state == 1:  # Was online\n            min_bounds[i] = max(unit['p_min_i'], prev_output - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], prev_output + unit['p_up_i'])\n        else:  # Must start now\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_current[i] = min_bounds[i]\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n    \n    # Identify flexible units\n    flexible_idx = [i for i in range(n) if i not in must_on and i not in must_off]\n    \n    if flexible_idx:\n        # Precompute normalization factors\n        base_costs = []\n        ramp_ups = []\n        min_ups = []\n        \n        for i in flexible_idx:\n            unit = units_info[i]\n            base_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            base_costs.append(base_cost)\n            ramp_ups.append(unit['p_up_i'])\n            min_ups.append(unit['t_on_min_i'])\n        \n        max_base = max(base_costs) if base_costs else 1\n        max_ramp_up = max(ramp_ups) if ramp_ups else 1\n        max_min_up = max(min_ups) if min_ups else 1\n        \n        # Calculate penalty-adjusted costs\n        penalty_factors = []\n        for i in flexible_idx:\n            unit = units_info[i]\n            base_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            normalized_base = base_cost / max_base if max_base != 0 else base_cost\n            \n            if next_load > current_load:\n                ramp_up = unit['p_up_i']\n                normalized_ramp = ramp_up / max_ramp_up if max_ramp_up != 0 else ramp_up\n                penalty = normalized_base - 0.3 * normalized_ramp\n            else:\n                min_up = unit['t_on_min_i']\n                normalized_minup = min_up / max_min_up if max_min_up != 0 else min_up\n                penalty = normalized_base + 0.3 * normalized_minup\n            \n            penalty_factors.append((i, penalty))\n        \n        # Sort by penalty-adjusted cost\n        penalty_factors.sort(key=lambda x: x[1])\n        flexible_sorted = [idx for idx, _ in penalty_factors]\n    else:\n        flexible_sorted = []\n    \n    # Commit flexible units in sorted order\n    for i in flexible_sorted:\n        if total_max >= current_load:\n            break\n            \n        unit = units_info[i]\n        prev_state = unit['u_i_0']\n        prev_output = unit['p_i_0']\n        \n        if prev_state == 1:  # Was online\n            min_bounds[i] = max(unit['p_min_i'], prev_output - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], prev_output + unit['p_up_i'])\n        else:  # Starting now\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        u_current[i] = 1\n        p_current[i] = min_bounds[i]\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n    \n    # Economic dispatch\n    committed = [i for i in range(n) if u_current[i] == 1]\n    total_output = sum(p_current[i] for i in committed)\n    residual = current_load - total_output\n    \n    if residual > 0:\n        current_outputs = p_current.copy()\n        active_units = committed.copy()\n        \n        while residual > 0 and active_units:\n            best_unit = None\n            min_mc = float('inf')\n            \n            # Find unit with lowest incremental cost\n            for i in active_units:\n                if current_outputs[i] < max_bounds[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_outputs[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            # Calculate maximum possible increase\n            inc = min(max_bounds[best_unit] - current_outputs[best_unit], residual)\n            current_outputs[best_unit] += inc\n            residual -= inc\n            \n            # Deactivate if output capped\n            if abs(current_outputs[best_unit] - max_bounds[best_unit]) < 1e-6:\n                active_units.remove(best_unit)\n        \n        # Update final outputs\n        for i in committed:\n            p_current[i] = current_outputs[i]\n    \n    schedules = np.array([u_current, p_current], dtype=float)\n    return schedules",
          "objective": 0.00805,
          "other_inf": null
     }
]