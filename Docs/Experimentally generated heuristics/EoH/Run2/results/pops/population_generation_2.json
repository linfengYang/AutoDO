[
     {
          "algorithm": "The new algorithm modifies the existing heuristic by adjusting the efficiency metrics used for committing free offline units and decommitting free online units. Instead of a two-period cost efficiency ratio for committing units, it uses a one-period ratio (startup cost plus one period of production cost at minimum output per MW). For decommitting units, it uses the marginal cost at minimum output (coefficient b_i + 2*c_i*min_output) instead of average cost. This prioritizes units with lower incremental costs and better reflects cost changes per additional MW. The main steps remain: classify units, commit must-run/free online, assess capacity needs, commit free offline units with new efficiency metric, decommit expensive units with new marginal cost metric, and perform economic dispatch.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on) | set(free_online)\n    \n    # Compute current bounds and next period capacity\n    lb = [0] * len(units_info)\n    ub = [0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[idx] = unit['p_min_i']\n            ub[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n        total_max_next += unit['p_max_i']\n    \n    # Commit free_offline units using one-period efficiency\n    candidates = []\n    for idx in free_offline:\n        unit = units_info[idx]\n        min_output = unit['p_min_i']\n        one_period_cost = unit['s_i'] + (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2)\n        efficiency_ratio = one_period_cost / min_output\n        max_output = min(unit['p_max_i'], unit['p_start_i'])\n        candidates.append((idx, efficiency_ratio, min_output, max_output, unit['p_max_i']))\n    \n    candidates.sort(key=lambda x: x[1])\n    \n    for idx, _, min_p, max_p, max_next in candidates:\n        if total_max_current >= current_load and total_max_next >= next_load:\n            break\n        committed.add(idx)\n        lb[idx] = min_p\n        ub[idx] = max_p\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n    \n    # Decommit using marginal cost at minimum output\n    decommit_candidates = []\n    for idx in free_online:\n        if idx not in must_on and idx in committed:\n            unit = units_info[idx]\n            min_output = lb[idx]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_output\n            decommit_candidates.append(\n                (idx, marginal_cost, lb[idx], ub[idx], unit['p_max_i'])\n            )\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    \n    for idx, _, min_p, max_p, max_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p\n        new_max_next = total_max_next - max_next\n        if (new_min <= current_load and \n            new_max_current >= current_load and \n            new_max_next >= next_load):\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Initialize outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            unit = units_info[idx]\n            available = ub[idx] - p_out[idx]\n            allocate = min(available, residual)\n            p_out[idx] += allocate\n            residual -= allocate\n            if residual <= 1e-6:\n                break\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "objective": 0.00601,
          "other_inf": null
     },
     {
          "algorithm": "A \"Predictive Load and Flexibility Driven Heuristic\" that emphasizes the next-period load requirements and unit flexibility to guide current commitments. The algorithm first categorizes units by status and dynamic flexibility, then uses next-period demand to influence commitment decisions through a multi-stage process. Key steps:\n1. Precompute feasible power ranges considering ramp, min-up/down constraints\n2. Classify units into must-run, must-off, and flexibility-ranked categories\n3. Compute \"Dynamic Flexibility Scores\" combining next-period utility and cost-effectiveness\n4. Stage 1: Commit units needed for next-period capacity requirements\n5. Stage 2: Commit units for current-period load deficiency\n6. Adaptive decommitment considering two-period requirements\n7. Greedy economic dispatch prioritizing units with lowest marginal cost\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate initial capacity\n    committed = set(must_run)\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Compute Dynamic Flexibility Scores for flexible units\n    dynamic_scores = {}\n    max_ramp = max(unit['p_max_i'] - unit['p_min_i'] for unit in units_info)\n    max_p_min = max(p_min_feasible)\n    \n    for i in flexible:\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        efficiency = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        \n        # Flexibility metric based on next-period ramp capability\n        ramp_range = min(unit['p_up_i'], unit['p_down_i']) + max_ramp\n        normalized_ramp = ramp_range / (2 * max_ramp)\n        \n        # Production metric\n        production_metric = (marginal_cost / max_p_min) * 0.4 + (efficiency / max_p_min) * 0.3\n        \n        # Next-period utility metric\n        next_utility = min(1.0, next_load / (sum(unit['p_max_i'] for unit in units_info))) * 0.3\n        \n        dynamic_scores[i] = normalized_ramp + production_metric - next_utility\n    \n    # Stage 1: Commit for next-period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            next_capacity = unit['p_max_i']\n            # Priority: lower score = better\n            priority = dynamic_scores[i]\n            candidates.append((i, priority, next_capacity))\n        \n        # Sort by ascending score (most flexible first)\n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_max_next += cap\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n    \n    # Stage 2: Commit for current load deficiency\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            current_capacity = p_max_feasible[i]\n            min_cost = unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2\n            cost_metric = (min_cost + unit['s_i'] * (1 - unit['u_i_0'])) / current_capacity\n            # Priority: lower score = better\n            priority = cost_metric * (1 - dynamic_scores[i])\n            candidates.append((i, priority, current_capacity))\n        \n        # Sort by ascending score\n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n    \n    # Adaptive decommitment (if overcommitted for both periods)\n    if total_min_current > current_load and total_max_next > next_load:\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            unit = units_info[i]\n            min_p = p_min_feasible[i]\n            max_p_next = unit['p_max_i']\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n            \n            # Consider both periods in savings calculation\n            if unit['u_i_0'] == 0:\n                cost_per_mw += unit['s_i'] / min_p\n            \n            decommit_candidates.append((i, cost_per_mw, min_p, max_p_next))\n        \n        # Sort by descending cost (most expensive first)\n        decommit_candidates.sort(key=lambda x: -x[1])\n        for i, _, min_p, max_p_next in decommit_candidates:\n            new_min = total_min_current - min_p\n            new_max_next = total_max_next - max_p_next\n            \n            if new_min >= current_load and new_max_next >= next_load:\n                committed.remove(i)\n                total_min_current = new_min\n                total_max_next = new_max_next\n            if total_min_current <= current_load:\n                break\n    \n    # Greedy economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        # Prioritize units with lowest marginal cost first\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00633,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, \"Average-Cost Heuristic\", prioritizes units based on their average production cost at minimum feasible output. The main steps are:\n1. Calculate feasible power limits for each unit considering current state and ramp constraints\n2. Classify units into must-on, must-off, and flexible categories based on minimum runtime/downtime constraints\n3. Commit must-on units at their minimum feasible output\n4. Compute residual load after must-on commitments\n5. Prioritize flexible units by ascending average cost at minimum output: (fixed_cost + b_i*p_min + c_i*p_min\u00b2)/p_min\n6. Commit lowest-cost flexible units until capacity meets demand\n7. Decommit most expensive committed flexible units if system constraints allow\n8. Perform economic dispatch via lambda iteration to optimize generation levels\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 1: Calculate feasible power limits\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 2: Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 3: Commit must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Calculate base capacity from must-on units\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    \n    # Step 4: Calculate remaining power requirement\n    residual_load = current_load - total_min\n    \n    # Step 5: Select and commit flexible units\n    flexible_candidates = []\n    for i in flexible:\n        min_p = p_min_feasible[i]\n        max_p = p_max_feasible[i]\n        \n        if min_p > max_p:\n            continue\n            \n        # Calculate average cost at minimum feasible output\n        startup_cost = unit['s_i'] * (1 - units_info[i]['u_i_0'])\n        variable_cost = units_info[i]['b_i'] * min_p + units_info[i]['c_i'] * min_p**2\n        avg_cost = (startup_cost + variable_cost) / min_p if min_p > 0 else float('inf')\n        flexible_candidates.append((i, avg_cost, min_p, max_p))\n    \n    # Sort by ascending average cost\n    flexible_candidates.sort(key=lambda x: x[1])\n    \n    # Commit until capacity covers demand\n    committed_flexible = []\n    for (i, _, min_p, max_p) in flexible_candidates:\n        if total_max >= current_load:\n            break\n        u_out[i] = 1\n        p_out[i] = min_p\n        committed_flexible.append(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Step 6: Conservative decommitment\n    if committed_flexible:\n        # Calculate average cost for decommitment candidates\n        decommit_candidates = []\n        for i in committed_flexible:\n            min_p = p_min_feasible[i]\n            startup_cost = unit['s_i'] * (1 - units_info[i]['u_i_0'])\n            variable_cost = units_info[i]['b_i'] * min_p + units_info[i]['c_i'] * min_p**2\n            avg_cost = (startup_cost + variable_cost) / min_p if min_p > 0 else float('inf')\n            decommit_candidates.append((i, avg_cost, min_p, p_max_feasible[i]))\n        \n        # Sort by descending average cost (most expensive first)\n        decommit_candidates.sort(key=lambda x: -x[1])\n        \n        # Remove expensive units if system constraints allow\n        for (i, _, min_p, max_p) in decommit_candidates:\n            if (i in committed_flexible and \n                (total_min - min_p) <= current_load and \n                (total_max - max_p) >= current_load):\n                u_out[i] = 0\n                p_out[i] = 0\n                committed_flexible.remove(i)\n                total_min -= min_p\n                total_max -= max_p\n    \n    # Step 7: Final economic dispatch\n    target = min(max(total_min, current_load), total_max)\n    \n    committed_indices = must_on + committed_flexible\n    if not committed_indices:\n        return np.array([u_out, p_out])\n    \n    b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n    c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n    min_limits = [p_min_feasible[i] for i in committed_indices]\n    max_limits = [p_max_feasible[i] for i in committed_indices]\n    \n    # Lambda iteration\n    lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n    lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for idx, i in enumerate(committed_indices):\n            if c_coeffs[idx] > 0:\n                p_val = (lambda_mid - b_coeffs[idx]) / (2 * c_coeffs[idx])\n            else:\n                p_val = max_limits[idx] if lambda_mid >= b_coeffs[idx] else min_limits[idx]\n                \n            p_out[i] = max(min_limits[idx], min(max_limits[idx], p_val))\n            total_p += p_out[i]\n        \n        if abs(total_p - target) < 0.01:\n            break\n        if total_p < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set uncommitted units to off\n    for i in range(n_units):\n        if i not in committed_indices:\n            u_out[i] = 0\n            p_out[i] = 0\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00634,
          "other_inf": null
     },
     {
          "algorithm": "Adjusted Cost-Ramp Priority Heuristic with Weight Modifications. Modified weights in the Cost-Ramp Score calculation: 0.4 for normalized marginal cost, 0.1 for startup cost component, and 0.5 for ramp component. Increased emphasis on ramp flexibility while reducing startup cost influence. Main steps: 1) Precompute feasible power ranges 2) Classify units into must-run/must-off/flexible 3) Calculate adjusted Cost-Ramp Scores 4) Two-stage unit commitment (next-period then current deficiency) 5) Adaptive decommitment 6) Ramp-constrained dispatch.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    # Set must-run and must-off units\n    committed = set(must_run)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    \n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate system-wide parameters\n    max_ramp = max(max(unit['p_up_i'], unit['p_down_i']) for unit in units_info) if units_info else 1\n    max_marginal = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for unit in units_info) if units_info else 1\n    max_startup = max(unit['s_i'] for unit in units_info) if units_info else 1\n    \n    # Compute Modified Cost-Ramp Scores\n    cost_ramp_scores = {}\n    for i in flexible:\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        \n        # Normalized cost components\n        normalized_marginal = marginal_cost / max_marginal\n        startup_component = unit['s_i'] * (1 - unit['u_i_0']) / max_startup\n        ramp_component = (unit['p_up_i'] + unit['p_down_i']) / (2 * max_ramp)\n        \n        # Apply adjusted weights: 0.4 marginal, 0.1 startup, 0.5 ramp\n        cost_ramp_scores[i] = 0.4 * normalized_marginal + 0.1 * startup_component - 0.5 * ramp_component\n    \n    # Stage 1: Commit for next-period capacity\n    if total_max_next < next_load:\n        candidates = [(i, cost_ramp_scores[i], units_info[i]['p_max_i']) \n                     for i in flexible if i not in committed]\n        candidates.sort(key=lambda x: x[1])  # Sort by score ascending\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap\n    \n    # Stage 2: Commit for current load deficiency\n    if total_max_current < current_load:\n        deficiency = current_load - total_max_current\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            min_cost = (units_info[i]['a_i'] + \n                        units_info[i]['b_i'] * p_min_feasible[i] + \n                        units_info[i]['c_i'] * p_min_feasible[i]**2)\n            avg_cost = min_cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n            candidates.append((i, avg_cost, p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])  # Sort by cost ascending\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n    \n    # Adaptive decommitment if overcommitted\n    if total_min_current > current_load and total_max_next > next_load:\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            unit = units_info[i]\n            min_p = p_min_feasible[i]\n            max_p_next = unit['p_max_i']\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n            decommit_candidates.append((i, cost_per_mw, min_p, max_p_next))\n        \n        decommit_candidates.sort(key=lambda x: -x[1])  # Sort by cost descending\n        for i, _, min_p, max_p_next in decommit_candidates:\n            new_min = total_min_current - min_p\n            new_max_next = total_max_next - max_p_next\n            if new_min >= current_load and new_max_next >= next_load:\n                committed.remove(i)\n                total_min_current = new_min\n                total_max_next = new_max_next\n    \n    # Ramp-constrained economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    # Allocate residual load by marginal cost\n    if residual > 0:\n        active_units = [(i, units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i], \n                         p_max_feasible[i] - p_out[i]) \n                        for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda x: x[1])  # Sort by marginal cost ascending\n        for i, mc, max_inc in active_units:\n            if residual <= 0:\n                break\n            allocated = min(residual, max_inc)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.0064,
          "other_inf": null
     },
     {
          "algorithm": "1. Precompute feasible power output ranges for each unit based on their current state and constraints.\n2. Classify units into must-run, must-off, and flexible categories based on minimum uptime/downtime and output constraints.\n3. Initialize outputs, setting must-run units to minimum feasible output and must-off units to off.\n4. Commit flexible units in two stages: first to meet next-period load capacity using cost-effectiveness, then for current-period deficiency using marginal cost.\n5. Perform decommitment for overcommitted units based on economic efficiency.\n6. Dispatch power: assign minimum feasible outputs first, then residual load in increasing marginal cost order.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Initial capacity from must-run units\n    committed = set(must_run)\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Stage 1: Ensure next period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            cost = unit['s_i'] * (1 - unit['u_i_0']) \n            cost += unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2\n            priority = cost / unit['p_max_i']  # Cost per MW of capacity\n            candidates.append((i, priority, unit['p_max_i']))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap\n    \n    # Stage 2: Ensure current period capacity\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_feasible[i]\n            priority = marginal_cost / p_max_feasible[i]  # Marginal cost per MW\n            candidates.append((i, priority, p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n            total_max_next += units_info[i]['p_max_i']\n    \n    # Decommit overcommitted units\n    decommit_candidates = []\n    for i in committed:\n        if i in must_run:\n            continue\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p_next = unit['p_max_i']\n        cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        if unit['u_i_0'] == 0:\n            cost_per_mw += unit['s_i'] / min_p  # Include potential startup cost\n        decommit_candidates.append((i, cost_per_mw, min_p, max_p_next))\n    \n    decommit_candidates.sort(key=lambda x: -x[1])\n    for i, _, min_p, max_p_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_next = total_max_next - max_p_next\n        if new_min >= current_load and new_max_next >= next_load:\n            committed.remove(i)\n            total_min_current = new_min\n            total_max_next = new_max_next\n    \n    # Economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00641,
          "other_inf": null
     },
     {
          "algorithm": "A \"Two-Stage Cost and Ramp Priority Heuristic\" focusing on cost-efficiency and ramp flexibility constraints. Key steps:\n1. Precompute feasible power ranges using ramp limits and previous states\n2. Classify units into must-run, must-off, and flexible categories\n3. Calculate \"Cost-Ramp Scores\" combining marginal costs, ramp flexibility, and start-up costs\n4. Stage 1: Commit units for next-period capacity using cost-ramp scores\n5. Stage 2: Commit additional units for current load deficiency\n6. Decommit over-committed units based on cost-effectiveness\n7. Economic dispatch with ramp-constrained allocation\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges considering ramp limits\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    # Set must-run and must-off units\n    committed = set(must_run)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    \n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate system-wide parameters\n    max_ramp = max(max(unit['p_up_i'], unit['p_down_i']) for unit in units_info)\n    max_marginal = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for unit in units_info)\n    max_startup = max(unit['s_i'] for unit in units_info) if units_info else 1\n    \n    # Compute Cost-Ramp Scores for flexible units\n    cost_ramp_scores = {}\n    for i in flexible:\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        \n        # Normalized cost components\n        normalized_marginal = marginal_cost / max_marginal if max_marginal > 0 else 0\n        startup_component = unit['s_i'] * (1 - unit['u_i_0']) / max_startup\n        ramp_component = (unit['p_up_i'] + unit['p_down_i']) / (2 * max_ramp) if max_ramp > 0 else 0\n        \n        cost_ramp_scores[i] = 0.5 * normalized_marginal + 0.3 * startup_component - 0.2 * ramp_component\n    \n    # Stage 1: Commit for next-period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            candidates.append((i, cost_ramp_scores[i], units_info[i]['p_max_i']))\n        \n        # Sort by ascending score (lowest cost/ramp score first)\n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap\n    \n    # Stage 2: Commit for current load deficiency\n    if total_max_current < current_load:\n        deficiency = current_load - total_max_current\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            available = min(p_max_feasible[i], deficiency)\n            min_cost = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_feasible[i] + units_info[i]['c_i'] * p_min_feasible[i]**2\n            avg_cost = min_cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n            priority = avg_cost\n            candidates.append((i, priority, p_max_feasible[i]))\n        \n        # Sort by ascending cost\n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n    \n    # Adaptive decommitment if overcommitted\n    if total_min_current > current_load and total_max_next > next_load:\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            unit = units_info[i]\n            min_p = p_min_feasible[i]\n            max_p_next = unit['p_max_i']\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n            decommit_candidates.append((i, cost_per_mw, min_p, max_p_next))\n        \n        # Sort by descending cost (most expensive first)\n        decommit_candidates.sort(key=lambda x: -x[1])\n        for i, _, min_p, max_p_next in decommit_candidates:\n            new_min = total_min_current - min_p\n            new_max_next = total_max_next - max_p_next\n            if new_min >= current_load and new_max_next >= next_load:\n                committed.remove(i)\n                total_min_current = new_min\n                total_max_next = new_max_next\n    \n    # Ramp-constrained economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    # Allocate residual load by marginal cost\n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        marginal_costs = []\n        for i in active_units:\n            current_output = p_out[i]\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_output\n            max_increase = min(p_max_feasible[i] - current_output, residual)\n            marginal_costs.append((i, marginal_cost, max_increase))\n        \n        marginal_costs.sort(key=lambda x: x[1])\n        for i, mc, max_inc in marginal_costs:\n            if residual <= 0:\n                break\n            allocated = min(residual, max_inc)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00642,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the unit commitment process to enhance generalization by:\n1. Precomputing feasible power ranges considering current state and ramp constraints.\n2. Classifying units into must-run, must-off, and flexible categories based on their states and minimum up/down times.\n3. Prioritizing units based on cost per MW (minimal operating cost plus startup cost if applicable) for both stages.\n4. Using simpler cost-based prioritization: Stage 1 ensures next-period coverage, Stage 2 handles current load deficiency.\n5. Performing decommitment only when both period maximums can still meet demand after removal.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    committed = set()\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        committed.add(i)\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Initialize capacity metrics\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Stage 1: Commit for next-period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed or i in must_off:\n                continue\n            cap_add = units_info[i]['p_max_i']\n            min_cost = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_feasible[i] + units_info[i]['c_i'] * p_min_feasible[i]**2\n            startup_cost = units_info[i]['s_i'] * (1 - units_info[i]['u_i_0'])\n            priority = (min_cost + startup_cost) / cap_add\n            candidates.append((i, priority, cap_add))\n        \n        candidates.sort(key=lambda x: x[1])  # Ascending cost per MW\n        for i, _, cap_add in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap_add\n    \n    # Stage 2: Commit for current load deficiency\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed or i in must_off:\n                continue\n            cap_add = p_max_feasible[i]\n            min_cost = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_feasible[i] + units_info[i]['c_i'] * p_min_feasible[i]**2\n            startup_cost = units_info[i]['s_i'] * (1 - units_info[i]['u_i_0'])\n            priority = (min_cost + startup_cost) / cap_add\n            candidates.append((i, priority, cap_add))\n        \n        candidates.sort(key=lambda x: x[1])  # Ascending cost per MW\n        for i, _, cap_add in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap_add\n            total_max_next += units_info[i]['p_max_i']\n    \n    # Adaptive decommitment\n    changed = True\n    while changed:\n        changed = False\n        decommit_candidates = []\n        for i in list(committed):\n            if i in must_run: \n                continue\n            new_max_current = total_max_current - p_max_feasible[i]\n            new_max_next = total_max_next - units_info[i]['p_max_i']\n            if new_max_current < current_load or new_max_next < next_load:\n                continue\n            min_cost = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_feasible[i] + units_info[i]['c_i'] * p_min_feasible[i]**2\n            startup_cost = units_info[i]['s_i'] * (1 - units_info[i]['u_i_0'])\n            cost_per_mw = (min_cost + startup_cost) / p_min_feasible[i]\n            decommit_candidates.append((i, cost_per_mw, p_min_feasible[i], p_max_feasible[i], units_info[i]['p_max_i']))\n        \n        if decommit_candidates:\n            decommit_candidates.sort(key=lambda x: -x[1])  # Descending cost\n            i_remove, _, min_remove, max_current_remove, max_next_remove = decommit_candidates[0]\n            committed.remove(i_remove)\n            total_min_current -= min_remove\n            total_max_current -= max_current_remove\n            total_max_next -= max_next_remove\n            changed = True\n    \n    # Greedy economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00651,
          "other_inf": null
     },
     {
          "algorithm": "The proposed algorithm is a \"Lagrangian-Inspired Cost-Balance Heuristic\" that combines the strengths of incremental cost analysis with load balancing while strictly respecting operational constraints. The key steps are:\n\n1. Feasible Power Calculation: Determine feasible operating ranges for each unit considering current state, ramp constraints, and min/max limits.\n2. Unit Classification: Identify must-run, must-off, and flexible units based on minimum uptime/downtime constraints and shutdown limitations.\n3. Mandatory Commitment: Commit all must-run units at their minimum feasible output.\n4. Gap Assessment: Calculate remaining power deficit after mandatory commitments.\n5. Flexible Unit Selection:\n   - Calculate a balanced cost metric combining amortized startup cost and marginal generation cost\n   - Prioritize flexible units with lower balanced costs\n   - Commit units until the generation deficit is covered\n6. Conservative Decommitment: Remove the most expensive committed flexible units if system constraints allow\n7. Output Determination:\n   - Adjust target generation to stay within feasible operating range\n   - Dispatch power economically using lambda iteration with careful limits enforcement\n\nThis approach differs from existing methods by balancing fixed startup costs with variable generation costs, using a novel cost metric, and employing more conservative decommitment decisions.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 1: Calculate feasible power limits for current period\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 2: Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 3: Commit must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Calculate base capacity from must-on units\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    \n    # Step 4: Calculate remaining power requirement\n    residual_load = current_load - total_min\n    \n    # Step 5: Select and commit flexible units\n    flexible_candidates = []\n    for i in flexible:\n        # Skip units with infeasible operating range\n        if p_min_feasible[i] > p_max_feasible[i]:\n            continue\n            \n        # Calculate amortized startup cost\n        startup_cost_per_mw = (unit['s_i'] * (1 - units_info[i]['u_i_0'])) / p_min_feasible[i]\n        # Marginal cost at minimum output\n        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min_feasible[i]\n        # Combined balanced cost metric\n        balanced_cost = startup_cost_per_mw + marginal_cost\n        flexible_candidates.append((i, balanced_cost, p_min_feasible[i], p_max_feasible[i]))\n    \n    # Sort by balanced cost (lowest first)\n    flexible_candidates.sort(key=lambda x: x[1])\n    \n    # Commit flexible units until deficit is covered\n    committed_flexible = []\n    for (i, _, min_p, max_p) in flexible_candidates:\n        if total_max >= current_load:\n            break\n        u_out[i] = 1\n        p_out[i] = min_p\n        committed_flexible.append(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Step 6: Conservative decommitment\n    if committed_flexible:\n        # Calculate marginal cost for each committed unit at min power\n        decommit_candidates = []\n        for i in committed_flexible:\n            min_p = p_min_feasible[i]\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_p\n            decommit_candidates.append((i, marginal_cost, min_p, p_max_feasible[i]))\n        \n        # Sort by marginal cost descending (most expensive first)\n        decommit_candidates.sort(key=lambda x: -x[1])\n        \n        # Remove expensive units if system constraints allow\n        for (i, _, min_p, max_p) in decommit_candidates:\n            if (i in committed_flexible and \n                (total_min - min_p) <= current_load and \n                (total_max - max_p) >= current_load):\n                u_out[i] = 0\n                p_out[i] = 0\n                committed_flexible.remove(i)\n                total_min -= min_p\n                total_max -= max_p\n    \n    # Step 7: Final economic dispatch\n    # Determine feasible target generation\n    target = min(max(total_min, current_load), total_max)\n    \n    # Collect all committed units\n    committed_indices = must_on + committed_flexible\n    if not committed_indices:\n        return np.array([u_out, p_out])\n    \n    # Extract cost function parameters for committed units\n    b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n    c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n    min_limits = [p_min_feasible[i] for i in committed_indices]\n    max_limits = [p_max_feasible[i] for i in committed_indices]\n    \n    # Lambda iteration for economic dispatch\n    lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n    lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n    \n    for _ in range(100):  # Limited iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for idx, i in enumerate(committed_indices):\n            # Calculate economic output level\n            if c_coeffs[idx] > 0:\n                p_val = (lambda_mid - b_coeffs[idx]) / (2 * c_coeffs[idx])\n            else:\n                p_val = max_limits[idx] if lambda_mid >= b_coeffs[idx] else min_limits[idx]\n                \n            # Enforce operational limits\n            p_out[i] = max(min_limits[idx], min(max_limits[idx], p_val))\n            total_p += p_out[i]\n        \n        # Check convergence\n        if abs(total_p - target) < 0.01:\n            break\n        if total_p < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set uncommitted units to off state\n    for i in range(n_units):\n        if i not in committed_indices:\n            u_out[i] = 0\n            p_out[i] = 0\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00658,
          "other_inf": null
     },
     {
          "algorithm": "The \"Enhanced Ramp Flexibility Heuristic\" prioritizes ramp capabilities and operational readiness while considering marginal and startup costs. Key steps:\n1. Precompute feasible power ranges using ramp limits and previous states\n2. Classify units into must-run, must-off, and flexible categories\n3. Calculate \"Ramp-First Scores\" with 40% weight on ramp flexibility, 40% on marginal cost, and 20% on startup cost\n4. Stage 1: Commit units for next-period capacity using ramp-first scores\n5. Stage 2: Commit additional units for current load deficiency based on average cost\n6. Decommit over-committed units by descending cost per MW\n7. Economic dispatch with ramp-constrained allocation\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    committed = set(must_run)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    \n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    max_ramp = max(max(unit['p_up_i'], unit['p_down_i']) for unit in units_info)\n    max_marginal = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for unit in units_info)\n    max_startup = max(unit['s_i'] for unit in units_info) if units_info else 1\n    \n    ramp_first_scores = {}\n    for i in flexible:\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        \n        normalized_marginal = marginal_cost / max_marginal if max_marginal > 0 else 0\n        startup_component = unit['s_i'] * (1 - unit['u_i_0']) / max_startup\n        ramp_component = (unit['p_up_i'] + unit['p_down_i']) / (2 * max_ramp) if max_ramp > 0 else 0\n        \n        ramp_first_scores[i] = 0.4 * normalized_marginal + 0.2 * startup_component - 0.4 * ramp_component\n    \n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            candidates.append((i, ramp_first_scores[i], units_info[i]['p_max_i']))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap\n    \n    if total_max_current < current_load:\n        deficiency = current_load - total_max_current\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            available = min(p_max_feasible[i], deficiency)\n            min_cost = units_info[i]['a_i'] + units_info[i]['b_i'] * p_min_feasible[i] + units_info[i]['c_i'] * p_min_feasible[i]**2\n            avg_cost = min_cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n            priority = avg_cost\n            candidates.append((i, priority, p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n    \n    if total_min_current > current_load and total_max_next > next_load:\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            unit = units_info[i]\n            min_p = p_min_feasible[i]\n            max_p_next = unit['p_max_i']\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n            decommit_candidates.append((i, cost_per_mw, min_p, max_p_next))\n        \n        decommit_candidates.sort(key=lambda x: -x[1])\n        for i, _, min_p, max_p_next in decommit_candidates:\n            new_min = total_min_current - min_p\n            new_max_next = total_max_next - max_p_next\n            if new_min >= current_load and new_max_next >= next_load:\n                committed.remove(i)\n                total_min_current = new_min\n                total_max_next = new_max_next\n    \n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        marginal_costs = []\n        for i in active_units:\n            current_output = p_out[i]\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_output\n            max_increase = min(p_max_feasible[i] - current_output, residual)\n            marginal_costs.append((i, marginal_cost, max_increase))\n        \n        marginal_costs.sort(key=lambda x: x[1])\n        for i, mc, max_inc in marginal_costs:\n            if residual <= 0:\n                break\n            allocated = min(residual, max_inc)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00665,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the cost metric used for flexible unit commitment from cost per minimum power to fixed cost per minimum feasible power. The key steps are:\n1. Precompute feasible power ranges for each unit considering ramp constraints and current state.\n2. Classify units into must-on, must-off, and flexible based on minimum up/down times.\n3. Set must-on units to their feasible minimum output and must-off units to 0.\n4. Commit flexible units ordered by increasing fixed cost (startup plus no-load cost) per minimum feasible power until total maximum capacity meets or exceeds current load.\n5. If total minimum output exceeds current load after commitment, decommit most expensive flexible units (highest fixed cost per minimum power) while maintaining sufficient capacity to meet the load.\n6. Perform economic dispatch on remaining committed units using lambda iteration to precisely meet the load.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Precompute feasible min/max outputs\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-on and must-off units\n    total_min = 0.0\n    total_max = 0.0\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min += p_min_feasible[i]\n        total_max += p_max_feasible[i]\n    \n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Compute metrics for flexible units\n    cost_metrics = []\n    for i in flexible:\n        unit = units_info[i]\n        fixed_cost = unit['a_i'] + unit['s_i'] * (1 - unit['u_i_0'])\n        metrics = fixed_cost / p_min_feasible[i]\n        cost_metrics.append(metrics)\n    \n    # Sort by metrics (lowest first)\n    flex_sorted = sorted(zip(flexible, cost_metrics), key=lambda x: x[1])\n    flexible_indices = [idx for idx, _ in flex_sorted]\n    \n    # Commit flexible units until total_max >= current_load\n    committed_flex = []\n    for i in flexible_indices:\n        if total_max < current_load:\n            idx_in_flex = flexible.index(i)\n            u_out[i] = 1\n            p_out[i] = p_min_feasible[i]\n            committed_flex.append(i)\n            total_min += p_min_feasible[i]\n            total_max += p_max_feasible[i]\n    \n    # Decommit if overprovisioned\n    if total_min > current_load:\n        decommit_list = []\n        for i in committed_flex:\n            unit = units_info[i]\n            fixed_cost = unit['a_i'] + unit['s_i'] * (1 - unit['u_i_0'])\n            metrics = fixed_cost / p_min_feasible[i]\n            decommit_list.append((i, metrics))\n        \n        # Sort descending by metrics\n        decommit_list.sort(key=lambda x: -x[1])\n        \n        for (i, _) in decommit_list:\n            if (total_max - p_max_feasible[i]) >= current_load:\n                u_out[i] = 0\n                p_out[i] = 0.0\n                total_min -= p_min_feasible[i]\n                total_max -= p_max_feasible[i]\n                if total_min <= current_load:\n                    break\n    \n    # Perform economic dispatch\n    committed_indices = []\n    for i in range(n_units):\n        if u_out[i] == 1:\n            committed_indices.append(i)\n    \n    if committed_indices:\n        b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n        c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n        min_limits = [p_min_feasible[i] for i in committed_indices]\n        max_limits = [p_max_feasible[i] for i in committed_indices]\n        \n        # Lambda iteration method\n        lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n        lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n        \n        for _ in range(100):  # Limited iterations\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for j, idx in enumerate(committed_indices):\n                p_val = (lambda_mid - b_coeffs[j]) / (2 * c_coeffs[j])\n                p_val = max(min_limits[j], min(max_limits[j], p_val))\n                p_out[idx] = p_val\n                total_p += p_val\n            \n            if abs(total_p - current_load) < 0.01:\n                break\n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00684,
          "other_inf": null
     }
]