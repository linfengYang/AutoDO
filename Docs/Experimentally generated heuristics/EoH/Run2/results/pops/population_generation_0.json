[
     {
          "algorithm": "**  \nThe heuristic is a two-step process: unit commitment followed by economic dispatch. First, classify units as fixed-on, fixed-off, or flexible based on their state and constraints (minimum up/down times, shutdown ramp). Fixed-on units must run, fixed-off units cannot run. For flexible units, compute their feasible output ranges considering ramp limits. Sort flexible units by a cost metric (cost per MW at minimum output including startup costs if applicable). Then, commit units: if the load exceeds the capacity of fixed-on units, greedily add flexible units (cheapest first) until the cumulative maximum capacity covers the load. Determine total output as the closest feasible value to the load (min, max, or exact). Finally, perform economic dispatch: allocate the total output among committed units starting from their minimum outputs and distributing remaining power in increasing order of their marginal costs at minimum output.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Initialize output arrays\n    u = [0] * n_units\n    p = [0.0] * n_units\n    low_bounds = [0.0] * n_units\n    high_bounds = [0.0] * n_units\n    \n    # Classify units\n    fixed_on = []\n    fixed_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                fixed_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # u_i_0 == 0\n            if abs(t_i_0) < t_off_min_i:\n                fixed_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Compute bounds for fixed_on units\n    total_min_fixed = 0.0\n    total_max_fixed = 0.0\n    for i in fixed_on:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        low_bound = max(p_min_i, p_i_0 - p_down_i)\n        high_bound = min(p_max_i, p_i_0 + p_up_i)\n        low_bounds[i] = low_bound\n        high_bounds[i] = high_bound\n        total_min_fixed += low_bound\n        total_max_fixed += high_bound\n    \n    # Prepare flexible units list with cost metrics\n    flexible_list = []  # (i, min_output, max_output, cost_per_MW)\n    TypeA = []\n    TypeB = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        if units_info[i]['u_i_0'] == 1:  # Type A (currently on)\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            min_output = max(p_min_i, p_i_0 - p_down_i)\n            max_output = min(p_max_i, p_i_0 + p_up_i)\n            cost_per_MW = (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2) / min_output\n            flexible_list.append((i, min_output, max_output, cost_per_MW))\n            TypeA.append(i)\n        else:  # Type B (currently off)\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_output = min(p_max_i, p_start_i)\n            if p_min_i <= max_output:\n                min_output = p_min_i\n                cost_per_MW = (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2 + unit['s_i']) / min_output\n                flexible_list.append((i, min_output, max_output, cost_per_MW))\n                TypeB.append(i)\n    \n    # Sort flexible units by cost_per_MW\n    flexible_list.sort(key=lambda x: x[3])\n    \n    # Commit units\n    committed = fixed_on[:]  # Start with fixed_on units\n    total_min = total_min_fixed\n    total_max = total_max_fixed\n    added = []  # (i, min_output, max_output)\n    \n    if current_load > total_max_fixed:\n        for i, min_out, max_out, _ in flexible_list:\n            if total_max >= current_load:\n                break\n            committed.append(i)\n            added.append((i, min_out, max_out))\n            total_min += min_out\n            total_max += max_out\n    \n    # Determine total_output\n    if current_load < total_min_fixed:\n        total_output = total_min_fixed\n    elif current_load > total_max:\n        total_output = total_max\n    else:\n        total_output = current_load\n    \n    # Update bounds for added flexible units\n    for i, min_out, max_out in added:\n        low_bounds[i] = min_out\n        high_bounds[i] = max_out\n    \n    # Economic dispatch for committed units\n    min_array = []\n    max_array = []\n    units_info_committed = []\n    \n    for i in committed:\n        min_array.append(low_bounds[i])\n        max_array.append(high_bounds[i])\n        units_info_committed.append(units_info[i])\n    \n    p_committed = min_array[:]  # Start at min outputs\n    remaining = total_output - sum(min_array)\n    \n    # Distribute remaining power by marginal cost\n    if remaining > 0:\n        # Create list: (idx_in_committed, headroom, marginal_cost_at_min)\n        candidates = []\n        for idx, i in enumerate(committed):\n            headroom = max_array[idx] - min_array[idx]\n            if headroom > 0:\n                unit = units_info[i]\n                mc = unit['b_i'] + 2 * unit['c_i'] * min_array[idx]\n                candidates.append((idx, headroom, mc))\n        \n        candidates.sort(key=lambda x: x[2])  # Sort by marginal cost\n        for idx, headroom, mc in candidates:\n            if remaining <= 0:\n                break\n            assign = min(remaining, headroom)\n            p_committed[idx] += assign\n            remaining -= assign\n    \n    # Set u and p for all units\n    for idx, i in enumerate(committed):\n        u[i] = 1\n        p[i] = p_committed[idx]\n    \n    # Build and return the schedule\n    schedules = np.array([u, p])\n    return schedules",
          "objective": 0.00821,
          "other_inf": null
     },
     {
          "algorithm": "** The heuristic is a two-phase approach for each time step. In Phase 1, determine mandatory commitments based on constraints (must-on if not meeting min up-time or shutdown capacity; must-off if not meeting min down-time). Free units are considered if mandatory units cannot meet the load. Free units are prioritized by average cost per MWh at minimum output. In Phase 2, economic dispatch adjusts outputs of committed units within operational limits (ramp constraints, startup/shutdown limits) to match load as closely as possible, minimizing costs via greedy incremental cost-based allocation. Any unmet load (under/over generation) is minimized by setting outputs to bounds after dispatching.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n = len(units_info)\n    load_value = load[0]  # current load to meet\n    u_i = [0] * n\n    p_i = [0] * n\n    must_on = [False] * n\n    must_off = [False] * n\n    free_units = []  # indices of free units (not must_on or must_off)\n\n    # Determine must_on and must_off\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:  # unit was off\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Set initial commitment for must_on and must_off, and collect free units\n    for i in range(n):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            free_units.append(i)\n    \n    # Calculate bounds for mandatory units\n    lb_mandatory = [0] * n\n    ub_mandatory = [0] * n\n    min_mandatory = 0.0\n    max_mandatory = 0.0\n    mandatory_indices = []\n    for i in range(n):\n        if must_on[i]:\n            unit = units_info[i]\n            lb_mandatory[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_mandatory[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_mandatory += lb_mandatory[i]\n            max_mandatory += ub_mandatory[i]\n            mandatory_indices.append(i)\n    \n    # Case 1: load <= min_mandatory\n    if load_value <= min_mandatory:\n        for i in mandatory_indices:\n            p_i[i] = lb_mandatory[i]\n        schedules = np.array([u_i, p_i])\n        return schedules\n\n    # Initialize free unit commitments\n    committed_free = []  # indices of committed free units\n    current_min = min_mandatory\n    current_max = max_mandatory\n\n    # If mandatory units cannot meet load, consider free units\n    if max_mandatory < load_value:\n        # Sort free units by average cost per MWh at minimum output\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] +\n                    unit['c_i'] * (unit['p_min_i'] ** 2) + unit['s_i']) / unit['p_min_i']\n            free_costs.append((i, cost, unit['p_min_i'], min(unit['p_max_i'], unit['p_start_i'])))\n        free_costs.sort(key=lambda x: x[1])\n\n        # Commit free units until load is met or all are considered\n        for unit_info in free_costs:\n            idx, cost, p_min, p_max = unit_info\n            candidate_min = current_min + p_min\n            candidate_max = current_max + p_max\n            # Only commit if it doesn't force overgeneration beyond load\n            if candidate_min <= load_value:\n                committed_free.append(idx)\n                u_i[idx] = 1\n                current_min = candidate_min\n                current_max = candidate_max\n                if current_max >= load_value:\n                    break\n        # Check if further free units can reduce deviation if load not met\n        if current_max < load_value:\n            deviation_current = load_value - current_max\n            best_candidate = None\n            for unit_info in free_costs:\n                idx, cost, p_min, p_max = unit_info\n                if idx in committed_free:\n                    continue\n                candidate_dev = abs((current_min + p_min) - load_value)\n                if candidate_dev < deviation_current:\n                    deviation_current = candidate_dev\n                    best_candidate = idx\n            if best_candidate is not None:\n                committed_free.append(best_candidate)\n                u_i[best_candidate] = 1\n                # Update current_min/current_max is not crucial for dispatch\n\n    # Phase 2: Economic dispatch for all committed units\n    committed_indices = mandatory_indices + committed_free\n    lb = []\n    ub = []\n    # Determine bounds per committed unit\n    for i in committed_indices:\n        if must_on[i]:  # Mandatory unit\n            unit = units_info[i]\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Committed free unit\n            unit = units_info[i]\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_val)\n        ub.append(ub_val)\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    # Initialize dispatch with lower bounds\n    dispatch_powers = lb.copy()\n    residual = load_value - total_lb\n    \n    # Adjust for over/under generation or dispatch\n    if residual < 0:  # Overgeneration; cannot reduce below lb\n        pass  # Use lb values\n    elif residual > 0:  # Undergeneration; distribute if possible\n        active_idx = list(range(len(committed_indices)))\n        while residual > 1e-5 and active_idx:\n            # Find unit with lowest incremental cost not at upper bound\n            min_incr = float('inf')\n            best_i = -1\n            for j in active_idx:\n                i_comm = committed_indices[j]\n                incr = (units_info[i_comm]['b_i'] + \n                        2 * units_info[i_comm]['c_i'] * dispatch_powers[j])\n                if incr < min_incr and dispatch_powers[j] < ub[j]:\n                    min_incr = incr\n                    best_i = j\n            if best_i == -1:\n                break\n            # Increase this unit's output\n            max_addition = min(ub[best_i] - dispatch_powers[best_i], residual)\n            dispatch_powers[best_i] += max_addition\n            residual -= max_addition\n            if dispatch_powers[best_i] >= ub[best_i]:\n                active_idx.remove(best_i)\n    # Set p_i for committed units\n    for idx, power in zip(committed_indices, dispatch_powers):\n        p_i[idx] = power\n    \n    schedules = np.array([u_i, p_i])\n    return schedules",
          "objective": 0.00848,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe algorithm is a greedy heuristic for the rolling unit commitment problem at a single time step. It operates in four main steps:\n\n1. **Determine must-on and must-off units:** For each unit, check if it must be on due to minimum up-time constraints or shutdown ramp limits (if previous output exceeded shutdown capacity), or must be off due to minimum down-time constraints.\n\n2. **Initial commitment:** Set must-on units to on state and must-off units to off state. All other units are considered flexible and initially set to off.\n\n3. **Commit flexible units:** Compute the total minimum and maximum output from must-on units. If the maximum output is insufficient to meet the load, sort flexible units by increasing marginal cost at minimum output (b_i + 2*c_i*p_min_i). Commit flexible units in this order until the total maximum output meets or exceeds the load.\n\n4. **Economic dispatch:** Assign the load to committed units:\n   - Set each committed unit to its minimum possible output (considering ramp and startup limits).\n   - If the sum of minimum outputs exceeds the load, leave units at minimum outputs (overproduction).\n   - If the sum is below the load, distribute the residual load by increasing output on units with the lowest marginal cost first (b_i + 2*c_i*current_output), respecting each unit's maximum output limit.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u_current = [0] * n\n    p_current = [0.0] * n\n    must_on = []\n    must_off = []\n    \n    # Step 1: Identify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < t_on_min) or (p_i0 > p_shut_i):\n                must_on.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Step 2: Set must-on and must-off states\n    for i in must_on:\n        u_current[i] = 1\n    for i in must_off:\n        u_current[i] = 0\n        p_current[i] = 0.0\n    \n    # Step 3: Compute min/max for must-on units\n    total_min = 0.0\n    total_max = 0.0\n    min_bounds = [0.0] * n\n    max_bounds = [0.0] * n\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        p_current[i] = min_bounds[i]\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n    \n    # Handle flexible units (not must-on or must-off)\n    flexible_idx = [i for i in range(n) if i not in must_on and i not in must_off]\n    \n    # Sort flexible units by marginal cost at min output\n    flexible_idx.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'])\n    \n    # Commit flexible units if needed\n    for i in flexible_idx:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        min_bounds[i] = unit['p_min_i']\n        max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        u_current[i] = 1\n        p_current[i] = min_bounds[i]\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n    \n    # Step 4: Economic dispatch\n    committed = [i for i in range(n) if u_current[i] == 1]\n    total_output = sum(p_current[i] for i in committed)\n    residual = current_load - total_output\n    \n    if residual > 0:\n        current_outputs = [p_current[i] for i in range(n)]\n        while residual > 0:\n            best_unit = None\n            min_mc = float('inf')\n            for i in committed:\n                if current_outputs[i] < max_bounds[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_outputs[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_unit = i\n            if best_unit is None:\n                break\n            inc = min(max_bounds[best_unit] - current_outputs[best_unit], residual)\n            current_outputs[best_unit] += inc\n            residual -= inc\n        for i in committed:\n            p_current[i] = current_outputs[i]\n    \n    schedules = np.array([u_current, p_current], dtype=float)\n    return schedules",
          "objective": 0.00918,
          "other_inf": null
     },
     {
          "algorithm": "Our heuristic, Priority-Based Economic Dispatch with Constraints Handling (PEDCH), follows these steps:\n\n1. **Classify units**:\n   - Forced-on: Units that must remain on due to insufficient min-up time or previous output exceeding shutdown capacity.\n   - Forced-off: Units that must remain off due to insufficient min-down time.\n   - Flexible: Units that can be either on or off.\n\n2. **Handle forced-on units**:\n   - Calculate min/max outputs considering ramp limits.\n   - If load within min/max range of forced-on units:\n     - Set initial outputs to their minimum.\n     - Greedily increase outputs by lowest marginal cost until meeting load.\n   - Else set outputs to min (if load < min) or max (if load > max).\n\n3. **Dispatch flexible units if residual load remains** (load > forced-on max outputs):\n   - **Type 1 (currently off)**:\n     - Calculate average cost at minimum output (including startup).\n     - Turn on units by lowest average cost until cumulative maximum output >= residual.\n     - Set initial outputs to minimum.\n     - Greedily increase outputs by lowest marginal cost to meet residual.\n   - **Type 2 (currently on)**:\n     - Set min/max outputs considering ramp limits.\n     - Set initial outputs to their minimum.\n     - Greedily increase outputs by lowest marginal cost to meet partial residual.\n     - Remainder handled by Type 1 units.\n\n4. **Set all non-dispatched units to off state with zero output**.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    load_current = load[0]\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    flexible = []\n\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -t_i0 < t_off_min:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    L_forced = []\n    U_forced = []\n    for idx in forced_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_i0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        L = max(p_min, p_i0 - p_down)\n        U = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        L_forced.append(L)\n        U_forced.append(U)\n        u_out[idx] = 1\n    \n    forced_total_min = sum(L_forced) if forced_on else 0\n    forced_total_max = sum(U_forced) if forced_on else 0\n    \n    for i, idx in enumerate(forced_on):\n        p_out[idx] = L_forced[i]\n    \n    if forced_total_min <= load_current <= forced_total_max:\n        residual = load_current - forced_total_min\n        while residual > 0 and forced_on:\n            min_marginal = float('inf')\n            candidate_idx = None\n            candidate_forced_idx = None\n            for j, idx in enumerate(forced_on):\n                if p_out[idx] < U_forced[j]:\n                    marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx]\n                    if marginal_cost < min_marginal:\n                        min_marginal = marginal_cost\n                        candidate_idx = idx\n                        candidate_forced_idx = j\n            if candidate_idx is None:\n                break\n            increase = min(residual, U_forced[candidate_forced_idx] - p_out[candidate_idx])\n            p_out[candidate_idx] += increase\n            residual -= increase\n    elif load_current < forced_total_min:\n        for i, idx in enumerate(forced_on):\n            p_out[idx] = L_forced[i]\n    else:\n        for i, idx in enumerate(forced_on):\n            p_out[idx] = U_forced[i]\n        residual = load_current - forced_total_max\n\n        if residual > 0:\n            flex_on = []\n            flex_off = []\n            for idx in flexible:\n                if units_info[idx]['u_i_0'] == 1:\n                    flex_on.append(idx)\n                else:\n                    flex_off.append(idx)\n\n            type2_min = []\n            type2_max = []\n            for idx in flex_on:\n                unit = units_info[idx]\n                min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                type2_min.append(min_output)\n                type2_max.append(max_output)\n                u_out[idx] = 1\n            \n            p_type2 = [min_output for min_output in type2_min]\n            res_type2 = residual\n            while res_type2 > 0 and flex_on:\n                min_marginal = float('inf')\n                candidate_idx = None\n                candidate_flex_idx = None\n                for j, idx in enumerate(flex_on):\n                    if p_type2[j] < type2_max[j]:\n                        marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_type2[j]\n                        if marginal_cost < min_marginal:\n                            min_marginal = marginal_cost\n                            candidate_idx = idx\n                            candidate_flex_idx = j\n                if candidate_idx is None:\n                    break\n                increase = min(res_type2, type2_max[candidate_flex_idx] - p_type2[candidate_flex_idx])\n                p_type2[candidate_flex_idx] += increase\n                res_type2 -= increase\n            \n            for i, idx in enumerate(flex_on):\n                p_out[idx] = p_type2[i]\n            \n            residual = res_type2\n\n            if residual > 0 and flex_off:\n                avg_costs = []\n                min_outputs = []\n                max_outputs = []\n                for idx in flex_off:\n                    unit = units_info[idx]\n                    min_out = unit['p_min_i']\n                    max_out = min(unit['p_max_i'], unit['p_start_i'])\n                    cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * (min_out ** 2) + unit['s_i']\n                    avg_cost = cost / min_out if min_out > 0 else float('inf')\n                    avg_costs.append(avg_cost)\n                    min_outputs.append(min_out)\n                    max_outputs.append(max_out)\n                \n                sorted_flex_off = sorted(zip(flex_off, min_outputs, max_outputs, avg_costs), key=lambda x: x[3])\n                selected_units = []\n                cumulative_max = 0\n                for idx, min_out, max_out, _ in sorted_flex_off:\n                    cumulative_max += max_out\n                    selected_units.append((idx, min_out, max_out))\n                    if cumulative_max >= residual:\n                        break\n                \n                p_selected = [min_out for _, min_out, _ in selected_units]\n                res_selected = residual - sum(p_selected)\n                \n                if res_selected < 0:\n                    res_selected = 0\n                \n                while res_selected > 0:\n                    min_marginal = float('inf')\n                    candidate = None\n                    candidate_index = None\n                    for i, (idx, _, max_out) in enumerate(selected_units):\n                        current_p = p_selected[i]\n                        if current_p < max_out:\n                            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * current_p\n                            if marginal_cost < min_marginal:\n                                min_marginal = marginal_cost\n                                candidate = idx\n                                candidate_index = i\n                    if candidate is None:\n                        break\n                    increase = min(res_selected, selected_units[candidate_index][2] - p_selected[candidate_index])\n                    p_selected[candidate_index] += increase\n                    res_selected -= increase\n                \n                for i, (idx, _, _) in enumerate(selected_units):\n                    u_out[idx] = 1\n                    p_out[idx] = p_selected[i]\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "objective": 0.01008,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm is a priority-based method for unit commitment and economic dispatch. It proceeds as follows:\n1. **Pre-commitment**: Determine forced-on units (must remain on due to min-up time or shutdown ramp constraints) and forced-off units (must remain off due to min-down time constraints). Other units are flexible.\n2. **Bounds calculation**: Compute feasible output ranges for forced-on and potential flexible units based on ramp limits and startup/shutdown constraints.\n3. **Priority list**: Calculate average cost per MW at minimum output for flexible units. Sort by increasing cost, with currently-on units prioritized over off units due to avoided startup costs.\n4. **Commitment**: Start with forced-on units. If additional capacity is needed, commit flexible units in priority order until the load can be met.\n5. **Dispatch**: \n   - If under/over-generation is inevitable, set outputs to bounds.\n   - Otherwise, initialize outputs to previous values (within bounds) or minimums.\n   - Adjust outputs iteratively using marginal costs: increase output from the cheapest available unit when under-generated, decrease output from the most expensive unit when over-generated.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    flexible = []\n    l_bounds = [0.0] * n_units\n    u_bounds = [0.0] * n_units\n\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n\n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i and t_i0 >= 0) or (p_i0 > p_shut_i):\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and t_i0 > -t_off_min_i:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n\n    for i, unit in enumerate(units_info):\n        if i in forced_on or i in flexible:\n            if units_info[i]['u_i_0'] == 1:\n                l_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                u_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                l_bounds[i] = unit['p_min_i']\n                u_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            l_bounds[i] = 0.0\n            u_bounds[i] = 0.0\n\n    priority_list = []\n    for i in flexible:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        if unit['u_i_0'] == 1:\n            cost_per_mw = (a + b * l_bounds[i] + c * l_bounds[i] ** 2) / l_bounds[i]\n        else:\n            cost_per_mw = (s + a + b * l_bounds[i] + c * l_bounds[i] ** 2) / l_bounds[i]\n        priority_list.append((cost_per_mw, i))\n    \n    priority_list.sort(key=lambda x: x[0])\n    flexible_sorted = [idx for _, idx in priority_list]\n\n    committed = set(forced_on)\n    total_min = sum(l_bounds[i] for i in forced_on)\n    total_max = sum(u_bounds[i] for i in forced_on)\n\n    if total_max < current_load:\n        for i in flexible_sorted:\n            committed.add(i)\n            total_min += l_bounds[i]\n            total_max += u_bounds[i]\n            if total_max >= current_load:\n                break\n\n    p_out = [0.0] * n_units\n    u_out = [0] * n_units\n\n    if current_load <= total_min:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = l_bounds[i]\n    elif current_load >= total_max:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = u_bounds[i]\n    else:\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_out[i] = max(l_bounds[i], min(u_bounds[i], unit['p_i_0']))\n            else:\n                p_out[i] = l_bounds[i]\n            u_out[i] = 1\n\n        total_p = sum(p_out)\n        tol = 0.01\n        max_iter = 1000\n        iter_count = 0\n\n        while abs(total_p - current_load) > tol and iter_count < max_iter:\n            if total_p < current_load:\n                min_mc = float('inf')\n                candidate = -1\n                for i in committed:\n                    if p_out[i] < u_bounds[i]:\n                        mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                        if mc < min_mc:\n                            min_mc = mc\n                            candidate = i\n                if candidate == -1:\n                    break\n                headroom = u_bounds[candidate] - p_out[candidate]\n                needed = current_load - total_p\n                delta = min(needed, headroom)\n                p_out[candidate] += delta\n                total_p += delta\n\n            else:\n                max_mc = -float('inf')\n                candidate = -1\n                for i in committed:\n                    if p_out[i] > l_bounds[i]:\n                        mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                        if mc > max_mc:\n                            max_mc = mc\n                            candidate = i\n                if candidate == -1:\n                    break\n                reduction = p_out[candidate] - l_bounds[candidate]\n                excess = total_p - current_load\n                delta = min(excess, reduction)\n                p_out[candidate] -= delta\n                total_p -= delta\n\n            iter_count += 1\n\n    return np.array([u_out, p_out])",
          "objective": 0.01045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy heuristic for the Rolling Unit Commitment problem. It consists of the following main steps:\n\n1. **Classify units** based on their previous state and constraints into:\n   - **Forced-on**: Units that must remain online due to minimum uptime constraints or previous output exceeding shutdown ramp limits.\n   - **Forced-off**: Units that cannot be started due to minimum downtime constraints.\n   - **Non-forced-on**: Units currently online that can be turned off.\n   - **Non-forced-off**: Units currently offline that can be started.\n\n2. **Initialize candidate units** to all forced-on and non-forced-on units. Compute their feasible power ranges (lb, ub) considering ramp constraints:\n   - For previously online units: lb = max(p_min_i, p_i_0 - p_down_i), ub = min(p_max_i, p_i_0 + p_up_i).\n   - For units being started: lb = p_min_i, ub = min(p_max_i, p_start_i).\n\n3. **Adjust candidate set based on load**:\n   - **Add non-forced-off units** if load exceeds the candidate set's maximum output. Prioritize units with the lowest cost per MW at minimum output.\n   - **Remove non-forced-on units** if the load is below the candidate set's minimum output. Prioritize units with the highest fixed cost that can be removed while maintaining feasibility.\n\n4. **Economic dispatch** within the candidate set:\n   - Set each unit to its lower bound.\n   - Distribute any residual load incrementally to the unit with the smallest marginal cost (b_i + 2*c_i*p_i) first, respecting upper bounds.\n\n5. **Output commitment (u_i) and power output (p_i)** for all units. Non-candidate units are set to offline (0).\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    forced_on = []\n    forced_off = []\n    non_forced_on = []\n    non_forced_off = []\n    \n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(unit)\n            else:\n                non_forced_on.append(unit)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                non_forced_off.append(unit)\n                \n    candidate_set = forced_on + non_forced_on\n    total_min = 0.0\n    total_max = 0.0\n    for unit in candidate_set:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        total_min += lb\n        total_max += ub\n        \n    if current_load > total_max:\n        non_forced_off.sort(key=lambda unit: \n                          (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i'])\n        for unit in non_forced_off:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            candidate_set.append(unit)\n            unit['lb'] = lb\n            unit['ub'] = ub\n            total_min += lb\n            total_max += ub\n            if current_load <= total_max:\n                break\n                \n    if current_load < total_min and non_forced_on:\n        changed = True\n        while changed and current_load < total_min:\n            changed = False\n            non_forced_on_sorted = sorted(non_forced_on, key=lambda unit: unit['a_i'], reverse=True)\n            for unit in non_forced_on_sorted:\n                new_total_min = total_min - unit['lb']\n                new_total_max = total_max - unit['ub']\n                if new_total_min <= current_load <= new_total_max:\n                    candidate_set.remove(unit)\n                    non_forced_on.remove(unit)\n                    total_min = new_total_min\n                    total_max = new_total_max\n                    changed = True\n                    break\n                    \n    for unit in candidate_set:\n        unit['p_i'] = unit['lb']\n        \n    residual = current_load - total_min\n    if residual > 0:\n        units_avail = [u for u in candidate_set if u['p_i'] < u['ub']]\n        while residual > 0 and units_avail:\n            units_avail.sort(key=lambda u: u['b_i'] + 2 * u['c_i'] * u['p_i'])\n            u = units_avail[0]\n            delta = min(residual, u['ub'] - u['p_i'])\n            u['p_i'] += delta\n            residual -= delta\n            if u['p_i'] >= u['ub']:\n                units_avail.pop(0)\n                \n    u_list = []\n    p_list = []\n    for unit in units_info:\n        if unit in candidate_set:\n            u_list.append(1)\n            p_list.append(unit['p_i'])\n        else:\n            u_list.append(0)\n            p_list.append(0.0)\n            \n    schedules = np.array([u_list, p_list])\n    return schedules",
          "objective": 0.01739,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a priority-based heuristic that determines unit commitment and economic dispatch for the current time step in a rolling unit commitment problem. It classifies units into must-on (due to min-up time or shutdown ramp constraints), must-off (due to min-down time constraints), and free units. Must-on units are set to their minimum feasible output based on ramp constraints. Free online units (already running and not must-on) are sorted by production cost at minimum output in descending order; expensive units are turned off if feasible without underproducing. The remaining free online and must-on units are economically dispatched using a merit order based on incremental cost to meet any residual load. If underproduction persists, free offline units (available to start) are sorted by their average cost at minimum output and committed greedily to minimize the gap and total cost. The algorithm ensures physical constraints like minimum up/down times, ramp limits, and output bounds are satisfied while meeting load as closely as possible and minimizing costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    \n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(unit)\n            else:\n                free_online.append(unit)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_offline.append(unit)\n    \n    # Set must_off units\n    for unit in must_off:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Set must_on units to minimum feasible output\n    for unit in must_on:\n        unit['u_i'] = 1\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['min_output_i'] = min_output\n        unit['max_output_i'] = max_output\n        unit['p_i'] = min_output\n    \n    # Process free online units\n    total_min_must = sum(unit['p_i'] for unit in must_on)\n    for unit in free_online:\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['min_output_i'] = min_output\n        unit['max_output_i'] = max_output\n        unit['p_i'] = min_output\n        unit['u_i'] = 1\n    \n    total_min_free_online = sum(unit['p_i'] for unit in free_online)\n    total_min = total_min_must + total_min_free_online\n    unmet_after_must = current_load - total_min_must\n    \n    if free_online and unmet_after_must >= 0:\n        # Sort free_online by cost at min_output in descending order\n        free_online_sorted = sorted(\n            free_online,\n            key=lambda x: x['a_i'] + x['b_i'] * x['min_output_i'] + x['c_i'] * x['min_output_i']**2,\n            reverse=True\n        )\n        current_total = total_min_must + total_min_free_online\n        for unit in free_online_sorted:\n            if current_total - unit['min_output_i'] >= current_load:\n                unit['u_i'] = 0\n                unit['p_i'] = 0\n                current_total -= unit['min_output_i']\n    \n    # Collect online units for economic dispatch\n    online_units = []\n    for unit in must_on + free_online:\n        if unit['u_i'] == 1:\n            online_units.append(unit)\n    \n    # Initial output for online units\n    current_output = sum(unit['p_i'] for unit in online_units)\n    residual = current_load - current_output\n    if residual > 0:\n        # Sort by incremental cost at current output (min_output)\n        online_units_sorted = sorted(\n            online_units,\n            key=lambda unit: unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n        )\n        for unit in online_units_sorted:\n            if residual <= 0:\n                break\n            available = unit['max_output_i'] - unit['p_i']\n            if available > 0:\n                delta = min(residual, available)\n                unit['p_i'] += delta\n                residual -= delta\n    \n    # If still underproduced, consider free_offline units\n    total_with_online = sum(unit['p_i'] for unit in must_on + free_online + must_off)\n    residual_after_online = current_load - total_with_online\n    if residual_after_online > 0:\n        # Sort free_offline by average cost at min_output\n        free_offline_sorted = sorted(\n            free_offline,\n            key=lambda unit: (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                             unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        )\n        residual = residual_after_online\n        for unit in free_offline_sorted:\n            if residual <= 0:\n                break\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n            if min_output <= residual <= max_output:\n                unit['u_i'] = 1\n                unit['p_i'] = residual\n                residual = 0\n            elif residual < min_output:\n                if min_output - residual <= residual:\n                    unit['u_i'] = 1\n                    unit['p_i'] = min_output\n                    residual -= min_output\n                else:\n                    unit['u_i'] = 0\n                    unit['p_i'] = 0\n            else:  # residual > max_output\n                unit['u_i'] = 1\n                unit['p_i'] = max_output\n                residual -= max_output\n    else:\n        for unit in free_offline:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Set free_offline that weren't processed (if any)\n    for unit in free_offline:\n        if 'u_i' not in unit:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Prepare output\n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    schedules = np.array([u_list, p_list])\n    return schedules",
          "objective": 0.01751,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic is a priority-based approach that considers unit constraints and cost efficiency. The steps are:\n\n1. **Classify Units:** \n   - *Must-run units:* Online units that haven't satisfied minimum uptime or whose previous output exceeds shutdown capacity.\n   - *Must-off units:* Offline units that haven't satisfied minimum downtime.\n   - *Flexible units:* Remaining units that can be turned on or off.\n\n2. **Initial Commitment:**\n   - Commit must-run units and all flexible units that were previously online.\n\n3. **Calculate Ramp-Constrained Limits:**\n   - For each committed unit, compute current-period min/max output using ramp constraints:\n     - If unit was online: `[max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]`\n     - If started now: `[p_min_i, min(p_max_i, p_start_i)]`\n   - Total min (`T_min`) and max (`T_max`) output for the committed set.\n\n4. **Adjust Commitment:**\n   - **If load > T_max:** Start available offline flexible units sorted by (startup cost + min output cost)/min output. Add until `T_max >= load`.\n   - **If load < T_min:** Turn off expensive online flexible units sorted by (min output cost)/min output descending. Remove until `T_min <= load`.\n\n5. **Economic Dispatch:**\n   - Use lambda iteration to allocate exact load among committed units, respecting:\n     - Ramp constraints based on previous state.\n     - Unit output limits.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible = []  # Each elem: (index, state: 0=off/1=on, u_i_0)\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append((i, 1, u_i_0))\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append((i, 0, u_i_0))\n    \n    # Step 2: Initial committed units\n    committed = set(must_run)\n    committed.update(i for i, state, u_i_0 in flexible if state == 1)\n    \n    # Helper: Compute available min/max for unit i\n    def available_limits(i):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        return low, high\n    \n    # Step 3: Initial T_min, T_max\n    T_min = 0.0\n    T_max = 0.0\n    avail_low = [0] * n_units\n    avail_high = [0] * n_units\n    for i in committed:\n        low_i, high_i = available_limits(i)\n        avail_low[i] = low_i\n        avail_high[i] = high_i\n        T_min += low_i\n        T_max += high_i\n    \n    # Step 4: Add units if needed (load > T_max)\n    if current_load > T_max:\n        candidates = []\n        for i, state, u_i_0 in flexible:\n            if state == 0 and i not in committed:\n                unit = units_info[i]\n                # Check if can start (p_min_i <= p_start_i)\n                if unit['p_min_i'] <= unit['p_start_i']:\n                    cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                                  unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n                    candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1])  # Ascending cost\n        \n        for i, _ in candidates:\n            low_i = units_info[i]['p_min_i']\n            high_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            if T_min + low_i > T_max + high_i: \n                continue\n            T_min += low_i\n            T_max += high_i\n            committed.add(i)\n            avail_low[i] = low_i\n            avail_high[i] = high_i\n            if T_max >= current_load:\n                break\n    \n    # Step 5: Remove units if needed (load < T_min)\n    if current_load < T_min:\n        candidates = []\n        for i, state, u_i_0 in flexible:\n            if state == 1 and i in committed and u_i_0 == 1 and i not in must_run:\n                unit = units_info[i]\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                              unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n                candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)  # Descending cost\n        \n        for i, _ in candidates:\n            low_i = avail_low[i]\n            high_i = avail_high[i]\n            T_min_new = T_min - low_i\n            T_max_new = T_max - high_i\n            if T_min_new <= current_load <= T_max_new:\n                T_min = T_min_new\n                T_max = T_max_new\n                committed.remove(i)\n                avail_low[i] = 0\n                avail_high[i] = 0\n                if T_min <= current_load:\n                    break\n    \n    # Step 6: Economic Dispatch using Lambda Iteration\n    p_i_out = [0.0] * n_units\n    u_i_out = [0] * n_units\n    \n    # Collect committed units and their bounds\n    comm_list = []\n    bounds = []\n    b = []\n    c = []\n    for i in committed:\n        unit = units_info[i]\n        u_i_out[i] = 1\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        comm_list.append(i)\n        bounds.append((low_i, high_i))\n        b.append(unit['b_i'])\n        c.append(unit['c_i'])\n    \n    if comm_list:\n        n_comm = len(comm_list)\n        lambda_low = min(b_i + 2 * c_i * bounds[i][0] for i, (b_i, c_i) in enumerate(zip(b, c)))\n        lambda_high = max(b_i + 2 * c_i * bounds[i][1] for i, (b_i, c_i) in enumerate(zip(b, c)))\n        total_p = 0\n        tolerance = 0.001\n        max_iter = 1000\n        \n        # If bounds allow adjustment\n        if abs(lambda_low - lambda_high) > tolerance:\n            for _ in range(max_iter):\n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_p = 0.0\n                for i in range(n_comm):\n                    p_val = (lambda_mid - b[i]) / (2 * c[i])\n                    p_val = max(bounds[i][0], min(bounds[i][1], p_val))\n                    total_p += p_val\n                \n                if abs(total_p - current_load) < tolerance:\n                    break\n                if total_p < current_load:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n        \n        # Assign power to committed units\n        for idx, i in enumerate(comm_list):\n            p_val = (lambda_mid - b[idx]) / (2 * c[idx])\n            p_val = max(bounds[idx][0], min(bounds[idx][1], p_val))\n            p_i_out[i] = p_val\n    \n    # Step 7: Format output\n    schedules = np.array([u_i_out, p_i_out])\n    return schedules",
          "objective": 0.01809,
          "other_inf": null
     }
]