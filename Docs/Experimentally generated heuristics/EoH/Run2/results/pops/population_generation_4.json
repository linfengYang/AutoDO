[
     {
          "algorithm": "This algorithm performs unit commitment and economic dispatch using a ramp-constrained startup-costâ€“aware heuristic with next-period load consideration. Key steps: 1) Compute feasible min/max outputs per unit considering ramp limits and startup constraints; 2) Classify units into forced-on, forced-off, and flexible categories; 3) Commit forced-on units; 4) Greedily add flexible units ranked by effective cost/MW (amortizing startup costs if next-period load is high); 5) Prune expensive flexible units operating above minimum output; 6) Economically dispatch committed units by reducing output from highest-marginal-cost units first while respecting individual min/max limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Precompute min/max outputs considering ramp constraints\n    min_i_dict = {}\n    max_i_dict = {}\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Unit was offline\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_i_dict[i] = min_i\n        max_i_dict[i] = max_i\n    \n    # Classify units based on physical constraints\n    forced_on = []\n    forced_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize with forced-on units\n    candidate_set = forced_on[:]\n    total_min = sum(min_i_dict[i] for i in forced_on)\n    total_max = sum(max_i_dict[i] for i in forced_on)\n    \n    # Add flexible units greedily with recalculated metrics\n    flexible_remaining = flexible[:]\n    while flexible_remaining and total_max < current_load:\n        adjusted_data = []\n        for i in flexible_remaining:\n            unit = units_info[i]\n            # Adjust startup cost based on next period load\n            if unit['u_i_0'] == 0:  # Unit was offline\n                if next_load > total_max:  # Amortize startup if needed next period\n                    effective_startup = 0\n                else:\n                    effective_startup = unit['s_i']\n            else:\n                effective_startup = 0\n                \n            # Compute full cost at max output\n            full_cost = (unit['a_i'] + unit['b_i'] * max_i_dict[i] + \n                         unit['c_i'] * max_i_dict[i]**2 + effective_startup)\n            metric = full_cost / max_i_dict[i]\n            adjusted_data.append((i, metric, min_i_dict[i], max_i_dict[i]))\n        \n        # Select most cost-efficient unit\n        i, metric, min_i, max_i = min(adjusted_data, key=lambda x: x[1])\n        candidate_set.append(i)\n        flexible_remaining.remove(i)\n        total_min += min_i\n        total_max += max_i\n    \n    # Prune unnecessary units using operating cost only\n    prune_list = []\n    for i in candidate_set:\n        if i in forced_on:  # Don't prune forced-on units\n            continue\n        unit = units_info[i]\n        # Compute operating cost at max output (no startup)\n        op_cost = (unit['a_i'] + unit['b_i'] * max_i_dict[i] + \n                   unit['c_i'] * max_i_dict[i]**2)\n        metric = op_cost / max_i_dict[i]\n        prune_list.append((metric, i, min_i_dict[i], max_i_dict[i]))\n    \n    prune_list.sort(key=lambda x: x[0], reverse=True)  # Highest cost first\n    for metric_val, i, min_i, max_i in prune_list:\n        new_min = total_min - min_i\n        new_max = total_max - max_i\n        if new_min <= current_load <= new_max:\n            candidate_set.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Initialize commitment and dispatch at maximum capacity\n    u_arr = [1 if i in candidate_set else 0 for i in range(n_units)]\n    p_arr = [max_i_dict[i] if u_arr[i] else 0 for i in range(n_units)]\n    residual = total_max - current_load\n    \n    # Economic dispatch: reduce expensive units first\n    reduce_list = []\n    for i in candidate_set:\n        # Calculate marginal cost at current output (max_i)\n        mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n        reduction_room = p_arr[i] - min_i_dict[i]\n        reduce_list.append((mc, i, reduction_room))\n    \n    # Sort by marginal cost descending\n    reduce_list.sort(key=lambda x: x[0], reverse=True)\n    \n    for mc, i, room in reduce_list:\n        if residual <= 0:\n            break\n        reduction = min(residual, room)\n        p_arr[i] -= reduction\n        residual -= reduction\n    \n    return np.array([u_arr, p_arr])",
          "objective": 0.00476,
          "other_inf": null
     },
     {
          "algorithm": "The \"Flexible Ramp and Stability-Cost Heuristic\" integrates forward-looking ramp requirements, unit state stability, and normalized cost components. Key steps:\n1. Compute feasible power ranges considering current state and ramp constraints\n2. Classify units into must-run, must-off, and flexible based on minimum up/down times\n3. Commit must-run units at minimum feasible output\n4. Calculate total system deficiency for current/next periods\n5. Prioritize flexible units using normalized cost metric balancing:\n   - Current-period marginal cost\n   - Next-period average cost\n   - Ramp-down capability for future adjustments\n   - State stability incentive (longer online/offline durations favored)\n6. Commit units until demands are covered\n7. Perform stability-weighted decommitment: remove high-cost units considering ramp reserves and time in current state\n8. Execute lambda-based economic dispatch with ramp-rate constraints\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Initialize outputs\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    \n    # Calculate deficiencies\n    def_current = max(0, current_load - total_max_current)\n    def_next = max(0, next_load - total_max_next)\n    \n    # Calculate normalization factors\n    max_marginal = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for unit in units_info) if units_info else 1\n    max_ramp_down = max(unit['p_down_i'] for unit in units_info) if units_info else 1\n    max_state_time = max(max(abs(unit['t_i_0']) for unit in units_info), 1) if units_info else 1\n    \n    # Flexible unit prioritization\n    priorities = []\n    for i in flexible:\n        if i in must_off:\n            continue\n            \n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p = p_max_feasible[i]\n        max_next = unit['p_max_i']\n        \n        # Current period cost components\n        current_cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n        \n        # Next period cost estimate\n        next_cost = unit['a_i'] + unit['b_i']*max_next + unit['c_i']*max_next**2\n        \n        # Normalized metrics\n        cost_current = (current_cost + startup_cost) / min_p if min_p > 0 else float('inf')\n        cost_next = next_cost / max_next if max_next > 0 else float('inf')\n        \n        # Combined priority metric (lower is better)\n        cost_component = 0.6 * (cost_current / max_marginal) + 0.4 * (cost_next / max_marginal)\n        ramp_component = -0.3 * (unit['p_down_i'] / max_ramp_down)  # Negative for better ramp-down\n        stability_component = 0.1 * (abs(unit['t_i_0']) / max_state_time)\n        \n        priority = cost_component + ramp_component + stability_component\n        priorities.append((i, priority, min_p, max_p, max_next))\n    \n    # Sort by ascending priority\n    priorities.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    for i, _, min_p, max_p, max_next in priorities:\n        if def_current <= 0 and def_next <= 0:\n            break\n        u_out[i] = 1\n        p_out[i] = min_p\n        committed.add(i)\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n        def_current = max(0, current_load - total_max_current)\n        def_next = max(0, next_load - total_max_next)\n    \n    # Stability-weighted decommitment\n    if len(committed) > len(must_run):\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            min_p = p_min_feasible[i]\n            max_p = p_max_feasible[i]\n            max_next = units_info[i]['p_max_i']\n            new_min = total_min_current - min_p\n            new_max_current = total_max_current - max_p\n            new_max_next = total_max_next - max_next\n            \n            if new_max_current < current_load or new_max_next < next_load:\n                continue\n                \n            # Cost and state metrics\n            state_time = abs(units_info[i]['t_i_0'])\n            current_cost = (units_info[i]['a_i'] + units_info[i]['b_i']*min_p + units_info[i]['c_i']*min_p**2) / min_p\n            decommit_score = current_cost + 0.2 * (state_time / max_state_time)  # Prefer removing high-cost + unstable units\n            decommit_candidates.append((i, decommit_score, min_p, max_p, max_next))\n        \n        # Sort by descending decommit score\n        decommit_candidates.sort(key=lambda x: -x[1])\n        for candidate in decommit_candidates:\n            i, _, min_p, max_p, max_next = candidate\n            u_out[i] = 0\n            p_out[i] = 0\n            committed.remove(i)\n            total_min_current -= min_p\n            total_max_current -= max_p\n            total_max_next -= max_next\n            # Recheck system constraints after each removal\n            if total_max_current < current_load or total_max_next < next_load:\n                committed.add(i)\n                u_out[i] = 1\n                p_out[i] = p_min_feasible[i]\n                total_min_current += min_p\n                total_max_current += max_p\n                total_max_next += max_next\n                break\n    \n    # Lambda iteration dispatch with ramp constraints\n    committed_list = list(committed)\n    if not committed_list:\n        return np.array([u_out, p_out])\n    \n    # Initialize at minimum outputs\n    for i in committed_list:\n        p_out[i] = p_min_feasible[i]\n    \n    target = max(total_min_current, min(total_max_current, current_load))\n    residual = target - sum(p_min_feasible[i] for i in committed_list)\n    \n    # Dispatch parameters\n    b_vals = [units_info[i]['b_i'] for i in committed_list]\n    c_vals = [units_info[i]['c_i'] for i in committed_list]\n    min_lims = [p_min_feasible[i] for i in committed_list]\n    max_lims = [p_max_feasible[i] for i in committed_list]\n    \n    # Lambda iteration\n    lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_vals, c_vals, min_lims))\n    lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_vals, c_vals, max_lims))\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        # Allocate power based on lambda\n        for idx, i in enumerate(committed_list):\n            p_ideal = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx]) if c_vals[idx] > 0 else max_lims[idx]\n            # Apply ramp constraints\n            if units_info[i]['u_i_0'] == 1:\n                ramp_bound = units_info[i]['p_i_0'] + units_info[i]['p_up_i']\n                p_ideal = min(p_ideal, ramp_bound)\n            p_val = max(min_lims[idx], min(max_lims[idx], p_ideal))\n            p_out[i] = p_val\n            total_gen += p_val\n        \n        # Adjust lambda\n        if abs(total_gen - target) < 0.01:\n            break\n        if total_gen < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00564,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm modifies the scoring function for the next period commitment stage by introducing weighted parameters (w1=0.7 for next period capacity, w2=0.3 for current period capacity) to prioritize units that balance both periods' requirements. Key steps: 1) Compute feasible power ranges considering ramp constraints; 2) Classify units into must-run, must-off, and flexible; 3) Commit must-run units and turn off must-off units; 4) Commit flexible units in two stages - first for next period capacity using a modified score (startup cost + min generation cost)/(w1*max_next_capacity + w2*current_max_capacity), then for current period capacity using marginal cost; 5) Decommit non-essential units; 6) Perform economic dispatch starting from min power, distributing residual load by marginal cost.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Initial capacity from must-run units\n    committed = set(must_run)\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Weight parameters for modified scoring\n    w1, w2 = 0.7, 0.3\n    \n    # Stage 1: Ensure next period capacity with modified score\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n            cost_at_min = unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2\n            total_cost = startup_cost + cost_at_min\n            # Modified denominator with weights\n            combined_cap = w1 * unit['p_max_i'] + w2 * p_max_feasible[i]\n            priority = total_cost / combined_cap\n            candidates.append((i, priority, unit['p_max_i'], p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap_next, cap_current in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap_current\n            total_max_next += cap_next\n    \n    # Stage 2: Ensure current period capacity\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_feasible[i]\n            priority = marginal_cost / p_max_feasible[i]\n            candidates.append((i, priority, p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n            total_max_next += units_info[i]['p_max_i']\n    \n    # Decommit overcommitted units with feasibility check\n    decommit_candidates = []\n    for i in committed:\n        if i in must_run:\n            continue\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p_current = p_max_feasible[i]\n        max_p_next = unit['p_max_i']\n        cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        if unit['u_i_0'] == 0:\n            cost_per_mw += unit['s_i'] / min_p\n        decommit_candidates.append((i, cost_per_mw, min_p, max_p_current, max_p_next))\n    \n    decommit_candidates.sort(key=lambda x: -x[1])\n    for i, _, min_p, max_p_current, max_p_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p_current\n        new_max_next = total_max_next - max_p_next\n        # Check feasibility for both periods after decommitment\n        if new_min <= current_load <= new_max_current and next_load <= new_max_next:\n            committed.remove(i)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.0058,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm schedules units for the current period while considering both current and next period loads. It first computes feasible power ranges and classifies units into must-run, must-off, and flexible categories. Must-run units are committed at minimum power, while must-off units are turned off. Flexible units are committed in two stages: first for next period capacity, then for current period capacity, prioritizing units based on cost efficiency. A decommitment step removes non-essential units by ensuring feasibility for both current and next periods with updated constraints. Finally, economic dispatch assigns minimum power then distributes residual load based on marginal costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Initial capacity from must-run units\n    committed = set(must_run)\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Stage 1: Ensure next period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            cost = unit['s_i'] * (1 - unit['u_i_0']) \n            cost += unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2\n            priority = cost / unit['p_max_i']\n            candidates.append((i, priority, unit['p_max_i']))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap\n    \n    # Stage 2: Ensure current period capacity\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_feasible[i]\n            priority = marginal_cost / p_max_feasible[i]\n            candidates.append((i, priority, p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n            total_max_next += units_info[i]['p_max_i']\n    \n    # Decommit overcommitted units with feasibility check\n    decommit_candidates = []\n    for i in committed:\n        if i in must_run:\n            continue\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p_current = p_max_feasible[i]\n        max_p_next = unit['p_max_i']\n        cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        if unit['u_i_0'] == 0:\n            cost_per_mw += unit['s_i'] / min_p\n        decommit_candidates.append((i, cost_per_mw, min_p, max_p_current, max_p_next))\n    \n    decommit_candidates.sort(key=lambda x: -x[1])\n    for i, _, min_p, max_p_current, max_p_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p_current\n        new_max_next = total_max_next - max_p_next\n        # Check feasibility for both periods after decommitment\n        if new_min <= current_load <= new_max_current and next_load <= new_max_next:\n            committed.remove(i)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00584,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the existing heuristic by adjusting the efficiency metrics used for committing free offline units and decommitting free online units. Instead of a two-period cost efficiency ratio for committing units, it uses a one-period ratio (startup cost plus one period of production cost at minimum output per MW). For decommitting units, it uses the marginal cost at minimum output (coefficient b_i + 2*c_i*min_output) instead of average cost. This prioritizes units with lower incremental costs and better reflects cost changes per additional MW. The main steps remain: classify units, commit must-run/free online, assess capacity needs, commit free offline units with new efficiency metric, decommit expensive units with new marginal cost metric, and perform economic dispatch.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on) | set(free_online)\n    \n    # Compute current bounds and next period capacity\n    lb = [0] * len(units_info)\n    ub = [0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[idx] = unit['p_min_i']\n            ub[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n        total_max_next += unit['p_max_i']\n    \n    # Commit free_offline units using one-period efficiency\n    candidates = []\n    for idx in free_offline:\n        unit = units_info[idx]\n        min_output = unit['p_min_i']\n        one_period_cost = unit['s_i'] + (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2)\n        efficiency_ratio = one_period_cost / min_output\n        max_output = min(unit['p_max_i'], unit['p_start_i'])\n        candidates.append((idx, efficiency_ratio, min_output, max_output, unit['p_max_i']))\n    \n    candidates.sort(key=lambda x: x[1])\n    \n    for idx, _, min_p, max_p, max_next in candidates:\n        if total_max_current >= current_load and total_max_next >= next_load:\n            break\n        committed.add(idx)\n        lb[idx] = min_p\n        ub[idx] = max_p\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n    \n    # Decommit using marginal cost at minimum output\n    decommit_candidates = []\n    for idx in free_online:\n        if idx not in must_on and idx in committed:\n            unit = units_info[idx]\n            min_output = lb[idx]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_output\n            decommit_candidates.append(\n                (idx, marginal_cost, lb[idx], ub[idx], unit['p_max_i'])\n            )\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    \n    for idx, _, min_p, max_p, max_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p\n        new_max_next = total_max_next - max_next\n        if (new_min <= current_load and \n            new_max_current >= current_load and \n            new_max_next >= next_load):\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Initialize outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            unit = units_info[idx]\n            available = ub[idx] - p_out[idx]\n            allocate = min(available, residual)\n            p_out[idx] += allocate\n            residual -= allocate\n            if residual <= 1e-6:\n                break\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "objective": 0.00601,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, \"Ramp-Weighted Dynamic Commitment Heuristic\", integrates ramp flexibility and normalized cost metrics to prioritize unit commitments. It features:\n1. Precomputation of feasible power ranges for each unit.\n2. Classification into must-run, must-off, and flexible units based on current state and min up/down constraints.\n3. Calculation of dynamic priority scores combining cost-efficiency, ramp flexibility, and next-period utility using normalized weights.\n4. Unified commitment of flexible units in priority order until both current and next period capacity requirements are met.\n5. Iterative decommitment of the most expensive units (based on minimal-output cost per MW) while maintaining feasibility for both periods.\n6. Economic dispatch with ramp-aware marginal cost ordering for residual load allocation.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs and committed set\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    committed = set(must_run)\n    \n    # Set must-run and must-off units\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Compute normalization factors\n    max_ramp_range = max((unit['p_up_i'] + unit['p_down_i']) for unit in units_info) if n_units > 0 else 1.0\n    max_p_max = max(unit['p_max_i'] for unit in units_info) if n_units > 0 else 1.0\n    \n    # Calculate priority scores for flexible units\n    priorities = []\n    for i in flexible:\n        if i in must_off:\n            continue\n        unit = units_info[i]\n        startup_needed = 1 - unit['u_i_0']\n        cost_current = startup_needed * unit['s_i'] + (unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2)\n        ramp_flex = (unit['p_up_i'] + unit['p_down_i']) / max_ramp_range\n        next_util = unit['p_max_i'] / max_p_max\n        \n        current_capacity = max(p_max_feasible[i], 1e-6)  # Avoid division by zero\n        cost_component = cost_current / current_capacity\n        priority = 0.5 * cost_component - 0.3 * ramp_flex - 0.2 * next_util\n        priorities.append((i, priority, p_min_feasible[i], p_max_feasible[i], unit['p_max_i']))\n    \n    # Commit units based on priority\n    priorities.sort(key=lambda x: x[1])\n    for i, _, min_p, max_p, max_next in priorities:\n        if total_max_current >= current_load and total_max_next >= next_load:\n            break\n        committed.add(i)\n        u_out[i] = 1\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n    \n    # Iterative decommitment of expensive units\n    changed = True\n    while changed:\n        changed = False\n        decommit_list = []\n        for i in committed:\n            if i in must_run:\n                continue\n            unit = units_info[i]\n            startup_needed = 1 - unit['u_i_0']\n            cost_current = startup_needed * unit['s_i'] + (unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2)\n            avg_cost = cost_current / max(p_min_feasible[i], 1e-6)\n            decommit_list.append((i, avg_cost, p_min_feasible[i], p_max_feasible[i], unit['p_max_i']))\n        \n        if decommit_list:\n            decommit_list.sort(key=lambda x: x[1], reverse=True)\n            i_remove, _, min_remove, max_remove, max_next_remove = decommit_list[0]\n            if (total_max_current - max_remove >= current_load) and (total_max_next - max_next_remove >= next_load):\n                committed.remove(i_remove)\n                u_out[i_remove] = 0\n                total_min_current -= min_remove\n                total_max_current -= max_remove\n                total_max_next -= max_next_remove\n                changed = True\n    \n    # Economic dispatch\n    residual = current_load\n    for i in committed:\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        dispatch_units = []\n        for i in committed:\n            if p_out[i] < p_max_feasible[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                available = p_max_feasible[i] - p_out[i]\n                dispatch_units.append((i, marginal_cost, available))\n        dispatch_units.sort(key=lambda x: x[1])\n        \n        for i, _, avail in dispatch_units:\n            if residual <= 0:\n                break\n            allocated = min(residual, avail)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00605,
          "other_inf": null
     },
     {
          "algorithm": "This new heuristic, named \"Enhanced Flexibility-Penalty Heuristic\", modifies the unit prioritization and decommitment strategies with stronger emphasis on operational flexibility and constraint penalties. Key steps:\n1. Compute feasible power ranges considering current state, ramp, and start/shutdown limits\n2. Classify units into must-run, must-off, and flexible based on minimum up/down times\n3. Commit must-run units at minimum feasible output\n4. Calculate total system deficiency for current and next periods\n5. Prioritize flexible units using modified metric:\n   - 40% weight on current-period cost per MW\n   - 30% weight on next-period cost per MW\n   - 15% weight on ramp-down flexibility (normalized)\n   - 15% weight on stability penalty (favoring units near min up/down completion)\n6. Commit highest-priority units until demands are covered\n7. Decommit using ramp-constrained penalty score:\n   - Combine per-MW operating cost and stability penalty\n   - Include ramp-down capability for next-period adjustment cost\n8. Execute lambda-based economic dispatch respecting ramp constraints\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Initialize outputs\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    \n    # Calculate deficiencies\n    def_current = max(0, current_load - total_max_current)\n    def_next = max(0, next_load - total_max_next)\n    \n    # Calculate normalization factors\n    max_marginal = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for unit in units_info) if units_info else 1\n    max_ramp_down = max(unit['p_down_i'] for unit in units_info) if units_info else 1\n    max_state_time = max(max(abs(unit['t_i_0']) for unit in units_info), 1) if units_info else 1\n    \n    # Flexible unit prioritization\n    priorities = []\n    for i in flexible:\n        if i in must_off:\n            continue\n            \n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p = p_max_feasible[i]\n        max_next = unit['p_max_i']\n        \n        # Current period cost components\n        current_cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2\n        startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n        \n        # Next period cost estimate\n        next_cost = unit['a_i'] + unit['b_i']*max_next + unit['c_i']*max_next**2\n        \n        # Normalized metrics\n        cost_current = (current_cost + startup_cost) / min_p if min_p > 0 else float('inf')\n        cost_next = next_cost / max_next if max_next > 0 else float('inf')\n        \n        # Stability penalty: favor units near min up/down completion\n        state_percent = 0\n        if unit['u_i_0'] == 1:\n            if unit['t_on_min_i'] > 0:\n                state_percent = min(1.0, unit['t_i_0'] / unit['t_on_min_i'])\n        else:\n            if unit['t_off_min_i'] > 0:\n                state_percent = min(1.0, abs(unit['t_i_0']) / unit['t_off_min_i'])\n        stability_penalty = 1.0 - state_percent  # Lower when near constraint completion\n        \n        # Combined priority metric (lower is better)\n        cost_component = 0.4 * (cost_current / max_marginal) + 0.3 * (cost_next / max_marginal)\n        ramp_component = -0.15 * (unit['p_down_i'] / max_ramp_down)  # Negative for better ramp-down\n        stability_component = 0.15 * stability_penalty\n        \n        priority = cost_component + ramp_component + stability_component\n        priorities.append((i, priority, min_p, max_p, max_next))\n    \n    # Sort by ascending priority\n    priorities.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    for i, _, min_p, max_p, max_next in priorities:\n        if def_current <= 0 and def_next <= 0:\n            break\n        u_out[i] = 1\n        p_out[i] = min_p\n        committed.add(i)\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n        def_current = max(0, current_load - total_max_current)\n        def_next = max(0, next_load - total_max_next)\n    \n    # Flexibility-penalty decommitment\n    if len(committed) > len(must_run):\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            min_p = p_min_feasible[i]\n            max_p = p_max_feasible[i]\n            max_next = units_info[i]['p_max_i']\n            new_min = total_min_current - min_p\n            new_max_current = total_max_current - max_p\n            new_max_next = total_max_next - max_next\n            \n            if new_max_current < current_load or new_max_next < next_load:\n                continue\n                \n            # Cost metrics\n            current_cost = (units_info[i]['a_i'] + units_info[i]['b_i']*min_p + units_info[i]['c_i']*min_p**2) / min_p\n            future_penalty = 0.1 * (units_info[i]['p_down_i'] / max_ramp_down)  # Lower penalty for better ramp-down\n            \n            # Stability penalty (reverse of commitment logic)\n            state_percent = 0\n            if units_info[i]['u_i_0'] == 1:\n                if units_info[i]['t_on_min_i'] > 0:\n                    state_percent = min(1.0, units_info[i]['t_i_0'] / units_info[i]['t_on_min_i'])\n            else:\n                if units_info[i]['t_off_min_i'] > 0:\n                    state_percent = min(1.0, abs(units_info[i]['t_i_0']) / units_info[i]['t_off_min_i'])\n            stability_penalty = state_percent  # Higher for newly changed units\n            \n            decommit_score = current_cost - future_penalty + 0.2 * stability_penalty\n            decommit_candidates.append((i, decommit_score, min_p, max_p, max_next))\n        \n        # Sort by descending decommit score\n        decommit_candidates.sort(key=lambda x: -x[1])\n        for candidate in decommit_candidates:\n            i, _, min_p, max_p, max_next = candidate\n            u_out[i] = 0\n            p_out[i] = 0\n            committed.remove(i)\n            total_min_current -= min_p\n            total_max_current -= max_p\n            total_max_next -= max_next\n            # Recheck system constraints after each removal\n            if total_max_current < current_load or total_max_next < next_load:\n                committed.add(i)\n                u_out[i] = 1\n                p_out[i] = p_min_feasible[i]\n                total_min_current += min_p\n                total_max_current += max_p\n                total_max_next += max_next\n                break\n    \n    # Lambda iteration dispatch with ramp constraints\n    committed_list = list(committed)\n    if not committed_list:\n        return np.array([u_out, p_out])\n    \n    # Initialize at minimum outputs\n    for i in committed_list:\n        p_out[i] = p_min_feasible[i]\n    \n    target = max(total_min_current, min(total_max_current, current_load))\n    residual = target - sum(p_min_feasible[i] for i in committed_list)\n    \n    # Dispatch parameters\n    b_vals = [units_info[i]['b_i'] for i in committed_list]\n    c_vals = [units_info[i]['c_i'] for i in committed_list]\n    min_lims = [p_min_feasible[i] for i in committed_list]\n    max_lims = [p_max_feasible[i] for i in committed_list]\n    \n    # Lambda iteration\n    lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_vals, c_vals, min_lims))\n    lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_vals, c_vals, max_lims))\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        # Allocate power based on lambda\n        for idx, i in enumerate(committed_list):\n            p_ideal = (lambda_mid - b_vals[idx]) / (2 * c_vals[idx]) if c_vals[idx] > 0 else max_lims[idx]\n            # Apply ramp constraints\n            if units_info[i]['u_i_0'] == 1:\n                ramp_bound = units_info[i]['p_i_0'] + units_info[i]['p_up_i']\n                p_ideal = min(p_ideal, ramp_bound)\n            p_val = max(min_lims[idx], min(max_lims[idx], p_ideal))\n            p_out[i] = p_val\n            total_gen += p_val\n        \n        # Adjust lambda\n        if abs(total_gen - target) < 0.01:\n            break\n        if total_gen < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00608,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, named \"Dynamic Priority with Feasibility Adjustment\", introduces an adaptive priority metric that balances the current and next-period demands by weighting the cost per MW for each period based on the deficiency severity. It enhances feasibility handling during commitment by ensuring that only units which contribute positively to meeting unmet demands are committed. Main steps:\n1. Precompute feasible power output ranges considering ramp constraints and current state.\n2. Classify units into must-run, must-off, and flexible categories.\n3. Commit must-run units at minimum feasible output.\n4. Calculate current-period and next-period capacity deficiencies.\n5. Compute dynamic weight for next period based on deficiencies.\n6. Calculate unit priorities: (current cost/MW) \u00d7 (1 - w_next) + (fixed cost/MW for next period) \u00d7 w_next.\n7. Commit flexible units by ascending priority until either deficiency is resolved.\n8. Decommit units using marginal cost at minimum output if system constraints allow.\n9. Perform economic dispatch: allocate minimum outputs first, then residual load by ascending marginal cost.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    committed = set()\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    # Commit must-run units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        committed.add(i)\n        total_min_current += p_min_feasible[i]\n        total_max_current += p_max_feasible[i]\n        total_max_next += units_info[i]['p_max_i']\n    \n    # Compute deficiencies\n    deficiency_current = max(0, current_load - total_max_current)\n    deficiency_next = max(0, next_load - total_max_next)\n    total_deficiency = deficiency_current + deficiency_next\n    w_next = deficiency_next / (total_deficiency + 1e-9) if total_deficiency > 0 else 0.0\n    \n    # Calculate priorities for flexible units\n    priorities = []\n    for i in flexible:\n        if i in must_off:\n            continue\n            \n        unit = units_info[i]\n        startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n        min_output = p_min_feasible[i]\n        \n        # Current period cost per MW\n        current_cost_per_MW = (startup_cost + unit['a_i'] + unit['b_i']*min_output + unit['c_i']*min_output**2) / min_output\n        \n        # Next period fixed cost per MW\n        fixed_cost_per_MW = (unit['a_i'] + startup_cost) / unit['p_max_i']\n        \n        # Combined priority\n        priority = current_cost_per_MW * (1 - w_next) + fixed_cost_per_MW * w_next\n        priorities.append((i, priority))\n    \n    # Sort by ascending priority\n    priorities.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    for i, _ in priorities:\n        if deficiency_current <= 1e-9 and deficiency_next <= 1e-9:\n            break\n            \n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p_current = p_max_feasible[i]\n        max_p_next = unit['p_max_i']\n        \n        # Skip if no positive deficiency contribution\n        if deficiency_current > 0 or deficiency_next > 0:\n            committed.add(i)\n            u_out[i] = 1\n            p_out[i] = min_p\n            total_min_current += min_p\n            total_max_current += max_p_current\n            total_max_next += max_p_next\n            \n            deficiency_current = max(0, current_load - total_max_current)\n            deficiency_next = max(0, next_load - total_max_next)\n    \n    # Decommitment\n    decommit_candidates = []\n    for i in committed:\n        if i in must_run:\n            continue\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p_current = p_max_feasible[i]\n        max_p_next = unit['p_max_i']\n        \n        # Marginal cost at minimum output\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        decommit_candidates.append((i, marginal_cost, min_p, max_p_current, max_p_next))\n    \n    # Sort by descending marginal cost\n    decommit_candidates.sort(key=lambda x: -x[1])\n    \n    for i, _, min_p, max_p_current, max_p_next in decommit_candidates:\n        if i not in committed:\n            continue\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p_current\n        new_max_next = total_max_next - max_p_next\n        \n        if (new_min <= current_load and \n            new_max_current >= current_load and \n            new_max_next >= next_load):\n            committed.remove(i)\n            u_out[i] = 0\n            p_out[i] = 0.0\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Economic dispatch\n    residual = current_load - total_min_current\n    if residual < 0:\n        residual = 0.0\n    \n    # Allocate minimum outputs\n    for i in committed:\n        p_out[i] = p_min_feasible[i]\n    \n    # Allocate residual load\n    if residual > 0:\n        active_units = []\n        for i in committed:\n            if p_out[i] < p_max_feasible[i]:\n                current_output = p_out[i]\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_output\n                max_increase = p_max_feasible[i] - current_output\n                active_units.append((i, marginal_cost, max_increase))\n        \n        # Sort by ascending marginal cost\n        active_units.sort(key=lambda x: x[1])\n        \n        for i, mc, max_inc in active_units:\n            allocate = min(residual, max_inc)\n            p_out[i] += allocate\n            residual -= allocate\n            if residual <= 1e-9:\n                break\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00623,
          "other_inf": null
     },
     {
          "algorithm": "A \"Predictive Load and Flexibility Driven Heuristic\" that emphasizes the next-period load requirements and unit flexibility to guide current commitments. The algorithm first categorizes units by status and dynamic flexibility, then uses next-period demand to influence commitment decisions through a multi-stage process. Key steps:\n1. Precompute feasible power ranges considering ramp, min-up/down constraints\n2. Classify units into must-run, must-off, and flexibility-ranked categories\n3. Compute \"Dynamic Flexibility Scores\" combining next-period utility and cost-effectiveness\n4. Stage 1: Commit units needed for next-period capacity requirements\n5. Stage 2: Commit units for current-period load deficiency\n6. Adaptive decommitment considering two-period requirements\n7. Greedy economic dispatch prioritizing units with lowest marginal cost\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Calculate initial capacity\n    committed = set(must_run)\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Compute Dynamic Flexibility Scores for flexible units\n    dynamic_scores = {}\n    max_ramp = max(unit['p_max_i'] - unit['p_min_i'] for unit in units_info)\n    max_p_min = max(p_min_feasible)\n    \n    for i in flexible:\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        efficiency = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        \n        # Flexibility metric based on next-period ramp capability\n        ramp_range = min(unit['p_up_i'], unit['p_down_i']) + max_ramp\n        normalized_ramp = ramp_range / (2 * max_ramp)\n        \n        # Production metric\n        production_metric = (marginal_cost / max_p_min) * 0.4 + (efficiency / max_p_min) * 0.3\n        \n        # Next-period utility metric\n        next_utility = min(1.0, next_load / (sum(unit['p_max_i'] for unit in units_info))) * 0.3\n        \n        dynamic_scores[i] = normalized_ramp + production_metric - next_utility\n    \n    # Stage 1: Commit for next-period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            next_capacity = unit['p_max_i']\n            # Priority: lower score = better\n            priority = dynamic_scores[i]\n            candidates.append((i, priority, next_capacity))\n        \n        # Sort by ascending score (most flexible first)\n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_max_next += cap\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n    \n    # Stage 2: Commit for current load deficiency\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            current_capacity = p_max_feasible[i]\n            min_cost = unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2\n            cost_metric = (min_cost + unit['s_i'] * (1 - unit['u_i_0'])) / current_capacity\n            # Priority: lower score = better\n            priority = cost_metric * (1 - dynamic_scores[i])\n            candidates.append((i, priority, current_capacity))\n        \n        # Sort by ascending score\n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n    \n    # Adaptive decommitment (if overcommitted for both periods)\n    if total_min_current > current_load and total_max_next > next_load:\n        decommit_candidates = []\n        for i in committed:\n            if i in must_run:\n                continue\n            unit = units_info[i]\n            min_p = p_min_feasible[i]\n            max_p_next = unit['p_max_i']\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n            \n            # Consider both periods in savings calculation\n            if unit['u_i_0'] == 0:\n                cost_per_mw += unit['s_i'] / min_p\n            \n            decommit_candidates.append((i, cost_per_mw, min_p, max_p_next))\n        \n        # Sort by descending cost (most expensive first)\n        decommit_candidates.sort(key=lambda x: -x[1])\n        for i, _, min_p, max_p_next in decommit_candidates:\n            new_min = total_min_current - min_p\n            new_max_next = total_max_next - max_p_next\n            \n            if new_min >= current_load and new_max_next >= next_load:\n                committed.remove(i)\n                total_min_current = new_min\n                total_max_next = new_max_next\n            if total_min_current <= current_load:\n                break\n    \n    # Greedy economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        # Prioritize units with lowest marginal cost first\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00633,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, \"Average-Cost Heuristic\", prioritizes units based on their average production cost at minimum feasible output. The main steps are:\n1. Calculate feasible power limits for each unit considering current state and ramp constraints\n2. Classify units into must-on, must-off, and flexible categories based on minimum runtime/downtime constraints\n3. Commit must-on units at their minimum feasible output\n4. Compute residual load after must-on commitments\n5. Prioritize flexible units by ascending average cost at minimum output: (fixed_cost + b_i*p_min + c_i*p_min\u00b2)/p_min\n6. Commit lowest-cost flexible units until capacity meets demand\n7. Decommit most expensive committed flexible units if system constraints allow\n8. Perform economic dispatch via lambda iteration to optimize generation levels\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 1: Calculate feasible power limits\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 2: Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 3: Commit must-on units\n    for i in must_on:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    \n    # Calculate base capacity from must-on units\n    total_min = sum(p_min_feasible[i] for i in must_on)\n    total_max = sum(p_max_feasible[i] for i in must_on)\n    \n    # Step 4: Calculate remaining power requirement\n    residual_load = current_load - total_min\n    \n    # Step 5: Select and commit flexible units\n    flexible_candidates = []\n    for i in flexible:\n        min_p = p_min_feasible[i]\n        max_p = p_max_feasible[i]\n        \n        if min_p > max_p:\n            continue\n            \n        # Calculate average cost at minimum feasible output\n        startup_cost = unit['s_i'] * (1 - units_info[i]['u_i_0'])\n        variable_cost = units_info[i]['b_i'] * min_p + units_info[i]['c_i'] * min_p**2\n        avg_cost = (startup_cost + variable_cost) / min_p if min_p > 0 else float('inf')\n        flexible_candidates.append((i, avg_cost, min_p, max_p))\n    \n    # Sort by ascending average cost\n    flexible_candidates.sort(key=lambda x: x[1])\n    \n    # Commit until capacity covers demand\n    committed_flexible = []\n    for (i, _, min_p, max_p) in flexible_candidates:\n        if total_max >= current_load:\n            break\n        u_out[i] = 1\n        p_out[i] = min_p\n        committed_flexible.append(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Step 6: Conservative decommitment\n    if committed_flexible:\n        # Calculate average cost for decommitment candidates\n        decommit_candidates = []\n        for i in committed_flexible:\n            min_p = p_min_feasible[i]\n            startup_cost = unit['s_i'] * (1 - units_info[i]['u_i_0'])\n            variable_cost = units_info[i]['b_i'] * min_p + units_info[i]['c_i'] * min_p**2\n            avg_cost = (startup_cost + variable_cost) / min_p if min_p > 0 else float('inf')\n            decommit_candidates.append((i, avg_cost, min_p, p_max_feasible[i]))\n        \n        # Sort by descending average cost (most expensive first)\n        decommit_candidates.sort(key=lambda x: -x[1])\n        \n        # Remove expensive units if system constraints allow\n        for (i, _, min_p, max_p) in decommit_candidates:\n            if (i in committed_flexible and \n                (total_min - min_p) <= current_load and \n                (total_max - max_p) >= current_load):\n                u_out[i] = 0\n                p_out[i] = 0\n                committed_flexible.remove(i)\n                total_min -= min_p\n                total_max -= max_p\n    \n    # Step 7: Final economic dispatch\n    target = min(max(total_min, current_load), total_max)\n    \n    committed_indices = must_on + committed_flexible\n    if not committed_indices:\n        return np.array([u_out, p_out])\n    \n    b_coeffs = [units_info[i]['b_i'] for i in committed_indices]\n    c_coeffs = [units_info[i]['c_i'] for i in committed_indices]\n    min_limits = [p_min_feasible[i] for i in committed_indices]\n    max_limits = [p_max_feasible[i] for i in committed_indices]\n    \n    # Lambda iteration\n    lambda_low = min(b + 2*c*min_l for b, c, min_l in zip(b_coeffs, c_coeffs, min_limits))\n    lambda_high = max(b + 2*c*max_l for b, c, max_l in zip(b_coeffs, c_coeffs, max_limits))\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for idx, i in enumerate(committed_indices):\n            if c_coeffs[idx] > 0:\n                p_val = (lambda_mid - b_coeffs[idx]) / (2 * c_coeffs[idx])\n            else:\n                p_val = max_limits[idx] if lambda_mid >= b_coeffs[idx] else min_limits[idx]\n                \n            p_out[i] = max(min_limits[idx], min(max_limits[idx], p_val))\n            total_p += p_out[i]\n        \n        if abs(total_p - target) < 0.01:\n            break\n        if total_p < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set uncommitted units to off\n    for i in range(n_units):\n        if i not in committed_indices:\n            u_out[i] = 0\n            p_out[i] = 0\n    \n    return np.array([u_out, p_out])",
          "objective": 0.00634,
          "other_inf": null
     }
]