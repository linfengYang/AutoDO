{
     "algorithm": "The algorithm schedules units for the current period while considering both current and next period loads. It first computes feasible power ranges and classifies units into must-run, must-off, and flexible categories. Must-run units are committed at minimum power, while must-off units are turned off. Flexible units are committed in two stages: first for next period capacity, then for current period capacity, prioritizing units based on cost efficiency. A decommitment step removes non-essential units by ensuring feasibility for both current and next periods with updated constraints. Finally, economic dispatch assigns minimum power then distributes residual load based on marginal costs.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load, next_load = load\n    n_units = len(units_info)\n    \n    # Precompute feasible power ranges\n    p_min_feasible = [0] * n_units\n    p_max_feasible = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize outputs\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Set must-run and must-off units\n    for i in must_run:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    # Initial capacity from must-run units\n    committed = set(must_run)\n    total_min_current = sum(p_min_feasible[i] for i in must_run)\n    total_max_current = sum(p_max_feasible[i] for i in must_run)\n    total_max_next = sum(units_info[i]['p_max_i'] for i in must_run)\n    \n    # Stage 1: Ensure next period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            cost = unit['s_i'] * (1 - unit['u_i_0']) \n            cost += unit['a_i'] + unit['b_i'] * p_min_feasible[i] + unit['c_i'] * p_min_feasible[i]**2\n            priority = cost / unit['p_max_i']\n            candidates.append((i, priority, unit['p_max_i']))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_next >= next_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += p_max_feasible[i]\n            total_max_next += cap\n    \n    # Stage 2: Ensure current period capacity\n    if total_max_current < current_load:\n        candidates = []\n        for i in flexible:\n            if i in committed:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_feasible[i]\n            priority = marginal_cost / p_max_feasible[i]\n            candidates.append((i, priority, p_max_feasible[i]))\n        \n        candidates.sort(key=lambda x: x[1])\n        for i, _, cap in candidates:\n            if total_max_current >= current_load:\n                break\n            committed.add(i)\n            total_min_current += p_min_feasible[i]\n            total_max_current += cap\n            total_max_next += units_info[i]['p_max_i']\n    \n    # Decommit overcommitted units with feasibility check\n    decommit_candidates = []\n    for i in committed:\n        if i in must_run:\n            continue\n        unit = units_info[i]\n        min_p = p_min_feasible[i]\n        max_p_current = p_max_feasible[i]\n        max_p_next = unit['p_max_i']\n        cost_per_mw = (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n        if unit['u_i_0'] == 0:\n            cost_per_mw += unit['s_i'] / min_p\n        decommit_candidates.append((i, cost_per_mw, min_p, max_p_current, max_p_next))\n    \n    decommit_candidates.sort(key=lambda x: -x[1])\n    for i, _, min_p, max_p_current, max_p_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p_current\n        new_max_next = total_max_next - max_p_next\n        # Check feasibility for both periods after decommitment\n        if new_min <= current_load <= new_max_current and next_load <= new_max_next:\n            committed.remove(i)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Economic dispatch\n    residual = current_load\n    for i in committed:\n        u_out[i] = 1\n        p_out[i] = p_min_feasible[i]\n        residual -= p_min_feasible[i]\n    \n    if residual > 0:\n        active_units = [i for i in committed if p_out[i] < p_max_feasible[i]]\n        active_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i])\n        \n        for i in active_units:\n            if residual <= 0:\n                break\n            available = p_max_feasible[i] - p_out[i]\n            allocated = min(residual, available)\n            p_out[i] += allocated\n            residual -= allocated\n    \n    return np.array([u_out, p_out])",
     "objective": 0.00584,
     "other_inf": null
}