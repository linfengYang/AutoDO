{
     "algorithm": "The new algorithm modifies the existing heuristic by adjusting the efficiency metrics used for committing free offline units and decommitting free online units. Instead of a two-period cost efficiency ratio for committing units, it uses a one-period ratio (startup cost plus one period of production cost at minimum output per MW). For decommitting units, it uses the marginal cost at minimum output (coefficient b_i + 2*c_i*min_output) instead of average cost. This prioritizes units with lower incremental costs and better reflects cost changes per additional MW. The main steps remain: classify units, commit must-run/free online, assess capacity needs, commit free offline units with new efficiency metric, decommit expensive units with new marginal cost metric, and perform economic dispatch.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on) | set(free_online)\n    \n    # Compute current bounds and next period capacity\n    lb = [0] * len(units_info)\n    ub = [0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[idx] = unit['p_min_i']\n            ub[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n        total_max_next += unit['p_max_i']\n    \n    # Commit free_offline units using one-period efficiency\n    candidates = []\n    for idx in free_offline:\n        unit = units_info[idx]\n        min_output = unit['p_min_i']\n        one_period_cost = unit['s_i'] + (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2)\n        efficiency_ratio = one_period_cost / min_output\n        max_output = min(unit['p_max_i'], unit['p_start_i'])\n        candidates.append((idx, efficiency_ratio, min_output, max_output, unit['p_max_i']))\n    \n    candidates.sort(key=lambda x: x[1])\n    \n    for idx, _, min_p, max_p, max_next in candidates:\n        if total_max_current >= current_load and total_max_next >= next_load:\n            break\n        committed.add(idx)\n        lb[idx] = min_p\n        ub[idx] = max_p\n        total_min_current += min_p\n        total_max_current += max_p\n        total_max_next += max_next\n    \n    # Decommit using marginal cost at minimum output\n    decommit_candidates = []\n    for idx in free_online:\n        if idx not in must_on and idx in committed:\n            unit = units_info[idx]\n            min_output = lb[idx]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_output\n            decommit_candidates.append(\n                (idx, marginal_cost, lb[idx], ub[idx], unit['p_max_i'])\n            )\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    \n    for idx, _, min_p, max_p, max_next in decommit_candidates:\n        new_min = total_min_current - min_p\n        new_max_current = total_max_current - max_p\n        new_max_next = total_max_next - max_next\n        if (new_min <= current_load and \n            new_max_current >= current_load and \n            new_max_next >= next_load):\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max_current\n            total_max_next = new_max_next\n    \n    # Initialize outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            unit = units_info[idx]\n            available = ub[idx] - p_out[idx]\n            allocate = min(available, residual)\n            p_out[idx] += allocate\n            residual -= allocate\n            if residual <= 1e-6:\n                break\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
     "objective": 0.00601,
     "other_inf": null
}