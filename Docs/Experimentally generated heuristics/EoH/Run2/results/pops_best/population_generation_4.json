{
     "algorithm": "This algorithm performs unit commitment and economic dispatch using a ramp-constrained startup-costâ€“aware heuristic with next-period load consideration. Key steps: 1) Compute feasible min/max outputs per unit considering ramp limits and startup constraints; 2) Classify units into forced-on, forced-off, and flexible categories; 3) Commit forced-on units; 4) Greedily add flexible units ranked by effective cost/MW (amortizing startup costs if next-period load is high); 5) Prune expensive flexible units operating above minimum output; 6) Economically dispatch committed units by reducing output from highest-marginal-cost units first while respecting individual min/max limits.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    \n    # Precompute min/max outputs considering ramp constraints\n    min_i_dict = {}\n    max_i_dict = {}\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Unit was offline\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_i_dict[i] = min_i\n        max_i_dict[i] = max_i\n    \n    # Classify units based on physical constraints\n    forced_on = []\n    forced_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously offline\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize with forced-on units\n    candidate_set = forced_on[:]\n    total_min = sum(min_i_dict[i] for i in forced_on)\n    total_max = sum(max_i_dict[i] for i in forced_on)\n    \n    # Add flexible units greedily with recalculated metrics\n    flexible_remaining = flexible[:]\n    while flexible_remaining and total_max < current_load:\n        adjusted_data = []\n        for i in flexible_remaining:\n            unit = units_info[i]\n            # Adjust startup cost based on next period load\n            if unit['u_i_0'] == 0:  # Unit was offline\n                if next_load > total_max:  # Amortize startup if needed next period\n                    effective_startup = 0\n                else:\n                    effective_startup = unit['s_i']\n            else:\n                effective_startup = 0\n                \n            # Compute full cost at max output\n            full_cost = (unit['a_i'] + unit['b_i'] * max_i_dict[i] + \n                         unit['c_i'] * max_i_dict[i]**2 + effective_startup)\n            metric = full_cost / max_i_dict[i]\n            adjusted_data.append((i, metric, min_i_dict[i], max_i_dict[i]))\n        \n        # Select most cost-efficient unit\n        i, metric, min_i, max_i = min(adjusted_data, key=lambda x: x[1])\n        candidate_set.append(i)\n        flexible_remaining.remove(i)\n        total_min += min_i\n        total_max += max_i\n    \n    # Prune unnecessary units using operating cost only\n    prune_list = []\n    for i in candidate_set:\n        if i in forced_on:  # Don't prune forced-on units\n            continue\n        unit = units_info[i]\n        # Compute operating cost at max output (no startup)\n        op_cost = (unit['a_i'] + unit['b_i'] * max_i_dict[i] + \n                   unit['c_i'] * max_i_dict[i]**2)\n        metric = op_cost / max_i_dict[i]\n        prune_list.append((metric, i, min_i_dict[i], max_i_dict[i]))\n    \n    prune_list.sort(key=lambda x: x[0], reverse=True)  # Highest cost first\n    for metric_val, i, min_i, max_i in prune_list:\n        new_min = total_min - min_i\n        new_max = total_max - max_i\n        if new_min <= current_load <= new_max:\n            candidate_set.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Initialize commitment and dispatch at maximum capacity\n    u_arr = [1 if i in candidate_set else 0 for i in range(n_units)]\n    p_arr = [max_i_dict[i] if u_arr[i] else 0 for i in range(n_units)]\n    residual = total_max - current_load\n    \n    # Economic dispatch: reduce expensive units first\n    reduce_list = []\n    for i in candidate_set:\n        # Calculate marginal cost at current output (max_i)\n        mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n        reduction_room = p_arr[i] - min_i_dict[i]\n        reduce_list.append((mc, i, reduction_room))\n    \n    # Sort by marginal cost descending\n    reduce_list.sort(key=lambda x: x[0], reverse=True)\n    \n    for mc, i, room in reduce_list:\n        if residual <= 0:\n            break\n        reduction = min(residual, room)\n        p_arr[i] -= reduction\n        residual -= reduction\n    \n    return np.array([u_arr, p_arr])",
     "objective": 0.00476,
     "other_inf": null
}

