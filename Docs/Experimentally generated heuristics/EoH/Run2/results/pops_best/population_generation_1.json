{
     "algorithm": "This algorithm modifies the existing lookahead approach by introducing staged commitment prioritization and adaptive thresholds. The key steps are:\n1. Classify units into must-run, must-off, free online, and free offline based on current state and constraints.\n2. Commit must-run and free online units, calculating their feasible power ranges while considering ramp constraints.\n3. Implement two-stage commitment of free offline units:\n   - Stage 1: Commit units based on current-load deficiency, prioritizing startup+min-gen cost per MW.\n   - Stage 2: If next-period capacity is insufficient, commit additional units based on two-period cost efficiency.\n4. Perform adaptive decommitment of expensive free online units only when both periods' requirements are securely met.\n5. Conduct economic dispatch by allocating minimum feasible outputs then distributing residual load to lowest marginal cost units.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_online.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_offline.append(idx)\n    \n    # Initialize committed sets\n    committed = set(must_on + free_online)\n    \n    # Initialize lb, ub arrays and capacity totals\n    lb = [0.0] * len(units_info)\n    ub = [0.0] * len(units_info)\n    total_min_current = 0.0\n    total_max_current = 0.0\n    total_max_next = 0.0\n    \n    # Set initial lb/ub for committed units considering ramp constraints\n    for idx in committed:\n        unit = units_info[idx]\n        lb[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_current += lb[idx]\n        total_max_current += ub[idx]\n        total_max_next += unit['p_max_i']\n    \n    # Stage 1: Commit free offline units for current load deficiency\n    if total_max_current < current_load:\n        candidates = []\n        for idx in free_offline:\n            if idx in committed:\n                continue\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            cost_current = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            efficiency = (unit['s_i'] + cost_current) / min_p\n            candidates.append((idx, efficiency, min_p, min(unit['p_max_i'], unit['p_start_i'])))\n        \n        candidates.sort(key=lambda x: x[1])\n        for candidate in candidates:\n            if total_max_current >= current_load:\n                break\n            idx, _, min_p, max_p = candidate\n            unit = units_info[idx]\n            committed.add(idx)\n            lb[idx] = min_p\n            ub[idx] = max_p\n            total_min_current += min_p\n            total_max_current += max_p\n            total_max_next += unit['p_max_i']\n    \n    # Stage 2: Commit free offline units for next-period capacity\n    if total_max_next < next_load:\n        candidates = []\n        for idx in free_offline:\n            if idx in committed:\n                continue\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            cost_two_periods = 2 * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)\n            efficiency = (unit['s_i'] + cost_two_periods) / (2 * min_p)\n            candidates.append((idx, efficiency, min_p, min(unit['p_max_i'], unit['p_start_i']), unit['p_max_i']))\n        \n        candidates.sort(key=lambda x: x[1])\n        for candidate in candidates:\n            if total_max_next >= next_load:\n                break\n            idx, _, min_p, max_p, max_next = candidate\n            committed.add(idx)\n            lb[idx] = min_p\n            ub[idx] = max_p\n            total_min_current += min_p\n            total_max_current += max_p\n            total_max_next += max_next\n    \n    # Decommit expensive free online units if capacity margins allow\n    decommit_candidates = []\n    for idx in free_online:\n        if idx in committed and idx not in must_on:\n            unit = units_info[idx]\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * lb[idx] + unit['c_i'] * lb[idx]**2) / lb[idx]\n            decommit_candidates.append((idx, cost_per_mw, lb[idx], ub[idx], unit['p_max_i']))\n    \n    decommit_candidates.sort(key=lambda x: x[1], reverse=True)\n    for candidate in decommit_candidates:\n        idx, _, min_p, max_p, max_next = candidate\n        new_min = total_min_current - min_p\n        new_max_curr = total_max_current - max_p\n        new_max_next = total_max_next - max_next\n        \n        if (new_min <= current_load and \n            new_max_curr >= current_load and \n            new_max_next >= next_load):\n            committed.remove(idx)\n            total_min_current = new_min\n            total_max_current = new_max_curr\n            total_max_next = new_max_next\n    \n    # Initialize outputs\n    p_out = [0.0] * len(units_info)\n    u_out = [0] * len(units_info)\n    residual = current_load\n    \n    # Set outputs for must-off units\n    for idx in must_off:\n        u_out[idx] = 0\n        p_out[idx] = 0\n    \n    # Set committed units to minimum output\n    for idx in committed:\n        u_out[idx] = 1\n        p_out[idx] = lb[idx]\n        residual -= lb[idx]\n    \n    # Dispatch residual load\n    if residual > 0:\n        active_units = [idx for idx in committed if p_out[idx] < ub[idx]]\n        active_units.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_out[idx])\n        \n        for idx in active_units:\n            capacity = ub[idx] - p_out[idx]\n            allocation = min(capacity, residual)\n            p_out[idx] += allocation\n            residual -= allocation\n            if residual <= 1e-8:\n                break\n    \n    return np.array([u_out, p_out])",
     "objective": 0.00694,
     "other_inf": null
}