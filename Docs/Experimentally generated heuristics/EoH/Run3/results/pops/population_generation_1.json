[
     {
          "algorithm": "The new algorithm uses a priority-based commitment with ramp-adjusted costs and a look-ahead dispatch. Key steps: 1) Identify must-run/must-off units; 2) For free units, calculate ramp-flexible priorities combining operating costs and startup costs scaled by ramp capabilities; 3) Build committed set by adding units in priority order until meeting load; 4) Remove overcommitted units using reverse-priority order; 5) Perform unconstrained dispatch ignoring ramp limits; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residual load incrementally while respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Identify must-run, must-off, and free units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Start with must-run units committed\n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate initial bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Calculate ramp-flexible priorities for free units\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Currently online\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - 0.1 * ramp_ratio)\n        else:  # Currently offline\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - 0.1 * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    # Build commitment set\n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units\n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    # Skip dispatch if no committed units\n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    # Unconstrained economic dispatch ignoring ramp limits\n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Project to ramp-constrained bounds\n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Adjust residual load\n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    # Distribute residual load\n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00514,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm is a ramp-weighted priority heuristic that modifies the scoring function by increasing the ramp weight parameter from 0.1 to 0.15 and explicitly using minimum outputs for cost amortization in offline units. Key steps: 1) Identify must-run/must-off units based on current state; 2) For free units, compute priorities with ramp weight=0.15 and cost amortization period equal to min_up_time; 3) Commit units in ascending priority order until satisfying load; 4) Remove overcommitted units in descending priority order; 5) Dispatch via cost-based lambda iteration; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight = 0.15\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00516,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the unit commitment and dispatch process by removing complex ramp scaling in priority calculations and marginal cost averaging in residual distribution. Key steps:\n1. Classify units into must-run, must-off, and free categories based on current state and operational constraints\n2. Commit must-run units and calculate min/max capacity bounds\n3. Prioritize free units using simplified cost-based criteria without ramp ratio adjustments\n4. Commit free units in ascending cost order until generation capacity meets load\n5. Remove overcommitted units by reverse cost priority while ensuring system can still meet load\n6. Perform economic dispatch via marginal cost bisection\n7. Distribute residual load using marginal cost at dispatch point rather than range average\n8. Handle edge cases (no committed units)\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Initialize committed set with must-run units\n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Simplified priority calculation without ramp scaling\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Online units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:  # Offline units\n            # Amortize startup cost over minimum generation\n            base_cost = (unit['s_i'] + unit['a_i']) / unit['p_min_i']\n            incremental_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            priority = base_cost + incremental_cost\n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units with undercommitment safeguard\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        # Skip removal if it causes undercommitment\n        if total_max - UB[idx] < current_load:\n            continue\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        committed.remove(idx)\n        total_min = new_min\n        total_max = new_max\n        if total_min <= current_load:\n            break\n    \n    # Handle no-commitment edge case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Unconstrained economic dispatch\n    lam_low = min(unit['b_i'] + 2*unit['c_i']*unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] < 1e-6:  # Linear cost\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp outputs to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    residual = current_load - sum(p_proj)\n    \n    # Residual distribution using marginal cost at dispatch point\n    if residual > 0:  # Underproduction\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort()\n        \n        for cost, idx, cap in candidates:\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:  # Overproduction\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort(reverse=True)\n        \n        for cost, idx, cap in candidates:\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00595,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the priority calculation by removing the quadratic ramp scaling and the arbitrary startup ratio, using direct marginal costs and startup-adjusted costs instead. For residual distribution, it replaces the averaged marginal cost with the current marginal cost for prioritization, enhancing generalization. The unit removal condition is streamlined to require load feasibility within the remaining unit bounds. Steps include unit classification, commitment of must-run units, priority-based commitment of free units, removal of overcommitted units via reverse priority, economic dispatch via lambda bisection, clamping to ramp limits, and residual distribution using current marginal costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Initialize committed set with must-run units\n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Simplified priority calculation\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Online units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:  # Offline units\n            base_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            startup_adjusted = (unit['s_i'] + unit['a_i']) / unit['p_min_i']\n            priority = startup_adjusted + base_cost\n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units in reverse priority order\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_min <= current_load and current_load <= new_max:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    # Handle no-commitment edge case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Unconstrained economic dispatch\n    lam_low = min(unit['b_i'] + 2*unit['c_i']*unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] < 1e-6:  # Linear cost\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp outputs to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    residual = current_load - sum(p_proj)\n    \n    # Residual distribution using current marginal costs\n    if residual > 0:  # Underproduction\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort()\n        \n        for cost, idx, cap in candidates:\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:  # Overproduction\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort(reverse=True)\n        \n        for cost, idx, cap in candidates:\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00611,
          "other_inf": null
     },
     {
          "algorithm": "A priority-based heuristic for rolling unit commitment that modifies the priority calculation to emphasize ramp flexibility using a quadratic scaling factor. Key steps: 1) Classify units into must-run, must-off, or free categories. 2) Calculate priorities using a modified formula that squares ramp capability ratios and scales startup costs differently. 3) Commit units in ascending priority order until meeting load. 4) Remove overcommitted units via reverse priority order. 5) Perform unconstrained dispatch via lambda iteration. 6) Clamp outputs to feasible ramp limits. 7) Distribute residual load using averaged marginal costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Initialize committed set with must-run units\n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Modified priority calculation with quadratic ramp scaling\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Online units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            base_cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            priority = base_cost * (1.0 - 0.15 * (ramp_ratio ** 2))\n        else:  # Offline units\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            avg_min_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            startup_ratio = max(0.1, unit['t_on_min_i'] / 10.0)\n            base_cost = (unit['s_i'] * startup_ratio + unit['a_i']) / unit['p_min_i'] + avg_min_cost\n            priority = base_cost * (1.0 - 0.2 * (ramp_ratio ** 2))\n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units in reverse priority order\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_min <= current_load <= new_max or new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    # Handle no-commitment edge case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Unconstrained economic dispatch\n    lam_low = min(unit['b_i'] + 2*unit['c_i']*unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] < 1e-6:  # Linear cost\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp outputs to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    residual = current_load - sum(p_proj)\n    \n    # Residual distribution using averaged marginal costs\n    if residual > 0:  # Underproduction\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap <= 0:\n                continue\n            base_cost = units_info[idx]['b_i']\n            c_coeff = units_info[idx]['c_i']\n            # Average marginal cost over adjustment range\n            cost_avg = (base_cost + c_coeff * (p_proj[idx] + UB[idx]))\n            candidates.append((cost_avg, idx, cap))\n        candidates.sort()\n        \n        for cost, idx, cap in candidates:\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:  # Overproduction\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap <= 0:\n                continue\n            base_cost = units_info[idx]['b_i']\n            c_coeff = units_info[idx]['c_i']\n            # Average marginal cost over adjustment range\n            cost_avg = (base_cost + c_coeff * (LB[idx] + p_proj[idx]))\n            candidates.append((cost_avg, idx, cap))\n        candidates.sort(reverse=True)\n        \n        for cost, idx, cap in candidates:\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.007,
          "other_inf": null
     },
     {
          "algorithm": "The Dual-Target Economic Commitment and Dispatch (DTECD) algorithm first identifies units that must stay on or off due to physical constraints. It then solves an unconstrained economic dispatch problem to determine ideal generation targets. These targets are clamped to feasible output ranges dictated by ramp constraints. Finally, it adjusts outputs through incremental cost-based distribution to match the load exactly. The key distinction is using unconstrained optimal targets as anchors before applying ramp constraints and adjustments.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_vector = [0] * n_units\n    p_vector = [0.0] * n_units\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Compute ramp-constrained output ranges\n    ramp_min = [0] * n_units\n    ramp_max = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            ramp_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ramp_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ramp_min[i] = unit['p_min_i']\n            ramp_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize committed set with must-run units\n    committed = set(must_run)\n    total_min = sum(ramp_min[i] for i in must_run)\n    total_max = sum(ramp_max[i] for i in must_run)\n    \n    # Turn on additional units if needed\n    free_off = [i for i in range(n_units) if i not in must_run and i not in must_off and units_info[i]['u_i_0'] == 0]\n    free_off_sorted = []\n    for i in free_off:\n        unit = units_info[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * ramp_min[i] + unit['c_i'] * (ramp_min[i]**2) + unit['s_i']) / ramp_min[i]\n        free_off_sorted.append((avg_cost, i))\n    free_off_sorted.sort(key=lambda x: x[0])\n    \n    for _, i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += ramp_min[i]\n        total_max += ramp_max[i]\n    \n    # Turn off non-essential units if minimum output is too high\n    non_must_run = [i for i in committed if i not in must_run]\n    non_must_run_sorted = sorted(non_must_run, key=lambda i: ramp_min[i], reverse=True)\n    for i in non_must_run_sorted:\n        if total_min <= current_load:\n            break\n        new_min = total_min - ramp_min[i]\n        new_max = total_max - ramp_max[i]\n        if new_max >= current_load:\n            committed.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Skip dispatch if no committed units\n    if not committed:\n        return np.array([u_vector, p_vector])\n    \n    # Solve unconstrained economic dispatch\n    abs_min = [unit['p_min_i'] for unit in units_info]\n    abs_max = [unit['p_max_i'] for unit in units_info]\n    lambda_low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * abs_min[i] for i in committed)\n    lambda_high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * abs_max[i] for i in committed)\n    \n    # Adjust lambda bounds for safety\n    lambda_low = max(0, lambda_low - 10)\n    lambda_high += 10\n    \n    # Lambda iteration for ideal outputs\n    ideal_p = [0] * n_units\n    tol = 0.1\n    for _ in range(20):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] > 0:\n                p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                if lambda_mid <= unit['b_i']:\n                    p_val = abs_min[i]\n                else:\n                    p_val = abs_max[i]\n            p_val = max(abs_min[i], min(abs_max[i], p_val))\n            ideal_p[i] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Apply ramp constraints\n    for i in committed:\n        p_vector[i] = max(ramp_min[i], min(ramp_max[i], ideal_p[i]))\n    \n    # Adjust to meet exact load\n    total_p = sum(p_vector)\n    R = current_load - total_p\n    \n    if R > 0:  # Under-generation\n        headroom = []\n        inc_costs = []\n        idx_list = []\n        for i in committed:\n            h = ramp_max[i] - p_vector[i]\n            if h > 0:\n                headroom.append(h)\n                inc_costs.append(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_vector[i])\n                idx_list.append(i)\n        \n        order = np.argsort(inc_costs)\n        for idx in order:\n            if R <= 0:\n                break\n            i = idx_list[idx]\n            add = min(R, headroom[idx])\n            p_vector[i] += add\n            R -= add\n    \n    elif R < 0:  # Over-generation\n        headroom = []\n        inc_costs = []\n        idx_list = []\n        for i in committed:\n            h = p_vector[i] - ramp_min[i]\n            if h > 0:\n                headroom.append(h)\n                inc_costs.append(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_vector[i])\n                idx_list.append(i)\n        \n        order = np.argsort(inc_costs)[::-1]\n        for idx in order:\n            if R >= 0:\n                break\n            i = idx_list[idx]\n            reduce = min(-R, headroom[idx])\n            p_vector[i] -= reduce\n            R += reduce\n    \n    # Set commitment status\n    for i in committed:\n        u_vector[i] = 1\n    \n    return np.array([u_vector, p_vector])",
          "objective": 0.00707,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic employs a three-stage adaptive priority approach for the rolling unit commitment problem:\n\n1. **Feasibility Enforcement & Initial Commitments**\n   - Identify must-run units based on minimum up-time violations (t_i_0 < t_on_min_i) or shutdown capacity constraints (p_i_0 > p_shut_i)\n   - Identify must-off units violating minimum down-time (abs(t_i_0) < t_off_min_i)\n   - Form initial commitment set using must-run units\n\n2. **Adaptive Priority Commitment**\n   - Calculate a novel dynamic priority metric for eligible free units (neither must-run nor must-off):\n     - Currently ONLINE units: Operating cost per MW at minimum feasible output (b_i + 2*c_i*min_p)\n     - Currently OFFLINE units: Amortized cost per MW (startup cost + operating cost over minimum up-time)\n   - Add free units in priority order until projected maximum output meets load\n   - Remove overcommitted units (lowest priority first) while maintaining feasible load coverage\n\n3. **Constraint-Adjusted Economic Dispatch**\n   - Calculate feasible operating bounds for committed units:\n     - ONLINE units: [max(p_min_i, p_i_0-p_down_i), min(p_max_i, p_i_0+p_up_i)]\n     - NEWLY STARTED units: [p_min_i, min(p_max_i, p_start_i)]\n   - Distribute load in ascending order of marginal cost (b_i + 2*c_i*output) while respecting:\n     - Minimum output constraints\n     - Ramp-rate limitations\n     - Startup/shutdown capacities\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    \n    # Identify must-run and must-off units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n        elif abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(idx)\n    \n    free_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    committed = must_run[:]  # Start with must-run units\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    LB = np.zeros(n_units)\n    UB = np.zeros(n_units)\n    \n    # Calculate initial capacity from must-run units\n    total_min = 0.0\n    total_max = 0.0\n    for idx in must_run:\n        u_i0 = units_info[idx]['u_i_0']\n        prev_p = units_info[idx]['p_i_0']\n        if u_i0 == 1:\n            LB[idx] = max(units_info[idx]['p_min_i'], prev_p - units_info[idx]['p_down_i'])\n            UB[idx] = min(units_info[idx]['p_max_i'], prev_p + units_info[idx]['p_up_i'])\n        else:\n            LB[idx] = units_info[idx]['p_min_i']\n            UB[idx] = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Calculate dynamic priorities for free units\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Already online\n            prev_p = unit['p_i_0']\n            lb_val = max(min_p, prev_p - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * lb_val\n        else:  # Currently offline\n            T_min = unit['t_on_min_i']\n            amortized_cost = (unit['s_i'] + T_min * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2))\n            priority = amortized_cost / (min_p * T_min) if min_p > 0 else float('inf')\n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    free_committed = []\n    \n    # Commit free units by priority\n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Online unit\n            new_LB = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            new_UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Offline unit\n            new_LB = unit['p_min_i']\n            new_UB = min(unit['p_max_i'], unit['p_start_i'])\n        \n        total_min += new_LB\n        total_max += new_UB\n        committed.append(idx)\n        free_committed.append(idx)\n        LB[idx] = new_LB\n        UB[idx] = new_UB\n    \n    # Remove overcommitted units (lowest priority first)\n    free_committed.sort(key=lambda i: priorities[[p[1] for p in priorities].index(i)][0], reverse=True)\n    i = 0\n    while i < len(free_committed) and total_min > current_load:\n        idx = free_committed[i]\n        if total_max - UB[idx] >= current_load:  # Maintain feasibility\n            total_min -= LB[idx]\n            total_max -= UB[idx]\n            committed.remove(idx)\n            free_committed.pop(i)\n        else:\n            i += 1\n    \n    # Initialize outputs at lower bounds\n    for idx in committed:\n        p[idx] = LB[idx]\n        u[idx] = 1\n    \n    # Economic dispatch for remaining load\n    deficit = current_load - np.sum(p)\n    if deficit > 0:\n        inc_costs = []\n        headrooms = []\n        for idx in committed:\n            headroom = UB[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * LB[idx]\n                inc_costs.append(inc_cost)\n                headrooms.append((idx, headroom))\n        \n        headrooms.sort(key=lambda x: inc_costs[committed.index(x[0])])\n        \n        for idx, headroom in headrooms:\n            if deficit <= 0:\n                break\n            allocation = min(deficit, headroom)\n            p[idx] += allocation\n            deficit -= allocation\n    \n    schedules = np.array([u, p])\n    return schedules",
          "objective": 0.00753,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic, Greedy Priority-Based Dispatch with Rolling Constraints (GPBDRC), works in three main steps:\n\n1. **Constraint Enforcement**: Identify units that must remain on or off due to minimum up/down time and shutdown ramp constraints. Must-run units were previously online and either haven't met minimum up-time or their previous output exceeded the shutdown ramp limit. Must-off units were previously offline and haven't met minimum down-time.\n\n2. **Flexible Unit Commitment**: \n   - For flexible units not forced on/off, initially keep their previous state (on/off).\n   - Compute the total min/max output of must-run and flexible units that are left on.\n   - If this total minimum output exceeds the current load, turn off all flexible units and dispatch only must-run units to minimize overproduction.\n   - If the total maximum output is below the load, greedily turn on the most cost-effective offline flexible units (by average cost at minimum output including startup cost) until the load can be met or no more units are available.\n\n3. **Economic Dispatch**: \n   - For each committed unit, compute feasible output bounds considering ramp constraints and startup/shutdown limits.\n   - If the total feasible range doesn't cover the load, set outputs to the bound nearest the load.\n   - Otherwise, perform greedy incremental dispatch: start at the minimum feasible output for all units, then iteratively increase the output of the unit with the lowest marginal cost (derivative of quadratic cost) until the load is met.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if -t0 < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Identify flexible units\n    flex_on = []\n    flex_off = []\n    for i in range(n_units):\n        if i in must_run or i in must_off:\n            continue\n        if units_info[i]['u_i_0'] == 1:\n            flex_on.append(i)\n        else:\n            flex_off.append(i)\n    \n    # Initialize commitment and compute current output range\n    committed_set = set(must_run)\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Helper function to compute unit bounds\n    def compute_bounds(i, is_must_run_or_flex_on):\n        unit = units_info[i]\n        if is_must_run_or_flex_on:  # Was online in previous period\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Turned on in current period\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        return low, high\n    \n    # Initial bounds for must_run and flex_on\n    for i in must_run:\n        low, high = compute_bounds(i, True)\n        total_min += low\n        total_max += high\n    for i in flex_on:\n        low, high = compute_bounds(i, True)\n        total_min += low\n        total_max += high\n    \n    # Adjust flexible commitment if overcommitted\n    if total_min > current_load:\n        # Only use must_run and turn off flex_on\n        committed_set = set(must_run)\n        total_min, total_max = 0.0, 0.0\n        for i in must_run:\n            low, high = compute_bounds(i, True)\n            total_min += low\n            total_max += high\n    elif total_max < current_load:\n        # Sort flex_off by average cost at p_min_i\n        candidates = []\n        for i in flex_off:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2) + unit['s_i']\n            avg_cost = cost / unit['p_min_i']\n            candidates.append((avg_cost, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        # Turn on candidates until load can be met\n        for _, i in candidates:\n            if total_max >= current_load:\n                break\n            committed_set.add(i)\n            low, high = compute_bounds(i, False)\n            total_min += low\n            total_max += high\n    \n    # Set u_i for all units\n    u_vector = [1 if i in committed_set else 0 for i in range(n_units)]\n    \n    # Dispatch: assign output p_i for committed units\n    p_vector = [0.0] * n_units\n    low_bounds = []\n    high_bounds = []\n    b_list = []\n    c_list = []\n    indices = []  # Committed indices\n    \n    for i in committed_set:\n        if units_info[i]['u_i_0'] == 1 or i in flex_on or i in must_run:\n            low, high = compute_bounds(i, True)\n        else:\n            low, high = compute_bounds(i, False)\n        low_bounds.append(low)\n        high_bounds.append(high)\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n        indices.append(i)\n    \n    total_low = sum(low_bounds)\n    total_high = sum(high_bounds)\n    \n    if len(indices) > 0:\n        if total_high < current_load:\n            # Set all to max\n            for idx, i in enumerate(indices):\n                p_vector[i] = high_bounds[idx]\n        elif total_low > current_load:\n            # Set all to min\n            for idx, i in enumerate(indices):\n                p_vector[i] = low_bounds[idx]\n        else:\n            # Greedy incremental dispatch\n            current_p = low_bounds.copy()\n            R = current_load - total_low\n            available = [high_bounds[j] - current_p[j] for j in range(len(indices))]\n            indexes = list(range(len(indices)))\n            \n            while R > 0 and indexes:\n                # Find unit with min marginal cost\n                min_marg = float('inf')\n                chosen = -1\n                for j in indexes:\n                    if available[j] > 0:\n                        marg = b_list[j] + 2 * c_list[j] * current_p[j]\n                        if marg < min_marg:\n                            min_marg = marg\n                            chosen = j\n                if chosen == -1:\n                    break\n                \n                # Increase chosen unit\n                delta = min(available[chosen], R)\n                current_p[chosen] += delta\n                available[chosen] -= delta\n                R -= delta\n                if available[chosen] <= 0:\n                    indexes.remove(chosen)\n            \n            for idx, i in enumerate(indices):\n                p_vector[i] = current_p[idx]\n    \n    schedules = np.array([u_vector, p_vector])\n    return schedules",
          "objective": 0.00807,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic first identifies must-run and must-off units based on current state, minimum up/down times, and shutdown capacity constraints. Flexible units (neither must-run nor must-off) are prioritized by average cost per MW at minimum output. Additional units are committed from the flexible list if needed to meet load capacity requirements. For dispatch, the algorithm calculates feasible output ranges considering ramp limits and startup/shutdown constraints. If total minimum output exceeds load, outputs are clamped to minimums. If load exceeds total maximum, outputs are clamped to maximums. Otherwise, units are dispatched to meet the exact load via merit order based on incremental cost at their feasible minimum output, ensuring ramp and capacity constraints are satisfied.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    flexible = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                flexible.append(idx)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                continue\n            else:\n                flexible.append(idx)\n    \n    committed = must_run.copy()\n    \n    min_capacity = 0.0\n    max_capacity = 0.0\n    \n    for idx in must_run:\n        if units_info[idx]['u_i_0'] == 1:\n            LB = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            UB = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n        else:\n            LB = units_info[idx]['p_min_i']\n            UB = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n        min_capacity += LB\n        max_capacity += UB\n    \n    if max_capacity < current_load:\n        priority = []\n        for idx in flexible:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 0:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            else:\n                total_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            avg_cost = total_cost / unit['p_min_i']\n            priority.append((avg_cost, idx))\n        priority.sort(key=lambda x: x[0])\n        \n        for _, idx in priority:\n            if max_capacity >= current_load:\n                break\n            unit = units_info[idx]\n            if unit['u_i_0'] == 0:\n                additional_UB = min(unit['p_max_i'], unit['p_start_i'])\n                additional_LB = unit['p_min_i']\n            else:\n                additional_UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                additional_LB = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_capacity += additional_UB\n            min_capacity += additional_LB\n            committed.append(idx)\n    \n    target = current_load\n    if min_capacity > current_load:\n        target = min_capacity\n    elif max_capacity < current_load:\n        target = max_capacity\n    \n    LBs = np.zeros(n_units)\n    UBs = np.zeros(n_units)\n    inc_costs = []\n    indices = []\n    \n    for idx in committed:\n        u[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            LB_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            UB_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            LB_i = unit['p_min_i']\n            UB_i = min(unit['p_max_i'], unit['p_start_i'])\n        LBs[idx] = LB_i\n        UBs[idx] = UB_i\n        inc_cost = 2 * unit['c_i'] * LB_i + unit['b_i']\n        inc_costs.append((inc_cost, idx))\n    \n    if inc_costs:\n        inc_costs.sort(key=lambda x: x[0])\n        sorted_indices = [idx for _, idx in inc_costs]\n    else:\n        sorted_indices = []\n    \n    p = LBs.copy()\n    remaining = target - np.sum(LBs)\n    \n    for idx in sorted_indices:\n        if remaining <= 0:\n            break\n        available = UBs[idx] - LBs[idx]\n        if available > 0:\n            allocate = min(remaining, available)\n            p[idx] += allocate\n            remaining -= allocate\n    \n    for idx in range(n_units):\n        if idx not in committed:\n            u[idx] = 0\n            p[idx] = 0.0\n    \n    schedules = np.array([u, p])\n    return schedules",
          "objective": 0.00821,
          "other_inf": null
     },
     {
          "algorithm": "The Priority-Based Ramp-Limited Dispatch (PBRLD) algorithm prioritizes unit commitment based on economic feasibility and ramp constraints. First, identify must-run units that cannot be shut down and must-off units that cannot be started due to physical constraints. Next, create a priority list of available units sorted by average cost at minimum output. Commit must-run units initially. If total minimum output exceeds current load, decommit non-essential units starting with highest cost. If load isn't met, commit additional units from the priority list until feasible capacity covers the load. Finally, perform cost-based power adjustment: start all committed units at their ramp-constrained minimum output, then increase outputs of units with lowest incremental costs until load is met.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_vector = [0] * n_units\n    p_vector = [0.0] * n_units\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Compute ramp-constrained output ranges\n    ramp_min = [0] * n_units\n    ramp_max = [0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            ramp_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ramp_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ramp_min[i] = unit['p_min_i']\n            ramp_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Priority list for available off units\n    off_units = []\n    for i in range(n_units):\n        if i not in must_run and i not in must_off and units_info[i]['u_i_0'] == 0:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * ramp_min[i] + units_info[i]['c_i'] * (ramp_min[i]**2) + units_info[i]['s_i']\n            avg_cost = cost_at_min / ramp_min[i]\n            off_units.append((avg_cost, i))\n    off_units.sort(key=lambda x: x[0])\n    \n    # Initial commitment and capacity tracking\n    committed = set(must_run)\n    total_min = sum(ramp_min[i] for i in must_run)\n    total_max = sum(ramp_max[i] for i in must_run)\n    \n    # Decommit non-essential units if minimum output exceeds load\n    removable_units = [i for i in committed if i not in must_run]\n    removable_units.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*ramp_min[i], reverse=True)\n    for i in removable_units:\n        new_min = total_min - ramp_min[i]\n        new_max = total_max - ramp_max[i]\n        if new_min >= current_load and new_max >= current_load:\n            committed.remove(i)\n            total_min = new_min\n            total_max = new_max\n        if total_min <= current_load:\n            break\n    \n    # Commit additional units from priority list if needed\n    if total_max < current_load:\n        for _, i in off_units:\n            if total_max >= current_load:\n                break\n            committed.add(i)\n            total_min += ramp_min[i]\n            total_max += ramp_max[i]\n    \n    # Initialize all committed units at minimum output\n    for i in committed:\n        p_vector[i] = ramp_min[i]\n    total_power = sum(p_vector)\n    \n    # Distribute remaining load using incremental cost sorting\n    remaining_load = current_load - total_power\n    if remaining_load > 0:\n        adjustable_units = []\n        for i in committed:\n            inc_cost = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_vector[i]\n            headroom = ramp_max[i] - p_vector[i]\n            if headroom > 0:\n                adjustable_units.append((inc_cost, headroom, i))\n        adjustable_units.sort(key=lambda x: x[0])\n        \n        for inc_cost, headroom, i in adjustable_units:\n            if remaining_load <= 0:\n                break\n            allocation = min(headroom, remaining_load)\n            p_vector[i] += allocation\n            remaining_load -= allocation\n    \n    # Set commitment status\n    for i in committed:\n        u_vector[i] = 1\n    \n    return np.array([u_vector, p_vector])",
          "objective": 0.00831,
          "other_inf": null
     }
]