[
     {
          "algorithm": "The new algorithm, \"Load-Adjusted Cost per MW with Ramp-Stress Factor\", modifies the priority calculation and forecast impact adjustments. Key changes include:\n\n1. For online units, base priority is computed as marginal cost per MW of ramp headroom (feasible_max - feasible_min), promoting cost-efficiency and flexibility.\n2. For offline units, base priority uses total cost per MW (amortized fixed cost plus marginal cost) over ramp headroom.\n3. Forecast factors are adjusted with new constants (0.6/0.4 for ramp-up, -0.5/-0.3 for ramp-down) to strengthen forecast responsiveness.\n4. Decommitment conditions are refined to balance cost savings against ramp capability preservation, using a 40% ramp-up threshold.\n\nSteps:\n1. Classify units into must-run, must-off, and free.\n2. Commit must-run units and compute feasible operating ranges.\n3. Calculate base priorities using new cost per MW formulas.\n4. Adjust priorities using forecasted load differences.\n5. Commit free units with look-ahead feasibility checks.\n6. Decommit high-cost units while preserving ramp flexibility.\n7. Perform ramp-constrained economic dispatch.\n8. Adjust residuals based on marginal costs and ramp headroom.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    load_diff = next_load - current_load\n    available_ramp_up = 0\n    available_ramp_down = 0\n    \n    for idx in range(n_units):\n        if units_info[idx]['u_i_0'] == 1:\n            available_ramp_up += units_info[idx]['p_up_i']\n            available_ramp_down += units_info[idx]['p_down_i']\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            ramp_headroom = feasible_max - feasible_min\n            marginal_cost_min = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            base_priority = marginal_cost_min / max(ramp_headroom, 1e-6)\n        else:\n            min_p = unit['p_min_i']\n            feasible_max = min(unit['p_max_i'], unit['p_start_i'])\n            ramp_headroom = feasible_max - min_p\n            T = max(1, unit['t_on_min_i'])\n            amortized_fixed_cost = (unit['s_i'] + T * unit['a_i']) / (T * min_p)\n            variable_cost_per_MW = unit['b_i'] + unit['c_i'] * min_p\n            total_cost_per_MW = amortized_fixed_cost + variable_cost_per_MW\n            base_priority = total_cost_per_MW / max(ramp_headroom, 1e-6)\n        \n        forecast_factor = 0\n        if abs(load_diff) > 1e-6:\n            norm_diff = load_diff / max(current_load, 1.0)\n            if load_diff > 0:\n                if unit['u_i_0'] == 1:\n                    forecast_factor = min(0.6, norm_diff * unit['p_up_i'] / max(available_ramp_up, 1e-6))\n                else:\n                    forecast_factor = min(0.4, norm_diff * unit['p_start_i'] / max(available_ramp_up + unit['p_start_i'], 1e-6))\n            else:\n                if unit['u_i_0'] == 1:\n                    forecast_factor = max(-0.5, norm_diff * unit['p_down_i'] / max(available_ramp_down, 1e-6))\n                else:\n                    forecast_factor = max(-0.3, norm_diff * 0.1)\n        priority = base_priority * (1 - forecast_factor)\n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    for _, idx in priorities:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        future_ok = True\n        if load_diff > 0:\n            future_ok = (current_load + total_min - lb_val + ub_val + (unit['p_up_i'] if unit['u_i_0']==0 else 0) >= next_load)\n        elif load_diff < 0:\n            future_ok = (current_load + total_min - lb_val <= next_load)\n        \n        if total_max < current_load and future_ok:\n            committed.add(idx)\n            LB[idx] = lb_val\n            UB[idx] = ub_val\n            total_min += lb_val\n            total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    if free_committed:\n        removal_candidates = [(p, i) for p, i in priorities if i in free_committed]\n        removal_candidates.sort(reverse=True)\n        \n        for _, idx in removal_candidates:\n            unit = units_info[idx]\n            new_min = total_min - LB[idx]\n            new_max = total_max - UB[idx]\n            \n            remove_ok = (new_min <= current_load and new_max >= current_load)\n            if load_diff > 0 and unit['p_up_i'] > 0.4 * available_ramp_up:\n                remove_ok = False\n            \n            if remove_ok:\n                committed.remove(idx)\n                total_min = new_min\n                total_max = new_max\n    \n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * LB[idx]\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * UB[idx]\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:\n                p_val = UB[idx] if lam > unit['b_i'] else LB[idx]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(LB[idx], min(UB[idx], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if abs(residual) > 1e-6:\n        adjustment_list = []\n        for idx in committed:\n            unit = units_info[idx]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_proj[idx]\n            if residual > 0:\n                headroom = UB[idx] - p_proj[idx]\n                if headroom > 0:\n                    adjustment_list.append((marginal_cost, headroom, idx, 1))\n            else:\n                headroom = p_proj[idx] - LB[idx]\n                if headroom > 0:\n                    adjustment_list.append((marginal_cost, headroom, idx, -1))\n        \n        if residual > 0:\n            adjustment_list.sort(key=lambda x: x[0])\n        else:\n            adjustment_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, headroom, idx, direction in adjustment_list:\n            if abs(residual) < 1e-6:\n                break\n            delta = min(abs(residual), headroom)\n            if direction == 1:\n                p_proj[idx] += delta\n                residual -= delta\n            else:\n                p_proj[idx] -= delta\n                residual += delta\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00359,
          "other_inf": null
     },
     {
          "algorithm": "The novel \"Ramp-Aware Adaptive Priority with Look-Ahead Feasibility\" algorithm integrates key insights from the existing algorithms while introducing unique components. It focuses on dynamic priority adjustments based on ramp capabilities, forecasts, and feasibility for future periods. Main steps:\n1. Classify units into must-run, must-off, and free categories based on min up/down-time constraints\n2. Commit must-run units and calculate their ramp-constrained min/max outputs\n3. Compute base priorities using a novel \"ramp-adaptive cost\" metric:\n   - For online units: Base cost = (unit['b_i'] + 2*unit['c_i'] * feasible_min) / ramp_headroom_ratio\n   - For offline units: Amortized cost adjusted by ramp-up capability and forecast impact\n4. Adjust priorities using forecasted load difference and normalized ramp flexibility\n5. Implement look-ahead feasibility check during commitment: Only add units if they maintain sufficient ramp capacity for next period's forecast\n6. Execute ramp-respecting dispatch via lambda iteration\n7. Perform ramp-aware residual adjustment considering both direction and magnitude of imbalance\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Calculate load variation and available ramp\n    load_diff = next_load - current_load\n    available_ramp_up = 0\n    available_ramp_down = 0\n    \n    for idx in range(n_units):\n        if units_info[idx]['u_i_0'] == 1:\n            available_ramp_up += units_info[idx]['p_up_i']\n            available_ramp_down += units_info[idx]['p_down_i']\n    \n    # Base priorities with ramp-flexible adjustments\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        # Calculate feasible operating range\n        if unit['u_i_0'] == 1:  # Online free units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            ramp_headroom = unit['p_up_i'] - (unit['p_i_0'] - feasible_min)\n            ramp_ratio = max(1e-6, ramp_headroom) / max(1e-6, unit['p_up_i'])\n            base_priority = (unit['b_i'] + 2 * unit['c_i'] * feasible_min) / ramp_ratio\n        else:  # Offline free units\n            min_p = unit['p_min_i']\n            feasible_max = min(unit['p_max_i'], unit['p_start_i'])\n            T = max(1, unit['t_on_min_i'])\n            amortized_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / (T * min_p)\n            ramp_ratio = min(1.0, unit['p_up_i'] / max(1e-6, unit['p_max_i'] - min_p))\n            base_priority = amortized_cost / ramp_ratio\n        \n        # Forecast impact factor\n        forecast_factor = 0\n        if abs(load_diff) > 1e-6:\n            norm_diff = load_diff / max(current_load, 1.0)\n            if load_diff > 0:  # Load increasing\n                if unit['u_i_0'] == 1:\n                    forecast_factor = min(0.5, norm_diff * unit['p_up_i'] / max(available_ramp_up, 1e-6))\n                else:\n                    forecast_factor = min(0.3, norm_diff * unit['p_up_i'] / max(available_ramp_up + unit['p_up_i'], 1e-6))\n            else:  # Load decreasing\n                if unit['u_i_0'] == 1:\n                    forecast_factor = max(-0.4, norm_diff * unit['p_down_i'] / max(available_ramp_down, 1e-6))\n                else:\n                    forecast_factor = max(-0.2, norm_diff * 0.1)\n        priority = base_priority * (1 - forecast_factor)\n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    # Commit free units with look-ahead feasibility\n    for _, idx in priorities:\n        unit = units_info[idx]\n        \n        # Calculate potential unit contribution\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Check future feasibility\n        future_ok = True\n        if load_diff > 0:  # Next load higher\n            future_min = current_load + total_min - lb_val\n            future_max = current_load + total_max + (unit['p_up_i'] if unit['u_i_0']==1 else unit['p_start_i'])\n            future_ok = (future_max >= next_load)\n        elif load_diff < 0:  # Next load lower\n            future_min = current_load + total_min - lb_val\n            future_max = current_load + total_max - lb_val + ub_val\n            future_ok = (future_min <= next_load)\n        \n        if total_max < current_load and future_ok:\n            committed.add(idx)\n            LB[idx] = lb_val\n            UB[idx] = ub_val\n            total_min += lb_val\n            total_max += ub_val\n    \n    # Decommitment using forecast-aware strategy\n    free_committed = [idx for idx in committed if idx not in must_run]\n    if free_committed:\n        removal_candidates = [(p, i) for p, i in priorities if i in free_committed]\n        removal_candidates.sort(reverse=True)\n        \n        for _, idx in removal_candidates:\n            unit = units_info[idx]\n            current_contribution = UB[idx] - LB[idx]\n            \n            new_min = total_min - LB[idx]\n            new_max = total_max - UB[idx]\n            \n            remove_ok = True\n            if load_diff < 0:  # Prefer higher min capacity for load drop\n                remove_ok = (new_min <= current_load)\n            elif load_diff > 0:  # Prefer keeping flexible capacity\n                if unit['p_up_i'] > 0.3 * available_ramp_up:\n                    remove_ok = False\n            \n            if remove_ok and new_max >= current_load:\n                committed.remove(idx)\n                total_min = new_min\n                total_max = new_max\n    \n    # Handle no units committed\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Ramp-respecting economic dispatch\n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * LB[idx]\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * UB[idx]\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:  # Linear cost\n                p_val = UB[idx] if lam > unit['b_i'] else LB[idx]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(LB[idx], min(UB[idx], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Project to ramp-constrained bounds\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Ramp-aware residual adjustment\n    residual = current_load - sum(p_proj)\n    \n    if abs(residual) > 1e-6:\n        adjustment_list = []\n        for idx in committed:\n            unit = units_info[idx]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_proj[idx]\n            if residual > 0:  # Need more power\n                headroom = UB[idx] - p_proj[idx]\n                if headroom > 0:\n                    adjustment_list.append((marginal_cost, headroom, idx, 1))\n            else:  # Need less power\n                headroom = p_proj[idx] - LB[idx]\n                if headroom > 0:\n                    adjustment_list.append((marginal_cost, headroom, idx, -1))\n        \n        if residual > 0:\n            adjustment_list.sort(key=lambda x: x[0])\n        else:\n            adjustment_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, headroom, idx, direction in adjustment_list:\n            if abs(residual) < 1e-6:\n                break\n            delta = min(abs(residual), headroom)\n            if direction == 1:\n                p_proj[idx] += delta\n                residual -= delta\n            else:\n                p_proj[idx] -= delta\n                residual += delta\n    \n    # Prepare output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.0036,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a dynamic priority-based commitment that recalculates priorities at each step based on the current generation gap. The steps include: (1) Classify units into must-run, must-off, and free categories based on current state and constraints. (2) Commit must-run units and compute capacity bounds. (3) For free units, compute a dynamic cost per MW that considers the unit's contribution to filling the current generation gap while respecting minimum generation constraints. Units with insufficient minimum generation to contribute meaningfully are skipped. (4) Commit the lowest priority unit that can contribute to the gap and update system capacity. (5) Remove overcommitted units by reverse cost priority while ensuring the system meets demand. (6) Perform economic dispatch using marginal cost bisection, clamp outputs to ramp constraints, and adjust residual load.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    remaining_free = free_units.copy()\n    while remaining_free and total_max < current_load:\n        gap = current_load - total_max\n        best_priority = float('inf')\n        best_unit = None\n        best_lb = None\n        best_ub = None\n        \n        for idx in remaining_free:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_val = unit['p_min_i']\n                ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if lb_val > gap:\n                continue\n                \n            if unit['u_i_0'] == 1:\n                total_cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            else:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            cost_per_MW = total_cost / lb_val\n            \n            if cost_per_MW < best_priority:\n                best_priority = cost_per_MW\n                best_unit = idx\n                best_lb = lb_val\n                best_ub = ub_val\n        \n        if best_unit is None:\n            break\n        \n        committed.add(best_unit)\n        remaining_free.remove(best_unit)\n        LB[best_unit] = best_lb\n        UB[best_unit] = best_ub\n        total_min += best_lb\n        total_max += best_ub\n    \n    free_committed = list(committed - set(must_run))\n    removal_candidates = []\n    for idx in free_committed:\n        unit = units_info[idx]\n        lb_val = LB[idx]\n        if unit['u_i_0'] == 1:\n            total_cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        else:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        cost_per_MW = total_cost / lb_val\n        removal_candidates.append((cost_per_MW, idx))\n    \n    removal_candidates.sort(key=lambda x: x[0], reverse=True)\n    for cost_per_MW, idx in removal_candidates:\n        if total_max - UB[idx] >= current_load:\n            committed.remove(idx)\n            total_min -= LB[idx]\n            total_max -= UB[idx]\n    \n    if not committed:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 1e-6:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, idx, headroom in candidates:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, idx, headroom in candidates:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00441,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm utilizes a load-centric adaptive commitment approach combined with ramp-flexible economic dispatch. The key steps are:\n1. Unit Classification: Group units into must-run, must-off, and free categories based on current state and constraints.\n2. Flexible Capacity Gap Calculation: Compute the remaining load after must-run units are committed.\n3. Adaptive Unit Selection: Select free units based on a cost-flexibility ratio that balances marginal cost and ramp capability relative to the load gap.\n4. Load-Centric Commitment: Commit units in ascending order of the cost-flexibility ratio until the gap is filled.\n5. Feasibility Enforcement: Remove overcommitted units using reverse cost order.\n6. Ramp-Constrained Economic Dispatch: Perform cost-based dispatch via Lagrange multipliers, then clamp outputs to feasible ramp bounds.\n7. Residual Load Redistribution: Adjust any remaining load imbalance using ramp headroom-aware marginal costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n                \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    gap = max(0, current_load - total_max)\n    selection_metrics = []\n    \n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * lb_val\n            flex_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'] + 1e-6)\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            T = max(1, unit['t_on_min_i'])\n            total_cost = unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2)\n            marginal_cost = total_cost / (T * lb_val)\n            flex_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'] + 1e-6)\n        \n        capacity_share = min(1, (ub_val - lb_val) / (gap + 1e-6))\n        metric = marginal_cost / (1.0 + flex_ratio * capacity_share)\n        selection_metrics.append((metric, idx, lb_val, ub_val))\n    \n    selection_metrics.sort(key=lambda x: x[0])\n    \n    for metric, idx, lb_val, ub_val in selection_metrics:\n        if gap <= 0:\n            break\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n        gap = max(0, current_load - total_max)\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_metrics = []\n    for idx in free_committed:\n        unit = units_info[idx]\n        lb_val = LB[idx]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * lb_val\n        removal_metrics.append((marginal_cost, idx))\n    removal_metrics.sort(key=lambda x: x[0], reverse=True)\n    \n    for marginal_cost, idx in removal_metrics:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    if not committed:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        lam_mid = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if lam_mid >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam_mid\n        else:\n            lam_high = lam_mid\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        ramp_candidates = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                ramp_capability = min(headroom, units_info[idx]['p_up_i'])\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                ramp_candidates.append((marginal_cost, ramp_capability, idx, headroom))\n        ramp_candidates.sort(key=lambda x: x[0])\n        for _, ramp_cap, idx, headroom in ramp_candidates:\n            if residual <= 0:\n                break\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n    elif residual < 0:\n        ramp_candidates = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                ramp_capability = min(headroom, units_info[idx]['p_down_i'])\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                ramp_candidates.append((marginal_cost, ramp_capability, idx, headroom))\n        ramp_candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, ramp_cap, idx, headroom in ramp_candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00486,
          "other_inf": null
     },
     {
          "algorithm": "** \nThis algorithm enhances the original \"Load-Following Flexible Commitment\" by modifying the scoring mechanism for unit commitment. The key improvements are:\n1. **Increased flexibility weighting**: The ramp ratio multiplier in the scoring formula is increased from 0.2 to 0.5 to prioritize units with greater operational flexibility.\n2. **Adjusted gap-reduction strategy**: Uses the minimum of a unit's available capacity (UB) and the current gap during commitment to more accurately reflect immediate contribution potential.\n3. **Enhanced decommitment**: Applies the same modified scoring to identify inefficient/inflexible units for decommitment.\n4. **Refined dispatch**: Maintains precise economic dispatch via lambda iteration and ramp-constrained output projection.\n\nMain steps remain consistent:\n1. Classify units into must-run/must-off/free based on constraints\n2. Commit must-run units, compute bounds\n3. Commit free units using new score: (min(UB, gap)/cost) \u00d7 (1 + 0.5 \u00d7 ramp_ratio)\n4. Decommit overcommitted units using the same scoring logic\n5. Perform economic dispatch\n6. Enforce ramp limits\n7. Adjust residual load\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    free_list = free_units.copy()\n    while free_list and total_max < current_load:\n        gap = current_load - total_min\n        best_score = float('-inf')\n        best_unit = None\n        best_lb = None\n        best_ub = None\n        \n        for idx in free_list:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_val = unit['p_min_i']\n                ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            \n            potential_min = total_min + lb_val\n            potential_max = total_max + ub_val\n            \n            ramp_range = unit['p_max_i'] - unit['p_min_i']\n            ramp_ratio = (unit['p_up_i'] + unit['p_down_i']) / max(1e-5, ramp_range)\n            \n            if unit['u_i_0'] == 1:\n                cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            else:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            \n            gap_reduction = min(ub_val, gap)\n            cost_efficiency = gap_reduction / max(1e-5, cost)\n            score = cost_efficiency * (1 + 0.5 * ramp_ratio)\n            \n            if score > best_score:\n                best_score = score\n                best_unit = idx\n                best_lb = lb_val\n                best_ub = ub_val\n        \n        if best_unit is not None:\n            committed.add(best_unit)\n            free_list.remove(best_unit)\n            LB[best_unit] = best_lb\n            UB[best_unit] = best_ub\n            total_min += best_lb\n            total_max += best_ub\n        else:\n            break\n    \n    free_committed = list(committed - set(must_run))\n    decommit_candidates = []\n    \n    for idx in free_committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        else:\n            lb_val = unit['p_min_i']\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        \n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        ramp_ratio = (unit['p_up_i'] + unit['p_down_i']) / max(1e-5, ramp_range)\n        \n        gap_reduction = lb_val\n        cost_efficiency = gap_reduction / max(1e-5, cost)\n        score = cost_efficiency * (1 + 0.5 * ramp_ratio)\n        decommit_candidates.append((score, idx))\n    \n    decommit_candidates.sort(key=lambda x: x[0])\n    for _, idx in decommit_candidates:\n        if total_min - LB[idx] <= current_load <= total_max - UB[idx]:\n            committed.remove(idx)\n            total_min -= LB[idx]\n            total_max -= UB[idx]\n    \n    if not committed:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(50):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 1e-6:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0])\n        for _, idx, cap in candidates:\n            if residual <= 0:\n                break\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n    \n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, cap in candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    u_out = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00488,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm is a look-ahead ramp-weighted priority heuristic that modifies the scoring function to incorporate forecasted load information. Key enhancements include:\n1. Classify units into must-run, must-off, and free units based on current state\n2. Calculate current capacity from must-run units\n3. For free off units, compute adjusted priority by:\n   - Adding a look-ahead benefit based on forecasted load gap\n   - Incorporating startup cost savings per MW weighted by look-ahead factor\n   - Considering ramp capabilities via ramp ratio\n4. For free on units, use standard ramp-weighted cost priority\n5. Commit units in ascending adjusted priority order\n6. Remove overcommitted units in descending order\n7. Dispatch via lambda iteration with ramp constraints\n8. Adjust residuals respecting ramp limits\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight = 0.15\n    look_ahead_factor = 0.25\n    gap = max(0, forecast_load - total_max) if forecast_load is not None else 0\n    \n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            benefit = min(unit['p_max_i'], gap) / unit['p_max_i'] if unit['p_max_i'] > 0 else 0\n            look_ahead_benefit = look_ahead_factor * (unit['s_i'] / min_p) * benefit if min_p > 0 else 0\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            adjusted_amort = amort_cost / min_p - look_ahead_benefit\n            priority = adjusted_amort * (1.0 - ramp_weight * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00493,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm introduces a novel \"Load-Following Flexible Commitment\" approach. It focuses on dynamically adjusting unit commitment priorities based on both the current load gap and available ramp headroom. Key features include:\n1. Classifies units into must-run/must-off/free based on current status and constraints\n2. Commits must-run units and computes initial capacity bounds\n3. For each free unit, calculates a \"load-following score\" that blends cost efficiency (cost per MW at minimum output) with ramp flexibility (ramp ratio)\n4. Iteratively commits units with the best load-following scores until meeting load demand, recalculating scores after each commitment to adapt to the changing gap\n5. Decommits overcommitted units using reverse score order while ensuring feasibility\n6. Performs economic dispatch via lambda iteration\n7. Projects outputs to ramp-constrained bounds\n8. Corrects any residual load using marginal cost-based adjustments\nThe innovation lies in the adaptive gap-aware priority metric that continuously recalculates unit priorities as the commitment gap changes.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    free_list = free_units.copy()\n    while free_list and total_max < current_load:\n        gap = current_load - total_min\n        best_score = float('-inf')\n        best_unit = None\n        best_lb = None\n        best_ub = None\n        \n        for idx in free_list:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_val = unit['p_min_i']\n                ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            \n            potential_min = total_min + lb_val\n            potential_max = total_max + ub_val\n            \n            ramp_range = unit['p_max_i'] - unit['p_min_i']\n            ramp_ratio = (unit['p_up_i'] + unit['p_down_i']) / max(1e-5, ramp_range)\n            \n            if unit['u_i_0'] == 1:\n                cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            else:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            \n            gap_reduction = min(ub_val, gap) if gap > 0 else lb_val\n            cost_efficiency = gap_reduction / max(1e-5, cost)\n            score = cost_efficiency * (1 + 0.2 * ramp_ratio)\n            \n            if score > best_score:\n                best_score = score\n                best_unit = idx\n                best_lb = lb_val\n                best_ub = ub_val\n        \n        if best_unit is not None:\n            committed.add(best_unit)\n            free_list.remove(best_unit)\n            LB[best_unit] = best_lb\n            UB[best_unit] = best_ub\n            total_min += best_lb\n            total_max += best_ub\n        else:\n            break\n    \n    free_committed = list(committed - set(must_run))\n    decommit_candidates = []\n    \n    for idx in free_committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        else:\n            lb_val = unit['p_min_i']\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        \n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        ramp_ratio = (unit['p_up_i'] + unit['p_down_i']) / max(1e-5, ramp_range)\n        \n        gap_reduction = lb_val\n        cost_efficiency = gap_reduction / max(1e-5, cost)\n        score = cost_efficiency * (1 + 0.2 * ramp_ratio)\n        decommit_candidates.append((score, idx))\n    \n    decommit_candidates.sort(key=lambda x: x[0])\n    for _, idx in decommit_candidates:\n        if total_min - LB[idx] <= current_load <= total_max - UB[idx]:\n            committed.remove(idx)\n            total_min -= LB[idx]\n            total_max -= UB[idx]\n    \n    if not committed:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(50):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 1e-6:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0])\n        for _, idx, cap in candidates:\n            if residual <= 0:\n                break\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n    \n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, cap in candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    u_out = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00496,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm introduces a forward-looking component by utilizing the next period's forecasted load to adjust unit priorities, aiming to minimize startup costs and ensure feasibility for upcoming periods. Key steps:\n1. Classify units into must-run, must-off, and free units based on min up/down-time constraints\n2. Commit must-run units and calculate their ramp-constrained min/max outputs\n3. Compute base priorities for free units: marginal cost at feasible min for online units, amortized cost for offline units\n4. Adjust priorities considering ramp capabilities and next-period load difference:\n   - Boost priority for units with high ramp capacity if next load > current load\n   - Reduce priority for costly units if next load < current load\n5. Commit free units in adjusted priority order until meeting current load\n6. Perform decommitment in reverse priority order if overcommitted\n7. Execute lambda-based economic dispatch via bisection\n8. Clamp outputs to ramp-constrained bounds\n9. Distribute residual load using incremental costs within headroom limits\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]  # Forecasted load for next period\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Load difference between next and current period\n    load_diff = next_load - current_load\n    priorities = []\n    \n    # Base priorities with forecast-aware adjustments\n    for idx in free_units:\n        unit = units_info[idx]\n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        \n        if unit['u_i_0'] == 1:  # Online free units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            base_priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            \n            # Prioritize flexible units for increasing load\n            ramp_ratio = unit['p_up_i'] / ramp_range if ramp_range > 0 else 0\n            forecast_factor = ramp_ratio * max(0, min(1, load_diff / max(current_load, 1)))\n            priority = base_priority * (1 - 0.5 * forecast_factor)\n        else:  # Offline free units\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amortized_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / (T * min_p)\n            base_priority = amortized_cost\n            \n            # Penalize expensive startups for decreasing load\n            ramp_ratio = unit['p_start_i'] / ramp_range if ramp_range > 0 else 0\n            forecast_factor = ramp_ratio * max(0, min(1, -load_diff / max(current_load, 1)))\n            priority = base_priority * (1 + forecast_factor)\n        \n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Decommitment based on reverse priority order\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    # Edge case: no units committed\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Lambda-based economic dispatch\n    lam_low = min(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:  # Linear cost function\n                p_val = unit['p_max_i'] if lam > unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    # Residual load adjustment\n    if residual > 0:  # Under-generation\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx, cap in candidates:\n            if residual <= 0:\n                break\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n    \n    elif residual < 0:  # Over-generation\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx, cap in candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00498,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe revised algorithm maintains the core structure of unit commitment and economic dispatch but simplifies the priority calculation for free units by removing ramp ratio weighting. Units are classified as must-run, must-off, or free based on their initial state and constraints. Must-run units are committed first, considering their ramp limits. Free units are then prioritized: online units by marginal cost at their feasible minimum output, and offline units by amortized cost per MW at minimum power (factoring in startup costs over the minimum uptime). After committing free units in ascending priority order until total max capacity meets the load, an optional de-commitment step removes the highest-priority free units if minimum generation exceeds the load and removal doesn't violate feasibility. If units remain committed, economic dispatch via binary search allocates power based on marginal cost within ramp limits, followed by residual load adjustment using headroom capacities sorted by marginal cost.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            priority = amort_cost / min_p\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.005,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the priority adjustment mechanism and introduces a flexibility factor to better handle forecasted load changes. Key changes include:\n1. Using a flexibility factor based on ramp capabilities relative to power range\n2. Applying different adjustment formulas for online/offline units:\n   - For online units: Adjusted priority = base_priority \u00d7 (1 - flexibility_factor \u00d7 max(0, load_diff)/current_load)\n   - For offline units: Adjusted priority = base_priority \u00d7 (1 + flexibility_factor \u00d7 max(0, -load_diff)/current_load)\n3. Using additive adjustments instead of multiplicative for forecast factors\n4. Simplifying priority calculations while maintaining forecast awareness\n\nMain steps:\n1. Classify units into must-run, must-off, and free units\n2. Commit must-run units and calculate ramp-constrained bounds\n3. Compute base priorities for free units:\n   - Online: Marginal cost at feasible minimum output\n   - Offline: Amortized startup cost\n4. Calculate flexibility factor (ramp capabilities / power range)\n5. Adjust priorities using forecast-aware additive adjustments\n6. Commit free units in adjusted priority order\n7. Decommit in reverse adjusted priority order if overcommitted\n8. Perform lambda-based economic dispatch\n9. Clamp outputs to ramp constraints\n10. Distribute residual load using incremental costs\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    load_diff = next_load - current_load\n    priorities = []\n    \n    for idx in free_units:\n        unit = units_info[idx]\n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        flex_factor = (unit['p_up_i'] + unit['p_down_i']) / max(1, ramp_range)\n        \n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            base_priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            \n            forecast_factor = flex_factor * max(0, load_diff) / max(current_load, 1)\n            priority = base_priority * (1 - forecast_factor)\n        else:\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amortized_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / (T * min_p)\n            base_priority = amortized_cost\n            \n            forecast_factor = flex_factor * max(0, -load_diff) / max(current_load, 1)\n            priority = base_priority * (1 + forecast_factor)\n        \n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = min(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:\n                p_val = unit['p_max_i'] if lam > unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx, cap in candidates:\n            if residual <= 0:\n                break\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n    \n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx, cap in candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00502,
          "other_inf": null
     }
]