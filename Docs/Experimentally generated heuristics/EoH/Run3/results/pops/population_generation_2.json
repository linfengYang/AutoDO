[
     {
          "algorithm": "**\nThe revised algorithm maintains the core structure of unit commitment and economic dispatch but simplifies the priority calculation for free units by removing ramp ratio weighting. Units are classified as must-run, must-off, or free based on their initial state and constraints. Must-run units are committed first, considering their ramp limits. Free units are then prioritized: online units by marginal cost at their feasible minimum output, and offline units by amortized cost per MW at minimum power (factoring in startup costs over the minimum uptime). After committing free units in ascending priority order until total max capacity meets the load, an optional de-commitment step removes the highest-priority free units if minimum generation exceeds the load and removal doesn't violate feasibility. If units remain committed, economic dispatch via binary search allocates power based on marginal cost within ramp limits, followed by residual load adjustment using headroom capacities sorted by marginal cost.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            priority = amort_cost / min_p\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.005,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm uses a priority-based commitment with ramp-adjusted costs and a look-ahead dispatch. Key steps: 1) Identify must-run/must-off units; 2) For free units, calculate ramp-flexible priorities combining operating costs and startup costs scaled by ramp capabilities; 3) Build committed set by adding units in priority order until meeting load; 4) Remove overcommitted units using reverse-priority order; 5) Perform unconstrained dispatch ignoring ramp limits; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residual load incrementally while respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Identify must-run, must-off, and free units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Start with must-run units committed\n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate initial bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Calculate ramp-flexible priorities for free units\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Currently online\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - 0.1 * ramp_ratio)\n        else:  # Currently offline\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - 0.1 * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    # Build commitment set\n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units\n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    # Skip dispatch if no committed units\n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    # Unconstrained economic dispatch ignoring ramp limits\n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Project to ramp-constrained bounds\n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Adjust residual load\n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    # Distribute residual load\n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00514,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm employs a dual-phase unit commitment and dispatch strategy with segregated warm/cold unit processing and proactive feasibility checks. Key steps: 1) Classify units into must-run, must-off, warm-free, and cold-free. 2) Commit must-run units. 3) Compute ramp-adjusted priorities for warm and cold free units separately. 4) Commit warm units in priority order until meeting load, followed by cold units if needed. 5) Remove overcommitted units in reverse-priority order while maintaining feasibility. 6) Perform unconstrained dispatch using bisection. 7) Clamp outputs to ramp-constrained bounds. 8) Adjust residuals via incremental cost-based redistribution within ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    warm_free = []\n    cold_free = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                warm_free.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                cold_free.append(idx)\n    \n    # Commit must-run units\n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Compute priorities for warm free units\n    warm_prio = []\n    for idx in warm_free:\n        unit = units_info[idx]\n        ramp_up_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost * (1 - 0.1 * ramp_up_ratio)\n        warm_prio.append((priority, idx))\n    warm_prio.sort(key=lambda x: x[0])\n    \n    # Compute priorities for cold free units\n    cold_prio = []\n    for idx in cold_free:\n        unit = units_info[idx]\n        T = max(1, unit['t_on_min_i'])\n        amortized = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2)) / (T * unit['p_min_i'])\n        ramp_up_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n        priority = amortized * (1 - 0.1 * ramp_up_ratio)\n        cold_prio.append((priority, idx))\n    cold_prio.sort(key=lambda x: x[0])\n    \n    # Commit warm free units\n    all_prio = warm_prio + cold_prio\n    for priority, idx in all_prio:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Warm unit\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Cold unit\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units\n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in all_prio if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    # Handle no commitment case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Recalculate LB/UB for all committed units\n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            LB[idx] = unit['p_min_i']\n            UB[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Unconstrained dispatch via bisection\n    p_ideal = [0] * n_units\n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    for _ in range(100):\n        lam_mid = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if lam_mid >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam_mid\n        else:\n            lam_high = lam_mid\n    \n    # Clamp to feasible bounds\n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Adjust residual load\n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:  # Under-generation\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            if residual <= 0:\n                break\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n    elif residual < 0:  # Over-generation\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            if residual >= 0:\n                break\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    # Generate output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00515,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm is a ramp-weighted priority heuristic that modifies the scoring function by increasing the ramp weight parameter from 0.1 to 0.15 and explicitly using minimum outputs for cost amortization in offline units. Key steps: 1) Identify must-run/must-off units based on current state; 2) For free units, compute priorities with ramp weight=0.15 and cost amortization period equal to min_up_time; 3) Commit units in ascending priority order until satisfying load; 4) Remove overcommitted units in descending priority order; 5) Dispatch via cost-based lambda iteration; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight = 0.15\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00516,
          "other_inf": null
     },
     {
          "algorithm": "A modified ramp-weighted priority heuristic that differentiates ramp weights for online and offline units and incorporates the maximum feasible power during startup/shutdown. Key steps: 1) Identify must-run/must-off units based on min uptime/downtime and previous outputs. 2) For free units, calculate priorities using ramp weights (0.2 for online, 0.3 for offline) and cost amortization over min uptime for offline units. 3) Commit units in ascending priority order until satisfying load. 4) Remove overcommitted units in descending priority order if possible. 5) Dispatch via cost-based lambda iteration. 6) Clamp outputs to feasible ramp bounds. 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight_online = 0.2\n    ramp_weight_offline = 0.3\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight_online * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight_offline * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00525,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, \"adaptive-ramp-amortization,\" adjusts the ramp weight to 0.2 and modifies cost amortization for offline units using a fixed period of 2 instead of min_up_time. Main steps: 1) Identify must-run/must-off units based on current state; 2) For free units, compute priorities with ramp weight=0.2 and cost amortization period=2; 3) Commit units in ascending priority order until satisfying load; 4) Remove overcommitted units in descending priority order; 5) Dispatch via cost-based lambda iteration; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight = 0.2\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight * ramp_ratio)\n        else:\n            T = 2\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00527,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the priority calculation by incorporating a more nuanced ramp consideration and cost amortization. Key modifications include:\n\n1. **Priority Calculation**: \n   - For online units, use the current feasible minimum power output instead of the static min limit to compute marginal costs\n   - For offline units, incorporate both the minimum up-time and an estimated operation duration factor in startup cost amortization\n   - Apply distinct ramp sensitivity factors (0.15 for online, 0.25 for offline units) to better differentiate ramp capabilities\n\n2. **Residual Load Handling**: \n   - Explicitly calculate and distribute residual load using incremental costs\n   - Implement efficient headroom utilization during load adjustment\n\nMain steps:\n1. Identify must-run/must-off units based on physical constraints\n2. Calculate enhanced priorities considering dynamic ramp impact and cost amortization\n3. Build commitment set using priority order \n4. Remove overcommitted units via reverse-priority selection\n5. Perform lambda-based economic dispatch\n6. Clamp outputs to ramp-constrained bounds\n7. Adjust residual load incrementally using sorted incremental costs\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        ramp_range = unit['p_max_i'] - min_p\n        ramp_ratio = 0.0\n        \n        if ramp_range > 0:\n            if unit['u_i_0'] == 1:\n                feasible_min = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                ramp_ratio = unit['p_down_i'] / ramp_range\n                priority = (unit['b_i'] + 2 * unit['c_i'] * feasible_min) * (1.0 - 0.15 * ramp_ratio)\n            else:\n                ramp_ratio = unit['p_up_i'] / ramp_range\n                T = max(1, unit['t_on_min_i'])\n                # Include estimated operation duration in amortization\n                D = max(T, unit['t_off_min_i'] if unit['t_off_min_i'] > 0 else 5)\n                amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2)) / min_p / D\n                priority = amort_cost * (1.0 - 0.25 * ramp_ratio)\n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = -1000.0\n    high_lam = 10000.0\n    p_ideal = [0] * n_units\n    \n    for _ in range(50):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 1e-3:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    residual = current_load\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n        residual -= p_proj[idx]\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        \n        for inc_cost, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for inc_cost, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00554,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the unit commitment and dispatch process by removing complex ramp scaling in priority calculations and marginal cost averaging in residual distribution. Key steps:\n1. Classify units into must-run, must-off, and free categories based on current state and operational constraints\n2. Commit must-run units and calculate min/max capacity bounds\n3. Prioritize free units using simplified cost-based criteria without ramp ratio adjustments\n4. Commit free units in ascending cost order until generation capacity meets load\n5. Remove overcommitted units by reverse cost priority while ensuring system can still meet load\n6. Perform economic dispatch via marginal cost bisection\n7. Distribute residual load using marginal cost at dispatch point rather than range average\n8. Handle edge cases (no committed units)\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Initialize committed set with must-run units\n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Simplified priority calculation without ramp scaling\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Online units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:  # Offline units\n            # Amortize startup cost over minimum generation\n            base_cost = (unit['s_i'] + unit['a_i']) / unit['p_min_i']\n            incremental_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            priority = base_cost + incremental_cost\n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units with undercommitment safeguard\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        # Skip removal if it causes undercommitment\n        if total_max - UB[idx] < current_load:\n            continue\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        committed.remove(idx)\n        total_min = new_min\n        total_max = new_max\n        if total_min <= current_load:\n            break\n    \n    # Handle no-commitment edge case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Unconstrained economic dispatch\n    lam_low = min(unit['b_i'] + 2*unit['c_i']*unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] < 1e-6:  # Linear cost\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp outputs to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    residual = current_load - sum(p_proj)\n    \n    # Residual distribution using marginal cost at dispatch point\n    if residual > 0:  # Underproduction\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort()\n        \n        for cost, idx, cap in candidates:\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:  # Overproduction\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort(reverse=True)\n        \n        for cost, idx, cap in candidates:\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00595,
          "other_inf": null
     },
     {
          "algorithm": "** The revised algorithm simplifies the priority calculation for free units by removing arbitrary ramp ratio adjustments and using consistent average cost per MW for both committing and decommitting. For committing free units, it calculates priority based on average cost at feasible minimum output. For decommitting, it prioritizes units with the highest average cost per MW at their lower bound. This reduces overfitting to in-distribution patterns and enhances generalization for OOD instances while maintaining core constraints (ramp rates, min up/down times). The economic dispatch and residual adjustment remain unchanged.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['a_i'] + unit['b_i'] * feasible_min + unit['c_i'] * feasible_min**2\n            priority = cost / feasible_min\n        else:\n            min_p = unit['p_min_i']\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            priority = cost / min_p\n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    decommit_priorities = []\n    for idx in free_committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 0:\n            cost_avoided = unit['s_i'] + unit['a_i'] + unit['b_i'] * LB[idx] + unit['c_i'] * LB[idx]**2\n        else:\n            cost_avoided = unit['a_i'] + unit['b_i'] * LB[idx] + unit['c_i'] * LB[idx]**2\n        priority_decommit = cost_avoided / LB[idx]\n        decommit_priorities.append((priority_decommit, idx))\n    \n    decommit_priorities.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(decommit_priorities) and total_min > current_load:\n        _, idx = decommit_priorities[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = -1000.0\n    high_lam = 10000.0\n    p_ideal = [0] * n_units\n    \n    for _ in range(50):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 1e-3:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    residual = current_load\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n        residual -= p_proj[idx]\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        \n        for inc_cost, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for inc_cost, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00609,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the priority calculation for free units by incorporating the average cost per MW at minimum load for offline units. This provides a more balanced assessment of startup and operating costs. For online units, the priority remains the marginal cost at feasible minimum output. The algorithm classifies units, commits must-run units, prioritizes free units by ascending average cost (offline) or marginal cost (online), removes overcommitted units in reverse priority order, performs economic dispatch via lambda bisection, clamps outputs to ramp limits, and distributes residual load using current marginal costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Initialize committed set with must-run units\n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # New priority calculation with average cost for offline units\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Online units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:  # Offline units\n            avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n            priority = avg_cost\n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units in reverse priority order\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_min <= current_load and current_load <= new_max:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    # Handle no-commitment edge case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Unconstrained economic dispatch\n    lam_low = min(unit['b_i'] + 2*unit['c_i']*unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2*unit['c_i']*unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] < 1e-6:  # Linear cost\n                p_val = unit['p_max_i'] if lam >= unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp outputs to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    residual = current_load - sum(p_proj)\n    \n    # Residual distribution using current marginal costs\n    if residual > 0:  # Underproduction\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort()\n        \n        for cost, idx, cap in candidates:\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    \n    elif residual < 0:  # Overproduction\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap <= 0:\n                continue\n            marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n            candidates.append((marginal_cost, idx, cap))\n        candidates.sort(reverse=True)\n        \n        for cost, idx, cap in candidates:\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.0061,
          "other_inf": null
     }
]