[
     {
          "algorithm": "This algorithm uses a dynamic priority-based commitment that recalculates priorities at each step based on the current generation gap. The steps include: (1) Classify units into must-run, must-off, and free categories based on current state and constraints. (2) Commit must-run units and compute capacity bounds. (3) For free units, compute a dynamic cost per MW that considers the unit's contribution to filling the current generation gap while respecting minimum generation constraints. Units with insufficient minimum generation to contribute meaningfully are skipped. (4) Commit the lowest priority unit that can contribute to the gap and update system capacity. (5) Remove overcommitted units by reverse cost priority while ensuring the system meets demand. (6) Perform economic dispatch using marginal cost bisection, clamp outputs to ramp constraints, and adjust residual load.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    remaining_free = free_units.copy()\n    while remaining_free and total_max < current_load:\n        gap = current_load - total_max\n        best_priority = float('inf')\n        best_unit = None\n        best_lb = None\n        best_ub = None\n        \n        for idx in remaining_free:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_val = unit['p_min_i']\n                ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if lb_val > gap:\n                continue\n                \n            if unit['u_i_0'] == 1:\n                total_cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            else:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            cost_per_MW = total_cost / lb_val\n            \n            if cost_per_MW < best_priority:\n                best_priority = cost_per_MW\n                best_unit = idx\n                best_lb = lb_val\n                best_ub = ub_val\n        \n        if best_unit is None:\n            break\n        \n        committed.add(best_unit)\n        remaining_free.remove(best_unit)\n        LB[best_unit] = best_lb\n        UB[best_unit] = best_ub\n        total_min += best_lb\n        total_max += best_ub\n    \n    free_committed = list(committed - set(must_run))\n    removal_candidates = []\n    for idx in free_committed:\n        unit = units_info[idx]\n        lb_val = LB[idx]\n        if unit['u_i_0'] == 1:\n            total_cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        else:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        cost_per_MW = total_cost / lb_val\n        removal_candidates.append((cost_per_MW, idx))\n    \n    removal_candidates.sort(key=lambda x: x[0], reverse=True)\n    for cost_per_MW, idx in removal_candidates:\n        if total_max - UB[idx] >= current_load:\n            committed.remove(idx)\n            total_min -= LB[idx]\n            total_max -= UB[idx]\n    \n    if not committed:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 1e-6:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, idx, headroom in candidates:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, idx, headroom in candidates:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00441,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm introduces a forward-looking component by utilizing the next period's forecasted load to adjust unit priorities, aiming to minimize startup costs and ensure feasibility for upcoming periods. Key steps:\n1. Classify units into must-run, must-off, and free units based on min up/down-time constraints\n2. Commit must-run units and calculate their ramp-constrained min/max outputs\n3. Compute base priorities for free units: marginal cost at feasible min for online units, amortized cost for offline units\n4. Adjust priorities considering ramp capabilities and next-period load difference:\n   - Boost priority for units with high ramp capacity if next load > current load\n   - Reduce priority for costly units if next load < current load\n5. Commit free units in adjusted priority order until meeting current load\n6. Perform decommitment in reverse priority order if overcommitted\n7. Execute lambda-based economic dispatch via bisection\n8. Clamp outputs to ramp-constrained bounds\n9. Distribute residual load using incremental costs within headroom limits\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]  # Forecasted load for next period\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Offline units\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Process must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Load difference between next and current period\n    load_diff = next_load - current_load\n    priorities = []\n    \n    # Base priorities with forecast-aware adjustments\n    for idx in free_units:\n        unit = units_info[idx]\n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        \n        if unit['u_i_0'] == 1:  # Online free units\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            base_priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            \n            # Prioritize flexible units for increasing load\n            ramp_ratio = unit['p_up_i'] / ramp_range if ramp_range > 0 else 0\n            forecast_factor = ramp_ratio * max(0, min(1, load_diff / max(current_load, 1)))\n            priority = base_priority * (1 - 0.5 * forecast_factor)\n        else:  # Offline free units\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amortized_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / (T * min_p)\n            base_priority = amortized_cost\n            \n            # Penalize expensive startups for decreasing load\n            ramp_ratio = unit['p_start_i'] / ramp_range if ramp_range > 0 else 0\n            forecast_factor = ramp_ratio * max(0, min(1, -load_diff / max(current_load, 1)))\n            priority = base_priority * (1 + forecast_factor)\n        \n        priorities.append((priority, idx))\n    \n    # Commit units in ascending priority order\n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Decommitment based on reverse priority order\n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    # Edge case: no units committed\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Lambda-based economic dispatch\n    lam_low = min(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:  # Linear cost function\n                p_val = unit['p_max_i'] if lam > unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Clamp to feasible ramp ranges\n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    # Residual load adjustment\n    if residual > 0:  # Under-generation\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx, cap in candidates:\n            if residual <= 0:\n                break\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n    \n    elif residual < 0:  # Over-generation\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx, cap in candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    # Prepare output arrays\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00498,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe revised algorithm maintains the core structure of unit commitment and economic dispatch but simplifies the priority calculation for free units by removing ramp ratio weighting. Units are classified as must-run, must-off, or free based on their initial state and constraints. Must-run units are committed first, considering their ramp limits. Free units are then prioritized: online units by marginal cost at their feasible minimum output, and offline units by amortized cost per MW at minimum power (factoring in startup costs over the minimum uptime). After committing free units in ascending priority order until total max capacity meets the load, an optional de-commitment step removes the highest-priority free units if minimum generation exceeds the load and removal doesn't violate feasibility. If units remain committed, economic dispatch via binary search allocates power based on marginal cost within ramp limits, followed by residual load adjustment using headroom capacities sorted by marginal cost.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            priority = amort_cost / min_p\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.005,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the priority adjustment mechanism and introduces a flexibility factor to better handle forecasted load changes. Key changes include:\n1. Using a flexibility factor based on ramp capabilities relative to power range\n2. Applying different adjustment formulas for online/offline units:\n   - For online units: Adjusted priority = base_priority \u00d7 (1 - flexibility_factor \u00d7 max(0, load_diff)/current_load)\n   - For offline units: Adjusted priority = base_priority \u00d7 (1 + flexibility_factor \u00d7 max(0, -load_diff)/current_load)\n3. Using additive adjustments instead of multiplicative for forecast factors\n4. Simplifying priority calculations while maintaining forecast awareness\n\nMain steps:\n1. Classify units into must-run, must-off, and free units\n2. Commit must-run units and calculate ramp-constrained bounds\n3. Compute base priorities for free units:\n   - Online: Marginal cost at feasible minimum output\n   - Offline: Amortized startup cost\n4. Calculate flexibility factor (ramp capabilities / power range)\n5. Adjust priorities using forecast-aware additive adjustments\n6. Commit free units in adjusted priority order\n7. Decommit in reverse adjusted priority order if overcommitted\n8. Perform lambda-based economic dispatch\n9. Clamp outputs to ramp constraints\n10. Distribute residual load using incremental costs\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    load_diff = next_load - current_load\n    priorities = []\n    \n    for idx in free_units:\n        unit = units_info[idx]\n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        flex_factor = (unit['p_up_i'] + unit['p_down_i']) / max(1, ramp_range)\n        \n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            base_priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            \n            forecast_factor = flex_factor * max(0, load_diff) / max(current_load, 1)\n            priority = base_priority * (1 - forecast_factor)\n        else:\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amortized_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / (T * min_p)\n            base_priority = amortized_cost\n            \n            forecast_factor = flex_factor * max(0, -load_diff) / max(current_load, 1)\n            priority = base_priority * (1 + forecast_factor)\n        \n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    removal_order = [(p, i) for p, i in priorities if i in free_committed]\n    removal_order.sort(reverse=True)\n    \n    for _, idx in removal_order:\n        if total_min <= current_load:\n            break\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = min(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'] for idx in committed for unit in [units_info[idx]])\n    lam_high = max(unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i'] for idx in committed for unit in [units_info[idx]])\n    p_ideal = [0.0] * n_units\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:\n                p_val = unit['p_max_i'] if lam > unit['b_i'] else unit['p_min_i']\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            cap = UB[idx] - p_proj[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0])\n        \n        for _, idx, cap in candidates:\n            if residual <= 0:\n                break\n            add = min(residual, cap)\n            p_proj[idx] += add\n            residual -= add\n    \n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            cap = p_proj[idx] - LB[idx]\n            if cap > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, cap))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, idx, cap in candidates:\n            if residual >= 0:\n                break\n            reduce = min(-residual, cap)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00502,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm uses a priority-based commitment with ramp-adjusted costs and a look-ahead dispatch. Key steps: 1) Identify must-run/must-off units; 2) For free units, calculate ramp-flexible priorities combining operating costs and startup costs scaled by ramp capabilities; 3) Build committed set by adding units in priority order until meeting load; 4) Remove overcommitted units using reverse-priority order; 5) Perform unconstrained dispatch ignoring ramp limits; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residual load incrementally while respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Identify must-run, must-off, and free units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Start with must-run units committed\n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate initial bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Calculate ramp-flexible priorities for free units\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Currently online\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - 0.1 * ramp_ratio)\n        else:  # Currently offline\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - 0.1 * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    # Build commitment set\n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units\n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    # Skip dispatch if no committed units\n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    # Unconstrained economic dispatch ignoring ramp limits\n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Project to ramp-constrained bounds\n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Adjust residual load\n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    # Distribute residual load\n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00514,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm employs a dual-phase unit commitment and dispatch strategy with segregated warm/cold unit processing and proactive feasibility checks. Key steps: 1) Classify units into must-run, must-off, warm-free, and cold-free. 2) Commit must-run units. 3) Compute ramp-adjusted priorities for warm and cold free units separately. 4) Commit warm units in priority order until meeting load, followed by cold units if needed. 5) Remove overcommitted units in reverse-priority order while maintaining feasibility. 6) Perform unconstrained dispatch using bisection. 7) Clamp outputs to ramp-constrained bounds. 8) Adjust residuals via incremental cost-based redistribution within ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    warm_free = []\n    cold_free = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                warm_free.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                cold_free.append(idx)\n    \n    # Commit must-run units\n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Compute priorities for warm free units\n    warm_prio = []\n    for idx in warm_free:\n        unit = units_info[idx]\n        ramp_up_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost * (1 - 0.1 * ramp_up_ratio)\n        warm_prio.append((priority, idx))\n    warm_prio.sort(key=lambda x: x[0])\n    \n    # Compute priorities for cold free units\n    cold_prio = []\n    for idx in cold_free:\n        unit = units_info[idx]\n        T = max(1, unit['t_on_min_i'])\n        amortized = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2)) / (T * unit['p_min_i'])\n        ramp_up_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n        priority = amortized * (1 - 0.1 * ramp_up_ratio)\n        cold_prio.append((priority, idx))\n    cold_prio.sort(key=lambda x: x[0])\n    \n    # Commit warm free units\n    all_prio = warm_prio + cold_prio\n    for priority, idx in all_prio:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Warm unit\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Cold unit\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units\n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in all_prio if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    # Handle no commitment case\n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    # Recalculate LB/UB for all committed units\n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            LB[idx] = unit['p_min_i']\n            UB[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Unconstrained dispatch via bisection\n    p_ideal = [0] * n_units\n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    for _ in range(100):\n        lam_mid = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if lam_mid >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam_mid\n        else:\n            lam_high = lam_mid\n    \n    # Clamp to feasible bounds\n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Adjust residual load\n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:  # Under-generation\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            if residual <= 0:\n                break\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n    elif residual < 0:  # Over-generation\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            if residual >= 0:\n                break\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n    \n    # Generate output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00515,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm is a ramp-weighted priority heuristic that modifies the scoring function by increasing the ramp weight parameter from 0.1 to 0.15 and explicitly using minimum outputs for cost amortization in offline units. Key steps: 1) Identify must-run/must-off units based on current state; 2) For free units, compute priorities with ramp weight=0.15 and cost amortization period equal to min_up_time; 3) Commit units in ascending priority order until satisfying load; 4) Remove overcommitted units in descending priority order; 5) Dispatch via cost-based lambda iteration; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight = 0.15\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00516,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the priority calculation by incorporating a weighted combination of marginal cost and ramp flexibility, with adjusted coefficients to emphasize ramp rates. Key steps remain: 1) Identify must-run/must-off units based on min up/down times and shutdown capacity 2) For free units, compute priority as marginal cost times a ramp-dependent factor using coefficients 0.15 for online/0.2 for offline units 3) Commit units in ascending priority order until meeting load 4) Remove overcommitted units via reverse priority 5) Unconstrained dispatch via lambda iteration 6) Clamp outputs to ramp-constrained bounds 7) Resolve residual load via incremental cost-based adjustments  \n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - 0.15 * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - 0.2 * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00524,
          "other_inf": null
     },
     {
          "algorithm": "A modified ramp-weighted priority heuristic that differentiates ramp weights for online and offline units and incorporates the maximum feasible power during startup/shutdown. Key steps: 1) Identify must-run/must-off units based on min uptime/downtime and previous outputs. 2) For free units, calculate priorities using ramp weights (0.2 for online, 0.3 for offline) and cost amortization over min uptime for offline units. 3) Commit units in ascending priority order until satisfying load. 4) Remove overcommitted units in descending priority order if possible. 5) Dispatch via cost-based lambda iteration. 6) Clamp outputs to feasible ramp bounds. 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight_online = 0.2\n    ramp_weight_offline = 0.3\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight_online * ramp_ratio)\n        else:\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight_offline * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00525,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm, \"adaptive-ramp-amortization,\" adjusts the ramp weight to 0.2 and modifies cost amortization for offline units using a fixed period of 2 instead of min_up_time. Main steps: 1) Identify must-run/must-off units based on current state; 2) For free units, compute priorities with ramp weight=0.2 and cost amortization period=2; 3) Commit units in ascending priority order until satisfying load; 4) Remove overcommitted units in descending priority order; 5) Dispatch via cost-based lambda iteration; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residuals respecting ramp limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    ramp_weight = 0.2\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - ramp_weight * ramp_ratio)\n        else:\n            T = 2\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - ramp_weight * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
          "objective": 0.00527,
          "other_inf": null
     }
]