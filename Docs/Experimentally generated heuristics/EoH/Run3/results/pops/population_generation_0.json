[
     {
          "algorithm": "The heuristic, Greedy Priority-Based Dispatch with Rolling Constraints (GPBDRC), works in three main steps:\n\n1. **Constraint Enforcement**: Identify units that must remain on or off due to minimum up/down time and shutdown ramp constraints. Must-run units were previously online and either haven't met minimum up-time or their previous output exceeded the shutdown ramp limit. Must-off units were previously offline and haven't met minimum down-time.\n\n2. **Flexible Unit Commitment**: \n   - For flexible units not forced on/off, initially keep their previous state (on/off).\n   - Compute the total min/max output of must-run and flexible units that are left on.\n   - If this total minimum output exceeds the current load, turn off all flexible units and dispatch only must-run units to minimize overproduction.\n   - If the total maximum output is below the load, greedily turn on the most cost-effective offline flexible units (by average cost at minimum output including startup cost) until the load can be met or no more units are available.\n\n3. **Economic Dispatch**: \n   - For each committed unit, compute feasible output bounds considering ramp constraints and startup/shutdown limits.\n   - If the total feasible range doesn't cover the load, set outputs to the bound nearest the load.\n   - Otherwise, perform greedy incremental dispatch: start at the minimum feasible output for all units, then iteratively increase the output of the unit with the lowest marginal cost (derivative of quadratic cost) until the load is met.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if -t0 < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Identify flexible units\n    flex_on = []\n    flex_off = []\n    for i in range(n_units):\n        if i in must_run or i in must_off:\n            continue\n        if units_info[i]['u_i_0'] == 1:\n            flex_on.append(i)\n        else:\n            flex_off.append(i)\n    \n    # Initialize commitment and compute current output range\n    committed_set = set(must_run)\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Helper function to compute unit bounds\n    def compute_bounds(i, is_must_run_or_flex_on):\n        unit = units_info[i]\n        if is_must_run_or_flex_on:  # Was online in previous period\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Turned on in current period\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        return low, high\n    \n    # Initial bounds for must_run and flex_on\n    for i in must_run:\n        low, high = compute_bounds(i, True)\n        total_min += low\n        total_max += high\n    for i in flex_on:\n        low, high = compute_bounds(i, True)\n        total_min += low\n        total_max += high\n    \n    # Adjust flexible commitment if overcommitted\n    if total_min > current_load:\n        # Only use must_run and turn off flex_on\n        committed_set = set(must_run)\n        total_min, total_max = 0.0, 0.0\n        for i in must_run:\n            low, high = compute_bounds(i, True)\n            total_min += low\n            total_max += high\n    elif total_max < current_load:\n        # Sort flex_off by average cost at p_min_i\n        candidates = []\n        for i in flex_off:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2) + unit['s_i']\n            avg_cost = cost / unit['p_min_i']\n            candidates.append((avg_cost, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        # Turn on candidates until load can be met\n        for _, i in candidates:\n            if total_max >= current_load:\n                break\n            committed_set.add(i)\n            low, high = compute_bounds(i, False)\n            total_min += low\n            total_max += high\n    \n    # Set u_i for all units\n    u_vector = [1 if i in committed_set else 0 for i in range(n_units)]\n    \n    # Dispatch: assign output p_i for committed units\n    p_vector = [0.0] * n_units\n    low_bounds = []\n    high_bounds = []\n    b_list = []\n    c_list = []\n    indices = []  # Committed indices\n    \n    for i in committed_set:\n        if units_info[i]['u_i_0'] == 1 or i in flex_on or i in must_run:\n            low, high = compute_bounds(i, True)\n        else:\n            low, high = compute_bounds(i, False)\n        low_bounds.append(low)\n        high_bounds.append(high)\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n        indices.append(i)\n    \n    total_low = sum(low_bounds)\n    total_high = sum(high_bounds)\n    \n    if len(indices) > 0:\n        if total_high < current_load:\n            # Set all to max\n            for idx, i in enumerate(indices):\n                p_vector[i] = high_bounds[idx]\n        elif total_low > current_load:\n            # Set all to min\n            for idx, i in enumerate(indices):\n                p_vector[i] = low_bounds[idx]\n        else:\n            # Greedy incremental dispatch\n            current_p = low_bounds.copy()\n            R = current_load - total_low\n            available = [high_bounds[j] - current_p[j] for j in range(len(indices))]\n            indexes = list(range(len(indices)))\n            \n            while R > 0 and indexes:\n                # Find unit with min marginal cost\n                min_marg = float('inf')\n                chosen = -1\n                for j in indexes:\n                    if available[j] > 0:\n                        marg = b_list[j] + 2 * c_list[j] * current_p[j]\n                        if marg < min_marg:\n                            min_marg = marg\n                            chosen = j\n                if chosen == -1:\n                    break\n                \n                # Increase chosen unit\n                delta = min(available[chosen], R)\n                current_p[chosen] += delta\n                available[chosen] -= delta\n                R -= delta\n                if available[chosen] <= 0:\n                    indexes.remove(chosen)\n            \n            for idx, i in enumerate(indices):\n                p_vector[i] = current_p[idx]\n    \n    schedules = np.array([u_vector, p_vector])\n    return schedules",
          "objective": 0.00807,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic first identifies must-run and must-off units based on current state, minimum up/down times, and shutdown capacity constraints. Flexible units (neither must-run nor must-off) are prioritized by average cost per MW at minimum output. Additional units are committed from the flexible list if needed to meet load capacity requirements. For dispatch, the algorithm calculates feasible output ranges considering ramp limits and startup/shutdown constraints. If total minimum output exceeds load, outputs are clamped to minimums. If load exceeds total maximum, outputs are clamped to maximums. Otherwise, units are dispatched to meet the exact load via merit order based on incremental cost at their feasible minimum output, ensuring ramp and capacity constraints are satisfied.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    flexible = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                flexible.append(idx)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                continue\n            else:\n                flexible.append(idx)\n    \n    committed = must_run.copy()\n    \n    min_capacity = 0.0\n    max_capacity = 0.0\n    \n    for idx in must_run:\n        if units_info[idx]['u_i_0'] == 1:\n            LB = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            UB = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n        else:\n            LB = units_info[idx]['p_min_i']\n            UB = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n        min_capacity += LB\n        max_capacity += UB\n    \n    if max_capacity < current_load:\n        priority = []\n        for idx in flexible:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 0:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            else:\n                total_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            avg_cost = total_cost / unit['p_min_i']\n            priority.append((avg_cost, idx))\n        priority.sort(key=lambda x: x[0])\n        \n        for _, idx in priority:\n            if max_capacity >= current_load:\n                break\n            unit = units_info[idx]\n            if unit['u_i_0'] == 0:\n                additional_UB = min(unit['p_max_i'], unit['p_start_i'])\n                additional_LB = unit['p_min_i']\n            else:\n                additional_UB = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                additional_LB = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_capacity += additional_UB\n            min_capacity += additional_LB\n            committed.append(idx)\n    \n    target = current_load\n    if min_capacity > current_load:\n        target = min_capacity\n    elif max_capacity < current_load:\n        target = max_capacity\n    \n    LBs = np.zeros(n_units)\n    UBs = np.zeros(n_units)\n    inc_costs = []\n    indices = []\n    \n    for idx in committed:\n        u[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            LB_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            UB_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            LB_i = unit['p_min_i']\n            UB_i = min(unit['p_max_i'], unit['p_start_i'])\n        LBs[idx] = LB_i\n        UBs[idx] = UB_i\n        inc_cost = 2 * unit['c_i'] * LB_i + unit['b_i']\n        inc_costs.append((inc_cost, idx))\n    \n    if inc_costs:\n        inc_costs.sort(key=lambda x: x[0])\n        sorted_indices = [idx for _, idx in inc_costs]\n    else:\n        sorted_indices = []\n    \n    p = LBs.copy()\n    remaining = target - np.sum(LBs)\n    \n    for idx in sorted_indices:\n        if remaining <= 0:\n            break\n        available = UBs[idx] - LBs[idx]\n        if available > 0:\n            allocate = min(remaining, available)\n            p[idx] += allocate\n            remaining -= allocate\n    \n    for idx in range(n_units):\n        if idx not in committed:\n            u[idx] = 0\n            p[idx] = 0.0\n    \n    schedules = np.array([u, p])\n    return schedules",
          "objective": 0.00821,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic is a two-phase approach: Commitment and Economic Dispatch. \n\n1. **Commitment Phase**:\n   - Identify must-run units (online and insufficient min-up time, or prior output exceeds shutdown ramp limit) and must-off units (offline and insufficient min-down time).\n   - Turn on must-run units.\n   - For remaining units, if the current must-run capacity is insufficient for the load, turn on additional units sorted by average cost per MW at minimum output (including startup cost if turning on).\n   - Ensure next period's forecasted load can be met by adjusting unit commitments if needed.\n\n2. **Economic Dispatch Phase**:\n   - For online units, compute output bounds based on ramp constraints: \n     - Previously online: bound by ramp up/down from prior output.\n     - Newly online: bound by startup ramp and minimum output.\n   - Allocate load using merit-order dispatch: \n     - Set all online units to their lower bound.\n     - Distribute remaining load in ascending order of incremental cost (derivative of cost function at current output), respecting upper bounds.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    current_load = load[0]\n    next_load = load[1]\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    current_min = 0.0\n    current_max = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        current_min += min_output\n        current_max += max_output\n    \n    candidates = []\n    for i in flexible:\n        if i not in must_off:\n            unit = units_info[i]\n            min_output = unit['p_min_i']\n            max_output = unit['p_max_i']\n            if unit['u_i_0'] == 0:\n                max_output = min(max_output, unit['p_start_i'])\n                cost_per_MW = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2) / min_output\n            else:\n                min_output = max(min_output, unit['p_i_0'] - unit['p_down_i'])\n                max_output = min(max_output, unit['p_i_0'] + unit['p_up_i'])\n                cost_per_MW = (unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2) / min_output\n            candidates.append((i, cost_per_MW, min_output, max_output))\n    \n    candidates.sort(key=lambda x: x[1])\n    \n    for idx, *_, min_o, max_o in candidates:\n        if current_max < current_load or current_max < next_load:\n            u[idx] = 1\n            current_min += min_o\n            current_max += max_o\n        else:\n            u[idx] = 0\n    \n    online_indices = [i for i in range(n_units) if u[i] == 1]\n    lower_bounds = {}\n    upper_bounds = {}\n    total_min = 0.0\n    for i in online_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lower_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            upper_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lower_bound = unit['p_min_i']\n            upper_bound = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds[i] = lower_bound\n        upper_bounds[i] = upper_bound\n        total_min += lower_bound\n        p[i] = lower_bound\n    \n    residual = current_load - total_min\n    if residual > 0:\n        increments = []\n        for i in online_indices:\n            cost_derivative = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n            avail = upper_bounds[i] - p[i]\n            increments.append((cost_derivative, i, avail))\n        increments.sort(key=lambda x: x[0])\n        \n        for inc_cost, i, avail in increments:\n            if residual <= 0:\n                break\n            to_add = min(residual, avail)\n            p[i] += to_add\n            residual -= to_add\n    \n    return np.array([u, p])",
          "objective": 0.01021,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic employs a three-stage approach to schedule units for the current load demand while adhering to physical constraints. First, it identifies units forced on (must remain on due to minimum up-time or shutdown ramp violations) and forced off (must remain off due to minimum down-time). Second, it adjusts the initial on-set of forced-on and free units previously on to meet the load: if minimum generation exceeds load, it turns off eligible free units starting with the highest minimum output; if maximum generation falls short, it turns on eligible free units starting with the lowest average cost per MW at minimum output. Third, it performs economic dispatch: sets outputs to lower bounds initially, then allocates remaining load to units with the smallest incremental cost at their current output, respecting upper bounds. Units not in the final on-set are off with zero output.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    forced_on = []\n    forced_off = []\n    free_on = []\n    free_off = []\n    on_set = set()\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on.append(idx)\n                on_set.add(idx)\n            else:\n                free_on.append(idx)\n                on_set.add(idx)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    lbs = {}\n    ubs = {}\n    min_power = 0\n    max_power = 0\n    \n    for idx in on_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lbs[idx] = lb\n        ubs[idx] = ub\n        min_power += lb\n        max_power += ub\n    \n    if min_power > current_load:\n        candidate_off = sorted(free_on, key=lambda i: lbs[i], reverse=True)\n        for idx in candidate_off:\n            if min_power <= current_load:\n                break\n            on_set.remove(idx)\n            free_on.remove(idx)\n            min_power -= lbs[idx]\n            max_power -= ubs[idx]\n    \n    if current_load > max_power:\n        candidate_on = []\n        for idx in free_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * (p_min ** 2) + unit['s_i']\n            avg_cost = cost / p_min\n            candidate_on.append((idx, avg_cost))\n        candidate_on.sort(key=lambda x: x[1])\n        \n        for idx, _ in candidate_on:\n            if current_load <= max_power:\n                break\n            unit = units_info[idx]\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            lbs[idx] = lb_val\n            ubs[idx] = ub_val\n            on_set.add(idx)\n            min_power += lb_val\n            max_power += ub_val\n    \n    p_alloc = {}\n    if current_load <= min_power:\n        for idx in on_set:\n            p_alloc[idx] = lbs[idx]\n    elif current_load >= max_power:\n        for idx in on_set:\n            p_alloc[idx] = ubs[idx]\n    else:\n        for idx in on_set:\n            p_alloc[idx] = lbs[idx]\n        remaining = current_load - min_power\n        units_to_inc = [idx for idx in on_set if p_alloc[idx] < ubs[idx]]\n        units_to_inc.sort(key=lambda idx: units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_alloc[idx])\n        \n        while remaining > 0 and units_to_inc:\n            idx = units_to_inc[0]\n            inc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_alloc[idx]\n            max_inc = min(remaining, ubs[idx] - p_alloc[idx])\n            p_alloc[idx] += max_inc\n            remaining -= max_inc\n            if p_alloc[idx] >= ubs[idx]:\n                units_to_inc.pop(0)\n            else:\n                inc_new = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_alloc[idx]\n                if inc_new > inc and len(units_to_inc) > 1:\n                    del units_to_inc[0]\n                    for i, idj in enumerate(units_to_inc[1:], 1):\n                        if inc_new <= (units_info[idj]['b_i'] + 2 * units_info[idj]['c_i'] * p_alloc[idj]):\n                            units_to_inc.insert(i, idx)\n                            break\n                    else:\n                        units_to_inc.append(idx)\n    \n    u_list = [0] * n_units\n    p_list = [0] * n_units\n    for idx in on_set:\n        u_list[idx] = 1\n        p_list[idx] = p_alloc.get(idx, 0)\n    \n    return np.array([u_list, p_list])",
          "objective": 0.01739,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm for the Rolling Unit Commitment problem is designed to schedule units at each time step while considering physical constraints and minimizing costs. The main steps are:\n1. **Precompute constraints**: Determine which units are forced to remain on (due to minimum up-time or previous output exceeding shutdown capacity) or forced off (due to minimum down-time).\n2. **Initial commitment**: Initialize the commitment status for all units, setting must-run units to on and locked-off units to off. Non-forced units are tentatively set to their previous state.\n3. **Capacity adjustment**:\n   - If the current load exceeds the maximum capacity of the committed units, start additional non-forced off units sorted by increasing cost per MW at minimum output (including startup cost) until the load can be met.\n   - If the current load is below the minimum capacity of the committed units, turn off non-forced on units sorted by decreasing cost per MW at minimum output (excluding startup cost) while ensuring the remaining units can meet the load.\n4. **Economic dispatch**: For the final committed set, solve the economic dispatch using a lambda iteration method to minimize production costs, respecting ramp constraints and output limits. The method adjusts the marginal cost (lambda) to match the total generation with the load while adhering to unit-specific constraints.\n5. **Output assignment**: Assign the computed generation levels to committed units and set non-committed units to off with zero output.\n\nThe algorithm ensures constraints (minimum up/down times, ramp limits, and output bounds) are satisfied while meeting the load as closely as possible and minimizing total costs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u = [0] * n\n    p = [0.0] * n\n    \n    # Precompute forced states\n    must_stay_on = []\n    locked_off = []\n    for i, unit in enumerate(units_info):\n        must_stay_on_i = unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n        locked_off_i = unit['u_i_0'] == 0 and unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']\n        must_stay_on.append(must_stay_on_i)\n        locked_off.append(locked_off_i)\n        if must_stay_on_i:\n            u[i] = 1\n        if locked_off_i:\n            u[i] = 0\n    \n    # Identify non-forced units\n    non_forced_on = []\n    non_forced_off = []\n    for i, unit in enumerate(units_info):\n        if must_stay_on[i] or locked_off[i]:\n            continue\n        if unit['u_i_0'] == 1:\n            non_forced_on.append(i)\n        else:\n            non_forced_off.append(i)\n    \n    # Set initial non-forced units to their previous state\n    for i in non_forced_on:\n        u[i] = 1\n    for i in non_forced_off:\n        u[i] = 0\n    \n    # Compute initial min and max power for committed units\n    total_min = 0.0\n    total_max = 0.0\n    low_bounds = [0.0] * n\n    high_bounds = [0.0] * n\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_bounds[i] = unit['p_min_i']\n                high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low_bounds[i]\n            total_max += high_bounds[i]\n    \n    # Adjust commitment if load is not met\n    if current_load > total_max:\n        # Start additional units\n        cost_list = []\n        for i in non_forced_off:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2) + unit['s_i']) / unit['p_min_i']\n            cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0])\n        \n        for cost_val, i in cost_list:\n            if total_max >= current_load:\n                break\n            if u[i] == 0:\n                u[i] = 1\n                unit = units_info[i]\n                low_bounds[i] = unit['p_min_i']\n                high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n                total_min += low_bounds[i]\n                total_max += high_bounds[i]\n    \n    if current_load < total_min:\n        # Turn off expensive units\n        cost_list = []\n        for i in non_forced_on:\n            if u[i] == 1:\n                unit = units_info[i]\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n                cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost_val, i in cost_list:\n            if u[i] == 1:\n                if total_max - high_bounds[i] >= current_load:\n                    u[i] = 0\n                    total_min -= low_bounds[i]\n                    total_max -= high_bounds[i]\n                    if total_min <= current_load:\n                        break\n    \n    # Perform economic dispatch for committed units\n    committed_indices = [i for i in range(n) if u[i] == 1]\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bounds[i] = unit['p_min_i']\n            high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lambda = float('inf')\n    high_lambda = float('-inf')\n    for i in committed_indices:\n        unit = units_info[i]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * low_bounds[i]\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * high_bounds[i]\n        if cost_min < low_lambda:\n            low_lambda = cost_min\n        if cost_max > high_lambda:\n            high_lambda = cost_max\n    \n    low_lambda = max(0, low_lambda - 1)\n    high_lambda = high_lambda + 1\n    \n    tol = 0.01\n    iter_count = 0\n    p_vals = [0.0] * n\n    for _ in range(1000):\n        iter_count += 1\n        mid_lambda = (low_lambda + high_lambda) / 2.0\n        total_power = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] > 0:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = (mid_lambda - unit['b_i']) / 1e-5\n            p_val = max(low_bounds[i], min(high_bounds[i], p_val))\n            p_vals[i] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n    \n    for i in committed_indices:\n        p[i] = p_vals[i]\n    \n    for i in range(n):\n        if u[i] == 0:\n            p[i] = 0.0\n    \n    return np.array([u, p])",
          "objective": 0.01809,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe algorithm is a priority-based heuristic that enforces must-run constraints due to minimum uptime, downtime, and ramp limitations. The steps are:\n1. **Identify must-run and must-off units:**\n   - Units that were online and haven't met minimum uptime must stay on.\n   - Units whose previous output exceeds ramp-down or shutdown capacity must stay on.\n   - Units offline that haven't met minimum downtime must stay off.\n\n2. **Sort eligible units by cost efficiency:**\n   - Free units (not must-run or must-off) are sorted by cost per MW at minimum output.\n\n3. **Commit units:**\n   - Start with must-run units set to minimum feasible output.\n   - Add free units in sorted order until maximum capacity meets the load.\n\n4. **Dispatch load:**\n   - Set committed units to minimum feasible output considering ramp limits.\n   - If under-generating, increase output of units with lowest incremental cost, respecting headroom.\n   - Over-generation is left as-is due to minimum output constraints.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']\n                or unit['p_i_0'] > unit['p_down_i']\n                or unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n        elif unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n    \n    free_units = [i for i in range(n_units) if i not in must_on and i not in must_off]\n    priorities = []\n    \n    for i in free_units:\n        unit = units_info[i]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n        else:\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n        if min_p > 0:\n            priority = cost / min_p\n        else:\n            priority = float('inf')\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    sorted_free_units = [i for _, i in priorities]\n    \n    committed = must_on.copy()\n    for i in must_on:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_i[i] = p_min\n        u_i[i] = 1\n    \n    total_min = sum(p_i)\n    total_output = total_min\n    current_load = load[0]\n    \n    total_max = total_min\n    for i in must_on:\n        unit = units_info[i]\n        ramp_up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max += ramp_up_bound - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n    \n    free_committed = []\n    if total_min < current_load and total_max < current_load:\n        for i in sorted_free_units:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            u_i[i] = 1\n            p_i[i] = min_p\n            total_output += min_p\n            total_min += min_p\n            total_max += max_p - min_p\n            committed.append(i)\n            free_committed.append(i)\n            if total_max >= current_load:\n                break\n    \n    if total_output < current_load:\n        deficit = current_load - total_output\n        inc_costs = []\n        headrooms = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_p = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            headroom = max_p - p_i[i]\n            headrooms.append(headroom)\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_i[i]\n            inc_costs.append(inc_cost)\n        \n        indices = list(range(len(committed)))\n        indices.sort(key=lambda j: inc_costs[j])\n        \n        for j in indices:\n            if deficit <= 0:\n                break\n            idx = committed[j]\n            h = headrooms[j]\n            if h <= 0:\n                continue\n            to_add = min(deficit, h)\n            p_i[idx] += to_add\n            deficit -= to_add\n    \n    schedules = np.array([u_i, p_i], dtype=float)\n    return schedules",
          "objective": 0.01841,
          "other_inf": null
     }
]