{
     "algorithm": "The new algorithm, \"Load-Adjusted Cost per MW with Ramp-Stress Factor\", modifies the priority calculation and forecast impact adjustments. Key changes include:\n\n1. For online units, base priority is computed as marginal cost per MW of ramp headroom (feasible_max - feasible_min), promoting cost-efficiency and flexibility.\n2. For offline units, base priority uses total cost per MW (amortized fixed cost plus marginal cost) over ramp headroom.\n3. Forecast factors are adjusted with new constants (0.6/0.4 for ramp-up, -0.5/-0.3 for ramp-down) to strengthen forecast responsiveness.\n4. Decommitment conditions are refined to balance cost savings against ramp capability preservation, using a 40% ramp-up threshold.\n\nSteps:\n1. Classify units into must-run, must-off, and free.\n2. Commit must-run units and compute feasible operating ranges.\n3. Calculate base priorities using new cost per MW formulas.\n4. Adjust priorities using forecasted load differences.\n5. Commit free units with look-ahead feasibility checks.\n6. Decommit high-cost units while preserving ramp flexibility.\n7. Perform ramp-constrained economic dispatch.\n8. Adjust residuals based on marginal costs and ramp headroom.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    load_diff = next_load - current_load\n    available_ramp_up = 0\n    available_ramp_down = 0\n    \n    for idx in range(n_units):\n        if units_info[idx]['u_i_0'] == 1:\n            available_ramp_up += units_info[idx]['p_up_i']\n            available_ramp_down += units_info[idx]['p_down_i']\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            ramp_headroom = feasible_max - feasible_min\n            marginal_cost_min = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            base_priority = marginal_cost_min / max(ramp_headroom, 1e-6)\n        else:\n            min_p = unit['p_min_i']\n            feasible_max = min(unit['p_max_i'], unit['p_start_i'])\n            ramp_headroom = feasible_max - min_p\n            T = max(1, unit['t_on_min_i'])\n            amortized_fixed_cost = (unit['s_i'] + T * unit['a_i']) / (T * min_p)\n            variable_cost_per_MW = unit['b_i'] + unit['c_i'] * min_p\n            total_cost_per_MW = amortized_fixed_cost + variable_cost_per_MW\n            base_priority = total_cost_per_MW / max(ramp_headroom, 1e-6)\n        \n        forecast_factor = 0\n        if abs(load_diff) > 1e-6:\n            norm_diff = load_diff / max(current_load, 1.0)\n            if load_diff > 0:\n                if unit['u_i_0'] == 1:\n                    forecast_factor = min(0.6, norm_diff * unit['p_up_i'] / max(available_ramp_up, 1e-6))\n                else:\n                    forecast_factor = min(0.4, norm_diff * unit['p_start_i'] / max(available_ramp_up + unit['p_start_i'], 1e-6))\n            else:\n                if unit['u_i_0'] == 1:\n                    forecast_factor = max(-0.5, norm_diff * unit['p_down_i'] / max(available_ramp_down, 1e-6))\n                else:\n                    forecast_factor = max(-0.3, norm_diff * 0.1)\n        priority = base_priority * (1 - forecast_factor)\n        priorities.append((priority, idx))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    for _, idx in priorities:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        \n        future_ok = True\n        if load_diff > 0:\n            future_ok = (current_load + total_min - lb_val + ub_val + (unit['p_up_i'] if unit['u_i_0']==0 else 0) >= next_load)\n        elif load_diff < 0:\n            future_ok = (current_load + total_min - lb_val <= next_load)\n        \n        if total_max < current_load and future_ok:\n            committed.add(idx)\n            LB[idx] = lb_val\n            UB[idx] = ub_val\n            total_min += lb_val\n            total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    if free_committed:\n        removal_candidates = [(p, i) for p, i in priorities if i in free_committed]\n        removal_candidates.sort(reverse=True)\n        \n        for _, idx in removal_candidates:\n            unit = units_info[idx]\n            new_min = total_min - LB[idx]\n            new_max = total_max - UB[idx]\n            \n            remove_ok = (new_min <= current_load and new_max >= current_load)\n            if load_diff > 0 and unit['p_up_i'] > 0.4 * available_ramp_up:\n                remove_ok = False\n            \n            if remove_ok:\n                committed.remove(idx)\n                total_min = new_min\n                total_max = new_max\n    \n    if len(committed) == 0:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    lam_low = float('inf')\n    lam_high = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * LB[idx]\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * UB[idx]\n        lam_low = min(lam_low, cost_min)\n        lam_high = max(lam_high, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if abs(unit['c_i']) < 1e-6:\n                p_val = UB[idx] if lam > unit['b_i'] else LB[idx]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(LB[idx], min(UB[idx], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if abs(residual) > 1e-6:\n        adjustment_list = []\n        for idx in committed:\n            unit = units_info[idx]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_proj[idx]\n            if residual > 0:\n                headroom = UB[idx] - p_proj[idx]\n                if headroom > 0:\n                    adjustment_list.append((marginal_cost, headroom, idx, 1))\n            else:\n                headroom = p_proj[idx] - LB[idx]\n                if headroom > 0:\n                    adjustment_list.append((marginal_cost, headroom, idx, -1))\n        \n        if residual > 0:\n            adjustment_list.sort(key=lambda x: x[0])\n        else:\n            adjustment_list.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, headroom, idx, direction in adjustment_list:\n            if abs(residual) < 1e-6:\n                break\n            delta = min(abs(residual), headroom)\n            if direction == 1:\n                p_proj[idx] += delta\n                residual -= delta\n            else:\n                p_proj[idx] -= delta\n                residual += delta\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
     "objective": 0.00359,
     "other_inf": null
}