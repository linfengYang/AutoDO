{
     "algorithm": "**\nThe revised algorithm maintains the core structure of unit commitment and economic dispatch but simplifies the priority calculation for free units by removing ramp ratio weighting. Units are classified as must-run, must-off, or free based on their initial state and constraints. Must-run units are committed first, considering their ramp limits. Free units are then prioritized: online units by marginal cost at their feasible minimum output, and offline units by amortized cost per MW at minimum power (factoring in startup costs over the minimum uptime). After committing free units in ascending priority order until total max capacity meets the load, an optional de-commitment step removes the highest-priority free units if minimum generation exceeds the load and removal doesn't violate feasibility. If units remain committed, economic dispatch via binary search allocates power based on marginal cost within ramp limits, followed by residual load adjustment using headroom capacities sorted by marginal cost.\n\n**",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n        else:\n            min_p = unit['p_min_i']\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            priority = amort_cost / min_p\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    tol = 0.1\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < tol:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
     "objective": 0.005,
     "other_inf": null
}