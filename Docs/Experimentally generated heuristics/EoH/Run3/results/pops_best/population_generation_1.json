{
     "algorithm": "The new algorithm uses a priority-based commitment with ramp-adjusted costs and a look-ahead dispatch. Key steps: 1) Identify must-run/must-off units; 2) For free units, calculate ramp-flexible priorities combining operating costs and startup costs scaled by ramp capabilities; 3) Build committed set by adding units in priority order until meeting load; 4) Remove overcommitted units using reverse-priority order; 5) Perform unconstrained dispatch ignoring ramp limits; 6) Clamp outputs to feasible ramp bounds; 7) Adjust residual load incrementally while respecting ramp limits.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    # Identify must-run, must-off, and free units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Start with must-run units committed\n    committed = set(must_run)\n    LB = [0] * n_units\n    UB = [0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate initial bounds for must-run units\n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    # Calculate ramp-flexible priorities for free units\n    priorities = []\n    for idx in free_units:\n        unit = units_info[idx]\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Currently online\n            feasible_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            cost = unit['b_i'] + 2 * unit['c_i'] * feasible_min\n            ramp_ratio = unit['p_down_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = cost * (1.0 - 0.1 * ramp_ratio)\n        else:  # Currently offline\n            T = max(1, unit['t_on_min_i'])\n            amort_cost = (unit['s_i'] + T * (unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2)) / T\n            ramp_ratio = unit['p_up_i'] / (unit['p_max_i'] - unit['p_min_i'])\n            priority = (amort_cost / min_p) * (1.0 - 0.1 * ramp_ratio)\n        priorities.append((priority, idx))\n    priorities.sort(key=lambda x: x[0])\n    \n    # Build commitment set\n    for priority, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_val = unit['p_min_i']\n            ub_val = min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(idx)\n        LB[idx] = lb_val\n        UB[idx] = ub_val\n        total_min += lb_val\n        total_max += ub_val\n    \n    # Remove overcommitted units\n    free_committed = [idx for idx in committed if idx not in must_run]\n    free_prio = [(p, i) for p, i in priorities if i in free_committed]\n    free_prio.sort(key=lambda x: x[0], reverse=True)\n    \n    i = 0\n    while i < len(free_prio) and total_min > current_load:\n        _, idx = free_prio[i]\n        new_min = total_min - LB[idx]\n        new_max = total_max - UB[idx]\n        if new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n        i += 1\n    \n    # Skip dispatch if no committed units\n    if len(committed) == 0:\n        u = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u, p_out])\n    \n    # Unconstrained economic dispatch ignoring ramp limits\n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Project to ramp-constrained bounds\n    p_proj = [0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    # Adjust residual load\n    total_proj = sum(p_proj)\n    residual = current_load - total_proj\n    \n    # Distribute residual load\n    if residual > 0:\n        up_list = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                up_list.append((inc_cost, idx, headroom))\n        up_list.sort(key=lambda x: x[0])\n        for _, idx, headroom in up_list:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        down_list = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                down_list.append((inc_cost, idx, headroom))\n        down_list.sort(key=lambda x: x[0], reverse=True)\n        for _, idx, headroom in down_list:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    # Prepare output\n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
     "objective": 0.00514,
     "other_inf": null
}