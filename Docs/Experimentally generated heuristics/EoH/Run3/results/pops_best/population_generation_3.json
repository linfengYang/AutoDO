{
     "algorithm": "This algorithm uses a dynamic priority-based commitment that recalculates priorities at each step based on the current generation gap. The steps include: (1) Classify units into must-run, must-off, and free categories based on current state and constraints. (2) Commit must-run units and compute capacity bounds. (3) For free units, compute a dynamic cost per MW that considers the unit's contribution to filling the current generation gap while respecting minimum generation constraints. Units with insufficient minimum generation to contribute meaningfully are skipped. (4) Commit the lowest priority unit that can contribute to the gap and update system capacity. (5) Remove overcommitted units by reverse cost priority while ensuring the system meets demand. (6) Perform economic dispatch using marginal cost bisection, clamp outputs to ramp constraints, and adjust residual load.\n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_units = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                free_units.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    committed = set(must_run)\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    total_min = 0.0\n    total_max = 0.0\n    \n    for idx in must_run:\n        unit = units_info[idx]\n        LB[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        UB[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += LB[idx]\n        total_max += UB[idx]\n    \n    remaining_free = free_units.copy()\n    while remaining_free and total_max < current_load:\n        gap = current_load - total_max\n        best_priority = float('inf')\n        best_unit = None\n        best_lb = None\n        best_ub = None\n        \n        for idx in remaining_free:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_val = unit['p_min_i']\n                ub_val = min(unit['p_max_i'], unit['p_start_i'])\n            \n            if lb_val > gap:\n                continue\n                \n            if unit['u_i_0'] == 1:\n                total_cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            else:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n            cost_per_MW = total_cost / lb_val\n            \n            if cost_per_MW < best_priority:\n                best_priority = cost_per_MW\n                best_unit = idx\n                best_lb = lb_val\n                best_ub = ub_val\n        \n        if best_unit is None:\n            break\n        \n        committed.add(best_unit)\n        remaining_free.remove(best_unit)\n        LB[best_unit] = best_lb\n        UB[best_unit] = best_ub\n        total_min += best_lb\n        total_max += best_ub\n    \n    free_committed = list(committed - set(must_run))\n    removal_candidates = []\n    for idx in free_committed:\n        unit = units_info[idx]\n        lb_val = LB[idx]\n        if unit['u_i_0'] == 1:\n            total_cost = unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        else:\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * lb_val + unit['c_i'] * lb_val**2\n        cost_per_MW = total_cost / lb_val\n        removal_candidates.append((cost_per_MW, idx))\n    \n    removal_candidates.sort(key=lambda x: x[0], reverse=True)\n    for cost_per_MW, idx in removal_candidates:\n        if total_max - UB[idx] >= current_load:\n            committed.remove(idx)\n            total_min -= LB[idx]\n            total_max -= UB[idx]\n    \n    if not committed:\n        u_out = [0] * n_units\n        p_out = [0.0] * n_units\n        return np.array([u_out, p_out])\n    \n    low_lam = float('inf')\n    high_lam = float('-inf')\n    for idx in committed:\n        unit = units_info[idx]\n        cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        cost_max = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        low_lam = min(low_lam, cost_min)\n        high_lam = max(high_lam, cost_max)\n    \n    p_ideal = [0.0] * n_units\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2.0\n        total_power = 0.0\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 1e-6:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = unit['p_max_i'] if mid_lam >= unit['b_i'] else unit['p_min_i']\n            p_val = max(unit['p_min_i'], min(unit['p_max_i'], p_val))\n            p_ideal[idx] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < 0.1:\n            break\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    p_proj = [0.0] * n_units\n    for idx in committed:\n        p_proj[idx] = max(LB[idx], min(UB[idx], p_ideal[idx]))\n    \n    residual = current_load - sum(p_proj)\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed:\n            headroom = UB[idx] - p_proj[idx]\n            if headroom > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, idx, headroom in candidates:\n            add = min(residual, headroom)\n            p_proj[idx] += add\n            residual -= add\n            if residual <= 0:\n                break\n    elif residual < 0:\n        candidates = []\n        for idx in committed:\n            headroom = p_proj[idx] - LB[idx]\n            if headroom > 0:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_proj[idx]\n                candidates.append((marginal_cost, idx, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, idx, headroom in candidates:\n            reduce = min(-residual, headroom)\n            p_proj[idx] -= reduce\n            residual += reduce\n            if residual >= 0:\n                break\n    \n    u_out = [1 if idx in committed else 0 for idx in range(n_units)]\n    return np.array([u_out, p_proj])",
     "objective": 0.00441,
     "other_inf": null
}