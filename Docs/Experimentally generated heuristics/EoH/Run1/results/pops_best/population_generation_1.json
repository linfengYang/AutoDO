{
     "algorithm": "** \nThe algorithm uses a priority list method combined with a local search technique. It starts by categorizing units into forced-on, forced-off, and free units based on their physical limitations. Free units are prioritized by their average production cost at their midpoint output. The initial commitment greedily adds free units in priority order until the load can be met. An economic dispatch using lambda iteration allocates power optimally among committed units while respecting ramp and output limits. A local search then refines the solution by considering: decommitting expensive free units, adding uncommitted cheap units, or swapping expensive units for cheaper uncommitted ones. Each candidate solution undergoes feasibility checks, economic dispatch, and cost evaluation to ensure improvements while meeting all constraints.\n\n**",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
     "objective": 0.00607,
     "other_inf": null
}