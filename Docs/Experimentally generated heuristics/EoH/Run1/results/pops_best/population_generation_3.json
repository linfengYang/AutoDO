{
     "algorithm": "This algorithm modifies the priority score calculation to use average power instead of minimal power and incorporates a ramp impact factor. Key steps:  \n1. Classify forced-on units (if online and violating min-up time or shutdown capacity) and forced-off units (if offline and violating min-down time).  \n2. For non-forced units, compute priority score using cost per MW at average power (midpoint of min/max limits) and scale by ramp impact factor (1 + max ramp divided by operating range).  \n3. Build initial commitment with forced-on units, then add free units by ascending priority score until load can be met.  \n4. Remove least-efficient free units (highest scores) if feasible.  \n5. Allocate load among committed units via lambda iteration within ramp bounds.  \n6. Distribute any residual mismatch using ramp headroom proportions.  \n\n",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        avg_power = (unit['p_min_i'] + unit['p_max_i']) / 2\n        if unit['u_i_0'] == 0:\n            base_cost = unit['a_i'] + unit['b_i']*avg_power + unit['c_i']*avg_power**2 + unit['s_i']\n        else:\n            base_cost = unit['a_i'] + unit['b_i']*avg_power + unit['c_i']*avg_power**2\n        cost_per_mw = base_cost / avg_power\n        max_ramp = max(unit['p_up_i'], unit['p_down_i'])\n        operating_range = unit['p_max_i'] - unit['p_min_i'] + 1e-5\n        ramp_factor = 1.0 + max_ramp / operating_range\n        priority_scores[i] = cost_per_mw * ramp_factor\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n    for i in free_in_commit_sorted:\n        candidate = [j for j in committed if j != i]\n        c_min, c_max = power_bounds(candidate)\n        if c_min <= current_load <= c_max:\n            committed = candidate\n            total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        flex_adj = {}\n        total_flex = 0\n        for i in committed:\n            unit = units_info[i]\n            headroom = (p_list[i] - lb_dict[i], ub_dict[i] - p_list[i])\n            flex = (headroom[1] if diff > 0 else headroom[0]) + 1e-5\n            flex_adj[i] = flex\n            total_flex += flex\n        \n        for i in committed:\n            if flex_adj[i] > 1e-5:\n                adj_amount = diff * flex_adj[i] / total_flex\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj_amount))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
     "objective": 0.00578,
     "other_inf": null
}