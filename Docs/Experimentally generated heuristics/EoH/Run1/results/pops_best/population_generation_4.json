{
     "algorithm": "**  \nThe new algorithm modifies the priority score to incorporate forecasted load trends, using minimum output for cost calculation and directional ramp flexibility. Steps:  \n1. Identify forced-on/off units based on min up/down times and shutdown limits.  \n2. For free units, compute priority score:  \n   - Cost at `p_min_i` (minimum output) plus startup cost if offline.  \n   - Ramp term adapts to forecast: favors ramp-up if load increasing, ramp-down if decreasing, or sum if stable.  \n   - Score = total_cost / max(ramp_term, 1e-5)  \n3. Sort free units by ascending priority score.  \n4. Commit forced-on units, then add free units in score order until load can be met.  \n5. Refine: Remove worst-scored free units if load can still be met.  \n6. Dispatch with lambda iteration for optimal allocation within ramp bounds.  \n7. Adjust non-bound units proportionally for exact load matching.  \n\n**",
     "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    delta_load = next_load - current_load\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        p_ref = unit['p_min_i']\n        total_cost = unit['a_i'] + unit['b_i'] * p_ref + unit['c_i'] * p_ref**2\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n            \n        if delta_load > 0:\n            ramp_term = 2 * unit['p_up_i'] + unit['p_down_i']\n        elif delta_load < 0:\n            ramp_term = unit['p_up_i'] + 2 * unit['p_down_i']\n        else:\n            ramp_term = unit['p_up_i'] + unit['p_down_i']\n        if ramp_term < 1e-5:\n            ramp_term = 1e-5\n        priority_scores[i] = total_cost / ramp_term\n    \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n        for i in free_in_commit_sorted:\n            candidate = [j for j in committed if j != i]\n            c_min, c_max = power_bounds(candidate)\n            if c_min <= current_load <= c_max:\n                committed = candidate\n                total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound = [i for i in committed if lb_dict[i] < p_list[i] < ub_dict[i]]\n        if non_bound:\n            adj = diff / len(non_bound)\n            for i in non_bound:\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
     "objective": 0.00565,
     "other_inf": null
}