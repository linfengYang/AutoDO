[
     {
          "algorithm": "** \nThe algorithm uses a priority list method combined with a local search technique. It starts by categorizing units into forced-on, forced-off, and free units based on their physical limitations. Free units are prioritized by their average production cost at their midpoint output. The initial commitment greedily adds free units in priority order until the load can be met. An economic dispatch using lambda iteration allocates power optimally among committed units while respecting ramp and output limits. A local search then refines the solution by considering: decommitting expensive free units, adding uncommitted cheap units, or swapping expensive units for cheaper uncommitted ones. Each candidate solution undergoes feasibility checks, economic dispatch, and cost evaluation to ensure improvements while meeting all constraints.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00607,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a two-stage approach: priority-based initial commitment followed by a tabu search refinement. The key steps are:\n1. Compute forced-on and forced-off units based on physical constraints\n2. Form initial commitment: \n   - Start with forced-on units \n   - Add free units sorted by average cost (lowest first) until load can be met\n   - Perform economic dispatch using lambda iteration\n3. Refine solution via tabu search:\n   - Maintain tabu list to prevent cycling\n   - Generate moves: add, remove, or swap free units\n   - Evaluate moves: skip infeasible/tabu moves (except aspiration)\n   - Track best solution during iterations\n   - Terminate after set iterations without improvement\n4. Return best solution found\n\n",
          "code": "import numpy as np\nfrom collections import deque\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Determine forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    # Helper for power bounds\n    def compute_power_bounds(committed):\n        total_min, total_max = 0, 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    # Economic dispatch via lambda iteration\n    def economic_dispatch(committed):\n        if not committed: \n            return [0]*n_units, 0\n            \n        lb_vec, ub_vec = {}, {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        low_lam, high_lam = -10000, 10000\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        # Adjust for any load mismatch\n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, total_output\n    \n    # Cost calculation\n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n    \n    # Initialize\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    # Add free units by priority\n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    # Initial economic dispatch\n    dispatch, _ = economic_dispatch(committed)\n    best_cost = compute_total_cost(committed, dispatch)\n    best_committed = committed[:]\n    best_dispatch = dispatch[:]\n    current_committed = committed[:]\n    current_dispatch = dispatch[:]\n    current_cost = best_cost\n    \n    # Tabu search setup\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    tabu_list = deque(maxlen=5)\n    non_improve = 0\n    \n    # Tabu search main loop\n    while non_improve < 10:\n        candidates = []  # (move_type, unit1, unit2, committed, cost)\n        \n        # Generate drop candidates\n        for i in free_committed:\n            move = {'type': 'drop', 'unit': i}\n            new_committed = [u for u in current_committed if u != i]\n            total_min, total_max = compute_power_bounds(new_committed)\n            if total_min <= current_load <= total_max:\n                new_dispatch, _ = economic_dispatch(new_committed)\n                cost = compute_total_cost(new_committed, new_dispatch)\n                candidates.append((move, i, None, new_committed, new_dispatch, cost))\n        \n        # Generate add candidates\n        for j in uncommitted_free:\n            move = {'type': 'add', 'unit': j}\n            new_committed = current_committed + [j]\n            total_min, total_max = compute_power_bounds(new_committed)\n            if total_min <= current_load <= total_max:\n                new_dispatch, _ = economic_dispatch(new_committed)\n                cost = compute_total_cost(new_committed, new_dispatch)\n                candidates.append((move, j, None, new_committed, new_dispatch, cost))\n        \n        # Generate swap candidates\n        for i in free_committed:\n            for j in uncommitted_free:\n                move = {'type': 'swap', 'units': (i,j)}\n                new_committed = [u for u in current_committed if u != i] + [j]\n                total_min, total_max = compute_power_bounds(new_committed)\n                if total_min <= current_load <= total_max:\n                    new_dispatch, _ = economic_dispatch(new_committed)\n                    cost = compute_total_cost(new_committed, new_dispatch)\n                    candidates.append((move, i, j, new_committed, new_dispatch, cost))\n        \n        # Sort by cost and select best non-tabu candidate\n        candidates.sort(key=lambda x: x[5])\n        for cand in candidates:\n            move, u1, u2, new_comm, new_disp, new_cost = cand\n            tabu_flag = False\n            \n            # Tabu check based on reverse move\n            if move['type'] == 'drop':\n                rev_move = {'type': 'add', 'unit': u1}\n                tabu_flag = rev_move in tabu_list\n            elif move['type'] == 'add':\n                rev_move = {'type': 'drop', 'unit': u1}\n                tabu_flag = rev_move in tabu_list\n            else:  # swap\n                rev_move = {'type': 'swap', 'units': (u2, u1)}\n                tabu_flag = rev_move in tabu_list\n            \n            # Aspiration criterion\n            if not tabu_flag or new_cost < best_cost:\n                tabu_list.append(rev_move)  # Add reverse move to tabu list\n                current_committed = new_comm\n                current_dispatch = new_disp\n                current_cost = new_cost\n                non_improve = 0 if new_cost < best_cost else non_improve + 1\n                \n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_committed = new_comm[:]\n                    best_dispatch = new_disp[:]\n                break\n        else:\n            non_improve += 1\n    \n    # Prepare final solution\n    u_list = [1 if i in best_committed else 0 for i in range(n_units)]\n    return np.array([u_list, best_dispatch])",
          "objective": 0.00624,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm employs a two-stage decision-making approach combining look-ahead startup cost amortization with incremental power adjustment. Key steps:\n1. Identify forced-on/off units based on current states and physical constraints\n2. Precompute individual unit power bounds (min_out, max_out) considering ramp limits\n3. Calculate priority scores balancing current operating cost and next-period flexibility: \n   - Adjust startup cost based on next-period load forecast demand\n   - Compute operational flexibility as ramp range over total capacity range\n   - Combine adjusted costs per MW with flexibility factors\n4. Build initial commitment starting with forced-on units\n5. Add free units by ascending score until capacity >= load\n6. Remove redundant free units (worst-score first) while meeting load\n7. Perform ramp-constrained economic dispatch via lambda iteration\n8. Ensure exact load matching through proportional adjustment\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    # 1. Identify forced units\n    forced_on = []\n    forced_off = []\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            min_out[i] = unit['p_min_i']\n            max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # 2. Compute total max capacity for forced-on units\n    total_max_forced_on = sum(max_out[i] for i in forced_on)\n    \n    # 3. Calculate priority scores\n    scores = {}\n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    \n    for i in free_units:\n        unit = units_info[i]\n        # Startup cost amortization\n        if unit['u_i_0'] == 0 and next_load > total_max_forced_on:\n            adj_s = 0.5 * unit['s_i']\n        elif unit['u_i_0'] == 0:\n            adj_s = unit['s_i']\n        else:\n            adj_s = 0\n            \n        # Current cost at min output\n        min_cost = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i] ** 2 + adj_s\n        cost_per_mw = min_cost / min_out[i] if min_out[i] > 0 else float('inf')\n        \n        # Flexibility calculation\n        cap_range = unit['p_max_i'] - unit['p_min_i']\n        ramp_range = unit['p_up_i'] + unit['p_down_i']\n        flex_ratio = ramp_range / cap_range if cap_range > 0 else 0\n        flex_factor = min(1.0, flex_ratio)\n        \n        scores[i] = cost_per_mw / (flex_factor + 0.01)\n    \n    # 4-5. Build initial commitment\n    committed = forced_on.copy()\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n        else:\n            break\n    \n    # 6. Remove redundant units\n    free_in_commit = [i for i in committed if i in free_units]\n    changed = True\n    while changed and free_in_commit:\n        changed = False\n        worst_first = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in worst_first:\n            test_min = total_min - min_out[i]\n            test_max = total_max - max_out[i]\n            if test_min <= current_load <= test_max:\n                committed.remove(i)\n                total_min = test_min\n                total_max = test_max\n                free_in_commit.remove(i)\n                changed = True\n                break\n    \n    # 7. Economic dispatch\n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    p_list = [0.0] * n_units\n    \n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        lb_vec[i] = min_out[i]\n        ub_vec[i] = max_out[i]\n    \n    low_lam = -10000\n    high_lam = 10000\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    # 8. Load matching adjustment\n    total_output = sum(p_list[i] for i in committed)\n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        adjustable = [i for i in committed if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        if adjustable:\n            adj_per_unit = diff / len(adjustable)\n            for i in adjustable:\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj_per_unit))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00627,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm retains the two-stage structure but modifies the scoring function parameters for startup cost amortization and operating cost calculation. Key changes include: 1) Using a more aggressive startup cost amortization (20% when next period load exceeds forced-on capacity), 2) Calculating operational cost at midpoint power level instead of minimum output, and 3) Maintaining the original flexibility ratio weighting. Steps:\n1. Identify forced-on/off units based on current states\n2. Compute unit power bounds considering ramp limits\n3. Calculate priority scores:\n   - Apply 80% startup cost reduction when next load > forced capacity\n   - Compute operational cost at midpoint (avg of min/max)\n   - Flexibility score remains (ramp range / capacity range)\n   - Combine as cost_per_MW/(flexibility + 0.01)\n4. Commit forced-on units then add free units by ascending score\n5. Remove redundant free units worst-score first\n6. Execute ramp-constrained economic dispatch\n7. Adjust outputs proportionally for exact load matching\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    forced_on = []\n    forced_off = []\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            min_out[i] = unit['p_min_i']\n            max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    total_max_forced_on = sum(max_out[i] for i in forced_on)\n    \n    scores = {}\n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    \n    for i in free_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            if next_load > total_max_forced_on:\n                adj_s = 0.2 * unit['s_i']  \n            else:\n                adj_s = unit['s_i']\n        else:\n            adj_s = 0\n            \n        p_mid = (min_out[i] + max_out[i]) / 2.0\n        if p_mid <= 0:\n            cost_per_mw = float('inf')\n        else:\n            cost_at_mid = unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * p_mid ** 2 + adj_s\n            cost_per_mw = cost_at_mid / p_mid\n        \n        cap_range = unit['p_max_i'] - unit['p_min_i']\n        if cap_range > 0:\n            ramp_range = unit['p_up_i'] + unit['p_down_i']\n            flex_ratio = ramp_range / cap_range\n            flex_factor = min(1.0, flex_ratio)\n        else:\n            flex_factor = 0\n            \n        scores[i] = cost_per_mw / (flex_factor + 0.01)\n    \n    committed = forced_on.copy()\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n        else:\n            break\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    changed = True\n    while changed and free_in_commit:\n        changed = False\n        worst_first = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in worst_first:\n            test_min = total_min - min_out[i]\n            test_max = total_max - max_out[i]\n            if test_min <= current_load <= test_max:\n                committed.remove(i)\n                total_min = test_min\n                total_max = test_max\n                free_in_commit.remove(i)\n                changed = True\n                break\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    p_list = [0.0] * n_units\n    \n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        lb_vec[i] = min_out[i]\n        ub_vec[i] = max_out[i]\n    \n    low_lam = -10000\n    high_lam = 10000\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    total_output = sum(p_list[i] for i in committed)\n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        adjustable = [i for i in committed if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        if adjustable:\n            adj_per_unit = diff / len(adjustable)\n            for i in adjustable:\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj_per_unit))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00628,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the genetic approach by modifying key parameters and fitness evaluation. Main steps:\n1. Initialization: Create population_size solutions from current commitment state, respecting forced on/off constraints\n2. Fitness evaluation: Calculate total cost (including startup) plus penalty*load_deviation_squared\n3. Selection: Use roulette wheel selection based on fitness reciprocals\n4. Crossover: Perform one-point crossover on parent pairs\n5. Mutation: Apply state flips to flexible units with exponentially decaying rate\n6. Elitism: Preserve best solution across generations\n7. Economic dispatch: Use lambda iteration for load allocation on best solution\nKey modifications from original:\n- Increased population_size (20) and max_iter (100)\n- Squared load deviation term in fitness with penalty_factor=2000\n- Exponential mutation decay (0.5 base) instead of linear\n- Roulette wheel selection instead of tournament\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    population_size = 20\n    max_iter = 100\n    mutation_rate = 0.15\n    \n    population = []\n    for _ in range(population_size):\n        solution = []\n        for unit in units_info:\n            if unit['u_i_0'] == 1:\n                if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                    solution.append(1)\n                else:\n                    solution.append(np.random.choice([0,1]))\n            else:\n                if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                    solution.append(0)\n                else:\n                    solution.append(np.random.choice([0,1]))\n        population.append(solution)\n    \n    best_solution = None\n    best_fitness = float('inf')\n    \n    for iteration in range(max_iter):\n        fitness = []\n        for solution in population:\n            total_cost = 0\n            total_power_min = 0\n            total_power_max = 0\n            feasible = True\n            \n            for i, state in enumerate(solution):\n                unit = units_info[i]\n                if state == 1:\n                    if unit['u_i_0'] == 1:\n                        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:\n                        p_min = unit['p_min_i']\n                        p_max = min(unit['p_max_i'], unit['p_start_i'])\n                    total_power_min += p_min\n                    total_power_max += p_max\n                    \n                    if unit['u_i_0'] == 0:\n                        total_cost += unit['s_i']\n                    total_cost += unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n                else:\n                    p_min = 0\n                    p_max = 0\n            \n            load_dev = 0\n            if current_load < total_power_min:\n                load_dev = total_power_min - current_load\n            elif current_load > total_power_max:\n                load_dev = current_load - total_power_max\n            \n            fitness_val = total_cost + 2000 * (load_dev ** 2)\n            fitness.append(fitness_val)\n            \n            if fitness_val < best_fitness:\n                best_fitness = fitness_val\n                best_solution = solution.copy()\n        \n        recip_fitness = [1/(f+1e-5) for f in fitness]\n        total_recip = sum(recip_fitness)\n        probabilities = [r/total_recip for r in recip_fitness]\n        parents = []\n        for _ in range(population_size):\n            idx = np.random.choice(range(population_size), p=probabilities)\n            parents.append(population[idx])\n        \n        new_population = []\n        for i in range(0, population_size, 2):\n            parent1 = parents[i]\n            parent2 = parents[i+1]\n            child1 = parent1.copy()\n            child2 = parent2.copy()\n            \n            cross_point = np.random.randint(1, n_units)\n            child1[:cross_point] = parent2[:cross_point]\n            child2[:cross_point] = parent1[:cross_point]\n            \n            new_population.append(child1)\n            new_population.append(child2)\n        \n        decay_factor = 0.5 ** (iteration / (max_iter/2))\n        mutation_rate_iter = mutation_rate * decay_factor\n        for i in range(population_size):\n            for j in range(n_units):\n                if np.random.random() < mutation_rate_iter:\n                    unit = units_info[j]\n                    if unit['u_i_0'] == 1:\n                        if not (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n                            new_population[i][j] = 1 - new_population[i][j]\n                    else:\n                        if not (abs(unit['t_i_0']) < unit['t_off_min_i']):\n                            new_population[i][j] = 1 - new_population[i][j]\n        \n        new_population[0] = best_solution.copy()\n        population = new_population\n    \n    u_list = best_solution\n    committed_indices = [i for i, state in enumerate(u_list) if state == 1]\n    lb_vec = {}\n    ub_vec = {}\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_vec[i] = unit['p_min_i']\n            ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lambda = -10000\n    high_lambda = 10000\n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lambda > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        if abs(high_lambda - low_lambda) < 1e-6:\n            break\n    \n    final_lambda = (low_lambda + high_lambda) / 2\n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_vec[i] if final_lambda > unit['b_i'] else lb_vec[i]\n        else:\n            p_val = (final_lambda - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound_units = [i for i in committed_indices \n                          if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        num_non_bound = len(non_bound_units)\n        if num_non_bound > 0:\n            adjustment = diff / num_non_bound\n            for i in non_bound_units:\n                new_val = p_list[i] + adjustment\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], new_val))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00647,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a priority-based commitment considering efficiency and operational flexibility. The main steps are:\n\n1. **Identify forced units**: Determine units that must be on due to minimum up-time/shutdown constraints or off due to minimum down-time constraints\n\n2. **Calculate priority scores**: For free units, compute a score combining cost efficiency (based on max operating range) and flexibility (ramp capabilities), weighted by an efficiency factor\n\n3. **Form initial commitment**: Start with forced-on units, then add free units in priority order until load can be met\n\n4. **Refine commitment**: Remove redundant units starting from the least efficient free unit\n\n5. **Dispatch with lambda iteration**: Use bisection with dynamic marginal cost bounds for efficient load allocation among committed units\n\n6. **Adjust non-bound units**: Fine-tune outputs if total deviates from load using equal proportional adjustment\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        max_power = min(unit['p_max_i'], unit['p_up_i'] + (unit['p_i_0'] if unit['u_i_0']==1 else 0))\n        efficiency = (unit['a_i'] + unit['b_i']*max_power + unit['c_i']*max_power**2) / max_power\n        if unit['u_i_0'] == 0:\n            efficiency += unit['s_i'] / max_power\n        flexibility = (unit['p_up_i'] + unit['p_down_i']) / unit['p_max_i']\n        priority_scores[i] = efficiency / max(1e-5, flexibility)\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n        for i in free_in_commit_sorted:\n            candidate = [j for j in committed if j != i]\n            c_min, c_max = power_bounds(candidate)\n            if c_min <= current_load <= c_max:\n                committed = candidate\n                total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound = [i for i in committed if lb_dict[i] < p_list[i] < ub_dict[i]]\n        if non_bound:\n            adj = diff / len(non_bound)\n            for i in non_bound:\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00648,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a modified rolling unit commitment heuristic with enhanced look-ahead capabilities and ramp stability considerations. Key steps:\n1. Identify forced-on/off units based on current states and physical constraints (min uptime/downtime, shutdown capacity)\n2. Compute feasible power ranges (min_out, max_out) considering ramp limits and startup/shutdown constraints\n3. Calculate dynamic priority scores integrating:\n   - Amortized startup cost based on next-period load forecast and unit's maximum deliverable next-period output\n   - Operating cost per MW at minimum output\n   - Ramp stability factor incorporating ramp rates and relative operating point\n4. Commit forced-on units first, then free units ordered by ascending scores until capacity >= load\n5. Remove redundant free units in descending score order while maintaining load feasibility\n6. Perform lambda iteration for ramp-constrained economic dispatch\n7. Apply proportional adjustment for exact load matching using units within operating bounds\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    forced_on = []\n    forced_off = []\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            min_out[i] = unit['p_min_i']\n            max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    total_max_forced_on = sum(max_out[i] for i in forced_on)\n    \n    scores = {}\n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    \n    for i in free_units:\n        unit = units_info[i]\n        \n        if unit['u_i_0'] == 0:\n            max_next_output = min(unit['p_max_i'], unit['p_start_i'])\n            gap = max(0, next_load - total_max_forced_on)\n            if gap > 0:\n                fraction = min(1.0, max_next_output / gap)\n                adj_s = unit['s_i'] * (1 - fraction)\n            else:\n                adj_s = unit['s_i']\n        else:\n            adj_s = 0\n            \n        min_cost = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i]**2 + adj_s\n        cost_per_mw = min_cost / min_out[i] if min_out[i] > 0 else float('inf')\n        \n        cap_range = unit['p_max_i'] - unit['p_min_i']\n        ramp_range = min(unit['p_up_i'], cap_range) + min(unit['p_down_i'], cap_range)\n        if cap_range > 0:\n            ramp_stability = ramp_range / cap_range\n            avg_output = (min_out[i] + max_out[i]) / 2\n            ramp_penalty = 1 - min(0.9, abs(avg_output - unit['p_min_i']) / cap_range)\n            flex_factor = ramp_stability * ramp_penalty\n        else:\n            flex_factor = 0\n        \n        scores[i] = cost_per_mw / max(0.01, min(1.0, flex_factor))\n    \n    committed = forced_on.copy()\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n        else:\n            break\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    changed = True\n    while changed and free_in_commit:\n        changed = False\n        worst_first = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in worst_first:\n            test_min = total_min - min_out[i]\n            test_max = total_max - max_out[i]\n            if test_min <= current_load <= test_max:\n                committed.remove(i)\n                total_min = test_min\n                total_max = test_max\n                free_in_commit.remove(i)\n                changed = True\n                break\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    p_list = [0.0] * n_units\n    \n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        lb_vec[i] = min_out[i]\n        ub_vec[i] = max_out[i]\n    \n    low_lam = -10000\n    high_lam = 10000\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    total_output = sum(p_list[i] for i in committed)\n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        adjustable = [i for i in committed if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        if adjustable:\n            adj_per_unit = diff / len(adjustable)\n            for i in adjustable:\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj_per_unit))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00661,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses a dynamic priority approach with cost-efficient backtracking. In the first stage, it initializes forced commitments and prioritizes free units by marginal cost at minimum output. It ensures sufficient capacity by adding units until load coverage is met. Then, it performs backtracking to remove redundant expensive units. After an economic dispatch to allocate power, a refinement stage explores unit replacements. The refinement evaluates each potential swap between an online expensive unit and an offline cheaper unit, keeping only improvements that satisfy constraints. Finally, it returns the best found solution with minimal cost.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Determine forced on/off status\n    forced_on = []\n    forced_off = []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    # Helper function to compute power bounds\n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    # Economic dispatch using lambda iteration\n    def economic_dispatch(committed):\n        lb_dict = {}\n        ub_dict = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_dict[i] = unit['p_min_i']\n                ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        power_out = [0.0] * n_units\n        if not committed:\n            return power_out, 0.0\n        \n        lam_low, lam_high = -10000.0, 10000.0\n        for _ in range(100):\n            lam_mid = (lam_low + lam_high) / 2\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_dict[i] if lam_mid > unit['b_i'] else lb_dict[i]\n                else:\n                    p_val = (lam_mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n                total_power += p_val\n            if total_power < current_load:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n            if abs(lam_high - lam_low) < 1e-6:\n                break\n        \n        final_lam = (lam_low + lam_high) / 2\n        total_output = 0.0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if final_lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            power_out[i] = p_val\n            total_output += p_val\n        \n        deviation = current_load - total_output\n        if abs(deviation) > 1e-3:\n            flexible_units = [i for i in committed if lb_dict[i] < power_out[i] < ub_dict[i]]\n            if flexible_units:\n                adj_per_unit = deviation / len(flexible_units)\n                for i in flexible_units:\n                    power_out[i] = max(lb_dict[i], min(ub_dict[i], power_out[i] + adj_per_unit))\n        \n        return power_out, sum(power_out)\n    \n    # Total cost calculation\n    def total_cost(committed, dispatch):\n        cost = 0.0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                cost += unit['s_i']\n            cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_diff = abs(current_load - sum(dispatch))\n        return cost + 1000 * load_diff\n    \n    # Initialize commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    # Priority by marginal cost at p_min_i\n    priorities = []\n    for i in free_units:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priorities.append((marginal_cost, i))\n    priorities.sort(key=lambda x: x[0])\n    sorted_free = [idx for _, idx in priorities]\n    \n    # Add units until capacity covers load\n    min_power, max_power = compute_power_bounds(committed)\n    for idx in sorted_free:\n        if max_power < current_load:\n            committed.append(idx)\n            min_power, max_power = compute_power_bounds(committed)\n        else:\n            break\n    \n    # Backtrack: remove expensive redundant units\n    free_committed = [i for i in committed if i in free_units]\n    if free_committed:\n        priorities = []\n        for i in free_committed:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            priorities.append((marginal_cost, i))\n        priorities.sort(key=lambda x: x[0], reverse=True)\n        sorted_committed = [idx for _, idx in priorities]\n        \n        improved = True\n        while improved and sorted_committed:\n            improved = False\n            for i in sorted_committed:\n                candidate = [j for j in committed if j != i]\n                min_p, max_p = compute_power_bounds(candidate)\n                if min_p <= current_load <= max_p:\n                    committed = candidate\n                    free_committed.remove(i)\n                    sorted_committed.remove(i)\n                    improved = True\n                    break\n    \n    # Initial dispatch and cost\n    dispatch, _ = economic_dispatch(committed)\n    best_cost = total_cost(committed, dispatch)\n    best_commit = committed.copy()\n    best_dispatch = dispatch.copy()\n    \n    # Refinement: unit swaps\n    online_free = [i for i in committed if i in free_units]\n    offline_free = [i for i in free_units if i not in committed]\n    \n    for out_unit in online_free:\n        for in_unit in offline_free:\n            candidate_committed = [j for j in committed if j != out_unit]\n            candidate_committed.append(in_unit)\n            min_p, max_p = compute_power_bounds(candidate_committed)\n            if min_p <= current_load <= max_p:\n                candidate_dispatch, _ = economic_dispatch(candidate_committed)\n                candidate_cost = total_cost(candidate_committed, candidate_dispatch)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_commit = candidate_committed\n                    best_dispatch = candidate_dispatch\n    \n    # Prepare output\n    u_list = [1 if i in best_commit else 0 for i in range(n_units)]\n    return np.array([u_list, best_dispatch])",
          "objective": 0.00663,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm enhances generalization by improving the priority order for unit commitment. Key steps:\n1. Precompute forced on/off status based on initial conditions\n2. Initial commitment: \n   - Commit forced-on units\n   - Sort free units by cost efficiency: (startup_cost + fixed_cost + variable_cost at midpoint) / midpoint power\n   - Add units until total maximum power meets or exceeds load\n3. Perform economic dispatch via lambda iteration\n4. Conduct local search by evaluating candidate solutions:\n   - Remove free committed units\n   - Add free uncommitted units\n   - Swap free committed and uncommitted units\n5. Select the solution with minimum total cost\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            if mid > 0:\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2\n                avg_cost = total_cost / mid\n            else:\n                avg_cost = float('inf')\n            avg_costs.append(avg_cost)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00675,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm employs a three-phase approach: feasibility assessment, prioritized commitment, and a unique load shift adjustment. First, units are categorized as forced-on, forced-off, or flexible based on operational constraints. Second, flexible units are prioritized using a novel efficiency index (production cost per MW at maximum output divided by ramp-up capability). Third, an initial commitment is built by adding flexible units in efficiency order until load coverage is achieved. After economic dispatch via lambda iteration, a refinement phase selectively shifts load between units that offer the highest marginal cost reduction while maintaining ramp constraints, rather than recomputing full dispatch for all possible swaps.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Phase 1: Identify forced and flexible units\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Initialize commitment states\n    u_list = [1 if i in forced_on else 0 for i in range(n_units)]\n    for i in forced_off:\n        u_list[i] = 0\n    \n    # Flexible units (neither forced on nor off)\n    flexible = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    \n    # Phase 2: Prioritize flexible units by efficiency index\n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else unit['p_max_i']\n        base_cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost_per_mw = (base_cost + startup_cost) / p_max\n        efficiency_index = cost_per_mw / unit['p_up_i']\n        priorities.append((efficiency_index, i))\n    priorities.sort(key=lambda x: x[0])\n    \n    # Initial commitment with coverage check\n    committed = forced_on.copy()\n    total_min = sum(max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i']) for i in committed)\n    total_max = sum(min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i']) for i in committed)\n    \n    for _, idx in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        if total_min + p_min <= current_load:\n            committed.append(idx)\n            u_list[idx] = 1\n            total_min += p_min\n            total_max += p_max\n    \n    # Phase 3: Economic dispatch\n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_vec[i] = unit['p_min_i']\n            ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Lambda iteration dispatch\n    low_lam, high_lam = -10000, 10000\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            total_power += p_val\n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    final_lam = (low_lam + high_lam) / 2\n    p_list = [0] * n_units\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n        else:\n            p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n        p_list[i] = p_val\n    \n    # Phase 4: Load shift adjustment\n    output_dev = current_load - sum(p_list[i] for i in committed)\n    if abs(output_dev) > 1e-3:\n        non_bound = []\n        for i in committed:\n            if lb_vec[i] < p_list[i] < ub_vec[i]:\n                non_bound.append(i)\n        \n        if non_bound:\n            # Calculate cost sensitivities for non-bound units\n            cost_reductions = []\n            for i in non_bound:\n                unit = units_info[i]\n                cost_slope = unit['b_i'] + 2*unit['c_i']*p_list[i]\n                cost_reductions.append((cost_slope, i))\n            cost_reductions.sort(key=lambda x: x[0])\n            \n            # Shift load to units with negative sensitivity (cost reducers)\n            shift_targets = [idx for _, idx in cost_reductions if cost_reductions[0][0] < 0]\n            if shift_targets:\n                adj_per_unit = output_dev / len(shift_targets)\n                for i in shift_targets:\n                    proposed = p_list[i] + adj_per_unit\n                    if lb_vec[i] <= proposed <= ub_vec[i]:\n                        p_list[i] = proposed\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00682,
          "other_inf": null
     }
]