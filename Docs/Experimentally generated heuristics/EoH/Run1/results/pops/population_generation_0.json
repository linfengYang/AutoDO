[
     {
          "algorithm": "**\nThe heuristic algorithm for the Rolling Unit Commitment Problem involves a priority list-based method to determine unit commitments and dispatches for the current time step. The main steps are:\n\n1. **Identify Forced Units**: For each unit, determine if it must be online (forced_on) due to minimum up-time constraints or shutdown capacity violations (previous output > shutdown capacity), or offline (forced_off) due to minimum down-time constraints.\n\n2. **Calculate Min/Max Outputs**: Compute possible output ranges for each unit considering ramp limits and startup/shutdown constraints. For units previously online, apply ramp-down and ramp-up limits. For potential startups, apply startup output limits.\n\n3. **Form Initial Commit Set**: Start with forced-on units. Calculate the total min and max possible output from these units.\n\n4. **Load Matching**:\n   - If the current load is within the min and max range of forced-on units, no additional units are committed.\n   - If the load exceeds the max output, add available units (not forced) from a priority list sorted by average cost per MW (including startup cost if applicable) until the total max output meets or exceeds the load.\n   - If the load is below the min output, the total output is set to the minimum.\n\n5. **Dispatch Committed Units**: Perform economic dispatch for committed units to meet the required total output while respecting individual unit constraints, using incremental cost merit-order dispatch.\n\n6. **Output Schedule**: Generate a 2D array with commitment states and dispatched outputs for all units.\n\n**",
          "code": "import numpy as np\n\ndef economic_dispatch(min_outputs, max_outputs, b_list, c_list, P_total):\n    n = len(min_outputs)\n    p = min_outputs.copy()\n    remaining = P_total - sum(p)\n    active_indices = [i for i in range(n) if p[i] < max_outputs[i]]\n    \n    while remaining > 1e-5 and active_indices:\n        min_ic = float('inf')\n        candidate_idx = None\n        \n        for idx in active_indices:\n            ic = b_list[idx] + 2 * c_list[idx] * p[idx]\n            if ic < min_ic:\n                min_ic = ic\n                candidate_idx = idx\n        \n        max_adjust = max_outputs[candidate_idx] - p[candidate_idx]\n        adjust = min(remaining, max_adjust)\n        p[candidate_idx] += adjust\n        remaining -= adjust\n        \n        if p[candidate_idx] >= max_outputs[candidate_idx]:\n            active_indices.remove(candidate_idx)\n            \n    return p\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    p_shut_i = [unit['p_shut_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    current_load = load[0]\n    \n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_output_i = [0] * n_units\n    max_output_i = [0] * n_units\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            forced_on[i] = (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i])\n            min_output_i[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n            max_output_i[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n        else:\n            forced_off[i] = (t_i_0[i] < 0) and (abs(t_i_0[i]) < t_off_min_i[i])\n            min_output_i[i] = p_min_i[i]\n            max_output_i[i] = min(p_max_i[i], p_start_i[i])\n    \n    forced_on_units = [i for i in range(n_units) if forced_on[i]]\n    forced_off_units = [i for i in range(n_units) if forced_off[i]]\n    available_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    total_min_forced = sum(min_output_i[i] for i in forced_on_units)\n    total_max_forced = sum(max_output_i[i] for i in forced_on_units)\n    committed_set = set(forced_on_units)\n    P_total = current_load\n    \n    if current_load > total_max_forced:\n        def priority(i):\n            if u_i_0[i] == 1:\n                fixed_cost = a_i[i]\n            else:\n                fixed_cost = s_i[i] + a_i[i]\n            total_cost = fixed_cost + b_i[i] * min_output_i[i] + c_i[i] * min_output_i[i] ** 2\n            return total_cost / min_output_i[i]\n        \n        sorted_available = sorted(available_units, key=priority)\n        current_min = total_min_forced\n        current_max = total_max_forced\n        added_set = []\n        \n        for i in sorted_available:\n            added_set.append(i)\n            current_min += min_output_i[i]\n            current_max += max_output_i[i]\n            if current_max >= current_load:\n                break\n                \n        committed_set = committed_set.union(added_set)\n        \n        if current_min <= current_load <= current_max:\n            P_total = current_load\n        elif current_load < current_min:\n            P_total = current_min\n        else:\n            P_total = current_max\n    elif current_load < total_min_forced:\n        P_total = total_min_forced\n        \n    min_outputs_committed = []\n    max_outputs_committed = []\n    b_committed = []\n    c_committed = []\n    idx_committed = list(committed_set)\n    \n    for i in idx_committed:\n        min_outputs_committed.append(min_output_i[i])\n        max_outputs_committed.append(max_output_i[i])\n        b_committed.append(b_i[i])\n        c_committed.append(c_i[i])\n        \n    if min_outputs_committed:\n        p_dispatch = economic_dispatch(min_outputs_committed, max_outputs_committed, b_committed, c_committed, P_total)\n    else:\n        p_dispatch = []\n        \n    u_sol = []\n    p_sol = []\n    for i in range(n_units):\n        if i in committed_set:\n            u_sol.append(1)\n            pos = idx_committed.index(i)\n            p_sol.append(p_dispatch[pos])\n        else:\n            u_sol.append(0)\n            p_sol.append(0.0)\n            \n    schedules = np.array([u_sol, p_sol])\n    return schedules",
          "objective": 0.00821,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic prioritizes units that must remain on due to minimum up-time or shutdown capacity constraints and units that must stay off due to minimum down-time. For flexible units, it sorts them by average cost per MW at minimum output (including startup costs) and commits them in order until the load can be met within ramp and output limits. Economic dispatch then allocates power to committed units by initially setting them to their minimum output and incrementally increasing the output of units with the lowest marginal cost until the target load is met or constraints are reached. The target load is clamped to stay within the total minimum and maximum possible generation limits.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n\n    must_on = []\n    must_off = []\n    flexible = []\n\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n                u[idx] = 1\n            else:\n                flexible.append(idx)\n        else:\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n                u[idx] = 0\n            else:\n                flexible.append(idx)\n\n    min_fixed = 0\n    max_fixed = 0\n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        min_fixed += min_output\n        max_fixed += max_output\n\n    current_load = load[0]\n    started_flex = []\n    min_so_far = min_fixed\n    max_so_far = max_fixed\n\n    if current_load > max_fixed:\n        def cost_per_MW(unit):\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            s = unit['s_i']\n            p_min = unit['p_min_i']\n            total_cost = a + s + b * p_min + c * (p_min ** 2)\n            return total_cost / p_min if p_min > 0 else float('inf')\n\n        flex_sorted = sorted(\n            [(idx, units_info[idx]) for idx in flexible],\n            key=lambda x: cost_per_MW(x[1])\n        )\n\n        for idx, unit in flex_sorted:\n            p_min = unit['p_min_i']\n            if min_so_far + p_min > current_load:\n                continue\n            started_flex.append(idx)\n            min_so_far += p_min\n            max_so_far += min(unit['p_max_i'], unit['p_start_i'])\n            u[idx] = 1\n            if max_so_far >= current_load:\n                break\n\n    target_power = min(max(current_load, min_so_far), max_so_far)\n    committed = must_on + started_flex\n    bounds = {}\n\n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[idx] = (lb, ub)\n        p[idx] = lb\n\n    total_allocated = sum(p)\n    remaining = target_power - total_allocated\n    active_units = [idx for idx in committed if p[idx] < bounds[idx][1]]\n\n    while remaining > 0 and active_units:\n        candidate = None\n        min_mc = float('inf')\n        for idx in active_units:\n            unit = units_info[idx]\n            mc = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n            if mc < min_mc:\n                min_mc = mc\n                candidate = idx\n\n        if candidate is None:\n            break\n\n        unit_candidate = units_info[candidate]\n        max_add = bounds[candidate][1] - p[candidate]\n        add = min(remaining, max_add)\n        p[candidate] += add\n        remaining -= add\n\n        if p[candidate] >= bounds[candidate][1]:\n            active_units.remove(candidate)\n\n    return np.array([u, p])",
          "objective": 0.00843,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic is a two-stage approach: unit commitment followed by economic dispatch. \n1. **Identify must-commit and must-off units:**\n   - Units must be committed if they were previously online and haven't satisfied minimum uptime or exceeded shutdown capacity.\n   - Units must remain off if they were offline and haven't satisfied minimum downtime.\n2. **Select additional units:**\n   - Free units (not must-commit/off) are sorted by startup-adjusted cost per MW at minimum output.\n   - Commit units in this order until total maximum capacity meets the current load.\n3. **Dispatch the load:**\n   - Compute feasible operating bounds for each committed unit considering ramp rates, startup/shutdown limits, and min/max capacities.\n   - Start all units at their minimum output.\n   - Increase outputs in order of increasing marginal cost until the load is met or all units are at maximum capacity.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    load0 = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    must_run = []\n    must_off = []\n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n    \n    total_min = 0.0\n    total_max = 0.0\n    for i in must_run:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += lb\n        total_max += ub\n\n    free_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    free_units.sort(\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n    )\n    \n    committed = must_run.copy()\n    for i in free_units:\n        if total_max >= load0:\n            break\n        u[i] = 1\n        committed.append(i)\n        lb_i = units_info[i]['p_min_i']\n        ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        total_min += lb_i\n        total_max += ub_i\n    \n    bounds = []\n    for i in committed:\n        unit = units_info[i]\n        if i in must_run:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((lb, ub))\n    \n    p_vals = [lb for lb, ub in bounds]\n    remaining = load0 - sum(p_vals)\n    if remaining < 0:\n        pass\n    else:\n        available = list(range(len(committed)))\n        while remaining > 1e-5 and available:\n            mc_list = []\n            for idx in available:\n                unit_id = committed[idx]\n                mc_val = units_info[unit_id]['b_i'] + 2 * units_info[unit_id]['c_i'] * p_vals[idx]\n                mc_list.append(mc_val)\n            min_mc = min(mc_list)\n            idx_to_update = available[mc_list.index(min_mc)]\n            headroom = bounds[idx_to_update][1] - p_vals[idx_to_update]\n            delta = min(headroom, remaining)\n            p_vals[idx_to_update] += delta\n            remaining -= delta\n            if p_vals[idx_to_update] >= bounds[idx_to_update][1] - 1e-5:\n                available.remove(idx_to_update)\n    \n    for idx, unit_id in enumerate(committed):\n        p[unit_id] = p_vals[idx]\n    \n    schedules = np.array([u, p], dtype=object)\n    return schedules",
          "objective": 0.00848,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic combines unit classification, greedy commitment adjustment, and economic dispatch. \n\n1. **Classify Units:** Identify must-on, must-off, and free units. Must-on units are those that must remain on due to minimum up-time constraints or shutdown capacity limits. Must-off units are those that must stay off due to minimum down-time constraints. Free units can be committed or decommitted. \n\n2. **Initialize Free Units:** Set free units to their previous commitment state. Compute min/max power limits for must-on units and free units that are initially committed.\n\n3. **Adjust Commitment for Load Balance:**\n   - **Overgeneration (load < total_min):** Sort free-on units by cost per MW at minimum output (descending). Turn off expensive units until total_min \u2264 load or no units left.\n   - **Undergeneration (load > total_max):** Sort free-off units by cost per MW at minimum output including startup cost (ascending). Turn on cheapest units until total_max \u2265 load or no units left.\n\n4. **Economic Dispatch:** Distribute remaining load among committed units:\n   - Start at minimum power for each committed unit.\n   - Repeatedly allocate remaining load to the unit with the lowest marginal cost until load is met or all units reach maximum.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    load_current = load[0]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1 and (t_i0 < t_on_min or p_i0 > p_shut):\n            must_on.append(unit)\n        elif u_i0 == 0 and (-t_i0) < t_off_min:\n            must_off.append(unit)\n        else:\n            if u_i0 == 1:\n                free_on.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # Initialize commitment info for must_on and free_on\n    must_on_min = []\n    must_on_max = []\n    for unit in must_on:\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min.append(p_min)\n        must_on_max.append(p_max)\n    \n    free_on_min = []\n    free_on_max = []\n    for unit in free_on:\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        free_on_min.append(p_min)\n        free_on_max.append(p_max)\n    \n    # Calculate initial total min and max\n    total_min = sum(must_on_min) + sum(free_on_min)\n    total_max = sum(must_on_max) + sum(free_on_max)\n    \n    # Greedy adjustment for free units\n    free_on_to_turn_off = []\n    free_off_to_turn_on = []\n    \n    if load_current < total_min:\n        # Overgeneration: turn off expensive free_on units\n        cost_per_mw = []\n        for i, unit in enumerate(free_on):\n            min_p = free_on_min[i]\n            cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2\n            cost_per_mw.append(cost / min_p)\n        indices = sorted(range(len(free_on)), key=lambda i: cost_per_mw[i], reverse=True)\n        \n        for idx in indices:\n            unit = free_on[idx]\n            total_min -= free_on_min[idx]\n            total_max -= free_on_max[idx]\n            free_on_to_turn_off.append(unit)\n            if total_min <= load_current:\n                break\n                \n    elif load_current > total_max:\n        # Undergeneration: turn on cheap free_off units\n        cost_per_mw = []\n        min_limits = []\n        max_limits = []\n        for unit in free_off:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2 + unit['s_i']\n            cost_per_mw.append(cost / min_p)\n            min_limits.append(min_p)\n            max_limits.append(max_p)\n        \n        indices = sorted(range(len(free_off)), key=lambda i: cost_per_mw[i])\n        \n        for i in indices:\n            total_min += min_limits[i]\n            total_max += max_limits[i]\n            free_off_to_turn_on.append(free_off[i])\n            if total_max >= load_current:\n                break\n                \n    # Build committed units list with min/max limits\n    committed_units = []\n    min_limits = []\n    max_limits = []\n    \n    for i, unit in enumerate(must_on):\n        committed_units.append(unit)\n        min_limits.append(must_on_min[i])\n        max_limits.append(must_on_max[i])\n    \n    for i, unit in enumerate(free_on):\n        if unit not in free_on_to_turn_off:\n            committed_units.append(unit)\n            min_limits.append(free_on_min[i])\n            max_limits.append(free_on_max[i])\n    \n    for unit in free_off_to_turn_on:\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        committed_units.append(unit)\n        min_limits.append(min_p)\n        max_limits.append(max_p)\n    \n    # Economic dispatch for committed units\n    n_committed = len(committed_units)\n    p_values = np.array(min_limits).copy()\n    remaining = load_current - np.sum(p_values)\n    \n    if remaining < 0:\n        remaining = 0\n    \n    while remaining > 0:\n        min_marginal_cost = float('inf')\n        candidate_index = None\n        \n        for i in range(n_committed):\n            if p_values[i] < max_limits[i]:\n                marginal_cost = committed_units[i]['b_i'] + 2 * committed_units[i]['c_i'] * p_values[i]\n                if marginal_cost < min_marginal_cost:\n                    min_marginal_cost = marginal_cost\n                    candidate_index = i\n        \n        if candidate_index is None:\n            break\n            \n        available = max_limits[candidate_index] - p_values[candidate_index]\n        allocate = min(remaining, available)\n        p_values[candidate_index] += allocate\n        remaining -= allocate\n    \n    # Create mapping for dispatch results\n    dispatch_result = {}\n    for unit, p in zip(committed_units, p_values):\n        dispatch_result[id(unit)] = p\n    \n    # Prepare output arrays\n    u_output = np.zeros(len(units_info))\n    p_output = np.zeros(len(units_info))\n    \n    for i, unit in enumerate(units_info):\n        unit_id = id(unit)\n        if unit_id in dispatch_result:\n            u_output[i] = 1\n            p_output[i] = dispatch_result[unit_id]\n        else:\n            u_output[i] = 0\n            p_output[i] = 0\n    \n    schedules = np.vstack([u_output, p_output])\n    \n    return schedules",
          "objective": 0.01739,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic approach for the rolling unit commitment problem schedules units to meet the current load demand while respecting physical constraints and minimizing costs. The main steps are:\n\n1. **Determine forced commitments**: Identify units that must be on (insufficient minimum uptime or previous output exceeds shutdown capacity) or off (insufficient minimum downtime).\n2. **Initialize commitment states**: Set units marked as forced on to 1, forced off to 0. Free units (neither forced) initially retain their previous state.\n3. **Compute feasible output ranges**: For each committed unit (forced on and initially free on units), calculate the minimum and maximum output limits considering ramp constraints.\n4. **Adjust commitment for excess generation**: If the total minimum output exceeds the load, turn off eligible free units (output drop within ramp-down limits) in descending order of their cost at minimum output to reduce over-generation.\n5. **Handle insufficient generation**: If the total maximum output is below the load, turn on eligible free off units in ascending order of their average incremental cost to meet the demand.\n6. **Economic dispatch**: Distribute the load among committed units:\n   - Start with minimum outputs.\n   - For under-generation, increase output in ascending order of marginal cost until the load is met or headroom is exhausted.\n   - For over-generation, outputs remain at minimum (excess is unavoidable).\n7. **Set schedules**: Uncommitted units are set to 0; committed units are assigned their dispatched outputs.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    forced_on = [False] * n\n    forced_off = [False] * n\n    F = []\n    O = []\n    u = [0] * n\n    min_output = [0] * n\n    max_output = [0] * n\n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n            else:\n                F.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n            else:\n                O.append(i)\n    \n    for i in range(n):\n        if forced_on[i]:\n            u[i] = 1\n        elif forced_off[i]:\n            u[i] = 0\n        else:\n            u[i] = 1 if i in F else 0\n    \n    committed_set = [i for i in range(n) if u[i] == 1]\n    \n    for i in committed_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        min_output[i] = min_i\n        max_output[i] = max_i\n    \n    total_min = sum(min_output[i] for i in committed_set)\n    total_max = sum(max_output[i] for i in committed_set)\n    \n    if total_min > current_load:\n        eligible_F = []\n        for i in F:\n            if u[i] == 1 and units_info[i]['p_i_0'] <= units_info[i]['p_down_i']:\n                eligible_F.append(i)\n        cost_list = []\n        for i in eligible_F:\n            unit = units_info[i]\n            cost_i = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            cost_list.append((i, cost_i))\n        cost_list.sort(key=lambda x: x[1], reverse=True)\n        for i, _ in cost_list:\n            if u[i] == 0: \n                continue\n            new_min = total_min - min_output[i]\n            u[i] = 0\n            committed_set.remove(i)\n            total_min = new_min\n            total_max -= max_output[i]\n    \n    if total_max < current_load:\n        aic_list = []\n        for i in O:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            startup_cost = unit['s_i']\n            cost_min = unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i**2\n            aic = (startup_cost + cost_min) / min_i\n            aic_list.append((i, aic))\n        aic_list.sort(key=lambda x: x[1])\n        for i, aic in aic_list:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            committed_set.append(i)\n            min_i = units_info[i]['p_min_i']\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n            min_output[i] = min_i\n            max_output[i] = max_i\n            total_min += min_i\n            total_max += max_i\n    \n    p = [0] * n\n    for i in committed_set:\n        p[i] = min_output[i]\n    \n    total = sum(p)\n    remaining = current_load - total\n    \n    if remaining > 0:\n        unit_list = []\n        for i in committed_set:\n            headroom = max_output[i] - p[i]\n            if headroom > 0:\n                unit = units_info[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                unit_list.append((i, marginal_cost, headroom))\n        unit_list.sort(key=lambda x: x[1])\n        for i, mc, headroom in unit_list:\n            if remaining <= 0:\n                break\n            add = min(remaining, headroom)\n            p[i] += add\n            remaining -= add\n    \n    return np.array([u, p])",
          "objective": 0.01967,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic is a priority-based approach that ensures constraints like minimum up/downtime, ramp limits, and startup/shutdown constraints are respected. It starts by identifying must-run and must-off units based on their prior states and physical constraints. Must-run units are initialized at their minimum possible output considering ramp-down limits. Flexible units (neither must-run nor must-off) inherit their prior commitment state. The remaining load is then managed in two phases:\n1. **Deficit Handling (positive remaining load):** First, increase output of committed units in order of increasing marginal cost. If the deficit persists, start new units in order of increasing average cost per MW (amortizing startup costs).\n2. **Surplus Handling (negative remaining load):** Reduce output of committed units (above minimum) in order of decreasing marginal cost to minimize overproduction.\n\nThe algorithm strictly adheres to unit constraints and does not explicitly consider look-ahead for future periods.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]  # Next period forecast ignored\n    u = [0] * n_units\n    p = [0] * n_units\n\n    # Step 1: Identify must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:  # Was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:  # t_i_0 negative for offline\n                must_off[i] = True\n\n    # Step 2: Initialize commitment and dispatch\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            # Min output considering ramp down constraint\n            p_i_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p[i] = p_i_min\n        elif must_off[i]:\n            u[i] = 0\n            p[i] = 0\n        else:  # Flexible unit\n            if unit['u_i_0'] == 1:\n                u[i] = 1\n                p_i_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p[i] = p_i_min\n            else:\n                u[i] = 0\n                p[i] = 0\n\n    total_output = sum(p)\n    remaining_load = current_load - total_output\n\n    # Step 3: Handle remaining load\n    if remaining_load >= 0:  # Deficit\n        # Increase committed units (must-run and flexible online)\n        online_indices = [i for i in range(n_units) if u[i] == 1]\n        can_increase = []\n        for i in online_indices:\n            unit = units_info[i]\n            # Max output considering ramp up constraint\n            p_i_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if p[i] < p_i_max:\n                avail = p_i_max - p[i]\n                marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                can_increase.append((marginal_cost, avail, i))\n        \n        # Increase by lowest marginal cost\n        can_increase.sort(key=lambda x: x[0])\n        for mc, avail, i in can_increase:\n            if remaining_load <= 0:\n                break\n            add = min(avail, remaining_load)\n            p[i] += add\n            remaining_load -= add\n\n        # Start new units if deficit persists\n        if remaining_load > 0:\n            candidate_units = []\n            for i, unit in enumerate(units_info):\n                if not u[i] and not must_run[i] and not must_off[i]:\n                    # Constraints for starting: min and max possible\n                    p_i_min = unit['p_min_i']\n                    p_i_max = min(unit['p_max_i'], unit['p_start_i'])\n                    # Setpoint (at least min, as much as possible within constraints)\n                    set_point = max(p_i_min, min(p_i_max, remaining_load))\n                    # Amortized cost per MW (including startup cost)\n                    total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * set_point + unit['c_i'] * set_point**2\n                    avg_cost = total_cost / set_point\n                    candidate_units.append((avg_cost, set_point, i))\n            \n            # Start by lowest cost per MW\n            candidate_units.sort(key=lambda x: x[0])\n            for ac, set_point, i in candidate_units:\n                if remaining_load <= 0:\n                    break\n                u[i] = 1\n                p[i] = set_point\n                remaining_load -= set_point\n\n    else:  # Surplus (overproduction)\n        overproduction = -remaining_load\n        online_indices = [i for i in range(n_units) if u[i] == 1]\n        can_decrease = []\n        for i in online_indices:\n            unit = units_info[i]\n            # Only reduce units above minimum output\n            if p[i] > unit['p_min_i']:\n                reduction_avail = p[i] - unit['p_min_i']\n                # Use marginal cost for prioritization (expensive units reduced first)\n                marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                can_decrease.append((-marginal_cost, reduction_avail, i))  # Negative for descending sort\n        \n        # Reduce expensive units first\n        can_decrease.sort(key=lambda x: x[0])\n        for nmc, avail, i in can_decrease:\n            if overproduction <= 0:\n                break\n            reduce_by = min(avail, overproduction)\n            p[i] -= reduce_by\n            overproduction -= reduce_by\n\n    return np.array([u, p])",
          "objective": 0.02,
          "other_inf": null
     },
     {
          "algorithm": "** \nThe heuristic algorithm for the Rolling Unit Commitment Problem operates in two main stages. In the commitment stage, units are categorized into forced on, forced off, or free based on minimum up/down time constraints and shutdown ramp limits. Free units are prioritized using a cost-efficiency metric (average cost per MW at minimum output) to build a candidate set that meets the load. If minimal production from committed units exceeds the load, the least efficient free unit is conditionally removed to minimize the gap. In the dispatch stage, feasible power bounds for each committed unit are determined considering ramp limits. The optimal total output (closest to the load within system constraints) is calculated. A lambda iteration method solves the quadratic cost minimization problem to assign exact power outputs to each committed unit while respecting individual bounds.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    forced_on = []\n    forced_off = []\n    free_units = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] > 0 and unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on.append(unit)\n            else:\n                free_units.append(unit)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free_units.append(unit)\n    \n    base_min = sum(unit['p_min_i'] for unit in forced_on)\n    base_max = sum(unit['p_max_i'] for unit in forced_on)\n    \n    for unit in free_units:\n        if unit['p_min_i'] == 0:\n            unit['avg_cost'] = 1e12\n        else:\n            startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n            cost_at_min = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2) + startup_cost\n            unit['avg_cost'] = cost_at_min / unit['p_min_i']\n    \n    free_units_sorted = sorted(free_units, key=lambda x: x['avg_cost'])\n    candidate_free = []\n    current_min = base_min\n    current_max = base_max\n    for unit in free_units_sorted:\n        candidate_free.append(unit)\n        current_min += unit['p_min_i']\n        current_max += unit['p_max_i']\n        if current_max >= current_load:\n            break\n    \n    if current_min > current_load and candidate_free:\n        last_unit = candidate_free.pop()\n        new_min = current_min - last_unit['p_min_i']\n        new_max = current_max - last_unit['p_max_i']\n        gap_with = current_min - current_load\n        gap_without = current_load - new_max\n        if abs(gap_without) < abs(gap_with):\n            current_min, current_max = new_min, new_max\n        else:\n            candidate_free.append(last_unit)\n    \n    committed_set = forced_on + candidate_free\n    \n    LB = []\n    UB = []\n    units_list = []\n    for unit in committed_set:\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        LB.append(lb)\n        UB.append(ub)\n        units_list.append(unit)\n    \n    total_min = sum(LB)\n    total_max = sum(UB)\n    T_star = total_min if current_load < total_min else total_max if current_load > total_max else current_load\n    \n    n_units = len(units_list)\n    p_committed = np.zeros(n_units)\n    if n_units > 0:\n        min_deriv = min(unit['b_i'] + 2 * unit['c_i'] * LB[i] for i, unit in enumerate(units_list))\n        max_deriv = max(unit['b_i'] + 2 * unit['c_i'] * UB[i] for i, unit in enumerate(units_list))\n        low_lambda = min_deriv - 1.0\n        high_lambda = max_deriv + 1.0\n        tolerance = 0.01\n        max_iter = 1000\n        for _ in range(max_iter):\n            if high_lambda - low_lambda < tolerance:\n                break\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_p = 0.0\n            p_vals = []\n            for i, unit in enumerate(units_list):\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_i_val = (mid_lambda - b_i) / (2 * c_i) if c_i != 0 else LB[i] if mid_lambda < b_i else UB[i]\n                p_i_val = max(LB[i], min(UB[i], p_i_val))\n                p_vals.append(p_i_val)\n                total_p += p_i_val\n            if total_p < T_star:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        p_committed = np.array(p_vals)\n    \n    n_total = len(units_info)\n    result_u = np.zeros(n_total, dtype=int)\n    result_p = np.zeros(n_total, dtype=float)\n    for i, unit in enumerate(units_info):\n        if unit in committed_set:\n            idx = units_list.index(unit)\n            result_u[i] = 1\n            result_p[i] = p_committed[idx]\n    schedules = np.array([result_u, result_p])\n    return schedules",
          "objective": 0.02462,
          "other_inf": null
     },
     {
          "algorithm": "The heuristic algorithm efficiently schedules power generation units for the current load demand in a rolling unit commitment framework. It proceeds in several key steps: \n\n1. **Identify Must-Run Units**: Determine units forced to remain online due to minimum up-time constraints or shutdown ramp limitations (previous output > shutdown capacity).\n\n2. **Initial Commitment**: Set all must-run units and units previously online as initially committed.\n\n3. **Check Minimum and Maximum Generation**:\n   - Calculate the total minimum output (sum of lower bounds) and maximum output (sum of upper bounds) for committed units, considering ramp constraints for previously online units, and minimum/maximum constraints for newly started units.\n\n4. **Adjust Commitment Based on Load**:\n   - **Over-Commitment (load < total min)**: Turn off the most expensive non-must-run units (measured by cost per MW at minimum output) until feasible or no candidates remain.\n   - **Under-Commitment (load > total max)**: Turn on the cheapest available units (considering startup cost and cost per MW at minimum output) until generation meets demand or no candidates remain.\n\n5. **Economic Dispatch**:\n   - Initialize all committed units to their minimum feasible output.\n   - Distribute remaining load by increasing outputs of units with the lowest incremental cost (derivative of cost function) until load is met or all units reach maximum output.\n\n6. **Output**: Return commitment status and power output for all units as a 2D array.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n, dtype=int)\n    p = np.zeros(n)\n\n    must_run = [False] * n\n    can_turn_off = [False] * n\n    can_turn_on = [False] * n\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n\n        if u0 == 1:\n            if (t0 < t_on_min) or (p0 > p_shut):\n                must_run[i] = True\n        else:\n            must_run[i] = False\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_down = unit['p_down_i']\n        p_shut = unit['p_shut_i']\n\n        if must_run[i]:\n            can_turn_off[i] = False\n        elif u0 == 1:\n            if p0 <= p_down:\n                can_turn_off[i] = True\n            else:\n                can_turn_off[i] = False\n        else:\n            can_turn_off[i] = False\n\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        p_start = unit['p_start_i']\n        p_up = unit['p_up_i']\n        p_max = unit['p_max_i']\n        t_off_min = unit['t_off_min_i']\n\n        if must_run[i]:\n            can_turn_on[i] = False\n        elif u0 == 0:\n            if t0 < 0 and abs(t0) >= t_off_min:\n                if p_min <= min(p_up, p_start) and p_min <= p_max:\n                    can_turn_on[i] = True\n                else:\n                    can_turn_on[i] = False\n            else:\n                can_turn_on[i] = False\n        else:\n            can_turn_on[i] = False\n\n    committed = []\n    min_output = np.zeros(n)\n    max_output = np.zeros(n)\n    for i in range(n):\n        if must_run[i] or (units_info[i]['u_i_0'] == 1 and not must_run[i]):\n            committed.append(i)\n            if units_info[i]['u_i_0'] == 1:\n                min_output[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                min_output[i] = units_info[i]['p_min_i']\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n        else:\n            min_output[i] = 0.0\n            max_output[i] = 0.0\n\n    total_min = np.sum(min_output)\n    total_max = np.sum(max_output)\n    current_load = load[0]\n\n    if current_load < total_min:\n        candidate_list = [i for i in range(n) if i in committed and can_turn_off[i] and not must_run[i]]\n        candidate_list.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] + units_info[i]['c_i'] * min_output[i]**2) / min_output[i], \n                          reverse=True)\n        for i in candidate_list:\n            if total_min > current_load:\n                committed.remove(i)\n                total_min -= min_output[i]\n                total_max -= max_output[i]\n            else:\n                break\n\n    if current_load > total_max:\n        candidate_list = [i for i in range(n) if i not in committed and can_turn_on[i]]\n        candidate_costs = []\n        for i in candidate_list:\n            min_i = units_info[i]['p_min_i']\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n            cost_per_mw = (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*min_i + units_info[i]['c_i']*min_i**2) / min_i\n            candidate_costs.append((i, min_i, max_i, cost_per_mw))\n        candidate_costs.sort(key=lambda x: x[3])\n        for i, min_i, max_i, _ in candidate_costs:\n            if total_max < current_load:\n                committed.append(i)\n                min_output[i] = min_i\n                max_output[i] = max_i\n                total_min += min_i\n                total_max += max_i\n            else:\n                break\n\n    L_arr = []\n    U_arr = []\n    a_arr = []\n    b_arr = []\n    c_arr = []\n    committed_min = []\n    committed_index = []\n\n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            L_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            U_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            L_i = units_info[i]['p_min_i']\n            U_i = min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n        L_arr.append(L_i)\n        U_arr.append(U_i)\n        a_arr.append(units_info[i]['a_i'])\n        b_arr.append(units_info[i]['b_i'])\n        c_arr.append(units_info[i]['c_i'])\n        committed_min.append(L_i)\n        committed_index.append(i)\n\n    current_p = np.array(committed_min)\n    remaining = current_load - np.sum(committed_min)\n    sorted_indices = list(range(len(committed)))\n\n    if remaining > 1e-5:\n        while remaining > 1e-5:\n            min_incr = float('inf')\n            candidate = None\n            for idx in sorted_indices:\n                if current_p[idx] < U_arr[idx]:\n                    inc_cost = b_arr[idx] + 2 * c_arr[idx] * current_p[idx]\n                    if inc_cost < min_incr:\n                        min_incr = inc_cost\n                        candidate = idx\n            if candidate is None:\n                break\n            available = U_arr[candidate] - current_p[candidate]\n            if available >= remaining:\n                current_p[candidate] += remaining\n                remaining = 0\n            else:\n                current_p[candidate] += available\n                remaining -= available\n\n    for i in range(n):\n        if i in committed:\n            u[i] = 1\n    for idx, i in enumerate(committed_index):\n        p[i] = current_p[idx]\n    for i in range(n):\n        if u[i] == 0:\n            p[i] = 0.0\n\n    return np.array([u, p])",
          "objective": 0.02503,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic algorithm for the Rolling Unit Commitment Problem involves:\n1. **Determine Forced Units:** Identify units forced to stay on (due to minimum up-time or shutdown capacity violation) or off (due to minimum down-time).\n2. **Free Units Classification:** Separate non-forced units into currently on (free_on) and off (free_off) units.\n3. **Capacity Analysis:** Calculate initial minimum and maximum power capacity from forced and free_on units.\n4. **Case Handling:**\n   - **Case A (Load within Range):** If current load is within initial capacity, turn off expensive free_on units if possible without violating load constraints.\n   - **Case B (Overload):** If load exceeds capacity, turn on free_off units with the lowest cost per MW (startup + min power cost) until capacity meets or exceeds the load.\n   - **Case C (Underload):** If initial minimum power exceeds load, turn off expensive free_on units until the minimum power is \u2264 load.\n5. **Unit Commitment:** Commit forced units, remaining free_on units, and any turned-on free_off units.\n6. **Economic Dispatch:** Use lambda iteration (bisection) to allocate the load among committed units, considering ramp and output constraints:\n   - For units previously on, ensure power change respects ramp limits.\n   - For newly started units, ensure power \u2264 startup ramp limit.\n   - Minimize total operating cost (quadratic cost functions).\n7. **Output:** Generate a schedule with commitment states (u_i) and power outputs (p_i) for all units in input order.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n = len(units_info)\n    forced_on = [False] * n\n    forced_off = [False] * n\n    free_on = []\n    free_off = []\n    \n    for i in range(n):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n            else:\n                free_on.append(i)\n        else:\n            off_duration = abs(unit['t_i_0'])\n            if off_duration < unit['t_off_min_i']:\n                forced_off[i] = True\n            else:\n                free_off.append(i)\n    \n    total_min_initial = 0\n    total_max_initial = 0\n    for i in range(n):\n        if forced_on[i]:\n            unit = units_info[i]\n            total_min_initial += unit['p_min_i']\n            total_max_initial += unit['p_max_i']\n    for i in free_on:\n        unit = units_info[i]\n        total_min_initial += unit['p_min_i']\n        total_max_initial += unit['p_max_i']\n    \n    current_load = load[0]\n    units_to_turn_off = []\n    units_to_turn_on = []\n    \n    if total_min_initial <= current_load <= total_max_initial:\n        free_on_costs = []\n        for i in free_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            free_on_costs.append((cost, i))\n        free_on_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        new_total_min = total_min_initial\n        new_total_max = total_max_initial\n        for cost, i in free_on_costs:\n            unit = units_info[i]\n            proposed_min = new_total_min - unit['p_min_i']\n            proposed_max = new_total_max - unit['p_max_i']\n            if proposed_min <= current_load <= proposed_max:\n                units_to_turn_off.append(i)\n                new_total_min = proposed_min\n                new_total_max = proposed_max\n        free_on = [i for i in free_on if i not in units_to_turn_off]\n    \n    elif current_load > total_max_initial:\n        deficit = current_load - total_max_initial\n        free_off_costs = []\n        for i in free_off:\n            unit = units_info[i]\n            total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            cost_per_mw = total_cost / unit['p_min_i']\n            free_off_costs.append((cost_per_mw, i))\n        free_off_costs.sort(key=lambda x: x[0])\n        \n        cumulative_max = total_max_initial\n        for _, i in free_off_costs:\n            if cumulative_max >= current_load:\n                break\n            units_to_turn_on.append(i)\n            cumulative_max += units_info[i]['p_max_i']\n        free_off = [i for i in free_off if i not in units_to_turn_on]\n    \n    else:\n        free_on_costs = []\n        for i in free_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            free_on_costs.append((cost, i))\n        free_on_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        cumulative_min = total_min_initial\n        for cost, i in free_on_costs:\n            if cumulative_min <= current_load:\n                break\n            units_to_turn_off.append(i)\n            cumulative_min -= units_info[i]['p_min_i']\n        free_on = [i for i in free_on if i not in units_to_turn_off]\n    \n    committed = []\n    for i in range(n):\n        if forced_on[i]:\n            committed.append(i)\n    committed.extend(free_on)\n    committed.extend(units_to_turn_on)\n    \n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_vec[i] = unit['p_min_i']\n            ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lambda = -1e9\n    high_lambda = 1e9\n    for i in committed:\n        unit = units_info[i]\n        inc_cost_min = unit['b_i'] + 2 * unit['c_i'] * lb_vec[i]\n        inc_cost_max = unit['b_i'] + 2 * unit['c_i'] * ub_vec[i]\n        low_lambda = min(low_lambda, inc_cost_min)\n        high_lambda = max(high_lambda, inc_cost_max)\n    low_lambda -= 100\n    high_lambda += 100\n    \n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2.0\n        total_power = 0.0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                if mid_lambda > unit['b_i']:\n                    p_val = ub_vec[i]\n                else:\n                    p_val = lb_vec[i]\n            else:\n                p_uncon = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_uncon))\n            total_power += p_val\n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        if high_lambda - low_lambda < 1e-6:\n            break\n    \n    final_lambda = (low_lambda + high_lambda) / 2.0\n    dispatch = {}\n    total_p = 0.0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            if final_lambda > unit['b_i']:\n                p_val = ub_vec[i]\n            else:\n                p_val = lb_vec[i]\n        else:\n            p_val = (final_lambda - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n        dispatch[i] = p_val\n        total_p += p_val\n    \n    diff = current_load - total_p\n    adjust_units = []\n    for i in committed:\n        if dispatch[i] < ub_vec[i] and dispatch[i] > lb_vec[i]:\n            adjust_units.append(i)\n    if adjust_units and abs(diff) > 1e-3:\n        for i in adjust_units:\n            dispatch[i] += diff / len(adjust_units)\n            unit = units_info[i]\n            dispatch[i] = max(lb_vec[i], min(ub_vec[i], dispatch[i]))\n    \n    u_list = [0] * n\n    p_list = [0.0] * n\n    for i in committed:\n        u_list[i] = 1\n        p_list[i] = dispatch[i]\n    \n    return np.array([u_list, p_list])",
          "objective": 0.0285,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic algorithm, named PriorityListRamp, solves the Rolling Unit Commitment problem in a rolling scheduling framework. It follows these main steps:\n1. **Enforce Constraints**: For each unit, determine if it is forced on (must remain on due to min up-time or shutdown capacity violation), forced off (must remain off due to min down-time), or flexible (can be turned on/off).\n2. **Initialize Commitment**: The committed set starts with all forced-on units.\n3. **Set Initial Bounds**: Calculate the minimum and maximum possible output from the committed set, considering ramp constraints and min/max output limits.\n4. **Add Flexible On Units**: All flexible units currently online (u_i_0=1) are added to the committed set to leverage their existing state.\n5. **Adjust Commitment**:\n   - Remove expensive flexible on units if they are not needed (the remaining set can still meet the load) to reduce cost.\n   - If the committed set cannot meet the load, add the cheapest flexible off units (considering startup cost) to cover the deficit.\n6. **Economic Dispatch**: For the committed set:\n   - If under-committed (total max output < load), set outputs to maximum.\n   - If over-committed (total min output > load), set outputs to minimum.\n   - Otherwise, perform merit-order dispatch: start from min outputs and increase the output of the least marginal cost unit until meeting the load.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    states = [0] * n_units\n    outputs = [0.0] * n_units\n    forced_on = set()\n    forced_off = set()\n    flexible_on = []\n    flexible_off = []\n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.add(i)\n                states[i] = 1\n            else:\n                flexible_on.append(i)\n                states[i] = 1\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                forced_off.add(i)\n                states[i] = 0\n            else:\n                flexible_off.append(i)\n                states[i] = 0\n                \n    committed = set(forced_on)\n    have_min_output = 0.0\n    have_max_output = 0.0\n    low_bounds = {}\n    high_bounds = {}\n    \n    for i in committed:\n        unit = units_info[i]\n        low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        low_bounds[i] = low_b\n        high_bounds[i] = high_b\n        have_min_output += low_b\n        have_max_output += high_b\n        \n    for i in flexible_on:\n        committed.add(i)\n        unit = units_info[i]\n        low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        low_bounds[i] = low_b\n        high_bounds[i] = high_b\n        have_min_output += low_b\n        have_max_output += high_b\n        \n    def compute_cost(i, unit):\n        a, b, c, s = unit['a_i'], unit['b_i'], unit['c_i'], unit['s_i']\n        p_min = unit['p_min_i']\n        if states[i] == 1 and unit['u_i_0'] == 0:\n            return (a + b * p_min + c * p_min**2 + s) / p_min\n        return (a + b * p_min + c * p_min**2) / p_min\n\n    flexible_on_sorted = sorted(\n        flexible_on, \n        key=lambda i: compute_cost(i, units_info[i]), \n        reverse=True\n    )\n    \n    for i in flexible_on_sorted:\n        min_without = have_min_output - low_bounds[i]\n        max_without = have_max_output - high_bounds[i]\n        if min_without <= current_load <= max_without:\n            committed.remove(i)\n            states[i] = 0\n            have_min_output = min_without\n            have_max_output = max_without\n            low_bounds[i] = 0\n            high_bounds[i] = 0\n\n    if have_max_output < current_load:\n        flexible_off_sorted = sorted(\n            flexible_off, \n            key=lambda i: compute_cost(i, units_info[i])\n        )\n        for i in flexible_off_sorted:\n            if have_max_output >= current_load:\n                break\n            unit = units_info[i]\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            if have_min_output + low_i <= current_load and have_max_output + high_i >= current_load:\n                committed.add(i)\n                states[i] = 1\n                low_bounds[i] = low_i\n                high_bounds[i] = high_i\n                have_min_output += low_i\n                have_max_output += high_i\n                if have_max_output >= current_load:\n                    break\n                    \n    for i in range(n_units):\n        if i in committed:\n            outputs[i] = low_bounds[i]\n        else:\n            outputs[i] = 0.0\n            states[i] = 0\n\n    total_min = have_min_output\n    total = sum(outputs)\n    \n    if have_max_output < current_load:\n        for i in committed:\n            outputs[i] = high_bounds[i]\n    elif total_min > current_load:\n        for i in committed:\n            outputs[i] = low_bounds[i]\n    else:\n        remaining = current_load - total\n        while remaining > 1e-6:\n            min_inc = float('inf')\n            best_i = None\n            for i in committed:\n                if outputs[i] < high_bounds[i]:\n                    inc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                    if inc < min_inc:\n                        min_inc = inc\n                        best_i = i\n            if best_i is None:\n                break\n            add = min(remaining, high_bounds[best_i] - outputs[best_i])\n            outputs[best_i] += add\n            remaining -= add\n\n    schedules = np.array([states, outputs])\n    return schedules",
          "objective": 0.24084,
          "other_inf": null
     }
]