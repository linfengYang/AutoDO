[
     {
          "algorithm": "This algorithm modifies the priority score calculation to use average power instead of minimal power and incorporates a ramp impact factor. Key steps:  \n1. Classify forced-on units (if online and violating min-up time or shutdown capacity) and forced-off units (if offline and violating min-down time).  \n2. For non-forced units, compute priority score using cost per MW at average power (midpoint of min/max limits) and scale by ramp impact factor (1 + max ramp divided by operating range).  \n3. Build initial commitment with forced-on units, then add free units by ascending priority score until load can be met.  \n4. Remove least-efficient free units (highest scores) if feasible.  \n5. Allocate load among committed units via lambda iteration within ramp bounds.  \n6. Distribute any residual mismatch using ramp headroom proportions.  \n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        avg_power = (unit['p_min_i'] + unit['p_max_i']) / 2\n        if unit['u_i_0'] == 0:\n            base_cost = unit['a_i'] + unit['b_i']*avg_power + unit['c_i']*avg_power**2 + unit['s_i']\n        else:\n            base_cost = unit['a_i'] + unit['b_i']*avg_power + unit['c_i']*avg_power**2\n        cost_per_mw = base_cost / avg_power\n        max_ramp = max(unit['p_up_i'], unit['p_down_i'])\n        operating_range = unit['p_max_i'] - unit['p_min_i'] + 1e-5\n        ramp_factor = 1.0 + max_ramp / operating_range\n        priority_scores[i] = cost_per_mw * ramp_factor\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n    for i in free_in_commit_sorted:\n        candidate = [j for j in committed if j != i]\n        c_min, c_max = power_bounds(candidate)\n        if c_min <= current_load <= c_max:\n            committed = candidate\n            total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        flex_adj = {}\n        total_flex = 0\n        for i in committed:\n            unit = units_info[i]\n            headroom = (p_list[i] - lb_dict[i], ub_dict[i] - p_list[i])\n            flex = (headroom[1] if diff > 0 else headroom[0]) + 1e-5\n            flex_adj[i] = flex\n            total_flex += flex\n        \n        for i in committed:\n            if flex_adj[i] > 1e-5:\n                adj_amount = diff * flex_adj[i] / total_flex\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj_amount))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00578,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm is a modified priority-based approach incorporating dynamic cost efficiency metrics and an incremental adjustment step. Key steps are:\n1. **Classify units**: Identify forced-on units (due to min up-time or high previous output) and forced-off units (due to min down-time)\n2. **Compute priority scores**: For non-forced units, calculate a base efficiency score using cost per MW at minimal output (including startup costs for offline units) weighted by ramp flexibility\n3. **Build commitment**: Start with forced-on units. Add free units by ascending priority until load can be met considering ramp-constrained bounds\n4. **Remove redundant units**: Eliminate least-efficient free units if their removal doesn't compromise load feasibility\n5. **Economic dispatch**: Use lambda iteration with dynamic cost bounds to allocate load among committed units\n6. **Incremental adjustment**: Distribute any power mismatch among units with ramp headroom using flexibility-based weighting\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        base_power = unit['p_min_i']\n        if unit['u_i_0'] == 0:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*base_power + unit['c_i']*base_power**2 + unit['s_i']) / base_power\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*base_power + unit['c_i']*base_power**2) / base_power\n        flex_factor = (unit['p_up_i'] + unit['p_down_i']) / (unit['p_max_i'] + 1e-5)\n        priority_scores[i] = cost_per_mw / max(flex_factor, 1e-5)\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n    for i in free_in_commit_sorted:\n        candidate = [j for j in committed if j != i]\n        c_min, c_max = power_bounds(candidate)\n        if c_min <= current_load <= c_max:\n            committed = candidate\n            total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        flex_adj = {}\n        total_flex = 0\n        for i in committed:\n            unit = units_info[i]\n            headroom = (p_list[i] - lb_dict[i], ub_dict[i] - p_list[i])\n            flex = (headroom[1] if diff > 0 else headroom[0]) + 1e-5\n            flex_adj[i] = flex\n            total_flex += flex\n        \n        for i in committed:\n            if flex_adj[i] > 1e-5:\n                adj_amount = diff * flex_adj[i] / total_flex\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj_amount))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00598,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the priority score calculation to better balance cost efficiency, startup costs, and ramp capabilities. Key changes include:\n1. Using the average operating point (midpoint between p_min and p_max) for cost calculation instead of maximum output\n2. Incorporating startup costs only for offline units in the cost term\n3. Adding a ramp flexibility term in the denominator to prioritize units with higher total ramp capabilities\n4. Sorting free units by ascending priority score (lower score = better) to favor more cost-effective units first\n\nMain steps remain similar to original with priority score modification:\n1. Identify forced units based on min up/down times and shutdown constraints\n2. Calculate new priority score: (cost at midpoint power + startup cost if offline) / (ramp_up + ramp_down)\n3. Form initial commitment: forced-on units + free units (ascending priority order) until load met\n4. Refine commitment: remove least efficient free units (highest priority score) if redundant\n5. Dispatch using lambda iteration for optimal load allocation\n6. Fine-tune outputs with proportional adjustment for bound units\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        # Calculate midpoint power and ramp flexibility\n        p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2.0\n        total_cost = unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * p_mid**2\n        if unit['u_i_0'] == 0:  # Add startup cost only if unit is offline\n            total_cost += unit['s_i']\n        ramp_flexibility = unit['p_up_i'] + unit['p_down_i']\n        # Avoid division by zero for ramp flexibility\n        if ramp_flexibility < 1e-5:\n            ramp_flexibility = 1e-5\n        priority_scores[i] = total_cost / ramp_flexibility\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    # Sort free units by ascending priority score (lower score = better)\n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        # Sort free units in descending priority score for removal (remove worst first)\n        free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n        for i in free_in_commit_sorted:\n            candidate = [j for j in committed if j != i]\n            c_min, c_max = power_bounds(candidate)\n            if c_min <= current_load <= c_max:\n                committed = candidate\n                total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound = [i for i in committed if lb_dict[i] < p_list[i] < ub_dict[i]]\n        if non_bound:\n            adj = diff / len(non_bound)\n            for i in non_bound:\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00603,
          "other_inf": null
     },
     {
          "algorithm": "** \nThe algorithm uses a priority list method combined with a local search technique. It starts by categorizing units into forced-on, forced-off, and free units based on their physical limitations. Free units are prioritized by their average production cost at their midpoint output. The initial commitment greedily adds free units in priority order until the load can be met. An economic dispatch using lambda iteration allocates power optimally among committed units while respecting ramp and output limits. A local search then refines the solution by considering: decommitting expensive free units, adding uncommitted cheap units, or swapping expensive units for cheaper uncommitted ones. Each candidate solution undergoes feasibility checks, economic dispatch, and cost evaluation to ensure improvements while meeting all constraints.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm starts by identifying forced on/off units based on prior states and constraints. It commits forced-on units and calculates power bounds. Free units are sorted by average cost. Units are added until the total max output meets the load. A decommitment phase follows: expensive free units are removed if feasible without violating load constraints. Initial dispatch is performed. Local search generates candidates via single removals, additions, and swaps of free units, with cost minimized to select the best solution.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = compute_power_bounds(committed)\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n            else:\n                break\n                \n        committed_free = [i for i in committed if i in free_units]\n        if committed_free:\n            avg_costs_dict = {}\n            for idx, i in enumerate(free_units):\n                avg_costs_dict[i] = avg_costs[idx]\n            removal_candidates = [(avg_costs_dict[i], i) for i in committed_free]\n            removal_candidates.sort(key=lambda x: x[0], reverse=True)\n            for cost_val, unit_idx in removal_candidates:\n                candidate_committed = [j for j in committed if j != unit_idx]\n                total_min_candidate, total_max_candidate = compute_power_bounds(candidate_committed)\n                if total_min_candidate <= current_load <= total_max_candidate:\n                    committed = candidate_committed\n                    total_min, total_max = total_min_candidate, total_max_candidate\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00612,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the priority scoring by incorporating dynamic load change factors for startup cost adjustment, introducing a responsiveness factor based on ramp capabilities relative to the required power change, and adding a proximity penalty for units nearing min up/down time violations. Key steps:\n1. Identify forced on/off units\n2. Calculate priority scores with:\n   - Base cost at average operating point\n   - Load-change-adjusted startup cost: Factor depends on relative load difference\n   - Responsiveness factor: Ramp capability vs required change to reach optimal power\n   - Proximity penalty for units close to min up/down limits\n3. Form initial commitment with forced-on units and prioritized free units\n4. Refine commitment by removing high-cost units while ensuring feasibility\n5. Perform lambda-iteration economic dispatch with predictive bounds\n6. Apply proportional adjustment for exact load matching\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n    \n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_power = [0] * n_units\n    max_power = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        # Determine power bounds\n        if unit['u_i_0'] == 1:  # Was online\n            min_power[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_power[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            forced_on[i] = (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n        else:  # Was offline\n            min_power[i] = unit['p_min_i']\n            max_power[i] = min(unit['p_max_i'], unit['p_start_i'])\n            forced_off[i] = (abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    # Calculate enhanced priority scores\n    scores = {}\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    for i in free_units:\n        unit = units_info[i]\n        avg_power = (unit['p_min_i'] + unit['p_max_i']) / 2\n        base_cost = unit['a_i'] + unit['b_i'] * avg_power + unit['c_i'] * avg_power**2\n        \n        # Load-change-adjusted startup cost\n        if unit['u_i_0'] == 0:\n            load_ratio = (next_load - current_load) / max(current_load, 1)\n            load_factor = min(1.0, max(-1.0, 0.6 * load_ratio))\n            adj_startup = unit['s_i'] * (1 - load_factor)\n        else:\n            adj_startup = 0\n            \n        # Responsiveness factor\n        target_power = avg_power\n        if unit['u_i_0'] == 1:  # Online\n            power_delta = abs(target_power - unit['p_i_0'])\n            ramp_cap = unit['p_up_i'] if target_power > unit['p_i_0'] else unit['p_down_i']\n        else:  # Offline\n            power_delta = abs(target_power)\n            ramp_cap = unit['p_start_i']\n        responsiveness = min(1.0, ramp_cap / power_delta) if power_delta > 0 else 1.0\n        \n        # Proximity penalty\n        proximity_penalty = 1.0\n        if unit['u_i_0'] == 1 and unit['t_on_min_i'] - unit['t_i_0'] < 2:\n            proximity_penalty = 1.2\n        elif unit['u_i_0'] == 0 and unit['t_off_min_i'] - abs(unit['t_i_0']) < 2:\n            proximity_penalty = 1.2\n            \n        # Final score calculation\n        scores[i] = (base_cost + adj_startup) / (avg_power * max(0.1, responsiveness)) * proximity_penalty\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_sorted = sorted(free_units, key=lambda i: scores[i])\n    \n    total_min = sum(min_power[i] for i in committed)\n    total_max = sum(max_power[i] for i in committed)\n    \n    for i in free_sorted:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_power[i]\n            total_max += max_power[i]\n    \n    # Refinement with progressive feasibility check\n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        cost_sorted = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in cost_sorted:\n            temp_commit = [j for j in committed if j != i]\n            temp_min = total_min - min_power[i]\n            temp_max = total_max - max_power[i]\n            if temp_min <= current_load <= temp_max:\n                committed = temp_commit\n                total_min = temp_min\n                total_max = temp_max\n    \n    # Economic dispatch\n    p_list = [0.0] * n_units\n    lb_dict = {}\n    ub_dict = {}\n    for i in committed:\n        lb_dict[i] = min_power[i]\n        ub_dict[i] = max_power[i]\n    \n    # Lambda iteration setup\n    lam_low = float('inf')\n    lam_high = -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            lam_low = min(lam_low, unit['b_i'])\n            lam_high = max(lam_high, unit['b_i'])\n        else:\n            lam_low = min(lam_low, unit['b_i'] + 2*unit['c_i']*lb_dict[i])\n            lam_high = max(lam_high, unit['b_i'] + 2*unit['c_i']*ub_dict[i])\n    \n    lam_low -= 100\n    lam_high += 100\n    \n    # Bisection method\n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n        if abs(lam_high - lam_low) < 1e-6:\n            break\n    \n    # Final dispatch\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    # Proportional adjustment\n    deviation = current_load - total_output\n    if abs(deviation) > 1e-3:\n        adjustable = []\n        for i in committed:\n            unit = units_info[i]\n            theoretical_min = max(unit['p_min_i'], p_list[i] - unit['p_down_i'])\n            theoretical_max = min(unit['p_max_i'], p_list[i] + unit['p_up_i'])\n            if p_list[i] > theoretical_min and p_list[i] < theoretical_max:\n                adjustable.append(i)\n        \n        if adjustable:\n            adj_per_unit = deviation / len(adjustable)\n            for i in adjustable:\n                p_list[i] += adj_per_unit\n                p_list[i] = max(min_power[i], min(max_power[i], p_list[i]))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00615,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm uses a two-stage approach: priority-based initial commitment followed by a tabu search refinement. The key steps are:\n1. Compute forced-on and forced-off units based on physical constraints\n2. Form initial commitment: \n   - Start with forced-on units \n   - Add free units sorted by average cost (lowest first) until load can be met\n   - Perform economic dispatch using lambda iteration\n3. Refine solution via tabu search:\n   - Maintain tabu list to prevent cycling\n   - Generate moves: add, remove, or swap free units\n   - Evaluate moves: skip infeasible/tabu moves (except aspiration)\n   - Track best solution during iterations\n   - Terminate after set iterations without improvement\n4. Return best solution found\n\n",
          "code": "import numpy as np\nfrom collections import deque\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Determine forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    # Helper for power bounds\n    def compute_power_bounds(committed):\n        total_min, total_max = 0, 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    # Economic dispatch via lambda iteration\n    def economic_dispatch(committed):\n        if not committed: \n            return [0]*n_units, 0\n            \n        lb_vec, ub_vec = {}, {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        low_lam, high_lam = -10000, 10000\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        # Adjust for any load mismatch\n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, total_output\n    \n    # Cost calculation\n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n    \n    # Initialize\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    # Add free units by priority\n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    # Initial economic dispatch\n    dispatch, _ = economic_dispatch(committed)\n    best_cost = compute_total_cost(committed, dispatch)\n    best_committed = committed[:]\n    best_dispatch = dispatch[:]\n    current_committed = committed[:]\n    current_dispatch = dispatch[:]\n    current_cost = best_cost\n    \n    # Tabu search setup\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    tabu_list = deque(maxlen=5)\n    non_improve = 0\n    \n    # Tabu search main loop\n    while non_improve < 10:\n        candidates = []  # (move_type, unit1, unit2, committed, cost)\n        \n        # Generate drop candidates\n        for i in free_committed:\n            move = {'type': 'drop', 'unit': i}\n            new_committed = [u for u in current_committed if u != i]\n            total_min, total_max = compute_power_bounds(new_committed)\n            if total_min <= current_load <= total_max:\n                new_dispatch, _ = economic_dispatch(new_committed)\n                cost = compute_total_cost(new_committed, new_dispatch)\n                candidates.append((move, i, None, new_committed, new_dispatch, cost))\n        \n        # Generate add candidates\n        for j in uncommitted_free:\n            move = {'type': 'add', 'unit': j}\n            new_committed = current_committed + [j]\n            total_min, total_max = compute_power_bounds(new_committed)\n            if total_min <= current_load <= total_max:\n                new_dispatch, _ = economic_dispatch(new_committed)\n                cost = compute_total_cost(new_committed, new_dispatch)\n                candidates.append((move, j, None, new_committed, new_dispatch, cost))\n        \n        # Generate swap candidates\n        for i in free_committed:\n            for j in uncommitted_free:\n                move = {'type': 'swap', 'units': (i,j)}\n                new_committed = [u for u in current_committed if u != i] + [j]\n                total_min, total_max = compute_power_bounds(new_committed)\n                if total_min <= current_load <= total_max:\n                    new_dispatch, _ = economic_dispatch(new_committed)\n                    cost = compute_total_cost(new_committed, new_dispatch)\n                    candidates.append((move, i, j, new_committed, new_dispatch, cost))\n        \n        # Sort by cost and select best non-tabu candidate\n        candidates.sort(key=lambda x: x[5])\n        for cand in candidates:\n            move, u1, u2, new_comm, new_disp, new_cost = cand\n            tabu_flag = False\n            \n            # Tabu check based on reverse move\n            if move['type'] == 'drop':\n                rev_move = {'type': 'add', 'unit': u1}\n                tabu_flag = rev_move in tabu_list\n            elif move['type'] == 'add':\n                rev_move = {'type': 'drop', 'unit': u1}\n                tabu_flag = rev_move in tabu_list\n            else:  # swap\n                rev_move = {'type': 'swap', 'units': (u2, u1)}\n                tabu_flag = rev_move in tabu_list\n            \n            # Aspiration criterion\n            if not tabu_flag or new_cost < best_cost:\n                tabu_list.append(rev_move)  # Add reverse move to tabu list\n                current_committed = new_comm\n                current_dispatch = new_disp\n                current_cost = new_cost\n                non_improve = 0 if new_cost < best_cost else non_improve + 1\n                \n                if new_cost < best_cost:\n                    best_cost = new_cost\n                    best_committed = new_comm[:]\n                    best_dispatch = new_disp[:]\n                break\n        else:\n            non_improve += 1\n    \n    # Prepare final solution\n    u_list = [1 if i in best_committed else 0 for i in range(n_units)]\n    return np.array([u_list, best_dispatch])",
          "objective": 0.00624,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm employs a two-stage decision-making approach combining look-ahead startup cost amortization with incremental power adjustment. Key steps:\n1. Identify forced-on/off units based on current states and physical constraints\n2. Precompute individual unit power bounds (min_out, max_out) considering ramp limits\n3. Calculate priority scores balancing current operating cost and next-period flexibility: \n   - Adjust startup cost based on next-period load forecast demand\n   - Compute operational flexibility as ramp range over total capacity range\n   - Combine adjusted costs per MW with flexibility factors\n4. Build initial commitment starting with forced-on units\n5. Add free units by ascending score until capacity >= load\n6. Remove redundant free units (worst-score first) while meeting load\n7. Perform ramp-constrained economic dispatch via lambda iteration\n8. Ensure exact load matching through proportional adjustment\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    # 1. Identify forced units\n    forced_on = []\n    forced_off = []\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            min_out[i] = unit['p_min_i']\n            max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # 2. Compute total max capacity for forced-on units\n    total_max_forced_on = sum(max_out[i] for i in forced_on)\n    \n    # 3. Calculate priority scores\n    scores = {}\n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    \n    for i in free_units:\n        unit = units_info[i]\n        # Startup cost amortization\n        if unit['u_i_0'] == 0 and next_load > total_max_forced_on:\n            adj_s = 0.5 * unit['s_i']\n        elif unit['u_i_0'] == 0:\n            adj_s = unit['s_i']\n        else:\n            adj_s = 0\n            \n        # Current cost at min output\n        min_cost = unit['a_i'] + unit['b_i'] * min_out[i] + unit['c_i'] * min_out[i] ** 2 + adj_s\n        cost_per_mw = min_cost / min_out[i] if min_out[i] > 0 else float('inf')\n        \n        # Flexibility calculation\n        cap_range = unit['p_max_i'] - unit['p_min_i']\n        ramp_range = unit['p_up_i'] + unit['p_down_i']\n        flex_ratio = ramp_range / cap_range if cap_range > 0 else 0\n        flex_factor = min(1.0, flex_ratio)\n        \n        scores[i] = cost_per_mw / (flex_factor + 0.01)\n    \n    # 4-5. Build initial commitment\n    committed = forced_on.copy()\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n        else:\n            break\n    \n    # 6. Remove redundant units\n    free_in_commit = [i for i in committed if i in free_units]\n    changed = True\n    while changed and free_in_commit:\n        changed = False\n        worst_first = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in worst_first:\n            test_min = total_min - min_out[i]\n            test_max = total_max - max_out[i]\n            if test_min <= current_load <= test_max:\n                committed.remove(i)\n                total_min = test_min\n                total_max = test_max\n                free_in_commit.remove(i)\n                changed = True\n                break\n    \n    # 7. Economic dispatch\n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    p_list = [0.0] * n_units\n    \n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        lb_vec[i] = min_out[i]\n        ub_vec[i] = max_out[i]\n    \n    low_lam = -10000\n    high_lam = 10000\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    # 8. Load matching adjustment\n    total_output = sum(p_list[i] for i in committed)\n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        adjustable = [i for i in committed if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        if adjustable:\n            adj_per_unit = diff / len(adjustable)\n            for i in adjustable:\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj_per_unit))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00627,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm retains the two-stage structure but modifies the scoring function parameters for startup cost amortization and operating cost calculation. Key changes include: 1) Using a more aggressive startup cost amortization (20% when next period load exceeds forced-on capacity), 2) Calculating operational cost at midpoint power level instead of minimum output, and 3) Maintaining the original flexibility ratio weighting. Steps:\n1. Identify forced-on/off units based on current states\n2. Compute unit power bounds considering ramp limits\n3. Calculate priority scores:\n   - Apply 80% startup cost reduction when next load > forced capacity\n   - Compute operational cost at midpoint (avg of min/max)\n   - Flexibility score remains (ramp range / capacity range)\n   - Combine as cost_per_MW/(flexibility + 0.01)\n4. Commit forced-on units then add free units by ascending score\n5. Remove redundant free units worst-score first\n6. Execute ramp-constrained economic dispatch\n7. Adjust outputs proportionally for exact load matching\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    \n    forced_on = []\n    forced_off = []\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            min_out[i] = unit['p_min_i']\n            max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    total_max_forced_on = sum(max_out[i] for i in forced_on)\n    \n    scores = {}\n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    \n    for i in free_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            if next_load > total_max_forced_on:\n                adj_s = 0.2 * unit['s_i']  \n            else:\n                adj_s = unit['s_i']\n        else:\n            adj_s = 0\n            \n        p_mid = (min_out[i] + max_out[i]) / 2.0\n        if p_mid <= 0:\n            cost_per_mw = float('inf')\n        else:\n            cost_at_mid = unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * p_mid ** 2 + adj_s\n            cost_per_mw = cost_at_mid / p_mid\n        \n        cap_range = unit['p_max_i'] - unit['p_min_i']\n        if cap_range > 0:\n            ramp_range = unit['p_up_i'] + unit['p_down_i']\n            flex_ratio = ramp_range / cap_range\n            flex_factor = min(1.0, flex_ratio)\n        else:\n            flex_factor = 0\n            \n        scores[i] = cost_per_mw / (flex_factor + 0.01)\n    \n    committed = forced_on.copy()\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n        else:\n            break\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    changed = True\n    while changed and free_in_commit:\n        changed = False\n        worst_first = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in worst_first:\n            test_min = total_min - min_out[i]\n            test_max = total_max - max_out[i]\n            if test_min <= current_load <= test_max:\n                committed.remove(i)\n                total_min = test_min\n                total_max = test_max\n                free_in_commit.remove(i)\n                changed = True\n                break\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    p_list = [0.0] * n_units\n    \n    lb_vec = {}\n    ub_vec = {}\n    for i in committed:\n        lb_vec[i] = min_out[i]\n        ub_vec[i] = max_out[i]\n    \n    low_lam = -10000\n    high_lam = 10000\n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    total_output = sum(p_list[i] for i in committed)\n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        adjustable = [i for i in committed if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        if adjustable:\n            adj_per_unit = diff / len(adjustable)\n            for i in adjustable:\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj_per_unit))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00628,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm uses priority-based initial commitment followed by hill climbing refinement. Key steps:\n1. Identify forced-on/off units based on previous state and constraints\n2. Form initial commitment:\n   - Start with forced-on units\n   - Add free units sorted by average cost (lowest first) until load can be met\n3. Perform economic dispatch using lambda iteration\n4. Refine solution via hill climbing:\n   - Iteratively evaluate neighbor solutions by:\n        a) Dropping a free unit\n        b) Adding a free unit\n        c) Swapping two free units\n   - Immediately accept first improving move found\n   - Restart search from new solution after each improvement\n   - Terminate when no improvements in full neighborhood pass\n5. Return best solution found\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Determine forced on/off status\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    # Helper for power bounds\n    def compute_power_bounds(committed):\n        total_min, total_max = 0, 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    # Economic dispatch via lambda iteration\n    def economic_dispatch(committed):\n        if not committed: \n            return [0]*n_units, 0\n            \n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        low_lam, high_lam = -10000, 10000\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        # Adjust for any load mismatch\n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, total_output\n    \n    # Cost calculation\n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n    \n    # Initialize\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    \n    # Add free units by priority\n    if uncommitted_free:\n        avg_costs = []\n        for i in uncommitted_free:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, uncommitted_free))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                free_committed.append(unit_idx)\n                uncommitted_free.remove(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    # Initial economic dispatch\n    dispatch, _ = economic_dispatch(committed)\n    best_committed = committed[:]\n    best_dispatch = dispatch[:]\n    best_cost = compute_total_cost(committed, dispatch)\n    \n    # Hill climbing refinement\n    improved = True\n    while improved:\n        improved = False\n        current_committed = best_committed[:]\n        current_free_committed = [i for i in best_committed if i in free_units]\n        current_uncommitted_free = [i for i in free_units if i not in best_committed]\n        \n        # Try drop moves\n        for unit in current_free_committed:\n            new_committed = [u for u in current_committed if u != unit]\n            new_free_committed = [u for u in current_free_committed if u != unit]\n            new_uncommitted_free = current_uncommitted_free + [unit]\n            \n            total_min, total_max = compute_power_bounds(new_committed)\n            if not (total_min <= current_load <= total_max):\n                continue\n                \n            new_dispatch, _ = economic_dispatch(new_committed)\n            new_cost = compute_total_cost(new_committed, new_dispatch)\n            if new_cost < best_cost:\n                best_committed = new_committed\n                best_dispatch = new_dispatch\n                best_cost = new_cost\n                improved = True\n                break\n        \n        if improved:\n            continue\n            \n        # Try add moves\n        for unit in current_uncommitted_free:\n            new_committed = current_committed + [unit]\n            new_free_committed = current_free_committed + [unit]\n            new_uncommitted_free = [u for u in current_uncommitted_free if u != unit]\n            \n            total_min, total_max = compute_power_bounds(new_committed)\n            if not (total_min <= current_load <= total_max):\n                continue\n                \n            new_dispatch, _ = economic_dispatch(new_committed)\n            new_cost = compute_total_cost(new_committed, new_dispatch)\n            if new_cost < best_cost:\n                best_committed = new_committed\n                best_dispatch = new_dispatch\n                best_cost = new_cost\n                improved = True\n                break\n        \n        if improved:\n            continue\n            \n        # Try swap moves\n        for unit_out in current_free_committed:\n            for unit_in in current_uncommitted_free:\n                new_committed = [u for u in current_committed if u != unit_out] + [unit_in]\n                new_free_committed = [u for u in current_free_committed if u != unit_out] + [unit_in]\n                new_uncommitted_free = [u for u in current_uncommitted_free if u != unit_in] + [unit_out]\n                \n                total_min, total_max = compute_power_bounds(new_committed)\n                if not (total_min <= current_load <= total_max):\n                    continue\n                    \n                new_dispatch, _ = economic_dispatch(new_committed)\n                new_cost = compute_total_cost(new_committed, new_dispatch)\n                if new_cost < best_cost:\n                    best_committed = new_committed\n                    best_dispatch = new_dispatch\n                    best_cost = new_cost\n                    improved = True\n                    break\n            if improved:\n                break\n    \n    # Prepare final solution\n    u_list = [1 if i in best_committed else 0 for i in range(n_units)]\n    return np.array([u_list, best_dispatch])",
          "objective": 0.00629,
          "other_inf": null
     }
]