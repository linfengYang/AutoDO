[
     {
          "algorithm": "** \nThe algorithm uses a priority list method combined with a local search technique. It starts by categorizing units into forced-on, forced-off, and free units based on their physical limitations. Free units are prioritized by their average production cost at their midpoint output. The initial commitment greedily adds free units in priority order until the load can be met. An economic dispatch using lambda iteration allocates power optimally among committed units while respecting ramp and output limits. A local search then refines the solution by considering: decommitting expensive free units, adding uncommitted cheap units, or swapping expensive units for cheaper uncommitted ones. Each candidate solution undergoes feasibility checks, economic dispatch, and cost evaluation to ensure improvements while meeting all constraints.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00607,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the genetic approach by modifying key parameters and fitness evaluation. Main steps:\n1. Initialization: Create population_size solutions from current commitment state, respecting forced on/off constraints\n2. Fitness evaluation: Calculate total cost (including startup) plus penalty*load_deviation_squared\n3. Selection: Use roulette wheel selection based on fitness reciprocals\n4. Crossover: Perform one-point crossover on parent pairs\n5. Mutation: Apply state flips to flexible units with exponentially decaying rate\n6. Elitism: Preserve best solution across generations\n7. Economic dispatch: Use lambda iteration for load allocation on best solution\nKey modifications from original:\n- Increased population_size (20) and max_iter (100)\n- Squared load deviation term in fitness with penalty_factor=2000\n- Exponential mutation decay (0.5 base) instead of linear\n- Roulette wheel selection instead of tournament\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    population_size = 20\n    max_iter = 100\n    mutation_rate = 0.15\n    \n    population = []\n    for _ in range(population_size):\n        solution = []\n        for unit in units_info:\n            if unit['u_i_0'] == 1:\n                if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                    solution.append(1)\n                else:\n                    solution.append(np.random.choice([0,1]))\n            else:\n                if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                    solution.append(0)\n                else:\n                    solution.append(np.random.choice([0,1]))\n        population.append(solution)\n    \n    best_solution = None\n    best_fitness = float('inf')\n    \n    for iteration in range(max_iter):\n        fitness = []\n        for solution in population:\n            total_cost = 0\n            total_power_min = 0\n            total_power_max = 0\n            feasible = True\n            \n            for i, state in enumerate(solution):\n                unit = units_info[i]\n                if state == 1:\n                    if unit['u_i_0'] == 1:\n                        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:\n                        p_min = unit['p_min_i']\n                        p_max = min(unit['p_max_i'], unit['p_start_i'])\n                    total_power_min += p_min\n                    total_power_max += p_max\n                    \n                    if unit['u_i_0'] == 0:\n                        total_cost += unit['s_i']\n                    total_cost += unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n                else:\n                    p_min = 0\n                    p_max = 0\n            \n            load_dev = 0\n            if current_load < total_power_min:\n                load_dev = total_power_min - current_load\n            elif current_load > total_power_max:\n                load_dev = current_load - total_power_max\n            \n            fitness_val = total_cost + 2000 * (load_dev ** 2)\n            fitness.append(fitness_val)\n            \n            if fitness_val < best_fitness:\n                best_fitness = fitness_val\n                best_solution = solution.copy()\n        \n        recip_fitness = [1/(f+1e-5) for f in fitness]\n        total_recip = sum(recip_fitness)\n        probabilities = [r/total_recip for r in recip_fitness]\n        parents = []\n        for _ in range(population_size):\n            idx = np.random.choice(range(population_size), p=probabilities)\n            parents.append(population[idx])\n        \n        new_population = []\n        for i in range(0, population_size, 2):\n            parent1 = parents[i]\n            parent2 = parents[i+1]\n            child1 = parent1.copy()\n            child2 = parent2.copy()\n            \n            cross_point = np.random.randint(1, n_units)\n            child1[:cross_point] = parent2[:cross_point]\n            child2[:cross_point] = parent1[:cross_point]\n            \n            new_population.append(child1)\n            new_population.append(child2)\n        \n        decay_factor = 0.5 ** (iteration / (max_iter/2))\n        mutation_rate_iter = mutation_rate * decay_factor\n        for i in range(population_size):\n            for j in range(n_units):\n                if np.random.random() < mutation_rate_iter:\n                    unit = units_info[j]\n                    if unit['u_i_0'] == 1:\n                        if not (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n                            new_population[i][j] = 1 - new_population[i][j]\n                    else:\n                        if not (abs(unit['t_i_0']) < unit['t_off_min_i']):\n                            new_population[i][j] = 1 - new_population[i][j]\n        \n        new_population[0] = best_solution.copy()\n        population = new_population\n    \n    u_list = best_solution\n    committed_indices = [i for i, state in enumerate(u_list) if state == 1]\n    lb_vec = {}\n    ub_vec = {}\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_vec[i] = unit['p_min_i']\n            ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lambda = -10000\n    high_lambda = 10000\n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lambda > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        if abs(high_lambda - low_lambda) < 1e-6:\n            break\n    \n    final_lambda = (low_lambda + high_lambda) / 2\n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_vec[i] if final_lambda > unit['b_i'] else lb_vec[i]\n        else:\n            p_val = (final_lambda - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound_units = [i for i in committed_indices \n                          if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        num_non_bound = len(non_bound_units)\n        if num_non_bound > 0:\n            adjustment = diff / num_non_bound\n            for i in non_bound_units:\n                new_val = p_list[i] + adjustment\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], new_val))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00647,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the scoring function by using a straightforward average cost calculation at each unit's minimum power output. It calculates cost per MW based on quadratic cost coefficients at p_min_i, with startup cost included if the unit is off. Forced on/off units are identified using current state information. Base commitment starts with forced-on units, then adds free units sorted by ascending cost per MW. Redundant free units are removed if the load can still be met. Candidate solutions are generated and evaluated, including base set, removals, additions, and swaps of free units, to find the minimum-cost feasible commitment and dispatch.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    forced_on_idxs = [i for i, flag in enumerate(forced_on) if flag]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        if p_min > 0:\n            base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n            if unit['u_i_0'] == 0:\n                base_cost += unit['s_i']\n            scores[i] = base_cost / p_min\n        else:\n            scores[i] = 1e10\n\n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    base_committed = forced_on_idxs[:]\n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    total_min, total_max = compute_power_bounds(base_committed)\n    \n    for i in sorted_free:\n        if total_max < current_load:\n            base_committed.append(i)\n            total_min, total_max = compute_power_bounds(base_committed)\n        else:\n            break\n    \n    free_in_base = [i for i in base_committed if i in free_units]\n    changed = True\n    while changed and free_in_base:\n        changed = False\n        free_in_base_sorted = sorted(free_in_base, key=lambda i: scores[i], reverse=True)\n        for i in free_in_base_sorted:\n            candidate_try = [j for j in base_committed if j != i]\n            t_min, t_max = compute_power_bounds(candidate_try)\n            if t_min <= current_load <= t_max:\n                base_committed = candidate_try\n                changed = True\n                free_in_base = [j for j in base_committed if j in free_units]\n                break\n    \n    try:\n        base_dispatch, _ = economic_dispatch(base_committed)\n    except:\n        base_dispatch = [0] * n_units\n    base_cost = compute_total_cost(base_committed, base_dispatch)\n    candidates = [(base_committed, base_dispatch, base_cost)]\n    \n    free_in_commit = [i for i in base_committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in base_committed]\n    \n    for i in free_in_commit:\n        candidate_committed = [j for j in base_committed if j != i]\n        try:\n            dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, dispatch)\n            candidates.append((candidate_committed, dispatch, cost))\n        except:\n            continue\n    \n    for j in uncommitted_free:\n        candidate_committed = base_committed + [j]\n        try:\n            dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, dispatch)\n            candidates.append((candidate_committed, dispatch, cost))\n        except:\n            continue\n    \n    for i in free_in_commit:\n        for j in uncommitted_free:\n            if scores[j] < scores[i]:\n                candidate_committed = [k for k in base_committed if k != i] + [j]\n                try:\n                    dispatch, _ = economic_dispatch(candidate_committed)\n                    cost = compute_total_cost(candidate_committed, dispatch)\n                    candidates.append((candidate_committed, dispatch, cost))\n                except:\n                    continue\n    \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00688,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the initial unit commitment priority list and refines the economic dispatch. For the priority list, it uses the average cost per MW at the maximum available power output for each free unit (considering startup costs for initially offline units). This provides a more generalized cost metric. In economic dispatch, the bisection bounds are dynamically set to the min/max marginal costs of committed units at their power bounds, avoiding fixed bounds. The rest of the logic (forced on/off status, local search) remains unchanged for robustness.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        if len(committed) > 0:\n            low_lam = float('inf')\n            high_lam = -float('inf')\n            for i in committed:\n                unit = units_info[i]\n                lb = lb_vec[i]\n                ub = ub_vec[i]\n                if unit['c_i'] < 1e-6:\n                    mc = unit['b_i']\n                    if mc < low_lam:\n                        low_lam = mc\n                    if mc > high_lam:\n                        high_lam = mc\n                else:\n                    mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n                    mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n                    if mc_lb < low_lam:\n                        low_lam = mc_lb\n                    if mc_ub > high_lam:\n                        high_lam = mc_ub\n            low_lam -= 100\n            high_lam += 100\n        else:\n            low_lam = -10000\n            high_lam = 10000\n\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                power_ub = min(unit['p_max_i'], unit['p_start_i'])\n                total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * power_ub + unit['c_i'] * power_ub**2\n            else:\n                power_ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                total_cost = unit['a_i'] + unit['b_i'] * power_ub + unit['c_i'] * power_ub**2\n            avg_costs.append(total_cost / power_ub)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00699,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe revised algorithm replaces the genetic algorithm with a deterministic priority-based method. It first categorizes each unit as forced on, forced off, or flexible based on current state and constraints. For forced on units, it calculates their power constraints and aggregates the minimum and maximum power. If the load is within the aggregated bounds, no further action is needed. Otherwise, flexible units are sorted by a priority index (production cost per MW for already on units, including startup cost for off units). Flexible units are committed in priority order until the aggregated maximum power covers the load, ensuring the aggregated minimum does not exceed the load. Finally, economic dispatch via lambda iteration is performed, distributing any residual load among non-bound units.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forced_state = []\n    flexible_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_state.append(1)\n            else:\n                forced_state.append(None)\n                flexible_indices.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_state.append(0)\n            else:\n                forced_state.append(None)\n                flexible_indices.append(i)\n    \n    u_list = [0] * n_units\n    lb_vec = {}\n    ub_vec = {}\n    min_forced = 0\n    max_forced = 0\n    for i in range(n_units):\n        if forced_state[i] == 1:\n            u_list[i] = 1\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n            min_forced += lb_vec[i]\n            max_forced += ub_vec[i]\n        elif forced_state[i] == 0:\n            u_list[i] = 0\n        else:\n            u_list[i] = 0\n    \n    if not (min_forced <= current_load <= max_forced):\n        priorities = []\n        for idx in flexible_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost = unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max**2\n                priority = cost / p_max\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * p_max + unit['c_i'] * p_max**2\n                priority = cost / p_max\n            priorities.append((priority, idx))\n        priorities.sort(key=lambda x: x[0])\n        \n        current_min = min_forced\n        current_max = max_forced\n        for priority, idx in priorities:\n            if current_min <= current_load and current_max >= current_load:\n                break\n            unit = units_info[idx]\n            if u_list[idx] != 1:\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_min = unit['p_min_i']\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if current_min + p_min > current_load:\n                    continue\n                u_list[idx] = 1\n                lb_vec[idx] = p_min\n                ub_vec[idx] = p_max\n                current_min += p_min\n                current_max += p_max\n    \n    committed_indices = [i for i in range(n_units) if u_list[i] == 1]\n    low_lambda = -10000\n    high_lambda = 10000\n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lambda > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            total_power += p_val\n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        if abs(high_lambda - low_lambda) < 1e-6:\n            break\n    \n    final_lambda = (low_lambda + high_lambda) / 2\n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_vec[i] if final_lambda > unit['b_i'] else lb_vec[i]\n        else:\n            p_val = (final_lambda - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound_units = [i for i in committed_indices \n                          if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        num_non_bound = len(non_bound_units)\n        if num_non_bound > 0:\n            adjustment = diff / num_non_bound\n            for i in non_bound_units:\n                new_val = p_list[i] + adjustment\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], new_val))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.00706,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe new algorithm replaces the genetic algorithm with a deterministic greedy priority list method. It first enforces mandatory commitments based on minimum up/down time constraints. Non-forced units are then committed in order of ascending average cost per MW at their minimum output until the total maximum power meets or exceeds the current load. This cost includes startup costs for units that are initially offline. Economic dispatch is then performed using lambda iteration to allocate the load optimally among committed units, with fine-tuning for boundary conditions.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    for i in forced_on:\n        u_list[i] = 1\n    for i in forced_off:\n        u_list[i] = 0\n    \n    non_forced = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    priorities = []\n    for i in non_forced:\n        unit = units_info[i]\n        min_power = unit['p_min_i']\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 0:\n            cost += unit['s_i']\n        priorities.append((cost / min_power, i))\n    priorities.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    for i in forced_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    for _, i in priorities:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n        u_list[i] = 1\n    \n    committed_indices = [i for i, state in enumerate(u_list) if state == 1]\n    lb_vec = {}\n    ub_vec = {}\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_vec[i] = unit['p_min_i']\n            ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lambda = -10000\n    high_lambda = 10000\n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if mid_lambda > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        if abs(high_lambda - low_lambda) < 1e-6:\n            break\n    \n    final_lambda = (low_lambda + high_lambda) / 2\n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_vec[i] if final_lambda > unit['b_i'] else lb_vec[i]\n        else:\n            p_val = (final_lambda - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound_units = [i for i in committed_indices \n                          if p_list[i] > lb_vec[i] and p_list[i] < ub_vec[i]]\n        num_non_bound = len(non_bound_units)\n        if num_non_bound > 0:\n            adjustment = diff / num_non_bound\n            for i in non_bound_units:\n                new_val = p_list[i] + adjustment\n                p_list[i] = max(lb_vec[i], min(ub_vec[i], new_val))\n    \n    return np.array([u_list, p_list])",
          "objective": 0.0071,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm prioritizes units based on a composite score that balances cost efficiency and operational flexibility. It uses a detailed initial commitment step that considers both minimum and maximum power bounds to avoid over/under-commitment, followed by a targeted local search. Key steps:\n1. Identify forced-on/off units based on physical limitations.\n2. Compute scores for free units: combines average cost at midpoint, startup cost factor, and ramp flexibility.\n3. Form initial commitment:\n   - Start with forced-on units.\n   - Add free units by score until minimum power covers load.\n   - If maximum power is insufficient, add more units.\n   - Remove free units (worst-first) if minimum power exceeds load while maintaining feasibility.\n4. Perform economic dispatch using lambda iteration.\n5. Local search: consider removing committed free units, adding uncommitted units, and cost-beneficial swaps.\n6. Evaluate candidates via dispatch and cost calculation, selecting the best solution.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    forced_on_idxs = [i for i, flag in enumerate(forced_on) if flag]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n        base_cost = unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2\n        avg_cost = base_cost / mid if mid > 0 else 1e10\n        startup_cost_factor = unit['s_i'] / base_cost if base_cost > 0 else 0\n        ramp_range = unit['p_max_i'] - unit['p_min_i']\n        if ramp_range <= 0:\n            ramp_factor = 1e10\n        else:\n            ramp_factor = max(unit['p_up_i'], unit['p_down_i']) / ramp_range\n            ramp_factor = max(ramp_factor, 1e-6)\n        scores[i] = avg_cost * (1 + startup_cost_factor) / ramp_factor\n\n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    base_committed = forced_on_idxs[:]\n    sorted_free = sorted(free_units, key=lambda i: scores[i])\n    total_min, total_max = compute_power_bounds(base_committed)\n    \n    for i in sorted_free:\n        if total_max < current_load:\n            base_committed.append(i)\n            total_min, total_max = compute_power_bounds(base_committed)\n        else:\n            break\n    \n    free_in_base = [i for i in base_committed if i in free_units]\n    changed = True\n    while changed and free_in_base:\n        changed = False\n        free_in_base_sorted = sorted(free_in_base, key=lambda i: scores[i], reverse=True)\n        for i in free_in_base_sorted:\n            candidate_try = [j for j in base_committed if j != i]\n            t_min, t_max = compute_power_bounds(candidate_try)\n            if t_min <= current_load <= t_max:\n                base_committed = candidate_try\n                changed = True\n                free_in_base = [j for j in base_committed if j in free_units]\n                break\n    \n    try:\n        base_dispatch, _ = economic_dispatch(base_committed)\n    except:\n        base_dispatch = [0] * n_units\n    base_cost = compute_total_cost(base_committed, base_dispatch)\n    candidates = [(base_committed, base_dispatch, base_cost)]\n    \n    free_in_commit = [i for i in base_committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in base_committed]\n    \n    for i in free_in_commit:\n        candidate_committed = [j for j in base_committed if j != i]\n        try:\n            dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, dispatch)\n            candidates.append((candidate_committed, dispatch, cost))\n        except:\n            continue\n    \n    for j in uncommitted_free:\n        candidate_committed = base_committed + [j]\n        try:\n            dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, dispatch)\n            candidates.append((candidate_committed, dispatch, cost))\n        except:\n            continue\n    \n    for i in free_in_commit:\n        for j in uncommitted_free:\n            if scores[j] < scores[i]:\n                candidate_committed = [k for k in base_committed if k != i] + [j]\n                try:\n                    dispatch, _ = economic_dispatch(candidate_committed)\n                    cost = compute_total_cost(candidate_committed, dispatch)\n                    candidates.append((candidate_committed, dispatch, cost))\n                except:\n                    continue\n    \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00714,
          "other_inf": null
     },
     {
          "algorithm": "The novel heuristic integrates look-ahead cost amortization with constraint-aware dispatching. Key steps: (1) Identify forced-on units (insufficient uptime/shutdown violations) and forced-off units (insufficient downtime). (2) Calculate feasible power ranges considering startup/shutdown ramp limitations and standard ramps. (3) For non-forced offline units, calculate adjusted startup cost amortized based on next period's load forecast. (4) Add units by priority of adjusted cost per MW until capacity meets load. (5) Remove most expensive non-forced units if min outputs exceed load. (6) Dispatch power using ramp-constrained lambda iteration for exact load matching.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else 0\n    forced_on = []\n    forced_off = []\n    min_out = [0.0] * n\n    max_out = [0.0] * n\n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            min_out[i] = unit['p_min_i']\n            max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    committed = set(forced_on)\n    free_units = [i for i in range(n) if i not in forced_on and i not in forced_off]\n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    candidate_units = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 0:\n            adjusted_s = units_info[i]['s_i'] * (0.5 if next_load > total_max + min_out[i] else 1.0)\n            cost_per_mw = (adjusted_s + units_info[i]['a_i'] + units_info[i]['b_i'] * min_out[i] \n                         + units_info[i]['c_i'] * min_out[i]**2) / min_out[i]\n            candidate_units.append((cost_per_mw, i))\n    \n    candidate_units.sort(key=lambda x: x[0])\n    for _, i in candidate_units:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_out[i]\n        total_max += max_out[i]\n    \n    non_forced = [i for i in committed if i not in forced_on]\n    if non_forced:\n        removal_costs = []\n        for i in non_forced:\n            cost_at_min = units_info[i]['a_i'] + units_info[i]['b_i'] * min_out[i] + units_info[i]['c_i'] * min_out[i]**2\n            removal_costs.append((cost_at_min, i))\n        removal_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in removal_costs:\n            if total_min <= current_load:\n                break\n            committed.remove(i)\n            total_min -= min_out[i]\n            total_max -= max_out[i]\n    \n    low_lambda, high_lambda = -1e5, 1e5\n    p_list = [0.0] * n\n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = max_out[i] if mid_lambda > unit['b_i'] else min_out[i]\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_out[i], min(max_out[i], p_val))\n            p_list[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        if abs(high_lambda - low_lambda) < 1e-5:\n            break\n    \n    u_list = [1 if i in committed else 0 for i in range(n)]\n    return np.array([u_list, p_list])",
          "objective": 0.00738,
          "other_inf": null
     },
     {
          "algorithm": "This heuristic enhances the initial algorithm by incorporating two-stage commitment based on economic efficiency and forecasted load, and refined dispatch considering marginal cost and ramp feasibility. Key steps:\n1. Classify units: must-on (min up-time/shutdown limit), must-off (min down-time), flexible.\n2. Calculate fixed generation range from must-on units using ramp limits.\n3. Sort flexible units by full-load average cost (including startup) per MW.\n4. Commit flexible units in sorted order until current load is met, then check if next period's forecasted load exceeds available generation. If so, commit additional most economic unit.\n5. Perform refined economic dispatch:\n   - Initialize committed units to their feasible minimum outputs.\n   - Allocate remaining load by increasing output of units with lowest marginal cost (b_i + 2c_i * p_i) until target load or ramp limits.\n   - Ensure target load is clamped within total feasible generation range.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n                u[idx] = 1\n            else:\n                flexible.append(idx)\n        else:\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n                u[idx] = 0\n            else:\n                flexible.append(idx)\n    \n    min_fixed = 0\n    max_fixed = 0\n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        min_fixed += lb\n        max_fixed += ub\n    \n    def average_full_cost_per_MW(unit):\n        p_max = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else unit['p_max_i']\n        total_cost = unit['a_i'] + unit['s_i'] + unit['b_i'] * p_max + unit['c_i'] * (p_max ** 2)\n        return total_cost / p_max\n    \n    flexible_sorted = sorted(\n        [(idx, units_info[idx]) for idx in flexible],\n        key=lambda x: average_full_cost_per_MW(x[1])\n    )\n    \n    started_flex = []\n    min_so_far = min_fixed\n    max_so_far = max_fixed\n    current_load = load[0]\n    next_load = load[1]\n    \n    for (idx, unit) in flexible_sorted:\n        if max_so_far >= current_load:\n            break\n        if unit['u_i_0'] == 1:\n            unit_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit_min = unit['p_min_i']\n            unit_max = min(unit['p_max_i'], unit['p_start_i'])\n        started_flex.append(idx)\n        u[idx] = 1\n        min_so_far += unit_min\n        max_so_far += unit_max\n    \n    remaining_flex = [item for item in flexible_sorted if item[0] not in started_flex]\n    if remaining_flex and next_load > max_so_far:\n        idx, unit = remaining_flex[0]\n        if unit['u_i_0'] == 1:\n            unit_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit_min = unit['p_min_i']\n            unit_max = min(unit['p_max_i'], unit['p_start_i'])\n        started_flex.append(idx)\n        u[idx] = 1\n        min_so_far += unit_min\n        max_so_far += unit_max\n    \n    target_power = min(max(current_load, min_so_far), max_so_far)\n    committed = must_on + started_flex\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        p[idx] = lb\n    \n    total_allocated = sum(p[idx] for idx in committed)\n    remaining = target_power - total_allocated\n    \n    active_units = []\n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        if p[idx] < ub:\n            active_units.append(idx)\n    \n    while remaining > 0 and active_units:\n        candidate = None\n        min_mc = float('inf')\n        for idx in active_units:\n            mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n            if mc < min_mc:\n                min_mc = mc\n                candidate = idx\n        \n        if candidate is None:\n            break\n        \n        unit = units_info[candidate]\n        if unit['u_i_0'] == 1:\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        max_add = ub - p[candidate]\n        add = min(remaining, max_add)\n        p[candidate] += add\n        remaining -= add\n        \n        if p[candidate] >= ub:\n            active_units.remove(candidate)\n    \n    return np.array([u, p])",
          "objective": 0.00784,
          "other_inf": null
     },
     {
          "algorithm": "**\nThe heuristic algorithm for the Rolling Unit Commitment Problem involves a priority list-based method to determine unit commitments and dispatches for the current time step. The main steps are:\n\n1. **Identify Forced Units**: For each unit, determine if it must be online (forced_on) due to minimum up-time constraints or shutdown capacity violations (previous output > shutdown capacity), or offline (forced_off) due to minimum down-time constraints.\n\n2. **Calculate Min/Max Outputs**: Compute possible output ranges for each unit considering ramp limits and startup/shutdown constraints. For units previously online, apply ramp-down and ramp-up limits. For potential startups, apply startup output limits.\n\n3. **Form Initial Commit Set**: Start with forced-on units. Calculate the total min and max possible output from these units.\n\n4. **Load Matching**:\n   - If the current load is within the min and max range of forced-on units, no additional units are committed.\n   - If the load exceeds the max output, add available units (not forced) from a priority list sorted by average cost per MW (including startup cost if applicable) until the total max output meets or exceeds the load.\n   - If the load is below the min output, the total output is set to the minimum.\n\n5. **Dispatch Committed Units**: Perform economic dispatch for committed units to meet the required total output while respecting individual unit constraints, using incremental cost merit-order dispatch.\n\n6. **Output Schedule**: Generate a 2D array with commitment states and dispatched outputs for all units.\n\n**",
          "code": "import numpy as np\n\ndef economic_dispatch(min_outputs, max_outputs, b_list, c_list, P_total):\n    n = len(min_outputs)\n    p = min_outputs.copy()\n    remaining = P_total - sum(p)\n    active_indices = [i for i in range(n) if p[i] < max_outputs[i]]\n    \n    while remaining > 1e-5 and active_indices:\n        min_ic = float('inf')\n        candidate_idx = None\n        \n        for idx in active_indices:\n            ic = b_list[idx] + 2 * c_list[idx] * p[idx]\n            if ic < min_ic:\n                min_ic = ic\n                candidate_idx = idx\n        \n        max_adjust = max_outputs[candidate_idx] - p[candidate_idx]\n        adjust = min(remaining, max_adjust)\n        p[candidate_idx] += adjust\n        remaining -= adjust\n        \n        if p[candidate_idx] >= max_outputs[candidate_idx]:\n            active_indices.remove(candidate_idx)\n            \n    return p\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    p_shut_i = [unit['p_shut_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    current_load = load[0]\n    \n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_output_i = [0] * n_units\n    max_output_i = [0] * n_units\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            forced_on[i] = (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i])\n            min_output_i[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n            max_output_i[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n        else:\n            forced_off[i] = (t_i_0[i] < 0) and (abs(t_i_0[i]) < t_off_min_i[i])\n            min_output_i[i] = p_min_i[i]\n            max_output_i[i] = min(p_max_i[i], p_start_i[i])\n    \n    forced_on_units = [i for i in range(n_units) if forced_on[i]]\n    forced_off_units = [i for i in range(n_units) if forced_off[i]]\n    available_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    total_min_forced = sum(min_output_i[i] for i in forced_on_units)\n    total_max_forced = sum(max_output_i[i] for i in forced_on_units)\n    committed_set = set(forced_on_units)\n    P_total = current_load\n    \n    if current_load > total_max_forced:\n        def priority(i):\n            if u_i_0[i] == 1:\n                fixed_cost = a_i[i]\n            else:\n                fixed_cost = s_i[i] + a_i[i]\n            total_cost = fixed_cost + b_i[i] * min_output_i[i] + c_i[i] * min_output_i[i] ** 2\n            return total_cost / min_output_i[i]\n        \n        sorted_available = sorted(available_units, key=priority)\n        current_min = total_min_forced\n        current_max = total_max_forced\n        added_set = []\n        \n        for i in sorted_available:\n            added_set.append(i)\n            current_min += min_output_i[i]\n            current_max += max_output_i[i]\n            if current_max >= current_load:\n                break\n                \n        committed_set = committed_set.union(added_set)\n        \n        if current_min <= current_load <= current_max:\n            P_total = current_load\n        elif current_load < current_min:\n            P_total = current_min\n        else:\n            P_total = current_max\n    elif current_load < total_min_forced:\n        P_total = total_min_forced\n        \n    min_outputs_committed = []\n    max_outputs_committed = []\n    b_committed = []\n    c_committed = []\n    idx_committed = list(committed_set)\n    \n    for i in idx_committed:\n        min_outputs_committed.append(min_output_i[i])\n        max_outputs_committed.append(max_output_i[i])\n        b_committed.append(b_i[i])\n        c_committed.append(c_i[i])\n        \n    if min_outputs_committed:\n        p_dispatch = economic_dispatch(min_outputs_committed, max_outputs_committed, b_committed, c_committed, P_total)\n    else:\n        p_dispatch = []\n        \n    u_sol = []\n    p_sol = []\n    for i in range(n_units):\n        if i in committed_set:\n            u_sol.append(1)\n            pos = idx_committed.index(i)\n            p_sol.append(p_dispatch[pos])\n        else:\n            u_sol.append(0)\n            p_sol.append(0.0)\n            \n    schedules = np.array([u_sol, p_sol])\n    return schedules",
          "objective": 0.00821,
          "other_inf": null
     }
]