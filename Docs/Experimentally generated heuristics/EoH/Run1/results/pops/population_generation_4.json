[
     {
          "algorithm": "**  \nThe new algorithm modifies the priority score to incorporate forecasted load trends, using minimum output for cost calculation and directional ramp flexibility. Steps:  \n1. Identify forced-on/off units based on min up/down times and shutdown limits.  \n2. For free units, compute priority score:  \n   - Cost at `p_min_i` (minimum output) plus startup cost if offline.  \n   - Ramp term adapts to forecast: favors ramp-up if load increasing, ramp-down if decreasing, or sum if stable.  \n   - Score = total_cost / max(ramp_term, 1e-5)  \n3. Sort free units by ascending priority score.  \n4. Commit forced-on units, then add free units in score order until load can be met.  \n5. Refine: Remove worst-scored free units if load can still be met.  \n6. Dispatch with lambda iteration for optimal allocation within ramp bounds.  \n7. Adjust non-bound units proportionally for exact load matching.  \n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1]\n    delta_load = next_load - current_load\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        p_ref = unit['p_min_i']\n        total_cost = unit['a_i'] + unit['b_i'] * p_ref + unit['c_i'] * p_ref**2\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n            \n        if delta_load > 0:\n            ramp_term = 2 * unit['p_up_i'] + unit['p_down_i']\n        elif delta_load < 0:\n            ramp_term = unit['p_up_i'] + 2 * unit['p_down_i']\n        else:\n            ramp_term = unit['p_up_i'] + unit['p_down_i']\n        if ramp_term < 1e-5:\n            ramp_term = 1e-5\n        priority_scores[i] = total_cost / ramp_term\n    \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n        for i in free_in_commit_sorted:\n            candidate = [j for j in committed if j != i]\n            c_min, c_max = power_bounds(candidate)\n            if c_min <= current_load <= c_max:\n                committed = candidate\n                total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound = [i for i in committed if lb_dict[i] < p_list[i] < ub_dict[i]]\n        if non_bound:\n            adj = diff / len(non_bound)\n            for i in non_bound:\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00565,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm modifies the priority score calculation to use average power instead of minimal power and incorporates a ramp impact factor. Key steps:  \n1. Classify forced-on units (if online and violating min-up time or shutdown capacity) and forced-off units (if offline and violating min-down time).  \n2. For non-forced units, compute priority score using cost per MW at average power (midpoint of min/max limits) and scale by ramp impact factor (1 + max ramp divided by operating range).  \n3. Build initial commitment with forced-on units, then add free units by ascending priority score until load can be met.  \n4. Remove least-efficient free units (highest scores) if feasible.  \n5. Allocate load among committed units via lambda iteration within ramp bounds.  \n6. Distribute any residual mismatch using ramp headroom proportions.  \n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        avg_power = (unit['p_min_i'] + unit['p_max_i']) / 2\n        if unit['u_i_0'] == 0:\n            base_cost = unit['a_i'] + unit['b_i']*avg_power + unit['c_i']*avg_power**2 + unit['s_i']\n        else:\n            base_cost = unit['a_i'] + unit['b_i']*avg_power + unit['c_i']*avg_power**2\n        cost_per_mw = base_cost / avg_power\n        max_ramp = max(unit['p_up_i'], unit['p_down_i'])\n        operating_range = unit['p_max_i'] - unit['p_min_i'] + 1e-5\n        ramp_factor = 1.0 + max_ramp / operating_range\n        priority_scores[i] = cost_per_mw * ramp_factor\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n    for i in free_in_commit_sorted:\n        candidate = [j for j in committed if j != i]\n        c_min, c_max = power_bounds(candidate)\n        if c_min <= current_load <= c_max:\n            committed = candidate\n            total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        flex_adj = {}\n        total_flex = 0\n        for i in committed:\n            unit = units_info[i]\n            headroom = (p_list[i] - lb_dict[i], ub_dict[i] - p_list[i])\n            flex = (headroom[1] if diff > 0 else headroom[0]) + 1e-5\n            flex_adj[i] = flex\n            total_flex += flex\n        \n        for i in committed:\n            if flex_adj[i] > 1e-5:\n                adj_amount = diff * flex_adj[i] / total_flex\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj_amount))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00578,
          "other_inf": null
     },
     {
          "algorithm": "The revised algorithm simplifies the economic dispatch by setting lambda bounds to extreme values (-1e10, 1e10) to avoid numerical instability with out-of-distribution cost functions. All other components remain unchanged:\n1. Precompute forced on/off status based on minimum up/down times and shutdown capacity\n2. Form initial commitment with forced-on units and add free units (sorted by average cost) until meeting load\n3. Perform economic dispatch for initial commitment with widened lambda bounds\n4. Generate candidate solutions via unit removals, additions, and swaps\n5. Select lowest-cost candidate solution for final commitment and dispatch\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -1e10, 1e10\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00597,
          "other_inf": null
     },
     {
          "algorithm": "This algorithm is a modified priority-based approach incorporating dynamic cost efficiency metrics and an incremental adjustment step. Key steps are:\n1. **Classify units**: Identify forced-on units (due to min up-time or high previous output) and forced-off units (due to min down-time)\n2. **Compute priority scores**: For non-forced units, calculate a base efficiency score using cost per MW at minimal output (including startup costs for offline units) weighted by ramp flexibility\n3. **Build commitment**: Start with forced-on units. Add free units by ascending priority until load can be met considering ramp-constrained bounds\n4. **Remove redundant units**: Eliminate least-efficient free units if their removal doesn't compromise load feasibility\n5. **Economic dispatch**: Use lambda iteration with dynamic cost bounds to allocate load among committed units\n6. **Incremental adjustment**: Distribute any power mismatch among units with ramp headroom using flexibility-based weighting\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        base_power = unit['p_min_i']\n        if unit['u_i_0'] == 0:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*base_power + unit['c_i']*base_power**2 + unit['s_i']) / base_power\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*base_power + unit['c_i']*base_power**2) / base_power\n        flex_factor = (unit['p_up_i'] + unit['p_down_i']) / (unit['p_max_i'] + 1e-5)\n        priority_scores[i] = cost_per_mw / max(flex_factor, 1e-5)\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n    for i in free_in_commit_sorted:\n        candidate = [j for j in committed if j != i]\n        c_min, c_max = power_bounds(candidate)\n        if c_min <= current_load <= c_max:\n            committed = candidate\n            total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        flex_adj = {}\n        total_flex = 0\n        for i in committed:\n            unit = units_info[i]\n            headroom = (p_list[i] - lb_dict[i], ub_dict[i] - p_list[i])\n            flex = (headroom[1] if diff > 0 else headroom[0]) + 1e-5\n            flex_adj[i] = flex\n            total_flex += flex\n        \n        for i in committed:\n            if flex_adj[i] > 1e-5:\n                adj_amount = diff * flex_adj[i] / total_flex\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj_amount))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00598,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm modifies the priority score calculation to better balance cost efficiency, startup costs, and ramp capabilities. Key changes include:\n1. Using the average operating point (midpoint between p_min and p_max) for cost calculation instead of maximum output\n2. Incorporating startup costs only for offline units in the cost term\n3. Adding a ramp flexibility term in the denominator to prioritize units with higher total ramp capabilities\n4. Sorting free units by ascending priority score (lower score = better) to favor more cost-effective units first\n\nMain steps remain similar to original with priority score modification:\n1. Identify forced units based on min up/down times and shutdown constraints\n2. Calculate new priority score: (cost at midpoint power + startup cost if offline) / (ramp_up + ramp_down)\n3. Form initial commitment: forced-on units + free units (ascending priority order) until load met\n4. Refine commitment: remove least efficient free units (highest priority score) if redundant\n5. Dispatch using lambda iteration for optimal load allocation\n6. Fine-tune outputs with proportional adjustment for bound units\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        # Calculate midpoint power and ramp flexibility\n        p_mid = (unit['p_min_i'] + unit['p_max_i']) / 2.0\n        total_cost = unit['a_i'] + unit['b_i'] * p_mid + unit['c_i'] * p_mid**2\n        if unit['u_i_0'] == 0:  # Add startup cost only if unit is offline\n            total_cost += unit['s_i']\n        ramp_flexibility = unit['p_up_i'] + unit['p_down_i']\n        # Avoid division by zero for ramp flexibility\n        if ramp_flexibility < 1e-5:\n            ramp_flexibility = 1e-5\n        priority_scores[i] = total_cost / ramp_flexibility\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    # Sort free units by ascending priority score (lower score = better)\n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        # Sort free units in descending priority score for removal (remove worst first)\n        free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n        for i in free_in_commit_sorted:\n            candidate = [j for j in committed if j != i]\n            c_min, c_max = power_bounds(candidate)\n            if c_min <= current_load <= c_max:\n                committed = candidate\n                total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        non_bound = [i for i in committed if lb_dict[i] < p_list[i] < ub_dict[i]]\n        if non_bound:\n            adj = diff / len(non_bound)\n            for i in non_bound:\n                p_list[i] = max(lb_dict[i], min(ub_dict[i], p_list[i] + adj))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00603,
          "other_inf": null
     },
     {
          "algorithm": "The revised scheduling algorithm maintains the core structure but enhances generalization by replacing the proportional power adjustment with a merit-based approach. The key steps are:\n1. Identify forced-on and forced-off units based on minimum uptime/downtime and shutdown constraints.\n2. Calculate priority scores for free units based on cost per MW normalized by flexibility.\n3. Commit forced-on units first, then add free units in priority order until total maximum capacity meets the load.\n4. Remove free units in reverse priority order when possible without violating load constraints.\n5. Compute economic dispatch using bisection to find the marginal cost (lambda).\n6. After initial dispatch, if a load gap remains, adjust generation using a merit-order approach:\n   - For positive gaps (under-generation), increase output starting from units with lowest marginal cost\n   - For negative gaps (over-generation), decrease output starting from units with highest marginal cost\n7. Adjustments respect ramp constraints and unit capabilities.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    priority_scores = {}\n    for i in free_units:\n        unit = units_info[i]\n        base_power = unit['p_min_i']\n        if unit['u_i_0'] == 0:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*base_power + unit['c_i']*base_power**2 + unit['s_i']) / base_power\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*base_power + unit['c_i']*base_power**2) / base_power\n        flex_factor = (unit['p_up_i'] + unit['p_down_i']) / (unit['p_max_i'] + 1e-5)\n        priority_scores[i] = cost_per_mw / max(flex_factor, 1e-5)\n        \n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = power_bounds(committed)\n    \n    sorted_free = sorted(free_units, key=lambda i: priority_scores[i])\n    for i in sorted_free:\n        if total_max < current_load:\n            committed.append(i)\n            total_min, total_max = power_bounds(committed)\n    \n    free_in_commit = [i for i in committed if i in free_units]\n    free_in_commit_sorted = sorted(free_in_commit, key=lambda i: priority_scores[i], reverse=True)\n    for i in free_in_commit_sorted:\n        candidate = [j for j in committed if j != i]\n        c_min, c_max = power_bounds(candidate)\n        if c_min <= current_load <= c_max:\n            committed = candidate\n            total_min, total_max = c_min, c_max\n    \n    lb_dict, ub_dict = {}, {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_dict[i] = unit['p_min_i']\n            ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lam, high_lam = float('inf'), -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        lb, ub = lb_dict[i], ub_dict[i]\n        if unit['c_i'] < 1e-6:\n            mc_lb = unit['b_i']\n            mc_ub = unit['b_i']\n        else:\n            mc_lb = unit['b_i'] + 2 * unit['c_i'] * lb\n            mc_ub = unit['b_i'] + 2 * unit['c_i'] * ub\n        low_lam = min(low_lam, mc_lb)\n        high_lam = max(high_lam, mc_ub)\n    low_lam -= 500\n    high_lam += 500\n    \n    for _ in range(100):\n        lam = (low_lam + high_lam) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            low_lam = lam\n        else:\n            high_lam = lam\n        if abs(high_lam - low_lam) < 1e-6:\n            break\n    \n    p_list = [0] * n_units\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    diff = current_load - total_output\n    if abs(diff) > 1e-3:\n        if diff > 0:\n            candidates = []\n            for i in committed:\n                if p_list[i] < ub_dict[i]:\n                    unit = units_info[i]\n                    mc = unit['b_i'] if unit['c_i'] < 1e-6 else unit['b_i'] + 2 * unit['c_i'] * p_list[i]\n                    headroom = ub_dict[i] - p_list[i]\n                    candidates.append((i, mc, headroom))\n            candidates.sort(key=lambda x: (x[1], x[0]))\n            remaining = diff\n            for i, mc, headroom in candidates:\n                if remaining <= headroom:\n                    p_list[i] += remaining\n                    remaining = 0\n                    break\n                else:\n                    p_list[i] = ub_dict[i]\n                    remaining -= headroom\n        else:\n            diff_abs = -diff\n            candidates = []\n            for i in committed:\n                if p_list[i] > lb_dict[i]:\n                    unit = units_info[i]\n                    mc = unit['b_i'] if unit['c_i'] < 1e-6 else unit['b_i'] + 2 * unit['c_i'] * p_list[i]\n                    headroom = p_list[i] - lb_dict[i]\n                    candidates.append((i, mc, headroom))\n            candidates.sort(key=lambda x: (-x[1], x[0]))\n            remaining = diff_abs\n            for i, mc, headroom in candidates:\n                if remaining <= headroom:\n                    p_list[i] -= remaining\n                    remaining = 0\n                    break\n                else:\n                    p_list[i] = lb_dict[i]\n                    remaining -= headroom\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00604,
          "other_inf": null
     },
     {
          "algorithm": "** \nThe algorithm uses a priority list method combined with a local search technique. It starts by categorizing units into forced-on, forced-off, and free units based on their physical limitations. Free units are prioritized by their average production cost at their midpoint output. The initial commitment greedily adds free units in priority order until the load can be met. An economic dispatch using lambda iteration allocates power optimally among committed units while respecting ramp and output limits. A local search then refines the solution by considering: decommitting expensive free units, adding uncommitted cheap units, or swapping expensive units for cheaper uncommitted ones. Each candidate solution undergoes feasibility checks, economic dispatch, and cost evaluation to ensure improvements while meeting all constraints.\n\n**",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        total_min, total_max = compute_power_bounds(committed)\n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00607,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm starts by identifying forced on/off units based on prior states and constraints. It commits forced-on units and calculates power bounds. Free units are sorted by average cost. Units are added until the total max output meets the load. A decommitment phase follows: expensive free units are removed if feasible without violating load constraints. Initial dispatch is performed. Local search generates candidates via single removals, additions, and swaps of free units, with cost minimized to select the best solution.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute forced on/off status\n    forced_on = []\n    forced_off = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            forced_on.append(unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n            forced_off.append(False)\n        else:\n            forced_on.append(False)\n            forced_off.append(abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    def compute_power_bounds(committed):\n        total_min = 0\n        total_max = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n\n    def economic_dispatch(committed):\n        lb_vec = {}\n        ub_vec = {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_vec[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_vec[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_vec[i] = unit['p_min_i']\n                ub_vec[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0] * n_units\n        if not committed:\n            return p_list, 0\n\n        low_lam, high_lam = -10000, 10000\n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_vec[i] if mid_lam > unit['b_i'] else lb_vec[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n                total_power += p_val\n                \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        final_lam = (low_lam + high_lam) / 2\n        total_output = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_vec[i] if final_lam > unit['b_i'] else lb_vec[i]\n            else:\n                p_val = (final_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_vec[i], min(ub_vec[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        diff = current_load - total_output\n        if abs(diff) > 1e-3:\n            non_bound = [i for i in committed if lb_vec[i] < p_list[i] < ub_vec[i]]\n            if non_bound:\n                adj = diff / len(non_bound)\n                for i in non_bound:\n                    p_list[i] = max(lb_vec[i], min(ub_vec[i], p_list[i] + adj))\n        \n        return p_list, sum(p_list)\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    total_min, total_max = compute_power_bounds(committed)\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    if free_units:\n        avg_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            mid = (unit['p_min_i'] + unit['p_max_i']) / 2\n            cost_val = (unit['a_i'] + unit['b_i'] * mid + unit['c_i'] * mid**2) / mid\n            avg_costs.append(cost_val)\n        sorted_free = [x for _, x in sorted(zip(avg_costs, free_units))]\n        \n        for unit_idx in sorted_free:\n            if total_max < current_load:\n                committed.append(unit_idx)\n                total_min, total_max = compute_power_bounds(committed)\n            else:\n                break\n                \n        committed_free = [i for i in committed if i in free_units]\n        if committed_free:\n            avg_costs_dict = {}\n            for idx, i in enumerate(free_units):\n                avg_costs_dict[i] = avg_costs[idx]\n            removal_candidates = [(avg_costs_dict[i], i) for i in committed_free]\n            removal_candidates.sort(key=lambda x: x[0], reverse=True)\n            for cost_val, unit_idx in removal_candidates:\n                candidate_committed = [j for j in committed if j != unit_idx]\n                total_min_candidate, total_max_candidate = compute_power_bounds(candidate_committed)\n                if total_min_candidate <= current_load <= total_max_candidate:\n                    committed = candidate_committed\n                    total_min, total_max = total_min_candidate, total_max_candidate\n    \n    dispatch, _ = economic_dispatch(committed)\n    current_cost = compute_total_cost(committed, dispatch)\n    \n    # Local search\n    free_committed = [i for i in committed if i in free_units]\n    uncommitted_free = [i for i in free_units if i not in committed]\n    candidates = [(committed, dispatch, current_cost)]\n    \n    for i in free_committed:\n        candidate_committed = [j for j in committed if j != i]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for j in uncommitted_free:\n        candidate_committed = committed + [j]\n        candidate_dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, candidate_dispatch)\n        candidates.append((candidate_committed, candidate_dispatch, cost))\n        \n    for i in free_committed:\n        for j in uncommitted_free:\n            candidate_committed = [k for k in committed if k != i] + [j]\n            candidate_dispatch, _ = economic_dispatch(candidate_committed)\n            cost = compute_total_cost(candidate_committed, candidate_dispatch)\n            candidates.append((candidate_committed, candidate_dispatch, cost))\n            \n    best_candidate = min(candidates, key=lambda x: x[2])\n    final_committed = best_candidate[0]\n    final_dispatch = best_candidate[1]\n    u_list = [1 if i in final_committed else 0 for i in range(n_units)]\n    \n    return np.array([u_list, final_dispatch])",
          "objective": 0.00612,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm enhances the priority scoring by incorporating dynamic load change factors for startup cost adjustment, introducing a responsiveness factor based on ramp capabilities relative to the required power change, and adding a proximity penalty for units nearing min up/down time violations. Key steps:\n1. Identify forced on/off units\n2. Calculate priority scores with:\n   - Base cost at average operating point\n   - Load-change-adjusted startup cost: Factor depends on relative load difference\n   - Responsiveness factor: Ramp capability vs required change to reach optimal power\n   - Proximity penalty for units close to min up/down limits\n3. Form initial commitment with forced-on units and prioritized free units\n4. Refine commitment by removing high-cost units while ensuring feasibility\n5. Perform lambda-iteration economic dispatch with predictive bounds\n6. Apply proportional adjustment for exact load matching\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n    \n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_power = [0] * n_units\n    max_power = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        # Determine power bounds\n        if unit['u_i_0'] == 1:  # Was online\n            min_power[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_power[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            forced_on[i] = (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])\n        else:  # Was offline\n            min_power[i] = unit['p_min_i']\n            max_power[i] = min(unit['p_max_i'], unit['p_start_i'])\n            forced_off[i] = (abs(unit['t_i_0']) < unit['t_off_min_i'])\n    \n    # Calculate enhanced priority scores\n    scores = {}\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    for i in free_units:\n        unit = units_info[i]\n        avg_power = (unit['p_min_i'] + unit['p_max_i']) / 2\n        base_cost = unit['a_i'] + unit['b_i'] * avg_power + unit['c_i'] * avg_power**2\n        \n        # Load-change-adjusted startup cost\n        if unit['u_i_0'] == 0:\n            load_ratio = (next_load - current_load) / max(current_load, 1)\n            load_factor = min(1.0, max(-1.0, 0.6 * load_ratio))\n            adj_startup = unit['s_i'] * (1 - load_factor)\n        else:\n            adj_startup = 0\n            \n        # Responsiveness factor\n        target_power = avg_power\n        if unit['u_i_0'] == 1:  # Online\n            power_delta = abs(target_power - unit['p_i_0'])\n            ramp_cap = unit['p_up_i'] if target_power > unit['p_i_0'] else unit['p_down_i']\n        else:  # Offline\n            power_delta = abs(target_power)\n            ramp_cap = unit['p_start_i']\n        responsiveness = min(1.0, ramp_cap / power_delta) if power_delta > 0 else 1.0\n        \n        # Proximity penalty\n        proximity_penalty = 1.0\n        if unit['u_i_0'] == 1 and unit['t_on_min_i'] - unit['t_i_0'] < 2:\n            proximity_penalty = 1.2\n        elif unit['u_i_0'] == 0 and unit['t_off_min_i'] - abs(unit['t_i_0']) < 2:\n            proximity_penalty = 1.2\n            \n        # Final score calculation\n        scores[i] = (base_cost + adj_startup) / (avg_power * max(0.1, responsiveness)) * proximity_penalty\n\n    # Initial commitment\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_sorted = sorted(free_units, key=lambda i: scores[i])\n    \n    total_min = sum(min_power[i] for i in committed)\n    total_max = sum(max_power[i] for i in committed)\n    \n    for i in free_sorted:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_power[i]\n            total_max += max_power[i]\n    \n    # Refinement with progressive feasibility check\n    free_in_commit = [i for i in committed if i in free_units]\n    if free_in_commit:\n        cost_sorted = sorted(free_in_commit, key=lambda i: scores[i], reverse=True)\n        for i in cost_sorted:\n            temp_commit = [j for j in committed if j != i]\n            temp_min = total_min - min_power[i]\n            temp_max = total_max - max_power[i]\n            if temp_min <= current_load <= temp_max:\n                committed = temp_commit\n                total_min = temp_min\n                total_max = temp_max\n    \n    # Economic dispatch\n    p_list = [0.0] * n_units\n    lb_dict = {}\n    ub_dict = {}\n    for i in committed:\n        lb_dict[i] = min_power[i]\n        ub_dict[i] = max_power[i]\n    \n    # Lambda iteration setup\n    lam_low = float('inf')\n    lam_high = -float('inf')\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            lam_low = min(lam_low, unit['b_i'])\n            lam_high = max(lam_high, unit['b_i'])\n        else:\n            lam_low = min(lam_low, unit['b_i'] + 2*unit['c_i']*lb_dict[i])\n            lam_high = max(lam_high, unit['b_i'] + 2*unit['c_i']*ub_dict[i])\n    \n    lam_low -= 100\n    lam_high += 100\n    \n    # Bisection method\n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2\n        total_power = 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            total_power += p_val\n        \n        if total_power < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n        if abs(lam_high - lam_low) < 1e-6:\n            break\n    \n    # Final dispatch\n    total_output = 0\n    for i in committed:\n        unit = units_info[i]\n        if unit['c_i'] < 1e-6:\n            p_val = ub_dict[i] if lam > unit['b_i'] else lb_dict[i]\n        else:\n            p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n        p_list[i] = p_val\n        total_output += p_val\n    \n    # Proportional adjustment\n    deviation = current_load - total_output\n    if abs(deviation) > 1e-3:\n        adjustable = []\n        for i in committed:\n            unit = units_info[i]\n            theoretical_min = max(unit['p_min_i'], p_list[i] - unit['p_down_i'])\n            theoretical_max = min(unit['p_max_i'], p_list[i] + unit['p_up_i'])\n            if p_list[i] > theoretical_min and p_list[i] < theoretical_max:\n                adjustable.append(i)\n        \n        if adjustable:\n            adj_per_unit = deviation / len(adjustable)\n            for i in adjustable:\n                p_list[i] += adj_per_unit\n                p_list[i] = max(min_power[i], min(max_power[i], p_list[i]))\n    \n    u_list = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_list, p_list])",
          "objective": 0.00615,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm employs a multi-strategy candidate generation approach with refinement. Initially, forced-on units are committed. Three distinct strategies create candidate solutions by adding free units: Strategy1 uses ascending average cost at midpoint, Strategy2 uses descending maximum output, and Strategy3 uses a flexibility-adjusted cost metric. Each candidate undergoes redundant removal of the least beneficial free unit and a one-step steepest swap optimization. The best candidate is selected by cost after economic dispatch.\n\n",
          "code": "import numpy as np\n\ndef schedule(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Identify forced-on and forced-off units\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            forced_on[i] = unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']\n        else:\n            forced_off[i] = abs(unit['t_i_0']) < unit['t_off_min_i']\n    \n    base_commit = [i for i in range(n_units) if forced_on[i]]\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    \n    # Helper functions\n    def power_bounds(committed):\n        total_min, total_max = 0, 0\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += lb\n            total_max += ub\n        return total_min, total_max\n    \n    def economic_dispatch(committed):\n        if not committed:\n            return [0.0] * n_units, 0.0\n        lb_dict, ub_dict = {}, {}\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                lb_dict[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                lb_dict[i] = unit['p_min_i']\n                ub_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_list = [0.0] * n_units\n        low_lam, high_lam = -10000.0, 10000.0\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] < 1e-6:\n                    p_val = ub_dict[i] if mid_lam > unit['b_i'] else lb_dict[i]\n                else:\n                    p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n                p_list[i] = p_val\n                total_power += p_val\n            \n            if total_power < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if abs(high_lam - low_lam) < 1e-6:\n                break\n        \n        total_output = 0.0\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] < 1e-6:\n                p_val = ub_dict[i] if mid_lam > unit['b_i'] else lb_dict[i]\n            else:\n                p_val = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(lb_dict[i], min(ub_dict[i], p_val))\n            p_list[i] = p_val\n            total_output += p_val\n        \n        return p_list, total_output\n    \n    def compute_total_cost(committed, dispatch):\n        total_cost = 0.0\n        for i in committed:\n            unit = units_info[i]\n            p_val = dispatch[i]\n            if unit['u_i_0'] == 0 and i in free_units:\n                total_cost += unit['s_i']\n            total_cost += unit['a_i'] + unit['b_i'] * p_val + unit['c_i'] * p_val**2\n        load_dev = abs(current_load - sum(dispatch))\n        return total_cost + 1000 * load_dev\n    \n    # Generate candidates\n    candidates = []\n    \n    # Base candidate\n    total_min_base, total_max_base = power_bounds(base_commit)\n    if total_min_base <= current_load <= total_max_base:\n        dispatch_base, _ = economic_dispatch(base_commit)\n        cost_base = compute_total_cost(base_commit, dispatch_base)\n        candidates.append((base_commit, dispatch_base, cost_base))\n    \n    # Define strategies\n    def strategy1_metric(i):\n        unit = units_info[i]\n        mid = (unit['p_min_i'] + unit['p_max_i']) / 2.0\n        return (unit['a_i'] + unit['b_i']*mid + unit['c_i']*mid**2) / mid\n        \n    def strategy2_metric(i):\n        return units_info[i]['p_max_i']\n    \n    def strategy3_metric(i):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n        if unit['u_i_0'] == 0:\n            cost += unit['s_i']\n        return cost / (unit['p_min_i'] * (unit['p_up_i'] + unit['p_down_i'] + 1e-5))\n    \n    strategies = [\n        (strategy1_metric, lambda x: x),\n        (strategy2_metric, lambda x: -x),\n        (strategy3_metric, lambda x: x)\n    ]\n    \n    for metric, sort_key in strategies:\n        candidate_committed = base_commit[:]\n        sorted_free = sorted(free_units, key=lambda i: sort_key(metric(i)))\n        total_min, total_max = power_bounds(candidate_committed)\n        \n        for i in sorted_free:\n            if total_max < current_load:\n                candidate_committed.append(i)\n                total_min, total_max = power_bounds(candidate_committed)\n        \n        # Remove redundant free units\n        free_in_commit = [i for i in candidate_committed if i in free_units]\n        if free_in_commit:\n            free_sorted = sorted(free_in_commit, key=lambda i: metric(i), reverse=isinstance(sort_key(0), float))\n            for i in free_sorted:\n                new_commit = [j for j in candidate_committed if j != i]\n                new_min, new_max = power_bounds(new_commit)\n                if new_min <= current_load <= new_max:\n                    candidate_committed = new_commit\n                    break\n        \n        # One-step steepest swap\n        dispatch, _ = economic_dispatch(candidate_committed)\n        best_cost = compute_total_cost(candidate_committed, dispatch)\n        free_in = [i for i in candidate_committed if i in free_units]\n        free_out = [i for i in free_units if i not in candidate_committed]\n        best_swap = None\n        \n        for i in free_in:\n            for j in free_out:\n                swap_commit = [x for x in candidate_committed if x != i] + [j]\n                swap_min, swap_max = power_bounds(swap_commit)\n                if not (swap_min <= current_load <= swap_max):\n                    continue\n                swap_dispatch, _ = economic_dispatch(swap_commit)\n                swap_cost = compute_total_cost(swap_commit, swap_dispatch)\n                if swap_cost < best_cost:\n                    best_cost = swap_cost\n                    best_swap = (swap_commit, swap_dispatch)\n        \n        if best_swap:\n            candidate_committed, dispatch = best_swap\n        else:\n            dispatch, _ = economic_dispatch(candidate_committed)\n        cost = compute_total_cost(candidate_committed, dispatch)\n        candidates.append((candidate_committed, dispatch, cost))\n    \n    # Select best candidate\n    if not candidates:\n        return np.zeros((2, n_units))\n    best_candidate = min(candidates, key=lambda x: x[2])\n    best_commit, best_dispatch, _ = best_candidate\n    u_list = [1 if i in best_commit else 0 for i in range(n_units)]\n    p_list = best_dispatch[:]\n    return np.array([u_list, p_list])",
          "objective": 0.00618,
          "other_inf": null
     }
]