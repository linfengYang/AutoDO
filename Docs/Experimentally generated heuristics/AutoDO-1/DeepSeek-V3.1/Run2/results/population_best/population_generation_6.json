{
     "name": "hybrid_rolling_cost_dispatch",
     "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including startup cost if unit was off, plus marginal cost adjustment for already-on units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
     "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    flexible_indices = []\n    committed_indices = []\n    \n    for i in range(n_units):\n        if must_run[i]:\n            committed_indices.append(i)\n        elif not must_off[i]:\n            flexible_indices.append(i)\n    \n    cost_index = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*unit['p_min_i']\n            avg_cost = 0.7*avg_cost + 0.3*marginal_cost\n        cost_index.append((avg_cost, i))\n    \n    cost_index.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    for cost, idx in cost_index:\n        if total_max >= load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_out\n        committed_indices.append(idx)\n    \n    if not committed_indices:\n        return np.array([u, p])\n    \n    ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((min_out, max_out))\n    \n    low = float('inf')\n    high = float('-inf')\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        mc_min = unit['b_i'] + 2*unit['c_i']*min_out\n        mc_max = unit['b_i'] + 2*unit['c_i']*max_out\n        low = min(low, mc_min)\n        high = max(high, mc_max)\n    \n    tol = 1e-6\n    max_iter = 1000\n    for _ in range(max_iter):\n        if abs(high - low) < tol:\n            break\n        lam = (low + high) / 2\n        total_p = 0\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            min_out, max_out = ranges[i]\n            if unit['c_i'] == 0:\n                p_i = max_out if lam > unit['b_i'] else min_out\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, min_out, max_out)\n            total_p += p_i\n        if total_p < load:\n            low = lam\n        else:\n            high = lam\n    \n    p_values = []\n    total_p = 0\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        if unit['c_i'] == 0:\n            p_i = max_out if lam > unit['b_i'] else min_out\n        else:\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, min_out, max_out)\n        p_values.append(p_i)\n        total_p += p_i\n    \n    gap = load - total_p\n    if abs(gap) > 1e-6:\n        adj_units = []\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            current_p = p_values[i]\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n            min_out, max_out = ranges[i]\n            adj_units.append((i, current_p, min_out, max_out, marginal_cost))\n        \n        if gap > 0:\n            adj_units.sort(key=lambda x: x[4])\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                add = min(max_out - current_p, gap)\n                p_values[i] += add\n                gap -= add\n        else:\n            adj_units.sort(key=lambda x: x[4], reverse=True)\n            gap = -gap\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                sub = min(current_p - min_out, gap)\n                p_values[i] -= sub\n                gap -= sub\n    \n    for i, idx in enumerate(committed_indices):\n        p[idx] = p_values[i]\n        u[idx] = 1\n    \n    return np.array([u, p])",
     "from": "crossover",
     "gap_power_rate": 0.00557,
     "gap_price_rate": 0.00906,
     "fitness": 0.00732
}