{
     "name": "enhanced_hybrid_rolling_dispatch",
     "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use average cost at maximum output with startup cost amortized over minimum up-time; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
     "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    max_available = np.zeros(n_units)\n    min_available = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            min_available[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_available[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            min_available[i] = unit['p_min_i']\n            max_available[i] = unit['p_start_i']\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        if u_i0 == 0 and t_i0 > -unit['t_off_min_i']:\n            must_off[i] = True\n    \n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_index = []\n    \n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            amortized_startup = unit['s_i'] / unit['t_on_min_i']\n            total_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i']**2) + amortized_startup\n            cost_index.append(total_cost / unit['p_max_i'])\n        else:\n            cost_index.append(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    committed = set()\n    total_max_avail = 0\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            committed.add(i)\n            total_max_avail += max_available[i]\n    \n    for i in sorted_flexible:\n        if total_max_avail >= load:\n            break\n        u[i] = 1\n        committed.add(i)\n        total_max_avail += max_available[i]\n    \n    low_bounds = []\n    high_bounds = []\n    units_dispatch = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_b = unit['p_min_i']\n            high_b = unit['p_start_i']\n        low_bounds.append(low_b)\n        high_bounds.append(high_b)\n        units_dispatch.append(i)\n    \n    if not committed:\n        return np.array([u, p])\n    \n    def total_gen(lam):\n        total = 0\n        for idx, i in enumerate(units_dispatch):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            low = low_bounds[idx]\n            high = high_bounds[idx]\n            if c == 0:\n                p_i = high if lam > b else low\n            else:\n                p_i = (lam - b) / (2 * c)\n                p_i = np.clip(p_i, low, high)\n            total += p_i\n        return total\n\n    min_marginal = float('inf')\n    max_marginal = -float('inf')\n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        marg_low = b + 2*c*low if c != 0 else b\n        marg_high = b + 2*c*high if c != 0 else b\n        min_marginal = min(min_marginal, marg_low)\n        max_marginal = max(max_marginal, marg_high)\n    \n    low_lam = min_marginal\n    high_lam = max_marginal\n    epsilon = 1e-5\n    max_iter = 100\n    \n    if low_lam == high_lam:\n        total_p = total_gen(low_lam)\n    else:\n        for _ in range(max_iter):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = total_gen(mid_lam)\n            if abs(total_p - load) < epsilon:\n                break\n            if total_p < load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        lam = (low_lam + high_lam) / 2\n        total_p = total_gen(lam)\n    \n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        if c == 0:\n            p_i = high if lam > b else low\n        else:\n            p_i = (lam - b) / (2 * c)\n            p_i = np.clip(p_i, low, high)\n        p[i] = p_i\n    \n    gap = load - total_p\n    if gap > 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)))]\n        for i in sorted_units:\n            if gap <= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_inc = high_bounds[idx] - p[i]\n            to_inc = min(gap, max_inc)\n            p[i] += to_inc\n            gap -= to_inc\n    elif gap < 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)), reverse=True)]\n        for i in sorted_units:\n            if gap >= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_dec = p[i] - low_bounds[idx]\n            to_dec = min(-gap, max_dec)\n            p[i] -= to_dec\n            gap += to_dec\n    \n    for i in range(n_units):\n        if must_off[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
     "from": "crossover",
     "gap_power_rate": 0.00499,
     "gap_price_rate": 0.00879,
     "fitness": 0.00689
}