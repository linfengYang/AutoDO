{
     "name": "enhanced_rolling_average_cost_dispatch",
     "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate average cost per MW at maximum output for flexible units, including startup cost if unit was previously off\n3. Sort flexible units by average cost in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using lambda iteration with ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load\n7. Validate solution against all physical constraints\n",
     "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u_prev = np.array([unit['u_i_0'] for unit in units_info])\n    t_prev = np.array([unit['t_i_0'] for unit in units_info])\n    p_prev = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if -t_prev[i] < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    u[must_run] = 1\n    u[must_off] = 0\n    \n    # Step 2-4: Commit flexible units by average cost\n    flexible_mask = ~(must_run | must_off)\n    flexible_idx = np.where(flexible_mask)[0]\n    \n    # Calculate average cost at max output\n    avg_costs = []\n    for i in flexible_idx:\n        if u_prev[i] == 0:\n            total_cost = startup_cost[i] + a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)\n        else:\n            total_cost = a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)\n        avg_costs.append(total_cost / p_max[i])\n    \n    # Sort by average cost\n    sorted_flexible = [x for _, x in sorted(zip(avg_costs, flexible_idx))]\n    \n    # Commit flexible units until load can be met\n    current_capacity = 0\n    committed = set(np.where(u == 1)[0])\n    \n    # Calculate available capacity from must-run units\n    for i in committed:\n        if u_prev[i] == 1:\n            max_output = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            max_output = min(p_max[i], p_start[i])\n        current_capacity += max_output\n    \n    # Commit flexible units in cost order\n    for i in sorted_flexible:\n        if current_capacity >= load:\n            break\n        if u_prev[i] == 1:\n            max_output = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            max_output = min(p_max[i], p_start[i])\n        current_capacity += max_output\n        u[i] = 1\n        committed.add(i)\n    \n    # Step 5: Economic dispatch using lambda iteration\n    committed_idx = list(committed)\n    n_committed = len(committed_idx)\n    \n    # Initialize bounds for lambda iteration\n    lambda_low = -1000\n    lambda_high = 1000\n    tolerance = 1e-5\n    \n    # Perform lambda iteration\n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed_idx:\n            # Calculate unconstrained output\n            p_unconstrained = (lambda_mid - b[i]) / (2 * c[i])\n            \n            # Apply constraints\n            if u_prev[i] == 1:\n                lb = max(p_min[i], p_prev[i] - p_down[i])\n                ub = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                lb = p_min[i]\n                ub = min(p_max[i], p_start[i])\n            \n            p[i] = np.clip(p_unconstrained, lb, ub)\n            total_p += p[i]\n        \n        if abs(total_p - load) < tolerance:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tune to match load exactly\n    total_p = sum(p[committed_idx])\n    error = load - total_p\n    \n    while abs(error) > tolerance:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed_idx:\n            if error > 0:  # Need to increase output\n                if u_prev[i] == 1:\n                    ub = min(p_max[i], p_prev[i] + p_up[i])\n                else:\n                    ub = min(p_max[i], p_start[i])\n                if p[i] < ub - tolerance:\n                    adjustable.append(i)\n            else:  # Need to decrease output\n                if u_prev[i] == 1:\n                    lb = max(p_min[i], p_prev[i] - p_down[i])\n                else:\n                    lb = p_min[i]\n                if p[i] > lb + tolerance:\n                    adjustable.append(i)\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost\n        marginal_costs = [b[i] + 2*c[i]*p[i] for i in adjustable]\n        if error > 0:\n            idx_to_adjust = adjustable[np.argmin(marginal_costs)]\n            max_increase = min(p_max[idx_to_adjust], p_prev[idx_to_adjust] + p_up[idx_to_adjust]) - p[idx_to_adjust]\n            adjustment = min(error, max_increase)\n            p[idx_to_adjust] += adjustment\n        else:\n            idx_to_adjust = adjustable[np.argmax(marginal_costs)]\n            max_decrease = p[idx_to_adjust] - max(p_min[idx_to_adjust], p_prev[idx_to_adjust] - p_down[idx_to_adjust])\n            adjustment = min(-error, max_decrease)\n            p[idx_to_adjust] -= adjustment\n        \n        error = load - sum(p[committed_idx])\n    \n    # Ensure off units have zero output\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
     "from": "crossover",
     "gap_power_rate": 0.00557,
     "gap_price_rate": 0.00921,
     "fitness": 0.00739
}