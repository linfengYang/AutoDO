{
     "name": "hybrid_rolling_cost_dispatch_v2",
     "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate hybrid cost index for flexible units: for offline units use average cost at maximum output including startup cost; for online units use marginal cost at minimum output\n3. Sort flexible units by hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
     "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    cost_index = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            cost_index.append(avg_cost)\n        else:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            cost_index.append(marginal_cost)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    total_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n        u[i] = 1\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p])\n    \n    lower_bounds = []\n    upper_bounds = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_min = sum(lower_bounds)\n    total_max = sum(upper_bounds)\n    \n    if total_max < load:\n        p_committed = upper_bounds\n    elif total_min > load:\n        p_committed = lower_bounds\n    else:\n        low = min(unit['b_i'] + 2*unit['c_i']*lb for unit, lb in zip([units_info[i] for i in committed_indices], lower_bounds))\n        high = max(unit['b_i'] + 2*unit['c_i']*ub for unit, ub in zip([units_info[i] for i in committed_indices], upper_bounds))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2\n            total_output = 0\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n                total_output += p_i\n            \n            if total_output < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_committed = []\n        for idx, i in enumerate(committed_indices):\n            unit = units_info[i]\n            p_i = (high - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n            p_committed.append(p_i)\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_committed[idx]\n    \n    total_output = sum(p)\n    diff = load - total_output\n    if abs(diff) > 1e-5:\n        committed_units = [units_info[i] for i in committed_indices]\n        current_outputs = [p[i] for i in committed_indices]\n        marginal_costs = [unit['b_i'] + 2*unit['c_i']*current_output for unit, current_output in zip(committed_units, current_outputs)]\n        \n        if diff > 0:\n            order = np.argsort(marginal_costs)\n            for idx in order:\n                i = committed_indices[idx]\n                available = upper_bounds[committed_indices.index(i)] - p[i]\n                if available > 0:\n                    add = min(diff, available)\n                    p[i] += add\n                    diff -= add\n                    if diff <= 0:\n                        break\n        else:\n            order = np.argsort(marginal_costs)[::-1]\n            for idx in order:\n                i = committed_indices[idx]\n                available = p[i] - lower_bounds[committed_indices.index(i)]\n                if available > 0:\n                    reduce = min(-diff, available)\n                    p[i] -= reduce\n                    diff += reduce\n                    if diff >= 0:\n                        break\n    \n    return np.array([u, p])",
     "from": "crossover",
     "gap_power_rate": 0.00557,
     "gap_price_rate": 0.00901,
     "fitness": 0.00729
}