[
     {
          "name": "hybrid_rolling_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including startup cost if unit was off, plus marginal cost adjustment for already-on units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    flexible_indices = []\n    committed_indices = []\n    \n    for i in range(n_units):\n        if must_run[i]:\n            committed_indices.append(i)\n        elif not must_off[i]:\n            flexible_indices.append(i)\n    \n    cost_index = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*unit['p_min_i']\n            avg_cost = 0.7*avg_cost + 0.3*marginal_cost\n        cost_index.append((avg_cost, i))\n    \n    cost_index.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    for cost, idx in cost_index:\n        if total_max >= load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_out\n        committed_indices.append(idx)\n    \n    if not committed_indices:\n        return np.array([u, p])\n    \n    ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((min_out, max_out))\n    \n    low = float('inf')\n    high = float('-inf')\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        mc_min = unit['b_i'] + 2*unit['c_i']*min_out\n        mc_max = unit['b_i'] + 2*unit['c_i']*max_out\n        low = min(low, mc_min)\n        high = max(high, mc_max)\n    \n    tol = 1e-6\n    max_iter = 1000\n    for _ in range(max_iter):\n        if abs(high - low) < tol:\n            break\n        lam = (low + high) / 2\n        total_p = 0\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            min_out, max_out = ranges[i]\n            if unit['c_i'] == 0:\n                p_i = max_out if lam > unit['b_i'] else min_out\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, min_out, max_out)\n            total_p += p_i\n        if total_p < load:\n            low = lam\n        else:\n            high = lam\n    \n    p_values = []\n    total_p = 0\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        if unit['c_i'] == 0:\n            p_i = max_out if lam > unit['b_i'] else min_out\n        else:\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, min_out, max_out)\n        p_values.append(p_i)\n        total_p += p_i\n    \n    gap = load - total_p\n    if abs(gap) > 1e-6:\n        adj_units = []\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            current_p = p_values[i]\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n            min_out, max_out = ranges[i]\n            adj_units.append((i, current_p, min_out, max_out, marginal_cost))\n        \n        if gap > 0:\n            adj_units.sort(key=lambda x: x[4])\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                add = min(max_out - current_p, gap)\n                p_values[i] += add\n                gap -= add\n        else:\n            adj_units.sort(key=lambda x: x[4], reverse=True)\n            gap = -gap\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                sub = min(current_p - min_out, gap)\n                p_values[i] -= sub\n                gap -= sub\n    \n    for i, idx in enumerate(committed_indices):\n        p[idx] = p_values[i]\n        u[idx] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00906,
          "fitness": 0.00732
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including prorated startup cost for offline units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost-based adjustment to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    cost_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        p0 = unit['p_i_0']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < ton_min or p0 > pshut):\n            must_run.append(i)\n        elif u0 == 0 and abs(t0) < toff_min:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            pmax = unit['p_max_i']\n            s = unit['s_i']\n            \n            if u0 == 0:\n                cost_index = (a + b*pmax + c*pmax**2 + s) / pmax\n            else:\n                cost_index = (a + b*pmax + c*pmax**2) / pmax\n            cost_indices.append(cost_index)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_indices, flexible))]\n    committed = set(must_run)\n    total_cap = 0.0\n    \n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in sorted_flexible:\n        if total_cap >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n    \n    min_limits = []\n    max_limits = []\n    committed_list = list(committed)\n    for i in committed_list:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        \n        if u0 == 1:\n            min_lim = max(pmin, p0 - pdown)\n            max_lim = min(pmax, p0 + pup)\n        else:\n            min_lim = pmin\n            max_lim = min(pmax, pstart)\n        min_limits.append(min_lim)\n        max_limits.append(max_lim)\n    \n    def total_gen(lmbda):\n        total = 0.0\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            minl = min_limits[idx]\n            maxl = max_limits[idx]\n            \n            if c == 0:\n                p_val = maxl if lmbda >= b else minl\n            else:\n                p_val = (lmbda - b) / (2 * c)\n                p_val = np.clip(p_val, minl, maxl)\n            total += p_val\n        return total\n\n    low = -1e6\n    high = 1e6\n    tol = 0.1\n    while high - low > tol:\n        mid = (low + high) / 2\n        if total_gen(mid) < load:\n            low = mid\n        else:\n            high = mid\n    \n    lambda_opt = (low + high) / 2\n    total_p = 0\n    for idx, i in enumerate(committed_list):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        minl = min_limits[idx]\n        maxl = max_limits[idx]\n        \n        if c == 0:\n            p_val = maxl if lambda_opt >= b else minl\n        else:\n            p_val = (lambda_opt - b) / (2 * c)\n            p_val = np.clip(p_val, minl, maxl)\n        p[i] = p_val\n        total_p += p_val\n    \n    mismatch = load - total_p\n    if abs(mismatch) > 1e-5:\n        margins = []\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            margin = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            margins.append((i, margin, p[i], min_limits[idx], max_limits[idx]))\n        \n        if mismatch > 0:\n            margins.sort(key=lambda x: x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = maxl - current\n                if avail > 0:\n                    add = min(avail, mismatch)\n                    p[i] += add\n                    mismatch -= add\n                    if mismatch <= 0:\n                        break\n        else:\n            margins.sort(key=lambda x: -x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = current - minl\n                if avail > 0:\n                    sub = min(avail, -mismatch)\n                    p[i] -= sub\n                    mismatch += sub\n                    if mismatch >= 0:\n                        break\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00912,
          "fitness": 0.00733
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate average cost per MW at maximum output for flexible units, including startup cost if unit was previously off\n3. Sort flexible units by average cost in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using lambda iteration with ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load\n7. Validate solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u_prev = np.array([unit['u_i_0'] for unit in units_info])\n    t_prev = np.array([unit['t_i_0'] for unit in units_info])\n    p_prev = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if -t_prev[i] < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    u[must_run] = 1\n    u[must_off] = 0\n    \n    # Step 2-4: Commit flexible units by average cost\n    flexible_mask = ~(must_run | must_off)\n    flexible_idx = np.where(flexible_mask)[0]\n    \n    # Calculate average cost at max output\n    avg_costs = []\n    for i in flexible_idx:\n        if u_prev[i] == 0:\n            total_cost = startup_cost[i] + a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)\n        else:\n            total_cost = a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)\n        avg_costs.append(total_cost / p_max[i])\n    \n    # Sort by average cost\n    sorted_flexible = [x for _, x in sorted(zip(avg_costs, flexible_idx))]\n    \n    # Commit flexible units until load can be met\n    current_capacity = 0\n    committed = set(np.where(u == 1)[0])\n    \n    # Calculate available capacity from must-run units\n    for i in committed:\n        if u_prev[i] == 1:\n            max_output = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            max_output = min(p_max[i], p_start[i])\n        current_capacity += max_output\n    \n    # Commit flexible units in cost order\n    for i in sorted_flexible:\n        if current_capacity >= load:\n            break\n        if u_prev[i] == 1:\n            max_output = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            max_output = min(p_max[i], p_start[i])\n        current_capacity += max_output\n        u[i] = 1\n        committed.add(i)\n    \n    # Step 5: Economic dispatch using lambda iteration\n    committed_idx = list(committed)\n    n_committed = len(committed_idx)\n    \n    # Initialize bounds for lambda iteration\n    lambda_low = -1000\n    lambda_high = 1000\n    tolerance = 1e-5\n    \n    # Perform lambda iteration\n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed_idx:\n            # Calculate unconstrained output\n            p_unconstrained = (lambda_mid - b[i]) / (2 * c[i])\n            \n            # Apply constraints\n            if u_prev[i] == 1:\n                lb = max(p_min[i], p_prev[i] - p_down[i])\n                ub = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                lb = p_min[i]\n                ub = min(p_max[i], p_start[i])\n            \n            p[i] = np.clip(p_unconstrained, lb, ub)\n            total_p += p[i]\n        \n        if abs(total_p - load) < tolerance:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tune to match load exactly\n    total_p = sum(p[committed_idx])\n    error = load - total_p\n    \n    while abs(error) > tolerance:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed_idx:\n            if error > 0:  # Need to increase output\n                if u_prev[i] == 1:\n                    ub = min(p_max[i], p_prev[i] + p_up[i])\n                else:\n                    ub = min(p_max[i], p_start[i])\n                if p[i] < ub - tolerance:\n                    adjustable.append(i)\n            else:  # Need to decrease output\n                if u_prev[i] == 1:\n                    lb = max(p_min[i], p_prev[i] - p_down[i])\n                else:\n                    lb = p_min[i]\n                if p[i] > lb + tolerance:\n                    adjustable.append(i)\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost\n        marginal_costs = [b[i] + 2*c[i]*p[i] for i in adjustable]\n        if error > 0:\n            idx_to_adjust = adjustable[np.argmin(marginal_costs)]\n            max_increase = min(p_max[idx_to_adjust], p_prev[idx_to_adjust] + p_up[idx_to_adjust]) - p[idx_to_adjust]\n            adjustment = min(error, max_increase)\n            p[idx_to_adjust] += adjustment\n        else:\n            idx_to_adjust = adjustable[np.argmax(marginal_costs)]\n            max_decrease = p[idx_to_adjust] - max(p_min[idx_to_adjust], p_prev[idx_to_adjust] - p_down[idx_to_adjust])\n            adjustment = min(-error, max_decrease)\n            p[idx_to_adjust] -= adjustment\n        \n        error = load - sum(p[committed_idx])\n    \n    # Ensure off units have zero output\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00921,
          "fitness": 0.00739
     },
     {
          "name": "enhanced_rolling_priority_dispatch",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints\n2. Sort available units by marginal cost at minimum output plus prorated startup cost\n3. Commit must-run units first, then activate additional units in sorted order until load can be met\n4. Perform economic dispatch using lambda iteration with ramp constraints\n5. Fine-tune outputs using marginal cost ordering to exactly match load\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitments\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Calculate available capacity from must-run units\n    total_min = 0\n    total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    # Sort available units by cost criteria\n    available_units = []\n    for i in range(n_units):\n        if i not in must_run and i not in must_off:\n            unit = units_info[i]\n            marginal_cost = 2 * unit['c_i'] * unit['p_min_i'] + unit['b_i']\n            avg_startup_cost = unit['s_i'] / unit['p_max_i'] if unit['p_max_i'] > 0 else float('inf')\n            priority = marginal_cost + avg_startup_cost\n            available_units.append((priority, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    # Commit additional units if needed\n    if total_max < load:\n        for _, i in available_units:\n            if total_max >= load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += p_max\n    \n    # Economic dispatch with ramp constraints\n    committed = [i for i in range(n_units) if u[i] == 1]\n    # Set initial outputs to minimum feasible\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n    \n    total_p = sum(p)\n    \n    # Lambda iteration for dispatch\n    max_iter = 100\n    tolerance = 1e-6\n    for _ in range(max_iter):\n        # Calculate marginal costs\n        marginal_costs = [2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i'] for i in committed]\n        lambda_val = sum(marginal_costs) / len(committed) if committed else 0\n        \n        # Adjust outputs\n        for i in committed:\n            unit = units_info[i]\n            # Calculate feasible range\n            if unit['u_i_0'] == 1:\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_low = unit['p_min_i']\n                p_high = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Calculate unconstrained output\n            p_unconstrained = (lambda_val - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_high\n            new_p = max(p_low, min(p_high, p_unconstrained))\n            \n            # Update total power\n            total_p = total_p - p[i] + new_p\n            p[i] = new_p\n        \n        if abs(total_p - load) < tolerance:\n            break\n    \n    # Fine-tuning to match load exactly\n    diff = load - total_p\n    while abs(diff) > tolerance:\n        # Find units to adjust\n        if diff > 0:\n            # Increase output of unit with smallest marginal cost\n            candidates = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_high = min(unit['p_max_i'], unit['p_start_i'])\n                if p[i] < p_high:\n                    marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                    candidates.append((marginal_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            i = candidates[0][1]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_high = min(unit['p_max_i'], unit['p_start_i'])\n            max_increase = min(diff, p_high - p[i])\n            p[i] += max_increase\n            diff -= max_increase\n        else:\n            # Decrease output of unit with largest marginal cost\n            candidates = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_low = unit['p_min_i']\n                if p[i] > p_low:\n                    marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                    candidates.append((marginal_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            i = candidates[0][1]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_low = unit['p_min_i']\n            max_decrease = min(-diff, p[i] - p_low)\n            p[i] -= max_decrease\n            diff += max_decrease\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00571,
          "gap_price_rate": 0.01075,
          "fitness": 0.00823
     },
     {
          "name": "rolling_priority_list_with_ramp",
          "algorithm": "1. Identify must-run units based on minimum up-time and shutdown ramp constraints\n2. Sort available units by average cost including startup cost\n3. Commit must-run units first, then additional units until load is met\n4. Perform economic dispatch considering ramp constraints and cost optimization\n5. Adjust outputs to match load exactly using marginal cost ordering\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_with_ramp(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = [False] * n_units\n    must_run = [False] * n_units\n    max_outputs = [0.0] * n_units\n    min_outputs = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n                committed[i] = True\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            if -unit['t_i_0'] >= unit['t_off_min_i']:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n                min_outputs[i] = unit['p_min_i']\n            else:\n                max_outputs[i] = 0\n                min_outputs[i] = 0\n\n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not committed[i] and max_outputs[i] > 0:\n            avg_cost = (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            available_units.append((avg_cost, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    current_capacity = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    for _, idx in available_units:\n        if current_capacity < load:\n            committed[idx] = True\n            current_capacity += max_outputs[idx]\n        else:\n            break\n\n    total_min = sum(min_outputs[i] for i in range(n_units) if committed[i])\n    total_max = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    \n    if total_min > load:\n        for i in range(n_units):\n            if committed[i] and not must_run[i]:\n                committed[i] = False\n                total_min -= min_outputs[i]\n                if total_min <= load:\n                    break\n        if total_min > load:\n            for i in range(n_units):\n                if committed[i] and must_run[i]:\n                    schedules[0][i] = 1\n                    schedules[1][i] = min_outputs[i]\n            return schedules\n\n    outputs = [min_outputs[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = load - total_min\n    \n    while remaining_load > 1e-6:\n        best_marginal = float('inf')\n        best_idx = -1\n        for i in range(n_units):\n            if committed[i] and outputs[i] < max_outputs[i]:\n                marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = i\n        if best_idx == -1:\n            break\n        \n        add_cap = min(remaining_load, max_outputs[best_idx] - outputs[best_idx])\n        outputs[best_idx] += add_cap\n        remaining_load -= add_cap\n\n    for i in range(n_units):\n        schedules[0][i] = 1 if committed[i] else 0\n        schedules[1][i] = outputs[i] if committed[i] else 0\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00624,
          "gap_price_rate": 0.0108,
          "fitness": 0.00852
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown capacity constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If needed, commit flexible units sorted by average cost per MW at maximum output\n4. Perform economic dispatch using greedy incremental cost method respecting ramp constraints\n5. Adjust outputs to match load while minimizing cost\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_cap = 0\n    total_max_cap = 0\n    bounds = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    flexible_sorted = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        flexible_sorted.append((cost_per_mw, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    for cost, i in flexible_sorted:\n        if total_max_cap >= load:\n            break\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    committed = [i for i in range(n_units) if u[i] == 1]\n    for i in committed:\n        p[i] = bounds[i][0]\n        \n    remaining = load - sum(p)\n    if remaining < 0:\n        remaining = 0\n        \n    active_units = committed.copy()\n    while remaining > 0 and active_units:\n        best_unit = None\n        best_marginal = float('inf')\n        for i in active_units:\n            unit = units_info[i]\n            marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            if marginal < best_marginal and p[i] < bounds[i][1]:\n                best_marginal = marginal\n                best_unit = i\n                \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        max_add = bounds[best_unit][1] - p[best_unit]\n        add = min(remaining, max_add)\n        p[best_unit] += add\n        remaining -= add\n        \n        if p[best_unit] >= bounds[best_unit][1]:\n            active_units.remove(best_unit)\n            \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "improved_rolling_priority_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: marginal cost at minimum output plus startup cost amortized over remaining minimum up-time for already-on units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef improved_rolling_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if t0[i] < min_up[i] or p0[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if -t0[i] < min_down[i]:\n                must_off[i] = True\n    \n    # Step 2: Calculate adjusted cost index for flexible units\n    adjusted_cost = np.full(n_units, np.inf)\n    for i in range(n_units):\n        if must_run[i] or must_off[i]:\n            continue\n        marginal_cost_min = b[i] + 2 * c[i] * p_min[i]\n        if u0[i] == 1:\n            remaining_up_time = max(1, min_up[i] - t0[i])\n            adjusted_cost[i] = marginal_cost_min + startup_cost[i] / remaining_up_time\n        else:\n            adjusted_cost[i] = marginal_cost_min + startup_cost[i] / min_up[i]\n    \n    # Step 3-4: Commit units\n    committed = must_run.copy()\n    available_capacity = 0\n    \n    # Add must-run units first\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            p_low = max(p_min[i], p0[i] - p_down[i]) if u0[i] == 1 else p_min[i]\n            p_high = min(p_max[i], p0[i] + p_up[i]) if u0[i] == 1 else p_start[i]\n            available_capacity += p_high\n    \n    # Add flexible units in cost order\n    sorted_indices = np.argsort(adjusted_cost)\n    for idx in sorted_indices:\n        if must_off[idx] or committed[idx]:\n            continue\n        if available_capacity >= load:\n            break\n        u[idx] = 1\n        committed[idx] = True\n        p_low = max(p_min[idx], p0[idx] - p_down[idx]) if u0[idx] == 1 else p_min[idx]\n        p_high = min(p_max[idx], p0[idx] + p_up[idx]) if u0[idx] == 1 else p_start[idx]\n        available_capacity += p_high\n    \n    # Step 5: Economic dispatch using bisection method\n    total_min = 0\n    total_max = 0\n    limits = []\n    for i in range(n_units):\n        if u[i] == 1:\n            if u0[i] == 1:\n                low = max(p_min[i], p0[i] - p_down[i])\n                high = min(p_max[i], p0[i] + p_up[i])\n            else:\n                low = p_min[i]\n                high = p_start[i]\n            total_min += low\n            total_max += high\n            limits.append((low, high))\n        else:\n            limits.append((0, 0))\n    \n    if total_min <= load <= total_max:\n        # Bisection method for lambda\n        lambda_low = 0\n        lambda_high = 1000\n        tolerance = 1e-6\n        while lambda_high - lambda_low > tolerance:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i in range(n_units):\n                if u[i] == 1:\n                    low, high = limits[i]\n                    p_dispatch = min(high, max(low, (lambda_mid - b[i]) / (2 * c[i])))\n                    total_p += p_dispatch\n            if total_p < load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Dispatch with final lambda\n        for i in range(n_units):\n            if u[i] == 1:\n                low, high = limits[i]\n                p[i] = min(high, max(low, (lambda_low - b[i]) / (2 * c[i])))\n    \n    # Step 6: Fine-tuning to match load exactly\n    current_total = np.sum(p)\n    diff = load - current_total\n    if abs(diff) > 1e-6:\n        # Calculate marginal costs\n        marginal_costs = b + 2 * c * p\n        # Adjust units in order of marginal cost\n        if diff > 0:\n            indices = np.argsort(marginal_costs)\n        else:\n            indices = np.argsort(-marginal_costs)\n        \n        for idx in indices:\n            if abs(diff) < 1e-6:\n                break\n            if u[idx] == 0:\n                continue\n            low, high = limits[idx]\n            adjustment = min(abs(diff), high - p[idx]) if diff > 0 else min(abs(diff), p[idx] - low)\n            p[idx] += adjustment if diff > 0 else -adjustment\n            diff -= adjustment if diff > 0 else -adjustment\n    \n    # Step 7: Validate constraints\n    for i in range(n_units):\n        if u[i] == 1:\n            assert p_min[i] <= p[i] <= p_max[i], f\"Unit {i} output out of bounds\"\n            if u0[i] == 1:\n                assert p[i] <= p0[i] + p_up[i], f\"Unit {i} ramp up violation\"\n                assert p[i] >= p0[i] - p_down[i], f\"Unit {i} ramp down violation\"\n            else:\n                assert p[i] <= p_start[i], f\"Unit {i} startup ramp violation\"\n    \n    return np.vstack((u, p))",
          "from": "mutation",
          "gap_power_rate": 0.00452,
          "gap_price_rate": 0.01583,
          "fitness": 0.01017
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch",
          "algorithm": "1. Identify must-run units (units violating minimum up-time or shutdown ramp constraints) and must-off units (units violating minimum down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output ((a_i + b_i*p_max_i + c_i*p_max_i**2)/p_max_i) plus prorated startup cost (s_i/t_on_min_i)\n3. Commit must-run units first, then activate flexible units in ascending adjusted cost order until available capacity meets load while ensuring minimum outputs don't exceed load\n4. Perform economic dispatch using bisection method (lambda iteration) with unit-specific ramp-aware output limits\n5. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n6. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u0[i] == 1:  # Unit was online\n            if t0[i] < min_up[i] or p0[i] > p_shut[i]:\n                must_run[i] = True\n        else:  # Unit was offline\n            if abs(t0[i]) < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment for must-run and must-off units\n    u[must_run] = 1\n    u[must_off] = 0\n    \n    # Calculate adjusted cost index for flexible units\n    cost_index = np.full(n_units, np.inf)\n    for i in range(n_units):\n        if not must_run[i] and not must_off[i]:\n            avg_cost = (a[i] + b[i]*p_max[i] + c[i]*p_max[i]**2) / p_max[i]\n            prorated_startup = startup_cost[i] / min_up[i]\n            cost_index[i] = avg_cost + prorated_startup\n    \n    # Commit flexible units in cost order\n    flexible_idx = np.where((~must_run) & (~must_off))[0]\n    sorted_flexible = flexible_idx[np.argsort(cost_index[flexible_idx])]\n    \n    current_capacity = 0\n    current_min_output = 0\n    \n    # Calculate current capacity from must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            if u0[i] == 1:\n                max_p = min(p_max[i], p0[i] + p_up[i])\n                min_p = max(p_min[i], p0[i] - p_down[i])\n            else:\n                max_p = min(p_max[i], p_start[i])\n                min_p = p_min[i]\n            current_capacity += max_p\n            current_min_output += min_p\n    \n    # Activate flexible units until load can be met\n    for i in sorted_flexible:\n        if current_capacity >= load:\n            break\n            \n        max_p = min(p_max[i], p_start[i]) if u0[i] == 0 else min(p_max[i], p0[i] + p_up[i])\n        min_p = p_min[i]\n        \n        if current_min_output + min_p <= load:\n            u[i] = 1\n            current_capacity += max_p\n            current_min_output += min_p\n    \n    # Economic dispatch using bisection method\n    committed = np.where(u == 1)[0]\n    if len(committed) == 0:\n        return np.array([u, p])\n    \n    # Determine output limits for committed units\n    p_low = np.zeros(len(committed))\n    p_high = np.zeros(len(committed))\n    for idx, i in enumerate(committed):\n        if u0[i] == 1:\n            p_low[idx] = max(p_min[i], p0[i] - p_down[i])\n            p_high[idx] = min(p_max[i], p0[i] + p_up[i])\n        else:\n            p_low[idx] = p_min[i]\n            p_high[idx] = min(p_max[i], p_start[i])\n    \n    # Lambda iteration\n    lambda_low = 0\n    lambda_high = 1000  # Sufficiently high initial value\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for idx, i in enumerate(committed):\n            p_i = (lambda_mid - b[i]) / (2 * c[i])\n            p_i = np.clip(p_i, p_low[idx], p_high[idx])\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Calculate final outputs\n    for idx, i in enumerate(committed):\n        p_i = (lambda_mid - b[i]) / (2 * c[i])\n        p[i] = np.clip(p_i, p_low[idx], p_high[idx])\n    \n    # Fine-tuning to match load exactly\n    total_p = np.sum(p)\n    error = load - total_p\n    n_committed = len(committed)\n    \n    while abs(error) > 1e-6 and n_committed > 0:\n        # Calculate marginal costs\n        mc = b[committed] + 2 * c[committed] * p[committed]\n        \n        if error > 0:\n            # Increase output of unit with lowest marginal cost\n            idx = np.argmin(mc)\n            i = committed[idx]\n            available = p_high[idx] - p[i]\n            adjustment = min(error, available)\n            p[i] += adjustment\n            error -= adjustment\n        else:\n            # Decrease output of unit with highest marginal cost\n            idx = np.argmax(mc)\n            i = committed[idx]\n            available = p[i] - p_low[idx]\n            adjustment = min(-error, available)\n            p[i] -= adjustment\n            error += adjustment\n        \n        if abs(adjustment) < 1e-6:\n            break\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00419,
          "gap_price_rate": 0.01618,
          "fitness": 0.01019
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch_v3",
          "algorithm": "1. Identify must-run units (units violating minimum up-time or shutdown ramp constraints) and must-off units (units violating minimum down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including prorated startup cost for offline units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load while ensuring minimum outputs don't exceed load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost-based adjustment to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch_v3(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    committed = []\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    # Step 1: Identify must-run and must-off units\n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 2: Calculate adjusted cost index for flexible units\n    adjusted_costs = []\n    for i in flexible:\n        unit = units[i]\n        avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        if unit['u_i_0'] == 0:\n            avg_cost += unit['s_i'] / (unit['t_on_min_i'] * unit['p_max_i'])\n        adjusted_costs.append(avg_cost)\n    \n    # Step 3: Sort flexible units by adjusted cost\n    flexible_sorted = [x for _, x in sorted(zip(adjusted_costs, flexible))]\n    \n    # Step 4: Commit units\n    committed = must_run.copy()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate current min/max for must-run units\n    for i in committed:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    # Add flexible units until load can be met\n    for i in flexible_sorted:\n        if i in must_off:\n            continue\n            \n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if total_min + p_min <= load:\n            committed.append(i)\n            total_min += p_min\n            total_max += p_max\n            if total_max >= load:\n                break\n    \n    # Step 5: Economic dispatch using bisection\n    p_outputs = np.zeros(n_units)\n    lambda_low = -1000.0\n    lambda_high = 1000.0\n    tolerance = 1e-6\n    \n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0.0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate output limits\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Calculate unconstrained output\n            p_unconstrained = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_constrained = max(p_min, min(p_max, p_unconstrained))\n            p_outputs[i] = p_constrained\n            total_p += p_constrained\n        \n        if abs(total_p - load) < tolerance:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tune outputs\n    current_total = np.sum(p_outputs)\n    error = load - current_total\n    \n    if error > 0:\n        # Sort by marginal cost ascending\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_outputs[i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for _, i in marginal_costs:\n            if error < tolerance:\n                break\n            unit = units[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n            available = p_max - p_outputs[i]\n            add = min(available, error)\n            p_outputs[i] += add\n            error -= add\n    \n    elif error < 0:\n        # Sort by marginal cost descending\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_outputs[i]\n            marginal_costs.append((marginal_cost, i))\n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in marginal_costs:\n            if abs(error) < tolerance:\n                break\n            unit = units[i]\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_min = unit['p_min_i']\n            \n            available = p_outputs[i] - p_min\n            subtract = min(available, abs(error))\n            p_outputs[i] -= subtract\n            error += subtract\n    \n    # Prepare output\n    u_outputs = np.zeros(n_units)\n    for i in committed:\n        u_outputs[i] = 1\n    \n    schedules = np.array([u_outputs, p_outputs])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00566,
          "gap_price_rate": 0.0191,
          "fitness": 0.01238
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch_v3",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including startup cost if unit was off\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch_v3(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        p_shut_i = unit['p_shut_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run[i] = True\n        else:\n            if t_i_0 > -t_off_min_i:\n                must_off[i] = True\n    \n    flexible_units = []\n    adjusted_costs = []\n    \n    for i, unit in enumerate(units_info):\n        if must_run[i] or must_off[i]:\n            continue\n            \n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_max_i = unit['p_max_i']\n        s_i = unit['s_i']\n        u_i_0 = unit['u_i_0']\n        \n        if u_i_0 == 0:\n            adjusted_cost = (a_i + b_i * p_max_i + c_i * p_max_i**2 + s_i) / p_max_i\n        else:\n            adjusted_cost = (a_i + b_i * p_max_i + c_i * p_max_i**2) / p_max_i\n            \n        flexible_units.append(i)\n        adjusted_costs.append(adjusted_cost)\n    \n    sorted_flexible = [i for _, i in sorted(zip(adjusted_costs, flexible_units))]\n    \n    committed = []\n    total_capacity = 0.0\n    \n    for i in range(n_units):\n        if must_run[i]:\n            committed.append(i)\n            total_capacity += units_info[i]['p_max_i']\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        committed.append(i)\n        total_capacity += units_info[i]['p_max_i']\n    \n    low_bounds = []\n    high_bounds = []\n    b_values = []\n    c_values = []\n    dispatch_units = []\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i_0 == 1:\n            low_bound = max(p_min_i, p_i_0 - p_down_i)\n            high_bound = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            low_bound = p_min_i\n            high_bound = min(p_max_i, p_start_i)\n            \n        low_bounds.append(low_bound)\n        high_bounds.append(high_bound)\n        b_values.append(unit['b_i'])\n        c_values.append(unit['c_i'])\n        dispatch_units.append(i)\n    \n    if not dispatch_units:\n        return schedules\n        \n    lambda_low = min(b_i + 2 * c_i * low_bounds[i] for i, (b_i, c_i) in enumerate(zip(b_values, c_values)))\n    lambda_high = max(b_i + 2 * c_i * high_bounds[i] for i, (b_i, c_i) in enumerate(zip(b_values, c_values)))\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0.0\n        \n        for i, (b_i, c_i) in enumerate(zip(b_values, c_values)):\n            p = (lambda_mid - b_i) / (2 * c_i)\n            p = max(low_bounds[i], min(high_bounds[i], p))\n            total_power += p\n            \n        if total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n            \n    outputs = []\n    total_power = 0.0\n    for i, (b_i, c_i) in enumerate(zip(b_values, c_values)):\n        p = (lambda_mid - b_i) / (2 * c_i)\n        p = max(low_bounds[i], min(high_bounds[i], p))\n        outputs.append(p)\n        total_power += p\n        \n    diff = load - total_power\n    if abs(diff) > 1e-5:\n        marginal_costs = []\n        for i, (b_i, c_i) in enumerate(zip(b_values, c_values)):\n            mc = b_i + 2 * c_i * outputs[i]\n            marginal_costs.append((mc, i))\n            \n        if diff > 0:\n            marginal_costs.sort(key=lambda x: x[0])\n            for mc, idx in marginal_costs:\n                if outputs[idx] < high_bounds[idx]:\n                    add = min(diff, high_bounds[idx] - outputs[idx])\n                    outputs[idx] += add\n                    diff -= add\n                    if diff <= 1e-5:\n                        break\n        else:\n            marginal_costs.sort(key=lambda x: x[0], reverse=True)\n            for mc, idx in marginal_costs:\n                if outputs[idx] > low_bounds[idx]:\n                    subtract = min(-diff, outputs[idx] - low_bounds[idx])\n                    outputs[idx] -= subtract\n                    diff += subtract\n                    if diff >= -1e-5:\n                        break\n                        \n    for i, unit_idx in enumerate(dispatch_units):\n        schedules[0, unit_idx] = 1\n        schedules[1, unit_idx] = outputs[i]\n        \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.02934,
          "gap_price_rate": 0.03463,
          "fitness": 0.03198
     }
]