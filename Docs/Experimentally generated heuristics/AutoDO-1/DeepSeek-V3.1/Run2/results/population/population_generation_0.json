[
     {
          "name": "rolling_priority_list_with_ramp",
          "algorithm": "1. Identify must-run units based on minimum up-time and shutdown ramp constraints\n2. Sort available units by average cost including startup cost\n3. Commit must-run units first, then additional units until load is met\n4. Perform economic dispatch considering ramp constraints and cost optimization\n5. Adjust outputs to match load exactly using marginal cost ordering\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_with_ramp(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = [False] * n_units\n    must_run = [False] * n_units\n    max_outputs = [0.0] * n_units\n    min_outputs = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n                committed[i] = True\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            if -unit['t_i_0'] >= unit['t_off_min_i']:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n                min_outputs[i] = unit['p_min_i']\n            else:\n                max_outputs[i] = 0\n                min_outputs[i] = 0\n\n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not committed[i] and max_outputs[i] > 0:\n            avg_cost = (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            available_units.append((avg_cost, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    current_capacity = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    for _, idx in available_units:\n        if current_capacity < load:\n            committed[idx] = True\n            current_capacity += max_outputs[idx]\n        else:\n            break\n\n    total_min = sum(min_outputs[i] for i in range(n_units) if committed[i])\n    total_max = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    \n    if total_min > load:\n        for i in range(n_units):\n            if committed[i] and not must_run[i]:\n                committed[i] = False\n                total_min -= min_outputs[i]\n                if total_min <= load:\n                    break\n        if total_min > load:\n            for i in range(n_units):\n                if committed[i] and must_run[i]:\n                    schedules[0][i] = 1\n                    schedules[1][i] = min_outputs[i]\n            return schedules\n\n    outputs = [min_outputs[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = load - total_min\n    \n    while remaining_load > 1e-6:\n        best_marginal = float('inf')\n        best_idx = -1\n        for i in range(n_units):\n            if committed[i] and outputs[i] < max_outputs[i]:\n                marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = i\n        if best_idx == -1:\n            break\n        \n        add_cap = min(remaining_load, max_outputs[best_idx] - outputs[best_idx])\n        outputs[best_idx] += add_cap\n        remaining_load -= add_cap\n\n    for i in range(n_units):\n        schedules[0][i] = 1 if committed[i] else 0\n        schedules[1][i] = outputs[i] if committed[i] else 0\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00624,
          "gap_price_rate": 0.0108,
          "fitness": 0.00852
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown capacity constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If needed, commit flexible units sorted by average cost per MW at maximum output\n4. Perform economic dispatch using greedy incremental cost method respecting ramp constraints\n5. Adjust outputs to match load while minimizing cost\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_cap = 0\n    total_max_cap = 0\n    bounds = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    flexible_sorted = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        flexible_sorted.append((cost_per_mw, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    for cost, i in flexible_sorted:\n        if total_max_cap >= load:\n            break\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    committed = [i for i in range(n_units) if u[i] == 1]\n    for i in committed:\n        p[i] = bounds[i][0]\n        \n    remaining = load - sum(p)\n    if remaining < 0:\n        remaining = 0\n        \n    active_units = committed.copy()\n    while remaining > 0 and active_units:\n        best_unit = None\n        best_marginal = float('inf')\n        for i in active_units:\n            unit = units_info[i]\n            marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            if marginal < best_marginal and p[i] < bounds[i][1]:\n                best_marginal = marginal\n                best_unit = i\n                \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        max_add = bounds[best_unit][1] - p[best_unit]\n        add = min(remaining, max_add)\n        p[best_unit] += add\n        remaining -= add\n        \n        if p[best_unit] >= bounds[best_unit][1]:\n            active_units.remove(best_unit)\n            \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Determine mandatory commitments based on minimum up/down times and shutdown ramp limits\n2. Initialize commitments using previous states and mandatory requirements\n3. Adjust commitments based on load demand:\n   - If load exceeds current capacity, activate units by ascending marginal cost at minimum output\n   - If load is below minimum capacity, deactivate units by descending marginal cost\n4. Perform economic dispatch considering ramp constraints:\n   - Set initial outputs to minimum feasible levels\n   - Increase outputs of units with lowest marginal costs first until load is met\n   - Decrease outputs of units with highest marginal costs if over generation occurs\n5. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                must_on[i] = True\n        else:\n            if abs(t0) < toff_min:\n                must_off[i] = True\n    \n    u = [0] * n_units\n    low_bounds = [0] * n_units\n    high_bounds = [0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n            \n    total_min = 0\n    total_max = 0\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_bounds[i] = unit['p_min_i']\n                high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low_bounds[i]\n            total_max += high_bounds[i]\n        else:\n            low_bounds[i] = 0\n            high_bounds[i] = 0\n\n    off_units = [i for i in range(n_units) if not u[i] and not must_off[i] and not must_on[i]]\n    off_units.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_min_i'] + units_info[i]['s_i']/units_info[i]['p_min_i'])\n    \n    for i in off_units:\n        if total_max >= load:\n            break\n        u[i] = 1\n        unit = units_info[i]\n        low_bounds[i] = unit['p_min_i']\n        high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += low_bounds[i]\n        total_max += high_bounds[i]\n\n    on_units_flex = [i for i in range(n_units) if u[i] == 1 and not must_on[i] and not must_off[i]]\n    on_units_flex.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_min_i'] + units_info[i]['s_i']/units_info[i]['p_min_i'], reverse=True)\n    \n    for i in on_units_flex:\n        if total_min <= load:\n            break\n        u[i] = 0\n        total_min -= low_bounds[i]\n        total_max -= high_bounds[i]\n        low_bounds[i] = 0\n        high_bounds[i] = 0\n\n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = low_bounds[i]\n        else:\n            p[i] = 0\n\n    total_output = sum(p)\n    \n    if total_output > load:\n        reducible = [i for i in range(n_units) if u[i] == 1 and p[i] > low_bounds[i]]\n        reducible.sort(key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'], reverse=True)\n        for i in reducible:\n            if total_output <= load:\n                break\n            reduction = min(total_output - load, p[i] - low_bounds[i])\n            p[i] -= reduction\n            total_output -= reduction\n    elif total_output < load:\n        increasable = [i for i in range(n_units) if u[i] == 1 and p[i] < high_bounds[i]]\n        increasable.sort(key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n        for i in increasable:\n            if total_output >= load:\n                break\n            increase = min(load - total_output, high_bounds[i] - p[i])\n            p[i] += increase\n            total_output += increase\n\n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 7e-05,
          "gap_price_rate": 0.04106,
          "fitness": 0.02056
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Identify must-run and must-off units based on min up/down times and shutdown ramp constraints\n2. Set must-run units to on and must-off units to off\n3. Calculate total output from must-run units considering ramp constraints\n4. If needed, turn on available units by priority (marginal cost + prorated startup cost)\n5. Dispatch load among committed units using economic dispatch considering ramp constraints\n6. Return schedule with commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_run = np.zeros(n, dtype=bool)\n    must_off = np.zeros(n, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_output = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p[i] = max(p_low, unit['p_min_i'])\n            p[i] = min(p[i], p_high)\n            total_output += p[i]\n        elif must_off[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i] and unit['p_min_i'] <= unit['p_start_i']:\n            priority = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'] + unit['s_i'] / unit['t_on_min_i']\n            available_units.append((i, priority))\n    \n    available_units.sort(key=lambda x: x[1])\n    \n    for idx, _ in available_units:\n        if total_output >= load:\n            break\n        unit = units_info[idx]\n        u[idx] = 1\n        p[idx] = unit['p_min_i']\n        total_output += p[idx]\n    \n    committed_idxs = [i for i in range(n) if u[i] == 1]\n    low_bounds = np.zeros(len(committed_idxs))\n    high_bounds = np.zeros(len(committed_idxs))\n    current_outputs = np.zeros(len(committed_idxs))\n    \n    for j, i in enumerate(committed_idxs):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_bounds[j] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[j] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bounds[j] = unit['p_min_i']\n            high_bounds[j] = min(unit['p_max_i'], unit['p_start_i'])\n        current_outputs[j] = p[i]\n    \n    total_min = np.sum(low_bounds)\n    remaining_load = load - total_min\n    \n    if remaining_load > 0:\n        marginal_costs = []\n        for j, i in enumerate(committed_idxs):\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[j]\n            marginal_costs.append((j, marginal_cost))\n        \n        marginal_costs.sort(key=lambda x: x[1])\n        \n        for j, _ in marginal_costs:\n            if remaining_load <= 0:\n                break\n            available = high_bounds[j] - current_outputs[j]\n            if available > 0:\n                add = min(remaining_load, available)\n                current_outputs[j] += add\n                remaining_load -= add\n        \n        for j, i in enumerate(committed_idxs):\n            p[i] = current_outputs[j]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.09239,
          "fitness": 0.04623
     }
]