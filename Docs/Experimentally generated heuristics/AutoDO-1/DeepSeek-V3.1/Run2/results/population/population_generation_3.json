[
     {
          "name": "enhanced_rolling_priority_dispatch",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints\n2. Sort available units by marginal cost at minimum output plus prorated startup cost\n3. Commit must-run units first, then activate additional units in sorted order until load can be met\n4. Perform economic dispatch using lambda iteration with ramp constraints\n5. Fine-tune outputs using marginal cost ordering to exactly match load\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitments\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Calculate available capacity from must-run units\n    total_min = 0\n    total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    # Sort available units by cost criteria\n    available_units = []\n    for i in range(n_units):\n        if i not in must_run and i not in must_off:\n            unit = units_info[i]\n            marginal_cost = 2 * unit['c_i'] * unit['p_min_i'] + unit['b_i']\n            avg_startup_cost = unit['s_i'] / unit['p_max_i'] if unit['p_max_i'] > 0 else float('inf')\n            priority = marginal_cost + avg_startup_cost\n            available_units.append((priority, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    # Commit additional units if needed\n    if total_max < load:\n        for _, i in available_units:\n            if total_max >= load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += p_max\n    \n    # Economic dispatch with ramp constraints\n    committed = [i for i in range(n_units) if u[i] == 1]\n    # Set initial outputs to minimum feasible\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n    \n    total_p = sum(p)\n    \n    # Lambda iteration for dispatch\n    max_iter = 100\n    tolerance = 1e-6\n    for _ in range(max_iter):\n        # Calculate marginal costs\n        marginal_costs = [2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i'] for i in committed]\n        lambda_val = sum(marginal_costs) / len(committed) if committed else 0\n        \n        # Adjust outputs\n        for i in committed:\n            unit = units_info[i]\n            # Calculate feasible range\n            if unit['u_i_0'] == 1:\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_low = unit['p_min_i']\n                p_high = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Calculate unconstrained output\n            p_unconstrained = (lambda_val - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_high\n            new_p = max(p_low, min(p_high, p_unconstrained))\n            \n            # Update total power\n            total_p = total_p - p[i] + new_p\n            p[i] = new_p\n        \n        if abs(total_p - load) < tolerance:\n            break\n    \n    # Fine-tuning to match load exactly\n    diff = load - total_p\n    while abs(diff) > tolerance:\n        # Find units to adjust\n        if diff > 0:\n            # Increase output of unit with smallest marginal cost\n            candidates = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_high = min(unit['p_max_i'], unit['p_start_i'])\n                if p[i] < p_high:\n                    marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                    candidates.append((marginal_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            i = candidates[0][1]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_high = min(unit['p_max_i'], unit['p_start_i'])\n            max_increase = min(diff, p_high - p[i])\n            p[i] += max_increase\n            diff -= max_increase\n        else:\n            # Decrease output of unit with largest marginal cost\n            candidates = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_low = unit['p_min_i']\n                if p[i] > p_low:\n                    marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                    candidates.append((marginal_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            i = candidates[0][1]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_low = unit['p_min_i']\n            max_decrease = min(-diff, p[i] - p_low)\n            p[i] -= max_decrease\n            diff += max_decrease\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00571,
          "gap_price_rate": 0.01075,
          "fitness": 0.00823
     },
     {
          "name": "rolling_priority_list_with_ramp",
          "algorithm": "1. Identify must-run units based on minimum up-time and shutdown ramp constraints\n2. Sort available units by average cost including startup cost\n3. Commit must-run units first, then additional units until load is met\n4. Perform economic dispatch considering ramp constraints and cost optimization\n5. Adjust outputs to match load exactly using marginal cost ordering\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_with_ramp(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = [False] * n_units\n    must_run = [False] * n_units\n    max_outputs = [0.0] * n_units\n    min_outputs = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n                committed[i] = True\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            if -unit['t_i_0'] >= unit['t_off_min_i']:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n                min_outputs[i] = unit['p_min_i']\n            else:\n                max_outputs[i] = 0\n                min_outputs[i] = 0\n\n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not committed[i] and max_outputs[i] > 0:\n            avg_cost = (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            available_units.append((avg_cost, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    current_capacity = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    for _, idx in available_units:\n        if current_capacity < load:\n            committed[idx] = True\n            current_capacity += max_outputs[idx]\n        else:\n            break\n\n    total_min = sum(min_outputs[i] for i in range(n_units) if committed[i])\n    total_max = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    \n    if total_min > load:\n        for i in range(n_units):\n            if committed[i] and not must_run[i]:\n                committed[i] = False\n                total_min -= min_outputs[i]\n                if total_min <= load:\n                    break\n        if total_min > load:\n            for i in range(n_units):\n                if committed[i] and must_run[i]:\n                    schedules[0][i] = 1\n                    schedules[1][i] = min_outputs[i]\n            return schedules\n\n    outputs = [min_outputs[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = load - total_min\n    \n    while remaining_load > 1e-6:\n        best_marginal = float('inf')\n        best_idx = -1\n        for i in range(n_units):\n            if committed[i] and outputs[i] < max_outputs[i]:\n                marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = i\n        if best_idx == -1:\n            break\n        \n        add_cap = min(remaining_load, max_outputs[best_idx] - outputs[best_idx])\n        outputs[best_idx] += add_cap\n        remaining_load -= add_cap\n\n    for i in range(n_units):\n        schedules[0][i] = 1 if committed[i] else 0\n        schedules[1][i] = outputs[i] if committed[i] else 0\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00624,
          "gap_price_rate": 0.0108,
          "fitness": 0.00852
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown capacity constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If needed, commit flexible units sorted by average cost per MW at maximum output\n4. Perform economic dispatch using greedy incremental cost method respecting ramp constraints\n5. Adjust outputs to match load while minimizing cost\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_cap = 0\n    total_max_cap = 0\n    bounds = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    flexible_sorted = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        flexible_sorted.append((cost_per_mw, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    for cost, i in flexible_sorted:\n        if total_max_cap >= load:\n            break\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    committed = [i for i in range(n_units) if u[i] == 1]\n    for i in committed:\n        p[i] = bounds[i][0]\n        \n    remaining = load - sum(p)\n    if remaining < 0:\n        remaining = 0\n        \n    active_units = committed.copy()\n    while remaining > 0 and active_units:\n        best_unit = None\n        best_marginal = float('inf')\n        for i in active_units:\n            unit = units_info[i]\n            marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            if marginal < best_marginal and p[i] < bounds[i][1]:\n                best_marginal = marginal\n                best_unit = i\n                \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        max_add = bounds[best_unit][1] - p[best_unit]\n        add = min(remaining, max_add)\n        p[best_unit] += add\n        remaining -= add\n        \n        if p[best_unit] >= bounds[best_unit][1]:\n            active_units.remove(best_unit)\n            \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "enhanced_rolling_amortized_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate amortized cost for flexible units (startup cost prorated over min up-time plus marginal cost at max output)\n3. Commit must-run units first, then flexible units in amortized cost order until load can be met\n4. Perform economic dispatch using lambda iteration with ramp-aware output limits\n5. Fine-tune outputs using marginal cost ordering to exactly match load\n6. Validate and enforce all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_amortized_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible_idx = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off[i] = True\n        if not must_run[i] and not must_off[i]:\n            flexible_idx.append(i)\n    \n    u[must_run] = 1\n    u[must_off] = 0\n    \n    amortized_costs = []\n    for i in flexible_idx:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            amortized_cost = (unit['s_i'] / unit['t_on_min_i']) + (unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i'])\n        else:\n            amortized_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        amortized_costs.append(amortized_cost)\n    \n    sorted_flexible = [flexible_idx[i] for i in np.argsort(amortized_costs)]\n    \n    total_capacity = 0\n    for i in range(n_units):\n        if must_run[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                total_capacity += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total_capacity += unit['p_start_i']\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            total_capacity += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_capacity += unit['p_start_i']\n    \n    committed_idx = np.where(u == 1)[0]\n    low_bounds = np.zeros(len(committed_idx))\n    high_bounds = np.zeros(len(committed_idx))\n    for j, i in enumerate(committed_idx):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_bounds[j] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[j] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bounds[j] = unit['p_min_i']\n            high_bounds[j] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    low_lambda = 0\n    high_lambda = 0\n    for j, i in enumerate(committed_idx):\n        unit = units_info[i]\n        low_marginal = unit['b_i'] + 2 * unit['c_i'] * low_bounds[j]\n        high_marginal = unit['b_i'] + 2 * unit['c_i'] * high_bounds[j]\n        low_lambda = min(low_lambda, low_marginal) if j == 0 else min(low_lambda, low_marginal)\n        high_lambda = max(high_lambda, high_marginal) if j == 0 else max(high_lambda, high_marginal)\n    \n    for _ in range(100):\n        lambda_val = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for j, i in enumerate(committed_idx):\n            unit = units_info[i]\n            p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] != 0 else high_bounds[j]\n            p_val = np.clip(p_val, low_bounds[j], high_bounds[j])\n            total_p += p_val\n            p[i] = p_val\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        if total_p < load:\n            low_lambda = lambda_val\n        else:\n            high_lambda = lambda_val\n    \n    marginal_costs = []\n    for j, i in enumerate(committed_idx):\n        unit = units_info[i]\n        marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p[i])\n    \n    order = np.argsort(marginal_costs)\n    total_p = np.sum(p)\n    \n    if total_p < load:\n        for j in order:\n            i = committed_idx[j]\n            available = high_bounds[j] - p[i]\n            need = load - total_p\n            if available > 0:\n                add = min(available, need)\n                p[i] += add\n                total_p += add\n            if total_p >= load:\n                break\n    elif total_p > load:\n        for j in order[::-1]:\n            i = committed_idx[j]\n            available = p[i] - low_bounds[j]\n            need = total_p - load\n            if available > 0:\n                subtract = min(available, need)\n                p[i] -= subtract\n                total_p -= subtract\n            if total_p <= load:\n                break\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00419,
          "gap_price_rate": 0.01634,
          "fitness": 0.01027
     },
     {
          "name": "enhanced_rolling_marginal_cost_dispatch",
          "algorithm": "1. Identify must-run and must-off units using minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp constraints\n3. Sort flexible units by marginal cost at minimum output plus prorated startup cost\n4. Commit additional units in cost priority order until load can be met\n5. Perform economic dispatch using lambda iteration with ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load\n7. Validate and enforce all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_marginal_cost_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 2: Calculate must-run capacity\n    must_run_min = 0\n    must_run_max = 0\n    for i in must_run:\n        unit = units[i]\n        # Calculate feasible output range considering ramp constraints\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_min += p_min\n        must_run_max += p_max\n        u_out[i] = 1\n        p_out[i] = p_min  # Temporary assignment\n    \n    # Step 3: Sort flexible units by cost priority\n    flexible_sorted = []\n    for i in flexible:\n        unit = units[i]\n        # Calculate prorated startup cost\n        startup_cost = unit['s_i'] / unit['t_on_min_i'] if unit['u_i_0'] == 0 else 0\n        # Marginal cost at minimum output\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost + startup_cost\n        flexible_sorted.append((priority, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit additional units\n    current_capacity = must_run_max\n    committed = set(must_run)\n    \n    for priority, idx in flexible_sorted:\n        if current_capacity >= load:\n            break\n        unit = units[idx]\n        # Calculate maximum feasible output\n        if unit['u_i_0'] == 0:  # Startup\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Already online\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        current_capacity += p_max\n        committed.add(idx)\n        u_out[idx] = 1\n    \n    # Step 5: Economic dispatch using lambda iteration\n    committed = list(committed)\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate feasible output range\n            if unit['u_i_0'] == 1:  # Previously online\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Startup\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Calculate unconstrained output\n            p_unconstrained = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_constrained = np.clip(p_unconstrained, p_min, p_max)\n            total_p += p_constrained\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        p_unconstrained = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p_out[i] = np.clip(p_unconstrained, p_min, p_max)\n    \n    # Step 6: Fine-tune to match load exactly\n    total_p = np.sum(p_out[committed])\n    delta = load - total_p\n    \n    while abs(delta) > 1e-6:\n        # Find unit with closest marginal cost to adjust\n        best_idx = None\n        best_cost_diff = float('inf')\n        \n        for i in committed:\n            unit = units[i]\n            current_p = p_out[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if delta > 0:  # Need to increase output\n                if unit['u_i_0'] == 1:\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                \n                if current_p < p_max:\n                    cost_diff = marginal_cost\n                    if cost_diff < best_cost_diff:\n                        best_cost_diff = cost_diff\n                        best_idx = i\n            else:  # Need to decrease output\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_min = unit['p_min_i']\n                \n                if current_p > p_min:\n                    cost_diff = -marginal_cost\n                    if cost_diff < best_cost_diff:\n                        best_cost_diff = cost_diff\n                        best_idx = i\n        \n        if best_idx is None:\n            break\n        \n        unit = units[best_idx]\n        current_p = p_out[best_idx]\n        \n        if delta > 0:\n            adjust = min(delta, unit['p_up_i'])\n            new_p = min(current_p + adjust, \n                       min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            adjust = min(-delta, unit['p_down_i'])\n            new_p = max(current_p - adjust, \n                       max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n        \n        p_out[best_idx] = new_p\n        delta = load - np.sum(p_out[committed])\n    \n    return np.vstack([u_out, p_out])\n",
          "from": "crossover",
          "gap_power_rate": 0.00421,
          "gap_price_rate": 0.01644,
          "fitness": 0.01033
     },
     {
          "name": "enhanced_rolling_priority_list_with_ramp",
          "algorithm": "1. Identify must-run and must-off units considering minimum up/down times and shutdown ramp constraints\n2. Calculate prorated startup cost per period for flexible units and sort by marginal cost at minimum output plus prorated cost\n3. Commit must-run units first, then flexible units until maximum available capacity meets load\n4. Adjust commitment to ensure minimum feasible output doesn't exceed load\n5. Perform economic dispatch using incremental cost optimization with ramp-aware adjustment\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_priority_list_with_ramp(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t0 > -toff_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_off:\n        schedules[0,i] = 0\n        schedules[1,i] = 0\n    \n    committed = must_run.copy()\n    \n    def get_feasible_range(unit, committed_state, u0, p0):\n        if not committed_state:\n            return (0, 0)\n        if u0 == 1:\n            pmin = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            pmax = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            pmin = unit['p_min_i']\n            pmax = min(unit['p_max_i'], unit['p_start_i'])\n        return (pmin, pmax)\n    \n    priority_list = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['t_on_min_i'] > 0:\n            prorated_startup = unit['s_i'] / unit['t_on_min_i']\n        else:\n            prorated_startup = unit['s_i']\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost + prorated_startup\n        priority_list.append((i, priority))\n    \n    priority_list.sort(key=lambda x: x[1])\n    \n    total_max = 0\n    for i in committed:\n        unit = units_info[i]\n        pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n        total_max += pmax\n    \n    for i, _ in priority_list:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n        total_max += pmax\n        committed.append(i)\n    \n    total_min = 0\n    for i in committed:\n        unit = units_info[i]\n        pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n        total_min += pmin\n    \n    flexible_committed = [i for i in committed if i in flexible]\n    flexible_priority = [item for item in priority_list if item[0] in flexible_committed]\n    flexible_priority.sort(key=lambda x: x[1], reverse=True)\n    \n    while total_min > load and flexible_priority:\n        remove_i = flexible_priority.pop(0)[0]\n        committed.remove(remove_i)\n        unit = units_info[remove_i]\n        pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n        total_min -= pmin\n    \n    outputs = {}\n    for i in committed:\n        unit = units_info[i]\n        pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n        outputs[i] = pmin\n    \n    total_output = sum(outputs.values())\n    \n    if total_output > load:\n        for i in committed:\n            schedules[0,i] = 1\n            schedules[1,i] = outputs[i]\n        return schedules\n    \n    while total_output < load:\n        best_unit = None\n        min_inc_cost = float('inf')\n        for i in committed:\n            unit = units_info[i]\n            pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n            if outputs[i] < pmax:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n                if inc_cost < min_inc_cost:\n                    min_inc_cost = inc_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n        \n        unit = units_info[best_unit]\n        pmin, pmax = get_feasible_range(unit, True, unit['u_i_0'], unit['p_i_0'])\n        step = min(0.1, pmax - outputs[best_unit], load - total_output)\n        outputs[best_unit] += step\n        total_output += step\n    \n    for i in committed:\n        schedules[0,i] = 1\n        schedules[1,i] = outputs[i]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00421,
          "gap_price_rate": 0.01663,
          "fitness": 0.01042
     },
     {
          "name": "refined_rolling_priority_dispatch",
          "algorithm": "1. Identify must-run units (units violating min up-time or shutdown ramp constraints) and must-off units (units violating min down-time constraints)\n2. Calculate prorated startup cost considering remaining minimum up-time for already-on units\n3. Sort available units by adjusted marginal cost (marginal cost at min output + prorated startup cost)\n4. Commit must-run units first, then activate additional units in cost order until load can be met\n5. Perform economic dispatch using iterative lambda adjustment with ramp-aware capacity limits\n6. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n7. Validate and enforce minimum runtime constraints post-dispatch\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_priority_dispatch(units_info, load):\n    # Extract unit parameters\n    n_units = len(units_info)\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    min_up = np.array([u['t_on_min_i'] for u in units_info])\n    min_down = np.array([u['t_off_min_i'] for u in units_info])\n    startup_cost = np.array([u['s_i'] for u in units_info])\n    u_prev = np.array([u['u_i_0'] for u in units_info])\n    t_prev = np.array([u['t_i_0'] for u in units_info])\n    p_prev = np.array([u['p_i_0'] for u in units_info])\n    \n    # Initialize arrays\n    u_current = np.zeros(n_units)\n    p_current = np.zeros(n_units)\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if -t_prev[i] < min_down[i]:\n                must_off[i] = True\n    \n    # Step 2: Calculate prorated startup cost\n    prorated_cost = np.zeros(n_units)\n    for i in range(n_units):\n        if u_prev[i] == 0:\n            remaining_time = max(1, min_up[i] - max(0, t_prev[i]))\n            prorated_cost[i] = startup_cost[i] / remaining_time\n        else:\n            prorated_cost[i] = 0\n    \n    # Step 3: Calculate adjusted marginal cost and sort\n    marginal_cost = b + 2 * c * p_min\n    adjusted_cost = marginal_cost + prorated_cost\n    available_units = [i for i in range(n_units) if not must_off[i]]\n    sorted_units = sorted(available_units, key=lambda i: adjusted_cost[i])\n    \n    # Step 4: Commit units\n    committed = must_run.copy()\n    total_capacity = 0\n    \n    # Add must-run units first\n    for i in range(n_units):\n        if must_run[i]:\n            if u_prev[i] == 1:\n                max_output = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                max_output = min(p_max[i], p_start[i])\n            total_capacity += max_output\n            committed[i] = True\n    \n    # Add units in cost order until load can be met\n    for i in sorted_units:\n        if not committed[i] and total_capacity < load:\n            if u_prev[i] == 1:\n                max_output = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                max_output = min(p_max[i], p_start[i])\n            total_capacity += max_output\n            committed[i] = True\n            if total_capacity >= load:\n                break\n    \n    # Step 5: Economic dispatch with lambda iteration\n    # Calculate min and max feasible outputs\n    p_low = np.zeros(n_units)\n    p_high = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if committed[i]:\n            if u_prev[i] == 1:\n                p_low[i] = max(p_min[i], p_prev[i] - p_down[i])\n                p_high[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                p_low[i] = p_min[i]\n                p_high[i] = min(p_max[i], p_start[i])\n        else:\n            p_low[i] = 0\n            p_high[i] = 0\n    \n    # Lambda iteration\n    lambda_low = min(b[committed] + 2 * c[committed] * p_low[committed])\n    lambda_high = max(b[committed] + 2 * c[committed] * p_high[committed])\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for i in range(n_units):\n            if committed[i]:\n                p_current[i] = max(p_low[i], min(p_high[i], (lambda_mid - b[i]) / (2 * c[i])))\n                total_p += p_current[i]\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tuning with bisection\n    under_committed = total_p < load\n    over_committed = total_p > load\n    \n    if under_committed or over_committed:\n        units_to_adjust = [i for i in range(n_units) if committed[i]]\n        if under_committed:\n            units_to_adjust.sort(key=lambda i: b[i] + 2 * c[i] * p_current[i])\n        else:\n            units_to_adjust.sort(key=lambda i: b[i] + 2 * c[i] * p_current[i], reverse=True)\n        \n        for i in units_to_adjust:\n            if under_committed:\n                available = p_high[i] - p_current[i]\n                needed = load - total_p\n                addition = min(available, needed)\n                p_current[i] += addition\n                total_p += addition\n            else:\n                reduction = min(p_current[i] - p_low[i], total_p - load)\n                p_current[i] -= reduction\n                total_p -= reduction\n            \n            if abs(total_p - load) < 1e-5:\n                break\n    \n    # Step 7: Validate minimum runtime constraints\n    u_current = committed.astype(int)\n    for i in range(n_units):\n        if u_current[i] == 0 and u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                u_current[i] = 1\n                p_current[i] = max(p_min[i], p_prev[i] - p_down[i])\n    \n    return np.vstack([u_current, p_current])",
          "from": "mutation",
          "gap_power_rate": 0.00421,
          "gap_price_rate": 0.0168,
          "fitness": 0.01051
     },
     {
          "name": "enhanced_rolling_amortized_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time)\n2. Calculate prorated startup cost for flexible units: (s_i / t_on_min_i) + marginal cost at minimum output (b_i + 2*c_i*p_min_i)\n3. Commit must-run units first, then activate flexible units in ascending prorated cost order until available capacity meets load\n4. Perform economic dispatch using bisection method (lambda iteration) with unit-specific ramp-aware output limits\n5. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n6. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_amortized_cost_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if (u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])):\n            must_run.append(i)\n        # Must-off conditions\n        elif (u_i0 == 0 and -t_i0 < unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Initialize commitments\n    commitments = set(must_run)\n    \n    # Step 2: Calculate prorated costs for flexible units\n    prorated_costs = []\n    for i in flexible:\n        unit = units[i]\n        startup_cost_per_period = unit['s_i'] / unit['t_on_min_i']\n        marginal_cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        prorated_costs.append((i, startup_cost_per_period + marginal_cost_min))\n    \n    # Sort flexible units by prorated cost\n    prorated_costs.sort(key=lambda x: x[1])\n    \n    # Step 3: Commit units until load can be met\n    current_capacity = 0\n    for idx in must_run:\n        unit = units[idx]\n        # Calculate available output considering ramp constraints\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        current_capacity += max_output\n    \n    for i, _ in prorated_costs:\n        if current_capacity >= load:\n            break\n        unit = units[i]\n        # Calculate available output\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        current_capacity += max_output\n        commitments.add(i)\n    \n    # Step 4: Economic dispatch using bisection method\n    committed_units = [units[i] for i in commitments]\n    \n    # Define output bounds for each committed unit\n    bounds = []\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((low, high))\n    \n    # Lambda iteration using bisection\n    def total_output(lambda_val):\n        total = 0\n        for unit, (low, high) in zip(committed_units, bounds):\n            p_unconstrained = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            p_constrained = np.clip(p_unconstrained, low, high)\n            total += p_constrained\n        return total\n    \n    lambda_low = min(unit['b_i'] + 2*unit['c_i']*low for unit, (low, high) in zip(committed_units, bounds))\n    lambda_high = max(unit['b_i'] + 2*unit['c_i']*high for unit, (low, high) in zip(committed_units, bounds))\n    \n    for _ in range(50):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_mid = total_output(lambda_mid)\n        if abs(total_mid - load) < 1e-6:\n            break\n        elif total_mid < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Calculate final outputs\n    outputs = []\n    for unit, (low, high) in zip(committed_units, bounds):\n        p_unconstrained = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p_constrained = np.clip(p_unconstrained, low, high)\n        outputs.append(p_constrained)\n    \n    total_out = sum(outputs)\n    \n    # Step 5: Fine-tune outputs\n    if abs(total_out - load) > 1e-6:\n        # Sort by marginal cost\n        marginal_costs = []\n        for i, (unit, p) in enumerate(zip(committed_units, outputs)):\n            mc = unit['b_i'] + 2 * unit['c_i'] * p\n            marginal_costs.append((i, mc, p))\n        \n        if total_out < load:\n            marginal_costs.sort(key=lambda x: x[1])  # Ascending cost\n            for i, mc, p in marginal_costs:\n                unit = committed_units[i]\n                high = bounds[i][1]\n                if p < high:\n                    add = min(load - total_out, high - p)\n                    outputs[i] += add\n                    total_out += add\n                    if abs(total_out - load) < 1e-6:\n                        break\n        else:\n            marginal_costs.sort(key=lambda x: -x[1])  # Descending cost\n            for i, mc, p in marginal_costs:\n                unit = committed_units[i]\n                low = bounds[i][0]\n                if p > low:\n                    subtract = min(total_out - load, p - low)\n                    outputs[i] -= subtract\n                    total_out -= subtract\n                    if abs(total_out - load) < 1e-6:\n                        break\n    \n    # Prepare final schedules\n    output_idx = 0\n    for i in range(n_units):\n        if i in commitments:\n            schedules[0, i] = 1\n            schedules[1, i] = outputs[output_idx]\n            output_idx += 1\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00421,
          "gap_price_rate": 0.01699,
          "fitness": 0.0106
     },
     {
          "name": "enhanced_amortized_marginal_cost_dispatch",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints\n2. Calculate adjusted cost index for flexible units: marginal cost at minimum output plus prorated startup cost amortized over min up-time\n3. Sort flexible units by adjusted cost index\n4. Commit must-run units first, then activate flexible units in cost priority order until load can be met\n5. Perform economic dispatch using incremental cost optimization with ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load\n7. Validate and enforce all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_marginal_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run.append(i)\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Calculate adjusted cost index for flexible units\n    cost_index = []\n    for i in flexible:\n        unit = units_info[i]\n        marginal_cost_min = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        prorated_startup = unit['s_i'] / unit['t_on_min_i'] if unit['t_on_min_i'] > 0 else unit['s_i']\n        cost_index.append(marginal_cost_min + prorated_startup)\n    \n    # Sort flexible units by cost index\n    flexible_sorted = [x for _, x in sorted(zip(cost_index, flexible))]\n    \n    # Initialize commitments\n    committed = set(must_run)\n    total_capacity = 0\n    \n    # Add must-run units capacity\n    for i in committed:\n        unit = units_info[i]\n        max_output = min(unit['p_max_i'], \n                        unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] else unit['p_start_i'])\n        total_capacity += max_output\n    \n    # Commit flexible units until load can be met\n    for i in flexible_sorted:\n        if total_capacity >= load:\n            break\n        if i not in must_off:\n            unit = units_info[i]\n            max_output = min(unit['p_max_i'], \n                            unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] else unit['p_start_i'])\n            total_capacity += max_output\n            committed.add(i)\n    \n    # Economic dispatch\n    remaining_load = load\n    min_outputs = []\n    max_outputs = []\n    indices = []\n    \n    # Calculate feasible output ranges\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0']:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        min_outputs.append(min_p)\n        max_outputs.append(max_p)\n        indices.append(i)\n        remaining_load -= min_p\n    \n    # Adjust outputs to match load\n    n_committed = len(committed)\n    p_temp = np.array(min_outputs)\n    \n    # Increase outputs based on marginal cost\n    while remaining_load > 0:\n        marginal_costs = []\n        for idx, i in enumerate(indices):\n            if p_temp[idx] < max_outputs[idx]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_temp[idx]\n                marginal_costs.append((marginal_cost, idx))\n        if not marginal_costs:\n            break\n        marginal_costs.sort()\n        cheapest_idx = marginal_costs[0][1]\n        increment = min(remaining_load, max_outputs[cheapest_idx] - p_temp[cheapest_idx])\n        p_temp[cheapest_idx] += increment\n        remaining_load -= increment\n    \n    # Decrease outputs if over generation (shouldn't occur with proper commitment)\n    while remaining_load < 0:\n        marginal_costs = []\n        for idx, i in enumerate(indices):\n            if p_temp[idx] > min_outputs[idx]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_temp[idx]\n                marginal_costs.append((marginal_cost, idx))\n        if not marginal_costs:\n            break\n        marginal_costs.sort(reverse=True)\n        expensive_idx = marginal_costs[0][1]\n        decrement = min(-remaining_load, p_temp[expensive_idx] - min_outputs[expensive_idx])\n        p_temp[expensive_idx] -= decrement\n        remaining_load += decrement\n    \n    # Update output values\n    for idx, i in enumerate(indices):\n        p[i] = p_temp[idx]\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00549,
          "gap_price_rate": 0.01634,
          "fitness": 0.01091
     },
     {
          "name": "enhanced_rolling_marginal_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (units violating minimum up-time or shutdown ramp constraints) and must-off units (units violating minimum down-time constraints)\n2. Calculate prorated startup cost for flexible units and sort by marginal cost at minimum output plus prorated startup cost\n3. Commit must-run units first, then activate additional units in cost priority order until load can be met\n4. Perform economic dispatch using iterative lambda adjustment with ramp-aware capacity limits\n5. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n6. Validate and enforce minimum runtime constraints post-dispatch\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_marginal_cost_dispatch_v2(units_info, load):\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    # Extract unit parameters\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    startup_cost = [unit['s_i'] for unit in units_info]\n    u0 = [unit['u_i_0'] for unit in units_info]\n    t0 = [unit['t_i_0'] for unit in units_info]\n    p0 = [unit['p_i_0'] for unit in units_info]\n\n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(num_units, dtype=bool)\n    must_off = np.zeros(num_units, dtype=bool)\n    \n    for i in range(num_units):\n        if u0[i] == 1:\n            if t0[i] < min_up[i] or p0[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if -t0[i] < min_down[i]:\n                must_off[i] = True\n\n    # Step 2: Calculate adjusted costs and sort flexible units\n    flexible_units = []\n    for i in range(num_units):\n        if not must_run[i] and not must_off[i]:\n            prorated_cost = startup_cost[i] / min_up[i] if min_up[i] > 0 else startup_cost[i]\n            marginal_cost = b[i] + 2 * c[i] * p_min[i]\n            adjusted_cost = marginal_cost + prorated_cost\n            flexible_units.append((i, adjusted_cost))\n    \n    flexible_units.sort(key=lambda x: x[1])\n\n    # Step 3: Commit units\n    committed = list(np.where(must_run)[0])\n    total_min = sum(p_min[i] for i in committed)\n    total_max = sum(min(p_max[i], p0[i] + p_up[i]) if u0[i] == 1 else p_start[i] for i in committed)\n\n    for unit_idx, _ in flexible_units:\n        if total_max < load:\n            committed.append(unit_idx)\n            total_min += p_min[unit_idx]\n            if u0[unit_idx] == 1:\n                total_max += min(p_max[unit_idx], p0[unit_idx] + p_up[unit_idx])\n            else:\n                total_max += p_start[unit_idx]\n        else:\n            break\n\n    # Initialize outputs for committed units\n    for i in committed:\n        u[i] = 1\n        if u0[i] == 1:\n            p[i] = max(p_min[i], p0[i] - p_down[i])\n        else:\n            p[i] = p_min[i]\n\n    # Step 4: Economic dispatch with lambda iteration\n    total_output = sum(p)\n    lambda_val = 0.0\n    delta = 10.0\n    iterations = 0\n\n    while abs(total_output - load) > 1e-3 and iterations < 1000:\n        for i in committed:\n            if u0[i] == 1:\n                max_p = min(p_max[i], p0[i] + p_up[i])\n                min_p = max(p_min[i], p0[i] - p_down[i])\n            else:\n                max_p = min(p_max[i], p_start[i])\n                min_p = p_min[i]\n                \n            proposed_p = (lambda_val - b[i]) / (2 * c[i]) if c[i] > 0 else max_p\n            p[i] = np.clip(proposed_p, min_p, max_p)\n        \n        total_output = sum(p)\n        lambda_val += delta * (load - total_output)\n        iterations += 1\n\n    # Step 5: Fine-tuning with bisection\n    low, high = 0, max(p_max) * num_units\n    for _ in range(20):\n        mid = (low + high) / 2\n        total = 0\n        for i in committed:\n            if u0[i] == 1:\n                max_p = min(p_max[i], p0[i] + p_up[i])\n                min_p = max(p_min[i], p0[i] - p_down[i])\n            else:\n                max_p = min(p_max[i], p_start[i])\n                min_p = p_min[i]\n                \n            proposed_p = (mid - b[i]) / (2 * c[i]) if c[i] > 0 else max_p\n            p[i] = np.clip(proposed_p, min_p, max_p)\n            total += p[i]\n        \n        if total < load:\n            low = mid\n        else:\n            high = mid\n\n    # Step 6: Validate constraints\n    for i in range(num_units):\n        if u[i] == 1:\n            if u0[i] == 1:\n                assert p[i] >= max(p_min[i], p0[i] - p_down[i])\n                assert p[i] <= min(p_max[i], p0[i] + p_up[i])\n            else:\n                assert p[i] >= p_min[i]\n                assert p[i] <= min(p_max[i], p_start[i])\n\n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00476,
          "gap_price_rate": 0.01743,
          "fitness": 0.0111
     }
]