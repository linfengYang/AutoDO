[
     {
          "name": "enhanced_hybrid_rolling_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use average cost at maximum output with startup cost amortized over minimum up-time; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    max_available = np.zeros(n_units)\n    min_available = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            min_available[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_available[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            min_available[i] = unit['p_min_i']\n            max_available[i] = unit['p_start_i']\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        if u_i0 == 0 and t_i0 > -unit['t_off_min_i']:\n            must_off[i] = True\n    \n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_index = []\n    \n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            amortized_startup = unit['s_i'] / unit['t_on_min_i']\n            total_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i']**2) + amortized_startup\n            cost_index.append(total_cost / unit['p_max_i'])\n        else:\n            cost_index.append(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    committed = set()\n    total_max_avail = 0\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            committed.add(i)\n            total_max_avail += max_available[i]\n    \n    for i in sorted_flexible:\n        if total_max_avail >= load:\n            break\n        u[i] = 1\n        committed.add(i)\n        total_max_avail += max_available[i]\n    \n    low_bounds = []\n    high_bounds = []\n    units_dispatch = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_b = unit['p_min_i']\n            high_b = unit['p_start_i']\n        low_bounds.append(low_b)\n        high_bounds.append(high_b)\n        units_dispatch.append(i)\n    \n    if not committed:\n        return np.array([u, p])\n    \n    def total_gen(lam):\n        total = 0\n        for idx, i in enumerate(units_dispatch):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            low = low_bounds[idx]\n            high = high_bounds[idx]\n            if c == 0:\n                p_i = high if lam > b else low\n            else:\n                p_i = (lam - b) / (2 * c)\n                p_i = np.clip(p_i, low, high)\n            total += p_i\n        return total\n\n    min_marginal = float('inf')\n    max_marginal = -float('inf')\n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        marg_low = b + 2*c*low if c != 0 else b\n        marg_high = b + 2*c*high if c != 0 else b\n        min_marginal = min(min_marginal, marg_low)\n        max_marginal = max(max_marginal, marg_high)\n    \n    low_lam = min_marginal\n    high_lam = max_marginal\n    epsilon = 1e-5\n    max_iter = 100\n    \n    if low_lam == high_lam:\n        total_p = total_gen(low_lam)\n    else:\n        for _ in range(max_iter):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = total_gen(mid_lam)\n            if abs(total_p - load) < epsilon:\n                break\n            if total_p < load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        lam = (low_lam + high_lam) / 2\n        total_p = total_gen(lam)\n    \n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        if c == 0:\n            p_i = high if lam > b else low\n        else:\n            p_i = (lam - b) / (2 * c)\n            p_i = np.clip(p_i, low, high)\n        p[i] = p_i\n    \n    gap = load - total_p\n    if gap > 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)))]\n        for i in sorted_units:\n            if gap <= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_inc = high_bounds[idx] - p[i]\n            to_inc = min(gap, max_inc)\n            p[i] += to_inc\n            gap -= to_inc\n    elif gap < 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)), reverse=True)]\n        for i in sorted_units:\n            if gap >= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_dec = p[i] - low_bounds[idx]\n            to_dec = min(-gap, max_dec)\n            p[i] -= to_dec\n            gap += to_dec\n    \n    for i in range(n_units):\n        if must_off[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00499,
          "gap_price_rate": 0.00879,
          "fitness": 0.00689
     },
     {
          "name": "enhanced_hybrid_rolling_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use average cost at maximum output with startup cost amortized over minimum up-time; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    max_available = np.zeros(n_units)\n    min_available = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            min_available[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_available[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            min_available[i] = unit['p_min_i']\n            max_available[i] = unit['p_start_i']\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        if u_i0 == 0 and t_i0 > -unit['t_off_min_i']:\n            must_off[i] = True\n    \n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_index = []\n    \n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            amortized_startup = unit['s_i'] / unit['t_on_min_i']\n            total_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i']**2) + amortized_startup\n            cost_index.append(total_cost / unit['p_max_i'])\n        else:\n            cost_index.append(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    committed = set()\n    total_max_avail = 0\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            committed.add(i)\n            total_max_avail += max_available[i]\n    \n    for i in sorted_flexible:\n        if total_max_avail >= load:\n            break\n        u[i] = 1\n        committed.add(i)\n        total_max_avail += max_available[i]\n    \n    low_bounds = []\n    high_bounds = []\n    units_dispatch = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_b = unit['p_min_i']\n            high_b = unit['p_start_i']\n        low_bounds.append(low_b)\n        high_bounds.append(high_b)\n        units_dispatch.append(i)\n    \n    if not committed:\n        return np.array([u, p])\n    \n    def total_gen(lam):\n        total = 0\n        for idx, i in enumerate(units_dispatch):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            low = low_bounds[idx]\n            high = high_bounds[idx]\n            if c == 0:\n                p_i = high if lam > b else low\n            else:\n                p_i = (lam - b) / (2 * c)\n                p_i = np.clip(p_i, low, high)\n            total += p_i\n        return total\n\n    min_marginal = float('inf')\n    max_marginal = -float('inf')\n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        marg_low = b + 2*c*low if c != 0 else b\n        marg_high = b + 2*c*high if c != 0 else b\n        min_marginal = min(min_marginal, marg_low)\n        max_marginal = max(max_marginal, marg_high)\n    \n    low_lam = min_marginal\n    high_lam = max_marginal\n    epsilon = 1e-5\n    max_iter = 100\n    \n    if low_lam == high_lam:\n        total_p = total_gen(low_lam)\n    else:\n        for _ in range(max_iter):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = total_gen(mid_lam)\n            if abs(total_p - load) < epsilon:\n                break\n            if total_p < load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        lam = (low_lam + high_lam) / 2\n        total_p = total_gen(lam)\n    \n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        if c == 0:\n            p_i = high if lam > b else low\n        else:\n            p_i = (lam - b) / (2 * c)\n            p_i = np.clip(p_i, low, high)\n        p[i] = p_i\n    \n    gap = load - total_p\n    if gap > 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)))]\n        for i in sorted_units:\n            if gap <= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_inc = high_bounds[idx] - p[i]\n            to_inc = min(gap, max_inc)\n            p[i] += to_inc\n            gap -= to_inc\n    elif gap < 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)), reverse=True)]\n        for i in sorted_units:\n            if gap >= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_dec = p[i] - low_bounds[idx]\n            to_dec = min(-gap, max_dec)\n            p[i] -= to_dec\n            gap += to_dec\n    \n    for i in range(n_units):\n        if must_off[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00499,
          "gap_price_rate": 0.00879,
          "fitness": 0.00689
     },
     {
          "name": "enhanced_hybrid_rolling_dispatch_v3",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use average cost at maximum output with startup cost amortized over minimum up-time plus marginal cost adjustment; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using adaptive bisection method with unit-specific ramp-aware output limits considering startup/shutdown constraints\n6. Fine-tune outputs using marginal cost ordering with ramp-aware adjustments to exactly match load\n7. Validate solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch_v3(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    cost_index = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n                \n    for i, unit in enumerate(units_info):\n        if flexible[i]:\n            if unit['u_i_0'] == 0:\n                avg_cost = (unit['s_i'] / unit['t_on_min_i'] + unit['b_i'] * unit['p_max_i'] + \n                           unit['c_i'] * unit['p_max_i'] ** 2) / unit['p_max_i']\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n                cost_index[i] = avg_cost + 0.5 * marginal_cost\n            else:\n                cost_index[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n    \n    flexible_indices = np.where(flexible)[0]\n    sorted_flexible = flexible_indices[np.argsort(cost_index[flexible_indices])]\n    \n    total_capacity = 0\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                p_max = min(units_info[i]['p_max_i'], \n                           units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                p_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_capacity += p_max\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        u[i] = 1\n        if units_info[i]['u_i_0'] == 1:\n            p_max = min(units_info[i]['p_max_i'], \n                       units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            p_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        total_capacity += p_max\n    \n    committed = np.where(u == 1)[0]\n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    \n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            lower_bounds[i] = max(units_info[i]['p_min_i'], \n                                units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            upper_bounds[i] = min(units_info[i]['p_max_i'], \n                                units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lower_bounds[i] = units_info[i]['p_min_i']\n            upper_bounds[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    def total_output(lambda_val):\n        total = 0\n        for i in committed:\n            p_i = (lambda_val - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            p_i = np.clip(p_i, lower_bounds[i], upper_bounds[i])\n            total += p_i\n        return total\n    \n    lambda_low = 0\n    lambda_high = 10000\n    tolerance = 1e-6\n    while lambda_high - lambda_low > tolerance:\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = total_output(lambda_mid)\n        if total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    for i in committed:\n        p[i] = (lambda_low - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n        p[i] = np.clip(p[i], lower_bounds[i], upper_bounds[i])\n    \n    total_p = np.sum(p)\n    mismatch = load - total_p\n    \n    while abs(mismatch) > tolerance:\n        if mismatch > 0:\n            candidates = [i for i in committed if p[i] < upper_bounds[i]]\n            if not candidates:\n                break\n            marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n            idx = candidates[np.argmin(marginal_costs)]\n            increase = min(mismatch, upper_bounds[idx] - p[idx])\n            p[idx] += increase\n            mismatch -= increase\n        else:\n            candidates = [i for i in committed if p[i] > lower_bounds[i]]\n            if not candidates:\n                break\n            marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n            idx = candidates[np.argmax(marginal_costs)]\n            decrease = min(-mismatch, p[idx] - lower_bounds[idx])\n            p[idx] -= decrease\n            mismatch += decrease\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00507,
          "gap_price_rate": 0.0088,
          "fitness": 0.00693
     },
     {
          "name": "enhanced_hybrid_rolling_dispatch_v3",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use average cost at maximum output with startup cost amortized over minimum up-time plus marginal cost adjustment; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using adaptive bisection method with unit-specific ramp-aware output limits considering startup/shutdown constraints\n6. Fine-tune outputs using marginal cost ordering with ramp-aware adjustments to exactly match load\n7. Validate solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch_v3(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    cost_index = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n                \n    for i, unit in enumerate(units_info):\n        if flexible[i]:\n            if unit['u_i_0'] == 0:\n                avg_cost = (unit['s_i'] / unit['t_on_min_i'] + unit['b_i'] * unit['p_max_i'] + \n                           unit['c_i'] * unit['p_max_i'] ** 2) / unit['p_max_i']\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n                cost_index[i] = avg_cost + 0.5 * marginal_cost\n            else:\n                cost_index[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n    \n    flexible_indices = np.where(flexible)[0]\n    sorted_flexible = flexible_indices[np.argsort(cost_index[flexible_indices])]\n    \n    total_capacity = 0\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            if units_info[i]['u_i_0'] == 1:\n                p_max = min(units_info[i]['p_max_i'], \n                           units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                p_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_capacity += p_max\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        u[i] = 1\n        if units_info[i]['u_i_0'] == 1:\n            p_max = min(units_info[i]['p_max_i'], \n                       units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            p_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        total_capacity += p_max\n    \n    committed = np.where(u == 1)[0]\n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    \n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            lower_bounds[i] = max(units_info[i]['p_min_i'], \n                                units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            upper_bounds[i] = min(units_info[i]['p_max_i'], \n                                units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lower_bounds[i] = units_info[i]['p_min_i']\n            upper_bounds[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    def total_output(lambda_val):\n        total = 0\n        for i in committed:\n            p_i = (lambda_val - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n            p_i = np.clip(p_i, lower_bounds[i], upper_bounds[i])\n            total += p_i\n        return total\n    \n    lambda_low = 0\n    lambda_high = 10000\n    tolerance = 1e-6\n    while lambda_high - lambda_low > tolerance:\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = total_output(lambda_mid)\n        if total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    for i in committed:\n        p[i] = (lambda_low - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n        p[i] = np.clip(p[i], lower_bounds[i], upper_bounds[i])\n    \n    total_p = np.sum(p)\n    mismatch = load - total_p\n    \n    while abs(mismatch) > tolerance:\n        if mismatch > 0:\n            candidates = [i for i in committed if p[i] < upper_bounds[i]]\n            if not candidates:\n                break\n            marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n            idx = candidates[np.argmin(marginal_costs)]\n            increase = min(mismatch, upper_bounds[idx] - p[idx])\n            p[idx] += increase\n            mismatch -= increase\n        else:\n            candidates = [i for i in committed if p[i] > lower_bounds[i]]\n            if not candidates:\n                break\n            marginal_costs = [units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i] for i in candidates]\n            idx = candidates[np.argmax(marginal_costs)]\n            decrease = min(-mismatch, p[idx] - lower_bounds[idx])\n            p[idx] -= decrease\n            mismatch += decrease\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00507,
          "gap_price_rate": 0.0088,
          "fitness": 0.00693
     },
     {
          "name": "hybrid_rolling_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate hybrid cost index for flexible units: for offline units use average cost at maximum output including startup cost; for online units use marginal cost at minimum output\n3. Sort flexible units by hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    cost_index = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            cost_index.append(avg_cost)\n        else:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            cost_index.append(marginal_cost)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    total_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n        u[i] = 1\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p])\n    \n    lower_bounds = []\n    upper_bounds = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_min = sum(lower_bounds)\n    total_max = sum(upper_bounds)\n    \n    if total_max < load:\n        p_committed = upper_bounds\n    elif total_min > load:\n        p_committed = lower_bounds\n    else:\n        low = min(unit['b_i'] + 2*unit['c_i']*lb for unit, lb in zip([units_info[i] for i in committed_indices], lower_bounds))\n        high = max(unit['b_i'] + 2*unit['c_i']*ub for unit, ub in zip([units_info[i] for i in committed_indices], upper_bounds))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2\n            total_output = 0\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n                total_output += p_i\n            \n            if total_output < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_committed = []\n        for idx, i in enumerate(committed_indices):\n            unit = units_info[i]\n            p_i = (high - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n            p_committed.append(p_i)\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_committed[idx]\n    \n    total_output = sum(p)\n    diff = load - total_output\n    if abs(diff) > 1e-5:\n        committed_units = [units_info[i] for i in committed_indices]\n        current_outputs = [p[i] for i in committed_indices]\n        marginal_costs = [unit['b_i'] + 2*unit['c_i']*current_output for unit, current_output in zip(committed_units, current_outputs)]\n        \n        if diff > 0:\n            order = np.argsort(marginal_costs)\n            for idx in order:\n                i = committed_indices[idx]\n                available = upper_bounds[committed_indices.index(i)] - p[i]\n                if available > 0:\n                    add = min(diff, available)\n                    p[i] += add\n                    diff -= add\n                    if diff <= 0:\n                        break\n        else:\n            order = np.argsort(marginal_costs)[::-1]\n            for idx in order:\n                i = committed_indices[idx]\n                available = p[i] - lower_bounds[committed_indices.index(i)]\n                if available > 0:\n                    reduce = min(-diff, available)\n                    p[i] -= reduce\n                    diff += reduce\n                    if diff >= 0:\n                        break\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00901,
          "fitness": 0.00729
     },
     {
          "name": "hybrid_rolling_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate hybrid cost index for flexible units: for offline units use average cost at maximum output including startup cost; for online units use marginal cost at minimum output\n3. Sort flexible units by hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    cost_index = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            cost_index.append(avg_cost)\n        else:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            cost_index.append(marginal_cost)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    total_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n        u[i] = 1\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p])\n    \n    lower_bounds = []\n    upper_bounds = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_min = sum(lower_bounds)\n    total_max = sum(upper_bounds)\n    \n    if total_max < load:\n        p_committed = upper_bounds\n    elif total_min > load:\n        p_committed = lower_bounds\n    else:\n        low = min(unit['b_i'] + 2*unit['c_i']*lb for unit, lb in zip([units_info[i] for i in committed_indices], lower_bounds))\n        high = max(unit['b_i'] + 2*unit['c_i']*ub for unit, ub in zip([units_info[i] for i in committed_indices], upper_bounds))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2\n            total_output = 0\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n                total_output += p_i\n            \n            if total_output < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_committed = []\n        for idx, i in enumerate(committed_indices):\n            unit = units_info[i]\n            p_i = (high - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n            p_committed.append(p_i)\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_committed[idx]\n    \n    total_output = sum(p)\n    diff = load - total_output\n    if abs(diff) > 1e-5:\n        committed_units = [units_info[i] for i in committed_indices]\n        current_outputs = [p[i] for i in committed_indices]\n        marginal_costs = [unit['b_i'] + 2*unit['c_i']*current_output for unit, current_output in zip(committed_units, current_outputs)]\n        \n        if diff > 0:\n            order = np.argsort(marginal_costs)\n            for idx in order:\n                i = committed_indices[idx]\n                available = upper_bounds[committed_indices.index(i)] - p[i]\n                if available > 0:\n                    add = min(diff, available)\n                    p[i] += add\n                    diff -= add\n                    if diff <= 0:\n                        break\n        else:\n            order = np.argsort(marginal_costs)[::-1]\n            for idx in order:\n                i = committed_indices[idx]\n                available = p[i] - lower_bounds[committed_indices.index(i)]\n                if available > 0:\n                    reduce = min(-diff, available)\n                    p[i] -= reduce\n                    diff += reduce\n                    if diff >= 0:\n                        break\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00901,
          "fitness": 0.00729
     },
     {
          "name": "hybrid_rolling_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including startup cost if unit was off, plus marginal cost adjustment for already-on units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    flexible_indices = []\n    committed_indices = []\n    \n    for i in range(n_units):\n        if must_run[i]:\n            committed_indices.append(i)\n        elif not must_off[i]:\n            flexible_indices.append(i)\n    \n    cost_index = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*unit['p_min_i']\n            avg_cost = 0.7*avg_cost + 0.3*marginal_cost\n        cost_index.append((avg_cost, i))\n    \n    cost_index.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    for cost, idx in cost_index:\n        if total_max >= load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_out\n        committed_indices.append(idx)\n    \n    if not committed_indices:\n        return np.array([u, p])\n    \n    ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((min_out, max_out))\n    \n    low = float('inf')\n    high = float('-inf')\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        mc_min = unit['b_i'] + 2*unit['c_i']*min_out\n        mc_max = unit['b_i'] + 2*unit['c_i']*max_out\n        low = min(low, mc_min)\n        high = max(high, mc_max)\n    \n    tol = 1e-6\n    max_iter = 1000\n    for _ in range(max_iter):\n        if abs(high - low) < tol:\n            break\n        lam = (low + high) / 2\n        total_p = 0\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            min_out, max_out = ranges[i]\n            if unit['c_i'] == 0:\n                p_i = max_out if lam > unit['b_i'] else min_out\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, min_out, max_out)\n            total_p += p_i\n        if total_p < load:\n            low = lam\n        else:\n            high = lam\n    \n    p_values = []\n    total_p = 0\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        if unit['c_i'] == 0:\n            p_i = max_out if lam > unit['b_i'] else min_out\n        else:\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, min_out, max_out)\n        p_values.append(p_i)\n        total_p += p_i\n    \n    gap = load - total_p\n    if abs(gap) > 1e-6:\n        adj_units = []\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            current_p = p_values[i]\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n            min_out, max_out = ranges[i]\n            adj_units.append((i, current_p, min_out, max_out, marginal_cost))\n        \n        if gap > 0:\n            adj_units.sort(key=lambda x: x[4])\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                add = min(max_out - current_p, gap)\n                p_values[i] += add\n                gap -= add\n        else:\n            adj_units.sort(key=lambda x: x[4], reverse=True)\n            gap = -gap\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                sub = min(current_p - min_out, gap)\n                p_values[i] -= sub\n                gap -= sub\n    \n    for i, idx in enumerate(committed_indices):\n        p[idx] = p_values[i]\n        u[idx] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00906,
          "fitness": 0.00732
     },
     {
          "name": "hybrid_rolling_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including startup cost if unit was off, plus marginal cost adjustment for already-on units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    flexible_indices = []\n    committed_indices = []\n    \n    for i in range(n_units):\n        if must_run[i]:\n            committed_indices.append(i)\n        elif not must_off[i]:\n            flexible_indices.append(i)\n    \n    cost_index = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*unit['p_min_i']\n            avg_cost = 0.7*avg_cost + 0.3*marginal_cost\n        cost_index.append((avg_cost, i))\n    \n    cost_index.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    for cost, idx in cost_index:\n        if total_max >= load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_out\n        committed_indices.append(idx)\n    \n    if not committed_indices:\n        return np.array([u, p])\n    \n    ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((min_out, max_out))\n    \n    low = float('inf')\n    high = float('-inf')\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        mc_min = unit['b_i'] + 2*unit['c_i']*min_out\n        mc_max = unit['b_i'] + 2*unit['c_i']*max_out\n        low = min(low, mc_min)\n        high = max(high, mc_max)\n    \n    tol = 1e-6\n    max_iter = 1000\n    for _ in range(max_iter):\n        if abs(high - low) < tol:\n            break\n        lam = (low + high) / 2\n        total_p = 0\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            min_out, max_out = ranges[i]\n            if unit['c_i'] == 0:\n                p_i = max_out if lam > unit['b_i'] else min_out\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, min_out, max_out)\n            total_p += p_i\n        if total_p < load:\n            low = lam\n        else:\n            high = lam\n    \n    p_values = []\n    total_p = 0\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        if unit['c_i'] == 0:\n            p_i = max_out if lam > unit['b_i'] else min_out\n        else:\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, min_out, max_out)\n        p_values.append(p_i)\n        total_p += p_i\n    \n    gap = load - total_p\n    if abs(gap) > 1e-6:\n        adj_units = []\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            current_p = p_values[i]\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n            min_out, max_out = ranges[i]\n            adj_units.append((i, current_p, min_out, max_out, marginal_cost))\n        \n        if gap > 0:\n            adj_units.sort(key=lambda x: x[4])\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                add = min(max_out - current_p, gap)\n                p_values[i] += add\n                gap -= add\n        else:\n            adj_units.sort(key=lambda x: x[4], reverse=True)\n            gap = -gap\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                sub = min(current_p - min_out, gap)\n                p_values[i] -= sub\n                gap -= sub\n    \n    for i, idx in enumerate(committed_indices):\n        p[idx] = p_values[i]\n        u[idx] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00906,
          "fitness": 0.00732
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including prorated startup cost for offline units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost-based adjustment to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    cost_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        p0 = unit['p_i_0']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < ton_min or p0 > pshut):\n            must_run.append(i)\n        elif u0 == 0 and abs(t0) < toff_min:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            pmax = unit['p_max_i']\n            s = unit['s_i']\n            \n            if u0 == 0:\n                cost_index = (a + b*pmax + c*pmax**2 + s) / pmax\n            else:\n                cost_index = (a + b*pmax + c*pmax**2) / pmax\n            cost_indices.append(cost_index)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_indices, flexible))]\n    committed = set(must_run)\n    total_cap = 0.0\n    \n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in sorted_flexible:\n        if total_cap >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n    \n    min_limits = []\n    max_limits = []\n    committed_list = list(committed)\n    for i in committed_list:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        \n        if u0 == 1:\n            min_lim = max(pmin, p0 - pdown)\n            max_lim = min(pmax, p0 + pup)\n        else:\n            min_lim = pmin\n            max_lim = min(pmax, pstart)\n        min_limits.append(min_lim)\n        max_limits.append(max_lim)\n    \n    def total_gen(lmbda):\n        total = 0.0\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            minl = min_limits[idx]\n            maxl = max_limits[idx]\n            \n            if c == 0:\n                p_val = maxl if lmbda >= b else minl\n            else:\n                p_val = (lmbda - b) / (2 * c)\n                p_val = np.clip(p_val, minl, maxl)\n            total += p_val\n        return total\n\n    low = -1e6\n    high = 1e6\n    tol = 0.1\n    while high - low > tol:\n        mid = (low + high) / 2\n        if total_gen(mid) < load:\n            low = mid\n        else:\n            high = mid\n    \n    lambda_opt = (low + high) / 2\n    total_p = 0\n    for idx, i in enumerate(committed_list):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        minl = min_limits[idx]\n        maxl = max_limits[idx]\n        \n        if c == 0:\n            p_val = maxl if lambda_opt >= b else minl\n        else:\n            p_val = (lambda_opt - b) / (2 * c)\n            p_val = np.clip(p_val, minl, maxl)\n        p[i] = p_val\n        total_p += p_val\n    \n    mismatch = load - total_p\n    if abs(mismatch) > 1e-5:\n        margins = []\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            margin = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            margins.append((i, margin, p[i], min_limits[idx], max_limits[idx]))\n        \n        if mismatch > 0:\n            margins.sort(key=lambda x: x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = maxl - current\n                if avail > 0:\n                    add = min(avail, mismatch)\n                    p[i] += add\n                    mismatch -= add\n                    if mismatch <= 0:\n                        break\n        else:\n            margins.sort(key=lambda x: -x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = current - minl\n                if avail > 0:\n                    sub = min(avail, -mismatch)\n                    p[i] -= sub\n                    mismatch += sub\n                    if mismatch >= 0:\n                        break\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00912,
          "fitness": 0.00733
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including prorated startup cost for offline units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost-based adjustment to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    cost_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        p0 = unit['p_i_0']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < ton_min or p0 > pshut):\n            must_run.append(i)\n        elif u0 == 0 and abs(t0) < toff_min:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            pmax = unit['p_max_i']\n            s = unit['s_i']\n            \n            if u0 == 0:\n                cost_index = (a + b*pmax + c*pmax**2 + s) / pmax\n            else:\n                cost_index = (a + b*pmax + c*pmax**2) / pmax\n            cost_indices.append(cost_index)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_indices, flexible))]\n    committed = set(must_run)\n    total_cap = 0.0\n    \n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in sorted_flexible:\n        if total_cap >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n    \n    min_limits = []\n    max_limits = []\n    committed_list = list(committed)\n    for i in committed_list:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        \n        if u0 == 1:\n            min_lim = max(pmin, p0 - pdown)\n            max_lim = min(pmax, p0 + pup)\n        else:\n            min_lim = pmin\n            max_lim = min(pmax, pstart)\n        min_limits.append(min_lim)\n        max_limits.append(max_lim)\n    \n    def total_gen(lmbda):\n        total = 0.0\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            minl = min_limits[idx]\n            maxl = max_limits[idx]\n            \n            if c == 0:\n                p_val = maxl if lmbda >= b else minl\n            else:\n                p_val = (lmbda - b) / (2 * c)\n                p_val = np.clip(p_val, minl, maxl)\n            total += p_val\n        return total\n\n    low = -1e6\n    high = 1e6\n    tol = 0.1\n    while high - low > tol:\n        mid = (low + high) / 2\n        if total_gen(mid) < load:\n            low = mid\n        else:\n            high = mid\n    \n    lambda_opt = (low + high) / 2\n    total_p = 0\n    for idx, i in enumerate(committed_list):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        minl = min_limits[idx]\n        maxl = max_limits[idx]\n        \n        if c == 0:\n            p_val = maxl if lambda_opt >= b else minl\n        else:\n            p_val = (lambda_opt - b) / (2 * c)\n            p_val = np.clip(p_val, minl, maxl)\n        p[i] = p_val\n        total_p += p_val\n    \n    mismatch = load - total_p\n    if abs(mismatch) > 1e-5:\n        margins = []\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            margin = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            margins.append((i, margin, p[i], min_limits[idx], max_limits[idx]))\n        \n        if mismatch > 0:\n            margins.sort(key=lambda x: x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = maxl - current\n                if avail > 0:\n                    add = min(avail, mismatch)\n                    p[i] += add\n                    mismatch -= add\n                    if mismatch <= 0:\n                        break\n        else:\n            margins.sort(key=lambda x: -x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = current - minl\n                if avail > 0:\n                    sub = min(avail, -mismatch)\n                    p[i] -= sub\n                    mismatch += sub\n                    if mismatch >= 0:\n                        break\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00912,
          "fitness": 0.00733
     }
]