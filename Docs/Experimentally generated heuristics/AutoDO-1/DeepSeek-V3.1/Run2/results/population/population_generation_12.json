[
     {
          "name": "enhanced_hybrid_rolling_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use average cost at maximum output with startup cost amortized over minimum up-time; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    max_available = np.zeros(n_units)\n    min_available = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            min_available[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_available[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            min_available[i] = unit['p_min_i']\n            max_available[i] = unit['p_start_i']\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run[i] = True\n        if u_i0 == 0 and t_i0 > -unit['t_off_min_i']:\n            must_off[i] = True\n    \n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    cost_index = []\n    \n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            amortized_startup = unit['s_i'] / unit['t_on_min_i']\n            total_cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i']**2) + amortized_startup\n            cost_index.append(total_cost / unit['p_max_i'])\n        else:\n            cost_index.append(unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    committed = set()\n    total_max_avail = 0\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            committed.add(i)\n            total_max_avail += max_available[i]\n    \n    for i in sorted_flexible:\n        if total_max_avail >= load:\n            break\n        u[i] = 1\n        committed.add(i)\n        total_max_avail += max_available[i]\n    \n    low_bounds = []\n    high_bounds = []\n    units_dispatch = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_b = unit['p_min_i']\n            high_b = unit['p_start_i']\n        low_bounds.append(low_b)\n        high_bounds.append(high_b)\n        units_dispatch.append(i)\n    \n    if not committed:\n        return np.array([u, p])\n    \n    def total_gen(lam):\n        total = 0\n        for idx, i in enumerate(units_dispatch):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            low = low_bounds[idx]\n            high = high_bounds[idx]\n            if c == 0:\n                p_i = high if lam > b else low\n            else:\n                p_i = (lam - b) / (2 * c)\n                p_i = np.clip(p_i, low, high)\n            total += p_i\n        return total\n\n    min_marginal = float('inf')\n    max_marginal = -float('inf')\n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        marg_low = b + 2*c*low if c != 0 else b\n        marg_high = b + 2*c*high if c != 0 else b\n        min_marginal = min(min_marginal, marg_low)\n        max_marginal = max(max_marginal, marg_high)\n    \n    low_lam = min_marginal\n    high_lam = max_marginal\n    epsilon = 1e-5\n    max_iter = 100\n    \n    if low_lam == high_lam:\n        total_p = total_gen(low_lam)\n    else:\n        for _ in range(max_iter):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = total_gen(mid_lam)\n            if abs(total_p - load) < epsilon:\n                break\n            if total_p < load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        lam = (low_lam + high_lam) / 2\n        total_p = total_gen(lam)\n    \n    for idx, i in enumerate(units_dispatch):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        low = low_bounds[idx]\n        high = high_bounds[idx]\n        if c == 0:\n            p_i = high if lam > b else low\n        else:\n            p_i = (lam - b) / (2 * c)\n            p_i = np.clip(p_i, low, high)\n        p[i] = p_i\n    \n    gap = load - total_p\n    if gap > 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)))]\n        for i in sorted_units:\n            if gap <= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_inc = high_bounds[idx] - p[i]\n            to_inc = min(gap, max_inc)\n            p[i] += to_inc\n            gap -= to_inc\n    elif gap < 0:\n        marginal_costs = [unit['b_i'] + 2 * unit['c_i'] * p[i] for i in committed]\n        sorted_units = [x for _, x in sorted(zip(marginal_costs, list(committed)), reverse=True)]\n        for i in sorted_units:\n            if gap >= 0:\n                break\n            idx = units_dispatch.index(i)\n            max_dec = p[i] - low_bounds[idx]\n            to_dec = min(-gap, max_dec)\n            p[i] -= to_dec\n            gap += to_dec\n    \n    for i in range(n_units):\n        if must_off[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00499,
          "gap_price_rate": 0.00879,
          "fitness": 0.00689
     },
     {
          "name": "hybrid_rolling_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate hybrid cost index for flexible units: for offline units use average cost at maximum output including startup cost; for online units use marginal cost at minimum output\n3. Sort flexible units by hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n    \n    flexible_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    cost_index = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            cost_index.append(avg_cost)\n        else:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            cost_index.append(marginal_cost)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_index, flexible_units))]\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    total_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = unit['p_start_i']\n        total_capacity += max_output\n        u[i] = 1\n    \n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    if not committed_indices:\n        return np.array([u, p])\n    \n    lower_bounds = []\n    upper_bounds = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        lower_bounds.append(lb)\n        upper_bounds.append(ub)\n    \n    total_min = sum(lower_bounds)\n    total_max = sum(upper_bounds)\n    \n    if total_max < load:\n        p_committed = upper_bounds\n    elif total_min > load:\n        p_committed = lower_bounds\n    else:\n        low = min(unit['b_i'] + 2*unit['c_i']*lb for unit, lb in zip([units_info[i] for i in committed_indices], lower_bounds))\n        high = max(unit['b_i'] + 2*unit['c_i']*ub for unit, ub in zip([units_info[i] for i in committed_indices], upper_bounds))\n        \n        tol = 1e-5\n        while high - low > tol:\n            mid = (low + high) / 2\n            total_output = 0\n            for idx, i in enumerate(committed_indices):\n                unit = units_info[i]\n                p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n                total_output += p_i\n            \n            if total_output < load:\n                low = mid\n            else:\n                high = mid\n        \n        p_committed = []\n        for idx, i in enumerate(committed_indices):\n            unit = units_info[i]\n            p_i = (high - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, lower_bounds[idx], upper_bounds[idx])\n            p_committed.append(p_i)\n    \n    for idx, i in enumerate(committed_indices):\n        p[i] = p_committed[idx]\n    \n    total_output = sum(p)\n    diff = load - total_output\n    if abs(diff) > 1e-5:\n        committed_units = [units_info[i] for i in committed_indices]\n        current_outputs = [p[i] for i in committed_indices]\n        marginal_costs = [unit['b_i'] + 2*unit['c_i']*current_output for unit, current_output in zip(committed_units, current_outputs)]\n        \n        if diff > 0:\n            order = np.argsort(marginal_costs)\n            for idx in order:\n                i = committed_indices[idx]\n                available = upper_bounds[committed_indices.index(i)] - p[i]\n                if available > 0:\n                    add = min(diff, available)\n                    p[i] += add\n                    diff -= add\n                    if diff <= 0:\n                        break\n        else:\n            order = np.argsort(marginal_costs)[::-1]\n            for idx in order:\n                i = committed_indices[idx]\n                available = p[i] - lower_bounds[committed_indices.index(i)]\n                if available > 0:\n                    reduce = min(-diff, available)\n                    p[i] -= reduce\n                    diff += reduce\n                    if diff >= 0:\n                        break\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00901,
          "fitness": 0.00729
     },
     {
          "name": "hybrid_rolling_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including startup cost if unit was off, plus marginal cost adjustment for already-on units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    flexible_indices = []\n    committed_indices = []\n    \n    for i in range(n_units):\n        if must_run[i]:\n            committed_indices.append(i)\n        elif not must_off[i]:\n            flexible_indices.append(i)\n    \n    cost_index = []\n    for i in flexible_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*unit['p_min_i']\n            avg_cost = 0.7*avg_cost + 0.3*marginal_cost\n        cost_index.append((avg_cost, i))\n    \n    cost_index.sort(key=lambda x: x[0])\n    \n    total_min = 0\n    total_max = 0\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    for cost, idx in cost_index:\n        if total_max >= load:\n            break\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += max_out\n        committed_indices.append(idx)\n    \n    if not committed_indices:\n        return np.array([u, p])\n    \n    ranges = []\n    for i in committed_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((min_out, max_out))\n    \n    low = float('inf')\n    high = float('-inf')\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        mc_min = unit['b_i'] + 2*unit['c_i']*min_out\n        mc_max = unit['b_i'] + 2*unit['c_i']*max_out\n        low = min(low, mc_min)\n        high = max(high, mc_max)\n    \n    tol = 1e-6\n    max_iter = 1000\n    for _ in range(max_iter):\n        if abs(high - low) < tol:\n            break\n        lam = (low + high) / 2\n        total_p = 0\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            min_out, max_out = ranges[i]\n            if unit['c_i'] == 0:\n                p_i = max_out if lam > unit['b_i'] else min_out\n            else:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = np.clip(p_i, min_out, max_out)\n            total_p += p_i\n        if total_p < load:\n            low = lam\n        else:\n            high = lam\n    \n    p_values = []\n    total_p = 0\n    for i, idx in enumerate(committed_indices):\n        unit = units_info[idx]\n        min_out, max_out = ranges[i]\n        if unit['c_i'] == 0:\n            p_i = max_out if lam > unit['b_i'] else min_out\n        else:\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, min_out, max_out)\n        p_values.append(p_i)\n        total_p += p_i\n    \n    gap = load - total_p\n    if abs(gap) > 1e-6:\n        adj_units = []\n        for i, idx in enumerate(committed_indices):\n            unit = units_info[idx]\n            current_p = p_values[i]\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*current_p\n            min_out, max_out = ranges[i]\n            adj_units.append((i, current_p, min_out, max_out, marginal_cost))\n        \n        if gap > 0:\n            adj_units.sort(key=lambda x: x[4])\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                add = min(max_out - current_p, gap)\n                p_values[i] += add\n                gap -= add\n        else:\n            adj_units.sort(key=lambda x: x[4], reverse=True)\n            gap = -gap\n            for i, current_p, min_out, max_out, mc in adj_units:\n                if gap <= 0:\n                    break\n                sub = min(current_p - min_out, gap)\n                p_values[i] -= sub\n                gap -= sub\n    \n    for i, idx in enumerate(committed_indices):\n        p[idx] = p_values[i]\n        u[idx] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00906,
          "fitness": 0.00732
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate adjusted cost index for flexible units: average cost at maximum output including prorated startup cost for offline units\n3. Sort flexible units by adjusted cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost-based adjustment to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    cost_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        p0 = unit['p_i_0']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1 and (t0 < ton_min or p0 > pshut):\n            must_run.append(i)\n        elif u0 == 0 and abs(t0) < toff_min:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            pmax = unit['p_max_i']\n            s = unit['s_i']\n            \n            if u0 == 0:\n                cost_index = (a + b*pmax + c*pmax**2 + s) / pmax\n            else:\n                cost_index = (a + b*pmax + c*pmax**2) / pmax\n            cost_indices.append(cost_index)\n    \n    sorted_flexible = [x for _, x in sorted(zip(cost_indices, flexible))]\n    committed = set(must_run)\n    total_cap = 0.0\n    \n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in sorted_flexible:\n        if total_cap >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            total_cap += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_cap += min(unit['p_max_i'], unit['p_start_i'])\n        committed.add(i)\n    \n    min_limits = []\n    max_limits = []\n    committed_list = list(committed)\n    for i in committed_list:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        \n        if u0 == 1:\n            min_lim = max(pmin, p0 - pdown)\n            max_lim = min(pmax, p0 + pup)\n        else:\n            min_lim = pmin\n            max_lim = min(pmax, pstart)\n        min_limits.append(min_lim)\n        max_limits.append(max_lim)\n    \n    def total_gen(lmbda):\n        total = 0.0\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            minl = min_limits[idx]\n            maxl = max_limits[idx]\n            \n            if c == 0:\n                p_val = maxl if lmbda >= b else minl\n            else:\n                p_val = (lmbda - b) / (2 * c)\n                p_val = np.clip(p_val, minl, maxl)\n            total += p_val\n        return total\n\n    low = -1e6\n    high = 1e6\n    tol = 0.1\n    while high - low > tol:\n        mid = (low + high) / 2\n        if total_gen(mid) < load:\n            low = mid\n        else:\n            high = mid\n    \n    lambda_opt = (low + high) / 2\n    total_p = 0\n    for idx, i in enumerate(committed_list):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        minl = min_limits[idx]\n        maxl = max_limits[idx]\n        \n        if c == 0:\n            p_val = maxl if lambda_opt >= b else minl\n        else:\n            p_val = (lambda_opt - b) / (2 * c)\n            p_val = np.clip(p_val, minl, maxl)\n        p[i] = p_val\n        total_p += p_val\n    \n    mismatch = load - total_p\n    if abs(mismatch) > 1e-5:\n        margins = []\n        for idx, i in enumerate(committed_list):\n            unit = units_info[i]\n            margin = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            margins.append((i, margin, p[i], min_limits[idx], max_limits[idx]))\n        \n        if mismatch > 0:\n            margins.sort(key=lambda x: x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = maxl - current\n                if avail > 0:\n                    add = min(avail, mismatch)\n                    p[i] += add\n                    mismatch -= add\n                    if mismatch <= 0:\n                        break\n        else:\n            margins.sort(key=lambda x: -x[1])\n            for i, margin, current, minl, maxl in margins:\n                avail = current - minl\n                if avail > 0:\n                    sub = min(avail, -mismatch)\n                    p[i] -= sub\n                    mismatch += sub\n                    if mismatch >= 0:\n                        break\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00912,
          "fitness": 0.00733
     },
     {
          "name": "enhanced_rolling_average_cost_dispatch",
          "algorithm": "1. Identify must-run units (violating minimum up-time or shutdown ramp constraints) and must-off units (violating minimum down-time constraints)\n2. Calculate average cost per MW at maximum output for flexible units, including startup cost if unit was previously off\n3. Sort flexible units by average cost in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using lambda iteration with ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load\n7. Validate solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_average_cost_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u_prev = np.array([unit['u_i_0'] for unit in units_info])\n    t_prev = np.array([unit['t_i_0'] for unit in units_info])\n    p_prev = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if -t_prev[i] < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    u[must_run] = 1\n    u[must_off] = 0\n    \n    # Step 2-4: Commit flexible units by average cost\n    flexible_mask = ~(must_run | must_off)\n    flexible_idx = np.where(flexible_mask)[0]\n    \n    # Calculate average cost at max output\n    avg_costs = []\n    for i in flexible_idx:\n        if u_prev[i] == 0:\n            total_cost = startup_cost[i] + a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)\n        else:\n            total_cost = a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)\n        avg_costs.append(total_cost / p_max[i])\n    \n    # Sort by average cost\n    sorted_flexible = [x for _, x in sorted(zip(avg_costs, flexible_idx))]\n    \n    # Commit flexible units until load can be met\n    current_capacity = 0\n    committed = set(np.where(u == 1)[0])\n    \n    # Calculate available capacity from must-run units\n    for i in committed:\n        if u_prev[i] == 1:\n            max_output = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            max_output = min(p_max[i], p_start[i])\n        current_capacity += max_output\n    \n    # Commit flexible units in cost order\n    for i in sorted_flexible:\n        if current_capacity >= load:\n            break\n        if u_prev[i] == 1:\n            max_output = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            max_output = min(p_max[i], p_start[i])\n        current_capacity += max_output\n        u[i] = 1\n        committed.add(i)\n    \n    # Step 5: Economic dispatch using lambda iteration\n    committed_idx = list(committed)\n    n_committed = len(committed_idx)\n    \n    # Initialize bounds for lambda iteration\n    lambda_low = -1000\n    lambda_high = 1000\n    tolerance = 1e-5\n    \n    # Perform lambda iteration\n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed_idx:\n            # Calculate unconstrained output\n            p_unconstrained = (lambda_mid - b[i]) / (2 * c[i])\n            \n            # Apply constraints\n            if u_prev[i] == 1:\n                lb = max(p_min[i], p_prev[i] - p_down[i])\n                ub = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                lb = p_min[i]\n                ub = min(p_max[i], p_start[i])\n            \n            p[i] = np.clip(p_unconstrained, lb, ub)\n            total_p += p[i]\n        \n        if abs(total_p - load) < tolerance:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tune to match load exactly\n    total_p = sum(p[committed_idx])\n    error = load - total_p\n    \n    while abs(error) > tolerance:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed_idx:\n            if error > 0:  # Need to increase output\n                if u_prev[i] == 1:\n                    ub = min(p_max[i], p_prev[i] + p_up[i])\n                else:\n                    ub = min(p_max[i], p_start[i])\n                if p[i] < ub - tolerance:\n                    adjustable.append(i)\n            else:  # Need to decrease output\n                if u_prev[i] == 1:\n                    lb = max(p_min[i], p_prev[i] - p_down[i])\n                else:\n                    lb = p_min[i]\n                if p[i] > lb + tolerance:\n                    adjustable.append(i)\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost\n        marginal_costs = [b[i] + 2*c[i]*p[i] for i in adjustable]\n        if error > 0:\n            idx_to_adjust = adjustable[np.argmin(marginal_costs)]\n            max_increase = min(p_max[idx_to_adjust], p_prev[idx_to_adjust] + p_up[idx_to_adjust]) - p[idx_to_adjust]\n            adjustment = min(error, max_increase)\n            p[idx_to_adjust] += adjustment\n        else:\n            idx_to_adjust = adjustable[np.argmax(marginal_costs)]\n            max_decrease = p[idx_to_adjust] - max(p_min[idx_to_adjust], p_prev[idx_to_adjust] - p_down[idx_to_adjust])\n            adjustment = min(-error, max_decrease)\n            p[idx_to_adjust] -= adjustment\n        \n        error = load - sum(p[committed_idx])\n    \n    # Ensure off units have zero output\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00921,
          "fitness": 0.00739
     },
     {
          "name": "enhanced_hybrid_rolling_dispatch_v2",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use (startup cost amortized over minimum up-time) + marginal cost at minimum output; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits considering startup/shutdown constraints\n6. Fine-tune outputs using marginal cost ordering with ramp-aware adjustments to exactly match load\n7. Validate solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_dispatch_v2(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = np.zeros(n_units, dtype=bool)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible_mask = np.zeros(n_units, dtype=bool)\n    cost_indices = np.zeros(n_units)\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    p_outputs = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible_mask[i] = True\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible_mask[i] = True\n                \n        if must_run[i]:\n            committed[i] = True\n            feasible_min[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            feasible_max[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        elif must_off[i]:\n            committed[i] = False\n            p_outputs[i] = 0.0\n        else:\n            if u_i0 == 1:\n                cost_indices[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            else:\n                amortized_startup = unit['s_i'] / (unit['t_on_min_i'] * unit['p_max_i'])\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n                cost_indices[i] = amortized_startup + marginal_cost\n    \n    flexible_indices = np.where(flexible_mask)[0]\n    sorted_flexible = flexible_indices[np.argsort(cost_indices[flexible_indices])]\n    \n    total_capacity = 0.0\n    for i in np.where(must_run)[0]:\n        total_capacity += feasible_max[i]\n    \n    for i in sorted_flexible:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        total_capacity += max_output\n        committed[i] = True\n        if unit['u_i_0'] == 1:\n            feasible_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            feasible_max[i] = max_output\n        else:\n            feasible_min[i] = unit['p_min_i']\n            feasible_max[i] = max_output\n    \n    committed_indices = np.where(committed)[0]\n    if not committed_indices.size:\n        return schedules\n    \n    low_lambda = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * feasible_min[i] for i in committed_indices)\n    high_lambda = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * feasible_max[i] for i in committed_indices)\n    \n    for _ in range(100):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_p = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            p_opt = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n            p_clamped = np.clip(p_opt, feasible_min[i], feasible_max[i])\n            total_p += p_clamped\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n    \n    total_p = 0.0\n    marginal_costs = []\n    for i in committed_indices:\n        unit = units_info[i]\n        p_opt = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n        p_outputs[i] = np.clip(p_opt, feasible_min[i], feasible_max[i])\n        total_p += p_outputs[i]\n        marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * p_outputs[i])\n    \n    diff = load - total_p\n    if abs(diff) > 1e-5:\n        committed_list = list(committed_indices)\n        if diff > 0:\n            sorted_units = [x for _, x in sorted(zip(marginal_costs, committed_list))]\n            for i in sorted_units:\n                if diff <= 0:\n                    break\n                available = feasible_max[i] - p_outputs[i]\n                if available > 0:\n                    add = min(diff, available)\n                    p_outputs[i] += add\n                    diff -= add\n        else:\n            sorted_units = [x for _, x in sorted(zip(marginal_costs, committed_list), reverse=True)]\n            for i in sorted_units:\n                if diff >= 0:\n                    break\n                available = p_outputs[i] - feasible_min[i]\n                if available > 0:\n                    deduct = min(-diff, available)\n                    p_outputs[i] -= deduct\n                    diff += deduct\n    \n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0.0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00561,
          "gap_price_rate": 0.0095,
          "fitness": 0.00756
     },
     {
          "name": "hybrid_rolling_cost_dispatch_v3",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate hybrid cost index for flexible units: for offline units use average cost at maximum output including startup cost; for online units use marginal cost at minimum output\n3. Sort flexible units by hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using bisection method with unit-specific ramp-aware output limits\n6. Fine-tune outputs using marginal cost ordering to exactly match load while respecting all constraints\n7. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch_v3(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        s = unit['s_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    cost_indices = []\n    for i in flexible:\n        unit = units_info[i]\n        u0 = unit['u_i_0']\n        if u0 == 0:\n            avg_cost = (unit['s_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n            cost_indices.append((i, avg_cost))\n        else:\n            marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            cost_indices.append((i, marg_cost))\n    \n    cost_indices.sort(key=lambda x: x[1])\n    flexible_sorted = [x[0] for x in cost_indices]\n    \n    committed = set(must_run)\n    total_capacity = 0.0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_capacity += max_p\n    \n    for i in flexible_sorted:\n        if total_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_capacity += max_p\n        committed.add(i)\n    \n    committed = list(committed)\n    \n    def compute_outputs(lmbda):\n        total_p = 0.0\n        outputs = []\n        for i in committed:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            u0 = unit['u_i_0']\n            p0 = unit['p_i_0']\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_up = unit['p_up_i']\n            p_down = unit['p_down_i']\n            p_start = unit['p_start_i']\n            \n            if u0 == 1:\n                lower = max(p_min, p0 - p_down)\n                upper = min(p_max, p0 + p_up)\n            else:\n                lower = p_min\n                upper = min(p_max, p_start)\n            \n            ideal_p = (lmbda - b) / (2 * c) if c > 0 else upper\n            actual_p = max(lower, min(upper, ideal_p))\n            outputs.append(actual_p)\n            total_p += actual_p\n        return total_p, outputs\n    \n    l_low = 0.0\n    l_high = 10000.0\n    tol = 1e-6\n    max_iter = 100\n    iter_count = 0\n    \n    while iter_count < max_iter:\n        l_mid = (l_low + l_high) / 2\n        total_p, _ = compute_outputs(l_mid)\n        if abs(total_p - load) < tol:\n            break\n        elif total_p < load:\n            l_low = l_mid\n        else:\n            l_high = l_mid\n        iter_count += 1\n    \n    _, p_vals = compute_outputs(l_mid)\n    for idx, i in enumerate(committed):\n        p[i] = p_vals[idx]\n        u[i] = 1\n    \n    total_p = sum(p)\n    mismatch = load - total_p\n    if abs(mismatch) > tol:\n        marginal_costs = []\n        for i in committed:\n            unit = units_info[i]\n            marg_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginal_costs.append((i, marg_cost))\n        \n        if mismatch > 0:\n            marginal_costs.sort(key=lambda x: x[1])\n            for i, _ in marginal_costs:\n                unit = units_info[i]\n                u0 = unit['u_i_0']\n                p0 = unit['p_i_0']\n                p_max = unit['p_max_i']\n                p_up = unit['p_up_i']\n                p_start = unit['p_start_i']\n                \n                if u0 == 1:\n                    max_inc = min(p_max, p0 + p_up) - p[i]\n                else:\n                    max_inc = min(p_max, p_start) - p[i]\n                \n                inc = min(mismatch, max_inc)\n                p[i] += inc\n                mismatch -= inc\n                if mismatch <= 0:\n                    break\n        else:\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            for i, _ in marginal_costs:\n                unit = units_info[i]\n                u0 = unit['u_i_0']\n                p0 = unit['p_i_0']\n                p_min = unit['p_min_i']\n                p_down = unit['p_down_i']\n                \n                if u0 == 1:\n                    max_dec = p[i] - max(p_min, p0 - p_down)\n                else:\n                    max_dec = p[i] - p_min\n                \n                dec = min(-mismatch, max_dec)\n                p[i] -= dec\n                mismatch += dec\n                if mismatch >= 0:\n                    break\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00542,
          "gap_price_rate": 0.00984,
          "fitness": 0.00763
     },
     {
          "name": "hybrid_rolling_cost_dispatch_v3",
          "algorithm": "1. Identify must-run units (violating min up-time or shutdown ramp constraints) and must-off units (violating min down-time constraints)\n2. Calculate enhanced hybrid cost index for flexible units: for offline units use prorated startup cost amortized over minimum up-time added to marginal cost at minimum output; for online units use marginal cost at minimum output\n3. Sort flexible units by enhanced hybrid cost index in ascending order\n4. Commit must-run units first, then activate flexible units in cost priority order until available capacity meets load\n5. Perform economic dispatch using adaptive bisection method with unit-specific ramp-aware output limits considering startup/shutdown constraints\n6. Fine-tune outputs using marginal cost ordering with ramp-aware adjustments to exactly match load\n7. Validate solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_cost_dispatch_v3(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    cost_index = np.full(n_units, np.inf)\n    flexible_units = []\n    for i, unit in enumerate(units_info):\n        if must_run[i] or must_off[i]:\n            continue\n        flexible_units.append(i)\n        if unit['u_i_0'] == 0:\n            prorated_startup = unit['s_i'] / (unit['t_on_min_i'] * unit['p_min_i'])\n            cost_index[i] = prorated_startup + unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        else:\n            cost_index[i] = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n    \n    flexible_units_sorted = sorted(flexible_units, key=lambda i: cost_index[i])\n    \n    committed_units = []\n    total_capacity = 0.0\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            committed_units.append(i)\n            if units_info[i]['u_i_0'] == 1:\n                max_p = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                max_p = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_capacity += max_p\n    \n    for i in flexible_units_sorted:\n        if total_capacity >= load:\n            break\n        u[i] = 1\n        committed_units.append(i)\n        if units_info[i]['u_i_0'] == 1:\n            max_p = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            max_p = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        total_capacity += max_p\n    \n    if not committed_units:\n        return np.array([u, p])\n    \n    lower_limits = []\n    upper_limits = []\n    for i in committed_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            up = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            up = min(unit['p_max_i'], unit['p_start_i'])\n        lower_limits.append(low)\n        upper_limits.append(up)\n    \n    lambda_low = -1e6\n    lambda_high = 1e6\n    tolerance = 1e-5\n    max_iter = 1000\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0.0\n        for idx, i in enumerate(committed_units):\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                p_val = upper_limits[idx] if lambda_mid > unit['b_i'] else lower_limits[idx]\n            else:\n                p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_val = np.clip(p_val, lower_limits[idx], upper_limits[idx])\n            total_gen += p_val\n        \n        if abs(total_gen - load) < tolerance:\n            break\n        elif total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    total_gen = 0.0\n    for idx, i in enumerate(committed_units):\n        unit = units_info[i]\n        if unit['c_i'] == 0:\n            p_val = upper_limits[idx] if lambda_mid > unit['b_i'] else lower_limits[idx]\n        else:\n            p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_val = np.clip(p_val, lower_limits[idx], upper_limits[idx])\n        p[i] = p_val\n        total_gen += p_val\n    \n    diff = load - total_gen\n    if abs(diff) > tolerance:\n        marginal_costs = []\n        for idx, i in enumerate(committed_units):\n            unit = units_info[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginal_costs.append((i, mc, idx))\n        \n        if diff > 0:\n            marginal_costs.sort(key=lambda x: x[1])\n            for i, mc, idx in marginal_costs:\n                if p[i] < upper_limits[idx]:\n                    add = min(diff, upper_limits[idx] - p[i])\n                    p[i] += add\n                    diff -= add\n                if diff <= 0:\n                    break\n        else:\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            for i, mc, idx in marginal_costs:\n                if p[i] > lower_limits[idx]:\n                    reduce = min(-diff, p[i] - lower_limits[idx])\n                    p[i] -= reduce\n                    diff += reduce\n                if diff >= 0:\n                    break\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00561,
          "gap_price_rate": 0.00983,
          "fitness": 0.00772
     }
]