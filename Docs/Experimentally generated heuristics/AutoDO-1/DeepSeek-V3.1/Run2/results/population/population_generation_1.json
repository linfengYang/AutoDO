[
     {
          "name": "enhanced_rolling_priority_dispatch",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints\n2. Sort available units by marginal cost at minimum output plus prorated startup cost\n3. Commit must-run units first, then activate additional units in sorted order until load can be met\n4. Perform economic dispatch using lambda iteration with ramp constraints\n5. Fine-tune outputs using marginal cost ordering to exactly match load\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitments\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Calculate available capacity from must-run units\n    total_min = 0\n    total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += p_min\n        total_max += p_max\n    \n    # Sort available units by cost criteria\n    available_units = []\n    for i in range(n_units):\n        if i not in must_run and i not in must_off:\n            unit = units_info[i]\n            marginal_cost = 2 * unit['c_i'] * unit['p_min_i'] + unit['b_i']\n            avg_startup_cost = unit['s_i'] / unit['p_max_i'] if unit['p_max_i'] > 0 else float('inf')\n            priority = marginal_cost + avg_startup_cost\n            available_units.append((priority, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    # Commit additional units if needed\n    if total_max < load:\n        for _, i in available_units:\n            if total_max >= load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += p_max\n    \n    # Economic dispatch with ramp constraints\n    committed = [i for i in range(n_units) if u[i] == 1]\n    # Set initial outputs to minimum feasible\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n    \n    total_p = sum(p)\n    \n    # Lambda iteration for dispatch\n    max_iter = 100\n    tolerance = 1e-6\n    for _ in range(max_iter):\n        # Calculate marginal costs\n        marginal_costs = [2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i'] for i in committed]\n        lambda_val = sum(marginal_costs) / len(committed) if committed else 0\n        \n        # Adjust outputs\n        for i in committed:\n            unit = units_info[i]\n            # Calculate feasible range\n            if unit['u_i_0'] == 1:\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_low = unit['p_min_i']\n                p_high = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Calculate unconstrained output\n            p_unconstrained = (lambda_val - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_high\n            new_p = max(p_low, min(p_high, p_unconstrained))\n            \n            # Update total power\n            total_p = total_p - p[i] + new_p\n            p[i] = new_p\n        \n        if abs(total_p - load) < tolerance:\n            break\n    \n    # Fine-tuning to match load exactly\n    diff = load - total_p\n    while abs(diff) > tolerance:\n        # Find units to adjust\n        if diff > 0:\n            # Increase output of unit with smallest marginal cost\n            candidates = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_high = min(unit['p_max_i'], unit['p_start_i'])\n                if p[i] < p_high:\n                    marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                    candidates.append((marginal_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            i = candidates[0][1]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_high = min(unit['p_max_i'], unit['p_start_i'])\n            max_increase = min(diff, p_high - p[i])\n            p[i] += max_increase\n            diff -= max_increase\n        else:\n            # Decrease output of unit with largest marginal cost\n            candidates = []\n            for i in committed:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_low = unit['p_min_i']\n                if p[i] > p_low:\n                    marginal_cost = 2 * unit['c_i'] * p[i] + unit['b_i']\n                    candidates.append((marginal_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            i = candidates[0][1]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_low = unit['p_min_i']\n            max_decrease = min(-diff, p[i] - p_low)\n            p[i] -= max_decrease\n            diff += max_decrease\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00571,
          "gap_price_rate": 0.01075,
          "fitness": 0.00823
     },
     {
          "name": "rolling_priority_list_with_ramp",
          "algorithm": "1. Identify must-run units based on minimum up-time and shutdown ramp constraints\n2. Sort available units by average cost including startup cost\n3. Commit must-run units first, then additional units until load is met\n4. Perform economic dispatch considering ramp constraints and cost optimization\n5. Adjust outputs to match load exactly using marginal cost ordering\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_with_ramp(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = [False] * n_units\n    must_run = [False] * n_units\n    max_outputs = [0.0] * n_units\n    min_outputs = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n                committed[i] = True\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            if -unit['t_i_0'] >= unit['t_off_min_i']:\n                max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n                min_outputs[i] = unit['p_min_i']\n            else:\n                max_outputs[i] = 0\n                min_outputs[i] = 0\n\n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not committed[i] and max_outputs[i] > 0:\n            avg_cost = (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n            available_units.append((avg_cost, i))\n    \n    available_units.sort(key=lambda x: x[0])\n    \n    current_capacity = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    for _, idx in available_units:\n        if current_capacity < load:\n            committed[idx] = True\n            current_capacity += max_outputs[idx]\n        else:\n            break\n\n    total_min = sum(min_outputs[i] for i in range(n_units) if committed[i])\n    total_max = sum(max_outputs[i] for i in range(n_units) if committed[i])\n    \n    if total_min > load:\n        for i in range(n_units):\n            if committed[i] and not must_run[i]:\n                committed[i] = False\n                total_min -= min_outputs[i]\n                if total_min <= load:\n                    break\n        if total_min > load:\n            for i in range(n_units):\n                if committed[i] and must_run[i]:\n                    schedules[0][i] = 1\n                    schedules[1][i] = min_outputs[i]\n            return schedules\n\n    outputs = [min_outputs[i] if committed[i] else 0 for i in range(n_units)]\n    remaining_load = load - total_min\n    \n    while remaining_load > 1e-6:\n        best_marginal = float('inf')\n        best_idx = -1\n        for i in range(n_units):\n            if committed[i] and outputs[i] < max_outputs[i]:\n                marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = i\n        if best_idx == -1:\n            break\n        \n        add_cap = min(remaining_load, max_outputs[best_idx] - outputs[best_idx])\n        outputs[best_idx] += add_cap\n        remaining_load -= add_cap\n\n    for i in range(n_units):\n        schedules[0][i] = 1 if committed[i] else 0\n        schedules[1][i] = outputs[i] if committed[i] else 0\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00624,
          "gap_price_rate": 0.0108,
          "fitness": 0.00852
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Determine must-run and must-off units based on minimum up/down times and shutdown capacity constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If needed, commit flexible units sorted by average cost per MW at maximum output\n4. Perform economic dispatch using greedy incremental cost method respecting ramp constraints\n5. Adjust outputs to match load while minimizing cost\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        \n    total_min_cap = 0\n    total_max_cap = 0\n    bounds = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    flexible_sorted = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2) / unit['p_max_i']\n        else:\n            cost_per_mw = (unit['a_i'] + unit['b_i']*unit['p_max_i'] + unit['c_i']*unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        flexible_sorted.append((cost_per_mw, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    for cost, i in flexible_sorted:\n        if total_max_cap >= load:\n            break\n        unit = units_info[i]\n        u[i] = 1\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min_cap += lb\n        total_max_cap += ub\n        \n    committed = [i for i in range(n_units) if u[i] == 1]\n    for i in committed:\n        p[i] = bounds[i][0]\n        \n    remaining = load - sum(p)\n    if remaining < 0:\n        remaining = 0\n        \n    active_units = committed.copy()\n    while remaining > 0 and active_units:\n        best_unit = None\n        best_marginal = float('inf')\n        for i in active_units:\n            unit = units_info[i]\n            marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            if marginal < best_marginal and p[i] < bounds[i][1]:\n                best_marginal = marginal\n                best_unit = i\n                \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        max_add = bounds[best_unit][1] - p[best_unit]\n        add = min(remaining, max_add)\n        p[best_unit] += add\n        remaining -= add\n        \n        if p[best_unit] >= bounds[best_unit][1]:\n            active_units.remove(best_unit)\n            \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "rolling_commitment_with_amortized_cost",
          "algorithm": "1. Identify must-run and must-off units based on minimum up/down times and shutdown ramp constraints\n2. Initialize commitments using must-run units and previous states\n3. Calculate required additional capacity and commit units sorted by amortized average cost (startup cost prorated over minimum up-time plus marginal cost at maximum output)\n4. Perform economic dispatch using incremental cost sorting while respecting ramp constraints and output limits\n5. Adjust outputs to exactly match load using marginal cost ordering\n6. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_with_amortized_cost(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Initialize commitments\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += p_min\n            total_max += p_max\n    \n    # Step 3: Commit additional units if needed\n    if total_max < load:\n        # Create list of available units\n        available_units = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 0 and i not in must_off:\n                # Calculate amortized average cost\n                min_up_time = unit['t_on_min_i']\n                avg_cost = (unit['s_i'] / min_up_time + unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i'] ** 2) / unit['p_max_i']\n                available_units.append((i, avg_cost))\n        \n        # Sort by amortized average cost\n        available_units.sort(key=lambda x: x[1])\n        \n        # Commit units until load is met\n        for i, _ in available_units:\n            if total_max >= load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            total_max += min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Economic dispatch\n    committed = [i for i in range(n_units) if u[i] == 1]\n    \n    # Initialize outputs\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p[i] = unit['p_min_i']\n    \n    total_p = np.sum(p)\n    \n    # Dispatch load using incremental cost\n    while abs(total_p - load) > 1e-6:\n        if total_p < load:\n            # Find unit with smallest incremental cost that can increase\n            inc_costs = []\n            for i in committed:\n                unit = units_info[i]\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                if unit['u_i_0'] == 1:\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if p[i] < p_max:\n                    inc_costs.append((i, inc_cost))\n            if not inc_costs:\n                break\n            i = min(inc_costs, key=lambda x: x[1])[0]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            delta = min(load - total_p, p_max - p[i])\n            p[i] += delta\n            total_p += delta\n        else:\n            # Find unit with largest incremental cost that can decrease\n            inc_costs = []\n            for i in committed:\n                unit = units_info[i]\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_min = unit['p_min_i']\n                if p[i] > p_min:\n                    inc_costs.append((i, inc_cost))\n            if not inc_costs:\n                break\n            i = max(inc_costs, key=lambda x: x[1])[0]\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_min = unit['p_min_i']\n            delta = min(total_p - load, p[i] - p_min)\n            p[i] -= delta\n            total_p -= delta\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 7e-05,
          "gap_price_rate": 0.03565,
          "fitness": 0.01786
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Determine mandatory commitments based on minimum up/down times and shutdown ramp limits\n2. Initialize commitments using previous states and mandatory requirements\n3. Adjust commitments based on load demand:\n   - If load exceeds current capacity, activate units by ascending marginal cost at minimum output\n   - If load is below minimum capacity, deactivate units by descending marginal cost\n4. Perform economic dispatch considering ramp constraints:\n   - Set initial outputs to minimum feasible levels\n   - Increase outputs of units with lowest marginal costs first until load is met\n   - Decrease outputs of units with highest marginal costs if over generation occurs\n5. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        ton_min = unit['t_on_min_i']\n        toff_min = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < ton_min or p0 > pshut:\n                must_on[i] = True\n        else:\n            if abs(t0) < toff_min:\n                must_off[i] = True\n    \n    u = [0] * n_units\n    low_bounds = [0] * n_units\n    high_bounds = [0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n            \n    total_min = 0\n    total_max = 0\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_bounds[i] = unit['p_min_i']\n                high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low_bounds[i]\n            total_max += high_bounds[i]\n        else:\n            low_bounds[i] = 0\n            high_bounds[i] = 0\n\n    off_units = [i for i in range(n_units) if not u[i] and not must_off[i] and not must_on[i]]\n    off_units.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_min_i'] + units_info[i]['s_i']/units_info[i]['p_min_i'])\n    \n    for i in off_units:\n        if total_max >= load:\n            break\n        u[i] = 1\n        unit = units_info[i]\n        low_bounds[i] = unit['p_min_i']\n        high_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += low_bounds[i]\n        total_max += high_bounds[i]\n\n    on_units_flex = [i for i in range(n_units) if u[i] == 1 and not must_on[i] and not must_off[i]]\n    on_units_flex.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*units_info[i]['p_min_i'] + units_info[i]['s_i']/units_info[i]['p_min_i'], reverse=True)\n    \n    for i in on_units_flex:\n        if total_min <= load:\n            break\n        u[i] = 0\n        total_min -= low_bounds[i]\n        total_max -= high_bounds[i]\n        low_bounds[i] = 0\n        high_bounds[i] = 0\n\n    p = [0] * n_units\n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = low_bounds[i]\n        else:\n            p[i] = 0\n\n    total_output = sum(p)\n    \n    if total_output > load:\n        reducible = [i for i in range(n_units) if u[i] == 1 and p[i] > low_bounds[i]]\n        reducible.sort(key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'], reverse=True)\n        for i in reducible:\n            if total_output <= load:\n                break\n            reduction = min(total_output - load, p[i] - low_bounds[i])\n            p[i] -= reduction\n            total_output -= reduction\n    elif total_output < load:\n        increasable = [i for i in range(n_units) if u[i] == 1 and p[i] < high_bounds[i]]\n        increasable.sort(key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n        for i in increasable:\n            if total_output >= load:\n                break\n            increase = min(load - total_output, high_bounds[i] - p[i])\n            p[i] += increase\n            total_output += increase\n\n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 7e-05,
          "gap_price_rate": 0.04106,
          "fitness": 0.02056
     },
     {
          "name": "rolling_priority_dispatch",
          "algorithm": "1. Identify must-run units based on minimum up-time and shutdown ramp constraints, and must-off units based on minimum down-time constraints\n2. Compute average cost including startup cost for flexible units and sort by priority\n3. Initialize commitments using must-run units and previous states of flexible units\n4. Adjust commitments based on load demand by committing/decommitting flexible units using priority order\n5. Perform economic dispatch considering ramp constraints by first setting outputs to minimum feasible levels, then adjusting using marginal cost ordering\n6. Fine-tune outputs to match load exactly while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef rolling_priority_dispatch(units_info, load):\n    units = units_info\n    num_units = len(units)\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_run.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n    \n    # Calculate average cost for flexible units\n    flexible_units = []\n    avg_costs = []\n    for i, unit in enumerate(units):\n        if i not in must_run and i not in must_off:\n            p_min = unit['p_min_i']\n            if p_min > 0:\n                avg_cost = (unit['s_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            else:\n                avg_cost = float('inf')\n            flexible_units.append(i)\n            avg_costs.append(avg_cost)\n    \n    # Sort flexible units by average cost\n    flexible_sorted = [x for _, x in sorted(zip(avg_costs, flexible_units))]\n    \n    # Initialize commitment states\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in flexible_units:\n        u[i] = units[i]['u_i_0']\n    \n    # Adjust commitments based on load demand\n    total_min = 0\n    total_max = 0\n    for i in range(num_units):\n        if u[i] == 1:\n            u0 = units[i]['u_i_0']\n            p0 = units[i]['p_i_0']\n            if u0 == 1:\n                p_min = max(units[i]['p_min_i'], p0 - units[i]['p_down_i'])\n                p_max = min(units[i]['p_max_i'], p0 + units[i]['p_up_i'])\n            else:\n                p_min = units[i]['p_min_i']\n                p_max = min(units[i]['p_start_i'], units[i]['p_max_i'])\n            total_min += p_min\n            total_max += p_max\n        else:\n            p_min = 0\n            p_max = 0\n    \n    if load > total_max:\n        for i in flexible_sorted:\n            if u[i] == 0:\n                u[i] = 1\n                p_min = units[i]['p_min_i']\n                p_max = min(units[i]['p_start_i'], units[i]['p_max_i'])\n                total_min += p_min\n                total_max += p_max\n                if total_max >= load:\n                    break\n    elif load < total_min:\n        for i in reversed(flexible_sorted):\n            if u[i] == 1:\n                u0 = units[i]['u_i_0']\n                p0 = units[i]['p_i_0']\n                if u0 == 1:\n                    p_min = max(units[i]['p_min_i'], p0 - units[i]['p_down_i'])\n                else:\n                    p_min = units[i]['p_min_i']\n                total_min -= p_min\n                total_max -= min(units[i]['p_max_i'], units[i]['p_start_i'])\n                u[i] = 0\n                if total_min <= load:\n                    break\n    \n    # Economic dispatch\n    committed = [i for i in range(num_units) if u[i] == 1]\n    for i in committed:\n        u0 = units[i]['u_i_0']\n        p0 = units[i]['p_i_0']\n        if u0 == 1:\n            p[i] = max(units[i]['p_min_i'], p0 - units[i]['p_down_i'])\n        else:\n            p[i] = units[i]['p_min_i']\n    \n    total_p = sum(p)\n    \n    # Increase output if needed\n    if total_p < load:\n        marginal_costs = []\n        for i in committed:\n            u0 = units[i]['u_i_0']\n            p0 = units[i]['p_i_0']\n            if u0 == 1:\n                p_max = min(units[i]['p_max_i'], p0 + units[i]['p_up_i'])\n            else:\n                p_max = min(units[i]['p_start_i'], units[i]['p_max_i'])\n            if p[i] < p_max:\n                marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        for mc, i in marginal_costs:\n            u0 = units[i]['u_i_0']\n            p0 = units[i]['p_i_0']\n            if u0 == 1:\n                p_max = min(units[i]['p_max_i'], p0 + units[i]['p_up_i'])\n            else:\n                p_max = min(units[i]['p_start_i'], units[i]['p_max_i'])\n            add = min(load - total_p, p_max - p[i])\n            p[i] += add\n            total_p += add\n            if total_p >= load:\n                break\n    \n    # Decrease output if needed\n    if total_p > load:\n        marginal_costs = []\n        for i in committed:\n            u0 = units[i]['u_i_0']\n            p0 = units[i]['p_i_0']\n            if u0 == 1:\n                p_min = max(units[i]['p_min_i'], p0 - units[i]['p_down_i'])\n            else:\n                p_min = units[i]['p_min_i']\n            if p[i] > p_min:\n                marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                marginal_costs.append((marginal_cost, i))\n        \n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n        for mc, i in marginal_costs:\n            u0 = units[i]['u_i_0']\n            p0 = units[i]['p_i_0']\n            if u0 == 1:\n                p_min = max(units[i]['p_min_i'], p0 - units[i]['p_down_i'])\n            else:\n                p_min = units[i]['p_min_i']\n            subtract = min(total_p - load, p[i] - p_min)\n            p[i] -= subtract\n            total_p -= subtract\n            if total_p <= load:\n                break\n    \n    schedules = np.zeros((2, num_units))\n    schedules[0] = u\n    schedules[1] = p\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 7e-05,
          "gap_price_rate": 0.04106,
          "fitness": 0.02057
     },
     {
          "name": "rolling_adaptive_dispatch",
          "algorithm": "1. Identify must-run and must-off units using minimum up/down times and shutdown ramp constraints\n2. Initialize commitments based on must-run status and previous states\n3. Sort available units by marginal cost at minimum output plus prorated startup cost\n4. Commit additional units in cost order until load can be met considering ramp limits\n5. Perform economic dispatch using incremental cost optimization with ramp-aware adjustment\n6. Fine-tune outputs using marginal cost ordering to exactly match load\n7. Validate and enforce all physical constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef rolling_adaptive_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Create working copies of unit information\n    units = [dict(unit) for unit in units_info]\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:  # Unit was online\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run[i] = True\n            if unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:  # Unit was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Step 2: Initialize commitments\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units[i]['u_i_0']  # Maintain previous state\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i, unit in enumerate(units):\n        if u[i] == 1:\n            # Calculate min and max possible output considering ramp constraints\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min = unit['p_min_i']\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += p_min\n            total_max += p_max\n    \n    # Step 3-4: Commit additional units if needed\n    if total_max < load:\n        # Calculate cost metrics for available units\n        costs = []\n        available_units = []\n        for i, unit in enumerate(units):\n            if not must_run[i] and not must_off[i] and u[i] == 0:\n                # Calculate average cost including startup\n                avg_cost = (unit['s_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n                costs.append(avg_cost)\n                available_units.append(i)\n        \n        # Sort by cost\n        sorted_units = [i for _, i in sorted(zip(costs, available_units))]\n        \n        # Commit units until load can be met\n        for i in sorted_units:\n            if total_max >= load:\n                break\n            u[i] = 1\n            unit = units[i]\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += p_max\n    \n    # Step 5: Economic dispatch\n    # Initialize outputs to minimum feasible values\n    for i, unit in enumerate(units):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p[i] = unit['p_min_i']\n    \n    current_total = np.sum(p)\n    remaining_load = load - current_total\n    \n    # Calculate marginal costs\n    marginal_costs = []\n    for i, unit in enumerate(units):\n        if u[i] == 1:\n            mc = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            marginal_costs.append((mc, i))\n    \n    # Sort units by marginal cost\n    marginal_costs.sort(key=lambda x: x[0])\n    \n    # Increase outputs starting from lowest marginal cost\n    for mc, i in marginal_costs:\n        if remaining_load <= 0:\n            break\n        \n        unit = units[i]\n        # Calculate maximum possible increase\n        if unit['u_i_0'] == 1:\n            max_increase = min(unit['p_max_i'] - p[i], unit['p_up_i'])\n        else:\n            max_increase = min(unit['p_max_i'] - p[i], unit['p_start_i'])\n        \n        increase = min(remaining_load, max_increase)\n        p[i] += increase\n        remaining_load -= increase\n    \n    # Step 6: Fine-tuning to exactly match load\n    current_total = np.sum(p)\n    mismatch = load - current_total\n    \n    if mismatch > 0:\n        # Under generation - increase output of most efficient units\n        for mc, i in marginal_costs:\n            if mismatch <= 0:\n                break\n            unit = units[i]\n            available = unit['p_max_i'] - p[i]\n            increase = min(mismatch, available)\n            p[i] += increase\n            mismatch -= increase\n    else:\n        # Over generation - decrease output of least efficient units\n        for mc, i in reversed(marginal_costs):\n            if mismatch >= 0:\n                break\n            unit = units[i]\n            # Calculate minimum feasible output\n            if unit['u_i_0'] == 1:\n                min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_output = unit['p_min_i']\n            decrease = min(p[i] - min_output, -mismatch)\n            p[i] -= decrease\n            mismatch += decrease\n    \n    # Step 7: Final validation\n    for i, unit in enumerate(units):\n        if u[i] == 1:\n            # Enforce minimum and maximum limits\n            p[i] = max(unit['p_min_i'], min(unit['p_max_i'], p[i]))\n            \n            # Enforce ramp constraints\n            if unit['u_i_0'] == 1:\n                p[i] = max(unit['p_i_0'] - unit['p_down_i'], \n                          min(unit['p_i_0'] + unit['p_up_i'], p[i]))\n            else:\n                p[i] = min(unit['p_start_i'], p[i])\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.01662,
          "gap_price_rate": 0.03508,
          "fitness": 0.02585
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Identify must-run and must-off units based on min up/down times and shutdown ramp constraints\n2. Set must-run units to on and must-off units to off\n3. Calculate total output from must-run units considering ramp constraints\n4. If needed, turn on available units by priority (marginal cost + prorated startup cost)\n5. Dispatch load among committed units using economic dispatch considering ramp constraints\n6. Return schedule with commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_run = np.zeros(n, dtype=bool)\n    must_off = np.zeros(n, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_output = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            p_low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p[i] = max(p_low, unit['p_min_i'])\n            p[i] = min(p[i], p_high)\n            total_output += p[i]\n        elif must_off[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    available_units = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i] and unit['p_min_i'] <= unit['p_start_i']:\n            priority = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'] + unit['s_i'] / unit['t_on_min_i']\n            available_units.append((i, priority))\n    \n    available_units.sort(key=lambda x: x[1])\n    \n    for idx, _ in available_units:\n        if total_output >= load:\n            break\n        unit = units_info[idx]\n        u[idx] = 1\n        p[idx] = unit['p_min_i']\n        total_output += p[idx]\n    \n    committed_idxs = [i for i in range(n) if u[i] == 1]\n    low_bounds = np.zeros(len(committed_idxs))\n    high_bounds = np.zeros(len(committed_idxs))\n    current_outputs = np.zeros(len(committed_idxs))\n    \n    for j, i in enumerate(committed_idxs):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_bounds[j] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bounds[j] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bounds[j] = unit['p_min_i']\n            high_bounds[j] = min(unit['p_max_i'], unit['p_start_i'])\n        current_outputs[j] = p[i]\n    \n    total_min = np.sum(low_bounds)\n    remaining_load = load - total_min\n    \n    if remaining_load > 0:\n        marginal_costs = []\n        for j, i in enumerate(committed_idxs):\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[j]\n            marginal_costs.append((j, marginal_cost))\n        \n        marginal_costs.sort(key=lambda x: x[1])\n        \n        for j, _ in marginal_costs:\n            if remaining_load <= 0:\n                break\n            available = high_bounds[j] - current_outputs[j]\n            if available > 0:\n                add = min(remaining_load, available)\n                current_outputs[j] += add\n                remaining_load -= add\n        \n        for j, i in enumerate(committed_idxs):\n            p[i] = current_outputs[j]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.09239,
          "fitness": 0.04623
     },
     {
          "name": "enhanced_rolling_marginal_cost",
          "algorithm": "1. Identify must-run/must-off units considering min up/down times and shutdown ramp constraints\n2. Calculate residual load after must-run units' minimum feasible output\n3. Commit flexible units by ascending marginal cost at minimum output plus prorated startup cost\n4. Perform economic dispatch using incremental cost ranking with ramp-aware capacity limits\n5. Fine-tune outputs using bisection method to exactly match load while respecting all constraints\n6. Validate and adjust for minimum runtime violations post-dispatch\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Calculate feasible output ranges\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_feasible[i] = unit['p_min_i']\n                max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n    \n    # Commit additional units if needed\n    residual_load = load - np.sum(min_feasible)\n    flexible_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    \n    # Priority list based on marginal cost at min output + prorated startup\n    priority_list = []\n    for i in flexible_units:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        prorated_startup = unit['s_i'] / unit['p_max_i'] if unit['u_i_0'] == 0 else 0\n        priority_list.append((marginal_cost + prorated_startup, i))\n    \n    priority_list.sort(key=lambda x: x[0])\n    \n    for _, i in priority_list:\n        if residual_load > 0:\n            u[i] = 1\n            min_feasible[i] = units_info[i]['p_min_i']\n            max_feasible[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            residual_load -= min_feasible[i]\n        else:\n            u[i] = 0\n    \n    # Economic dispatch\n    p = min_feasible.copy()\n    remaining_load = load - np.sum(p)\n    \n    # Create dispatch order based on incremental cost\n    incremental_costs = []\n    for i in range(n_units):\n        if u[i] == 1:\n            inc_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n            incremental_costs.append((inc_cost, i))\n    \n    incremental_costs.sort(key=lambda x: x[0])\n    \n    # Dispatch load to units with lowest incremental cost\n    for _, i in incremental_costs:\n        if remaining_load <= 0:\n            break\n        \n        available = max_feasible[i] - p[i]\n        add_load = min(remaining_load, available)\n        p[i] += add_load\n        remaining_load -= add_load\n    \n    # Fine-tuning with bisection method\n    def total_output(p_vec):\n        return np.sum(p_vec)\n    \n    lower_bound = min_feasible.copy()\n    upper_bound = max_feasible.copy()\n    \n    for _ in range(10):  # 10 iterations for convergence\n        mid = (lower_bound + upper_bound) / 2\n        total_mid = total_output(mid)\n        if abs(total_mid - load) < 1e-5:\n            p = mid\n            break\n        elif total_mid < load:\n            lower_bound = mid\n        else:\n            upper_bound = mid\n    \n    # Validate min up/down times\n    for i in range(n_units):\n        if u[i] == 1 and units_info[i]['u_i_0'] == 0:\n            if units_info[i]['t_i_0'] > -units_info[i]['t_off_min_i']:\n                u[i] = 0\n                p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.03374,
          "gap_price_rate": 0.07575,
          "fitness": 0.05475
     },
     {
          "name": "improved_rolling_priority_list",
          "algorithm": "1. Identify must-run and must-off units considering minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units using ramp-constrained limits\n3. Commit additional units by priority based on marginal cost at minimum output plus prorated startup cost\n4. Perform economic dispatch using lambda iteration with ramp-constrained output limits\n5. Adjust outputs to exactly match load while respecting all constraints\n",
          "code": "import numpy as np\n\ndef improved_rolling_priority_list(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Set must-run units to on\n    for i in must_run:\n        u[i] = 1\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p[i] = p_min\n    \n    # Set must-off units to off\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    # Calculate current total output\n    total_output = np.sum(p)\n    \n    # If load not met, commit additional units by priority\n    if total_output < load:\n        available_units = [i for i in range(n_units) if i not in must_run and i not in must_off]\n        # Calculate priority: marginal cost at min output + startup cost prorated by min output\n        priorities = []\n        for i in available_units:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            prorated_startup = unit['s_i'] / unit['p_min_i'] if unit['p_min_i'] > 0 else float('inf')\n            priorities.append(marginal_cost + prorated_startup)\n        \n        # Sort by priority (ascending)\n        sorted_units = [i for _, i in sorted(zip(priorities, available_units))]\n        \n        for i in sorted_units:\n            if total_output >= load:\n                break\n            u[i] = 1\n            unit = units_info[i]\n            if unit['u_i_0'] == 0:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_min = unit['p_min_i']\n            p[i] = p_min\n            total_output += p_min\n    \n    # Economic dispatch using lambda iteration\n    committed = np.where(u == 1)[0]\n    if len(committed) > 0:\n        # Calculate feasible output ranges\n        p_mins = np.zeros(len(committed))\n        p_maxs = np.zeros(len(committed))\n        for idx, i in enumerate(committed):\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_mins[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_maxs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_mins[idx] = unit['p_min_i']\n                p_maxs[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Lambda iteration\n        lambda_low = min(unit['b_i'] + 2 * unit['c_i'] * p_mins[idx] for idx, i in enumerate(committed))\n        lambda_high = max(unit['b_i'] + 2 * unit['c_i'] * p_maxs[idx] for idx, i in enumerate(committed))\n        \n        tolerance = 1e-5\n        while lambda_high - lambda_low > tolerance:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for idx, i in enumerate(committed):\n                unit = units_info[i]\n                p_dispatch = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_dispatch = np.clip(p_dispatch, p_mins[idx], p_maxs[idx])\n                total_p += p_dispatch\n            \n            if total_p < load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Set final outputs\n        for idx, i in enumerate(committed):\n            unit = units_info[i]\n            p_dispatch = (lambda_low - unit['b_i']) / (2 * unit['c_i'])\n            p[i] = np.clip(p_dispatch, p_mins[idx], p_maxs[idx])\n    \n    return np.vstack((u, p))",
          "from": "mutation",
          "gap_power_rate": 0.16542,
          "gap_price_rate": 0.13158,
          "fitness": 0.1485
     }
]