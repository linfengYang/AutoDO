{
     "name": "hybrid_avg_marginal_commitment",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Set must-run units to on state with minimum feasible output considering ramp constraints\n3. Set must-off units to off state with zero output\n4. Sort flexible units by average cost at minimum output (including startup cost for offline units)\n5. Commit flexible units in cost order until total maximum capacity meets or exceeds load\n6. Perform economic dispatch using priority-based incremental adjustment:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from units with smallest marginal cost while respecting constraints\n   d. Decrease generation from units with largest marginal cost if surplus occurs\n7. Ensure exact load matching through fine-tuning adjustments\n8. Maintain all operational constraints throughout the process\n\n",
     "code": "import numpy as np\n\ndef hybrid_avg_marginal_commitment(units_info, load):\n    units = units_info.copy()\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['p_i'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n    \n    for unit in must_off:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    def cost_metric(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_metric)\n    \n    total_capacity = 0\n    for unit in must_run:\n        total_capacity += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    committed_flexible = []\n    for unit in flexible:\n        if total_capacity >= load:\n            break\n        max_output = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_capacity += max_output\n        unit['u_i'] = 1\n        committed_flexible.append(unit)\n    \n    for unit in flexible[len(committed_flexible):]:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    committed_units = must_run + committed_flexible\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            unit['p_i'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            unit['p_i'] = unit['p_min_i']\n    \n    total_power = sum(unit['p_i'] for unit in committed_units)\n    deficit = load - total_power\n    \n    step = 0.1\n    tolerance = 1e-6\n    \n    while abs(deficit) > tolerance:\n        if deficit > 0:\n            candidate = None\n            min_marginal = float('inf')\n            for unit in committed_units:\n                marginal = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                max_feasible = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                if unit['p_i'] < max_feasible and marginal < min_marginal:\n                    min_marginal = marginal\n                    candidate = unit\n            if candidate:\n                max_feasible = min(candidate['p_max_i'], candidate['p_start_i']) if candidate['u_i_0'] == 0 else min(candidate['p_max_i'], candidate['p_i_0'] + candidate['p_up_i'])\n                increment = min(step, deficit, max_feasible - candidate['p_i'])\n                candidate['p_i'] += increment\n                total_power += increment\n                deficit -= increment\n            else:\n                break\n        else:\n            candidate = None\n            max_marginal = -float('inf')\n            for unit in committed_units:\n                marginal = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                min_feasible = unit['p_min_i'] if unit['u_i_0'] == 0 else max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                if unit['p_i'] > min_feasible and marginal > max_marginal:\n                    max_marginal = marginal\n                    candidate = unit\n            if candidate:\n                min_feasible = candidate['p_min_i'] if candidate['u_i_0'] == 0 else max(candidate['p_min_i'], candidate['p_i_0'] - candidate['p_down_i'])\n                decrement = min(step, -deficit, candidate['p_i'] - min_feasible)\n                candidate['p_i'] -= decrement\n                total_power -= decrement\n                deficit += decrement\n            else:\n                break\n    \n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.00543,
     "gap_price_rate": 0.00878,
     "fitness": 0.0071
}