{
     "name": "commit_units_by_marginal_cost",
     "algorithm": "1. Classify units into must-on, must-off, and free based on minimum up/down times and shutdown ramp constraints.\n2. Set must-off units to off state and zero output.\n3. Calculate total minimum and maximum output from must-on units.\n4. Commit free units in ascending order of average cost at maximum output (including startup cost if applicable) until the total maximum output meets or exceeds the load.\n5. Perform economic dispatch using a priority queue to adjust outputs incrementally based on marginal cost, respecting ramp constraints and output limits.\n6. Set uncommitted free units to off state and zero output.\n\n",
     "code": "import numpy as np\nimport heapq\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_on = []\n    must_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if t_i0 > -t_off_min_i:\n                must_off.append(i)\n            else:\n                free_units.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    committed = must_on.copy()\n    total_min = 0.0\n    total_max = 0.0\n    low_bounds_must_on = []\n    high_bounds_must_on = []\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds_must_on.append(low_i)\n        high_bounds_must_on.append(high_i)\n        total_min += low_i\n        total_max += high_i\n        u[i] = 1\n    \n    free_units_sorted = []\n    for i in free_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2)) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2) + unit['s_i']) / unit['p_max_i']\n        free_units_sorted.append((avg_cost, i))\n    \n    free_units_sorted.sort(key=lambda x: x[0])\n    committed_free = []\n    \n    for avg_cost, i in free_units_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += high_i\n        committed_free.append(i)\n        u[i] = 1\n        committed.append(i)\n    \n    for i in free_units:\n        if i not in committed_free:\n            u[i] = 0\n            p[i] = 0\n    \n    low_bounds = []\n    high_bounds = []\n    indices = committed\n    for i in indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds.append(low_i)\n        high_bounds.append(high_i)\n    \n    current_outputs = low_bounds.copy()\n    total_output = sum(current_outputs)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        heap = []\n        for idx, i in enumerate(indices):\n            if current_outputs[idx] < high_bounds[idx]:\n                unit = units_info[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                heapq.heappush(heap, (marginal_cost, idx, i))\n        \n        while deficit > 0 and heap:\n            marginal_cost, idx, i = heapq.heappop(heap)\n            available = high_bounds[idx] - current_outputs[idx]\n            if available > 0:\n                increase = min(deficit, available)\n                current_outputs[idx] += increase\n                deficit -= increase\n                if current_outputs[idx] < high_bounds[idx]:\n                    unit = units_info[i]\n                    new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                    heapq.heappush(heap, (new_marginal_cost, idx, i))\n    \n    for idx, i in enumerate(indices):\n        p[i] = current_outputs[idx]\n    \n    return np.array([u, p])",
     "from": null,
     "gap_power_rate": 0.00668,
     "gap_price_rate": 0.0112,
     "fitness": 0.00894
}