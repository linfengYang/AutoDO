[
     {
          "name": "hybrid_avg_marginal_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Set must-run units to on state with minimum feasible output considering ramp constraints\n3. Set must-off units to off state with zero output\n4. Sort flexible units by average cost at minimum output (including startup cost for offline units)\n5. Commit flexible units in cost order until total maximum capacity meets or exceeds load\n6. Perform economic dispatch using priority-based incremental adjustment:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from units with smallest marginal cost while respecting constraints\n   d. Decrease generation from units with largest marginal cost if surplus occurs\n7. Ensure exact load matching through fine-tuning adjustments\n8. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef hybrid_avg_marginal_commitment(units_info, load):\n    units = units_info.copy()\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        unit['u_i'] = 1\n        unit['p_i'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n    \n    for unit in must_off:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    def cost_metric(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_metric)\n    \n    total_capacity = 0\n    for unit in must_run:\n        total_capacity += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    committed_flexible = []\n    for unit in flexible:\n        if total_capacity >= load:\n            break\n        max_output = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_capacity += max_output\n        unit['u_i'] = 1\n        committed_flexible.append(unit)\n    \n    for unit in flexible[len(committed_flexible):]:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    committed_units = must_run + committed_flexible\n    \n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            unit['p_i'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            unit['p_i'] = unit['p_min_i']\n    \n    total_power = sum(unit['p_i'] for unit in committed_units)\n    deficit = load - total_power\n    \n    step = 0.1\n    tolerance = 1e-6\n    \n    while abs(deficit) > tolerance:\n        if deficit > 0:\n            candidate = None\n            min_marginal = float('inf')\n            for unit in committed_units:\n                marginal = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                max_feasible = min(unit['p_max_i'], unit['p_start_i']) if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                if unit['p_i'] < max_feasible and marginal < min_marginal:\n                    min_marginal = marginal\n                    candidate = unit\n            if candidate:\n                max_feasible = min(candidate['p_max_i'], candidate['p_start_i']) if candidate['u_i_0'] == 0 else min(candidate['p_max_i'], candidate['p_i_0'] + candidate['p_up_i'])\n                increment = min(step, deficit, max_feasible - candidate['p_i'])\n                candidate['p_i'] += increment\n                total_power += increment\n                deficit -= increment\n            else:\n                break\n        else:\n            candidate = None\n            max_marginal = -float('inf')\n            for unit in committed_units:\n                marginal = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                min_feasible = unit['p_min_i'] if unit['u_i_0'] == 0 else max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                if unit['p_i'] > min_feasible and marginal > max_marginal:\n                    max_marginal = marginal\n                    candidate = unit\n            if candidate:\n                min_feasible = candidate['p_min_i'] if candidate['u_i_0'] == 0 else max(candidate['p_min_i'], candidate['p_i_0'] - candidate['p_down_i'])\n                decrement = min(step, -deficit, candidate['p_i'] - min_feasible)\n                candidate['p_i'] -= decrement\n                total_power -= decrement\n                deficit += decrement\n            else:\n                break\n    \n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.0071
     },
     {
          "name": "improved_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units at their minimum feasible output considering ramp constraints\n3. Sort flexible units by average cost at maximum output including prorated startup cost for offline units\n4. Commit flexible units in cost order until total available capacity meets load, respecting startup ramp limits\n5. Perform economic dispatch using priority-based incremental adjustment with adaptive step sizes:\n   a. Initialize all committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from cheapest units using marginal cost priority queue\n   d. Decrease generation from most expensive units if surplus occurs\n6. Ensure exact load matching through fine-tuning adjustments\n7. Maintain all operational constraints throughout the process\n",
          "code": "import numpy as np\nimport heapq\n\ndef improved_rolling_commitment_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    committed = []\n    total_min_cap = 0\n    total_max_cap = 0\n    \n    for i in must_run:\n        unit = units_info[i]\n        u[i] = 1\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p[i] = min_p\n        total_min_cap += min_p\n        total_max_cap += max_p\n        committed.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    def avg_cost(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n    \n    flexible_sorted = sorted(flexible, key=lambda i: avg_cost(units_info[i]))\n    \n    for i in flexible_sorted:\n        if total_max_cap >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n        \n        total_max_cap += max_p\n        total_min_cap += min_p\n        u[i] = 1\n        p[i] = min_p\n        committed.append(i)\n    \n    total_output = np.sum(p)\n    deficit = load - total_output\n    \n    step = 1.0\n    while abs(deficit) > 1e-8:\n        if deficit > 0:\n            heap = []\n            for i in committed:\n                unit = units_info[i]\n                current_p = p[i]\n                if unit['u_i_0'] == 0:\n                    max_p = min(unit['p_max_i'], unit['p_start_i'])\n                else:\n                    max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                \n                if current_p < max_p - 1e-8:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                    heapq.heappush(heap, (marginal_cost, i))\n            \n            if not heap:\n                break\n                \n            _, idx = heapq.heappop(heap)\n            unit = units_info[idx]\n            if unit['u_i_0'] == 0:\n                max_inc = min(unit['p_max_i'], unit['p_start_i']) - p[idx]\n            else:\n                max_inc = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - p[idx]\n            \n            inc = min(deficit, max_inc, step)\n            p[idx] += inc\n            total_output += inc\n            deficit -= inc\n            step = max(0.1, step * 0.99)\n        else:\n            heap = []\n            for i in committed:\n                unit = units_info[i]\n                current_p = p[i]\n                if unit['u_i_0'] == 1:\n                    min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    min_p = unit['p_min_i']\n                \n                if current_p > min_p + 1e-8:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                    heapq.heappush(heap, (-marginal_cost, i))\n            \n            if not heap:\n                break\n                \n            _, idx = heapq.heappop(heap)\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                min_dec = p[idx] - max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                min_dec = p[idx] - unit['p_min_i']\n            \n            dec = min(-deficit, min_dec, step)\n            p[idx] -= dec\n            total_output -= dec\n            deficit += dec\n            step = max(0.1, step * 0.99)\n    \n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0.0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00557,
          "gap_price_rate": 0.00921,
          "fitness": 0.00739
     },
     {
          "name": "refined_avg_min_cost_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Set must-run units to on state with minimum feasible output considering ramp constraints\n3. Set must-off units to off state with zero output\n4. Sort flexible units by average cost at minimum output (including startup cost for offline units)\n5. Commit flexible units in cost order until total maximum capacity meets or exceeds load\n6. Perform economic dispatch using adaptive priority-based incremental adjustment:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from units with smallest marginal costs using adaptive step sizes\n   d. Decrease generation from units with largest marginal costs if surplus occurs\n7. Ensure exact load matching through fine-tuning adjustments\n8. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef refined_avg_min_cost_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_down = unit['p_down_i']\n        p_i_0 = unit['p_i_0']\n        p[i] = max(p_min, p_i_0 - p_down)\n        u[i] = 1\n        \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    def avg_cost(i):\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        p_min = unit['p_min_i']\n        if units_info[i]['u_i_0'] == 0:\n            return (s + a + b * p_min + c * p_min ** 2) / p_min\n        else:\n            return (a + b * p_min + c * p_min ** 2) / p_min\n            \n    flexible.sort(key=avg_cost)\n    \n    committed = set(must_run)\n    total_max_cap = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_i_0 = unit['p_i_0']\n        total_max_cap += min(p_max, p_i_0 + p_up)\n        \n    for i in flexible:\n        if total_max_cap >= load:\n            break\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_max = unit['p_max_i']\n        if u_i_0 == 1:\n            p_up = unit['p_up_i']\n            p_i_0 = unit['p_i_0']\n            max_cap = min(p_max, p_i_0 + p_up)\n        else:\n            p_start = unit['p_start_i']\n            max_cap = min(p_max, p_start)\n        total_max_cap += max_cap\n        committed.add(i)\n        u[i] = 1\n        \n    for i in committed:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_min = unit['p_min_i']\n        if u_i_0 == 1:\n            p_down = unit['p_down_i']\n            p_i_0 = unit['p_i_0']\n            p[i] = max(p_min, p_i_0 - p_down)\n        else:\n            p[i] = p_min\n            \n    total_p = sum(p)\n    deficit = load - total_p\n    \n    max_feasible = np.zeros(n_units)\n    min_feasible = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_max = unit['p_max_i']\n        p_min = unit['p_min_i']\n        if u_i_0 == 1:\n            p_up = unit['p_up_i']\n            p_i_0 = unit['p_i_0']\n            max_feasible[i] = min(p_max, p_i_0 + p_up)\n            p_down = unit['p_down_i']\n            min_feasible[i] = max(p_min, p_i_0 - p_down)\n        else:\n            p_start = unit['p_start_i']\n            max_feasible[i] = min(p_max, p_start)\n            min_feasible[i] = p_min\n            \n    tol = 1e-6\n    while abs(deficit) > tol:\n        if deficit > 0:\n            best_unit = None\n            best_marginal = float('inf')\n            for i in committed:\n                if p[i] < max_feasible[i] - tol:\n                    unit = units_info[i]\n                    marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n            if best_unit is None:\n                break\n            increase = min(deficit, max_feasible[best_unit] - p[best_unit])\n            p[best_unit] += increase\n            deficit -= increase\n        else:\n            best_unit = None\n            best_marginal = -float('inf')\n            for i in committed:\n                if p[i] > min_feasible[i] + tol:\n                    unit = units_info[i]\n                    marginal = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    if marginal > best_marginal:\n                        best_marginal = marginal\n                        best_unit = i\n            if best_unit is None:\n                break\n            decrease = min(-deficit, p[best_unit] - min_feasible[best_unit])\n            p[best_unit] -= decrease\n            deficit += decrease\n            \n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0\n            \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00618,
          "gap_price_rate": 0.01024,
          "fitness": 0.00821
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-on, must-off, and free based on minimum up/down times and shutdown ramp constraints.\n2. Set must-off units to off state and zero output.\n3. Calculate total minimum and maximum output from must-on units.\n4. Commit free units in ascending order of average cost at maximum output (including startup cost if applicable) until the total maximum output meets or exceeds the load.\n5. Perform economic dispatch using a priority queue to adjust outputs incrementally based on marginal cost, respecting ramp constraints and output limits.\n6. Set uncommitted free units to off state and zero output.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_on = []\n    must_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if t_i0 > -t_off_min_i:\n                must_off.append(i)\n            else:\n                free_units.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    committed = must_on.copy()\n    total_min = 0.0\n    total_max = 0.0\n    low_bounds_must_on = []\n    high_bounds_must_on = []\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds_must_on.append(low_i)\n        high_bounds_must_on.append(high_i)\n        total_min += low_i\n        total_max += high_i\n        u[i] = 1\n    \n    free_units_sorted = []\n    for i in free_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2)) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2) + unit['s_i']) / unit['p_max_i']\n        free_units_sorted.append((avg_cost, i))\n    \n    free_units_sorted.sort(key=lambda x: x[0])\n    committed_free = []\n    \n    for avg_cost, i in free_units_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += high_i\n        committed_free.append(i)\n        u[i] = 1\n        committed.append(i)\n    \n    for i in free_units:\n        if i not in committed_free:\n            u[i] = 0\n            p[i] = 0\n    \n    low_bounds = []\n    high_bounds = []\n    indices = committed\n    for i in indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds.append(low_i)\n        high_bounds.append(high_i)\n    \n    current_outputs = low_bounds.copy()\n    total_output = sum(current_outputs)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        heap = []\n        for idx, i in enumerate(indices):\n            if current_outputs[idx] < high_bounds[idx]:\n                unit = units_info[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                heapq.heappush(heap, (marginal_cost, idx, i))\n        \n        while deficit > 0 and heap:\n            marginal_cost, idx, i = heapq.heappop(heap)\n            available = high_bounds[idx] - current_outputs[idx]\n            if available > 0:\n                increase = min(deficit, available)\n                current_outputs[idx] += increase\n                deficit -= increase\n                if current_outputs[idx] < high_bounds[idx]:\n                    unit = units_info[i]\n                    new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                    heapq.heappush(heap, (new_marginal_cost, idx, i))\n    \n    for idx, i in enumerate(indices):\n        p[i] = current_outputs[idx]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "refined_avg_cost_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Set must-run units to on state with minimum feasible output considering ramp constraints\n3. Set must-off units to off state with zero output\n4. Sort flexible units by average cost at minimum output (including startup cost for offline units)\n5. Commit flexible units in cost order until total maximum capacity meets or exceeds load\n6. Perform economic dispatch using adaptive priority-based incremental adjustment:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from units with smallest marginal costs using 1 MW steps\n   d. Decrease generation from units with largest marginal costs if surplus occurs\n7. Ensure exact load matching through fine-tuning adjustments\n8. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef refined_avg_cost_commitment(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    \n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    u_0 = [unit['u_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i in range(n):\n        if u_0[i] == 1:\n            if t_0[i] < t_on_min[i] or p_0[i] > p_shut[i]:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_0[i] > -t_off_min[i]:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n        if u_0[i] == 1:\n            p[i] = max(p_min[i], p_0[i] - p_down[i])\n        else:\n            p[i] = p_min[i]\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    avg_costs = []\n    for i in flexible:\n        if u_0[i] == 0:\n            cost = (s[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i]\n        else:\n            cost = (b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i]\n        avg_costs.append((cost, i))\n    \n    avg_costs.sort(key=lambda x: x[0])\n    \n    total_max_cap = sum(p_max[i] for i in must_run)\n    flexible_committed = []\n    \n    for cost, i in avg_costs:\n        if total_max_cap >= load:\n            break\n        u[i] = 1\n        if u_0[i] == 1:\n            p[i] = max(p_min[i], p_0[i] - p_down[i])\n            unit_max = min(p_max[i], p_0[i] + p_up[i])\n        else:\n            p[i] = p_min[i]\n            unit_max = min(p_max[i], p_start[i])\n        total_max_cap += unit_max\n        flexible_committed.append(i)\n    \n    for cost, i in avg_costs[len(flexible_committed):]:\n        u[i] = 0\n        p[i] = 0\n    \n    committed_indices = must_run + flexible_committed\n    current_min = [0] * n\n    current_max = [0] * n\n    \n    for i in committed_indices:\n        if u_0[i] == 1:\n            current_min[i] = max(p_min[i], p_0[i] - p_down[i])\n            current_max[i] = min(p_max[i], p_0[i] + p_up[i])\n        else:\n            current_min[i] = p_min[i]\n            current_max[i] = min(p_max[i], p_start[i])\n    \n    total_output = sum(p)\n    \n    while abs(total_output - load) > 1e-5:\n        deficit = load - total_output\n        if deficit > 0:\n            best_idx = None\n            best_marginal = float('inf')\n            for i in committed_indices:\n                if p[i] < current_max[i]:\n                    marginal = b[i] + 2*c[i]*p[i]\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_idx = i\n            if best_idx is None:\n                break\n            amount = min(1, deficit, current_max[best_idx] - p[best_idx])\n            p[best_idx] += amount\n            total_output += amount\n        else:\n            best_idx = None\n            best_marginal = -float('inf')\n            for i in committed_indices:\n                if p[i] > current_min[i]:\n                    marginal = b[i] + 2*c[i]*p[i]\n                    if marginal > best_marginal:\n                        best_marginal = marginal\n                        best_idx = i\n            if best_idx is None:\n                break\n            amount = min(1, -deficit, p[best_idx] - current_min[best_idx])\n            p[best_idx] -= amount\n            total_output -= amount\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00997,
          "gap_price_rate": 0.00919,
          "fitness": 0.00958
     },
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units at their minimum feasible output considering ramp constraints\n3. Sort flexible units by average cost at maximum output including prorated startup cost for offline units\n4. Commit flexible units in cost order until total available capacity meets load, respecting startup ramp limits\n5. Perform economic dispatch using priority-based incremental adjustment:\n   a. Initialize all committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from cheapest units using marginal cost priority queue with adaptive step sizes\n   d. Decrease generation from most expensive units if needed\n6. Ensure exact load matching through final fine-tuning adjustments\n7. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i_0 > -t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    committed = set()\n    total_min_capacity = 0\n    total_max_capacity = 0\n    \n    for i in must_run:\n        unit = units_info[i]\n        u[i] = 1\n        p_min_feasible = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p[i] = p_min_feasible\n        total_min_capacity += p_min_feasible\n        p_max_feasible = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max_capacity += p_max_feasible\n        committed.add(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    def avg_cost(i, unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n        else:\n            return (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n    \n    flexible_sorted = sorted(flexible, key=lambda i: avg_cost(i, units_info[i]))\n    \n    for i in flexible_sorted:\n        if total_max_capacity >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            p_max_feasible = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_max_feasible = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max_capacity += p_max_feasible\n        u[i] = 1\n        committed.add(i)\n    \n    deficit = load - total_min_capacity\n    heap = []\n    \n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min_feasible = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible = unit['p_min_i']\n            p_max_feasible = min(unit['p_max_i'], unit['p_start_i'])\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_feasible\n        heapq.heappush(heap, (marginal_cost, i, p_min_feasible, p_max_feasible))\n        p[i] = p_min_feasible\n    \n    while deficit > 1e-6 and heap:\n        marginal_cost, i, p_current, p_max = heapq.heappop(heap)\n        unit = units_info[i]\n        increase = min(deficit, p_max - p_current)\n        new_p = p_current + increase\n        p[i] = new_p\n        deficit -= increase\n        if new_p < p_max:\n            new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * new_p\n            heapq.heappush(heap, (new_marginal_cost, i, new_p, p_max))\n    \n    if deficit < -1e-6:\n        heap = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_min_feasible = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_min_feasible = unit['p_min_i']\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            heapq.heappush(heap, (-marginal_cost, i, p[i], p_min_feasible))\n        \n        surplus = -deficit\n        while surplus > 1e-6 and heap:\n            neg_marginal_cost, i, p_current, p_min = heapq.heappop(heap)\n            decrease = min(surplus, p_current - p_min)\n            new_p = p_current - decrease\n            p[i] = new_p\n            surplus -= decrease\n            if new_p > p_min:\n                new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * new_p\n                heapq.heappush(heap, (-new_marginal_cost, i, new_p, p_min))\n    \n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00805,
          "gap_price_rate": 0.01208,
          "fitness": 0.01007
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints.\n2. Commit must-run units and set must-off units to off.\n3. Sort flexible units by average cost at minimum output (including startup cost).\n4. Turn on flexible units in sorted order until total maximum capacity meets load.\n5. Perform economic dispatch on committed units:\n   - Set initial output to minimum feasible values\n   - Increase output based on marginal cost while respecting ramp constraints\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    P_min_must = 0\n    P_max_must = 0\n    for i in must_on:\n        unit = units_info[i]\n        low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min_must += low_bound\n        P_max_must += up_bound\n    \n    remaining_load = load - P_min_must\n    if remaining_load < 0:\n        remaining_load = 0\n    \n    flexible_sorted = sorted(flexible, \n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                      units_info[i]['c_i']*units_info[i]['p_min_i']**2) / units_info[i]['p_min_i'])\n    \n    turned_on_flexible = []\n    total_max = P_max_must\n    for i in flexible_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max += max_p\n        u[i] = 1\n        turned_on_flexible.append(i)\n    \n    committed = must_on + turned_on_flexible\n    ranges = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1 and u[i] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif unit['u_i_0'] == 0 and u[i] == 1:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            low = unit['p_min_i']\n            high = unit['p_max_i']\n        ranges.append((low, high))\n    \n    total_output = 0\n    for idx, i in enumerate(committed):\n        p[i] = ranges[idx][0]\n        total_output += p[i]\n    \n    remaining_load = load - total_output\n    if remaining_load < 0:\n        remaining_load = 0\n    \n    while remaining_load > 0:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, i in enumerate(committed):\n            if p[i] < ranges[idx][1]:\n                marginal = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = (idx, i)\n        \n        if best_idx is None:\n            break\n            \n        idx, i = best_idx\n        increase = min(remaining_load, ranges[idx][1] - p[i])\n        p[i] += increase\n        remaining_load -= increase\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00647,
          "gap_price_rate": 0.01603,
          "fitness": 0.01125
     },
     {
          "name": "enhanced_marginal_cost_commitment_v2",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units at their minimum feasible output considering ramp constraints\n3. Sort flexible units by marginal cost at minimum output including prorated startup cost for offline units\n4. Commit flexible units in cost order until total available capacity meets load, respecting startup ramp limits\n5. Perform economic dispatch using adaptive priority-based incremental adjustment:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from cheapest units using marginal cost priority with adaptive step sizes\n   d. Decrease generation from most expensive units if surplus occurs\n6. Ensure exact load matching through fine-tuning adjustments\n7. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef enhanced_marginal_cost_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        s_i = unit['s_i']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1 and (t_i_0 < t_on_min_i or p_i_0 > p_shut_i):\n            must_run.append(i)\n        elif u_i_0 == 0 and abs(t_i_0) < t_off_min_i:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    committed = set(must_run)\n    \n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i_0 == 1:\n            min_feasible = max(p_min_i, p_i_0 - p_down_i)\n        else:\n            min_feasible = p_min_i\n        \n        u[i] = 1\n        p[i] = min_feasible\n        total_min += min_feasible\n        total_max += min(p_max_i, p_i_0 + p_up_i) if u_i_0 == 1 else p_start_i\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    cost_metrics = []\n    for i in flexible:\n        unit = units_info[i]\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        s_i = unit['s_i']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        u_i_0 = unit['u_i_0']\n        \n        if u_i_0 == 0:\n            metric = (b_i + 2*c_i*p_min_i) + s_i/p_min_i\n        else:\n            metric = b_i + 2*c_i*p_min_i\n        cost_metrics.append((metric, i))\n    \n    cost_metrics.sort(key=lambda x: x[0])\n    \n    for metric, i in cost_metrics:\n        if total_max >= load:\n            break\n        \n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_max_i = unit['p_max_i']\n        p_start_i = unit['p_start_i']\n        \n        max_output = p_start_i if u_i_0 == 0 else p_max_i\n        total_max += max_output\n        committed.add(i)\n        u[i] = 1\n    \n    for i in flexible:\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0\n    \n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    \n    for i in committed:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i_0 == 1:\n            min_feasible[i] = max(p_min_i, p_i_0 - p_down_i)\n            max_feasible[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_feasible[i] = p_min_i\n            max_feasible[i] = min(p_max_i, p_start_i)\n        \n        p[i] = min_feasible[i]\n    \n    total_power = sum(p[i] for i in committed)\n    tolerance = 1e-3\n    \n    while abs(total_power - load) > tolerance:\n        if total_power < load:\n            best_i = None\n            best_marginal = float('inf')\n            for i in committed:\n                if p[i] < max_feasible[i]:\n                    unit = units_info[i]\n                    marginal = unit['b_i'] + 2*unit['c_i']*p[i]\n                    if marginal < best_marginal:\n                        best_marginal = marginal\n                        best_i = i\n            \n            if best_i is None:\n                break\n            \n            step = min(max_feasible[best_i] - p[best_i], load - total_power)\n            p[best_i] += step\n            total_power += step\n        \n        else:\n            best_i = None\n            best_marginal = -float('inf')\n            for i in committed:\n                if p[i] > min_feasible[i]:\n                    unit = units_info[i]\n                    marginal = unit['b_i'] + 2*unit['c_i']*p[i]\n                    if marginal > best_marginal:\n                        best_marginal = marginal\n                        best_i = i\n            \n            if best_i is None:\n                break\n            \n            step = min(p[best_i] - min_feasible[best_i], total_power - load)\n            p[best_i] -= step\n            total_power -= step\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00687,
          "gap_price_rate": 0.01582,
          "fitness": 0.01134
     },
     {
          "name": "refined_marginal_cost_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Set must-run units to on state with minimum feasible output considering ramp constraints\n3. Set must-off units to off state with zero output\n4. Sort flexible units by average cost at minimum output (including startup cost for offline units)\n5. Commit flexible units in cost order until total maximum capacity meets or exceeds load\n6. Perform economic dispatch using priority-based incremental adjustment with adaptive step sizes:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from units with smallest marginal costs\n   d. Decrease generation from units with largest marginal costs if surplus occurs\n7. Ensure exact load matching through fine-tuning adjustments\n8. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef refined_marginal_cost_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            min_feasible[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_feasible[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            if -t0 < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            min_feasible[i] = unit['p_min_i']\n            max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in must_run:\n        u[i] = 1\n        p[i] = min_feasible[i]\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        min_feasible[i] = 0\n        max_feasible[i] = 0\n    \n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['a_i'] + unit['s_i'] + unit['b_i'] * min_feasible[i] + unit['c_i'] * min_feasible[i] ** 2) / min_feasible[i]\n        else:\n            cost = (unit['a_i'] + unit['b_i'] * min_feasible[i] + unit['c_i'] * min_feasible[i] ** 2) / min_feasible[i]\n        costs.append((i, cost))\n    \n    costs.sort(key=lambda x: x[1])\n    \n    total_cap = sum(max_feasible)\n    committed_flexible = []\n    for i, _ in costs:\n        if total_cap >= load:\n            break\n        u[i] = 1\n        p[i] = min_feasible[i]\n        committed_flexible.append(i)\n        total_cap += max_feasible[i]\n    \n    for i in flexible:\n        if i not in committed_flexible:\n            u[i] = 0\n            p[i] = 0\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n    \n    committed = must_run + committed_flexible\n    total_p = sum(p)\n    deficit = load - total_p\n    tol = 1e-5\n    \n    while abs(deficit) > tol:\n        if deficit > 0:\n            best_idx = None\n            best_mc = float('inf')\n            for i in committed:\n                if p[i] < max_feasible[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc < best_mc:\n                        best_mc = mc\n                        best_idx = i\n            if best_idx is None:\n                break\n            step = min(max_feasible[best_idx] - p[best_idx], deficit, units_info[best_idx]['p_up_i'])\n            p[best_idx] += step\n            deficit -= step\n        else:\n            best_idx = None\n            best_mc = -float('inf')\n            for i in committed:\n                if p[i] > min_feasible[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    if mc > best_mc:\n                        best_mc = mc\n                        best_idx = i\n            if best_idx is None:\n                break\n            step = min(p[best_idx] - min_feasible[best_idx], -deficit, units_info[best_idx]['p_down_i'])\n            p[best_idx] -= step\n            deficit += step\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.03236,
          "gap_price_rate": 0.0263,
          "fitness": 0.02933
     },
     {
          "name": "enhanced_hybrid_avg_marginal_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Set must-run units to on state with minimum feasible output considering ramp constraints\n3. Set must-off units to off state with zero output\n4. Sort flexible units by hybrid cost metric combining average cost at minimum output and marginal cost at maximum output\n5. Commit flexible units in cost order until total maximum capacity meets or exceeds load\n6. Perform economic dispatch using adaptive priority-based incremental adjustment:\n   a. Initialize committed units to minimum feasible outputs\n   b. Calculate power deficit relative to load\n   c. Increase generation from units with smallest marginal costs using dynamic step sizes\n   d. Decrease generation from units with largest marginal costs if surplus occurs\n7. Ensure exact load matching through fine-tuning adjustments\n8. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_avg_marginal_commitment(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    n_units = len(units)\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if t_i0 > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    schedules = np.zeros((2, n_units))\n    committed = set()\n    \n    for i in must_run:\n        unit = units[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['u_i'] = 1\n        unit['p_i'] = p_min\n        committed.add(i)\n    \n    for i in must_off:\n        unit = units[i]\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    def calc_hybrid_cost(unit):\n        if unit['u_i_0'] == 1:\n            avg_cost = (unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n        else:\n            avg_cost = (unit['s_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n        marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n        return 0.7 * avg_cost + 0.3 * marg_cost\n    \n    flexible.sort(key=lambda i: calc_hybrid_cost(units[i]))\n    \n    total_max = sum(units[i]['p_max_i'] for i in committed)\n    for i in flexible:\n        if total_max >= load:\n            break\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        unit['u_i'] = 1\n        unit['p_i'] = p_min\n        committed.add(i)\n        total_max += unit['p_max_i']\n    \n    current_total = sum(units[i]['p_i'] for i in committed)\n    deficit = load - current_total\n    \n    while abs(deficit) > 1e-6:\n        if deficit > 0:\n            candidates = []\n            for i in committed:\n                unit = units[i]\n                if unit['u_i_0'] == 1:\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if unit['p_i'] < p_max:\n                    marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((marg_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0])\n            best_i = candidates[0][1]\n            unit = units[best_i]\n            if unit['u_i_0'] == 1:\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n            step = min(deficit, p_max - unit['p_i'])\n            unit['p_i'] += step\n            current_total += step\n            deficit -= step\n        else:\n            candidates = []\n            for i in committed:\n                unit = units[i]\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_min = unit['p_min_i']\n                if unit['p_i'] > p_min:\n                    marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    candidates.append((marg_cost, i))\n            if not candidates:\n                break\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            best_i = candidates[0][1]\n            unit = units[best_i]\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_min = unit['p_min_i']\n            step = min(-deficit, unit['p_i'] - p_min)\n            unit['p_i'] -= step\n            current_total -= step\n            deficit += step\n    \n    for i in range(n_units):\n        schedules[0, i] = units[i]['u_i']\n        schedules[1, i] = units[i]['p_i']\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.03158,
          "gap_price_rate": 0.02817,
          "fitness": 0.02987
     }
]