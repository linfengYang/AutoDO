[
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-on, must-off, and free based on minimum up/down times and shutdown ramp constraints.\n2. Set must-off units to off state and zero output.\n3. Calculate total minimum and maximum output from must-on units.\n4. Commit free units in ascending order of average cost at maximum output (including startup cost if applicable) until the total maximum output meets or exceeds the load.\n5. Perform economic dispatch using a priority queue to adjust outputs incrementally based on marginal cost, respecting ramp constraints and output limits.\n6. Set uncommitted free units to off state and zero output.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_on = []\n    must_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if t_i0 > -t_off_min_i:\n                must_off.append(i)\n            else:\n                free_units.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    committed = must_on.copy()\n    total_min = 0.0\n    total_max = 0.0\n    low_bounds_must_on = []\n    high_bounds_must_on = []\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds_must_on.append(low_i)\n        high_bounds_must_on.append(high_i)\n        total_min += low_i\n        total_max += high_i\n        u[i] = 1\n    \n    free_units_sorted = []\n    for i in free_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2)) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2) + unit['s_i']) / unit['p_max_i']\n        free_units_sorted.append((avg_cost, i))\n    \n    free_units_sorted.sort(key=lambda x: x[0])\n    committed_free = []\n    \n    for avg_cost, i in free_units_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += high_i\n        committed_free.append(i)\n        u[i] = 1\n        committed.append(i)\n    \n    for i in free_units:\n        if i not in committed_free:\n            u[i] = 0\n            p[i] = 0\n    \n    low_bounds = []\n    high_bounds = []\n    indices = committed\n    for i in indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds.append(low_i)\n        high_bounds.append(high_i)\n    \n    current_outputs = low_bounds.copy()\n    total_output = sum(current_outputs)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        heap = []\n        for idx, i in enumerate(indices):\n            if current_outputs[idx] < high_bounds[idx]:\n                unit = units_info[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                heapq.heappush(heap, (marginal_cost, idx, i))\n        \n        while deficit > 0 and heap:\n            marginal_cost, idx, i = heapq.heappop(heap)\n            available = high_bounds[idx] - current_outputs[idx]\n            if available > 0:\n                increase = min(deficit, available)\n                current_outputs[idx] += increase\n                deficit -= increase\n                if current_outputs[idx] < high_bounds[idx]:\n                    unit = units_info[i]\n                    new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                    heapq.heappush(heap, (new_marginal_cost, idx, i))\n    \n    for idx, i in enumerate(indices):\n        p[i] = current_outputs[idx]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints.\n2. Commit must-run units and set must-off units to off.\n3. Sort flexible units by average cost at minimum output (including startup cost).\n4. Turn on flexible units in sorted order until total maximum capacity meets load.\n5. Perform economic dispatch on committed units:\n   - Set initial output to minimum feasible values\n   - Increase output based on marginal cost while respecting ramp constraints\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    P_min_must = 0\n    P_max_must = 0\n    for i in must_on:\n        unit = units_info[i]\n        low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min_must += low_bound\n        P_max_must += up_bound\n    \n    remaining_load = load - P_min_must\n    if remaining_load < 0:\n        remaining_load = 0\n    \n    flexible_sorted = sorted(flexible, \n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                      units_info[i]['c_i']*units_info[i]['p_min_i']**2) / units_info[i]['p_min_i'])\n    \n    turned_on_flexible = []\n    total_max = P_max_must\n    for i in flexible_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max += max_p\n        u[i] = 1\n        turned_on_flexible.append(i)\n    \n    committed = must_on + turned_on_flexible\n    ranges = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1 and u[i] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif unit['u_i_0'] == 0 and u[i] == 1:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            low = unit['p_min_i']\n            high = unit['p_max_i']\n        ranges.append((low, high))\n    \n    total_output = 0\n    for idx, i in enumerate(committed):\n        p[i] = ranges[idx][0]\n        total_output += p[i]\n    \n    remaining_load = load - total_output\n    if remaining_load < 0:\n        remaining_load = 0\n    \n    while remaining_load > 0:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, i in enumerate(committed):\n            if p[i] < ranges[idx][1]:\n                marginal = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = (idx, i)\n        \n        if best_idx is None:\n            break\n            \n        idx, i = best_idx\n        increase = min(remaining_load, ranges[idx][1] - p[i])\n        p[i] += increase\n        remaining_load -= increase\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00647,
          "gap_price_rate": 0.01603,
          "fitness": 0.01125
     },
     {
          "name": "commit_units_rolling",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state and minimum up/down times.\n2. Dispatch must-run units first within ramp constraints and output limits.\n3. Sort flexible on units by marginal cost and dispatch remaining load.\n4. Sort flexible off units by marginal cost, turn on if feasible, and dispatch within startup ramp limits.\n5. Adjust outputs to balance load exactly by increasing generation from cheapest units or decreasing from most expensive units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_gen = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p[i] = p_min\n            total_gen += p[i]\n    \n    remaining_load = load - total_gen\n    \n    flexible_on = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i] and unit['u_i_0'] == 1:\n            flexible_on.append(i)\n    \n    flexible_on.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_max_i'])\n    \n    for i in flexible_on:\n        if remaining_load <= 0:\n            break\n        u[i] = 1\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        alloc = min(remaining_load, p_max - p_min)\n        p[i] = p_min + alloc\n        remaining_load -= alloc\n    \n    flexible_off = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i] and unit['u_i_0'] == 0:\n            flexible_off.append(i)\n    \n    flexible_off.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_max_i'])\n    \n    for i in flexible_off:\n        if remaining_load <= 0:\n            break\n        unit = units_info[i]\n        p_max = min(unit['p_start_i'], unit['p_up_i'], unit['p_max_i'])\n        if p_max < unit['p_min_i']:\n            continue\n        u[i] = 1\n        alloc = min(remaining_load, p_max)\n        if alloc < unit['p_min_i']:\n            alloc = unit['p_min_i']\n        p[i] = alloc\n        remaining_load -= alloc\n    \n    on_units = [i for i in range(n_units) if u[i] == 1]\n    on_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n    \n    for i in on_units:\n        if remaining_load <= 0:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_max = min(unit['p_start_i'], unit['p_up_i'], unit['p_max_i'])\n        additional = min(remaining_load, p_max - p[i])\n        p[i] += additional\n        remaining_load -= additional\n    \n    on_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n    \n    for i in on_units:\n        if remaining_load >= 0:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        reduction = min(-remaining_load, p[i] - p_min)\n        p[i] -= reduction\n        remaining_load += reduction\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.19293,
          "gap_price_rate": 0.18348,
          "fitness": 0.18821
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Sort flexible units by average cost per unit power at maximum output\n3. Commit flexible units in cost order until total available capacity meets load\n4. Perform economic dispatch considering ramp constraints and cost minimization\n5. Adjust commitment and dispatch if load cannot be met exactly\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n        p[i] = max(units_info[i]['p_min_i'], \n                  units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    def avg_cost(i):\n        unit = units_info[i]\n        return (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n    \n    flexible.sort(key=avg_cost)\n    \n    total_min = sum(p)\n    total_max = sum(p)\n    for i in must_run:\n        total_max += min(units_info[i]['p_max_i'], \n                       units_info[i]['p_i_0'] + units_info[i]['p_up_i']) - p[i]\n    \n    committed_flexible = []\n    for i in flexible:\n        if total_max < load:\n            u[i] = 1\n            committed_flexible.append(i)\n            if units_info[i]['u_i_0'] == 0:\n                p_i_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            else:\n                p_i_max = min(units_info[i]['p_max_i'], \n                             units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            total_max += p_i_max\n        else:\n            u[i] = 0\n            p[i] = 0\n    \n    committed = must_run + committed_flexible\n    remaining_load = load - sum(p)\n    \n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            lb[i] = max(units_info[i]['p_min_i'], \n                       units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            ub[i] = min(units_info[i]['p_max_i'], \n                       units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lb[i] = units_info[i]['p_min_i']\n            ub[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        p[i] = lb[i]\n    \n    remaining_load -= sum(p)\n    \n    while remaining_load > 1e-6:\n        best_i = None\n        best_cost = float('inf')\n        for i in committed:\n            if p[i] < ub[i]:\n                marginal_cost = (units_info[i]['b_i'] + \n                                2 * units_info[i]['c_i'] * p[i])\n                if marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_i = i\n        if best_i is None:\n            break\n        \n        max_inc = ub[best_i] - p[best_i]\n        inc = min(remaining_load, max_inc)\n        p[best_i] += inc\n        remaining_load -= inc\n    \n    while remaining_load < -1e-6:\n        worst_i = None\n        worst_cost = -float('inf')\n        for i in committed:\n            if p[i] > lb[i]:\n                marginal_cost = (units_info[i]['b_i'] + \n                                2 * units_info[i]['c_i'] * p[i])\n                if marginal_cost > worst_cost:\n                    worst_cost = marginal_cost\n                    worst_i = i\n        if worst_i is None:\n            break\n        \n        max_dec = p[worst_i] - lb[worst_i]\n        dec = min(-remaining_load, max_dec)\n        p[worst_i] -= dec\n        remaining_load += dec\n    \n    schedules = np.vstack([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.3607,
          "gap_price_rate": 0.25024,
          "fitness": 0.30547
     }
]