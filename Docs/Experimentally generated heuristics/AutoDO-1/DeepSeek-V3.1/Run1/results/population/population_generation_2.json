[
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Classify units into must-on, must-off, and free based on minimum up/down times and shutdown ramp constraints.\n2. Set must-off units to off state and zero output.\n3. Calculate total minimum and maximum output from must-on units.\n4. Commit free units in ascending order of average cost at maximum output (including startup cost if applicable) until the total maximum output meets or exceeds the load.\n5. Perform economic dispatch using a priority queue to adjust outputs incrementally based on marginal cost, respecting ramp constraints and output limits.\n6. Set uncommitted free units to off state and zero output.\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_on = []\n    must_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if t_i0 > -t_off_min_i:\n                must_off.append(i)\n            else:\n                free_units.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    committed = must_on.copy()\n    total_min = 0.0\n    total_max = 0.0\n    low_bounds_must_on = []\n    high_bounds_must_on = []\n    \n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds_must_on.append(low_i)\n        high_bounds_must_on.append(high_i)\n        total_min += low_i\n        total_max += high_i\n        u[i] = 1\n    \n    free_units_sorted = []\n    for i in free_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2)) / unit['p_max_i']\n        else:\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * (unit['p_max_i'] ** 2) + unit['s_i']) / unit['p_max_i']\n        free_units_sorted.append((avg_cost, i))\n    \n    free_units_sorted.sort(key=lambda x: x[0])\n    committed_free = []\n    \n    for avg_cost, i in free_units_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        total_max += high_i\n        committed_free.append(i)\n        u[i] = 1\n        committed.append(i)\n    \n    for i in free_units:\n        if i not in committed_free:\n            u[i] = 0\n            p[i] = 0\n    \n    low_bounds = []\n    high_bounds = []\n    indices = committed\n    for i in indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_i = unit['p_min_i']\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n        low_bounds.append(low_i)\n        high_bounds.append(high_i)\n    \n    current_outputs = low_bounds.copy()\n    total_output = sum(current_outputs)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        heap = []\n        for idx, i in enumerate(indices):\n            if current_outputs[idx] < high_bounds[idx]:\n                unit = units_info[i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                heapq.heappush(heap, (marginal_cost, idx, i))\n        \n        while deficit > 0 and heap:\n            marginal_cost, idx, i = heapq.heappop(heap)\n            available = high_bounds[idx] - current_outputs[idx]\n            if available > 0:\n                increase = min(deficit, available)\n                current_outputs[idx] += increase\n                deficit -= increase\n                if current_outputs[idx] < high_bounds[idx]:\n                    unit = units_info[i]\n                    new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[idx]\n                    heapq.heappush(heap, (new_marginal_cost, idx, i))\n    \n    for idx, i in enumerate(indices):\n        p[i] = current_outputs[idx]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00668,
          "gap_price_rate": 0.0112,
          "fitness": 0.00894
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints.\n2. Commit must-run units and set must-off units to off.\n3. Sort flexible units by average cost at minimum output (including startup cost).\n4. Turn on flexible units in sorted order until total maximum capacity meets load.\n5. Perform economic dispatch on committed units:\n   - Set initial output to minimum feasible values\n   - Increase output based on marginal cost while respecting ramp constraints\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    P_min_must = 0\n    P_max_must = 0\n    for i in must_on:\n        unit = units_info[i]\n        low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min_must += low_bound\n        P_max_must += up_bound\n    \n    remaining_load = load - P_min_must\n    if remaining_load < 0:\n        remaining_load = 0\n    \n    flexible_sorted = sorted(flexible, \n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                      units_info[i]['c_i']*units_info[i]['p_min_i']**2) / units_info[i]['p_min_i'])\n    \n    turned_on_flexible = []\n    total_max = P_max_must\n    for i in flexible_sorted:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_max += max_p\n        u[i] = 1\n        turned_on_flexible.append(i)\n    \n    committed = must_on + turned_on_flexible\n    ranges = []\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1 and u[i] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif unit['u_i_0'] == 0 and u[i] == 1:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            low = unit['p_min_i']\n            high = unit['p_max_i']\n        ranges.append((low, high))\n    \n    total_output = 0\n    for idx, i in enumerate(committed):\n        p[i] = ranges[idx][0]\n        total_output += p[i]\n    \n    remaining_load = load - total_output\n    if remaining_load < 0:\n        remaining_load = 0\n    \n    while remaining_load > 0:\n        best_idx = None\n        best_marginal = float('inf')\n        for idx, i in enumerate(committed):\n            if p[i] < ranges[idx][1]:\n                marginal = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = (idx, i)\n        \n        if best_idx is None:\n            break\n            \n        idx, i = best_idx\n        increase = min(remaining_load, ranges[idx][1] - p[i])\n        p[i] += increase\n        remaining_load -= increase\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00647,
          "gap_price_rate": 0.01603,
          "fitness": 0.01125
     },
     {
          "name": "enhanced_marginal_cost_commitment",
          "algorithm": "1. Classify units into must-on, must-off, and free categories based on minimum up/down times and shutdown ramp constraints, with enhanced feasibility checks considering current state and ramp limits.\n2. Set must-off units to off state with zero output.\n3. Calculate total available capacity from must-on units considering current ramp constraints and output limits.\n4. Commit free units in ascending order of marginal cost at minimum output (including prorated startup cost if applicable) until total available capacity meets or exceeds load.\n5. Perform economic dispatch using an iterative marginal cost balancing approach with constraint-aware adjustments:\n   a. Initialize all committed units to their feasible minimum outputs\n   b. Calculate power deficit/surplus relative to load\n   c. Adjust outputs incrementally based on marginal cost priority while respecting all ramp and output constraints\n   d. Use adaptive step sizes for faster convergence\n6. Ensure exact load matching through final fine-tuning adjustments\n7. Set uncommitted free units to off state with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_marginal_cost_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    free = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                free.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    total_must_on_capacity = 0\n    for i in must_on:\n        unit = units_info[i]\n        u[i] = 1\n        p_min = unit['p_min_i']\n        p_down = unit['p_down_i']\n        p_i0 = unit['p_i_0']\n        p[i] = max(p_min, p_i0 - p_down)\n        total_must_on_capacity += p[i]\n    \n    remaining_load = load - total_must_on_capacity\n    \n    free_units = []\n    for i in free:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        s_i = unit['s_i']\n        u_i0 = unit['u_i_0']\n        \n        marginal_cost = b_i + 2 * c_i * p_min\n        if u_i0 == 0:\n            prorated_startup = s_i / (unit['p_max_i'] - p_min) if unit['p_max_i'] > p_min else s_i\n            marginal_cost += prorated_startup\n        \n        free_units.append((marginal_cost, i))\n    \n    free_units.sort(key=lambda x: x[0])\n    \n    committed_free = []\n    total_capacity = total_must_on_capacity\n    for cost, i in free_units:\n        unit = units_info[i]\n        p_max = unit['p_max_i']\n        if unit['u_i_0'] == 0:\n            p_max = min(p_max, unit['p_start_i'])\n        else:\n            p_max = min(p_max, unit['p_i_0'] + unit['p_up_i'])\n        \n        total_capacity += p_max\n        committed_free.append(i)\n        if total_capacity >= load:\n            break\n    \n    for i in committed_free:\n        unit = units_info[i]\n        u[i] = 1\n        p_min = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            p_down = unit['p_down_i']\n            p_i0 = unit['p_i_0']\n            p[i] = max(p_min, p_i0 - p_down)\n        else:\n            p[i] = p_min\n    \n    committed = must_on + committed_free\n    current_total = sum(p[i] for i in committed)\n    deficit = load - current_total\n    \n    min_limits = []\n    max_limits = []\n    for i in committed:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        if unit['u_i_0'] == 1:\n            min_lim = max(p_min, unit['p_i_0'] - unit['p_down_i'])\n            max_lim = min(p_max, unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_lim = p_min\n            max_lim = min(p_max, unit['p_start_i'])\n        min_limits.append(min_lim)\n        max_limits.append(max_lim)\n    \n    while abs(deficit) > 1e-8:\n        if deficit > 0:\n            best_idx = None\n            best_cost = float('inf')\n            for idx, i in enumerate(committed):\n                if p[i] < max_limits[idx]:\n                    unit = units_info[i]\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    if marginal_cost < best_cost:\n                        best_cost = marginal_cost\n                        best_idx = idx\n            if best_idx is None:\n                break\n            i = committed[best_idx]\n            increase = min(deficit, max_limits[best_idx] - p[i])\n            p[i] += increase\n            deficit -= increase\n        else:\n            best_idx = None\n            best_cost = -float('inf')\n            for idx, i in enumerate(committed):\n                if p[i] > min_limits[idx]:\n                    unit = units_info[i]\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    if marginal_cost > best_cost:\n                        best_cost = marginal_cost\n                        best_idx = idx\n            if best_idx is None:\n                break\n            i = committed[best_idx]\n            decrease = min(-deficit, p[i] - min_limits[best_idx])\n            p[i] -= decrease\n            deficit += decrease\n    \n    for i in free:\n        if i not in committed_free:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.08452,
          "fitness": 0.0423
     },
     {
          "name": "enhanced_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units at their minimum feasible output considering ramp constraints\n3. Sort flexible units by marginal cost (b_i + 2*c_i*p_min_i) including prorated startup cost\n4. Commit flexible units in cost order until load is met, respecting startup ramp limits for newly activated units\n5. Perform economic dispatch using adaptive step size adjustment based on marginal cost priority:\n   a. Initialize all committed units to their feasible minimum outputs\n   b. Calculate power deficit relative to load\n   c. Increase output from cheapest units using larger step sizes for units with flatter cost curves\n   d. Fine-tune with smaller steps near load balance point\n6. Ensure exact load matching through final marginal cost-based adjustments\n7. Maintain all operational constraints throughout the process\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_commitment_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed_units = []\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize must-off units\n    for i in must_off:\n        schedules[0][i] = 0\n        schedules[1][i] = 0\n    \n    # Dispatch must-run units\n    total_output = 0\n    for i in must_run:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        schedules[0][i] = 1\n        schedules[1][i] = min_output\n        total_output += min_output\n        committed_units.append(i)\n    \n    # Calculate remaining load\n    remaining_load = load - total_output\n    \n    # Sort flexible units by marginal cost including startup cost\n    def cost_key(i):\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        avg_cost = marginal_cost + (unit['s_i'] / unit['p_max_i']) if unit['u_i_0'] == 0 else marginal_cost\n        return avg_cost\n    \n    flexible.sort(key=cost_key)\n    \n    # Commit flexible units\n    for i in flexible:\n        if remaining_load <= 0:\n            break\n            \n        unit = units_info[i]\n        max_output = min(unit['p_max_i'], \n                        unit['p_start_i'] if unit['u_i_0'] == 0 else unit['p_i_0'] + unit['p_up_i'])\n        \n        if max_output >= unit['p_min_i']:\n            schedules[0][i] = 1\n            min_output = unit['p_min_i']\n            schedules[1][i] = min_output\n            total_output += min_output\n            remaining_load -= min_output\n            committed_units.append(i)\n    \n    # Economic dispatch with adaptive step sizing\n    deficit = load - total_output\n    \n    # Create priority queue based on marginal cost\n    heap = []\n    for i in committed_units:\n        unit = units_info[i]\n        current_output = schedules[1][i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_output\n        \n        # Calculate maximum possible output\n        if unit['u_i_0'] == 1:\n            max_possible = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_possible = min(unit['p_max_i'], unit['p_start_i'])\n        \n        heapq.heappush(heap, (marginal_cost, i, current_output, max_possible))\n    \n    # Adjust outputs\n    while abs(deficit) > 1e-6 and heap:\n        marginal_cost, i, current_output, max_possible = heapq.heappop(heap)\n        unit = units_info[i]\n        \n        # Determine step size based on cost curve steepness\n        step_size = min(1.0, max(0.1, 1 / (2 * abs(unit['c_i']) + 1e-6)))\n        \n        if deficit > 0:\n            # Increase output\n            increment = min(deficit, max_possible - current_output, step_size)\n            if increment > 1e-6:\n                new_output = current_output + increment\n                schedules[1][i] = new_output\n                deficit -= increment\n                new_marginal = unit['b_i'] + 2 * unit['c_i'] * new_output\n                if new_output < max_possible:\n                    heapq.heappush(heap, (new_marginal, i, new_output, max_possible))\n        else:\n            # Decrease output\n            min_possible = max(unit['p_min_i'], \n                              unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] == 1 else unit['p_min_i'])\n            decrement = min(-deficit, current_output - min_possible, step_size)\n            if decrement > 1e-6:\n                new_output = current_output - decrement\n                schedules[1][i] = new_output\n                deficit += decrement\n                new_marginal = unit['b_i'] + 2 * unit['c_i'] * new_output\n                if new_output > min_possible:\n                    heapq.heappush(heap, (new_marginal, i, new_output, max_possible))\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.09168,
          "fitness": 0.04588
     },
     {
          "name": "enhanced_marginal_cost_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units first within their operating constraints while respecting ramp limits\n3. Sort flexible units by marginal cost (b_i + 2*c_i*p_i) at maximum output, considering startup costs for offline units\n4. Commit flexible units in cost order until total available capacity meets load, respecting startup ramp limits for newly activated units\n5. Perform economic dispatch using priority-based incremental adjustment:\n   - Start from minimum feasible outputs considering ramp constraints\n   - Increase generation from cheapest units using marginal cost priority queue\n   - Decrease generation from most expensive units if needed\n   - Respect all ramp constraints and output limits throughout\n6. Ensure exact load matching through fine-tuning adjustments\n7. Maintain all constraints including minimum up/down times and startup/shutdown ramps\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_marginal_cost_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0.0\n    \n    # Initialize must-run units\n    for i in must_run:\n        u[i] = 1\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p[i] = p_min\n    \n    # Calculate remaining load\n    current_gen = np.sum(p)\n    remaining_load = load - current_gen\n    \n    # Sort flexible units by marginal cost at max output\n    flexible_sorted = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * max_p\n        else:\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            marginal_cost = (unit['b_i'] + 2 * unit['c_i'] * max_p + \n                           unit['s_i'] / max_p if max_p > 0 else float('inf'))\n        flexible_sorted.append((marginal_cost, max_p, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    # Commit flexible units\n    for cost, max_p, i in flexible_sorted:\n        if remaining_load > 0:\n            u[i] = 1\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                p_min = unit['p_min_i']\n            p[i] = p_min\n            current_gen += p_min\n            remaining_load -= p_min\n    \n    # Economic dispatch - increase generation\n    if remaining_load > 0:\n        heap = []\n        for i in range(n_units):\n            if u[i] == 1:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if p[i] < p_max:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    heapq.heappush(heap, (marginal_cost, i, p_max))\n        \n        while remaining_load > 0 and heap:\n            cost, i, p_max = heapq.heappop(heap)\n            unit = units_info[i]\n            increase = min(remaining_load, p_max - p[i])\n            p[i] += increase\n            remaining_load -= increase\n            if p[i] < p_max:\n                new_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                heapq.heappush(heap, (new_cost, i, p_max))\n    \n    # Economic dispatch - decrease generation\n    if remaining_load < 0:\n        heap = []\n        for i in range(n_units):\n            if u[i] == 1:\n                unit = units_info[i]\n                if unit['u_i_0'] == 1:\n                    p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    p_min = unit['p_min_i']\n                if p[i] > p_min:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    heapq.heappush(heap, (-marginal_cost, i, p_min))\n        \n        while remaining_load < 0 and heap:\n            neg_cost, i, p_min = heapq.heappop(heap)\n            unit = units_info[i]\n            decrease = min(-remaining_load, p[i] - p_min)\n            p[i] -= decrease\n            remaining_load += decrease\n            if p[i] > p_min:\n                new_neg_cost = -(unit['b_i'] + 2 * unit['c_i'] * p[i])\n                heapq.heappush(heap, (new_neg_cost, i, p_min))\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.09239,
          "fitness": 0.04623
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units first within ramp constraints and output limits\n3. Sort flexible units by marginal cost (b_i + 2*c_i*p_i) at maximum output\n4. Commit flexible units in cost order until total available capacity meets load, considering startup costs and feasibility constraints\n5. Perform economic dispatch using priority-based incremental adjustment:\n   - Start from minimum feasible outputs\n   - Increase generation from cheapest units until load is met\n   - Respect all ramp constraints and output limits\n6. Fine-tune outputs to exactly match load by adjusting most economical units\n7. Ensure all constraints are satisfied including minimum up/down times and startup/shutdown ramps\n\n",
          "code": "import numpy as np\nimport heapq\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    units = units_info\n    n_units = len(units)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Dispatch must-run units\n    total_output = 0\n    for i in must_run:\n        unit = units[i]\n        u[i] = 1\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p[i] = max(p_min, min(p_max, unit['p_i_0']))\n        total_output += p[i]\n    \n    # Sort flexible units by marginal cost at max output\n    def cost_func(i):\n        unit = units[i]\n        return unit['b_i'] + 2 * unit['c_i'] * unit['p_max_i']\n    \n    flexible.sort(key=cost_func)\n    \n    # Commit flexible units until load is met\n    remaining_load = load - total_output\n    committed_flexible = []\n    \n    for i in flexible:\n        unit = units[i]\n        if remaining_load <= 0:\n            break\n            \n        # Check if unit can be committed\n        if unit['u_i_0'] == 0:\n            # Check minimum down time\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                u[i] = 1\n                p_max = min(unit['p_max_i'], unit['p_start_i'])\n                if p_max >= unit['p_min_i']:\n                    committed_flexible.append(i)\n                    total_output += p_max\n                    remaining_load -= p_max\n        else:\n            u[i] = 1\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            committed_flexible.append(i)\n            total_output += p_max\n            remaining_load -= p_max\n    \n    # Economic dispatch with priority queue\n    # Initialize outputs\n    for i in committed_flexible:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        p[i] = p_min\n        total_output += p_min\n    \n    # Create priority queue for increasing output\n    heap = []\n    for i in must_run + committed_flexible:\n        unit = units[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n        if unit['u_i_0'] == 1:\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        if p[i] < p_max:\n            heapq.heappush(heap, (marginal_cost, i, p_max))\n    \n    # Increase generation from cheapest units\n    remaining_load = load - total_output\n    while remaining_load > 0 and heap:\n        marginal_cost, i, p_max = heapq.heappop(heap)\n        unit = units[i]\n        increase = min(remaining_load, p_max - p[i], unit['p_up_i'])\n        p[i] += increase\n        total_output += increase\n        remaining_load -= increase\n        if p[i] < p_max:\n            new_marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            heapq.heappush(heap, (new_marginal_cost, i, p_max))\n    \n    # Fine-tune to exactly match load\n    if abs(total_output - load) > 1e-6:\n        # Find cheapest unit to adjust\n        adjustable_units = []\n        for i in must_run + committed_flexible:\n            unit = units[i]\n            if total_output < load and p[i] < min(unit['p_max_i'], \n                unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i']):\n                adjustable_units.append((unit['b_i'] + 2 * unit['c_i'] * p[i], i, 1))\n            elif total_output > load and p[i] > max(unit['p_min_i'], \n                unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] == 1 else 0):\n                adjustable_units.append((-(unit['b_i'] + 2 * unit['c_i'] * p[i]), i, -1))\n        \n        adjustable_units.sort(key=lambda x: x[0])\n        for _, i, direction in adjustable_units:\n            if abs(total_output - load) < 1e-6:\n                break\n            unit = units[i]\n            if direction == 1:\n                max_increase = min(load - total_output, \n                                 min(unit['p_max_i'], \n                                     unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i']) - p[i])\n                p[i] += max_increase\n                total_output += max_increase\n            else:\n                max_decrease = min(total_output - load, \n                                 p[i] - max(unit['p_min_i'], \n                                           unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] == 1 else 0))\n                p[i] -= max_decrease\n                total_output -= max_decrease\n    \n    # Set must-off units to off\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.23019,
          "gap_price_rate": 0.12406,
          "fitness": 0.17713
     },
     {
          "name": "commit_units_rolling",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state and minimum up/down times.\n2. Dispatch must-run units first within ramp constraints and output limits.\n3. Sort flexible on units by marginal cost and dispatch remaining load.\n4. Sort flexible off units by marginal cost, turn on if feasible, and dispatch within startup ramp limits.\n5. Adjust outputs to balance load exactly by increasing generation from cheapest units or decreasing from most expensive units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    total_gen = 0\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            u[i] = 1\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p[i] = p_min\n            total_gen += p[i]\n    \n    remaining_load = load - total_gen\n    \n    flexible_on = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i] and unit['u_i_0'] == 1:\n            flexible_on.append(i)\n    \n    flexible_on.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_max_i'])\n    \n    for i in flexible_on:\n        if remaining_load <= 0:\n            break\n        u[i] = 1\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        alloc = min(remaining_load, p_max - p_min)\n        p[i] = p_min + alloc\n        remaining_load -= alloc\n    \n    flexible_off = []\n    for i, unit in enumerate(units_info):\n        if not must_run[i] and not must_off[i] and unit['u_i_0'] == 0:\n            flexible_off.append(i)\n    \n    flexible_off.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_max_i'])\n    \n    for i in flexible_off:\n        if remaining_load <= 0:\n            break\n        unit = units_info[i]\n        p_max = min(unit['p_start_i'], unit['p_up_i'], unit['p_max_i'])\n        if p_max < unit['p_min_i']:\n            continue\n        u[i] = 1\n        alloc = min(remaining_load, p_max)\n        if alloc < unit['p_min_i']:\n            alloc = unit['p_min_i']\n        p[i] = alloc\n        remaining_load -= alloc\n    \n    on_units = [i for i in range(n_units) if u[i] == 1]\n    on_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n    \n    for i in on_units:\n        if remaining_load <= 0:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_max = min(unit['p_start_i'], unit['p_up_i'], unit['p_max_i'])\n        additional = min(remaining_load, p_max - p[i])\n        p[i] += additional\n        remaining_load -= additional\n    \n    on_units.sort(key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n    \n    for i in on_units:\n        if remaining_load >= 0:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        else:\n            p_min = unit['p_min_i']\n        reduction = min(-remaining_load, p[i] - p_min)\n        p[i] -= reduction\n        remaining_load += reduction\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.19293,
          "gap_price_rate": 0.18348,
          "fitness": 0.18821
     },
     {
          "name": "commit_units_combined",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on previous state, minimum up/down times, and shutdown ramp constraints\n2. Dispatch must-run units at minimum feasible output considering ramp constraints\n3. Sort flexible on units by marginal cost and dispatch remaining load incrementally\n4. Sort flexible off units by average cost at maximum output (including startup cost) and commit until load is met\n5. Perform economic dispatch using marginal cost sorting to balance load exactly\n6. Adjust outputs respecting all ramp and output constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_combined(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    committed = list(must_run)\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p[i] = p_min\n        u[i] = 1\n    \n    current_load = sum(p)\n    remaining_load = load - current_load\n    \n    flexible_on = [i for i in flexible if units_info[i]['u_i_0'] == 1]\n    flexible_off = [i for i in flexible if units_info[i]['u_i_0'] == 0]\n    \n    def marginal_cost(i, power):\n        return units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * power\n    \n    flexible_on_sorted = sorted(flexible_on, key=lambda i: marginal_cost(i, units_info[i]['p_min_i']))\n    \n    for i in flexible_on_sorted:\n        if remaining_load <= 0:\n            break\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        available = p_max - p_min\n        to_add = min(remaining_load, available)\n        if to_add > 0:\n            p[i] = p_min + to_add\n            u[i] = 1\n            committed.append(i)\n            remaining_load -= to_add\n    \n    if remaining_load > 0:\n        def avg_cost(i):\n            unit = units_info[i]\n            max_p = unit['p_max_i']\n            cost = unit['a_i'] + unit['b_i'] * max_p + unit['c_i'] * max_p ** 2 + unit['s_i']\n            return cost / max_p\n        \n        flexible_off_sorted = sorted(flexible_off, key=avg_cost)\n        \n        for i in flexible_off_sorted:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            available = p_max - p_min\n            to_add = min(remaining_load, available)\n            if to_add > 0:\n                p[i] = p_min + to_add\n                u[i] = 1\n                committed.append(i)\n                remaining_load -= to_add\n    \n    current_load = sum(p)\n    remaining_load = load - current_load\n    \n    if abs(remaining_load) > 1e-6:\n        committed_sorted = sorted(committed, key=lambda i: marginal_cost(i, p[i]))\n        \n        if remaining_load > 0:\n            for i in committed_sorted:\n                if remaining_load <= 0:\n                    break\n                unit = units_info[i]\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n                available = p_max - p[i]\n                to_add = min(remaining_load, available)\n                if to_add > 0:\n                    p[i] += to_add\n                    remaining_load -= to_add\n        else:\n            for i in reversed(committed_sorted):\n                if remaining_load >= 0:\n                    break\n                unit = units_info[i]\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n                available = p[i] - p_min\n                to_reduce = min(-remaining_load, available)\n                if to_reduce > 0:\n                    p[i] -= to_reduce\n                    remaining_load += to_reduce\n    \n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.21314,
          "gap_price_rate": 0.21031,
          "fitness": 0.21172
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Dispatch must-run units first within their operating constraints\n3. Sort flexible units by marginal cost (including startup cost if applicable)\n4. Commit flexible units in cost order until load is met, respecting startup ramp limits for newly activated units\n5. Perform economic dispatch using priority-based adjustment to balance load exactly\n6. Ensure all constraints are maintained throughout the process\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = []\n    flexible_units = []\n    \n    # Classify units and handle must-run/must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                # Must-run unit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                schedules[0,i] = 1\n                schedules[1,i] = p_min\n                committed.append((i, p_min, p_max))\n            else:\n                flexible_units.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                # Must-off unit\n                schedules[0,i] = 0\n                schedules[1,i] = 0\n            else:\n                flexible_units.append(i)\n    \n    # Calculate current total generation\n    total_gen = sum(schedules[1,i] for i in range(n_units))\n    remaining_load = load - total_gen\n    \n    # Sort flexible units by marginal cost\n    def calculate_cost(unit, output):\n        return unit['a_i'] + unit['b_i'] * output + unit['c_i'] * output**2\n    \n    flexible_sorted = []\n    for i in flexible_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            # Include startup cost for offline units\n            base_cost = calculate_cost(unit, unit['p_max_i']) + unit['s_i']\n        else:\n            base_cost = calculate_cost(unit, unit['p_max_i'])\n        marginal_cost = base_cost / unit['p_max_i']\n        flexible_sorted.append((marginal_cost, i))\n    \n    flexible_sorted.sort(key=lambda x: x[0])\n    \n    # Commit flexible units until load is met\n    for cost, i in flexible_sorted:\n        if remaining_load <= 0:\n            break\n            \n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        \n        available = p_max - p_min\n        if available > 0:\n            schedules[0,i] = 1\n            schedules[1,i] = p_min\n            committed.append((i, p_min, p_max))\n            remaining_load -= p_min\n    \n    # Economic dispatch with priority queue\n    total_gen = sum(schedules[1,i] for i in range(n_units))\n    remaining_load = load - total_gen\n    \n    # Increase generation if needed\n    if remaining_load > 0:\n        heap = []\n        for i, p_min, p_max in committed:\n            unit = units_info[i]\n            current_p = schedules[1,i]\n            if current_p < p_max:\n                marginal_cost = 2 * unit['c_i'] * current_p + unit['b_i']\n                heapq.heappush(heap, (marginal_cost, i, current_p, p_max))\n        \n        while remaining_load > 0 and heap:\n            cost, i, current_p, p_max = heapq.heappop(heap)\n            unit = units_info[i]\n            max_increase = min(remaining_load, p_max - current_p, unit['p_up_i'])\n            new_p = current_p + max_increase\n            schedules[1,i] = new_p\n            remaining_load -= max_increase\n            \n            if new_p < p_max:\n                new_marginal = 2 * unit['c_i'] * new_p + unit['b_i']\n                heapq.heappush(heap, (new_marginal, i, new_p, p_max))\n    \n    # Decrease generation if needed\n    elif remaining_load < 0:\n        heap = []\n        for i, p_min, p_max in committed:\n            unit = units_info[i]\n            current_p = schedules[1,i]\n            if current_p > p_min:\n                marginal_cost = -(2 * unit['c_i'] * current_p + unit['b_i'])\n                heapq.heappush(heap, (marginal_cost, i, current_p, p_min))\n        \n        while remaining_load < 0 and heap:\n            cost, i, current_p, p_min = heapq.heappop(heap)\n            unit = units_info[i]\n            max_decrease = min(-remaining_load, current_p - p_min, unit['p_down_i'])\n            new_p = current_p - max_decrease\n            schedules[1,i] = new_p\n            remaining_load += max_decrease\n            \n            if new_p > p_min:\n                new_marginal = -(2 * unit['c_i'] * new_p + unit['b_i'])\n                heapq.heappush(heap, (new_marginal, i, new_p, p_min))\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.21381,
          "gap_price_rate": 0.21109,
          "fitness": 0.21245
     },
     {
          "name": "commit_units_by_priority_list",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Sort flexible units by average cost per unit power at maximum output\n3. Commit flexible units in cost order until total available capacity meets load\n4. Perform economic dispatch considering ramp constraints and cost minimization\n5. Adjust commitment and dispatch if load cannot be met exactly\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_list(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    for i in must_run:\n        u[i] = 1\n        p[i] = max(units_info[i]['p_min_i'], \n                  units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n    \n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    def avg_cost(i):\n        unit = units_info[i]\n        return (unit['a_i'] + unit['b_i'] * unit['p_max_i'] + \n                unit['c_i'] * unit['p_max_i']**2 + unit['s_i']) / unit['p_max_i']\n    \n    flexible.sort(key=avg_cost)\n    \n    total_min = sum(p)\n    total_max = sum(p)\n    for i in must_run:\n        total_max += min(units_info[i]['p_max_i'], \n                       units_info[i]['p_i_0'] + units_info[i]['p_up_i']) - p[i]\n    \n    committed_flexible = []\n    for i in flexible:\n        if total_max < load:\n            u[i] = 1\n            committed_flexible.append(i)\n            if units_info[i]['u_i_0'] == 0:\n                p_i_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            else:\n                p_i_max = min(units_info[i]['p_max_i'], \n                             units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            total_max += p_i_max\n        else:\n            u[i] = 0\n            p[i] = 0\n    \n    committed = must_run + committed_flexible\n    remaining_load = load - sum(p)\n    \n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            lb[i] = max(units_info[i]['p_min_i'], \n                       units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            ub[i] = min(units_info[i]['p_max_i'], \n                       units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lb[i] = units_info[i]['p_min_i']\n            ub[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        p[i] = lb[i]\n    \n    remaining_load -= sum(p)\n    \n    while remaining_load > 1e-6:\n        best_i = None\n        best_cost = float('inf')\n        for i in committed:\n            if p[i] < ub[i]:\n                marginal_cost = (units_info[i]['b_i'] + \n                                2 * units_info[i]['c_i'] * p[i])\n                if marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_i = i\n        if best_i is None:\n            break\n        \n        max_inc = ub[best_i] - p[best_i]\n        inc = min(remaining_load, max_inc)\n        p[best_i] += inc\n        remaining_load -= inc\n    \n    while remaining_load < -1e-6:\n        worst_i = None\n        worst_cost = -float('inf')\n        for i in committed:\n            if p[i] > lb[i]:\n                marginal_cost = (units_info[i]['b_i'] + \n                                2 * units_info[i]['c_i'] * p[i])\n                if marginal_cost > worst_cost:\n                    worst_cost = marginal_cost\n                    worst_i = i\n        if worst_i is None:\n            break\n        \n        max_dec = p[worst_i] - lb[worst_i]\n        dec = min(-remaining_load, max_dec)\n        p[worst_i] -= dec\n        remaining_load += dec\n    \n    schedules = np.vstack([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.3607,
          "gap_price_rate": 0.25024,
          "fitness": 0.30547
     }
]