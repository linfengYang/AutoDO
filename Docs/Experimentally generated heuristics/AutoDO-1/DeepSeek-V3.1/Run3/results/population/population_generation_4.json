[
     {
          "name": "enhanced_adaptive_priority_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Step 1: Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power range considering ramp constraints\n        if unit['u_i_0'] == 1:  # Previously on\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check minimum up time constraint\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously off\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            # Check minimum down time constraint\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = p_min\n        feasible_max[i] = p_max\n    \n    # Step 2: Commit must-run units\n    committed = set(must_run)\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        schedules[0][i] = 1\n        schedules[1][i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    # Step 3: Compute adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        if units_info[i]['u_i_0'] == 0:\n            # Include startup cost if unit was off\n            full_cost = (units_info[i]['s_i'] + \n                         units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        else:\n            full_cost = (units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        \n        # Adjust priority based on ramp capabilities\n        ramp_factor = (feasible_max[i] - feasible_min[i]) / max(1, units_info[i]['p_up_i'])\n        priority = full_cost / (feasible_min[i] + 1e-6) * (1 - 0.1 * ramp_factor)\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            schedules[0][i] = 1\n            schedules[1][i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Step 5: Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units_info[i]\n            # Calculate unconstrained output\n            p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n            # Constrain within feasible range\n            p_dispatch = max(feasible_min[i], min(feasible_max[i], p_star))\n            total_power += p_dispatch\n        \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final dispatch values\n    for i in committed:\n        unit = units_info[i]\n        p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n        schedules[1][i] = max(feasible_min[i], min(feasible_max[i], p_star))\n    \n    # Step 6: Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    while abs(diff) > 1e-6:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed:\n            if diff > 0 and schedules[1][i] < feasible_max[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n            elif diff < 0 and schedules[1][i] > feasible_min[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost (ascending for increasing, descending for decreasing)\n        adjustable.sort(key=lambda x: x[0], reverse=diff < 0)\n        \n        # Adjust the most suitable unit\n        i = adjustable[0][1]\n        if diff > 0:\n            adjust = min(diff, feasible_max[i] - schedules[1][i])\n        else:\n            adjust = max(diff, feasible_min[i] - schedules[1][i])\n        \n        schedules[1][i] += adjust\n        diff -= adjust\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0087069616,
          "fitness": 0.0070677491
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units using adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check minimum up/down time constraints\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate feasible output range\n        if u_i0 == 1:\n            p_min = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n        unit['p_min_feas'] = p_min\n        unit['p_max_feas'] = p_max\n\n    # Commit must-run units\n    total_min = 0\n    total_max = 0\n    committed = set(must_run)\n    \n    for i in must_run:\n        unit = units[i]\n        schedules[0, i] = 1\n        schedules[1, i] = unit['p_min_feas']\n        total_min += unit['p_min_feas']\n        total_max += unit['p_max_feas']\n        \n    # Commit flexible units if needed\n    if total_min > load:\n        # Decommit most expensive flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_feas']\n            flexible_costs.append((i, marginal_cost))\n        \n        flexible_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in flexible_costs:\n            if total_min <= load:\n                break\n            unit = units[i]\n            total_min -= unit['p_min_feas']\n            total_max -= unit['p_max_feas']\n            committed.discard(i)\n            \n    elif total_max < load:\n        # Commit additional flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            full_cost = (unit['s_i'] if unit['u_i_0'] == 0 else 0) + \\\n                       unit['a_i'] + unit['b_i'] * unit['p_min_feas'] + \\\n                       unit['c_i'] * unit['p_min_feas'] ** 2\n            cost_per_mw = full_cost / unit['p_min_feas']\n            flexible_costs.append((i, cost_per_mw))\n        \n        flexible_costs.sort(key=lambda x: x[1])\n        \n        for i, _ in flexible_costs:\n            if total_max >= load:\n                break\n            unit = units[i]\n            committed.add(i)\n            total_min += unit['p_min_feas']\n            total_max += unit['p_max_feas']\n\n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # Sufficiently high value\n    \n    for _ in range(100):  # Iteration limit\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units[i]\n            p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_dispatch = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n            total_power += p_dispatch\n            \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n\n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        schedules[0, i] = 1\n        schedules[1, i] = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n\n    # Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    if diff != 0:\n        # Create priority list based on marginal cost\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((i, mc))\n        \n        if diff > 0:\n            marginal_costs.sort(key=lambda x: x[1])\n        else:\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            \n        for i, _ in marginal_costs:\n            if abs(diff) < 1e-6:\n                break\n            unit = units[i]\n            current_p = schedules[1, i]\n            if diff > 0:\n                new_p = min(current_p + diff, unit['p_max_feas'])\n            else:\n                new_p = max(current_p + diff, unit['p_min_feas'])\n            diff -= (new_p - current_p)\n            schedules[1, i] = new_p\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0087811081,
          "fitness": 0.0071048223
     },
     {
          "name": "improved_commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units by adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef improved_commit_units_heuristic(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Calculate feasible power range\n        if unit['u_i_0'] == 1:  # previously online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check if must-run due to min up-time or shutdown ramp\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # previously offline\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            # Check if must-off due to min down-time\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = min_p\n        feasible_max[i] = max_p\n    \n    # Commit must-run units\n    committed = set(must_run)\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]  # start at minimum\n    \n    # Calculate current total generation\n    total_gen = np.sum(p)\n    total_max = np.sum([feasible_max[i] for i in committed])\n    total_min = np.sum([feasible_min[i] for i in committed])\n    \n    # Commit flexible units if needed\n    if total_max < load:\n        # Calculate full cost for flexible units\n        costs = []\n        for i in flexible:\n            if i in must_off:\n                continue\n            min_cost = (units[i]['a_i'] + units[i]['b_i'] * feasible_min[i] + \n                        units[i]['c_i'] * feasible_min[i]**2)\n            full_cost = min_cost + units[i]['s_i'] if units[i]['u_i_0'] == 0 else min_cost\n            costs.append((full_cost / feasible_min[i], i))\n        \n        # Sort by cost per MW\n        costs.sort(key=lambda x: x[0])\n        \n        # Commit units until load can be met\n        for _, i in costs:\n            if total_max >= load:\n                break\n            if i not in committed:\n                committed.add(i)\n                u[i] = 1\n                p[i] = feasible_min[i]\n                total_max += feasible_max[i]\n                total_min += feasible_min[i]\n    \n    # Decommit units if minimum generation exceeds load\n    if total_min > load:\n        # Sort committed units by marginal cost at minimum output\n        costs = []\n        for i in committed:\n            if i in must_run:\n                continue\n            marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * feasible_min[i]\n            costs.append((marg_cost, i))\n        \n        costs.sort(reverse=True, key=lambda x: x[0])\n        \n        # Decommit units until feasible\n        for _, i in costs:\n            if total_min <= load:\n                break\n            committed.discard(i)\n            u[i] = 0\n            p[i] = 0\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n    \n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # sufficiently high value\n    \n    for _ in range(100):  # 100 iterations for convergence\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            # Constrain output\n            p_i = max(feasible_min[i], min(feasible_max[i], p_uncon))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = max(feasible_min[i], min(feasible_max[i], p_uncon))\n    \n    # Adjust to exactly match load\n    total_p = np.sum(p)\n    diff = load - total_p\n    \n    while abs(diff) > 1e-5:\n        # Find unit to adjust\n        if diff > 0:\n            # Increase output of unit with lowest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = min(feasible_max[i], p[i] + min(diff, feasible_max[i] - p[i]))\n        else:\n            # Decrease output of unit with highest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(reverse=True, key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = max(feasible_min[i], p[i] + max(diff, feasible_min[i] - p[i]))\n        \n        total_p = np.sum(p)\n        diff = load - total_p\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0087811083,
          "fitness": 0.007104823
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If must-run units can meet load, perform economic dispatch only on must-run units\n4. Otherwise, activate additional units based on cost efficiency considering startup costs\n5. Perform constrained economic dispatch on committed units to match load exactly\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    committed = [False] * num_units\n    p_outputs = [0.0] * num_units\n    \n    # Identify must-run units\n    must_run = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                committed[i] = True\n                # Set initial output considering ramp down limit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_outputs[i] = p_min\n    \n    # Calculate available capacity from must-run units\n    must_run_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_capacity += p_max\n    \n    # Activate additional units if needed\n    if must_run_capacity < load:\n        # Create candidate list of non-committed units that can be activated\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                if unit['u_i_0'] == 0 and abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    # Calculate effective cost per MW\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']\n                    cost_per_mw = min_cost / unit['p_min_i']\n                    candidates.append((cost_per_mw, i))\n                elif unit['u_i_0'] == 1:\n                    # Already on but not must-run - use marginal cost\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n                    candidates.append((marginal_cost, i))\n        \n        # Sort candidates by cost\n        candidates.sort(key=lambda x: x[0])\n        \n        # Activate cheapest units until we can meet load\n        for cost, idx in candidates:\n            if must_run_capacity >= load:\n                break\n            unit = units_info[idx]\n            committed[idx] = True\n            if unit['u_i_0'] == 0:\n                # Starting up - respect startup ramp\n                p_outputs[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                # Already on - respect ramp up\n                p_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_run_capacity += p_outputs[idx]\n    \n    # Perform economic dispatch to match load exactly\n    total_output = sum(p_outputs)\n    remaining_load = load - total_output\n    \n    # Adjust outputs while respecting constraints\n    while abs(remaining_load) > 1e-6:\n        # Find unit with minimum marginal cost for increase or maximum for decrease\n        best_unit = None\n        best_cost = float('inf') if remaining_load > 0 else float('-inf')\n        \n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                continue\n                \n            current_p = p_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0:  # Need to increase output\n                # Check ramp up and max limits\n                max_p = unit['p_max_i']\n                if unit['u_i_0'] == 1:\n                    max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n                elif unit['u_i_0'] == 0 and committed[i]:\n                    max_p = min(max_p, unit['p_start_i'])\n                \n                if current_p < max_p and marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n            else:  # Need to decrease output\n                # Check ramp down and min limits\n                min_p = unit['p_min_i']\n                if unit['u_i_0'] == 1:\n                    min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                \n                if current_p > min_p and marginal_cost > best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = p_outputs[best_unit]\n        \n        if remaining_load > 0:\n            max_p = unit['p_max_i']\n            if unit['u_i_0'] == 1:\n                max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n            elif unit['u_i_0'] == 0:\n                max_p = min(max_p, unit['p_start_i'])\n            \n            adjustment = min(remaining_load, max_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n        else:\n            min_p = unit['p_min_i']\n            if unit['u_i_0'] == 1:\n                min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n            \n            adjustment = max(remaining_load, min_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n    \n    # Prepare output\n    for i in range(num_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0055684358,
          "gap_price_rate": 0.0091494698,
          "fitness": 0.0073589528
     },
     {
          "name": "commit_units_improved_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute adaptive priorities considering marginal cost, startup cost, and ramp capabilities for flexible units\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Commit flexible units in adaptive priority order until load can be met\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n",
          "code": "import numpy as np\n\ndef commit_units_improved_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute constraints and categories\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    p_min_cur = np.zeros(n_units)\n    p_max_cur = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Check must-run conditions\n        if u0 == 1 and (t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']):\n            must_run[i] = True\n        \n        # Check must-off conditions\n        if u0 == 0 and abs(t0) < unit['t_off_min_i']:\n            must_off[i] = True\n        \n        # Calculate current output limits\n        if must_run[i] or u0 == 1:\n            p_min_cur[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            p_max_cur[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            p_min_cur[i] = unit['p_min_i']\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate adaptive priorities\n    priorities = []\n    for i, unit in enumerate(units_info):\n        if must_off[i]:\n            continue\n            \n        if must_run[i] or unit['u_i_0'] == 1:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_cur[i]\n            ramp_factor = unit['p_up_i'] + unit['p_down_i']\n            priority = marginal_cost / (1 + ramp_factor)\n        else:\n            avg_cost = (unit['s_i'] + unit['b_i'] * p_min_cur[i] + \n                       unit['c_i'] * p_min_cur[i]**2) / p_min_cur[i]\n            ramp_factor = unit['p_up_i']\n            priority = avg_cost / (1 + ramp_factor)\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    # Initial commitment\n    committed = set(np.where(must_run)[0])\n    total_min = sum(p_min_cur[i] for i in committed)\n    total_max = sum(p_max_cur[i] for i in committed)\n    \n    # Add flexible units by priority\n    for _, i in priorities:\n        if i not in committed and not must_off[i]:\n            if total_max < load:\n                committed.add(i)\n                total_min += p_min_cur[i]\n                total_max += p_max_cur[i]\n            else:\n                break\n    \n    # Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Bisection iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units_info[i]\n            p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, p_min_cur[i], p_max_cur[i])\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units_info[i]\n        p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = np.clip(p_i, p_min_cur[i], p_max_cur[i])\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0039112517,
          "gap_price_rate": 0.0117700626,
          "fitness": 0.0078406571
     },
     {
          "name": "refined_commit_units_priority_dispatch",
          "algorithm": "1. Enforce minimum up/down time constraints by identifying must-run and must-off units based on current state and historical parameters\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Sort available units by full incremental cost (including startup costs when applicable)\n4. Perform priority-based commitment using adaptive thresholding to balance load demand and cost efficiency\n5. Execute constrained economic dispatch using iterative lambda adjustment with ramp-aware generation limits\n6. Fine-tune outputs using marginal cost prioritization to exactly match load while respecting all physical constraints\n7. Validate and adjust commitments to ensure minimum generation and ramp constraints are satisfied\n\n",
          "code": "import numpy as np\n\ndef refined_commit_units_priority_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Enforce minimum up/down constraints\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Step 2: Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    for i, unit in enumerate(units):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min[i] = unit['p_min_i']\n                p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    # Step 3: Calculate full incremental costs\n    cost_list = []\n    for i, unit in enumerate(units):\n        if i in must_run or i in must_off:\n            continue\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min[i]\n        if unit['u_i_0'] == 0:\n            full_cost = marginal_cost + unit['s_i'] / max(p_min[i], 1e-6)\n        else:\n            full_cost = marginal_cost\n        cost_list.append((i, full_cost))\n    \n    # Sort by full incremental cost\n    cost_list.sort(key=lambda x: x[1])\n    \n    # Step 4: Priority-based commitment\n    current_capacity = sum(p_max[i] for i in range(n_units) if u[i] == 1)\n    for i, _ in cost_list:\n        if current_capacity >= load:\n            break\n        if u[i] == 0:\n            u[i] = 1\n            p_min[i] = units[i]['p_min_i']\n            p_max[i] = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            current_capacity += p_max[i]\n    \n    # Step 5: Constrained economic dispatch\n    total_min = sum(p_min[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(p_max[i] for i in range(n_units) if u[i] == 1)\n    \n    if load < total_min:\n        # Decommit highest cost units\n        committed = [i for i in range(n_units) if u[i] == 1 and i not in must_run]\n        cost_vals = []\n        for i in committed:\n            cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p_min[i]\n            cost_vals.append((i, cost))\n        cost_vals.sort(key=lambda x: -x[1])\n        \n        for i, _ in cost_vals:\n            if total_min <= load:\n                break\n            u[i] = 0\n            p_min[i] = 0\n            p_max[i] = 0\n            total_min -= units[i]['p_min_i']\n    \n    elif load > total_max:\n        # Commit additional units\n        available = [i for i in range(n_units) if u[i] == 0 and i not in must_off]\n        cost_vals = []\n        for i in available:\n            cost = units[i]['b_i'] + 2 * units[i]['c_i'] * units[i]['p_min_i']\n            cost += units[i]['s_i'] / max(units[i]['p_min_i'], 1e-6)\n            cost_vals.append((i, cost))\n        cost_vals.sort(key=lambda x: x[1])\n        \n        for i, _ in cost_vals:\n            if total_max >= load:\n                break\n            u[i] = 1\n            p_min[i] = units[i]['p_min_i']\n            p_max[i] = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            total_max += p_max[i]\n    \n    # Lambda iteration with ramp constraints\n    lambda_low = 0\n    lambda_high = 1000\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    \n    for _ in range(100):  # Iterative lambda adjustment\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for i in committed_idx:\n            p_i = (lambda_mid - units[i]['b_i']) / (2 * units[i]['c_i'])\n            p_i = max(p_min[i], min(p_max[i], p_i))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tune outputs\n    for i in committed_idx:\n        p[i] = (lambda_mid - units[i]['b_i']) / (2 * units[i]['c_i'])\n        p[i] = max(p_min[i], min(p_max[i], p[i]))\n    \n    # Step 7: Validate and adjust\n    total_output = sum(p)\n    if abs(total_output - load) > 1e-6:\n        # Marginal cost-based adjustment\n        mc = []\n        for i in committed_idx:\n            marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n            mc.append((i, marginal_cost))\n        \n        mc.sort(key=lambda x: x[1] if total_output < load else -x[1])\n        \n        for i, _ in mc:\n            if abs(total_output - load) < 1e-6:\n                break\n            if total_output < load:\n                adjust = min(p_max[i] - p[i], load - total_output)\n                p[i] += adjust\n                total_output += adjust\n            else:\n                adjust = min(p[i] - p_min[i], total_output - load)\n                p[i] -= adjust\n                total_output -= adjust\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.004662822,
          "gap_price_rate": 0.012217254,
          "fitness": 0.008440038
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints.\n2. Compute adaptive priorities considering marginal cost, startup cost, and ramp capabilities.\n3. Commit must-run units and flexible units by adaptive priority until load is met.\n4. Perform economic dispatch using a merit order approach while respecting output and ramp constraints.\n5. Adjust commitments if load is not met or constraints are violated.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost + unit['s_i'] / unit['p_max_i'] if unit['u_i_0'] == 0 else marginal_cost\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    sorted_flexible = [i for _, i in priorities]\n    \n    committed = must_run[:]\n    total_max = sum(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else unit['p_start_i'] for unit in [units_info[i] for i in committed])\n    \n    for i in sorted_flexible:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        committed.append(i)\n        total_max += unit['p_start_i'] if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    L = np.zeros(n_units)\n    U = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            L[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            L[i] = unit['p_min_i']\n            U[i] = unit['p_start_i']\n    \n    for i in committed:\n        p[i] = L[i]\n    \n    remaining = load - np.sum(p)\n    units_to_adjust = [i for i in committed if p[i] < U[i]]\n    \n    while remaining > 0 and units_to_adjust:\n        marginal_costs = []\n        for i in units_to_adjust:\n            unit = units_info[i]\n            marginal_costs.append((unit['b_i'] + 2 * unit['c_i'] * p[i], i))\n        marginal_costs.sort(key=lambda x: x[0])\n        best_unit = marginal_costs[0][1]\n        increase = min(remaining, U[best_unit] - p[best_unit])\n        p[best_unit] += increase\n        remaining -= increase\n        if p[best_unit] >= U[best_unit]:\n            units_to_adjust.remove(best_unit)\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0062422093,
          "gap_price_rate": 0.0107972871,
          "fitness": 0.0085197482
     },
     {
          "name": "enhanced_commitment_dispatch",
          "algorithm": "1. Enforce minimum up/down time constraints by identifying must-run and must-off units based on current state and historical parameters\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Sort available units by full incremental cost (including startup costs when applicable)\n4. Perform priority-based commitment using adaptive thresholding to balance load demand and cost efficiency\n5. Execute constrained economic dispatch using iterative lambda adjustment with ramp-aware generation limits\n6. Fine-tune outputs using marginal cost prioritization to exactly match load while respecting all physical constraints\n7. Validate and adjust commitments to ensure minimum generation and ramp constraints are satisfied\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch(units_info, load):\n    units = units_info\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Calculate feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3: Calculate full incremental costs\n    full_costs = []\n    for i, unit in enumerate(units):\n        if i in must_off:\n            continue\n        min_p = p_min_feasible[i]\n        incremental_cost = unit['b_i'] + 2 * unit['c_i'] * min_p\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        full_cost = incremental_cost + startup_cost / min_p if min_p > 0 else float('inf')\n        full_costs.append((full_cost, i))\n    \n    full_costs.sort(key=lambda x: x[0])\n    \n    # Step 4: Priority-based commitment\n    committed = set(must_run)\n    total_min = sum(p_min_feasible[i] for i in committed)\n    total_max = sum(p_max_feasible[i] for i in committed)\n    \n    for cost, i in full_costs:\n        if i not in committed and i not in must_off:\n            if total_max < load:\n                committed.add(i)\n                total_min += p_min_feasible[i]\n                total_max += p_max_feasible[i]\n            else:\n                break\n    \n    # Adjust if overcommitted\n    while total_min > load:\n        candidate = -1\n        highest_cost = -1\n        for i in committed:\n            if i not in must_run:\n                cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p_min_feasible[i]\n                if cost > highest_cost:\n                    highest_cost = cost\n                    candidate = i\n        if candidate == -1:\n            break\n        committed.remove(candidate)\n        total_min -= p_min_feasible[candidate]\n        total_max -= p_max_feasible[candidate]\n    \n    # Step 5: Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 1000\n    tol = 1e-6\n    committed_list = list(committed)\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for i in committed_list:\n            unit = units[i]\n            p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_max_feasible[i]\n            p_i = max(p_min_feasible[i], min(p_max_feasible[i], p_i))\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Assign power outputs\n    for i in committed_list:\n        unit = units[i]\n        p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else p_max_feasible[i]\n        p[i] = max(p_min_feasible[i], min(p_max_feasible[i], p_i))\n        u[i] = 1\n    \n    # Step 6: Fine-tune to match load exactly\n    total_p = sum(p)\n    diff = load - total_p\n    while abs(diff) > tol:\n        candidates = []\n        for i in committed_list:\n            if diff > 0 and p[i] < p_max_feasible[i]:\n                candidates.append((units[i]['b_i'] + 2 * units[i]['c_i'] * p[i], i))\n            elif diff < 0 and p[i] > p_min_feasible[i]:\n                candidates.append((units[i]['b_i'] + 2 * units[i]['c_i'] * p[i], i))\n        \n        if not candidates:\n            break\n        \n        candidates.sort(key=lambda x: x[0] if diff > 0 else -x[0])\n        i = candidates[0][1]\n        if diff > 0:\n            p[i] = min(p_max_feasible[i], p[i] + min(diff, units[i]['p_up_i']))\n        else:\n            p[i] = max(p_min_feasible[i], p[i] + max(diff, -units[i]['p_down_i']))\n        total_p = sum(p)\n        diff = load - total_p\n    \n    # Step 7: Validate and adjust constraints\n    for i in range(n_units):\n        if u[i] == 1:\n            if p[i] < p_min_feasible[i] or p[i] > p_max_feasible[i]:\n                u[i] = 0\n                p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0057602299,
          "gap_price_rate": 0.0151141701,
          "fitness": 0.0104372
     },
     {
          "name": "enhanced_adaptive_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories using minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output while respecting ramp constraints\n4. If must-run units cannot meet load, activate flexible units using adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method with ramp-aware output limits to find optimal lambda\n6. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n7. Validate and enforce all physical constraints before returning schedules\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment_dispatch(units_info, load):\n    # Initialize schedules\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges and initialize commitments\n    p_min_feasible = np.zeros(num_units)\n    p_max_feasible = np.zeros(num_units)\n    \n    for i in range(num_units):\n        unit = units_info[i]\n        if i in must_run:\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            schedules[0, i] = 1\n        elif i in must_off:\n            p_min_feasible[i] = 0\n            p_max_feasible[i] = 0\n            schedules[0, i] = 0\n        else:\n            if unit['u_i_0'] == 1:\n                p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min_feasible[i] = unit['p_min_i']\n                p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Commit must-run units\n    total_min = sum(p_min_feasible[i] for i in must_run)\n    total_max = sum(p_max_feasible[i] for i in must_run)\n    \n    # Activate flexible units if needed\n    if total_max < load:\n        # Calculate full costs for flexible units\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            if schedules[0, i] == 0:  # Currently off\n                min_cost = (unit['s_i'] + unit['b_i'] * p_min_feasible[i] + \n                           unit['c_i'] * p_min_feasible[i] ** 2)\n                cost_per_mw = min_cost / p_min_feasible[i] if p_min_feasible[i] > 0 else float('inf')\n            else:\n                cost_per_mw = (unit['b_i'] + 2 * unit['c_i'] * p_min_feasible[i])\n            costs.append((cost_per_mw, i))\n        \n        # Sort by cost priority\n        costs.sort(key=lambda x: x[0])\n        \n        for cost, i in costs:\n            if total_max >= load:\n                break\n            schedules[0, i] = 1\n            total_max += p_max_feasible[i]\n    \n    # Economic dispatch using bisection\n    committed_idx = [i for i in range(num_units) if schedules[0, i] == 1]\n    if not committed_idx:\n        return schedules\n    \n    # Initialize lambda bounds\n    low = min(units_info[i]['b_i'] for i in committed_idx)\n    high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_max_feasible[i] \n              for i in committed_idx)\n    \n    # Bisection method\n    for _ in range(100):\n        lambda_val = (low + high) / 2\n        total_p = 0\n        for i in committed_idx:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                p_val = p_max_feasible[i] if lambda_val >= unit['b_i'] else p_min_feasible[i]\n            else:\n                p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(p_min_feasible[i], min(p_max_feasible[i], p_val))\n            schedules[1, i] = p_val\n            total_p += p_val\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            low = lambda_val\n        else:\n            high = lambda_val\n    \n    # Fine-tune for exact load matching\n    total_p = sum(schedules[1, i] for i in committed_idx)\n    delta = load - total_p\n    if abs(delta) > 1e-6:\n        # Adjust based on marginal costs\n        margins = []\n        for i in committed_idx:\n            unit = units_info[i]\n            margin = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            if delta > 0 and schedules[1, i] < p_max_feasible[i]:\n                margins.append((margin, i, 1))\n            elif delta < 0 and schedules[1, i] > p_min_feasible[i]:\n                margins.append((margin, i, -1))\n        \n        margins.sort(key=lambda x: x[0] * x[2])\n        \n        for margin, i, direction in margins:\n            if abs(delta) < 1e-6:\n                break\n            adjust = min(abs(delta), \n                        p_max_feasible[i] - schedules[1, i] if direction == 1 else \n                        schedules[1, i] - p_min_feasible[i])\n            schedules[1, i] += direction * adjust\n            delta -= direction * adjust\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0059476368,
          "gap_price_rate": 0.0159099608,
          "fitness": 0.0109287988
     },
     {
          "name": "commit_units_priority_dispatch",
          "algorithm": "1. Enforce minimum up/down time constraints by forcing units to remain on/off if required\n2. Sort available units by incremental cost (derivative of cost function)\n3. Perform priority-based unit commitment considering startup costs and ramp constraints\n4. Execute economic dispatch using lambda iteration to minimize production costs\n5. Adjust outputs to respect ramp limits and minimum generation constraints\n6. Ensure load balance while respecting all physical constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Enforce minimum up/down time constraints\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Calculate incremental costs for all units\n    incremental_costs = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            current_p = unit['p_i_0']\n        else:\n            current_p = 0\n        inc_cost = 2 * unit['c_i'] * current_p + unit['b_i']\n        incremental_costs.append(inc_cost)\n    \n    # Create priority list based on incremental costs\n    priority_list = sorted(range(n_units), key=lambda i: incremental_costs[i])\n    \n    # Commit units based on priority\n    committed = set(forced_on)\n    total_capacity = 0\n    for i in priority_list:\n        if i in forced_off:\n            continue\n        unit = units_info[i]\n        max_output = min(unit['p_max_i'], \n                        unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i'])\n        if total_capacity + max_output < load and i not in forced_on:\n            committed.add(i)\n            total_capacity += max_output\n        elif i in forced_on:\n            total_capacity += max_output\n    \n    # Economic dispatch using lambda iteration\n    low = min(2*unit['c_i']*unit['p_min_i'] + unit['b_i'] for i in committed for unit in [units_info[i]])\n    high = max(2*unit['c_i']*unit['p_max_i'] + unit['b_i'] for i in committed for unit in [units_info[i]])\n    \n    for _ in range(100):  # Lambda iteration\n        lambda_val = (low + high) / 2\n        total_gen = 0\n        for i in committed:\n            unit = units_info[i]\n            p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            # Apply output constraints\n            p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n            # Apply ramp constraints\n            if unit['u_i_0'] == 1:\n                p = max(unit['p_i_0'] - unit['p_down_i'], \n                       min(unit['p_i_0'] + unit['p_up_i'], p))\n            else:\n                p = min(unit['p_start_i'], p)\n            total_gen += p\n        \n        if abs(total_gen - load) < 1e-3:\n            break\n        elif total_gen < load:\n            low = lambda_val\n        else:\n            high = lambda_val\n    \n    # Final dispatch with constraint enforcement\n    total_gen = 0\n    for i in committed:\n        unit = units_info[i]\n        p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n        if unit['u_i_0'] == 1:\n            p = max(unit['p_i_0'] - unit['p_down_i'], \n                   min(unit['p_i_0'] + unit['p_up_i'], p))\n        else:\n            p = min(unit['p_start_i'], p)\n        schedules[1][i] = p\n        schedules[0][i] = 1\n        total_gen += p\n    \n    # Load balancing adjustment\n    diff = load - total_gen\n    while abs(diff) > 1e-3:\n        adjusted = False\n        for i in committed:\n            unit = units_info[i]\n            if diff > 0:  # Need more power\n                new_p = min(schedules[1][i] + diff, unit['p_max_i'])\n                if unit['u_i_0'] == 1:\n                    new_p = min(new_p, unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    new_p = min(new_p, unit['p_start_i'])\n                if new_p > schedules[1][i]:\n                    diff -= (new_p - schedules[1][i])\n                    schedules[1][i] = new_p\n                    adjusted = True\n            else:  # Need less power\n                new_p = max(schedules[1][i] + diff, unit['p_min_i'])\n                if unit['u_i_0'] == 1:\n                    new_p = max(new_p, unit['p_i_0'] - unit['p_down_i'])\n                if new_p < schedules[1][i]:\n                    diff -= (new_p - schedules[1][i])\n                    schedules[1][i] = new_p\n                    adjusted = True\n        if not adjusted:\n            break\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0051705491,
          "gap_price_rate": 0.0175151129,
          "fitness": 0.011342831
     }
]