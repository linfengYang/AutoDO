[
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If must-run units can meet load, perform economic dispatch only on must-run units\n4. Otherwise, activate additional units based on cost efficiency considering startup costs\n5. Perform constrained economic dispatch on committed units to match load exactly\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    committed = [False] * num_units\n    p_outputs = [0.0] * num_units\n    \n    # Identify must-run units\n    must_run = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                committed[i] = True\n                # Set initial output considering ramp down limit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_outputs[i] = p_min\n    \n    # Calculate available capacity from must-run units\n    must_run_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_capacity += p_max\n    \n    # Activate additional units if needed\n    if must_run_capacity < load:\n        # Create candidate list of non-committed units that can be activated\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                if unit['u_i_0'] == 0 and abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    # Calculate effective cost per MW\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']\n                    cost_per_mw = min_cost / unit['p_min_i']\n                    candidates.append((cost_per_mw, i))\n                elif unit['u_i_0'] == 1:\n                    # Already on but not must-run - use marginal cost\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n                    candidates.append((marginal_cost, i))\n        \n        # Sort candidates by cost\n        candidates.sort(key=lambda x: x[0])\n        \n        # Activate cheapest units until we can meet load\n        for cost, idx in candidates:\n            if must_run_capacity >= load:\n                break\n            unit = units_info[idx]\n            committed[idx] = True\n            if unit['u_i_0'] == 0:\n                # Starting up - respect startup ramp\n                p_outputs[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                # Already on - respect ramp up\n                p_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_run_capacity += p_outputs[idx]\n    \n    # Perform economic dispatch to match load exactly\n    total_output = sum(p_outputs)\n    remaining_load = load - total_output\n    \n    # Adjust outputs while respecting constraints\n    while abs(remaining_load) > 1e-6:\n        # Find unit with minimum marginal cost for increase or maximum for decrease\n        best_unit = None\n        best_cost = float('inf') if remaining_load > 0 else float('-inf')\n        \n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                continue\n                \n            current_p = p_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0:  # Need to increase output\n                # Check ramp up and max limits\n                max_p = unit['p_max_i']\n                if unit['u_i_0'] == 1:\n                    max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n                elif unit['u_i_0'] == 0 and committed[i]:\n                    max_p = min(max_p, unit['p_start_i'])\n                \n                if current_p < max_p and marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n            else:  # Need to decrease output\n                # Check ramp down and min limits\n                min_p = unit['p_min_i']\n                if unit['u_i_0'] == 1:\n                    min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                \n                if current_p > min_p and marginal_cost > best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = p_outputs[best_unit]\n        \n        if remaining_load > 0:\n            max_p = unit['p_max_i']\n            if unit['u_i_0'] == 1:\n                max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n            elif unit['u_i_0'] == 0:\n                max_p = min(max_p, unit['p_start_i'])\n            \n            adjustment = min(remaining_load, max_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n        else:\n            min_p = unit['p_min_i']\n            if unit['u_i_0'] == 1:\n                min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n            \n            adjustment = max(remaining_load, min_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n    \n    # Prepare output\n    for i in range(num_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0055684358,
          "gap_price_rate": 0.0091494698,
          "fitness": 0.0073589528
     },
     {
          "name": "commit_units_improved_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Compute adaptive priorities considering marginal cost, startup cost, and ramp capabilities for flexible units\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Commit flexible units in adaptive priority order until load can be met\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n",
          "code": "import numpy as np\n\ndef commit_units_improved_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute constraints and categories\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    p_min_cur = np.zeros(n_units)\n    p_max_cur = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        # Check must-run conditions\n        if u0 == 1 and (t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']):\n            must_run[i] = True\n        \n        # Check must-off conditions\n        if u0 == 0 and abs(t0) < unit['t_off_min_i']:\n            must_off[i] = True\n        \n        # Calculate current output limits\n        if must_run[i] or u0 == 1:\n            p_min_cur[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            p_max_cur[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:\n            p_min_cur[i] = unit['p_min_i']\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate adaptive priorities\n    priorities = []\n    for i, unit in enumerate(units_info):\n        if must_off[i]:\n            continue\n            \n        if must_run[i] or unit['u_i_0'] == 1:\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min_cur[i]\n            ramp_factor = unit['p_up_i'] + unit['p_down_i']\n            priority = marginal_cost / (1 + ramp_factor)\n        else:\n            avg_cost = (unit['s_i'] + unit['b_i'] * p_min_cur[i] + \n                       unit['c_i'] * p_min_cur[i]**2) / p_min_cur[i]\n            ramp_factor = unit['p_up_i']\n            priority = avg_cost / (1 + ramp_factor)\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    # Initial commitment\n    committed = set(np.where(must_run)[0])\n    total_min = sum(p_min_cur[i] for i in committed)\n    total_max = sum(p_max_cur[i] for i in committed)\n    \n    # Add flexible units by priority\n    for _, i in priorities:\n        if i not in committed and not must_off[i]:\n            if total_max < load:\n                committed.add(i)\n                total_min += p_min_cur[i]\n                total_max += p_max_cur[i]\n            else:\n                break\n    \n    # Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Bisection iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units_info[i]\n            p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, p_min_cur[i], p_max_cur[i])\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units_info[i]\n        p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = np.clip(p_i, p_min_cur[i], p_max_cur[i])\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0039112517,
          "gap_price_rate": 0.0117700626,
          "fitness": 0.0078406571
     },
     {
          "name": "refined_commit_units_priority_dispatch",
          "algorithm": "1. Enforce minimum up/down time constraints by identifying must-run and must-off units based on current state and historical parameters\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Sort available units by full incremental cost (including startup costs when applicable)\n4. Perform priority-based commitment using adaptive thresholding to balance load demand and cost efficiency\n5. Execute constrained economic dispatch using iterative lambda adjustment with ramp-aware generation limits\n6. Fine-tune outputs using marginal cost prioritization to exactly match load while respecting all physical constraints\n7. Validate and adjust commitments to ensure minimum generation and ramp constraints are satisfied\n\n",
          "code": "import numpy as np\n\ndef refined_commit_units_priority_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Enforce minimum up/down constraints\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    \n    # Step 2: Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    for i, unit in enumerate(units):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                p_min[i] = unit['p_min_i']\n                p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    # Step 3: Calculate full incremental costs\n    cost_list = []\n    for i, unit in enumerate(units):\n        if i in must_run or i in must_off:\n            continue\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p_min[i]\n        if unit['u_i_0'] == 0:\n            full_cost = marginal_cost + unit['s_i'] / max(p_min[i], 1e-6)\n        else:\n            full_cost = marginal_cost\n        cost_list.append((i, full_cost))\n    \n    # Sort by full incremental cost\n    cost_list.sort(key=lambda x: x[1])\n    \n    # Step 4: Priority-based commitment\n    current_capacity = sum(p_max[i] for i in range(n_units) if u[i] == 1)\n    for i, _ in cost_list:\n        if current_capacity >= load:\n            break\n        if u[i] == 0:\n            u[i] = 1\n            p_min[i] = units[i]['p_min_i']\n            p_max[i] = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            current_capacity += p_max[i]\n    \n    # Step 5: Constrained economic dispatch\n    total_min = sum(p_min[i] for i in range(n_units) if u[i] == 1)\n    total_max = sum(p_max[i] for i in range(n_units) if u[i] == 1)\n    \n    if load < total_min:\n        # Decommit highest cost units\n        committed = [i for i in range(n_units) if u[i] == 1 and i not in must_run]\n        cost_vals = []\n        for i in committed:\n            cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p_min[i]\n            cost_vals.append((i, cost))\n        cost_vals.sort(key=lambda x: -x[1])\n        \n        for i, _ in cost_vals:\n            if total_min <= load:\n                break\n            u[i] = 0\n            p_min[i] = 0\n            p_max[i] = 0\n            total_min -= units[i]['p_min_i']\n    \n    elif load > total_max:\n        # Commit additional units\n        available = [i for i in range(n_units) if u[i] == 0 and i not in must_off]\n        cost_vals = []\n        for i in available:\n            cost = units[i]['b_i'] + 2 * units[i]['c_i'] * units[i]['p_min_i']\n            cost += units[i]['s_i'] / max(units[i]['p_min_i'], 1e-6)\n            cost_vals.append((i, cost))\n        cost_vals.sort(key=lambda x: x[1])\n        \n        for i, _ in cost_vals:\n            if total_max >= load:\n                break\n            u[i] = 1\n            p_min[i] = units[i]['p_min_i']\n            p_max[i] = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            total_max += p_max[i]\n    \n    # Lambda iteration with ramp constraints\n    lambda_low = 0\n    lambda_high = 1000\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    \n    for _ in range(100):  # Iterative lambda adjustment\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for i in committed_idx:\n            p_i = (lambda_mid - units[i]['b_i']) / (2 * units[i]['c_i'])\n            p_i = max(p_min[i], min(p_max[i], p_i))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Fine-tune outputs\n    for i in committed_idx:\n        p[i] = (lambda_mid - units[i]['b_i']) / (2 * units[i]['c_i'])\n        p[i] = max(p_min[i], min(p_max[i], p[i]))\n    \n    # Step 7: Validate and adjust\n    total_output = sum(p)\n    if abs(total_output - load) > 1e-6:\n        # Marginal cost-based adjustment\n        mc = []\n        for i in committed_idx:\n            marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n            mc.append((i, marginal_cost))\n        \n        mc.sort(key=lambda x: x[1] if total_output < load else -x[1])\n        \n        for i, _ in mc:\n            if abs(total_output - load) < 1e-6:\n                break\n            if total_output < load:\n                adjust = min(p_max[i] - p[i], load - total_output)\n                p[i] += adjust\n                total_output += adjust\n            else:\n                adjust = min(p[i] - p_min[i], total_output - load)\n                p[i] -= adjust\n                total_output -= adjust\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.004662822,
          "gap_price_rate": 0.012217254,
          "fitness": 0.008440038
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints.\n2. Compute adaptive priorities considering marginal cost, startup cost, and ramp capabilities.\n3. Commit must-run units and flexible units by adaptive priority until load is met.\n4. Perform economic dispatch using a merit order approach while respecting output and ramp constraints.\n5. Adjust commitments if load is not met or constraints are violated.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost + unit['s_i'] / unit['p_max_i'] if unit['u_i_0'] == 0 else marginal_cost\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    sorted_flexible = [i for _, i in priorities]\n    \n    committed = must_run[:]\n    total_max = sum(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else unit['p_start_i'] for unit in [units_info[i] for i in committed])\n    \n    for i in sorted_flexible:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        committed.append(i)\n        total_max += unit['p_start_i'] if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    L = np.zeros(n_units)\n    U = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            L[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            L[i] = unit['p_min_i']\n            U[i] = unit['p_start_i']\n    \n    for i in committed:\n        p[i] = L[i]\n    \n    remaining = load - np.sum(p)\n    units_to_adjust = [i for i in committed if p[i] < U[i]]\n    \n    while remaining > 0 and units_to_adjust:\n        marginal_costs = []\n        for i in units_to_adjust:\n            unit = units_info[i]\n            marginal_costs.append((unit['b_i'] + 2 * unit['c_i'] * p[i], i))\n        marginal_costs.sort(key=lambda x: x[0])\n        best_unit = marginal_costs[0][1]\n        increase = min(remaining, U[best_unit] - p[best_unit])\n        p[best_unit] += increase\n        remaining -= increase\n        if p[best_unit] >= U[best_unit]:\n            units_to_adjust.remove(best_unit)\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0062422093,
          "gap_price_rate": 0.0107972871,
          "fitness": 0.0085197482
     },
     {
          "name": "commit_units_priority_dispatch",
          "algorithm": "1. Enforce minimum up/down time constraints by forcing units to remain on/off if required\n2. Sort available units by incremental cost (derivative of cost function)\n3. Perform priority-based unit commitment considering startup costs and ramp constraints\n4. Execute economic dispatch using lambda iteration to minimize production costs\n5. Adjust outputs to respect ramp limits and minimum generation constraints\n6. Ensure load balance while respecting all physical constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Enforce minimum up/down time constraints\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Calculate incremental costs for all units\n    incremental_costs = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            current_p = unit['p_i_0']\n        else:\n            current_p = 0\n        inc_cost = 2 * unit['c_i'] * current_p + unit['b_i']\n        incremental_costs.append(inc_cost)\n    \n    # Create priority list based on incremental costs\n    priority_list = sorted(range(n_units), key=lambda i: incremental_costs[i])\n    \n    # Commit units based on priority\n    committed = set(forced_on)\n    total_capacity = 0\n    for i in priority_list:\n        if i in forced_off:\n            continue\n        unit = units_info[i]\n        max_output = min(unit['p_max_i'], \n                        unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i'])\n        if total_capacity + max_output < load and i not in forced_on:\n            committed.add(i)\n            total_capacity += max_output\n        elif i in forced_on:\n            total_capacity += max_output\n    \n    # Economic dispatch using lambda iteration\n    low = min(2*unit['c_i']*unit['p_min_i'] + unit['b_i'] for i in committed for unit in [units_info[i]])\n    high = max(2*unit['c_i']*unit['p_max_i'] + unit['b_i'] for i in committed for unit in [units_info[i]])\n    \n    for _ in range(100):  # Lambda iteration\n        lambda_val = (low + high) / 2\n        total_gen = 0\n        for i in committed:\n            unit = units_info[i]\n            p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            # Apply output constraints\n            p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n            # Apply ramp constraints\n            if unit['u_i_0'] == 1:\n                p = max(unit['p_i_0'] - unit['p_down_i'], \n                       min(unit['p_i_0'] + unit['p_up_i'], p))\n            else:\n                p = min(unit['p_start_i'], p)\n            total_gen += p\n        \n        if abs(total_gen - load) < 1e-3:\n            break\n        elif total_gen < load:\n            low = lambda_val\n        else:\n            high = lambda_val\n    \n    # Final dispatch with constraint enforcement\n    total_gen = 0\n    for i in committed:\n        unit = units_info[i]\n        p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n        if unit['u_i_0'] == 1:\n            p = max(unit['p_i_0'] - unit['p_down_i'], \n                   min(unit['p_i_0'] + unit['p_up_i'], p))\n        else:\n            p = min(unit['p_start_i'], p)\n        schedules[1][i] = p\n        schedules[0][i] = 1\n        total_gen += p\n    \n    # Load balancing adjustment\n    diff = load - total_gen\n    while abs(diff) > 1e-3:\n        adjusted = False\n        for i in committed:\n            unit = units_info[i]\n            if diff > 0:  # Need more power\n                new_p = min(schedules[1][i] + diff, unit['p_max_i'])\n                if unit['u_i_0'] == 1:\n                    new_p = min(new_p, unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    new_p = min(new_p, unit['p_start_i'])\n                if new_p > schedules[1][i]:\n                    diff -= (new_p - schedules[1][i])\n                    schedules[1][i] = new_p\n                    adjusted = True\n            else:  # Need less power\n                new_p = max(schedules[1][i] + diff, unit['p_min_i'])\n                if unit['u_i_0'] == 1:\n                    new_p = max(new_p, unit['p_i_0'] - unit['p_down_i'])\n                if new_p < schedules[1][i]:\n                    diff -= (new_p - schedules[1][i])\n                    schedules[1][i] = new_p\n                    adjusted = True\n        if not adjusted:\n            break\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0051705491,
          "gap_price_rate": 0.0175151129,
          "fitness": 0.011342831
     },
     {
          "name": "rolling_uc_heuristic_improved",
          "algorithm": "1. Classify units into must-on, must-off, and adjustable based on minimum up/down times and shutdown ramp limits, considering current state and historical parameters\n2. Set must-on units to committed state and must-off units to decommitted state\n3. Initialize adjustable units to their previous commitment state\n4. Calculate total minimum and maximum generation capacity considering ramp constraints and startup/shutdown limits\n5. If total minimum generation exceeds load, decommit adjustable units with highest marginal costs until feasible\n6. If total maximum generation is below load, commit adjustable units with lowest full costs (including startup costs) until feasible\n7. Perform economic dispatch using lambda iteration with bisection method to optimize generation levels\n8. Adjust outputs to exactly match load while respecting all physical constraints\n9. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef rolling_uc_heuristic_improved(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    adjustable = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                adjustable[i] = True\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                adjustable[i] = True\n    \n    for i in range(n_units):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    committed = np.where(u == 1)[0]\n    available = np.where(adjustable)[0]\n    \n    total_min = 0\n    total_max = 0\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += low_bound[i]\n        total_max += high_bound[i]\n    \n    if total_min > load:\n        off_candidates = [i for i in available if u[i] == 1]\n        off_candidates.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*low_bound[i], reverse=True)\n        \n        for i in off_candidates:\n            if total_min <= load:\n                break\n            u[i] = 0\n            total_min -= low_bound[i]\n            total_max -= high_bound[i]\n    \n    if total_max < load:\n        on_candidates = [i for i in available if u[i] == 0]\n        on_candidates.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                                         units_info[i]['c_i']*units_info[i]['p_min_i']**2 + units_info[i]['s_i']) / units_info[i]['p_min_i'])\n        \n        for i in on_candidates:\n            unit = units_info[i]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            if total_max + new_high >= load:\n                break\n            u[i] = 1\n            low_bound[i] = new_low\n            high_bound[i] = new_high\n            total_min += new_low\n            total_max += new_high\n    \n    committed = np.where(u == 1)[0]\n    if not committed.size:\n        return np.array([u, p])\n    \n    lambda_low = min(units_info[i]['b_i'] + 2*units_info[i]['c_i']*low_bound[i] for i in committed)\n    lambda_high = max(units_info[i]['b_i'] + 2*units_info[i]['c_i']*high_bound[i] for i in committed)\n    \n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        for i in committed:\n            unit = units_info[i]\n            p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_i = max(low_bound[i], min(high_bound[i], p_i))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p > load:\n            lambda_high = lambda_mid\n        else:\n            lambda_low = lambda_mid\n    \n    for i in committed:\n        unit = units_info[i]\n        p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = max(low_bound[i], min(high_bound[i], p_i))\n    \n    total_p = np.sum(p)\n    residual = load - total_p\n    while abs(residual) > 1e-6:\n        if residual > 0:\n            candidates = [i for i in committed if p[i] < high_bound[i]]\n            if not candidates:\n                break\n            i = min(candidates, key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i])\n            p[i] = min(p[i] + residual, high_bound[i])\n        else:\n            candidates = [i for i in committed if p[i] > low_bound[i]]\n            if not candidates:\n                break\n            i = max(candidates, key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i])\n            p[i] = max(p[i] + residual, low_bound[i])\n        residual = load - np.sum(p)\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0012355582,
          "gap_price_rate": 0.0335082138,
          "fitness": 0.017371886
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": "1. Determine must-run units (online units violating min up-time or shutdown ramp limits) and must-off units (offline units violating min down-time).\n2. Initialize online set with must-run units and previously online units not must-off.\n3. Calculate total min/max output of online set considering ramp limits and startup/shutdown constraints.\n4. If load exceeds total max, start additional cheapest available units (by average cost at minimum power) until load is within capacity.\n5. If load is below total min, shut down most expensive non-must-run units (considering shutdown ramp limits) until load is within capacity.\n6. Perform economic dispatch via bisection method to find optimal lambda for equal marginal cost, enforcing output limits.\n7. Adjust outputs to exactly match load using marginal cost-based prioritization.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    online_units = set()\n    for i in range(n_units):\n        if must_run[i]:\n            online_units.add(i)\n        elif units_info[i]['u_i_0'] == 1 and not must_off[i]:\n            online_units.add(i)\n    \n    L = np.zeros(n_units)\n    U = np.zeros(n_units)\n    for i in online_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            L[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            L[i] = unit['p_min_i']\n            U[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(L[i] for i in online_units)\n    total_max = sum(U[i] for i in online_units)\n    \n    if load > total_max:\n        available_units = [i for i in range(n_units) if i not in online_units and not must_off[i] and not must_run[i]]\n        avg_costs = []\n        for i in available_units:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n            avg_costs.append((i, cost))\n        avg_costs.sort(key=lambda x: x[1])\n        \n        for i, _ in avg_costs:\n            unit = units_info[i]\n            L_i = unit['p_min_i']\n            U_i = min(unit['p_max_i'], unit['p_start_i'])\n            if total_max + U_i >= load:\n                online_units.add(i)\n                L[i] = L_i\n                U[i] = U_i\n                total_min += L_i\n                total_max += U_i\n                break\n            online_units.add(i)\n            L[i] = L_i\n            U[i] = U_i\n            total_min += L_i\n            total_max += U_i\n    \n    if load < total_min:\n        non_must_run = [i for i in online_units if not must_run[i] and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']]\n        avg_costs = []\n        for i in non_must_run:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n            avg_costs.append((i, cost))\n        avg_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in avg_costs:\n            if units_info[i]['u_i_0'] == 1:\n                L_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            else:\n                L_i = units_info[i]['p_min_i']\n            if total_min - L_i <= load:\n                online_units.remove(i)\n                total_min -= L_i\n                if units_info[i]['u_i_0'] == 1:\n                    U_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    U_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                total_max -= U_i\n                if total_min <= load:\n                    break\n    \n    p_outputs = np.zeros(n_units)\n    online_list = list(online_units)\n    if online_list:\n        L_online = [L[i] for i in online_list]\n        U_online = [U[i] for i in online_list]\n        b_online = [units_info[i]['b_i'] for i in online_list]\n        c_online = [units_info[i]['c_i'] for i in online_list]\n        \n        low = min(b_online[j] + 2 * c_online[j] * L_online[j] for j in range(len(online_list)))\n        high = max(b_online[j] + 2 * c_online[j] * U_online[j] for j in range(len(online_list)))\n        \n        tol = 0.01\n        while high - low > tol:\n            mid = (low + high) / 2\n            total_p = 0\n            for j in range(len(online_list)):\n                p_uncon = (mid - b_online[j]) / (2 * c_online[j])\n                p_clip = max(L_online[j], min(U_online[j], p_uncon))\n                total_p += p_clip\n            if total_p < load:\n                low = mid\n            else:\n                high = mid\n        \n        total_p = 0\n        p_vals = []\n        for j in range(len(online_list)):\n            p_uncon = (high - b_online[j]) / (2 * c_online[j])\n            p_clip = max(L_online[j], min(U_online[j], p_uncon))\n            p_vals.append(p_clip)\n            total_p += p_clip\n        \n        disc = load - total_p\n        if disc > 0:\n            candidates = [j for j in range(len(online_list)) if p_vals[j] < U_online[j]]\n            margins = [b_online[j] + 2 * c_online[j] * p_vals[j] for j in candidates]\n            sorted_candidates = [c for _, c in sorted(zip(margins, candidates))]\n            for j in sorted_candidates:\n                addable = U_online[j] - p_vals[j]\n                to_add = min(disc, addable)\n                p_vals[j] += to_add\n                disc -= to_add\n                if disc <= 0:\n                    break\n        else:\n            disc = -disc\n            candidates = [j for j in range(len(online_list)) if p_vals[j] > L_online[j]]\n            margins = [b_online[j] + 2 * c_online[j] * p_vals[j] for j in candidates]\n            sorted_candidates = [c for _, c in sorted(zip(margins, candidates), reverse=True)]\n            for j in sorted_candidates:\n                reducible = p_vals[j] - L_online[j]\n                to_reduce = min(disc, reducible)\n                p_vals[j] -= to_reduce\n                disc -= to_reduce\n                if disc <= 0:\n                    break\n        \n        for idx, i in enumerate(online_list):\n            p_outputs[i] = p_vals[idx]\n    \n    u_outputs = np.zeros(n_units)\n    for i in online_units:\n        u_outputs[i] = 1\n    \n    schedules = np.vstack((u_outputs, p_outputs))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0360461575,
          "fitness": 0.018087918
     },
     {
          "name": "refined_rolling_uc_heuristic",
          "algorithm": "1. Identify must-run units (online units violating min up-time or shutdown ramp limits) and must-off units (offline units violating min down-time)\n2. Initialize committed units with must-run units and previously online units not must-off\n3. Calculate feasible power ranges for committed units considering ramp limits and startup/shutdown constraints\n4. If load exceeds committed capacity, activate additional units sorted by full cost efficiency (startup cost + production cost at minimum output)\n5. If committed minimum output exceeds load, decommit most expensive non-must-run units considering shutdown ramp limits\n6. Perform economic dispatch using iterative lambda optimization with ramp-constrained output limits\n7. Fine-tune outputs using marginal cost prioritization to exactly match load\n8. Validate and enforce all physical constraints before returning schedules\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_uc_heuristic(units_info, load):\n    units = units_info\n    n_units = len(units)\n    committed = np.zeros(n_units, dtype=bool)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    # Determine must-run and must-off units\n    for i, u in enumerate(units):\n        if u['u_i_0'] == 1:  # previously online\n            if u['t_i_0'] < u['t_on_min_i'] or u['p_i_0'] > u['p_shut_i']:\n                must_run[i] = True\n        else:  # previously offline\n            if -u['t_i_0'] < u['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize committed units\n    for i in range(n_units):\n        if must_run[i] or (units[i]['u_i_0'] == 1 and not must_off[i]):\n            committed[i] = True\n    \n    # Calculate feasible power ranges\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    for i, u in enumerate(units):\n        if committed[i]:\n            if u['u_i_0'] == 1:  # previously online\n                p_min[i] = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n                p_max[i] = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n            else:  # newly committed\n                p_min[i] = u['p_min_i']\n                p_max[i] = min(u['p_max_i'], u['p_start_i'])\n        else:\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    total_min = np.sum(p_min[committed])\n    total_max = np.sum(p_max[committed])\n    \n    # Add units if load exceeds capacity\n    available = [i for i in range(n_units) if not committed[i] and not must_off[i]]\n    full_costs = []\n    for i in available:\n        u = units[i]\n        min_cost = u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2 + u['s_i']\n        full_costs.append((min_cost / u['p_min_i'], i))\n    full_costs.sort(key=lambda x: x[0])\n    \n    for cost, i in full_costs:\n        if total_max < load:\n            committed[i] = True\n            u = units[i]\n            p_min[i] = u['p_min_i']\n            p_max[i] = min(u['p_max_i'], u['p_start_i'])\n            total_min += p_min[i]\n            total_max += p_max[i]\n        else:\n            break\n    \n    # Remove units if minimum output exceeds load\n    non_must_run = [i for i in range(n_units) if committed[i] and not must_run[i]]\n    costs = []\n    for i in non_must_run:\n        u = units[i]\n        cost = u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * u['p_min_i']**2\n        costs.append((cost, i))\n    costs.sort(reverse=True, key=lambda x: x[0])\n    \n    for cost, i in costs:\n        if total_min > load and units[i]['p_i_0'] <= units[i]['p_shut_i']:\n            committed[i] = False\n            total_min -= p_min[i]\n            total_max -= p_max[i]\n            p_min[i] = 0\n            p_max[i] = 0\n    \n    # Economic dispatch with bisection\n    lambda_low = 0\n    lambda_high = 1000  # Sufficiently high value\n    p_out = np.zeros(n_units)\n    committed_idx = np.where(committed)[0]\n    \n    for _ in range(100):  # Bisection iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        for i in committed_idx:\n            u = units[i]\n            marginal = lambda_mid - u['b_i']\n            p_ideal = marginal / (2 * u['c_i']) if u['c_i'] > 0 else p_max[i]\n            p_out[i] = np.clip(p_ideal, p_min[i], p_max[i])\n            total_gen += p_out[i]\n        \n        if abs(total_gen - load) < 1e-6:\n            break\n        elif total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Fine-tuning to match load exactly\n    diff = load - total_gen\n    if diff > 0:\n        margins = []\n        for i in committed_idx:\n            if p_out[i] < p_max[i]:\n                margin = units[i]['b_i'] + 2 * units[i]['c_i'] * p_out[i]\n                margins.append((margin, i))\n        margins.sort(key=lambda x: x[0])\n        for margin, i in margins:\n            if diff <= 0:\n                break\n            add = min(diff, p_max[i] - p_out[i])\n            p_out[i] += add\n            diff -= add\n    else:\n        margins = []\n        for i in committed_idx:\n            if p_out[i] > p_min[i]:\n                margin = units[i]['b_i'] + 2 * units[i]['c_i'] * p_out[i]\n                margins.append((margin, i))\n        margins.sort(reverse=True, key=lambda x: x[0])\n        for margin, i in margins:\n            if diff >= 0:\n                break\n            reduce = min(-diff, p_out[i] - p_min[i])\n            p_out[i] -= reduce\n            diff += reduce\n    \n    # Build output array\n    schedules = np.zeros((2, n_units))\n    schedules[0] = committed.astype(float)\n    schedules[1] = p_out\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0360463335,
          "fitness": 0.018088006
     },
     {
          "name": "rolling_uc_heuristic_improved",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints\n2. Set must-run units to committed state and must-off units to decommitted state\n3. Initialize flexible units to previous commitment state\n4. Calculate total minimum and maximum generation capacity considering ramp limits\n5. If load exceeds maximum capacity, commit additional flexible units by ascending full cost (including startup costs)\n6. If load is below minimum capacity, decommit flexible units by descending marginal cost\n7. Perform economic dispatch using lambda iteration with bisection method\n8. Adjust generation outputs to exactly match load while respecting all constraints\n\n",
          "code": "import numpy as np\n\ndef rolling_uc_heuristic_improved(units_info, load):\n    # Initialize arrays\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute parameters\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    full_cost = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible output ranges\n        if unit['u_i_0'] == 1:  # Previously online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Calculate cost characteristics\n        marginal_cost[i] = unit['b_i'] + 2 * unit['c_i'] * min_p[i]\n        full_cost[i] = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                       unit['c_i'] * min_p[i]**2 + unit['s_i']) / min_p[i]\n    \n    # Classify units\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        elif (unit['u_i_0'] == 0 and \n              -unit['t_i_0'] < unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Set initial commitment\n    for i in must_run:\n        u[i] = 1\n        p[i] = min_p[i]\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    for i in flexible:\n        u[i] = units_info[i]['u_i_0']\n        p[i] = min_p[i] if u[i] == 1 else 0\n    \n    # Adjust commitment based on load\n    total_min = sum(min_p[i] for i in must_run) + sum(min_p[i] for i in flexible if u[i] == 1)\n    total_max = sum(max_p[i] for i in must_run) + sum(max_p[i] for i in flexible if u[i] == 1)\n    \n    # Commit additional units if needed\n    if total_max < load:\n        # Sort flexible offline units by full cost\n        candidates = [i for i in flexible if u[i] == 0]\n        candidates.sort(key=lambda i: full_cost[i])\n        \n        for i in candidates:\n            if total_max >= load:\n                break\n            u[i] = 1\n            p[i] = min_p[i]\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Decommit units if needed\n    if total_min > load:\n        # Sort flexible online units by marginal cost (descending)\n        candidates = [i for i in flexible if u[i] == 1]\n        candidates.sort(key=lambda i: marginal_cost[i], reverse=True)\n        \n        for i in candidates:\n            if total_min <= load:\n                break\n            u[i] = 0\n            p[i] = 0\n            total_min -= min_p[i]\n            total_max -= max_p[i]\n    \n    # Economic dispatch using lambda iteration\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    if not committed_idx:\n        return np.array([u, p])\n    \n    # Bisection parameters\n    lambda_low = min(marginal_cost[i] for i in committed_idx)\n    lambda_high = max(marginal_cost[i] for i in committed_idx)\n    tolerance = 1e-6\n    max_iter = 100\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        \n        for i in committed_idx:\n            unit = units_info[i]\n            # Calculate unconstrained output\n            p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            # Constrain by limits\n            p_i = np.clip(p_i, min_p[i], max_p[i])\n            total_gen += p_i\n        \n        if abs(total_gen - load) < tolerance:\n            break\n        elif total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed_idx:\n        unit = units_info[i]\n        p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = np.clip(p_i, min_p[i], max_p[i])\n    \n    # Adjust for exact load matching\n    total_gen = sum(p)\n    mismatch = load - total_gen\n    \n    if abs(mismatch) > tolerance:\n        # Sort units by marginal cost\n        if mismatch > 0:\n            # Need more power - use units with lowest marginal cost\n            candidates = sorted(committed_idx, key=lambda i: marginal_cost[i])\n            for i in candidates:\n                if p[i] < max_p[i]:\n                    add = min(mismatch, max_p[i] - p[i])\n                    p[i] += add\n                    mismatch -= add\n                    if mismatch <= 0:\n                        break\n        else:\n            # Need less power - use units with highest marginal cost\n            candidates = sorted(committed_idx, key=lambda i: marginal_cost[i], reverse=True)\n            for i in candidates:\n                if p[i] > min_p[i]:\n                    reduce = min(-mismatch, p[i] - min_p[i])\n                    p[i] -= reduce\n                    mismatch += reduce\n                    if mismatch >= 0:\n                        break\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001296785,
          "gap_price_rate": 0.0361900801,
          "fitness": 0.0181598793
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and adjustable based on minimum up/down times and shutdown ramp limits.\n2. Set must-on units to committed state and must-off units to decommitted state.\n3. Initialize adjustable units to their previous commitment state.\n4. If total minimum generation exceeds load, decommit adjustable units with highest operating costs until feasible.\n5. If total maximum generation is below load, commit adjustable units with lowest full costs until feasible.\n6. Perform economic dispatch using a merit order approach based on marginal costs, respecting output limits and ramp constraints.\n7. Adjust generation levels iteratively to meet load while satisfying all constraints.\n\n",
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    adjustable = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                adjustable.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                adjustable.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in adjustable:\n        u[i] = units_info[i]['u_i_0']\n    \n    total_min = 0\n    total_max = 0\n    for i in range(n_units):\n        if u[i] == 1:\n            total_min += units_info[i]['p_min_i']\n            total_max += units_info[i]['p_max_i']\n    \n    if total_min > load:\n        adj_on = [i for i in adjustable if u[i] == 1]\n        costs = []\n        for i in adj_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n            costs.append((cost, i))\n        costs.sort(reverse=True, key=lambda x: x[0])\n        \n        for cost, i in costs:\n            if total_min <= load:\n                break\n            u[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= units_info[i]['p_max_i']\n    \n    if total_max < load:\n        adj_off = [i for i in adjustable if u[i] == 0]\n        full_costs = []\n        for i in adj_off:\n            unit = units_info[i]\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2 + unit['s_i']) / unit['p_min_i']\n            full_costs.append((avg_cost, i))\n        full_costs.sort(key=lambda x: x[0])\n        \n        for cost, i in full_costs:\n            if total_max >= load:\n                break\n            u[i] = 1\n            total_min += units_info[i]['p_min_i']\n            total_max += units_info[i]['p_max_i']\n    \n    committed = [i for i in range(n_units) if u[i] == 1]\n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    \n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[i] = unit['p_min_i']\n            ub[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in committed:\n        p[i] = lb[i]\n    \n    total_gen = np.sum(p)\n    remaining = load - total_gen\n    \n    while abs(remaining) > 1e-6:\n        if remaining > 0:\n            marginal_costs = []\n            for i in committed:\n                if p[i] < ub[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(key=lambda x: x[0])\n            i = marginal_costs[0][1]\n            add = min(ub[i] - p[i], remaining)\n            p[i] += add\n            remaining -= add\n        else:\n            marginal_costs = []\n            for i in committed:\n                if p[i] > lb[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(reverse=True, key=lambda x: x[0])\n            i = marginal_costs[0][1]\n            reduce = min(p[i] - lb[i], -remaining)\n            p[i] -= reduce\n            remaining += reduce\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0231401898,
          "gap_price_rate": 0.0138037235,
          "fitness": 0.0184719567
     }
]