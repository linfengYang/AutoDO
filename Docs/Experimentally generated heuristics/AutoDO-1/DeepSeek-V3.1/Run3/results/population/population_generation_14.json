[
     {
          "name": "refined_enhanced_adaptive_priority_dispatch",
          "algorithm": "1. Enhanced unit classification considering startup/shutdown ramp constraints and extended must-run conditions\n2. Dynamic feasible power range calculation with improved ramp rate handling\n3. Adaptive priority computation with amortized startup costs and ramp flexibility factors\n4. Bisection-based economic dispatch with enhanced lambda convergence\n5. Precision adjustment using marginal cost sorting with constraint-aware corrections\n6. Comprehensive validation with iterative repair for constraint violations\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_adaptive_priority_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Enhanced unit classification\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        # Extended must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        # Enhanced must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              unit['t_i_0'] > -unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Step 2: Dynamic feasible power range calculation\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        if i in must_run:\n            if unit['u_i_0'] == 0:  # Starting up\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Already online\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in must_off:\n            min_p[i] = 0\n            max_p[i] = 0\n        else:  # Flexible units\n            if unit['u_i_0'] == 1:\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3: Commit must-run units and compute adaptive priorities\n    committed = set(must_run)\n    total_min = sum(min_p[i] for i in committed)\n    total_max = sum(max_p[i] for i in committed)\n    \n    # Calculate adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        unit = units[i]\n        if unit['u_i_0'] == 0:\n            # Amortize startup cost over minimum uptime\n            amortized_cost = unit['s_i'] / max(1, unit['t_on_min_i'])\n            full_cost = (amortized_cost + unit['a_i'] + \n                         unit['b_i'] * min_p[i] + \n                         unit['c_i'] * min_p[i]**2)\n            # Add ramp flexibility factor\n            ramp_factor = 1 + (unit['p_up_i'] / unit['p_max_i'])\n            priority = full_cost * ramp_factor / min_p[i] if min_p[i] > 0 else float('inf')\n        else:\n            # Use marginal cost for already online units\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p[i]\n            ramp_factor = 1 + (unit['p_up_i'] / unit['p_max_i'])\n            priority = marginal_cost * ramp_factor\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            break\n    \n    # Step 5: Enhanced bisection economic dispatch\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else max_p[i]\n            # Constrain by feasible range\n            p[i] = np.clip(p_uncon, min_p[i], max_p[i])\n            total_gen += p[i]\n        \n        if abs(total_gen - load) < 1e-6:\n            break\n        elif total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Precision adjustment with marginal cost sorting\n    current_gen = sum(p[i] for i in committed)\n    deficit = load - current_gen\n    \n    if abs(deficit) > 1e-6:\n        # Create list of adjustable units with marginal costs\n        adjustable = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            adjustable.append((marginal_cost, i))\n        \n        adjustable.sort(key=lambda x: x[0], reverse=deficit < 0)\n        \n        # Adjust outputs\n        for mc, i in adjustable:\n            if deficit > 0:  # Need more generation\n                add_capacity = min(deficit, max_p[i] - p[i])\n                p[i] += add_capacity\n                deficit -= add_capacity\n            else:  # Need less generation\n                reduce_capacity = min(-deficit, p[i] - min_p[i])\n                p[i] -= reduce_capacity\n                deficit += reduce_capacity\n            \n            if abs(deficit) < 1e-6:\n                break\n    \n    # Step 7: Final validation and constraint enforcement\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0043993514,
          "gap_price_rate": 0.0091072805,
          "fitness": 0.0067533159
     },
     {
          "name": "enhanced_adaptive_priority_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Step 1: Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power range considering ramp constraints\n        if unit['u_i_0'] == 1:  # Previously on\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check minimum up time constraint\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously off\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            # Check minimum down time constraint\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = p_min\n        feasible_max[i] = p_max\n    \n    # Step 2: Commit must-run units\n    committed = set(must_run)\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        schedules[0][i] = 1\n        schedules[1][i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    # Step 3: Compute adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        if units_info[i]['u_i_0'] == 0:\n            # Include startup cost if unit was off\n            full_cost = (units_info[i]['s_i'] + \n                         units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        else:\n            full_cost = (units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        \n        # Adjust priority based on ramp capabilities\n        ramp_factor = (feasible_max[i] - feasible_min[i]) / max(1, units_info[i]['p_up_i'])\n        priority = full_cost / (feasible_min[i] + 1e-6) * (1 - 0.1 * ramp_factor)\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            schedules[0][i] = 1\n            schedules[1][i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Step 5: Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units_info[i]\n            # Calculate unconstrained output\n            p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n            # Constrain within feasible range\n            p_dispatch = max(feasible_min[i], min(feasible_max[i], p_star))\n            total_power += p_dispatch\n        \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final dispatch values\n    for i in committed:\n        unit = units_info[i]\n        p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n        schedules[1][i] = max(feasible_min[i], min(feasible_max[i], p_star))\n    \n    # Step 6: Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    while abs(diff) > 1e-6:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed:\n            if diff > 0 and schedules[1][i] < feasible_max[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n            elif diff < 0 and schedules[1][i] > feasible_min[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost (ascending for increasing, descending for decreasing)\n        adjustable.sort(key=lambda x: x[0], reverse=diff < 0)\n        \n        # Adjust the most suitable unit\n        i = adjustable[0][1]\n        if diff > 0:\n            adjust = min(diff, feasible_max[i] - schedules[1][i])\n        else:\n            adjust = max(diff, feasible_min[i] - schedules[1][i])\n        \n        schedules[1][i] += adjust\n        diff -= adjust\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0087069616,
          "fitness": 0.0070677491
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units using adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check minimum up/down time constraints\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate feasible output range\n        if u_i0 == 1:\n            p_min = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n        unit['p_min_feas'] = p_min\n        unit['p_max_feas'] = p_max\n\n    # Commit must-run units\n    total_min = 0\n    total_max = 0\n    committed = set(must_run)\n    \n    for i in must_run:\n        unit = units[i]\n        schedules[0, i] = 1\n        schedules[1, i] = unit['p_min_feas']\n        total_min += unit['p_min_feas']\n        total_max += unit['p_max_feas']\n        \n    # Commit flexible units if needed\n    if total_min > load:\n        # Decommit most expensive flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_feas']\n            flexible_costs.append((i, marginal_cost))\n        \n        flexible_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in flexible_costs:\n            if total_min <= load:\n                break\n            unit = units[i]\n            total_min -= unit['p_min_feas']\n            total_max -= unit['p_max_feas']\n            committed.discard(i)\n            \n    elif total_max < load:\n        # Commit additional flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            full_cost = (unit['s_i'] if unit['u_i_0'] == 0 else 0) + \\\n                       unit['a_i'] + unit['b_i'] * unit['p_min_feas'] + \\\n                       unit['c_i'] * unit['p_min_feas'] ** 2\n            cost_per_mw = full_cost / unit['p_min_feas']\n            flexible_costs.append((i, cost_per_mw))\n        \n        flexible_costs.sort(key=lambda x: x[1])\n        \n        for i, _ in flexible_costs:\n            if total_max >= load:\n                break\n            unit = units[i]\n            committed.add(i)\n            total_min += unit['p_min_feas']\n            total_max += unit['p_max_feas']\n\n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # Sufficiently high value\n    \n    for _ in range(100):  # Iteration limit\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units[i]\n            p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_dispatch = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n            total_power += p_dispatch\n            \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n\n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        schedules[0, i] = 1\n        schedules[1, i] = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n\n    # Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    if diff != 0:\n        # Create priority list based on marginal cost\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((i, mc))\n        \n        if diff > 0:\n            marginal_costs.sort(key=lambda x: x[1])\n        else:\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            \n        for i, _ in marginal_costs:\n            if abs(diff) < 1e-6:\n                break\n            unit = units[i]\n            current_p = schedules[1, i]\n            if diff > 0:\n                new_p = min(current_p + diff, unit['p_max_feas'])\n            else:\n                new_p = max(current_p + diff, unit['p_min_feas'])\n            diff -= (new_p - current_p)\n            schedules[1, i] = new_p\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0087811081,
          "fitness": 0.0071048223
     },
     {
          "name": "improved_commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units by adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef improved_commit_units_heuristic(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Calculate feasible power range\n        if unit['u_i_0'] == 1:  # previously online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check if must-run due to min up-time or shutdown ramp\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # previously offline\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            # Check if must-off due to min down-time\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = min_p\n        feasible_max[i] = max_p\n    \n    # Commit must-run units\n    committed = set(must_run)\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]  # start at minimum\n    \n    # Calculate current total generation\n    total_gen = np.sum(p)\n    total_max = np.sum([feasible_max[i] for i in committed])\n    total_min = np.sum([feasible_min[i] for i in committed])\n    \n    # Commit flexible units if needed\n    if total_max < load:\n        # Calculate full cost for flexible units\n        costs = []\n        for i in flexible:\n            if i in must_off:\n                continue\n            min_cost = (units[i]['a_i'] + units[i]['b_i'] * feasible_min[i] + \n                        units[i]['c_i'] * feasible_min[i]**2)\n            full_cost = min_cost + units[i]['s_i'] if units[i]['u_i_0'] == 0 else min_cost\n            costs.append((full_cost / feasible_min[i], i))\n        \n        # Sort by cost per MW\n        costs.sort(key=lambda x: x[0])\n        \n        # Commit units until load can be met\n        for _, i in costs:\n            if total_max >= load:\n                break\n            if i not in committed:\n                committed.add(i)\n                u[i] = 1\n                p[i] = feasible_min[i]\n                total_max += feasible_max[i]\n                total_min += feasible_min[i]\n    \n    # Decommit units if minimum generation exceeds load\n    if total_min > load:\n        # Sort committed units by marginal cost at minimum output\n        costs = []\n        for i in committed:\n            if i in must_run:\n                continue\n            marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * feasible_min[i]\n            costs.append((marg_cost, i))\n        \n        costs.sort(reverse=True, key=lambda x: x[0])\n        \n        # Decommit units until feasible\n        for _, i in costs:\n            if total_min <= load:\n                break\n            committed.discard(i)\n            u[i] = 0\n            p[i] = 0\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n    \n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # sufficiently high value\n    \n    for _ in range(100):  # 100 iterations for convergence\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            # Constrain output\n            p_i = max(feasible_min[i], min(feasible_max[i], p_uncon))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = max(feasible_min[i], min(feasible_max[i], p_uncon))\n    \n    # Adjust to exactly match load\n    total_p = np.sum(p)\n    diff = load - total_p\n    \n    while abs(diff) > 1e-5:\n        # Find unit to adjust\n        if diff > 0:\n            # Increase output of unit with lowest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = min(feasible_max[i], p[i] + min(diff, feasible_max[i] - p[i]))\n        else:\n            # Decrease output of unit with highest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(reverse=True, key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = max(feasible_min[i], p[i] + max(diff, feasible_min[i] - p[i]))\n        \n        total_p = np.sum(p)\n        diff = load - total_p\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0087811083,
          "fitness": 0.007104823
     },
     {
          "name": "enhanced_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate dynamic feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output\n4. If needed, activate flexible units using adaptive full-cost priority considering amortized startup costs\n5. Perform bisection-based economic dispatch with ramp-aware lambda convergence\n6. Adjust outputs using marginal cost sorting for exact load matching\n7. Validate and repair constraint violations through iterative correction\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch(units_info, load):\n    n = len(units_info)\n    schedules = np.zeros((2, n))\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    p_min_arr = np.zeros(n)\n    p_max_arr = np.zeros(n)\n    total_min = 0\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p_min_arr[i] = p_min\n        p_max_arr[i] = p_max\n        schedules[0, i] = 1\n        schedules[1, i] = p_min\n        total_min += p_min\n    \n    if total_min > load:\n        return schedules\n    \n    total_max = sum(p_max_arr[i] for i in must_run)\n    cost_list = []\n    \n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        else:\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        cost_list.append((i, cost))\n    \n    cost_list.sort(key=lambda x: x[1])\n    \n    for i, _ in cost_list:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        p_min_arr[i] = p_min\n        p_max_arr[i] = p_max\n        schedules[0, i] = 1\n        schedules[1, i] = p_min\n        total_max += p_max\n    \n    committed = must_run + [i for i, _ in cost_list if schedules[0, i] == 1]\n    b = np.array([units_info[i]['b_i'] for i in committed])\n    c = np.array([units_info[i]['c_i'] for i in committed])\n    p_min_c = p_min_arr[committed]\n    p_max_c = p_max_arr[committed]\n    \n    total_min_c = p_min_c.sum()\n    total_max_c = p_max_c.sum()\n    \n    if load <= total_min_c:\n        for i in committed:\n            schedules[1, i] = p_min_arr[i]\n    elif load >= total_max_c:\n        for i in committed:\n            schedules[1, i] = p_max_arr[i]\n    else:\n        l_low = min(2 * c * p_min_c + b)\n        l_high = max(2 * c * p_max_c + b)\n        tol = 1e-6\n        \n        while l_high - l_low > tol:\n            l_mid = (l_low + l_high) / 2\n            p = np.clip((l_mid - b) / (2 * c), p_min_c, p_max_c)\n            if p.sum() < load:\n                l_low = l_mid\n            else:\n                l_high = l_mid\n        \n        p_final = np.clip((l_low - b) / (2 * c), p_min_c, p_max_c)\n        for idx, i in enumerate(committed):\n            schedules[1, i] = p_final[idx]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285796,
          "gap_price_rate": 0.0087810783,
          "fitness": 0.0071048289
     },
     {
          "name": "enhanced_refined_adaptive_priority_dispatch",
          "algorithm": "1. Enhanced unit classification with extended must-run conditions considering shutdown ramp constraints, minimum up/down times, and current state transitions\n2. Dynamic feasible power range calculation with improved handling of startup/shutdown ramp limits and current state transitions\n3. Adaptive priority computation using amortized startup costs over minimum up-time and ramp flexibility factors\n4. Bisection-based economic dispatch with ramp-aware lambda convergence and marginal cost sorting\n5. Precision adjustment with constraint-aware corrections for exact load matching\n6. Comprehensive validation against all physical constraints with iterative repair mechanisms\n",
          "code": "import numpy as np\n\ndef enhanced_refined_adaptive_priority_dispatch(units_info, load):\n    units = units_info\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Enhanced unit classification\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units):\n        # Must-run conditions\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Step 2: Calculate dynamic feasible power ranges\n    p_min_feasible = np.zeros(n_units)\n    p_max_feasible = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        if must_run[i] or (flexible[i] and unit['u_i_0'] == 1):\n            p_min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif flexible[i] and unit['u_i_0'] == 0:\n            p_min_feasible[i] = unit['p_min_i']\n            p_max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min_feasible[i] = 0\n            p_max_feasible[i] = 0\n    \n    # Commit must-run units\n    committed = np.copy(must_run)\n    p[committed] = p_min_feasible[committed]\n    u[committed] = 1\n    \n    total_min = np.sum(p_min_feasible[committed])\n    total_max = np.sum(p_max_feasible[committed])\n    \n    # Step 3: Compute adaptive priorities for flexible units\n    priorities = np.full(n_units, np.inf)\n    for i in range(n_units):\n        if flexible[i]:\n            if units[i]['u_i_0'] == 0:\n                amortized_startup = units[i]['s_i'] / units[i]['t_on_min_i']\n                cost = amortized_startup + units[i]['a_i'] + units[i]['b_i'] * p_min_feasible[i] + units[i]['c_i'] * p_min_feasible[i]**2\n            else:\n                cost = units[i]['a_i'] + units[i]['b_i'] * p_min_feasible[i] + units[i]['c_i'] * p_min_feasible[i]**2\n            priorities[i] = cost / p_min_feasible[i] if p_min_feasible[i] > 0 else np.inf\n    \n    # Commit flexible units by priority\n    flexible_indices = np.where(flexible)[0]\n    priority_order = np.argsort(priorities[flexible_indices])\n    \n    for idx in priority_order:\n        i = flexible_indices[idx]\n        if total_min <= load and total_max < load:\n            committed[i] = True\n            u[i] = 1\n            p[i] = p_min_feasible[i]\n            total_min += p_min_feasible[i]\n            total_max += p_max_feasible[i]\n        else:\n            break\n    \n    # Step 4: Economic dispatch using bisection method\n    committed_idx = np.where(committed)[0]\n    lambda_low = 0\n    lambda_high = 0\n    for i in committed_idx:\n        marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p_max_feasible[i]\n        if marginal_cost > lambda_high:\n            lambda_high = marginal_cost\n    \n    tolerance = 1e-6\n    max_iter = 1000\n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        for i in committed_idx:\n            p_i = (lambda_mid - units[i]['b_i']) / (2 * units[i]['c_i'])\n            p_i = np.clip(p_i, p_min_feasible[i], p_max_feasible[i])\n            total_power += p_i\n        \n        if abs(total_power - load) < tolerance:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set dispatch values\n    for i in committed_idx:\n        p[i] = (lambda_mid - units[i]['b_i']) / (2 * units[i]['c_i'])\n        p[i] = np.clip(p[i], p_min_feasible[i], p_max_feasible[i])\n    \n    # Step 5: Precision adjustment\n    total_power = np.sum(p)\n    residual = load - total_power\n    if abs(residual) > tolerance:\n        marginal_costs = []\n        for i in committed_idx:\n            if residual > 0 and p[i] < p_max_feasible[i]:\n                marginal_costs.append((units[i]['b_i'] + 2 * units[i]['c_i'] * p[i], i))\n            elif residual < 0 and p[i] > p_min_feasible[i]:\n                marginal_costs.append((units[i]['b_i'] + 2 * units[i]['c_i'] * p[i], i))\n        \n        marginal_costs.sort(key=lambda x: x[0], reverse=residual<0)\n        \n        for mc, i in marginal_costs:\n            if abs(residual) < tolerance:\n                break\n            if residual > 0:\n                adjust = min(residual, p_max_feasible[i] - p[i])\n            else:\n                adjust = max(residual, p_min_feasible[i] - p[i])\n            p[i] += adjust\n            residual -= adjust\n    \n    # Step 6: Validation and constraint repair\n    for i in committed_idx:\n        # Ramp constraint validation\n        if units[i]['u_i_0'] == 1:\n            if p[i] - units[i]['p_i_0'] > units[i]['p_up_i']:\n                p[i] = units[i]['p_i_0'] + units[i]['p_up_i']\n            elif units[i]['p_i_0'] - p[i] > units[i]['p_down_i']:\n                p[i] = units[i]['p_i_0'] - units[i]['p_down_i']\n        # Ensure within absolute limits\n        p[i] = np.clip(p[i], units[i]['p_min_i'], units[i]['p_max_i'])\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055425106,
          "gap_price_rate": 0.0089835113,
          "fitness": 0.007263011
     },
     {
          "name": "refined_commit_units_heuristic",
          "algorithm": "1. Enhanced unit classification with extended must-run conditions considering shutdown ramp constraints, minimum up/down times, and current state transitions\n2. Dynamic feasible power range calculation with improved handling of startup/shutdown ramp limits and current state transitions\n3. Adaptive priority computation using amortized startup costs over minimum up-time and ramp flexibility factors\n4. Bisection-based economic dispatch with ramp-aware lambda convergence and marginal cost sorting\n5. Precision adjustment with constraint-aware corrections for exact load matching\n6. Comprehensive validation against all physical constraints with iterative repair mechanisms\n\n",
          "code": "import numpy as np\n\ndef refined_commit_units_heuristic(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Step 1: Enhanced unit classification\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_run.append(i)\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Step 2: Dynamic feasible power range calculation\n    p_min = np.zeros(n_units)\n    p_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        if i in must_off:\n            p_min[i] = 0\n            p_max[i] = 0\n            continue\n            \n        if unit['u_i_0'] == 1:\n            p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min[i] = unit['p_min_i']\n            p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize commitments\n    committed = set(must_run)\n    total_min = sum(p_min[i] for i in committed)\n    total_max = sum(p_max[i] for i in committed)\n    \n    # Step 3: Adaptive priority commitment\n    if total_max < load:\n        # Calculate priorities for flexible units\n        priorities = []\n        for i in flexible:\n            unit = units[i]\n            amortized_startup = unit['s_i'] / unit['t_on_min_i']\n            ramp_flexibility = (p_max[i] - p_min[i]) / unit['p_max_i']\n            priority = (amortized_startup + unit['b_i'] * p_min[i] + unit['c_i'] * p_min[i]**2) / p_min[i]\n            priority /= (1 + ramp_flexibility)  # Reward flexibility\n            priorities.append((priority, i))\n        \n        priorities.sort()\n        \n        for _, i in priorities:\n            if total_max >= load:\n                break\n            committed.add(i)\n            total_min += p_min[i]\n            total_max += p_max[i]\n    \n    # Step 4: Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    p_alloc = np.zeros(n_units)\n    for i in committed:\n        p_alloc[i] = p_min[i]\n    \n    # Bisection method\n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units[i]\n            p_val = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_alloc[i] = np.clip(p_val, p_min[i], p_max[i])\n            total_p += p_alloc[i]\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 5: Precision adjustment\n    total_p = sum(p_alloc[i] for i in committed)\n    mismatch = load - total_p\n    \n    if abs(mismatch) > 1e-6:\n        # Create adjustment list with marginal costs\n        adj_list = []\n        for i in committed:\n            marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p_alloc[i]\n            adj_list.append((marginal_cost, i))\n        \n        adj_list.sort(reverse=mismatch < 0)\n        \n        for cost, i in adj_list:\n            if mismatch > 0 and p_alloc[i] < p_max[i]:\n                add_amount = min(mismatch, p_max[i] - p_alloc[i])\n                p_alloc[i] += add_amount\n                mismatch -= add_amount\n            elif mismatch < 0 and p_alloc[i] > p_min[i]:\n                sub_amount = min(-mismatch, p_alloc[i] - p_min[i])\n                p_alloc[i] -= sub_amount\n                mismatch += sub_amount\n            \n            if abs(mismatch) < 1e-6:\n                break\n    \n    # Step 6: Validation and repair\n    for i in committed:\n        unit = units[i]\n        # Ramp constraint validation\n        if unit['u_i_0'] == 1:\n            ramp_limit = unit['p_up_i'] if p_alloc[i] > unit['p_i_0'] else unit['p_down_i']\n            if abs(p_alloc[i] - unit['p_i_0']) > ramp_limit:\n                p_alloc[i] = unit['p_i_0'] + np.sign(p_alloc[i] - unit['p_i_0']) * ramp_limit\n    \n    # Ensure load matching after repair\n    total_p = sum(p_alloc)\n    if abs(total_p - load) > 1e-6:\n        # Redistribute mismatch proportionally\n        for i in committed:\n            p_alloc[i] += (load - total_p) * p_alloc[i] / total_p\n            p_alloc[i] = np.clip(p_alloc[i], p_min[i], p_max[i])\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if i in committed else 0\n        schedules[1, i] = p_alloc[i] if i in committed else 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054190663,
          "gap_price_rate": 0.0091753332,
          "fitness": 0.0072971998
     },
     {
          "name": "refined_adaptive_priority_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(p_max_i, p_start_i)\n    \n    committed = must_run.copy()\n    total_min = sum(feasible_min[i] for i in committed)\n    total_max = sum(feasible_max[i] for i in committed)\n    \n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        if units_info[i]['u_i_0'] == 0:\n            min_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * feasible_min[i] + \n                       unit['c_i'] * feasible_min[i] ** 2)\n            priority = min_cost / feasible_min[i]\n        else:\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, i in priorities:\n        if total_max < load:\n            committed.append(i)\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    committed_set = set(committed)\n    low_lambda = 0\n    high_lambda = 0\n    for i in committed:\n        unit = units_info[i]\n        inc_cost_min = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        inc_cost_max = unit['b_i'] + 2 * unit['c_i'] * feasible_max[i]\n        low_lambda = min(low_lambda, inc_cost_min)\n        high_lambda = max(high_lambda, inc_cost_max)\n    \n    tol = 1e-6\n    max_iter = 100\n    for _ in range(max_iter):\n        lambda_val = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for i in committed:\n            unit = units_info[i]\n            p_i = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, feasible_min[i], feasible_max[i])\n            p[i] = p_i\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        elif total_p < load:\n            low_lambda = lambda_val\n        else:\n            high_lambda = lambda_val\n    \n    total_p = sum(p[i] for i in committed)\n    if total_p > load:\n        sorted_units = sorted(committed, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n        for i in sorted_units:\n            reduction = min(total_p - load, p[i] - feasible_min[i])\n            p[i] -= reduction\n            total_p -= reduction\n            if abs(total_p - load) < tol:\n                break\n    elif total_p < load:\n        sorted_units = sorted(committed, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n        for i in sorted_units:\n            addition = min(load - total_p, feasible_max[i] - p[i])\n            p[i] += addition\n            total_p += addition\n            if abs(total_p - load) < tol:\n                break\n    \n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0092644293,
          "fitness": 0.0073464829
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If must-run units can meet load, perform economic dispatch only on must-run units\n4. Otherwise, activate additional units based on cost efficiency considering startup costs\n5. Perform constrained economic dispatch on committed units to match load exactly\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    committed = [False] * num_units\n    p_outputs = [0.0] * num_units\n    \n    # Identify must-run units\n    must_run = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                committed[i] = True\n                # Set initial output considering ramp down limit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_outputs[i] = p_min\n    \n    # Calculate available capacity from must-run units\n    must_run_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_capacity += p_max\n    \n    # Activate additional units if needed\n    if must_run_capacity < load:\n        # Create candidate list of non-committed units that can be activated\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                if unit['u_i_0'] == 0 and abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    # Calculate effective cost per MW\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']\n                    cost_per_mw = min_cost / unit['p_min_i']\n                    candidates.append((cost_per_mw, i))\n                elif unit['u_i_0'] == 1:\n                    # Already on but not must-run - use marginal cost\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n                    candidates.append((marginal_cost, i))\n        \n        # Sort candidates by cost\n        candidates.sort(key=lambda x: x[0])\n        \n        # Activate cheapest units until we can meet load\n        for cost, idx in candidates:\n            if must_run_capacity >= load:\n                break\n            unit = units_info[idx]\n            committed[idx] = True\n            if unit['u_i_0'] == 0:\n                # Starting up - respect startup ramp\n                p_outputs[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                # Already on - respect ramp up\n                p_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_run_capacity += p_outputs[idx]\n    \n    # Perform economic dispatch to match load exactly\n    total_output = sum(p_outputs)\n    remaining_load = load - total_output\n    \n    # Adjust outputs while respecting constraints\n    while abs(remaining_load) > 1e-6:\n        # Find unit with minimum marginal cost for increase or maximum for decrease\n        best_unit = None\n        best_cost = float('inf') if remaining_load > 0 else float('-inf')\n        \n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                continue\n                \n            current_p = p_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0:  # Need to increase output\n                # Check ramp up and max limits\n                max_p = unit['p_max_i']\n                if unit['u_i_0'] == 1:\n                    max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n                elif unit['u_i_0'] == 0 and committed[i]:\n                    max_p = min(max_p, unit['p_start_i'])\n                \n                if current_p < max_p and marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n            else:  # Need to decrease output\n                # Check ramp down and min limits\n                min_p = unit['p_min_i']\n                if unit['u_i_0'] == 1:\n                    min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                \n                if current_p > min_p and marginal_cost > best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = p_outputs[best_unit]\n        \n        if remaining_load > 0:\n            max_p = unit['p_max_i']\n            if unit['u_i_0'] == 1:\n                max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n            elif unit['u_i_0'] == 0:\n                max_p = min(max_p, unit['p_start_i'])\n            \n            adjustment = min(remaining_load, max_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n        else:\n            min_p = unit['p_min_i']\n            if unit['u_i_0'] == 1:\n                min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n            \n            adjustment = max(remaining_load, min_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n    \n    # Prepare output\n    for i in range(num_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0055684358,
          "gap_price_rate": 0.0091494698,
          "fitness": 0.0073589528
     },
     {
          "name": "refined_adaptive_commitment_dispatch",
          "algorithm": "1. Enhanced unit classification with extended must-run conditions considering shutdown ramp constraints and minimum up/down times\n2. Dynamic feasible power range calculation with improved handling of startup/shutdown ramp limits and current state transitions\n3. Adaptive priority computation using amortized startup costs over minimum up-time and ramp flexibility factors\n4. Bisection-based economic dispatch with ramp-aware lambda convergence and marginal cost sorting\n5. Precision adjustment with constraint-aware corrections for exact load matching\n6. Comprehensive validation against all physical constraints with iterative repair mechanisms\n",
          "code": "import numpy as np\n\ndef refined_adaptive_commitment_dispatch(units_info, load):\n    # Initialize units\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Enhanced unit classification\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if t0[i] < min_up[i] or p0[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if t0[i] > -min_down[i]:\n                must_off[i] = True\n    \n    # Step 2: Calculate dynamic feasible power ranges\n    p_low = np.zeros(n_units)\n    p_high = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            p_low[i] = max(p_min[i], p0[i] - p_down[i])\n            p_high[i] = min(p_max[i], p0[i] + p_up[i])\n        else:\n            p_low[i] = p_min[i]\n            p_high[i] = min(p_max[i], p_start[i])\n    \n    # Commit must-run units\n    committed = must_run.copy()\n    total_min = np.sum(p_low[committed])\n    total_max = np.sum(p_high[committed])\n    \n    # Step 3: Adaptive priority computation\n    priorities = np.full(n_units, np.inf)\n    for i in range(n_units):\n        if not must_run[i] and not must_off[i]:\n            amortized_startup = startup_cost[i] / (min_up[i] * p_min[i]) if u0[i] == 0 else 0\n            marginal_cost = b[i] + 2 * c[i] * p_min[i]\n            ramp_flexibility = (p_high[i] - p_low[i]) / (p_max[i] - p_min[i])\n            priorities[i] = amortized_startup + marginal_cost / (1 + ramp_flexibility)\n    \n    # Commit flexible units by priority\n    flexible_indices = np.argsort(priorities)\n    for idx in flexible_indices:\n        if priorities[idx] == np.inf:\n            continue\n        if total_max < load:\n            committed[idx] = True\n            total_min += p_low[idx]\n            total_max += p_high[idx]\n        else:\n            break\n    \n    # Step 4: Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    def compute_outputs(lmbda):\n        p_out = np.zeros(n_units)\n        for i in range(n_units):\n            if committed[i]:\n                p_desired = (lmbda - b[i]) / (2 * c[i])\n                p_out[i] = np.clip(p_desired, p_low[i], p_high[i])\n        return p_out\n    \n    for _ in range(100):  # Bisection iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_mid = compute_outputs(lambda_mid)\n        total_power = np.sum(p_mid)\n        \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    p_opt = compute_outputs(lambda_mid)\n    \n    # Step 5: Precision adjustment\n    total_power = np.sum(p_opt[committed])\n    deficit = load - total_power\n    \n    while abs(deficit) > 1e-6:\n        marginal_costs = []\n        for i in range(n_units):\n            if committed[i]:\n                if deficit > 0 and p_opt[i] < p_high[i]:\n                    marginal_costs.append(b[i] + 2 * c[i] * p_opt[i])\n                elif deficit < 0 and p_opt[i] > p_low[i]:\n                    marginal_costs.append(b[i] + 2 * c[i] * p_opt[i])\n                else:\n                    marginal_costs.append(np.inf)\n            else:\n                marginal_costs.append(np.inf)\n        \n        if np.all(np.isinf(marginal_costs)):\n            break\n        \n        if deficit > 0:\n            idx = np.argmin(marginal_costs)\n            p_opt[idx] = min(p_opt[idx] + deficit, p_high[idx])\n        else:\n            idx = np.argmax(marginal_costs)\n            p_opt[idx] = max(p_opt[idx] + deficit, p_low[idx])\n        \n        total_power = np.sum(p_opt[committed])\n        deficit = load - total_power\n    \n    # Step 6: Constraint validation and repair\n    for i in range(n_units):\n        if committed[i]:\n            u[i] = 1\n            p[i] = p_opt[i]\n            # Validate ramp constraints\n            if u0[i] == 1:\n                if p[i] - p0[i] > p_up[i]:\n                    p[i] = p0[i] + p_up[i]\n                elif p0[i] - p[i] > p_down[i]:\n                    p[i] = p0[i] - p_down[i]\n            else:\n                if p[i] > p_start[i]:\n                    p[i] = p_start[i]\n        else:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.vstack((u, p))",
          "from": "mutation",
          "gap_power_rate": 0.0054190663,
          "gap_price_rate": 0.0093540565,
          "fitness": 0.0073865614
     }
]