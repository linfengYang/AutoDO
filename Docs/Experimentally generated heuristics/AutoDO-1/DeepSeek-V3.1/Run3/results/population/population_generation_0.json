[
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If must-run units can meet load, perform economic dispatch only on must-run units\n4. Otherwise, activate additional units based on cost efficiency considering startup costs\n5. Perform constrained economic dispatch on committed units to match load exactly\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    committed = [False] * num_units\n    p_outputs = [0.0] * num_units\n    \n    # Identify must-run units\n    must_run = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                committed[i] = True\n                # Set initial output considering ramp down limit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_outputs[i] = p_min\n    \n    # Calculate available capacity from must-run units\n    must_run_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_capacity += p_max\n    \n    # Activate additional units if needed\n    if must_run_capacity < load:\n        # Create candidate list of non-committed units that can be activated\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                if unit['u_i_0'] == 0 and abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    # Calculate effective cost per MW\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']\n                    cost_per_mw = min_cost / unit['p_min_i']\n                    candidates.append((cost_per_mw, i))\n                elif unit['u_i_0'] == 1:\n                    # Already on but not must-run - use marginal cost\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n                    candidates.append((marginal_cost, i))\n        \n        # Sort candidates by cost\n        candidates.sort(key=lambda x: x[0])\n        \n        # Activate cheapest units until we can meet load\n        for cost, idx in candidates:\n            if must_run_capacity >= load:\n                break\n            unit = units_info[idx]\n            committed[idx] = True\n            if unit['u_i_0'] == 0:\n                # Starting up - respect startup ramp\n                p_outputs[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                # Already on - respect ramp up\n                p_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_run_capacity += p_outputs[idx]\n    \n    # Perform economic dispatch to match load exactly\n    total_output = sum(p_outputs)\n    remaining_load = load - total_output\n    \n    # Adjust outputs while respecting constraints\n    while abs(remaining_load) > 1e-6:\n        # Find unit with minimum marginal cost for increase or maximum for decrease\n        best_unit = None\n        best_cost = float('inf') if remaining_load > 0 else float('-inf')\n        \n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                continue\n                \n            current_p = p_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0:  # Need to increase output\n                # Check ramp up and max limits\n                max_p = unit['p_max_i']\n                if unit['u_i_0'] == 1:\n                    max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n                elif unit['u_i_0'] == 0 and committed[i]:\n                    max_p = min(max_p, unit['p_start_i'])\n                \n                if current_p < max_p and marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n            else:  # Need to decrease output\n                # Check ramp down and min limits\n                min_p = unit['p_min_i']\n                if unit['u_i_0'] == 1:\n                    min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                \n                if current_p > min_p and marginal_cost > best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = p_outputs[best_unit]\n        \n        if remaining_load > 0:\n            max_p = unit['p_max_i']\n            if unit['u_i_0'] == 1:\n                max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n            elif unit['u_i_0'] == 0:\n                max_p = min(max_p, unit['p_start_i'])\n            \n            adjustment = min(remaining_load, max_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n        else:\n            min_p = unit['p_min_i']\n            if unit['u_i_0'] == 1:\n                min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n            \n            adjustment = max(remaining_load, min_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n    \n    # Prepare output\n    for i in range(num_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0055684358,
          "gap_price_rate": 0.0091494698,
          "fitness": 0.0073589528
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on minimum up/down times and shutdown ramp constraints.\n2. Compute adaptive priorities considering marginal cost, startup cost, and ramp capabilities.\n3. Commit must-run units and flexible units by adaptive priority until load is met.\n4. Perform economic dispatch using a merit order approach while respecting output and ramp constraints.\n5. Adjust commitments if load is not met or constraints are violated.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        priority = marginal_cost + unit['s_i'] / unit['p_max_i'] if unit['u_i_0'] == 0 else marginal_cost\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    sorted_flexible = [i for _, i in priorities]\n    \n    committed = must_run[:]\n    total_max = sum(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else unit['p_start_i'] for unit in [units_info[i] for i in committed])\n    \n    for i in sorted_flexible:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        committed.append(i)\n        total_max += unit['p_start_i'] if unit['u_i_0'] == 0 else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    L = np.zeros(n_units)\n    U = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            L[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            L[i] = unit['p_min_i']\n            U[i] = unit['p_start_i']\n    \n    for i in committed:\n        p[i] = L[i]\n    \n    remaining = load - np.sum(p)\n    units_to_adjust = [i for i in committed if p[i] < U[i]]\n    \n    while remaining > 0 and units_to_adjust:\n        marginal_costs = []\n        for i in units_to_adjust:\n            unit = units_info[i]\n            marginal_costs.append((unit['b_i'] + 2 * unit['c_i'] * p[i], i))\n        marginal_costs.sort(key=lambda x: x[0])\n        best_unit = marginal_costs[0][1]\n        increase = min(remaining, U[best_unit] - p[best_unit])\n        p[best_unit] += increase\n        remaining -= increase\n        if p[best_unit] >= U[best_unit]:\n            units_to_adjust.remove(best_unit)\n    \n    for i in committed:\n        u[i] = 1\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0062422093,
          "gap_price_rate": 0.0107972871,
          "fitness": 0.0085197482
     },
     {
          "name": "commit_units_priority_dispatch",
          "algorithm": "1. Enforce minimum up/down time constraints by forcing units to remain on/off if required\n2. Sort available units by incremental cost (derivative of cost function)\n3. Perform priority-based unit commitment considering startup costs and ramp constraints\n4. Execute economic dispatch using lambda iteration to minimize production costs\n5. Adjust outputs to respect ramp limits and minimum generation constraints\n6. Ensure load balance while respecting all physical constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Enforce minimum up/down time constraints\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Calculate incremental costs for all units\n    incremental_costs = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            current_p = unit['p_i_0']\n        else:\n            current_p = 0\n        inc_cost = 2 * unit['c_i'] * current_p + unit['b_i']\n        incremental_costs.append(inc_cost)\n    \n    # Create priority list based on incremental costs\n    priority_list = sorted(range(n_units), key=lambda i: incremental_costs[i])\n    \n    # Commit units based on priority\n    committed = set(forced_on)\n    total_capacity = 0\n    for i in priority_list:\n        if i in forced_off:\n            continue\n        unit = units_info[i]\n        max_output = min(unit['p_max_i'], \n                        unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] == 1 else unit['p_start_i'])\n        if total_capacity + max_output < load and i not in forced_on:\n            committed.add(i)\n            total_capacity += max_output\n        elif i in forced_on:\n            total_capacity += max_output\n    \n    # Economic dispatch using lambda iteration\n    low = min(2*unit['c_i']*unit['p_min_i'] + unit['b_i'] for i in committed for unit in [units_info[i]])\n    high = max(2*unit['c_i']*unit['p_max_i'] + unit['b_i'] for i in committed for unit in [units_info[i]])\n    \n    for _ in range(100):  # Lambda iteration\n        lambda_val = (low + high) / 2\n        total_gen = 0\n        for i in committed:\n            unit = units_info[i]\n            p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            # Apply output constraints\n            p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n            # Apply ramp constraints\n            if unit['u_i_0'] == 1:\n                p = max(unit['p_i_0'] - unit['p_down_i'], \n                       min(unit['p_i_0'] + unit['p_up_i'], p))\n            else:\n                p = min(unit['p_start_i'], p)\n            total_gen += p\n        \n        if abs(total_gen - load) < 1e-3:\n            break\n        elif total_gen < load:\n            low = lambda_val\n        else:\n            high = lambda_val\n    \n    # Final dispatch with constraint enforcement\n    total_gen = 0\n    for i in committed:\n        unit = units_info[i]\n        p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n        p = max(unit['p_min_i'], min(unit['p_max_i'], p))\n        if unit['u_i_0'] == 1:\n            p = max(unit['p_i_0'] - unit['p_down_i'], \n                   min(unit['p_i_0'] + unit['p_up_i'], p))\n        else:\n            p = min(unit['p_start_i'], p)\n        schedules[1][i] = p\n        schedules[0][i] = 1\n        total_gen += p\n    \n    # Load balancing adjustment\n    diff = load - total_gen\n    while abs(diff) > 1e-3:\n        adjusted = False\n        for i in committed:\n            unit = units_info[i]\n            if diff > 0:  # Need more power\n                new_p = min(schedules[1][i] + diff, unit['p_max_i'])\n                if unit['u_i_0'] == 1:\n                    new_p = min(new_p, unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    new_p = min(new_p, unit['p_start_i'])\n                if new_p > schedules[1][i]:\n                    diff -= (new_p - schedules[1][i])\n                    schedules[1][i] = new_p\n                    adjusted = True\n            else:  # Need less power\n                new_p = max(schedules[1][i] + diff, unit['p_min_i'])\n                if unit['u_i_0'] == 1:\n                    new_p = max(new_p, unit['p_i_0'] - unit['p_down_i'])\n                if new_p < schedules[1][i]:\n                    diff -= (new_p - schedules[1][i])\n                    schedules[1][i] = new_p\n                    adjusted = True\n        if not adjusted:\n            break\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0051705491,
          "gap_price_rate": 0.0175151129,
          "fitness": 0.011342831
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": "1. Determine must-run units (online units violating min up-time or shutdown ramp limits) and must-off units (offline units violating min down-time).\n2. Initialize online set with must-run units and previously online units not must-off.\n3. Calculate total min/max output of online set considering ramp limits and startup/shutdown constraints.\n4. If load exceeds total max, start additional cheapest available units (by average cost at minimum power) until load is within capacity.\n5. If load is below total min, shut down most expensive non-must-run units (considering shutdown ramp limits) until load is within capacity.\n6. Perform economic dispatch via bisection method to find optimal lambda for equal marginal cost, enforcing output limits.\n7. Adjust outputs to exactly match load using marginal cost-based prioritization.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    online_units = set()\n    for i in range(n_units):\n        if must_run[i]:\n            online_units.add(i)\n        elif units_info[i]['u_i_0'] == 1 and not must_off[i]:\n            online_units.add(i)\n    \n    L = np.zeros(n_units)\n    U = np.zeros(n_units)\n    for i in online_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            L[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            U[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            L[i] = unit['p_min_i']\n            U[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(L[i] for i in online_units)\n    total_max = sum(U[i] for i in online_units)\n    \n    if load > total_max:\n        available_units = [i for i in range(n_units) if i not in online_units and not must_off[i] and not must_run[i]]\n        avg_costs = []\n        for i in available_units:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n            avg_costs.append((i, cost))\n        avg_costs.sort(key=lambda x: x[1])\n        \n        for i, _ in avg_costs:\n            unit = units_info[i]\n            L_i = unit['p_min_i']\n            U_i = min(unit['p_max_i'], unit['p_start_i'])\n            if total_max + U_i >= load:\n                online_units.add(i)\n                L[i] = L_i\n                U[i] = U_i\n                total_min += L_i\n                total_max += U_i\n                break\n            online_units.add(i)\n            L[i] = L_i\n            U[i] = U_i\n            total_min += L_i\n            total_max += U_i\n    \n    if load < total_min:\n        non_must_run = [i for i in online_units if not must_run[i] and units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']]\n        avg_costs = []\n        for i in non_must_run:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n            avg_costs.append((i, cost))\n        avg_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in avg_costs:\n            if units_info[i]['u_i_0'] == 1:\n                L_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            else:\n                L_i = units_info[i]['p_min_i']\n            if total_min - L_i <= load:\n                online_units.remove(i)\n                total_min -= L_i\n                if units_info[i]['u_i_0'] == 1:\n                    U_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    U_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                total_max -= U_i\n                if total_min <= load:\n                    break\n    \n    p_outputs = np.zeros(n_units)\n    online_list = list(online_units)\n    if online_list:\n        L_online = [L[i] for i in online_list]\n        U_online = [U[i] for i in online_list]\n        b_online = [units_info[i]['b_i'] for i in online_list]\n        c_online = [units_info[i]['c_i'] for i in online_list]\n        \n        low = min(b_online[j] + 2 * c_online[j] * L_online[j] for j in range(len(online_list)))\n        high = max(b_online[j] + 2 * c_online[j] * U_online[j] for j in range(len(online_list)))\n        \n        tol = 0.01\n        while high - low > tol:\n            mid = (low + high) / 2\n            total_p = 0\n            for j in range(len(online_list)):\n                p_uncon = (mid - b_online[j]) / (2 * c_online[j])\n                p_clip = max(L_online[j], min(U_online[j], p_uncon))\n                total_p += p_clip\n            if total_p < load:\n                low = mid\n            else:\n                high = mid\n        \n        total_p = 0\n        p_vals = []\n        for j in range(len(online_list)):\n            p_uncon = (high - b_online[j]) / (2 * c_online[j])\n            p_clip = max(L_online[j], min(U_online[j], p_uncon))\n            p_vals.append(p_clip)\n            total_p += p_clip\n        \n        disc = load - total_p\n        if disc > 0:\n            candidates = [j for j in range(len(online_list)) if p_vals[j] < U_online[j]]\n            margins = [b_online[j] + 2 * c_online[j] * p_vals[j] for j in candidates]\n            sorted_candidates = [c for _, c in sorted(zip(margins, candidates))]\n            for j in sorted_candidates:\n                addable = U_online[j] - p_vals[j]\n                to_add = min(disc, addable)\n                p_vals[j] += to_add\n                disc -= to_add\n                if disc <= 0:\n                    break\n        else:\n            disc = -disc\n            candidates = [j for j in range(len(online_list)) if p_vals[j] > L_online[j]]\n            margins = [b_online[j] + 2 * c_online[j] * p_vals[j] for j in candidates]\n            sorted_candidates = [c for _, c in sorted(zip(margins, candidates), reverse=True)]\n            for j in sorted_candidates:\n                reducible = p_vals[j] - L_online[j]\n                to_reduce = min(disc, reducible)\n                p_vals[j] -= to_reduce\n                disc -= to_reduce\n                if disc <= 0:\n                    break\n        \n        for idx, i in enumerate(online_list):\n            p_outputs[i] = p_vals[idx]\n    \n    u_outputs = np.zeros(n_units)\n    for i in online_units:\n        u_outputs[i] = 1\n    \n    schedules = np.vstack((u_outputs, p_outputs))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0360461575,
          "fitness": 0.018087918
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and adjustable based on minimum up/down times and shutdown ramp limits.\n2. Set must-on units to committed state and must-off units to decommitted state.\n3. Initialize adjustable units to their previous commitment state.\n4. If total minimum generation exceeds load, decommit adjustable units with highest operating costs until feasible.\n5. If total maximum generation is below load, commit adjustable units with lowest full costs until feasible.\n6. Perform economic dispatch using a merit order approach based on marginal costs, respecting output limits and ramp constraints.\n7. Adjust generation levels iteratively to meet load while satisfying all constraints.\n\n",
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_on = []\n    must_off = []\n    adjustable = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                adjustable.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                adjustable.append(i)\n    \n    for i in must_on:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in adjustable:\n        u[i] = units_info[i]['u_i_0']\n    \n    total_min = 0\n    total_max = 0\n    for i in range(n_units):\n        if u[i] == 1:\n            total_min += units_info[i]['p_min_i']\n            total_max += units_info[i]['p_max_i']\n    \n    if total_min > load:\n        adj_on = [i for i in adjustable if u[i] == 1]\n        costs = []\n        for i in adj_on:\n            unit = units_info[i]\n            cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n            costs.append((cost, i))\n        costs.sort(reverse=True, key=lambda x: x[0])\n        \n        for cost, i in costs:\n            if total_min <= load:\n                break\n            u[i] = 0\n            total_min -= units_info[i]['p_min_i']\n            total_max -= units_info[i]['p_max_i']\n    \n    if total_max < load:\n        adj_off = [i for i in adjustable if u[i] == 0]\n        full_costs = []\n        for i in adj_off:\n            unit = units_info[i]\n            avg_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2 + unit['s_i']) / unit['p_min_i']\n            full_costs.append((avg_cost, i))\n        full_costs.sort(key=lambda x: x[0])\n        \n        for cost, i in full_costs:\n            if total_max >= load:\n                break\n            u[i] = 1\n            total_min += units_info[i]['p_min_i']\n            total_max += units_info[i]['p_max_i']\n    \n    committed = [i for i in range(n_units) if u[i] == 1]\n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    \n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb[i] = unit['p_min_i']\n            ub[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in committed:\n        p[i] = lb[i]\n    \n    total_gen = np.sum(p)\n    remaining = load - total_gen\n    \n    while abs(remaining) > 1e-6:\n        if remaining > 0:\n            marginal_costs = []\n            for i in committed:\n                if p[i] < ub[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(key=lambda x: x[0])\n            i = marginal_costs[0][1]\n            add = min(ub[i] - p[i], remaining)\n            p[i] += add\n            remaining -= add\n        else:\n            marginal_costs = []\n            for i in committed:\n                if p[i] > lb[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n                    marginal_costs.append((mc, i))\n            if not marginal_costs:\n                break\n            marginal_costs.sort(reverse=True, key=lambda x: x[0])\n            i = marginal_costs[0][1]\n            reduce = min(p[i] - lb[i], -remaining)\n            p[i] -= reduce\n            remaining += reduce\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0231401898,
          "gap_price_rate": 0.0138037235,
          "fitness": 0.0184719567
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-not-run, flexible-on, and flexible-off based on current state and constraints\n  2. Initialize must-run and flexible-on units to minimum feasible output\n  3. If total output exceeds load, turn off flexible-on units by descending marginal cost\n  4. For remaining load, adjust committed units by ascending marginal cost\n  5. If needed, turn on flexible-off units by ascending average cost and redispatch\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    must_run = []\n    must_not_run = []\n    flexible_on = []\n    flexible_off = []\n    low_bounds = [0] * n_units\n    high_bounds = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1 and (t_i0 < t_on_min or p_i0 > p_shut):\n            must_run.append(i)\n            low_bounds[i] = max(p_min, p_i0 - p_down)\n            high_bounds[i] = min(p_max, p_i0 + p_up)\n        elif u_i0 == 0 and abs(t_i0) < t_off_min:\n            must_not_run.append(i)\n            low_bounds[i] = 0\n            high_bounds[i] = 0\n        else:\n            if u_i0 == 1:\n                flexible_on.append(i)\n                low_bounds[i] = max(p_min, p_i0 - p_down)\n                high_bounds[i] = min(p_max, p_i0 + p_up)\n            else:\n                flexible_off.append(i)\n                low_bounds[i] = 0\n                high_bounds[i] = 0\n\n    for i in must_run:\n        schedules[0, i] = 1\n        schedules[1, i] = low_bounds[i]\n    for i in must_not_run:\n        schedules[0, i] = 0\n        schedules[1, i] = 0\n    for i in flexible_on:\n        schedules[0, i] = 1\n        schedules[1, i] = low_bounds[i]\n\n    total_p = np.sum(schedules[1, :])\n    remaining_load = load - total_p\n\n    if remaining_load < 0:\n        flexible_on_sorted = sorted(flexible_on, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * schedules[1, i], reverse=True)\n        for i in flexible_on_sorted:\n            if remaining_load >= 0:\n                break\n            reduction = min(schedules[1, i], -remaining_load)\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n            remaining_load += reduction\n\n    committed_indices = [i for i in must_run] + [i for i in flexible_on if schedules[0, i] == 1]\n    committed_units = []\n    for i in committed_indices:\n        unit = units_info[i]\n        current_p = schedules[1, i]\n        marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n        committed_units.append((marginal_cost, i, current_p, high_bounds[i]))\n    committed_units.sort(key=lambda x: x[0])\n    \n    for mc, i, current_p, high_bound in committed_units:\n        if remaining_load <= 0:\n            break\n        available = high_bound - current_p\n        to_add = min(available, remaining_load)\n        schedules[1, i] += to_add\n        remaining_load -= to_add\n\n    if remaining_load > 0:\n        flexible_off_costs = []\n        for i in flexible_off:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost_at_min = unit['b_i'] * p_min + unit['c_i'] * p_min**2 + unit['s_i']\n            avg_cost = cost_at_min / p_min\n            flexible_off_costs.append((avg_cost, i))\n        flexible_off_costs.sort(key=lambda x: x[0])\n        \n        for avg_cost, i in flexible_off_costs:\n            if remaining_load <= 0:\n                break\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_start = unit['p_start_i']\n            high_bound = min(unit['p_max_i'], p_start)\n            schedules[0, i] = 1\n            schedules[1, i] = p_min\n            remaining_load -= p_min\n            low_bounds[i] = p_min\n            high_bounds[i] = high_bound\n            committed_indices.append(i)\n\n        while abs(remaining_load) > 1e-5:\n            committed_units = []\n            for i in committed_indices:\n                unit = units_info[i]\n                current_p = schedules[1, i]\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n                committed_units.append((marginal_cost, i, current_p, high_bounds[i]))\n            \n            if remaining_load > 0:\n                committed_units.sort(key=lambda x: x[0])\n                for mc, i, current_p, high_bound in committed_units:\n                    if current_p < high_bound:\n                        to_add = min(high_bound - current_p, remaining_load)\n                        schedules[1, i] += to_add\n                        remaining_load -= to_add\n                        break\n                else:\n                    break\n            else:\n                committed_units.sort(key=lambda x: x[0], reverse=True)\n                for mc, i, current_p, high_bound in committed_units:\n                    if current_p > low_bounds[i]:\n                        to_reduce = min(current_p - low_bounds[i], -remaining_load)\n                        schedules[1, i] -= to_reduce\n                        remaining_load += to_reduce\n                        break\n                else:\n                    break\n\n    return schedules",
          "from": null,
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0408983306,
          "fitness": 0.0204850114
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Initialize units' states and compute feasible output ranges considering ramp limits and min up/down times\n2. Classify units into must-run, available, and must-off categories based on constraints\n3. Calculate marginal costs for available units and sort by cost efficiency\n4. Commit must-run units first, then cheapest available units until load is met\n5. Adjust generation levels using economic dispatch while respecting output constraints\n6. Handle residual load by adjusting flexible units or tolerating slight mismatch\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute marginal costs and feasible ranges\n    marginal_costs = []\n    low_bounds = []\n    high_bounds = []\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible output range\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        \n        # Check minimum up/down time constraints\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        marginal_cost = 2 * unit['c_i'] * (high + low)/2 + unit['b_i']\n        marginal_costs.append(marginal_cost)\n        low_bounds.append(low)\n        high_bounds.append(high)\n    \n    # Commit must-run units\n    total_output = 0\n    for i in must_run:\n        u[i] = 1\n        p[i] = low_bounds[i]\n        total_output += p[i]\n    \n    # Commit flexible units by marginal cost\n    flexible_sorted = sorted(flexible, key=lambda i: marginal_costs[i])\n    for i in flexible_sorted:\n        if total_output < load:\n            u[i] = 1\n            p[i] = low_bounds[i]\n            total_output += p[i]\n        else:\n            break\n    \n    # Economic dispatch\n    remaining_load = load - total_output\n    while abs(remaining_load) > 1e-6:\n        # Find adjustable units\n        adjustable = []\n        for i in range(n_units):\n            if u[i] == 1:\n                if remaining_load > 0 and p[i] < high_bounds[i]:\n                    adjustable.append(i)\n                elif remaining_load < 0 and p[i] > low_bounds[i]:\n                    adjustable.append(i)\n        \n        if not adjustable:\n            break\n        \n        # Sort adjustable units by cost sensitivity\n        if remaining_load > 0:\n            adjustable.sort(key=lambda i: marginal_costs[i])\n        else:\n            adjustable.sort(key=lambda i: -marginal_costs[i])\n        \n        # Adjust most sensitive unit\n        i = adjustable[0]\n        if remaining_load > 0:\n            change = min(remaining_load, high_bounds[i] - p[i])\n        else:\n            change = max(remaining_load, low_bounds[i] - p[i])\n        \n        p[i] += change\n        total_output += change\n        remaining_load -= change\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0920710346,
          "fitness": 0.0460755805
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run and must-off units based on minimum up/down times and shutdown ramp limits.\n2. Set must-run units to their minimum allowed output considering ramp-down constraints.\n3. If total output exceeds load, reduce must-run units to minimum allowed output.\n4. If load not met, commit available units in ascending order of marginal cost at maximum output.\n5. Perform economic dispatch by adjusting outputs of committed units to meet load while respecting ramp constraints, prioritizing units with lower marginal costs for load increases and higher marginal costs for load decreases.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    u = schedules[0, :]\n    p = schedules[1, :]\n    \n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up_time = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down_time = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    \n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if t0[i] < min_up_time[i] or p0[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if t0[i] > -min_down_time[i]:\n                must_off[i] = True\n    \n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            p[i] = max(p_min[i], p0[i] - p_down[i])\n    \n    total_p = np.sum(p)\n    if total_p > load:\n        return schedules\n    \n    remaining_load = load - total_p\n    available_indices = [i for i in range(n_units) if not must_run[i] and not must_off[i] and u[i] == 0]\n    marginal_cost_at_max = [b[i] + 2 * c[i] * p_max[i] for i in available_indices]\n    sorted_available = [i for _, i in sorted(zip(marginal_cost_at_max, available_indices))]\n    \n    for i in sorted_available:\n        if remaining_load <= 0:\n            break\n        u[i] = 1\n        min_p_i = p_min[i] if u0[i] == 0 else max(p_min[i], p0[i] - p_down[i])\n        p[i] = min_p_i\n        remaining_load -= min_p_i\n    \n    total_p = np.sum(p)\n    remaining_load = load - total_p\n    \n    min_allowed = np.zeros(n_units)\n    max_allowed = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if u0[i] == 1:\n                min_allowed[i] = max(p_min[i], p0[i] - p_down[i])\n                max_allowed[i] = min(p_max[i], p0[i] + p_up[i])\n            else:\n                min_allowed[i] = p_min[i]\n                max_allowed[i] = min(p_max[i], p_start[i])\n    \n    if remaining_load < 0:\n        reduction_needed = -remaining_load\n        committed_indices = [i for i in range(n_units) if u[i] == 1]\n        current_marginal = [b[i] + 2 * c[i] * p[i] for i in committed_indices]\n        sorted_committed = [i for _, i in sorted(zip(current_marginal, committed_indices), reverse=True)]\n        for i in sorted_committed:\n            if reduction_needed <= 0:\n                break\n            reduce_possible = p[i] - min_allowed[i]\n            reduce_amount = min(reduction_needed, reduce_possible)\n            p[i] -= reduce_amount\n            reduction_needed -= reduce_amount\n    elif remaining_load > 0:\n        increase_needed = remaining_load\n        committed_indices = [i for i in range(n_units) if u[i] == 1]\n        current_marginal = [b[i] + 2 * c[i] * p[i] for i in committed_indices]\n        sorted_committed = [i for _, i in sorted(zip(current_marginal, committed_indices))]\n        for i in sorted_committed:\n            if increase_needed <= 0:\n                break\n            increase_possible = max_allowed[i] - p[i]\n            increase_amount = min(increase_needed, increase_possible)\n            p[i] += increase_amount\n            increase_needed -= increase_amount\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0923868685,
          "fitness": 0.0462334975
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Precompute allowed power ranges and must-run status for each unit based on current state and constraints\n2. Categorize units into must-run, must-off, and flexible units\n3. Commit must-run units at their minimum allowed output\n4. Sort flexible units by marginal cost at minimum power (including startup costs for offline units)\n5. Commit flexible units in cost order until minimum capacity meets load\n6. Adjust commitment if overcommitted by decommitting expensive flexible units\n7. Perform economic dispatch on committed units using marginal cost ordering\n8. Handle any remaining load by committing additional units if necessary\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Precompute parameters for each unit\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    cost_per_mw = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Compute allowed output range\n        if unit['u_i_0'] == 1:  # Previously on\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check must-run conditions\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:  # Previously off\n            min_output[i] = unit['p_min_i']\n            max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n            # Check must-off conditions\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n        \n        # Compute cost metrics\n        if must_off[i]:\n            cost_per_mw[i] = float('inf')\n        else:\n            startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n            cost_per_mw[i] = (unit['a_i'] + startup_cost + \n                            unit['b_i'] * min_output[i] + \n                            unit['c_i'] * min_output[i]**2) / min_output[i]\n        \n        marginal_cost[i] = 2 * unit['c_i'] * min_output[i] + unit['b_i']\n    \n    # Initialize commitment and output\n    committed = must_run.copy()\n    output = np.zeros(n_units)\n    \n    # Set must-run units to minimum output\n    for i in range(n_units):\n        if must_run[i]:\n            output[i] = min_output[i]\n    \n    # Calculate current total output\n    current_total = output.sum()\n    \n    # Commit flexible units in cost order\n    flexible_units = [i for i in range(n_units) if not must_run[i] and not must_off[i]]\n    flexible_units.sort(key=lambda i: cost_per_mw[i])\n    \n    for i in flexible_units:\n        if current_total < load:\n            committed[i] = True\n            output[i] = min_output[i]\n            current_total += min_output[i]\n    \n    # Decommit expensive units if overcommitted\n    if current_total > load:\n        over_committed = [i for i in flexible_units if committed[i]]\n        over_committed.sort(key=lambda i: cost_per_mw[i], reverse=True)\n        \n        for i in over_committed:\n            if current_total - min_output[i] >= load:\n                committed[i] = False\n                output[i] = 0\n                current_total -= min_output[i]\n    \n    # Economic dispatch among committed units\n    remaining_load = load - current_total\n    while remaining_load > 1e-6:\n        # Find committed units with available capacity\n        available_units = [i for i in range(n_units) if committed[i] and \n                         output[i] < max_output[i]]\n        \n        if not available_units:\n            break\n            \n        # Find unit with lowest marginal cost\n        next_unit = min(available_units, key=lambda i: 2*unit['c_i']*output[i] + unit['b_i'])\n        \n        # Calculate possible increase\n        increase = min(remaining_load, \n                      max_output[next_unit] - output[next_unit])\n        output[next_unit] += increase\n        remaining_load -= increase\n    \n    # Commit additional units if load not met\n    if remaining_load > 1e-6:\n        for i in flexible_units:\n            if not committed[i] and not must_off[i]:\n                potential = min(remaining_load, max_output[i])\n                if potential > 0:\n                    committed[i] = True\n                    output[i] = potential\n                    remaining_load -= potential\n                    if remaining_load <= 1e-6:\n                        break\n    \n    # Prepare output\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = output[i]\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 9.48867e-05,
          "gap_price_rate": 0.1228311754,
          "fitness": 0.061463031
     }
]