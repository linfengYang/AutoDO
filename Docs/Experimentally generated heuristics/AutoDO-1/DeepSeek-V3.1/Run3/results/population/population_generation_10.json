[
     {
          "name": "refined_enhanced_adaptive_priority_dispatch",
          "algorithm": "1. Enhanced unit classification considering startup/shutdown ramp constraints and extended must-run conditions\n2. Dynamic feasible power range calculation with improved ramp rate handling\n3. Adaptive priority computation with amortized startup costs and ramp flexibility factors\n4. Bisection-based economic dispatch with enhanced lambda convergence\n5. Precision adjustment using marginal cost sorting with constraint-aware corrections\n6. Comprehensive validation with iterative repair for constraint violations\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_adaptive_priority_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Enhanced unit classification\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        # Extended must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        # Enhanced must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              unit['t_i_0'] > -unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Step 2: Dynamic feasible power range calculation\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        if i in must_run:\n            if unit['u_i_0'] == 0:  # Starting up\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Already online\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in must_off:\n            min_p[i] = 0\n            max_p[i] = 0\n        else:  # Flexible units\n            if unit['u_i_0'] == 1:\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3: Commit must-run units and compute adaptive priorities\n    committed = set(must_run)\n    total_min = sum(min_p[i] for i in committed)\n    total_max = sum(max_p[i] for i in committed)\n    \n    # Calculate adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        unit = units[i]\n        if unit['u_i_0'] == 0:\n            # Amortize startup cost over minimum uptime\n            amortized_cost = unit['s_i'] / max(1, unit['t_on_min_i'])\n            full_cost = (amortized_cost + unit['a_i'] + \n                         unit['b_i'] * min_p[i] + \n                         unit['c_i'] * min_p[i]**2)\n            # Add ramp flexibility factor\n            ramp_factor = 1 + (unit['p_up_i'] / unit['p_max_i'])\n            priority = full_cost * ramp_factor / min_p[i] if min_p[i] > 0 else float('inf')\n        else:\n            # Use marginal cost for already online units\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p[i]\n            ramp_factor = 1 + (unit['p_up_i'] / unit['p_max_i'])\n            priority = marginal_cost * ramp_factor\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            break\n    \n    # Step 5: Enhanced bisection economic dispatch\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else max_p[i]\n            # Constrain by feasible range\n            p[i] = np.clip(p_uncon, min_p[i], max_p[i])\n            total_gen += p[i]\n        \n        if abs(total_gen - load) < 1e-6:\n            break\n        elif total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Precision adjustment with marginal cost sorting\n    current_gen = sum(p[i] for i in committed)\n    deficit = load - current_gen\n    \n    if abs(deficit) > 1e-6:\n        # Create list of adjustable units with marginal costs\n        adjustable = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            adjustable.append((marginal_cost, i))\n        \n        adjustable.sort(key=lambda x: x[0], reverse=deficit < 0)\n        \n        # Adjust outputs\n        for mc, i in adjustable:\n            if deficit > 0:  # Need more generation\n                add_capacity = min(deficit, max_p[i] - p[i])\n                p[i] += add_capacity\n                deficit -= add_capacity\n            else:  # Need less generation\n                reduce_capacity = min(-deficit, p[i] - min_p[i])\n                p[i] -= reduce_capacity\n                deficit += reduce_capacity\n            \n            if abs(deficit) < 1e-6:\n                break\n    \n    # Step 7: Final validation and constraint enforcement\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0043993514,
          "gap_price_rate": 0.0091072805,
          "fitness": 0.0067533159
     },
     {
          "name": "enhanced_adaptive_priority_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Step 1: Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power range considering ramp constraints\n        if unit['u_i_0'] == 1:  # Previously on\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check minimum up time constraint\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously off\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            # Check minimum down time constraint\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = p_min\n        feasible_max[i] = p_max\n    \n    # Step 2: Commit must-run units\n    committed = set(must_run)\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        schedules[0][i] = 1\n        schedules[1][i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    # Step 3: Compute adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        if units_info[i]['u_i_0'] == 0:\n            # Include startup cost if unit was off\n            full_cost = (units_info[i]['s_i'] + \n                         units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        else:\n            full_cost = (units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        \n        # Adjust priority based on ramp capabilities\n        ramp_factor = (feasible_max[i] - feasible_min[i]) / max(1, units_info[i]['p_up_i'])\n        priority = full_cost / (feasible_min[i] + 1e-6) * (1 - 0.1 * ramp_factor)\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            schedules[0][i] = 1\n            schedules[1][i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Step 5: Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units_info[i]\n            # Calculate unconstrained output\n            p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n            # Constrain within feasible range\n            p_dispatch = max(feasible_min[i], min(feasible_max[i], p_star))\n            total_power += p_dispatch\n        \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final dispatch values\n    for i in committed:\n        unit = units_info[i]\n        p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n        schedules[1][i] = max(feasible_min[i], min(feasible_max[i], p_star))\n    \n    # Step 6: Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    while abs(diff) > 1e-6:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed:\n            if diff > 0 and schedules[1][i] < feasible_max[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n            elif diff < 0 and schedules[1][i] > feasible_min[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost (ascending for increasing, descending for decreasing)\n        adjustable.sort(key=lambda x: x[0], reverse=diff < 0)\n        \n        # Adjust the most suitable unit\n        i = adjustable[0][1]\n        if diff > 0:\n            adjust = min(diff, feasible_max[i] - schedules[1][i])\n        else:\n            adjust = max(diff, feasible_min[i] - schedules[1][i])\n        \n        schedules[1][i] += adjust\n        diff -= adjust\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0087069616,
          "fitness": 0.0070677491
     },
     {
          "name": "adaptive_commitment_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units using adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check minimum up/down time constraints\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate feasible output range\n        if u_i0 == 1:\n            p_min = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n        unit['p_min_feas'] = p_min\n        unit['p_max_feas'] = p_max\n\n    # Commit must-run units\n    total_min = 0\n    total_max = 0\n    committed = set(must_run)\n    \n    for i in must_run:\n        unit = units[i]\n        schedules[0, i] = 1\n        schedules[1, i] = unit['p_min_feas']\n        total_min += unit['p_min_feas']\n        total_max += unit['p_max_feas']\n        \n    # Commit flexible units if needed\n    if total_min > load:\n        # Decommit most expensive flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_feas']\n            flexible_costs.append((i, marginal_cost))\n        \n        flexible_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in flexible_costs:\n            if total_min <= load:\n                break\n            unit = units[i]\n            total_min -= unit['p_min_feas']\n            total_max -= unit['p_max_feas']\n            committed.discard(i)\n            \n    elif total_max < load:\n        # Commit additional flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            full_cost = (unit['s_i'] if unit['u_i_0'] == 0 else 0) + \\\n                       unit['a_i'] + unit['b_i'] * unit['p_min_feas'] + \\\n                       unit['c_i'] * unit['p_min_feas'] ** 2\n            cost_per_mw = full_cost / unit['p_min_feas']\n            flexible_costs.append((i, cost_per_mw))\n        \n        flexible_costs.sort(key=lambda x: x[1])\n        \n        for i, _ in flexible_costs:\n            if total_max >= load:\n                break\n            unit = units[i]\n            committed.add(i)\n            total_min += unit['p_min_feas']\n            total_max += unit['p_max_feas']\n\n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # Sufficiently high value\n    \n    for _ in range(100):  # Iteration limit\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units[i]\n            p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_dispatch = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n            total_power += p_dispatch\n            \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n\n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        schedules[0, i] = 1\n        schedules[1, i] = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n\n    # Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    if diff != 0:\n        # Create priority list based on marginal cost\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((i, mc))\n        \n        if diff > 0:\n            marginal_costs.sort(key=lambda x: x[1])\n        else:\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            \n        for i, _ in marginal_costs:\n            if abs(diff) < 1e-6:\n                break\n            unit = units[i]\n            current_p = schedules[1, i]\n            if diff > 0:\n                new_p = min(current_p + diff, unit['p_max_feas'])\n            else:\n                new_p = max(current_p + diff, unit['p_min_feas'])\n            diff -= (new_p - current_p)\n            schedules[1, i] = new_p\n\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0087811081,
          "fitness": 0.0071048223
     },
     {
          "name": "improved_commit_units_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units by adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
          "code": "import numpy as np\n\ndef improved_commit_units_heuristic(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Calculate feasible power range\n        if unit['u_i_0'] == 1:  # previously online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check if must-run due to min up-time or shutdown ramp\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # previously offline\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            # Check if must-off due to min down-time\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = min_p\n        feasible_max[i] = max_p\n    \n    # Commit must-run units\n    committed = set(must_run)\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]  # start at minimum\n    \n    # Calculate current total generation\n    total_gen = np.sum(p)\n    total_max = np.sum([feasible_max[i] for i in committed])\n    total_min = np.sum([feasible_min[i] for i in committed])\n    \n    # Commit flexible units if needed\n    if total_max < load:\n        # Calculate full cost for flexible units\n        costs = []\n        for i in flexible:\n            if i in must_off:\n                continue\n            min_cost = (units[i]['a_i'] + units[i]['b_i'] * feasible_min[i] + \n                        units[i]['c_i'] * feasible_min[i]**2)\n            full_cost = min_cost + units[i]['s_i'] if units[i]['u_i_0'] == 0 else min_cost\n            costs.append((full_cost / feasible_min[i], i))\n        \n        # Sort by cost per MW\n        costs.sort(key=lambda x: x[0])\n        \n        # Commit units until load can be met\n        for _, i in costs:\n            if total_max >= load:\n                break\n            if i not in committed:\n                committed.add(i)\n                u[i] = 1\n                p[i] = feasible_min[i]\n                total_max += feasible_max[i]\n                total_min += feasible_min[i]\n    \n    # Decommit units if minimum generation exceeds load\n    if total_min > load:\n        # Sort committed units by marginal cost at minimum output\n        costs = []\n        for i in committed:\n            if i in must_run:\n                continue\n            marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * feasible_min[i]\n            costs.append((marg_cost, i))\n        \n        costs.sort(reverse=True, key=lambda x: x[0])\n        \n        # Decommit units until feasible\n        for _, i in costs:\n            if total_min <= load:\n                break\n            committed.discard(i)\n            u[i] = 0\n            p[i] = 0\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n    \n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # sufficiently high value\n    \n    for _ in range(100):  # 100 iterations for convergence\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            # Constrain output\n            p_i = max(feasible_min[i], min(feasible_max[i], p_uncon))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = max(feasible_min[i], min(feasible_max[i], p_uncon))\n    \n    # Adjust to exactly match load\n    total_p = np.sum(p)\n    diff = load - total_p\n    \n    while abs(diff) > 1e-5:\n        # Find unit to adjust\n        if diff > 0:\n            # Increase output of unit with lowest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = min(feasible_max[i], p[i] + min(diff, feasible_max[i] - p[i]))\n        else:\n            # Decrease output of unit with highest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(reverse=True, key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = max(feasible_min[i], p[i] + max(diff, feasible_min[i] - p[i]))\n        \n        total_p = np.sum(p)\n        diff = load - total_p\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0087811083,
          "fitness": 0.007104823
     },
     {
          "name": "refined_adaptive_priority_dispatch",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        t_i_0 = unit['t_i_0']\n        s_i = unit['s_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            feasible_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n            feasible_min[i] = p_min_i\n            feasible_max[i] = min(p_max_i, p_start_i)\n    \n    committed = must_run.copy()\n    total_min = sum(feasible_min[i] for i in committed)\n    total_max = sum(feasible_max[i] for i in committed)\n    \n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        if units_info[i]['u_i_0'] == 0:\n            min_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * feasible_min[i] + \n                       unit['c_i'] * feasible_min[i] ** 2)\n            priority = min_cost / feasible_min[i]\n        else:\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    for priority, i in priorities:\n        if total_max < load:\n            committed.append(i)\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    committed_set = set(committed)\n    low_lambda = 0\n    high_lambda = 0\n    for i in committed:\n        unit = units_info[i]\n        inc_cost_min = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        inc_cost_max = unit['b_i'] + 2 * unit['c_i'] * feasible_max[i]\n        low_lambda = min(low_lambda, inc_cost_min)\n        high_lambda = max(high_lambda, inc_cost_max)\n    \n    tol = 1e-6\n    max_iter = 100\n    for _ in range(max_iter):\n        lambda_val = (low_lambda + high_lambda) / 2\n        total_p = 0\n        for i in committed:\n            unit = units_info[i]\n            p_i = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            p_i = np.clip(p_i, feasible_min[i], feasible_max[i])\n            p[i] = p_i\n            total_p += p_i\n        \n        if abs(total_p - load) < tol:\n            break\n        elif total_p < load:\n            low_lambda = lambda_val\n        else:\n            high_lambda = lambda_val\n    \n    total_p = sum(p[i] for i in committed)\n    if total_p > load:\n        sorted_units = sorted(committed, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i], reverse=True)\n        for i in sorted_units:\n            reduction = min(total_p - load, p[i] - feasible_min[i])\n            p[i] -= reduction\n            total_p -= reduction\n            if abs(total_p - load) < tol:\n                break\n    elif total_p < load:\n        sorted_units = sorted(committed, key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i])\n        for i in sorted_units:\n            addition = min(load - total_p, feasible_max[i] - p[i])\n            p[i] += addition\n            total_p += addition\n            if abs(total_p - load) < tol:\n                break\n    \n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0092644293,
          "fitness": 0.0073464829
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If must-run units can meet load, perform economic dispatch only on must-run units\n4. Otherwise, activate additional units based on cost efficiency considering startup costs\n5. Perform constrained economic dispatch on committed units to match load exactly\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    committed = [False] * num_units\n    p_outputs = [0.0] * num_units\n    \n    # Identify must-run units\n    must_run = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                committed[i] = True\n                # Set initial output considering ramp down limit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_outputs[i] = p_min\n    \n    # Calculate available capacity from must-run units\n    must_run_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_capacity += p_max\n    \n    # Activate additional units if needed\n    if must_run_capacity < load:\n        # Create candidate list of non-committed units that can be activated\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                if unit['u_i_0'] == 0 and abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    # Calculate effective cost per MW\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']\n                    cost_per_mw = min_cost / unit['p_min_i']\n                    candidates.append((cost_per_mw, i))\n                elif unit['u_i_0'] == 1:\n                    # Already on but not must-run - use marginal cost\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n                    candidates.append((marginal_cost, i))\n        \n        # Sort candidates by cost\n        candidates.sort(key=lambda x: x[0])\n        \n        # Activate cheapest units until we can meet load\n        for cost, idx in candidates:\n            if must_run_capacity >= load:\n                break\n            unit = units_info[idx]\n            committed[idx] = True\n            if unit['u_i_0'] == 0:\n                # Starting up - respect startup ramp\n                p_outputs[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                # Already on - respect ramp up\n                p_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_run_capacity += p_outputs[idx]\n    \n    # Perform economic dispatch to match load exactly\n    total_output = sum(p_outputs)\n    remaining_load = load - total_output\n    \n    # Adjust outputs while respecting constraints\n    while abs(remaining_load) > 1e-6:\n        # Find unit with minimum marginal cost for increase or maximum for decrease\n        best_unit = None\n        best_cost = float('inf') if remaining_load > 0 else float('-inf')\n        \n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                continue\n                \n            current_p = p_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0:  # Need to increase output\n                # Check ramp up and max limits\n                max_p = unit['p_max_i']\n                if unit['u_i_0'] == 1:\n                    max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n                elif unit['u_i_0'] == 0 and committed[i]:\n                    max_p = min(max_p, unit['p_start_i'])\n                \n                if current_p < max_p and marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n            else:  # Need to decrease output\n                # Check ramp down and min limits\n                min_p = unit['p_min_i']\n                if unit['u_i_0'] == 1:\n                    min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                \n                if current_p > min_p and marginal_cost > best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = p_outputs[best_unit]\n        \n        if remaining_load > 0:\n            max_p = unit['p_max_i']\n            if unit['u_i_0'] == 1:\n                max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n            elif unit['u_i_0'] == 0:\n                max_p = min(max_p, unit['p_start_i'])\n            \n            adjustment = min(remaining_load, max_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n        else:\n            min_p = unit['p_min_i']\n            if unit['u_i_0'] == 1:\n                min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n            \n            adjustment = max(remaining_load, min_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n    \n    # Prepare output\n    for i in range(num_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0055684358,
          "gap_price_rate": 0.0091494698,
          "fitness": 0.0073589528
     },
     {
          "name": "refined_adaptive_commitment_dispatch",
          "algorithm": "1. Enhanced unit classification with extended must-run conditions considering shutdown ramp constraints and minimum up/down times\n2. Dynamic feasible power range calculation with improved handling of startup/shutdown ramp limits and current state transitions\n3. Adaptive priority computation using amortized startup costs over minimum up-time and ramp flexibility factors\n4. Bisection-based economic dispatch with ramp-aware lambda convergence and marginal cost sorting\n5. Precision adjustment with constraint-aware corrections for exact load matching\n6. Comprehensive validation against all physical constraints with iterative repair mechanisms\n",
          "code": "import numpy as np\n\ndef refined_adaptive_commitment_dispatch(units_info, load):\n    # Initialize units\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Enhanced unit classification\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if t0[i] < min_up[i] or p0[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if t0[i] > -min_down[i]:\n                must_off[i] = True\n    \n    # Step 2: Calculate dynamic feasible power ranges\n    p_low = np.zeros(n_units)\n    p_high = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            p_low[i] = max(p_min[i], p0[i] - p_down[i])\n            p_high[i] = min(p_max[i], p0[i] + p_up[i])\n        else:\n            p_low[i] = p_min[i]\n            p_high[i] = min(p_max[i], p_start[i])\n    \n    # Commit must-run units\n    committed = must_run.copy()\n    total_min = np.sum(p_low[committed])\n    total_max = np.sum(p_high[committed])\n    \n    # Step 3: Adaptive priority computation\n    priorities = np.full(n_units, np.inf)\n    for i in range(n_units):\n        if not must_run[i] and not must_off[i]:\n            amortized_startup = startup_cost[i] / (min_up[i] * p_min[i]) if u0[i] == 0 else 0\n            marginal_cost = b[i] + 2 * c[i] * p_min[i]\n            ramp_flexibility = (p_high[i] - p_low[i]) / (p_max[i] - p_min[i])\n            priorities[i] = amortized_startup + marginal_cost / (1 + ramp_flexibility)\n    \n    # Commit flexible units by priority\n    flexible_indices = np.argsort(priorities)\n    for idx in flexible_indices:\n        if priorities[idx] == np.inf:\n            continue\n        if total_max < load:\n            committed[idx] = True\n            total_min += p_low[idx]\n            total_max += p_high[idx]\n        else:\n            break\n    \n    # Step 4: Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    def compute_outputs(lmbda):\n        p_out = np.zeros(n_units)\n        for i in range(n_units):\n            if committed[i]:\n                p_desired = (lmbda - b[i]) / (2 * c[i])\n                p_out[i] = np.clip(p_desired, p_low[i], p_high[i])\n        return p_out\n    \n    for _ in range(100):  # Bisection iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_mid = compute_outputs(lambda_mid)\n        total_power = np.sum(p_mid)\n        \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    p_opt = compute_outputs(lambda_mid)\n    \n    # Step 5: Precision adjustment\n    total_power = np.sum(p_opt[committed])\n    deficit = load - total_power\n    \n    while abs(deficit) > 1e-6:\n        marginal_costs = []\n        for i in range(n_units):\n            if committed[i]:\n                if deficit > 0 and p_opt[i] < p_high[i]:\n                    marginal_costs.append(b[i] + 2 * c[i] * p_opt[i])\n                elif deficit < 0 and p_opt[i] > p_low[i]:\n                    marginal_costs.append(b[i] + 2 * c[i] * p_opt[i])\n                else:\n                    marginal_costs.append(np.inf)\n            else:\n                marginal_costs.append(np.inf)\n        \n        if np.all(np.isinf(marginal_costs)):\n            break\n        \n        if deficit > 0:\n            idx = np.argmin(marginal_costs)\n            p_opt[idx] = min(p_opt[idx] + deficit, p_high[idx])\n        else:\n            idx = np.argmax(marginal_costs)\n            p_opt[idx] = max(p_opt[idx] + deficit, p_low[idx])\n        \n        total_power = np.sum(p_opt[committed])\n        deficit = load - total_power\n    \n    # Step 6: Constraint validation and repair\n    for i in range(n_units):\n        if committed[i]:\n            u[i] = 1\n            p[i] = p_opt[i]\n            # Validate ramp constraints\n            if u0[i] == 1:\n                if p[i] - p0[i] > p_up[i]:\n                    p[i] = p0[i] + p_up[i]\n                elif p0[i] - p[i] > p_down[i]:\n                    p[i] = p0[i] - p_down[i]\n            else:\n                if p[i] > p_start[i]:\n                    p[i] = p_start[i]\n        else:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.vstack((u, p))",
          "from": "mutation",
          "gap_power_rate": 0.0054190663,
          "gap_price_rate": 0.0093540565,
          "fitness": 0.0073865614
     },
     {
          "name": "refined_adaptive_priority_bisection",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories considering minimum up/down times and shutdown ramp constraints\n2. Calculate dynamic feasible power ranges incorporating ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at adjusted minimum outputs considering ramp constraints\n4. Compute adaptive priorities for flexible units using enhanced cost model combining incremental cost, amortized startup cost, and ramp flexibility\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform constrained economic dispatch using improved bisection method with ramp-aware lambda optimization\n7. Execute precision adjustment using marginal cost sorting for exact load matching\n8. Validate solution against all physical constraints with corrective measures\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_priority_bisection(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    u_prev = np.array([unit['u_i_0'] for unit in units_info])\n    t_prev = np.array([unit['t_i_0'] for unit in units_info])\n    p_prev = np.array([unit['p_i_0'] for unit in units_info])\n    \n    # Step 1: Classify units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if t_prev[i] > -min_down[i]:\n                must_off[i] = True\n    \n    # Step 2: Calculate feasible ranges\n    p_low = np.zeros(n_units)\n    p_high = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if must_off[i]:\n            p_low[i] = 0\n            p_high[i] = 0\n            continue\n            \n        if u_prev[i] == 1:\n            p_low[i] = max(p_min[i], p_prev[i] - p_down[i])\n            p_high[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:\n            p_low[i] = p_min[i]\n            p_high[i] = min(p_max[i], p_start[i])\n            \n        if must_run[i]:\n            p_low[i] = max(p_low[i], p_min[i])\n    \n    # Initialize commitments\n    committed = must_run.copy()\n    p_current = np.where(committed, p_low, 0)\n    \n    # Step 3: Commit must-run units\n    total_min = np.sum(p_current)\n    total_max = np.sum(np.where(committed, p_high, 0))\n    \n    # Step 4: Compute priorities for flexible units\n    flexible = ~(must_run | must_off)\n    priorities = np.full(n_units, np.inf)\n    \n    for i in np.where(flexible)[0]:\n        if u_prev[i] == 1:\n            cost = b[i] + 2*c[i]*p_min[i]\n        else:\n            amortized_startup = startup_cost[i] / (p_min[i] * max(1, min_up[i]))\n            cost = (b[i] + 2*c[i]*p_min[i]) + amortized_startup\n        \n        ramp_flex = (p_high[i] - p_low[i]) / (p_high[i] + 1e-8)\n        priorities[i] = cost / (1 + 0.1 * ramp_flex)\n    \n    # Step 5: Commit flexible units\n    flexible_indices = np.argsort(priorities)\n    \n    for i in flexible_indices:\n        if not flexible[i]:\n            continue\n        if total_min <= load <= total_max:\n            break\n            \n        committed[i] = True\n        total_min += p_low[i]\n        total_max += p_high[i]\n    \n    # Step 6: Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 5000  # Sufficiently high value\n    \n    for _ in range(50):  # Bisection iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in np.where(committed)[0]:\n            p_dispatch = (lambda_mid - b[i]) / (2 * c[i] + 1e-8)\n            p_dispatch = np.clip(p_dispatch, p_low[i], p_high[i])\n            total_p += p_dispatch\n        \n        if abs(total_p - load) < 1e-6:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Calculate final dispatch\n    for i in np.where(committed)[0]:\n        p[i] = (lambda_mid - b[i]) / (2 * c[i] + 1e-8)\n        p[i] = np.clip(p[i], p_low[i], p_high[i])\n    \n    # Step 7: Precision adjustment\n    total_p = np.sum(p)\n    margin = load - total_p\n    \n    if abs(margin) > 1e-6:\n        marginal_costs = b + 2*c*p\n        adjust_order = np.argsort(marginal_costs) if margin > 0 else np.argsort(-marginal_costs)\n        \n        for i in adjust_order:\n            if not committed[i]:\n                continue\n                \n            if margin > 0:\n                available = p_high[i] - p[i]\n                adjust = min(margin, available)\n            else:\n                available = p[i] - p_low[i]\n                adjust = max(margin, -available)\n                \n            p[i] += adjust\n            margin -= adjust\n            \n            if abs(margin) < 1e-6:\n                break\n    \n    # Set commitment states\n    u[committed] = 1\n    \n    return np.vstack([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054190663,
          "gap_price_rate": 0.0098774065,
          "fitness": 0.0076482364
     },
     {
          "name": "enhanced_adaptive_priority_bisection",
          "algorithm": "1. Enhanced unit classification with extended must-run conditions considering shutdown ramp constraints and minimum up/down times\n2. Dynamic feasible power range calculation with improved handling of startup/shutdown ramp limits and current state transitions\n3. Adaptive priority computation using amortized startup costs over minimum up-time and ramp flexibility factors\n4. Bisection-based economic dispatch with ramp-aware lambda convergence and marginal cost sorting\n5. Precision adjustment with constraint-aware corrections for exact load matching\n6. Comprehensive validation against all physical constraints with iterative repair mechanisms\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_priority_bisection(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Precompute feasible ranges and classifications\n    must_run = []\n    must_off = []\n    flexible = []\n    p_min_cur = np.zeros(n_units)\n    p_max_cur = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        # Calculate current feasible range\n        if u0 == 1:\n            p_min_cur[i] = max(p_min, p0 - p_down)\n            p_max_cur[i] = min(p_max, p0 + p_up)\n            if t0 < min_up or p0 > p_shut:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            p_min_cur[i] = p_min\n            p_max_cur[i] = p_start\n            if abs(t0) < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Commit must-run units\n    for i in must_run:\n        u[i] = 1\n        p[i] = p_min_cur[i]\n    \n    # Compute priorities for flexible units\n    priorities = []\n    for i in flexible:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            flex_factor = (unit['p_up_i'] + unit['p_down_i']) / (unit['p_max_i'] - unit['p_min_i'] + 1e-10)\n            priority = inc_cost - 0.1 * flex_factor\n        else:\n            amortized_startup = unit['s_i'] / (unit['t_on_min_i'] * unit['p_min_i'] + 1e-10)\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            flex_factor = (unit['p_up_i'] + unit['p_down_i']) / (unit['p_max_i'] - unit['p_min_i'] + 1e-10)\n            priority = inc_cost + amortized_startup - 0.1 * flex_factor\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    flexible_sorted = [idx for _, idx in priorities]\n    \n    # Commit flexible units\n    total_min = sum(p[i] for i in must_run)\n    total_max = sum(p_max_cur[i] for i in must_run)\n    \n    for i in flexible_sorted:\n        if total_max < load:\n            u[i] = 1\n            p[i] = p_min_cur[i]\n            total_min += p_min_cur[i]\n            total_max += p_max_cur[i]\n        else:\n            break\n    \n    committed = [i for i in range(n_units) if u[i] == 1]\n    \n    # Economic dispatch using bisection\n    low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min_cur[i] for i in committed)\n    high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_max_cur[i] for i in committed)\n    \n    for _ in range(100):\n        lam = (low + high) / 2\n        total_p = 0\n        for i in committed:\n            p_i = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'] + 1e-10)\n            p_i = max(p_min_cur[i], min(p_max_cur[i], p_i))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            low = lam\n        else:\n            high = lam\n    \n    # Set outputs based on final lambda\n    for i in committed:\n        p[i] = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'] + 1e-10)\n        p[i] = max(p_min_cur[i], min(p_max_cur[i], p[i]))\n    \n    # Precision adjustment\n    total_p = sum(p[i] for i in committed)\n    mismatch = load - total_p\n    marginal_costs = []\n    \n    for i in committed:\n        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n        if mismatch > 0:\n            headroom = p_max_cur[i] - p[i]\n            if headroom > 1e-5:\n                marginal_costs.append((marginal_cost, i, headroom))\n        else:\n            headroom = p[i] - p_min_cur[i]\n            if headroom > 1e-5:\n                marginal_costs.append((marginal_cost, i, headroom))\n    \n    if mismatch > 0:\n        marginal_costs.sort(key=lambda x: x[0])\n    else:\n        marginal_costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i, headroom in marginal_costs:\n        adjust = min(abs(mismatch), headroom)\n        if mismatch > 0:\n            p[i] += adjust\n        else:\n            p[i] -= adjust\n        mismatch -= adjust if mismatch > 0 else -adjust\n        if abs(mismatch) < 1e-5:\n            break\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0056072148,
          "gap_price_rate": 0.0098285713,
          "fitness": 0.0077178931
     },
     {
          "name": "adaptive_priority_bisection_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
          "code": "import numpy as np\n\ndef adaptive_priority_bisection_heuristic(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        \n        # Calculate feasible output range\n        if u0 == 1:  # Previously on\n            min_out = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            # Must-run check\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously off\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            # Must-off check\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = min_out\n        feasible_max[i] = max_out\n    \n    # Commit must-run units\n    committed = set(must_run)\n    total_min = sum(feasible_min[i] for i in committed)\n    total_max = sum(feasible_max[i] for i in committed)\n    \n    # Calculate adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            # Marginal cost at minimum output\n            priority = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        else:\n            # Full average cost including startup\n            avg_cost = (unit['s_i'] + unit['b_i'] * feasible_min[i] + \n                       unit['c_i'] * feasible_min[i]**2) / feasible_min[i]\n            priority = avg_cost\n        # Adjust priority based on ramp capability\n        priority /= (unit['p_up_i'] + 1e-6)\n        priorities.append((priority, i))\n    \n    priorities.sort(key=lambda x: x[0])\n    \n    # Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Economic dispatch using bisection\n    lambda_low = 0\n    lambda_high = 0\n    for i in committed:\n        unit = units[i]\n        cost_at_min = unit['b_i'] + 2 * unit['c_i'] * feasible_min[i]\n        cost_at_max = unit['b_i'] + 2 * unit['c_i'] * feasible_max[i]\n        lambda_low = min(lambda_low, cost_at_min)\n        lambda_high = max(lambda_high, cost_at_max)\n    \n    # Bisection iteration\n    for _ in range(100):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        for i in committed:\n            unit = units[i]\n            p = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p = max(feasible_min[i], min(feasible_max[i], p))\n            total_power += p\n        \n        if total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        if abs(total_power - load) < 1e-6:\n            break\n    \n    # Set outputs based on final lambda\n    outputs = np.zeros(n_units)\n    for i in committed:\n        unit = units[i]\n        p = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p = max(feasible_min[i], min(feasible_max[i], p))\n        outputs[i] = p\n    \n    # Adjust for exact load matching\n    total_output = sum(outputs)\n    diff = load - total_output\n    if abs(diff) > 1e-6:\n        # Create list of units to adjust\n        adjust_units = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * outputs[i]\n            adjust_units.append((marginal_cost, i, outputs[i]))\n        \n        if diff > 0:\n            adjust_units.sort(key=lambda x: x[0])\n            for cost, i, p in adjust_units:\n                if diff <= 0:\n                    break\n                max_add = feasible_max[i] - p\n                add = min(diff, max_add)\n                outputs[i] += add\n                diff -= add\n        else:\n            adjust_units.sort(key=lambda x: x[0], reverse=True)\n            for cost, i, p in adjust_units:\n                if diff >= 0:\n                    break\n                max_sub = p - feasible_min[i]\n                sub = min(-diff, max_sub)\n                outputs[i] -= sub\n                diff += sub\n    \n    # Set commitment states\n    for i in range(n_units):\n        if outputs[i] > 0:\n            schedules[0, i] = 1\n            schedules[1, i] = outputs[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0039112517,
          "gap_price_rate": 0.0115797324,
          "fitness": 0.007745492
     }
]