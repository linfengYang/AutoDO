{
     "name": "enhanced_adaptive_priority_dispatch",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. Compute adaptive priorities for flexible units using full incremental cost (including startup costs when applicable) and ramp capabilities\n5. Commit flexible units in adaptive priority order until load can be met while respecting minimum generation constraints\n6. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n7. Adjust commitments and outputs using marginal cost prioritization to ensure exact load matching\n8. Validate final solution against all physical constraints\n\n",
     "code": "import numpy as np\n\ndef enhanced_adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Step 1: Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        # Calculate feasible power range considering ramp constraints\n        if unit['u_i_0'] == 1:  # Previously on\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check minimum up time constraint\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.append(i)\n            elif unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously off\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            # Check minimum down time constraint\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = p_min\n        feasible_max[i] = p_max\n    \n    # Step 2: Commit must-run units\n    committed = set(must_run)\n    total_min = 0\n    total_max = 0\n    \n    for i in must_run:\n        schedules[0][i] = 1\n        schedules[1][i] = feasible_min[i]\n        total_min += feasible_min[i]\n        total_max += feasible_max[i]\n    \n    # Step 3: Compute adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        if units_info[i]['u_i_0'] == 0:\n            # Include startup cost if unit was off\n            full_cost = (units_info[i]['s_i'] + \n                         units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        else:\n            full_cost = (units_info[i]['a_i'] + \n                         units_info[i]['b_i'] * feasible_min[i] + \n                         units_info[i]['c_i'] * feasible_min[i]**2)\n        \n        # Adjust priority based on ramp capabilities\n        ramp_factor = (feasible_max[i] - feasible_min[i]) / max(1, units_info[i]['p_up_i'])\n        priority = full_cost / (feasible_min[i] + 1e-6) * (1 - 0.1 * ramp_factor)\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            schedules[0][i] = 1\n            schedules[1][i] = feasible_min[i]\n            total_min += feasible_min[i]\n            total_max += feasible_max[i]\n        else:\n            break\n    \n    # Step 5: Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Maximum iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units_info[i]\n            # Calculate unconstrained output\n            p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n            # Constrain within feasible range\n            p_dispatch = max(feasible_min[i], min(feasible_max[i], p_star))\n            total_power += p_dispatch\n        \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final dispatch values\n    for i in committed:\n        unit = units_info[i]\n        p_star = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else feasible_max[i]\n        schedules[1][i] = max(feasible_min[i], min(feasible_max[i], p_star))\n    \n    # Step 6: Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    while abs(diff) > 1e-6:\n        # Find units that can adjust output\n        adjustable = []\n        for i in committed:\n            if diff > 0 and schedules[1][i] < feasible_max[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n            elif diff < 0 and schedules[1][i] > feasible_min[i]:\n                adjustable.append((units_info[i]['b_i'] + 2*units_info[i]['c_i']*schedules[1][i], i))\n        \n        if not adjustable:\n            break\n        \n        # Sort by marginal cost (ascending for increasing, descending for decreasing)\n        adjustable.sort(key=lambda x: x[0], reverse=diff < 0)\n        \n        # Adjust the most suitable unit\n        i = adjustable[0][1]\n        if diff > 0:\n            adjust = min(diff, feasible_max[i] - schedules[1][i])\n        else:\n            adjust = max(diff, feasible_min[i] - schedules[1][i])\n        \n        schedules[1][i] += adjust\n        diff -= adjust\n    \n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.0054285366,
     "gap_price_rate": 0.0087069616,
     "fitness": 0.0070677491
}