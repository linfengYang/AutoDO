{
     "name": "refined_enhanced_adaptive_priority_dispatch",
     "algorithm": "1. Enhanced unit classification considering startup/shutdown ramp constraints and extended must-run conditions\n2. Dynamic feasible power range calculation with improved ramp rate handling\n3. Adaptive priority computation with amortized startup costs and ramp flexibility factors\n4. Bisection-based economic dispatch with enhanced lambda convergence\n5. Precision adjustment using marginal cost sorting with constraint-aware corrections\n6. Comprehensive validation with iterative repair for constraint violations\n\n",
     "code": "import numpy as np\n\ndef refined_enhanced_adaptive_priority_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Step 1: Enhanced unit classification\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        # Extended must-run conditions\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or \n             unit['p_i_0'] > unit['p_shut_i'])):\n            must_run.append(i)\n        # Enhanced must-off conditions\n        elif (unit['u_i_0'] == 0 and \n              unit['t_i_0'] > -unit['t_off_min_i']):\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Step 2: Dynamic feasible power range calculation\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        if i in must_run:\n            if unit['u_i_0'] == 0:  # Starting up\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Already online\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in must_off:\n            min_p[i] = 0\n            max_p[i] = 0\n        else:  # Flexible units\n            if unit['u_i_0'] == 1:\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 3: Commit must-run units and compute adaptive priorities\n    committed = set(must_run)\n    total_min = sum(min_p[i] for i in committed)\n    total_max = sum(max_p[i] for i in committed)\n    \n    # Calculate adaptive priorities for flexible units\n    priorities = []\n    for i in flexible:\n        unit = units[i]\n        if unit['u_i_0'] == 0:\n            # Amortize startup cost over minimum uptime\n            amortized_cost = unit['s_i'] / max(1, unit['t_on_min_i'])\n            full_cost = (amortized_cost + unit['a_i'] + \n                         unit['b_i'] * min_p[i] + \n                         unit['c_i'] * min_p[i]**2)\n            # Add ramp flexibility factor\n            ramp_factor = 1 + (unit['p_up_i'] / unit['p_max_i'])\n            priority = full_cost * ramp_factor / min_p[i] if min_p[i] > 0 else float('inf')\n        else:\n            # Use marginal cost for already online units\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_p[i]\n            ramp_factor = 1 + (unit['p_up_i'] / unit['p_max_i'])\n            priority = marginal_cost * ramp_factor\n        priorities.append((priority, i))\n    \n    # Sort by priority (lower is better)\n    priorities.sort(key=lambda x: x[0])\n    \n    # Step 4: Commit flexible units by priority\n    for priority, i in priorities:\n        if total_max < load:\n            committed.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            break\n    \n    # Step 5: Enhanced bisection economic dispatch\n    lambda_low = 0\n    lambda_high = 10000  # Sufficiently high value\n    \n    for _ in range(100):  # Max iterations\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i']) if unit['c_i'] > 0 else max_p[i]\n            # Constrain by feasible range\n            p[i] = np.clip(p_uncon, min_p[i], max_p[i])\n            total_gen += p[i]\n        \n        if abs(total_gen - load) < 1e-6:\n            break\n        elif total_gen < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Step 6: Precision adjustment with marginal cost sorting\n    current_gen = sum(p[i] for i in committed)\n    deficit = load - current_gen\n    \n    if abs(deficit) > 1e-6:\n        # Create list of adjustable units with marginal costs\n        adjustable = []\n        for i in committed:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n            adjustable.append((marginal_cost, i))\n        \n        adjustable.sort(key=lambda x: x[0], reverse=deficit < 0)\n        \n        # Adjust outputs\n        for mc, i in adjustable:\n            if deficit > 0:  # Need more generation\n                add_capacity = min(deficit, max_p[i] - p[i])\n                p[i] += add_capacity\n                deficit -= add_capacity\n            else:  # Need less generation\n                reduce_capacity = min(-deficit, p[i] - min_p[i])\n                p[i] -= reduce_capacity\n                deficit += reduce_capacity\n            \n            if abs(deficit) < 1e-6:\n                break\n    \n    # Step 7: Final validation and constraint enforcement\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.array([u, p])",
     "from": "mutation",
     "gap_power_rate": 0.0043993514,
     "gap_price_rate": 0.0091072805,
     "fitness": 0.0067533159
}