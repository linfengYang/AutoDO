{
     "name": "commit_units_heuristic",
     "algorithm": "1. Identify must-run units based on minimum up/down times and shutdown ramp constraints\n2. Calculate available capacity from must-run units considering ramp limits\n3. If must-run units can meet load, perform economic dispatch only on must-run units\n4. Otherwise, activate additional units based on cost efficiency considering startup costs\n5. Perform constrained economic dispatch on committed units to match load exactly\n6. Ensure all physical constraints are satisfied throughout the process\n\n",
     "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    committed = [False] * num_units\n    p_outputs = [0.0] * num_units\n    \n    # Identify must-run units\n    must_run = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                committed[i] = True\n                # Set initial output considering ramp down limit\n                p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p_outputs[i] = p_min\n    \n    # Calculate available capacity from must-run units\n    must_run_capacity = 0\n    for i in must_run:\n        unit = units_info[i]\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_run_capacity += p_max\n    \n    # Activate additional units if needed\n    if must_run_capacity < load:\n        # Create candidate list of non-committed units that can be activated\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                if unit['u_i_0'] == 0 and abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    # Calculate effective cost per MW\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2 + unit['s_i']\n                    cost_per_mw = min_cost / unit['p_min_i']\n                    candidates.append((cost_per_mw, i))\n                elif unit['u_i_0'] == 1:\n                    # Already on but not must-run - use marginal cost\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i_0']\n                    candidates.append((marginal_cost, i))\n        \n        # Sort candidates by cost\n        candidates.sort(key=lambda x: x[0])\n        \n        # Activate cheapest units until we can meet load\n        for cost, idx in candidates:\n            if must_run_capacity >= load:\n                break\n            unit = units_info[idx]\n            committed[idx] = True\n            if unit['u_i_0'] == 0:\n                # Starting up - respect startup ramp\n                p_outputs[idx] = min(unit['p_start_i'], unit['p_max_i'])\n            else:\n                # Already on - respect ramp up\n                p_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_run_capacity += p_outputs[idx]\n    \n    # Perform economic dispatch to match load exactly\n    total_output = sum(p_outputs)\n    remaining_load = load - total_output\n    \n    # Adjust outputs while respecting constraints\n    while abs(remaining_load) > 1e-6:\n        # Find unit with minimum marginal cost for increase or maximum for decrease\n        best_unit = None\n        best_cost = float('inf') if remaining_load > 0 else float('-inf')\n        \n        for i, unit in enumerate(units_info):\n            if not committed[i]:\n                continue\n                \n            current_p = p_outputs[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            \n            if remaining_load > 0:  # Need to increase output\n                # Check ramp up and max limits\n                max_p = unit['p_max_i']\n                if unit['u_i_0'] == 1:\n                    max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n                elif unit['u_i_0'] == 0 and committed[i]:\n                    max_p = min(max_p, unit['p_start_i'])\n                \n                if current_p < max_p and marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n            else:  # Need to decrease output\n                # Check ramp down and min limits\n                min_p = unit['p_min_i']\n                if unit['u_i_0'] == 1:\n                    min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n                \n                if current_p > min_p and marginal_cost > best_cost:\n                    best_cost = marginal_cost\n                    best_unit = i\n        \n        if best_unit is None:\n            break\n            \n        unit = units_info[best_unit]\n        current_p = p_outputs[best_unit]\n        \n        if remaining_load > 0:\n            max_p = unit['p_max_i']\n            if unit['u_i_0'] == 1:\n                max_p = min(max_p, unit['p_i_0'] + unit['p_up_i'])\n            elif unit['u_i_0'] == 0:\n                max_p = min(max_p, unit['p_start_i'])\n            \n            adjustment = min(remaining_load, max_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n        else:\n            min_p = unit['p_min_i']\n            if unit['u_i_0'] == 1:\n                min_p = max(min_p, unit['p_i_0'] - unit['p_down_i'])\n            \n            adjustment = max(remaining_load, min_p - current_p)\n            p_outputs[best_unit] += adjustment\n            remaining_load -= adjustment\n    \n    # Prepare output\n    for i in range(num_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i] if committed[i] else 0\n    \n    return schedules",
     "from": null,
     "gap_power_rate": 0.0055684358,
     "gap_price_rate": 0.0091494698,
     "fitness": 0.0073589528
}