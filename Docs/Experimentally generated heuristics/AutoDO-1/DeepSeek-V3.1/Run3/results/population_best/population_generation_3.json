{
     "name": "adaptive_commitment_dispatch",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units using adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
     "code": "import numpy as np\n\ndef adaptive_commitment_dispatch(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    schedules = np.zeros((2, n_units))\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Check minimum up/down time constraints\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Calculate feasible output range\n        if u_i0 == 1:\n            p_min = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n            \n        unit['p_min_feas'] = p_min\n        unit['p_max_feas'] = p_max\n\n    # Commit must-run units\n    total_min = 0\n    total_max = 0\n    committed = set(must_run)\n    \n    for i in must_run:\n        unit = units[i]\n        schedules[0, i] = 1\n        schedules[1, i] = unit['p_min_feas']\n        total_min += unit['p_min_feas']\n        total_max += unit['p_max_feas']\n        \n    # Commit flexible units if needed\n    if total_min > load:\n        # Decommit most expensive flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_feas']\n            flexible_costs.append((i, marginal_cost))\n        \n        flexible_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in flexible_costs:\n            if total_min <= load:\n                break\n            unit = units[i]\n            total_min -= unit['p_min_feas']\n            total_max -= unit['p_max_feas']\n            committed.discard(i)\n            \n    elif total_max < load:\n        # Commit additional flexible units\n        flexible_costs = []\n        for i in flexible:\n            unit = units[i]\n            full_cost = (unit['s_i'] if unit['u_i_0'] == 0 else 0) + \\\n                       unit['a_i'] + unit['b_i'] * unit['p_min_feas'] + \\\n                       unit['c_i'] * unit['p_min_feas'] ** 2\n            cost_per_mw = full_cost / unit['p_min_feas']\n            flexible_costs.append((i, cost_per_mw))\n        \n        flexible_costs.sort(key=lambda x: x[1])\n        \n        for i, _ in flexible_costs:\n            if total_max >= load:\n                break\n            unit = units[i]\n            committed.add(i)\n            total_min += unit['p_min_feas']\n            total_max += unit['p_max_feas']\n\n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # Sufficiently high value\n    \n    for _ in range(100):  # Iteration limit\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        \n        for i in committed:\n            unit = units[i]\n            p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            p_dispatch = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n            total_power += p_dispatch\n            \n        if abs(total_power - load) < 1e-6:\n            break\n        elif total_power < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n\n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_opt = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        schedules[0, i] = 1\n        schedules[1, i] = np.clip(p_opt, unit['p_min_feas'], unit['p_max_feas'])\n\n    # Adjust for exact load matching\n    total_output = np.sum(schedules[1])\n    diff = load - total_output\n    \n    if diff != 0:\n        # Create priority list based on marginal cost\n        marginal_costs = []\n        for i in committed:\n            unit = units[i]\n            mc = unit['b_i'] + 2 * unit['c_i'] * schedules[1, i]\n            marginal_costs.append((i, mc))\n        \n        if diff > 0:\n            marginal_costs.sort(key=lambda x: x[1])\n        else:\n            marginal_costs.sort(key=lambda x: x[1], reverse=True)\n            \n        for i, _ in marginal_costs:\n            if abs(diff) < 1e-6:\n                break\n            unit = units[i]\n            current_p = schedules[1, i]\n            if diff > 0:\n                new_p = min(current_p + diff, unit['p_max_feas'])\n            else:\n                new_p = max(current_p + diff, unit['p_min_feas'])\n            diff -= (new_p - current_p)\n            schedules[1, i] = new_p\n\n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.0054285366,
     "gap_price_rate": 0.0087811081,
     "fitness": 0.0071048223
}