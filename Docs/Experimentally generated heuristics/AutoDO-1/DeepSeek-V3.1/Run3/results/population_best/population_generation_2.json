{
     "name": "improved_commit_units_heuristic",
     "algorithm": "1. Classify units into must-run, must-off, and flexible categories based on minimum up/down times and shutdown ramp constraints\n2. Calculate feasible power ranges for each unit considering ramp limits, startup/shutdown constraints, and current state\n3. Commit must-run units at their minimum feasible output considering ramp constraints\n4. If must-run units cannot meet load, activate flexible units by adaptive full-cost priority (startup cost + production cost at minimum output)\n5. Perform economic dispatch using bisection method to find optimal lambda while respecting output limits and ramp constraints\n6. Adjust commitments and outputs to ensure exact load matching and constraint satisfaction\n7. Validate final solution against all physical constraints\n",
     "code": "import numpy as np\n\ndef improved_commit_units_heuristic(units_info, load):\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Classify units and calculate feasible ranges\n    must_run = []\n    must_off = []\n    flexible = []\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units):\n        # Calculate feasible power range\n        if unit['u_i_0'] == 1:  # previously online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check if must-run due to min up-time or shutdown ramp\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # previously offline\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            # Check if must-off due to min down-time\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n        \n        feasible_min[i] = min_p\n        feasible_max[i] = max_p\n    \n    # Commit must-run units\n    committed = set(must_run)\n    for i in must_run:\n        u[i] = 1\n        p[i] = feasible_min[i]  # start at minimum\n    \n    # Calculate current total generation\n    total_gen = np.sum(p)\n    total_max = np.sum([feasible_max[i] for i in committed])\n    total_min = np.sum([feasible_min[i] for i in committed])\n    \n    # Commit flexible units if needed\n    if total_max < load:\n        # Calculate full cost for flexible units\n        costs = []\n        for i in flexible:\n            if i in must_off:\n                continue\n            min_cost = (units[i]['a_i'] + units[i]['b_i'] * feasible_min[i] + \n                        units[i]['c_i'] * feasible_min[i]**2)\n            full_cost = min_cost + units[i]['s_i'] if units[i]['u_i_0'] == 0 else min_cost\n            costs.append((full_cost / feasible_min[i], i))\n        \n        # Sort by cost per MW\n        costs.sort(key=lambda x: x[0])\n        \n        # Commit units until load can be met\n        for _, i in costs:\n            if total_max >= load:\n                break\n            if i not in committed:\n                committed.add(i)\n                u[i] = 1\n                p[i] = feasible_min[i]\n                total_max += feasible_max[i]\n                total_min += feasible_min[i]\n    \n    # Decommit units if minimum generation exceeds load\n    if total_min > load:\n        # Sort committed units by marginal cost at minimum output\n        costs = []\n        for i in committed:\n            if i in must_run:\n                continue\n            marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * feasible_min[i]\n            costs.append((marg_cost, i))\n        \n        costs.sort(reverse=True, key=lambda x: x[0])\n        \n        # Decommit units until feasible\n        for _, i in costs:\n            if total_min <= load:\n                break\n            committed.discard(i)\n            u[i] = 0\n            p[i] = 0\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n    \n    # Economic dispatch using bisection method\n    lambda_low = 0\n    lambda_high = 1000  # sufficiently high value\n    \n    for _ in range(100):  # 100 iterations for convergence\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        \n        for i in committed:\n            unit = units[i]\n            # Calculate unconstrained output\n            p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n            # Constrain output\n            p_i = max(feasible_min[i], min(feasible_max[i], p_uncon))\n            total_p += p_i\n        \n        if abs(total_p - load) < 1e-5:\n            break\n        elif total_p < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Set final outputs\n    for i in committed:\n        unit = units[i]\n        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n        p[i] = max(feasible_min[i], min(feasible_max[i], p_uncon))\n    \n    # Adjust to exactly match load\n    total_p = np.sum(p)\n    diff = load - total_p\n    \n    while abs(diff) > 1e-5:\n        # Find unit to adjust\n        if diff > 0:\n            # Increase output of unit with lowest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] < feasible_max[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = min(feasible_max[i], p[i] + min(diff, feasible_max[i] - p[i]))\n        else:\n            # Decrease output of unit with highest marginal cost\n            marg_costs = []\n            for i in committed:\n                if p[i] > feasible_min[i]:\n                    marg_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n                    marg_costs.append((marg_cost, i))\n            if not marg_costs:\n                break\n            marg_costs.sort(reverse=True, key=lambda x: x[0])\n            i = marg_costs[0][1]\n            p[i] = max(feasible_min[i], p[i] + max(diff, feasible_min[i] - p[i]))\n        \n        total_p = np.sum(p)\n        diff = load - total_p\n    \n    return np.array([u, p])",
     "from": "mutation",
     "gap_power_rate": 0.0054285377,
     "gap_price_rate": 0.0087811083,
     "fitness": 0.007104823
}