[
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and flexible (both online/offline)\n2. For must-on units, compute min/max output bounds based on current state and ramp constraints\n3. Handle three cases:\n   - Case 1 (load between must-on min/max): Keep only must-on units, turn off flexible units\n   - Case 2 (load > must-on max): Keep online flexible units, start additional offline units based on cost-effectiveness until load can be met\n   - Case 3 (load < must-on min): Must-on units at minimum, turn off all flexible units\n4. Economic dispatch for all online units:\n   a. Start at min output bounds\n   b. Sort units by increasing marginal cost\n   c. Increase output of cheapest units until load met or capacity exhausted\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    \n    # Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flex_online_indices = []\n    flex_offline_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flex_online_indices.append(i)\n        else:\n            t_off_abs = abs(unit['t_i_0'])\n            if t_off_abs < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flex_offline_indices.append(i)\n    \n    # Set must-off units to off\n    for i in must_off_indices:\n        u[i] = 0\n        p[i] = 0\n    \n    # Compute bounds for must-on units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_on_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        total_min_must += min_bound\n        total_max_must += max_bound\n        u[i] = 1\n    \n    # Initialize online set with must-on units\n    online_set = set(must_on_indices)\n    \n    if total_min_must <= load <= total_max_must:\n        # Case 1: Only must-on units needed\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    elif load > total_max_must:\n        # Case 2: Need additional units\n        current_capacity = total_max_must\n        deficit = load - total_max_must\n        \n        # Keep flexible online units\n        for i in flex_online_indices:\n            u[i] = 1\n            min_b = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_b = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            min_bounds[i] = min_b\n            max_bounds[i] = max_b\n            current_capacity += max_b\n            online_set.add(i)\n        \n        # Calculate remaining deficit\n        deficit = max(0, load - current_capacity)\n        started_units = []\n        \n        if deficit > 0:\n            # Sort offline flex by cost per MW at min output\n            cost_per_mw = []\n            for i in flex_offline_indices:\n                unit = units_info[i]\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n                cost_per_mw.append(cost / unit['p_min_i'])\n            sorted_indices = [i for _, i in sorted(zip(cost_per_mw, flex_offline_indices))]\n            \n            # Start most economical units first\n            for i in sorted_indices:\n                if deficit <= 0:\n                    break\n                u[i] = 1\n                min_bounds[i] = units_info[i]['p_min_i']\n                max_b = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                max_bounds[i] = max_b\n                online_set.add(i)\n                started_units.append(i)\n                current_capacity += max_b\n                deficit = load - current_capacity\n    \n    else:\n        # Case 3: Load < must-on minimum\n        for i in must_on_indices:\n            p[i] = min_bounds[i]\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    # Economic dispatch for online units\n    online_indices = sorted(online_set)\n    params = [(units_info[i]['b_i'], units_info[i]['c_i'], min_bounds[i], max_bounds[i]) for i in online_indices]\n    b, c, mins, maxs = zip(*params)\n    b = np.array(b)\n    c = np.array(c)\n    mins = np.array(mins)\n    maxs = np.array(maxs)\n    \n    # Start from min outputs\n    p_online = np.array(mins)\n    total_output = np.sum(p_online)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        # Sort by increasing marginal cost\n        marginal_costs = 2 * c * p_online + b\n        order = np.argsort(marginal_costs)\n        headroom = maxs - mins\n        \n        # Allocate deficit\n        for i in order:\n            alloc = min(deficit, headroom[i])\n            p_online[i] += alloc\n            deficit -= alloc\n            if deficit <= 0:\n                break\n    \n    # Update outputs\n    for idx, val in enumerate(online_indices):\n        p[val] = p_online[idx]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0100041649,
          "fitness": 0.0074306418
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Identify must-on units (if unit was online and hasn't satisfied min up-time or previous output exceeds shutdown capacity) and must-off units (if unit was offline and hasn't satisfied min down-time)\n2. Classify remaining units as optional_offline (online units that can be turned off) and optional_online (offline units that can be turned on)\n3. Compute base min/max output from must-on units considering ramp constraints\n4. Handle three cases:\n   a. Case 1 (load between base min/max): Use only must-on units\n   b. Case 2 (load > base max): Add optional_offline units then start optional_online units by average cost priority until max capacity >= load\n   c. Case 3 (load < base min): Use only must-on units (overproduction unavoidable)\n5. Attempt to turn off expensive optional_offline units in Case 2 if excess capacity exists\n6. For committed units:\n   a. Calculate power bounds considering current state and ramp constraints\n   b. Initialize outputs to minimum bounds\n   c. Distribute residual load to units with lowest marginal cost\n7. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    must_on = []\n    must_off = []\n    optional_offline = []\n    optional_online = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                optional_offline.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                optional_online.append(idx)\n                \n    base_min = 0.0\n    base_max = 0.0\n    committed_set = set(must_on)\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min += min_i\n            base_max += max_i\n            \n    if base_min <= load <= base_max:\n        pass  # Case 1: No change to committed_set\n    elif load > base_max:\n        base_min2 = base_min\n        base_max2 = base_max\n        for idx in optional_offline:\n            unit = units_info[idx]\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min2 += min_i\n            base_max2 += max_i\n            committed_set.add(idx)\n            \n        if load > base_max2:\n            sorted_opt_online = sorted(\n                optional_online,\n                key=lambda idx: (units_info[idx]['a_i'] + \n                              units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                              units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2) + \n                              units_info[idx]['s_i']) / units_info[idx]['p_min_i']\n            )\n            for idx in sorted_opt_online:\n                unit = units_info[idx]\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n                if base_max2 + max_i >= load:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    break\n                else:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    \n        temp_set = committed_set.copy()\n        sorted_opt_offline = sorted(\n            [idx for idx in optional_offline if idx in committed_set],\n            key=lambda idx: (units_info[idx]['a_i'] + \n                           units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                           units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2)) / \n                           units_info[idx]['p_min_i'],\n            reverse=True\n        )\n        current_max = base_max2\n        for idx in sorted_opt_offline:\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if current_max - max_i >= load:\n                committed_set.discard(idx)\n                current_max -= max_i\n    else:\n        pass  # Case 3: Overproduction unavoidable with must-on units\n        \n    min_limits = {}\n    max_limits = {}\n    for idx in committed_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_limits[idx] = min_i\n        max_limits[idx] = max_i\n        p_list[idx] = min_i\n        u_list[idx] = 1\n        \n    total_p = sum(p_list)\n    residual = load - total_p\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed_set:\n            if p_list[idx] < max_limits[idx]:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_list[idx]\n                candidates.append((marginal_cost, idx, max_limits[idx]))\n                \n        while residual > 0 and candidates:\n            candidates_sorted = sorted(candidates, key=lambda x: x[0])\n            best_mc, best_idx, best_max = candidates_sorted[0]\n            headroom = best_max - p_list[best_idx]\n            if headroom <= 0:\n                candidates.remove(candidates_sorted[0])\n                continue\n                \n            if headroom > residual:\n                p_list[best_idx] += residual\n                residual = 0\n            else:\n                p_list[best_idx] += headroom\n                residual -= headroom\n                candidates.remove(candidates_sorted[0])\n    \n    for idx in range(n_units):\n        if idx not in committed_set:\n            u_list[idx] = 0\n            p_list[idx] = 0.0\n            \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Identify must-on units (if unit was online and hasn't satisfied min up-time or previous output exceeds shutdown capacity) and must-off units (if unit was offline and hasn't satisfied min down-time)\n2. Classify remaining units as optional_offline (online units that can be turned off) and optional_online (offline units that can be turned on)\n3. Compute base min/max output from must-on units considering ramp constraints\n4. Handle three cases:\n   a. Case 1 (load between base min/max): Use only must-on units\n   b. Case 2 (load > base max): Add optional_offline units then start optional_online units by average cost priority until max capacity >= load\n   c. Case 3 (load < base min): Use only must-on units (overproduction unavoidable)\n5. Attempt to turn off expensive optional_offline units in Case 2 if excess capacity exists\n6. For committed units:\n   a. Calculate power bounds considering current state and ramp constraints\n   b. Initialize outputs to minimum bounds\n   c. Distribute residual load to units with lowest marginal cost\n7. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    must_on = []\n    must_off = []\n    optional_offline = []\n    optional_online = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                optional_offline.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                optional_online.append(idx)\n                \n    base_min = 0.0\n    base_max = 0.0\n    committed_set = set(must_on)\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min += min_i\n            base_max += max_i\n            \n    if base_min <= load <= base_max:\n        pass  # Case 1: No change to committed_set\n    elif load > base_max:\n        base_min2 = base_min\n        base_max2 = base_max\n        for idx in optional_offline:\n            unit = units_info[idx]\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min2 += min_i\n            base_max2 += max_i\n            committed_set.add(idx)\n            \n        if load > base_max2:\n            sorted_opt_online = sorted(\n                optional_online,\n                key=lambda idx: (units_info[idx]['a_i'] + \n                              units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                              units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2) + \n                              units_info[idx]['s_i']) / units_info[idx]['p_min_i']\n            )\n            for idx in sorted_opt_online:\n                unit = units_info[idx]\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n                if base_max2 + max_i >= load:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    break\n                else:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    \n        temp_set = committed_set.copy()\n        sorted_opt_offline = sorted(\n            [idx for idx in optional_offline if idx in committed_set],\n            key=lambda idx: (units_info[idx]['a_i'] + \n                           units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                           units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2)) / \n                           units_info[idx]['p_min_i'],\n            reverse=True\n        )\n        current_max = base_max2\n        for idx in sorted_opt_offline:\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if current_max - max_i >= load:\n                committed_set.discard(idx)\n                current_max -= max_i\n    else:\n        pass  # Case 3: Overproduction unavoidable with must-on units\n        \n    min_limits = {}\n    max_limits = {}\n    for idx in committed_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_limits[idx] = min_i\n        max_limits[idx] = max_i\n        p_list[idx] = min_i\n        u_list[idx] = 1\n        \n    total_p = sum(p_list)\n    residual = load - total_p\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed_set:\n            if p_list[idx] < max_limits[idx]:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_list[idx]\n                candidates.append((marginal_cost, idx, max_limits[idx]))\n                \n        while residual > 0 and candidates:\n            candidates_sorted = sorted(candidates, key=lambda x: x[0])\n            best_mc, best_idx, best_max = candidates_sorted[0]\n            headroom = best_max - p_list[best_idx]\n            if headroom <= 0:\n                candidates.remove(candidates_sorted[0])\n                continue\n                \n            if headroom > residual:\n                p_list[best_idx] += residual\n                residual = 0\n            else:\n                p_list[best_idx] += headroom\n                residual -= headroom\n                candidates.remove(candidates_sorted[0])\n    \n    for idx in range(n_units):\n        if idx not in committed_set:\n            u_list[idx] = 0\n            p_list[idx] = 0.0\n            \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and free units based on minimum up/down times and shutdown constraints:\n   - Must-on: units that were on (u_i_0=1) and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or previous output exceeds shutdown capacity (p_i_0 > p_shut_i)\n   - Must-off: units that were off (u_i_0=0) and haven't satisfied minimum down-time (-t_i_0 < t_off_min_i)\n   - Free units: remaining units that can be committed or decommitted\n\n2. Set must-off units to off (u_i=0, p_i=0) and must-on units to on (u_i=1)\n\n3. Calculate total minimum and maximum possible output from must-on units considering ramp constraints\n\n4. For underproduction (load > must-on max output):\n   - Sort free units by average production cost at minimum output\n   - Turn on free units in increasing cost order until cumulative max output >= load\n\n5. For overproduction (load < must-on min output), keep free units off\n\n6. Dispatch power:\n   - For each committed unit, compute power bounds based on current state and history\n   - Initialize power outputs to minimum bounds\n   - Incrementally increase output on units with cheapest marginal cost (b_i + 2*c_i*p_i) until meeting load or hitting constraints\n\n7. Return 2D array with commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Make a copy to avoid modifying original data\n    units = [unit.copy() for unit in units_info]\n    \n    # Classify units\n    must_on_units = []\n    must_off_units = []\n    free_units = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # u_i_0 == 0\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Set must-off units\n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Set must-on units and compute bounds\n    min_must = 0\n    max_must = 0\n    for unit in must_on_units:\n        unit['u_i'] = 1\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_must += low\n        max_must += high\n    \n    # Initialize free units to off\n    for unit in free_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Turn on additional free units for underproduction\n    candidate_set = []\n    if load > max_must:\n        # Sort by average cost at minimum power\n        free_units_sorted = sorted(free_units, key=lambda u: (u['s_i'] + u['a_i'] + \n                                  u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'])\n        \n        current_min = min_must\n        current_max = max_must\n        for unit in free_units_sorted:\n            if current_max >= load:\n                break\n            candidate_set.append(unit)\n            unit['u_i'] = 1\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n            current_min += unit['p_min_i']\n            current_max += high_i\n    elif load < min_must:\n        # Overproduction case\n        candidate_set = []\n    \n    # Collect all committed units\n    committed_units = must_on_units + candidate_set\n    for unit in must_off_units + free_units:\n        if unit not in committed_units:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Power dispatch: Compute bounds for each committed unit\n    bounds = []\n    for unit in committed_units:\n        if unit in must_on_units:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_i = unit['p_min_i']\n                high_i = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((low_i, high_i))\n    \n    # Initialize to min outputs\n    total_output = 0\n    for idx, unit in enumerate(committed_units):\n        low_i, high_i = bounds[idx]\n        unit['p_i'] = low_i\n        total_output += low_i\n    \n    # Incremental power allocation\n    remaining = load - total_output\n    if remaining > 0:\n        avail_units = []\n        for idx, unit in enumerate(committed_units):\n            low_i, high_i = bounds[idx]\n            if unit['p_i'] < high_i:\n                # Store (marginal_cost, index, unit_ref)\n                marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units.append((marg_cost, idx, unit))\n        \n        while remaining > 0 and avail_units:\n            avail_units.sort(key=lambda x: x[0])\n            cost, idx, unit = avail_units[0]\n            low_i, high_i = bounds[idx]\n            amount = min(remaining, high_i - unit['p_i'])\n            unit['p_i'] += amount\n            remaining -= amount\n            \n            # Update availability\n            if unit['p_i'] >= high_i:\n                avail_units.pop(0)\n            else:\n                # Update marginal cost for this unit\n                new_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units[0] = (new_cost, idx, unit)\n    \n    # Format results in original unit order\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into four categories:\n   - Forced on: Online units with insufficient min-up-time or output exceeding shutdown ramp limit\n   - Forced off: Offline units with insufficient min-down-time\n   - Flexible online: Online units not in forced categories\n   - Flexible offline: Offline units not in forced categories\n\n2. Calculate must-run capacity:\n   - Compute min/max output for forced-on units considering ramp constraints\n   - If load is between min/max must-run capacity:\n        Commit only forced-on units, turn off flexible units\n   - If load exceeds must-run max capacity:\n        Commit flexible online units\n        Start flexible offline units by cost-effectiveness priority\n        (Priority = (startup_cost + production_cost_at_min_output) / min_output)\n   - If load is below must-run min capacity:\n        Turn off all flexible units (overproduction unavoidable)\n\n3. Economic dispatch for committed units:\n   a. Calculate power bounds per unit based on operational state\n   b. Initialize outputs at min production levels\n   c. If underproducing: Increase output on units with cheapest marginal cost\n   d. If overproducing: Keep min outputs (unavoidable overproduction)\n\n4. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    # Initialize outputs\n    u_current = [0] * n\n    p_current = [0] * n\n    \n    # Step 1: Classify units\n    forced_on_idx = []\n    forced_off_idx = []\n    flex_online_idx = []\n    flex_offline_idx = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_idx.append(i)\n            else:\n                flex_online_idx.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off_idx.append(i)\n            else:\n                flex_offline_idx.append(i)\n    \n    # Step 2: Calculate must-run capacity\n    total_min_forced = 0.0\n    total_max_forced = 0.0\n    min_p_forced = {}\n    max_p_forced = {}\n    \n    for i in forced_on_idx:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_p_forced[i] = min_p\n        max_p_forced[i] = max_p\n        total_min_forced += min_p\n        total_max_forced += max_p\n    \n    # Case handling\n    committed_set = set(forced_on_idx)  # Always include forced-on units\n    \n    if total_min_forced <= load <= total_max_forced:\n        # Case 1: Must-run units can handle load independently\n        for i in flex_online_idx + flex_offline_idx:\n            u_current[i] = 0\n            p_current[i] = 0\n        \n    elif load > total_max_forced:\n        # Case 2: Underproduction\n        # Commit flexible online units\n        min_p_flex_online = {}\n        max_p_flex_online = {}\n        current_max = total_max_forced\n        \n        for i in flex_online_idx:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_p_flex_online[i] = min_p\n            max_p_flex_online[i] = max_p\n            current_max += max_p\n            committed_set.add(i)\n        \n        # Start additional offline units if needed\n        if current_max < load:\n            # Priority calculation for offline units\n            candidates = []\n            for i in flex_offline_idx:\n                unit = units_info[i]\n                min_p = unit['p_min_i']\n                production_cost = unit['b_i'] * min_p + unit['c_i'] * min_p**2\n                cost_per_mw = (unit['s_i'] + production_cost) / min_p\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                candidates.append((cost_per_mw, min_p, max_p, i))\n            \n            # Start most cost-effective units first\n            candidates.sort(key=lambda x: x[0])\n            for _, min_p, max_p, i in candidates:\n                if current_max >= load:\n                    break\n                committed_set.add(i)\n                current_max += max_p\n        \n        # Set uncommitted flex_offline to offline\n        for i in flex_offline_idx:\n            if i not in committed_set:\n                u_current[i] = 0\n                p_current[i] = 0\n        \n    else:  # load < total_min_forced\n        # Case 3: Unavoidable overproduction\n        for i in flex_online_idx + flex_offline_idx:\n            u_current[i] = 0\n            p_current[i] = 0\n    \n    # Step 3: Economic dispatch for committed units\n    min_p_vec = {}\n    max_p_vec = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Was offline\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        min_p_vec[i] = min_p\n        max_p_vec[i] = max_p\n        u_current[i] = 1\n        p_current[i] = min_p\n    \n    # Calculate residual load\n    total_p = sum(p_current)\n    residual = load - total_p\n    \n    # Adjust output if possible\n    if residual > 0:  # Underproduction\n        # Priority by marginal cost\n        mc_list = []\n        for i in committed_set:\n            unit = units_info[i]\n            current_p = p_current[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            headroom = max_p_vec[i] - current_p\n            mc_list.append((marginal_cost, headroom, i))\n        \n        mc_list.sort(key=lambda x: x[0])\n        for mc, headroom, i in mc_list:\n            if residual <= 1e-7:\n                break\n            if headroom > 1e-7:\n                alloc = min(headroom, residual)\n                p_current[i] += alloc\n                residual -= alloc\n    \n    # Set non-committed units to off (redundant for safety)\n    for i in set(range(n)) - committed_set:\n        u_current[i] = 0\n        p_current[i] = 0\n    \n    return np.array([u_current, p_current])",
          "from": "mutation",
          "gap_power_rate": 0.005211854,
          "gap_price_rate": 0.0150284964,
          "fitness": 0.0101201752
     },
     {
          "name": "commit_units_refined",
          "algorithm": "**  \n1. Classify units into must-on (cannot shut due to min up-time or shutdown ramp constraint), must-off (cannot start due to min down-time), and flexible (can switch).  \n2. For must-on units: compute min/max power bounds considering ramp constraints from previous state.  \n3. Determine system state:  \n   - **Case 1 (load within must-on bounds):** Turn off all flexible units. Only dispatch must-on units.  \n   - **Case 2 (load > must-on max):** Keep current online flexible units; start new flexible units by ascending priority (startup cost per MW + marginal cost at min power).  \n   - **Case 3 (load < must-on min):** Turn off all flexible units. Must-on units operate at min output (overproduction).  \n4. For committed units:  \n   - Compute min/max bounds based on current state (startup/online ramp constraints).  \n   - Initialize outputs to min bounds.  \n   - Dispatch residual load by increasing output on units with lowest marginal cost (b_i + 2*c_i*p_i) until meeting load or exhausting capacity.  \n5. Set non-committed units to off (u_i=0, p_i=0).  \n\n**",
          "code": "import numpy as np\n\ndef commit_units_refined(units_info, load):\n    n = len(units_info)\n    u_out = np.zeros(n)\n    p_out = np.zeros(n)\n    must_on = [False] * n\n    must_off = [False] * n\n    flexible = [False] * n\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Set initial commitment\n    for i in range(n):\n        if must_on[i]:\n            u_out[i] = 1\n        elif must_off[i]:\n            u_out[i] = 0\n        else:\n            u_out[i] = units_info[i]['u_i_0']\n    \n    # Compute must-on bounds\n    must_on_min_sum = 0\n    must_on_max_sum = 0\n    for i in range(n):\n        if must_on[i]:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_on_min_sum += min_p\n            must_on_max_sum += max_p\n    \n    # Handle cases\n    committed_units = set(i for i in range(n) if must_on[i])\n    flexible_online = [i for i in range(n) if flexible[i] and u_out[i] == 1]\n    \n    if must_on_min_sum <= load <= must_on_max_sum:  # Case 1\n        for i in range(n):\n            if flexible[i]:\n                u_out[i] = 0\n        committed_units = set(i for i in range(n) if must_on[i])\n    elif load > must_on_max_sum:  # Case 2\n        current_max = must_on_max_sum\n        for i in flexible_online:\n            unit = units_info[i]\n            current_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            committed_units.add(i)\n        \n        candidate_units = [i for i in range(n) if flexible[i] and u_out[i] == 0]\n        candidate_units.sort(\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                           units_info[i]['c_i'] * (units_info[i]['p_min_i'] ** 2)) / units_info[i]['p_min_i']\n        )\n        \n        for i in candidate_units:\n            if current_max >= load:\n                break\n            u_out[i] = 1\n            committed_units.add(i)\n            current_max += min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n    else:  # Case 3: load < must_on_min_sum\n        for i in range(n):\n            if flexible[i]:\n                u_out[i] = 0\n        committed_units = set(i for i in range(n) if must_on[i])\n    \n    # Compute bounds for committed units\n    min_bounds = np.zeros(n)\n    max_bounds = np.zeros(n)\n    for i in committed_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1 and u_out[i] == 1:  # Remain online\n            min_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Startup\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n    \n    # Dispatch initialization\n    total_base = 0\n    for i in committed_units:\n        p_out[i] = min_bounds[i]\n        total_base += min_bounds[i]\n    \n    residual = max(0, load - total_base)\n    current_outputs = p_out.copy()\n    committed_list = list(committed_units)\n    \n    # Dispatch residual load\n    while residual > 1e-6:\n        best_idx = None\n        best_marginal = float('inf')\n        for i in committed_list:\n            if current_outputs[i] < max_bounds[i] - 1e-6:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_outputs[i]\n                if marginal_cost < best_marginal:\n                    best_marginal = marginal_cost\n                    best_idx = i\n        if best_idx is None:\n            break\n        \n        delta = min(residual, max_bounds[best_idx] - current_outputs[best_idx])\n        current_outputs[best_idx] += delta\n        residual -= delta\n    \n    p_out = current_outputs\n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0062535524,
          "gap_price_rate": 0.0151970712,
          "fitness": 0.0107253118
     },
     {
          "name": "commit_units_heuristic_refined",
          "algorithm": "1. Classify units into three sets:\n   a) Must-on units: Units that were on and either haven't satisfied minimum up-time or previous output exceeds shutdown capacity\n   b) Must-off units: Units that were off and haven't satisfied minimum down-time\n   c) Free units: Units that can be committed or decommitted, subdivided into:\n      - Free-on: Currently online (u_i_0=1)\n      - Free-off: Currently offline (u_i_0=0)\n2. Set must-off units to off\n3. Set must-on units to on\n4. Form initial candidate set (must-on + free-on) and compute min/max output:\n   a) Must-on/free-on units: Consider ramp limits using previous output\n   b) Free-off units: Consider startup ramp limits if committed\n5. Handle commitment based on load:\n   - Case 1 (load > max output): Commit free-off units sorted by average cost at min output\n   - Case 2 (load < min output): Decommit free-on units\n   - Case 3 (min \u2264 load \u2264 max): Decommit free-on units\n6. Dispatch power to final candidate set:\n   a) Compute min/max output limits considering state changes\n   b) Start at min output levels\n   c) Allocate residual load by increasing output of units with cheapest marginal cost\n7. Set all non-committed units to off\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic_refined(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Set must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n    \n    # Set must-on units\n    for i in must_on:\n        u[i] = 1\n    \n    # Initially set free units to previous state\n    for i in free_on:\n        u[i] = 1\n    for i in free_off:\n        u[i] = 0\n    \n    # Candidate set initially contains must-on and free-on units\n    candidate_set = must_on + free_on\n    \n    # Calculate min/max output for candidate set\n    total_min = 0.0\n    total_max = 0.0\n    for i in candidate_set:\n        unit = units_info[i]\n        if u[i] == 1:  # Online unit\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Offline unit (free-on initially online)\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    # Handle commitment scenarios\n    free_off_sorted = []\n    if load > total_max:  # Underproduction - commit more units\n        # Calculate average cost: (startup_cost/min_output) + fuel_cost_at_min\n        free_off_costs = []\n        for i in free_off:\n            unit = units_info[i]\n            avg_cost = (unit['s_i'] / unit['p_min_i']) + unit['b_i'] + unit['c_i'] * unit['p_min_i']\n            free_off_costs.append((avg_cost, i))\n        \n        # Sort by average cost\n        free_off_sorted = [i for _, i in sorted(free_off_costs, key=lambda x: x[0])]\n        \n        # Add free-off units until capacity >= load\n        for i in free_off_sorted:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            \n            total_min += min_i\n            total_max += max_i\n            u[i] = 1\n            candidate_set.append(i)\n            \n            if total_max >= load:\n                break\n    \n    elif load < total_min:  # Overproduction - decommit free-on units\n        for i in free_on:\n            u[i] = 0\n            p[i] = 0\n        candidate_set = must_on  # Only must-on units remain\n    \n    else:  # Load within range - decommit free-on units\n        for i in free_on:\n            u[i] = 0\n            p[i] = 0\n        candidate_set = must_on\n    \n    # Dispatch power to candidate_set units\n    min_outputs = []\n    max_outputs = []\n    marginal_costs = []\n    current_outputs = [0] * n_units\n    \n    # Compute min/max outputs considering current state\n    for i in candidate_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1 and u[i] == 1:  # Was and remains online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif u[i] == 1:  # Started this period\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Shouldn't happen for candidate_set\n            min_out = max_out = 0\n        \n        min_outputs.append(min_out)\n        max_outputs.append(max_out)\n        current_outputs[i] = min_out\n        marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * min_out)\n    \n    total_current = sum(min_outputs)\n    residual = load - total_current\n    indices = list(range(len(candidate_set)))\n    \n    # Increase output on cheapest units first\n    while residual > 0 and indices:\n        # Find unit with minimum marginal cost\n        idx_min = min(indices, key=lambda i: marginal_costs[i])\n        i_unit = candidate_set[idx_min]\n        \n        # Calculate available headroom\n        headroom = max_outputs[idx_min] - current_outputs[i_unit]\n        \n        if headroom <= 0:\n            indices.remove(idx_min)\n            continue\n        \n        # Allocate as much as possible\n        allocate = min(residual, headroom)\n        current_outputs[i_unit] += allocate\n        residual -= allocate\n        \n        # Update marginal cost\n        marginal_costs[idx_min] = (units_info[i_unit]['b_i'] + \n                                 2 * units_info[i_unit]['c_i'] * current_outputs[i_unit])\n        \n        # Remove if headroom exhausted\n        if current_outputs[i_unit] >= max_outputs[idx_min]:\n            indices.remove(idx_min)\n    \n    # Set final outputs\n    for i, output in enumerate(current_outputs):\n        p[i] = output\n    \n    return np.array([u, p], dtype=np.float64)",
          "from": "mutation",
          "gap_power_rate": 0.0084381837,
          "gap_price_rate": 0.0134344947,
          "fitness": 0.0109363392
     },
     {
          "name": "commit_units_by_advanced_heuristic",
          "algorithm": "1. Identify units that must remain on (forced_on) due to min up-time or shutdown capacity constraints.\n2. Identify units that must remain off (forced_off) due to min down-time constraints.\n3. Identify flexible units that can be committed or decommitted (flexible_on and flexible_off).\n4. Ensure flexible_on units that cannot ramp to zero output without violating ramp constraints are included in the commitment.\n5. Form initial committed_set from forced_on and must_include_flex_on.\n6. Add candidate units from flexible and off units to committed_set in increasing average cost order until total max capacity >= load.\n7. Perform economic dispatch for committed_set:\n   - Set initial output to minimum feasible\n   - Allocate remaining load based on increasing marginal cost and headroom\n8. Set uncommitted units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_advanced_heuristic(units_info, load):\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    flexible_on = []\n    flexible_off = []\n    must_include_flex_on = []\n\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on.append(i)\n            else:\n                if p_i_0 > p_down_i:\n                    must_include_flex_on.append(i)\n                else:\n                    flexible_on.append(i)\n        else:\n            if -t_i_0 < t_off_min_i:\n                forced_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    committed_set = forced_on + must_include_flex_on\n    candidate_units = flexible_on + flexible_off\n    total_min, total_max = 0.0, 0.0\n    min_output_vals = []\n    max_output_vals = []\n    \n    for i in committed_set:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        if u_i_0 == 1:\n            min_output = max(p_min_i, p_i_0 - p_down_i)\n            max_output = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_output = p_min_i\n            max_output = min(p_max_i, unit['p_start_i'])\n        \n        min_output_vals.append(min_output)\n        max_output_vals.append(max_output)\n        total_min += min_output\n        total_max += max_output\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        p_min_i = unit['p_min_i']\n        s_i = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost = s_i + a + b * p_min_i + c * p_min_i**2\n        cost_per_mw = cost / p_min_i if p_min_i > 0 else float('inf')\n        candidate_list.append((i, cost_per_mw))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    sorted_candidates = [idx for idx, _ in candidate_list]\n    candidate_minmax = []\n    \n    for i in candidate_units:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, unit['p_start_i'])\n        candidate_minmax.append((min_out, max_out))\n    \n    idx = 0\n    while load > total_max and idx < len(sorted_candidates):\n        i = sorted_candidates[idx]\n        min_out, max_out = candidate_minmax[candidate_units.index(i)]\n        committed_set.append(i)\n        min_output_vals.append(min_out)\n        max_output_vals.append(max_out)\n        total_min += min_out\n        total_max += max_out\n        idx += 1\n    \n    schedule_u = np.zeros(n_units)\n    schedule_p = np.zeros(n_units)\n    p_alloc = min_output_vals.copy()\n    remaining = load - sum(p_alloc)\n    if remaining > 0:\n        headroom = [max_val - min_val for min_val, max_val in zip(min_output_vals, max_output_vals)]\n        active_idxs = [j for j in range(len(committed_set)) if headroom[j] > 1e-6]\n        while remaining > 1e-6 and active_idxs:\n            min_marginal = float('inf')\n            best_idx = -1\n            best_inc = 0\n            for j in active_idxs:\n                unit_idx = committed_set[j]\n                unit = units_info[unit_idx]\n                c_val = unit['c_i']\n                b_val = unit['b_i']\n                marginal = 2 * c_val * p_alloc[j] + b_val\n                if marginal < min_marginal:\n                    min_marginal = marginal\n                    best_idx = j\n            if best_idx == -1:\n                break\n            inc = min(remaining, headroom[best_idx])\n            p_alloc[best_idx] += inc\n            headroom[best_idx] -= inc\n            remaining -= inc\n            if headroom[best_idx] <= 1e-6:\n                active_idxs.remove(best_idx)\n    \n    for j, unit_idx in enumerate(committed_set):\n        schedule_u[unit_idx] = 1\n        schedule_p[unit_idx] = p_alloc[j]\n    \n    return np.array([schedule_u, schedule_p])",
          "from": null,
          "gap_power_rate": 0.0005091712,
          "gap_price_rate": 0.0232513196,
          "fitness": 0.0118802454
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Identify must-run units that cannot be shut down (due to minimum up-time or previous output exceeding shutdown ramp limit) and must-remain-off units (insufficient minimum down-time).\n2. Compute min/max output bounds for must-run units based on current state and constraints.\n3. Form priority list of available non-committed units sorted by cost-per-MW at minimum output, considering startup costs for offline units.\n4. Commit additional units from priority list if must-run capacity is insufficient to meet demand.\n5. Perform economic dispatch for committed units using greedy lambda iteration to distribute residual load, respecting individual output constraints.\n6. Set outputs for non-committed units to zero.\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_run = [False] * n\n    must_remain_off = [False] * n\n    \n    # Step 1: Identify must-run and must-remain-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            must_run[i] = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n        else:\n            must_remain_off[i] = abs(unit['t_i_0']) < unit['t_off_min_i']\n    \n    # Precompute bounds and costs for all units\n    bounds = []\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            if unit['u_i_0'] == 1:  # Was on\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Must start\n                low_bound = unit['p_min_i']\n                up_bound = min(unit['p_max_i'], unit['p_start_i'])\n            bounds.append((low_bound, up_bound))\n        else:\n            bounds.append((0, 0))\n    \n    # Must-run commitment and bounds\n    must_run_indices = [i for i in range(n) if must_run[i]]\n    if must_run_indices:\n        total_low = sum(bounds[i][0] for i in must_run_indices)\n        total_high = sum(bounds[i][1] for i in must_run_indices)\n    else:\n        total_low = total_high = 0\n    \n    # Form available units list (non must-run, not forced off)\n    available_units = []\n    for i, unit in enumerate(units_info):\n        if must_run[i] or must_remain_off[i]:\n            continue\n        if unit['u_i_0'] == 1:  # Online (Set B)\n            cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Offline (Set C)\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)\n            low_bound = unit['p_min_i']\n            up_bound = min(unit['p_max_i'], unit['p_start_i'])\n        available_units.append((i, cost, low_bound, up_bound))\n    \n    # Sort by cost-per-MW at minimum output\n    available_units.sort(key=lambda x: x[1])\n    additional_indices = []\n    if total_high < load:\n        T_max = total_high\n        for idx, (i, cost, low_bound, up_bound) in enumerate(available_units):\n            if T_max >= load:\n                break\n            T_max += up_bound\n            additional_indices.append(i)\n            bounds[i] = (low_bound, up_bound)  # Update bounds\n    \n    committed_indices = must_run_indices + additional_indices\n    \n    # Dispatch power to committed units\n    if committed_indices:\n        dispatch_p = [bounds[i][0] for i in committed_indices]\n        residuals = [bounds[i][1] - bounds[i][0] for i in committed_indices]\n        total = sum(dispatch_p)\n        remaining = load - total\n        \n        # Function to compute marginal cost for a unit at current output\n        def marginal_cost(i, current_p):\n            return 2 * units_info[i]['c_i'] * current_p + units_info[i]['b_i']\n        \n        while abs(remaining) > 1e-5:\n            candidates = []\n            for j, i in enumerate(committed_indices):\n                if residuals[j] > 1e-5 and remaining > 0:  # Increase generation\n                    candidates.append((j, marginal_cost(i, dispatch_p[j])))\n                elif dispatch_p[j] > bounds[i][0] + 1e-5 and remaining < 0:  # Decrease generation\n                    candidates.append((j, -marginal_cost(i, dispatch_p[j])))  # Negative for sorting\n            \n            if not candidates:\n                break\n                \n            # Select candidate with most negative/positive marginal cost\n            candidates.sort(key=lambda x: x[1])\n            idx_in_committed = candidates[0][0] if remaining > 0 else candidates[-1][0]\n            unit_idx = committed_indices[idx_in_committed]\n            \n            # Calculate step size\n            if remaining > 0:\n                step = min(remaining, residuals[idx_in_committed])\n                dispatch_p[idx_in_committed] += step\n                residuals[idx_in_committed] -= step\n            else:\n                step = min(-remaining, dispatch_p[idx_in_committed] - bounds[unit_idx][0])\n                dispatch_p[idx_in_committed] -= step\n                residuals[idx_in_committed] += step  # Not used for decreasing but update for clarity\n            \n            remaining -= step if remaining > 0 else -step\n        \n        # Assign dispatch values\n        for j, i in enumerate(committed_indices):\n            p[i] = dispatch_p[j]\n            u[i] = 1\n    \n    # Set states and outputs\n    for i in range(n):\n        if i not in committed_indices:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0059313678,
          "gap_price_rate": 0.0179953764,
          "fitness": 0.0119633721
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run units that cannot be turned off due to minimum up-time or shutdown ramp constraints\n2. Identify must-off units that cannot be turned on due to minimum down-time constraints\n3. For must-run units, calculate minimum and maximum output considering ramp constraints\n4. For non-must-run, non-must-off candidate units:\n   - Calculate min/max output and priority cost (including startup for cold units)\n   - Separate into already-on and off units\n5. Adjust commitments:\n   - Turn off expensive already-on units if possible without causing undercapacity\n   - Turn on prioritized off-candidates if needed to meet load\n6. Dispatch power to committed units:\n   - Initialize to minimum possible output considering ramp constraints\n   - Increase output of units with lowest marginal cost to meet load\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    must_run = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        # Identify must-run units\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        # Identify must-off units\n        if unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n\n    # Calculate must-run power limits\n    must_run_total_min = 0\n    must_run_total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        must_run_total_min += min_output\n        must_run_total_max += max_output\n\n    # Prepare candidate units\n    on_candidates = []\n    off_candidates = []\n    for i in range(n_units):\n        if i in must_run or i in must_off:\n            continue\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2\n            priority = cost / min_output\n            on_candidates.append((priority, i, min_output, max_output))\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2\n            priority = cost / min_output\n            off_candidates.append((priority, i, min_output, max_output))\n    \n    # Sort candidates\n    on_candidates.sort(key=lambda x: -x[0])\n    off_candidates.sort(key=lambda x: x[0])\n    \n    # Adjust commitments\n    on_list = list(must_run)\n    total_min = must_run_total_min\n    total_max = must_run_total_max\n    for priority, i, min_out, max_out in on_candidates:\n        on_list.append(i)\n        total_min += min_out\n        total_max += max_out\n    \n    # Turn off expensive units if possible\n    turn_off = []\n    for priority, i, min_out, max_out in on_candidates:\n        if total_min > load and (total_max - max_out) >= load:\n            on_list.remove(i)\n            total_min -= min_out\n            total_max -= max_out\n            turn_off.append(i)\n    \n    # Turn on prioritized off-candidates if needed\n    for priority, i, min_out, max_out in off_candidates:\n        if total_max < load:\n            on_list.append(i)\n            total_min += min_out\n            total_max += max_out\n    \n    # Initialize output for all units\n    current_p = np.zeros(n_units)\n    room = np.zeros(n_units)\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if i in on_list:\n            schedules[0, i] = 1\n            if unit['u_i_0'] == 1:\n                current_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                current_p[i] = unit['p_min_i']\n            \n            # Calculate ramp room\n            if unit['u_i_0'] == 1:\n                room[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p[i]\n            else:\n                room[i] = min(unit['p_max_i'], unit['p_start_i']) - current_p[i]\n        else:\n            schedules[0, i] = 0\n            current_p[i] = 0\n    \n    # Economic dispatch\n    total_power = np.sum(current_p)\n    deficit = load - total_power\n\n    while deficit > 1e-5:\n        best_marginal = float('inf')\n        best_idx = None\n        \n        # Find unit with lowest marginal cost and available room\n        for i in on_list:\n            if room[i] > 1e-5:\n                marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = i\n        \n        if best_idx is None:\n            break\n        \n        # Increase power\n        increase = min(deficit, room[best_idx])\n        current_p[best_idx] += increase\n        room[best_idx] -= increase\n        total_power += increase\n        deficit -= increase\n\n    # Set schedule outputs\n    schedules[1, :] = current_p\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     }
]