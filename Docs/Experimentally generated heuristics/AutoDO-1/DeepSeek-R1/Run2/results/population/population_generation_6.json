[
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "refined_enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into four states: must-on (units violating min up-time/shutdown capacity), must-off (units violating min down-time), flexible-on (eligible online units), flexible-off (eligible offline units)  \n2. Calculate must-on generation bounds incorporating ramp constraints  \n3. Case handling:  \n   a) Load within must-on bounds: commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by ascending cost-per-MW metric  \n      - Decommit expensive flexible-on units using incremental capacity efficiency  \n   c) Load below must-on min: must-on units operate at minimum output  \n4. Compute dynamic power bounds per unit based on commitment history  \n5. Initialize outputs at lower bounds  \n6. Distribute residual load via marginal cost-ordered priority queue  \n7. Set uncommitted units to off-state  \n\n",
          "code": "import heapq\nimport numpy as np\n\ndef refined_enhanced_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Initialize lists for unit classifications\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units based on operational constraints\n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Previously online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Previously offline\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Calculate must-on generation bounds\n    must_on_min = 0.0\n    must_on_max = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        min_bound = max(p_min, p_i_0 - p_down_i)\n        max_bound = min(p_max, p_i_0 + p_up_i)\n        must_on_min += min_bound\n        must_on_max += max_bound\n    \n    # Case handling for load allocation\n    candidate_set = set(must_on)  # Units to be committed\n    \n    if must_on_min <= load <= must_on_max:\n        # Case 3a: Load within must-on bounds\n        candidate_set = set(must_on)\n    \n    elif load > must_on_max:\n        # Case 3b: Load exceeds must-on capacity\n        candidate_set = set(must_on + flexible_on)\n        \n        # Calculate candidate set capacity\n        cand_min = must_on_min\n        cand_max = must_on_max\n        for i in flexible_on:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            \n            min_bound = max(p_min, p_i_0 - p_down_i)\n            max_bound = min(p_max, p_i_0 + p_up_i)\n            cand_min += min_bound\n            cand_max += max_bound\n        \n        # Start flexible-off units if needed (cost-per-MW priority)\n        if cand_max < load:\n            cost_per_mw = []\n            for i in flexible_off:\n                unit = units_info[i]\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                \n                startup_cost = s_i\n                cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n                metric = (startup_cost + cost_at_min) / p_min_i\n                cost_per_mw.append((metric, i))\n            \n            cost_per_mw.sort(key=lambda x: x[0])\n            \n            for metric, i in cost_per_mw:\n                if cand_max >= load:\n                    break\n                \n                unit = units_info[i]\n                p_min_i = unit['p_min_i']\n                p_max_i = unit['p_max_i']\n                p_start_i = unit['p_start_i']\n                \n                max_output = min(p_max_i, p_start_i)\n                cand_min += p_min_i\n                cand_max += max_output\n                candidate_set.add(i)\n        \n        # Decommit expensive flexible-on units\n        cost_efficiency = []\n        for i in candidate_set - set(must_on):\n            unit = units_info[i]\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            \n            min_bound = max(p_min_i, p_i_0 - p_down_i)\n            max_bound = min(unit['p_max_i'], p_i_0 + p_up_i)\n            incremental_cap = max_bound - min_bound\n            cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n            metric = cost_at_min / incremental_cap if incremental_cap > 0 else float('inf')\n            cost_efficiency.append((metric, i, min_bound, max_bound))\n        \n        cost_efficiency.sort(key=lambda x: x[0], reverse=True)\n        \n        for metric, i, min_bound, max_bound in cost_efficiency:\n            if i not in candidate_set:\n                continue\n                \n            new_min = cand_min - min_bound\n            new_max = cand_max - max_bound\n            \n            if new_max >= load:\n                candidate_set.remove(i)\n                cand_min = new_min\n                cand_max = new_max\n    \n    else:  # Case 3c: Load below must-on minimum\n        candidate_set = set(must_on)\n    \n    # Compute power bounds per unit\n    lower_bounds = np.zeros(num_units)\n    upper_bounds = np.zeros(num_units)\n    for i in range(num_units):\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if i in candidate_set:\n            if u_i_0 == 1:  # Continuation from online state\n                lower_bounds[i] = max(p_min_i, p_i_0 - p_down_i)\n                upper_bounds[i] = min(p_max_i, p_i_0 + p_up_i)\n            else:  # Starting from offline state\n                lower_bounds[i] = p_min_i\n                upper_bounds[i] = min(p_max_i, p_start_i)\n        else:\n            lower_bounds[i] = 0\n            upper_bounds[i] = 0\n    \n    # Initialize outputs at lower bounds\n    outputs = lower_bounds.copy()\n    total_output = np.sum(outputs)\n    residual = load - total_output\n    \n    # Economic dispatch via priority queue\n    heap = []\n    for i in candidate_set:\n        if outputs[i] < upper_bounds[i]:\n            marginal_cost = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    while residual > 0 and heap:\n        marginal_cost, i = heapq.heappop(heap)\n        available = upper_bounds[i] - outputs[i]\n        \n        if available > 0:\n            increment = min(available, residual)\n            outputs[i] += increment\n            residual -= increment\n            \n            # Update marginal cost and push back if capacity remains\n            if outputs[i] < upper_bounds[i]:\n                new_marginal = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                heapq.heappush(heap, (new_marginal, i))\n    \n    # Build final schedule\n    for i in range(num_units):\n        schedules[0, i] = 1 if i in candidate_set else 0\n        schedules[1, i] = outputs[i] if i in candidate_set else 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0052449584,
          "gap_price_rate": 0.0085332973,
          "fitness": 0.0068891278
     },
     {
          "name": "refined_adaptive_commitment",
          "algorithm": "1. Classify units into must-on (online and unable to shut down due to min-up time or shutdown constraints), must-off (offline and unable to start due to min-down time), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for startup).  \n2. Calculate must-on min/max outputs with ramp constraints.  \n3. Handle cases:  \n   a) If load \u2264 total must-on min \u2192 Set commit_set=must-on  \n   b) If total must-on min < load \u2264 total must-on max \u2192 Set commit_set=must-on  \n   c) If load > total must-on max:  \n      - Form candidate_set (must-on + flexible-on)  \n      - Start flexible-off units by cost-per-MW priority until max capacity \u2265 load  \n      - Add started units to candidate_set  \n      - Decommit expensive non-must-on units from candidate_set while ensuring capacity \u2265 load  \n4. For each committed unit:  \n   a) Compute power bounds considering current state  \n   b) Initialize outputs at lower bounds  \n   c) Distribute residual load using marginal cost-based greedy allocation  \n5. Set uncommitted units to off state.  \n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_commitment(units_info, load):\n    # Initialize classification lists\n    must_on_units = []\n    must_off_units = []\n    flexible_on_units = []\n    flexible_off_units = []\n    \n    # Step 1: Classify units\n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on_units.append(unit)\n            else:\n                flexible_on_units.append(unit)\n        else:  # Previously offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                flexible_off_units.append(unit)\n    \n    # Initialize commit set and other containers\n    commit_set = []\n    started_units = []\n    \n    # Step 2: Calculate must-on bounds\n    total_must_on_min = 0\n    total_must_on_max = 0\n    for unit in must_on_units:\n        # Compute ramp-constrained bounds\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['min_output'] = min_output\n        unit['max_output'] = max_output\n        total_must_on_min += min_output\n        total_must_on_max += max_output\n    \n    # Step 3: Case handling\n    # Case 1: Load \u2264 total must-on min\n    if load <= total_must_on_min:\n        commit_set = must_on_units\n    \n    # Case 2: Load within must-on range\n    elif total_must_on_min < load <= total_must_on_max:\n        commit_set = must_on_units\n    \n    # Case 3: Load exceeds must-on capacity\n    else:\n        # Compute bounds for flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        for unit in flexible_on_units:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_output'] = min_output\n            unit['max_output'] = max_output\n            flex_on_min += min_output\n            flex_on_max += max_output\n        \n        # Form initial candidate set\n        commit_set = must_on_units + flexible_on_units\n        total_min = total_must_on_min + flex_on_min\n        total_max = total_must_on_max + flex_on_max\n        \n        # Start flexible-off units by cost-per-MW priority\n        if total_max < load:\n            # Calculate cost per MW at min output\n            cost_per_mw = []\n            for unit in flexible_off_units:\n                min_output = unit['p_min_i']\n                cost_at_min = (unit['a_i'] + unit['b_i'] * min_output + \n                              unit['c_i'] * min_output ** 2 + unit['s_i'])\n                cost_per_mw.append(cost_at_min / min_output)\n            \n            # Sort by cost per MW (ascending)\n            sorted_indices = np.argsort(cost_per_mw)\n            sorted_flex_off = [flexible_off_units[i] for i in sorted_indices]\n            \n            # Start units until max capacity \u2265 load\n            for unit in sorted_flex_off:\n                unit_max = min(unit['p_max_i'], unit['p_start_i'])\n                unit['min_output'] = unit['p_min_i']\n                unit['max_output'] = unit_max\n                commit_set.append(unit)\n                started_units.append(unit)\n                total_max += unit_max\n                if total_max >= load:\n                    break\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [u for u in commit_set if u not in must_on_units]\n        if non_must_on:\n            # Calculate marginal cost at min output\n            marginal_costs = []\n            for unit in non_must_on:\n                marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * unit['min_output'])\n            \n            # Sort by marginal cost (descending)\n            sorted_indices = np.argsort(marginal_costs)[::-1]\n            sorted_non_must_on = [non_must_on[i] for i in sorted_indices]\n            \n            # Decommit units with excess capacity\n            current_min = total_min\n            current_max = total_max\n            for unit in sorted_non_must_on:\n                if current_max - unit['max_output'] >= load:\n                    commit_set.remove(unit)\n                    current_min -= unit['min_output']\n                    current_max -= unit['max_output']\n    \n    # Step 4: Dispatch load to committed units\n    # Initialize each unit's output and bounds\n    for unit in commit_set:\n        if unit in started_units:\n            unit['lb'] = unit['p_min_i']\n            unit['ub'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['lb'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['ub'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['p_i'] = unit['lb']\n    \n    # Distribute residual load\n    total_allocated = sum(unit['p_i'] for unit in commit_set)\n    residual = load - total_allocated\n    \n    # Greedy allocation based on marginal costs\n    if residual > 0:\n        # Create updatable allocation state\n        while residual > 0:\n            # Find unit with smallest marginal cost that can increase\n            best_unit = None\n            best_marginal_cost = float('inf')\n            for unit in commit_set:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                if unit['p_i'] < unit['ub'] and marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = unit\n            \n            if best_unit is None:\n                break  # No more units can increase\n            \n            # Calculate max possible increase for this unit\n            max_increase = best_unit['ub'] - best_unit['p_i']\n            allocation = min(residual, max_increase)\n            \n            # Update allocation and residual\n            best_unit['p_i'] += allocation\n            residual -= allocation\n    \n    # Step 5: Prepare output schedule\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    for i, unit in enumerate(units_info):\n        if unit in commit_set:\n            schedules[0, i] = 1  # u_i = 1\n            schedules[1, i] = unit['p_i']  # p_i allocated\n        else:\n            schedules[0, i] = 0  # u_i = 0\n            schedules[1, i] = 0  # p_i = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0086067699,
          "fitness": 0.0068906524
     },
     {
          "name": "refined_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (online and cannot shut down due to minimum up-time or shutdown constraints), must-off (offline and cannot start due to minimum down-time), flexible-on (online and eligible for shutdown), flexible-off (offline and eligible for startup)  \n2. Calculate total minimum/maximum output from must-on units considering ramp constraints  \n3. Case handling:  \n   a) Load within must-on range: Commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by cost/MW priority until capacity \u2265 load  \n      - Decommit expensive flexible-on/started units if possible while maintaining capacity feasibility  \n   c) Load below must-on minimum: Commit only must-on (overproduction unavoidable)  \n4. For committed units:  \n   a) Calculate power bounds considering online state/startup constraints  \n   b) Initialize outputs at minimum bounds  \n   c) Distribute residual load using greedy marginal cost-based allocation  \n5. Set uncommitted units to off state with zero output  \n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Calculate must-on capacity\n    must_on_min = must_on_max = 0\n    must_on_min_bounds = {}\n    must_on_max_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_min_bounds[idx] = min_bound\n        must_on_max_bounds[idx] = max_bound\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on)\n    elif load > must_on_max:\n        candidate_set = set(must_on + flexible_on)\n        min_candidate = must_on_min\n        max_candidate = must_on_max\n        \n        # Add flexible-on capacity\n        for idx in flexible_on:\n            unit = units_info[idx]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_candidate += min_bound\n            max_candidate += max_bound\n        \n        # Start flexible-off units if needed\n        if max_candidate < load:\n            priority_list = []\n            for idx in flexible_off:\n                unit = units_info[idx]\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                              unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n                priority_list.append((cost_per_mw, idx))\n            priority_list.sort(key=lambda x: x[0])\n            \n            for _, idx in priority_list:\n                if max_candidate >= load:\n                    break\n                unit = units_info[idx]\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n                max_candidate += max_bound\n                candidate_set.add(idx)\n        \n        # Decommit expensive units if excess capacity\n        non_must_on = [idx for idx in candidate_set if idx not in must_on]\n        if max_candidate > load and non_must_on:\n            min_bounds = {}\n            max_bounds = {}\n            for idx in candidate_set:\n                if idx in must_on:\n                    min_bounds[idx] = must_on_min_bounds.get(idx, units_info[idx]['p_min_i'])\n                    max_bounds[idx] = must_on_max_bounds.get(idx, units_info[idx]['p_max_i'])\n                else:\n                    unit = units_info[idx]\n                    if unit['u_i_0'] == 1:  # flexible-on\n                        min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:  # started unit\n                        min_bounds[idx] = unit['p_min_i']\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            cost_per_mw = {}\n            for idx in non_must_on:\n                unit = units_info[idx]\n                cost_per_mw[idx] = (unit['a_i'] + unit['b_i']*min_bounds[idx] + \n                                   unit['c_i']*(min_bounds[idx]**2)) / min_bounds[idx]\n            \n            sorted_non_must = sorted(non_must_on, key=lambda idx: cost_per_mw[idx], reverse=True)\n            \n            for idx in sorted_non_must:\n                if min_candidate - min_bounds[idx] <= load <= max_candidate - max_bounds[idx]:\n                    candidate_set.remove(idx)\n                    min_candidate -= min_bounds[idx]\n                    max_candidate -= max_bounds[idx]\n                    if max_candidate < load:\n                        candidate_set.add(idx)\n                        min_candidate += min_bounds[idx]\n                        max_candidate += max_bounds[idx]\n                        break\n    else:  # load < must_on_min\n        candidate_set = set(must_on)\n    \n    # Calculate bounds for dispatch\n    min_bounds = {}\n    max_bounds = {}\n    outputs = {}\n    for idx in candidate_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # online in previous period\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # starting in current period\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[idx] = min_b\n        max_bounds[idx] = max_b\n        outputs[idx] = min_b\n    \n    # Economic dispatch\n    total_output = sum(outputs.values())\n    residual = load - total_output\n    \n    if residual > 0:\n        active_units = [idx for idx in candidate_set if outputs[idx] < max_bounds[idx]]\n        while residual > 0 and active_units:\n            min_mc = float('inf')\n            best_unit = None\n            for idx in active_units:\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * outputs[idx]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_unit = idx\n            \n            unit = units_info[best_unit]\n            increment = min(residual, max_bounds[best_unit] - outputs[best_unit])\n            outputs[best_unit] += increment\n            residual -= increment\n            \n            if outputs[best_unit] >= max_bounds[best_unit]:\n                active_units.remove(best_unit)\n    \n    # Generate output schedules\n    for idx in range(num_units):\n        if idx in candidate_set:\n            schedules[0, idx] = 1\n            schedules[1, idx] = outputs.get(idx, 0)\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "refined_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (online and cannot shut down due to minimum up-time or shutdown constraints), must-off (offline and cannot start due to minimum down-time), flexible-on (online and eligible for shutdown), flexible-off (offline and eligible for startup)  \n2. Calculate total minimum/maximum output from must-on units considering ramp constraints  \n3. Case handling:  \n   a) Load within must-on range: Commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by cost/MW priority until capacity \u2265 load  \n      - Decommit expensive flexible-on/started units if possible while maintaining capacity feasibility  \n   c) Load below must-on minimum: Commit only must-on (overproduction unavoidable)  \n4. For committed units:  \n   a) Calculate power bounds considering online state/startup constraints  \n   b) Initialize outputs at minimum bounds  \n   c) Distribute residual load using greedy marginal cost-based allocation  \n5. Set uncommitted units to off state with zero output  \n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Calculate must-on capacity\n    must_on_min = must_on_max = 0\n    must_on_min_bounds = {}\n    must_on_max_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_min_bounds[idx] = min_bound\n        must_on_max_bounds[idx] = max_bound\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on)\n    elif load > must_on_max:\n        candidate_set = set(must_on + flexible_on)\n        min_candidate = must_on_min\n        max_candidate = must_on_max\n        \n        # Add flexible-on capacity\n        for idx in flexible_on:\n            unit = units_info[idx]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_candidate += min_bound\n            max_candidate += max_bound\n        \n        # Start flexible-off units if needed\n        if max_candidate < load:\n            priority_list = []\n            for idx in flexible_off:\n                unit = units_info[idx]\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                              unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n                priority_list.append((cost_per_mw, idx))\n            priority_list.sort(key=lambda x: x[0])\n            \n            for _, idx in priority_list:\n                if max_candidate >= load:\n                    break\n                unit = units_info[idx]\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n                max_candidate += max_bound\n                candidate_set.add(idx)\n        \n        # Decommit expensive units if excess capacity\n        non_must_on = [idx for idx in candidate_set if idx not in must_on]\n        if max_candidate > load and non_must_on:\n            min_bounds = {}\n            max_bounds = {}\n            for idx in candidate_set:\n                if idx in must_on:\n                    min_bounds[idx] = must_on_min_bounds.get(idx, units_info[idx]['p_min_i'])\n                    max_bounds[idx] = must_on_max_bounds.get(idx, units_info[idx]['p_max_i'])\n                else:\n                    unit = units_info[idx]\n                    if unit['u_i_0'] == 1:  # flexible-on\n                        min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:  # started unit\n                        min_bounds[idx] = unit['p_min_i']\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            cost_per_mw = {}\n            for idx in non_must_on:\n                unit = units_info[idx]\n                cost_per_mw[idx] = (unit['a_i'] + unit['b_i']*min_bounds[idx] + \n                                   unit['c_i']*(min_bounds[idx]**2)) / min_bounds[idx]\n            \n            sorted_non_must = sorted(non_must_on, key=lambda idx: cost_per_mw[idx], reverse=True)\n            \n            for idx in sorted_non_must:\n                if min_candidate - min_bounds[idx] <= load <= max_candidate - max_bounds[idx]:\n                    candidate_set.remove(idx)\n                    min_candidate -= min_bounds[idx]\n                    max_candidate -= max_bounds[idx]\n                    if max_candidate < load:\n                        candidate_set.add(idx)\n                        min_candidate += min_bounds[idx]\n                        max_candidate += max_bounds[idx]\n                        break\n    else:  # load < must_on_min\n        candidate_set = set(must_on)\n    \n    # Calculate bounds for dispatch\n    min_bounds = {}\n    max_bounds = {}\n    outputs = {}\n    for idx in candidate_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # online in previous period\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # starting in current period\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[idx] = min_b\n        max_bounds[idx] = max_b\n        outputs[idx] = min_b\n    \n    # Economic dispatch\n    total_output = sum(outputs.values())\n    residual = load - total_output\n    \n    if residual > 0:\n        active_units = [idx for idx in candidate_set if outputs[idx] < max_bounds[idx]]\n        while residual > 0 and active_units:\n            min_mc = float('inf')\n            best_unit = None\n            for idx in active_units:\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * outputs[idx]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_unit = idx\n            \n            unit = units_info[best_unit]\n            increment = min(residual, max_bounds[best_unit] - outputs[best_unit])\n            outputs[best_unit] += increment\n            residual -= increment\n            \n            if outputs[best_unit] >= max_bounds[best_unit]:\n                active_units.remove(best_unit)\n    \n    # Generate output schedules\n    for idx in range(num_units):\n        if idx in candidate_set:\n            schedules[0, idx] = 1\n            schedules[1, idx] = outputs.get(idx, 0)\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "refined_combined_commitment",
          "algorithm": "1. Classify units into must-on, must-off, flexible-on, flexible-off based on operational constraints:\n   - must-on: units that were online and either haven't satisfied min up-time or previous output exceeds shutdown capacity\n   - must-off: units that were offline and haven't satisfied min down-time\n   - flexible-on: online units eligible for shutdown\n   - flexible-off: offline units eligible for startup\n\n2. Compute total min/max outputs from must-on units considering ramp constraints\n\n3. Handle three load cases:\n   a) Load within must-on range: commit only must-on units\n   b) Load exceeds must-on capacity:\n        - Form candidate set with must-on + flexible-on units\n        - Start flexible-off units by cost-per-MW priority (including startup cost)\n        - After meeting load, decommit non-must-on units by descending operating cost\n   c) Load below must-on min: commit only must-on units (overproduction unavoidable)\n\n4. For committed units:\n   a) Calculate power bounds considering operational state (online/startup)\n   b) Initialize outputs to min bounds\n   c) Distribute residual load using marginal cost-based allocation with:\n        - Priority queue ordering units by marginal cost\n        - Block allocation to minimize iteration count\n\n5. Turn off non-committed units\n",
          "code": "import heapq\nimport numpy as np\n\ndef refined_combined_commitment(units_info, load):\n    n_units = len(units_info)\n    u_arr = [0] * n_units\n    p_arr = [0.0] * n_units\n    \n    must_on_indices = set()\n    must_off_indices = set()\n    flexible_on_indices = set()\n    flexible_off_indices = set()\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                must_on_indices.add(idx)\n            else:\n                flexible_on_indices.add(idx)\n        else:\n            if t_i0 < 0 and (-t_i0 < t_off_min_i):\n                must_off_indices.add(idx)\n            else:\n                flexible_off_indices.add(idx)\n    \n    total_min_must = 0\n    total_max_must = 0\n    for idx in must_on_indices:\n        unit = units_info[idx]\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        min_output_i = max(p_min_i, p_i0 - p_down_i)\n        max_output_i = min(p_max_i, p_i0 + p_up_i)\n        total_min_must += min_output_i\n        total_max_must += max_output_i\n    \n    candidate_set = set()\n    \n    if total_min_must <= load <= total_max_must:\n        candidate_set = must_on_indices.copy()\n    elif load > total_max_must:\n        candidate_set = must_on_indices | flexible_on_indices\n        total_max_candidate = 0\n        for idx in candidate_set:\n            unit = units_info[idx]\n            p_i0 = unit['p_i_0']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            max_output_i = min(p_max_i, p_i0 + p_up_i)\n            total_max_candidate += max_output_i\n        \n        flexible_off_list = []\n        for idx in flexible_off_indices:\n            unit = units_info[idx]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            cost_effectiveness = (s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)) / p_min_i\n            flexible_off_list.append((cost_effectiveness, idx, unit))\n        \n        flexible_off_list.sort(key=lambda x: x[0])\n        \n        for cost_effect, idx, unit in flexible_off_list:\n            if total_max_candidate >= load:\n                break\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_output_i = min(p_max_i, p_start_i)\n            candidate_set.add(idx)\n            total_max_candidate += max_output_i\n        \n        non_muston = list(candidate_set - must_on_indices)\n        cost_info = []\n        for idx in non_muston:\n            unit = units_info[idx]\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n            if idx in flexible_on_indices:\n                unit_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                unit_max = min(unit['p_max_i'], unit['p_start_i'])\n            cost_info.append((cost_at_min, idx, unit, unit_max))\n        \n        cost_info.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, idx, unit, unit_max in cost_info:\n            if (total_max_candidate - unit_max) >= load:\n                candidate_set.remove(idx)\n                total_max_candidate -= unit_max\n    else:\n        candidate_set = must_on_indices.copy()\n    \n    candidate_p_min = {}\n    candidate_p_max = {}\n    current_output_arr = [0.0] * n_units\n    \n    for idx in candidate_set:\n        u_arr[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            p_min_i = unit['p_min_i']\n            p_i0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            min_bound = max(p_min_i, p_i0 - p_down_i)\n            max_bound = min(p_max_i, p_i0 + p_up_i)\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        p_arr[idx] = min_bound\n        current_output_arr[idx] = min_bound\n        candidate_p_min[idx] = min_bound\n        candidate_p_max[idx] = max_bound\n    \n    total_min_bound = sum(candidate_p_min.get(i, 0) for i in range(n_units))\n    residual = load - total_min_bound\n    \n    if residual > 0:\n        heap = []\n        for idx in candidate_set:\n            current_output = current_output_arr[idx]\n            max_bound = candidate_p_max[idx]\n            if current_output < max_bound:\n                unit = units_info[idx]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                marginal_cost = 2 * c_i * current_output + b_i\n                heapq.heappush(heap, (marginal_cost, idx, current_output))\n        \n        while residual > 0 and heap:\n            mc, idx, current_out = heapq.heappop(heap)\n            if abs(current_output_arr[idx] - current_out) > 1e-5:\n                continue\n            if current_out >= candidate_p_max[idx]:\n                continue\n            headroom = candidate_p_max[idx] - current_out\n            if headroom <= 0:\n                continue\n            delta = min(residual, headroom)\n            new_output = current_out + delta\n            current_output_arr[idx] = new_output\n            p_arr[idx] = new_output\n            residual -= delta\n            unit = units_info[idx]\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            new_mc = 2 * c_i * new_output + b_i\n            if new_output < candidate_p_max[idx]:\n                heapq.heappush(heap, (new_mc, idx, new_output))\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.008773668,
          "fitness": 0.0069479559
     },
     {
          "name": "enhanced_adaptive_commitment",
          "algorithm": "1. Classify units into four groups:\n   a) Must-on: Online units that cannot shut down (inadequate min up-time or previous output > shutdown capacity)\n   b) Must-off: Offline units that cannot start (inadequate min down-time)\n   c) Flexible-on: Online units eligible for shutdown (p_i_0 \u2264 p_down_i)\n   d) Flexible-off: Offline units eligible for start (p_min_i \u2264 min(p_max_i, p_start_i))\n2. Form initial candidate set (must-on + flexible-on). Compute system min/max:\n   a) For must-on/flexible-on: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   b) For flexible-off: min = p_min_i, max = min(p_max_i, p_start_i)\n3. Handle load imbalance:\n   a) Case 1 (load > system max): Commit flexible-off units by ascending (startup cost + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i\n   b) Case 2 (load < system min): Decommit flexible-on units by descending min_output\n   c) Case 3 (system min \u2264 load \u2264 system max): Decommit expensive flexible-on units with output safety (new_min \u2264 load \u2264 new_max after decommit)\n4. Enhanced dispatch for committed units:\n   a) Set initial output = unit-specific min\n   b) Compute residual = load - sum(initial outputs)\n   c) Increase outputs on units with lowest marginal cost while respecting max limits\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Unpack unit info into separate arrays for efficiency\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize commitment and output arrays\n    u_i = np.zeros(num_units, dtype=int)\n    p_i = np.zeros(num_units)\n    \n    # Classify units\n    must_on_mask = (u_i_0 == 1) & ((t_i_0 < t_on_min) | (p_i_0 > p_shut))\n    must_off_mask = (u_i_0 == 0) & (-t_i_0 < t_off_min)\n    flexible_on_mask = (u_i_0 == 1) & ~must_on_mask & (p_i_0 <= p_down)\n    flexible_off_mask = (u_i_0 == 0) & ~must_off_mask & (p_min <= np.minimum(p_max, p_start))\n    \n    # Set must-on/must-off states\n    u_i[must_on_mask] = 1\n    u_i[must_off_mask] = 0\n    \n    # Candidate set (must-on + flexible-on initially)\n    candidate_mask = must_on_mask | flexible_on_mask\n    \n    # Compute min/max boundaries for candidates\n    candidate_min = np.zeros(num_units)\n    candidate_max = np.zeros(num_units)\n    \n    # For online candidates\n    online_candidate = must_on_mask | flexible_on_mask\n    candidate_min[online_candidate] = np.maximum(p_min[online_candidate], p_i_0[online_candidate] - p_down[online_candidate])\n    candidate_max[online_candidate] = np.minimum(p_max[online_candidate], p_i_0[online_candidate] + p_up[online_candidate])\n    \n    # For offline flexible units\n    flexible_off_ids = np.where(flexible_off_mask)[0]\n    candidate_min[flexible_off_ids] = p_min[flexible_off_ids]\n    candidate_max[flexible_off_ids] = np.minimum(p_max[flexible_off_ids], p_start[flexible_off_ids])\n    \n    system_min = np.sum(candidate_min[candidate_mask])\n    system_max = np.sum(candidate_max[candidate_mask])\n    \n    # Handle commitment cases\n    if load > system_max and np.any(flexible_off_mask):\n        # Case 1: Underproduction - start flexible-off units\n        avg_costs = (s[flexible_off_ids] + a[flexible_off_ids] + b[flexible_off_ids] * p_min[flexible_off_ids] \n                   + c[flexible_off_ids] * p_min[flexible_off_ids]**2) / p_min[flexible_off_ids]\n        priority_order = np.argsort(avg_costs)\n        for idx in priority_order:\n            unit_id = flexible_off_ids[idx]\n            candidate_mask[unit_id] = True\n            system_min += p_min[unit_id]\n            system_max += np.minimum(p_max[unit_id], p_start[unit_id])\n            if system_max >= load:\n                break\n                \n    elif load < system_min and np.any(flexible_on_mask):\n        # Case 2: Overproduction - decommit flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        min_outputs = candidate_min[flexible_on_ids]\n        priority_order = np.argsort(min_outputs)[::-1]  # Descending min output\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            if load >= system_min:\n                break\n            candidate_mask[unit_id] = False\n            system_min -= min_outputs[np.where(flexible_on_ids == unit_id)[0][0]]\n            system_max -= candidate_max[unit_id]\n            flexible_on_mask[unit_id] = False\n    \n    elif system_min <= load <= system_max and np.any(flexible_on_mask):\n        # Case 3: Within bounds - decommit expensive flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        avg_costs = (a[flexible_on_ids] + b[flexible_on_ids] * p_min[flexible_on_ids] \n                   + c[flexible_on_ids] * p_min[flexible_on_ids]**2) / p_min[flexible_on_ids]\n        priority_order = np.argsort(avg_costs)[::-1]  # Descending cost\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            new_min = system_min - candidate_min[unit_id]\n            new_max = system_max - candidate_max[unit_id]\n            if new_min <= load <= new_max:\n                candidate_mask[unit_id] = False\n                system_min, system_max = new_min, new_max\n    \n    # Update commitment state\n    u_i[candidate_mask] = 1\n    \n    # Economic dispatch for committed units\n    unit_min = np.zeros(num_units)\n    unit_max = np.zeros(num_units)\n    \n    # Set boundaries based on state\n    for i in range(num_units):\n        if candidate_mask[i]:\n            if u_i_0[i] == 1:  # Already online\n                unit_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                unit_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # Started this period\n                unit_min[i] = p_min[i]\n                unit_max[i] = min(p_max[i], p_start[i])\n    \n    # Initialize outputs at min levels\n    p_i[candidate_mask] = unit_min[candidate_mask]\n    residual = load - np.sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5 and np.any(p_i[candidate_mask] < unit_max[candidate_mask]):\n        # Find cheapest available unit\n        marginal_costs = b + 2 * c * p_i\n        marginal_costs[~candidate_mask] = np.inf\n        marginal_costs[p_i >= unit_max] = np.inf\n        \n        if np.all(marginal_costs == np.inf):\n            break\n            \n        cheapest_id = np.argmin(marginal_costs)\n        \n        # Calculate max possible increase\n        headroom = unit_max[cheapest_id] - p_i[cheapest_id]\n        increment = min(residual, headroom)\n        \n        # Update output and residual\n        p_i[cheapest_id] += increment\n        residual -= increment\n    \n    # Set outputs for non-committed units\n    p_i[~candidate_mask] = 0\n    \n    # Format output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056659523,
          "gap_price_rate": 0.0086261957,
          "fitness": 0.007146074
     },
     {
          "name": "enhanced_adaptive_commitment",
          "algorithm": "1. Classify units into four groups:\n   a) Must-on: Online units that cannot shut down (inadequate min up-time or previous output > shutdown capacity)\n   b) Must-off: Offline units that cannot start (inadequate min down-time)\n   c) Flexible-on: Online units eligible for shutdown (p_i_0 \u2264 p_down_i)\n   d) Flexible-off: Offline units eligible for start (p_min_i \u2264 min(p_max_i, p_start_i))\n2. Form initial candidate set (must-on + flexible-on). Compute system min/max:\n   a) For must-on/flexible-on: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   b) For flexible-off: min = p_min_i, max = min(p_max_i, p_start_i)\n3. Handle load imbalance:\n   a) Case 1 (load > system max): Commit flexible-off units by ascending (startup cost + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i\n   b) Case 2 (load < system min): Decommit flexible-on units by descending min_output\n   c) Case 3 (system min \u2264 load \u2264 system max): Decommit expensive flexible-on units with output safety (new_min \u2264 load \u2264 new_max after decommit)\n4. Enhanced dispatch for committed units:\n   a) Set initial output = unit-specific min\n   b) Compute residual = load - sum(initial outputs)\n   c) Increase outputs on units with lowest marginal cost while respecting max limits\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Unpack unit info into separate arrays for efficiency\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize commitment and output arrays\n    u_i = np.zeros(num_units, dtype=int)\n    p_i = np.zeros(num_units)\n    \n    # Classify units\n    must_on_mask = (u_i_0 == 1) & ((t_i_0 < t_on_min) | (p_i_0 > p_shut))\n    must_off_mask = (u_i_0 == 0) & (-t_i_0 < t_off_min)\n    flexible_on_mask = (u_i_0 == 1) & ~must_on_mask & (p_i_0 <= p_down)\n    flexible_off_mask = (u_i_0 == 0) & ~must_off_mask & (p_min <= np.minimum(p_max, p_start))\n    \n    # Set must-on/must-off states\n    u_i[must_on_mask] = 1\n    u_i[must_off_mask] = 0\n    \n    # Candidate set (must-on + flexible-on initially)\n    candidate_mask = must_on_mask | flexible_on_mask\n    \n    # Compute min/max boundaries for candidates\n    candidate_min = np.zeros(num_units)\n    candidate_max = np.zeros(num_units)\n    \n    # For online candidates\n    online_candidate = must_on_mask | flexible_on_mask\n    candidate_min[online_candidate] = np.maximum(p_min[online_candidate], p_i_0[online_candidate] - p_down[online_candidate])\n    candidate_max[online_candidate] = np.minimum(p_max[online_candidate], p_i_0[online_candidate] + p_up[online_candidate])\n    \n    # For offline flexible units\n    flexible_off_ids = np.where(flexible_off_mask)[0]\n    candidate_min[flexible_off_ids] = p_min[flexible_off_ids]\n    candidate_max[flexible_off_ids] = np.minimum(p_max[flexible_off_ids], p_start[flexible_off_ids])\n    \n    system_min = np.sum(candidate_min[candidate_mask])\n    system_max = np.sum(candidate_max[candidate_mask])\n    \n    # Handle commitment cases\n    if load > system_max and np.any(flexible_off_mask):\n        # Case 1: Underproduction - start flexible-off units\n        avg_costs = (s[flexible_off_ids] + a[flexible_off_ids] + b[flexible_off_ids] * p_min[flexible_off_ids] \n                   + c[flexible_off_ids] * p_min[flexible_off_ids]**2) / p_min[flexible_off_ids]\n        priority_order = np.argsort(avg_costs)\n        for idx in priority_order:\n            unit_id = flexible_off_ids[idx]\n            candidate_mask[unit_id] = True\n            system_min += p_min[unit_id]\n            system_max += np.minimum(p_max[unit_id], p_start[unit_id])\n            if system_max >= load:\n                break\n                \n    elif load < system_min and np.any(flexible_on_mask):\n        # Case 2: Overproduction - decommit flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        min_outputs = candidate_min[flexible_on_ids]\n        priority_order = np.argsort(min_outputs)[::-1]  # Descending min output\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            if load >= system_min:\n                break\n            candidate_mask[unit_id] = False\n            system_min -= min_outputs[np.where(flexible_on_ids == unit_id)[0][0]]\n            system_max -= candidate_max[unit_id]\n            flexible_on_mask[unit_id] = False\n    \n    elif system_min <= load <= system_max and np.any(flexible_on_mask):\n        # Case 3: Within bounds - decommit expensive flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        avg_costs = (a[flexible_on_ids] + b[flexible_on_ids] * p_min[flexible_on_ids] \n                   + c[flexible_on_ids] * p_min[flexible_on_ids]**2) / p_min[flexible_on_ids]\n        priority_order = np.argsort(avg_costs)[::-1]  # Descending cost\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            new_min = system_min - candidate_min[unit_id]\n            new_max = system_max - candidate_max[unit_id]\n            if new_min <= load <= new_max:\n                candidate_mask[unit_id] = False\n                system_min, system_max = new_min, new_max\n    \n    # Update commitment state\n    u_i[candidate_mask] = 1\n    \n    # Economic dispatch for committed units\n    unit_min = np.zeros(num_units)\n    unit_max = np.zeros(num_units)\n    \n    # Set boundaries based on state\n    for i in range(num_units):\n        if candidate_mask[i]:\n            if u_i_0[i] == 1:  # Already online\n                unit_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                unit_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # Started this period\n                unit_min[i] = p_min[i]\n                unit_max[i] = min(p_max[i], p_start[i])\n    \n    # Initialize outputs at min levels\n    p_i[candidate_mask] = unit_min[candidate_mask]\n    residual = load - np.sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5 and np.any(p_i[candidate_mask] < unit_max[candidate_mask]):\n        # Find cheapest available unit\n        marginal_costs = b + 2 * c * p_i\n        marginal_costs[~candidate_mask] = np.inf\n        marginal_costs[p_i >= unit_max] = np.inf\n        \n        if np.all(marginal_costs == np.inf):\n            break\n            \n        cheapest_id = np.argmin(marginal_costs)\n        \n        # Calculate max possible increase\n        headroom = unit_max[cheapest_id] - p_i[cheapest_id]\n        increment = min(residual, headroom)\n        \n        # Update output and residual\n        p_i[cheapest_id] += increment\n        residual -= increment\n    \n    # Set outputs for non-committed units\n    p_i[~candidate_mask] = 0\n    \n    # Format output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056659523,
          "gap_price_rate": 0.0086261957,
          "fitness": 0.007146074
     },
     {
          "name": "enhanced_adaptive_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_adaptive_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n, dtype=int)\n    p = np.zeros(n, dtype=float)\n    \n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min) or (p_i0 > p_shut):\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:\n            if -t_i0 < t_off_min:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    must_on_min_total = 0.0\n    must_on_max_total = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_i0 = unit['p_i_0']\n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        must_on_min_total += low_bound\n        must_on_max_total += high_bound\n    \n    commit_set = []\n    \n    if load >= must_on_min_total and load <= must_on_max_total:\n        commit_set = must_on[:]\n    elif load > must_on_max_total:\n        commit_set = must_on + flexible_on\n        candidate_max = must_on_max_total\n        for i in flexible_on:\n            unit = units_info[i]\n            p_i0 = unit['p_i_0']\n            p_up = unit['p_up_i']\n            p_max = unit['p_max_i']\n            high_bound_i = min(p_max, p_i0 + p_up)\n            candidate_max += high_bound_i\n            \n        cost_per_mw = []\n        for i in flexible_off:\n            unit = units_info[i]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            cost = (s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)) / p_min_i\n            cost_per_mw.append((cost, i))\n        cost_per_mw.sort(key=lambda x: x[0])\n        \n        for cost, i in cost_per_mw:\n            unit = units_info[i]\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            high_bound_i = min(p_max_i, p_start_i)\n            candidate_max += high_bound_i\n            commit_set.append(i)\n            if candidate_max >= load:\n                break\n                \n        non_must_on = [i for i in commit_set if i not in must_on]\n        avoidable_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            p_min = unit['p_min_i']\n            if i in flexible_on:\n                avoidable = a + b * p_min + c * (p_min ** 2)\n            else:\n                s = unit['s_i']\n                avoidable = s + a + b * p_min + c * (p_min ** 2)\n                \n            if i in flexible_on:\n                p_i0 = unit['p_i_0']\n                p_up_i = unit['p_up_i']\n                p_max_i = unit['p_max_i']\n                max_output = min(p_max_i, p_i0 + p_up_i)\n            else:\n                p_start_i = unit['p_start_i']\n                p_max_i = unit['p_max_i']\n                max_output = min(p_max_i, p_start_i)\n                \n            avoidable_costs.append((avoidable, max_output, i))\n            \n        avoidable_costs.sort(key=lambda x: x[0], reverse=True)\n        for avoidable, max_output, i in avoidable_costs:\n            if candidate_max - max_output >= load:\n                candidate_max -= max_output\n                commit_set.remove(i)\n        \n    else:\n        commit_set = must_on[:]\n    \n    low_bounds = np.zeros(n)\n    high_bounds = np.zeros(n)\n    p_values = np.zeros(n)\n    \n    for i in commit_set:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            low_bound = max(p_min_i, p_i0 - p_down_i)\n            high_bound = min(p_max_i, p_i0 + p_up_i)\n        else:\n            low_bound = p_min_i\n            high_bound = min(p_max_i, p_start_i)\n            \n        low_bounds[i] = low_bound\n        high_bounds[i] = high_bound\n        p_values[i] = low_bound\n        \n    total_min = np.sum(p_values)\n    residual = load - total_min\n    \n    if residual > 0:\n        available_units = [i for i in commit_set if p_values[i] < high_bounds[i]]\n        while residual > 0 and available_units:\n            min_mc = float('inf')\n            best_i = None\n            for i in available_units:\n                unit = units_info[i]\n                b = unit['b_i']\n                c = unit['c_i']\n                mc = b + 2 * c * p_values[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_i = i\n                    \n            if best_i is None:\n                break\n                \n            max_add = high_bounds[best_i] - p_values[best_i]\n            add = min(max_add, residual)\n            p_values[best_i] += add\n            residual -= add\n            if p_values[best_i] >= high_bounds[best_i]:\n                available_units.remove(best_i)\n                \n    for i in commit_set:\n        u[i] = 1\n        \n    return np.array([u, p_values])",
          "from": "crossover",
          "gap_power_rate": 0.0055922217,
          "gap_price_rate": 0.0089152336,
          "fitness": 0.0072537276
     }
]