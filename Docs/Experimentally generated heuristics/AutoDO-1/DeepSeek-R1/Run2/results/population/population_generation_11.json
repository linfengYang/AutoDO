[
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "enhanced_combined_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-on (online units violating min up-time/shutdown constraints), must-off (offline units violating min down-time), flexible-on (eligible online units), and flexible-off (eligible offline units)\n2. Compute must-on generation bounds incorporating ramp constraints\n3. Case handling:\n   a) Load within must-on range: commit only must-on units\n   b) Load exceeds must-on capacity:\n      - Start flexible-off units by ascending cost-per-MW including startup costs\n      - Form candidate set with must-on + flexible-on + started units\n      - Decommit expensive non-must-on units using operating cost efficiency\n   c) Load below must-on min: set must-on units to minimum generation\n4. Set power bounds considering online/startup constraints\n5. Initialize outputs at effective lower bounds\n6. Distribute residual load via marginal cost-based greedy allocation\n7. Set uncommitted units to off-state\n",
          "code": "import numpy as np\n\ndef enhanced_combined_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    tolerance = 1e-5\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Compute must-on bounds\n    total_min_must = 0.0\n    total_max_must = 0.0\n    must_on_bounds = {}\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_bounds[idx] = (lb, ub)\n        total_min_must += lb\n        total_max_must += ub\n    \n    # Load case handling\n    commit_set = set(must_on)\n    \n    if load <= total_min_must:\n        pass  # Only must-on units committed\n    elif load > total_max_must:\n        # Compute current capacity\n        candidate_set = set(must_on) | set(flexible_on)\n        total_capacity = total_max_must\n        \n        for idx in flexible_on:\n            unit = units_info[idx]\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_capacity += ub\n        \n        # Start flexible-off units\n        started = []\n        start_candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            start_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*min_p + unit['c_i']*(min_p**2)\n            metric = start_cost / min_p\n            start_candidates.append((metric, idx))\n        \n        start_candidates.sort(key=lambda x: x[0])\n        \n        for metric, idx in start_candidates:\n            if total_capacity >= load:\n                break\n            unit = units_info[idx]\n            max_capacity = min(unit['p_max_i'], unit['p_start_i'])\n            total_capacity += max_capacity\n            candidate_set.add(idx)\n            started.append(idx)\n        \n        # Decommit non-must-on units\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        decommit_candidates = []\n        for idx in non_must_on:\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            op_cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*(min_p**2)\n            metric = op_cost / min_p\n            decommit_candidates.append((metric, idx))\n        \n        decommit_candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for metric, idx in decommit_candidates:\n            if idx in flexible_on:\n                capacity = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            else:\n                capacity = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            \n            if total_capacity - capacity >= load:\n                total_capacity -= capacity\n                candidate_set.remove(idx)\n        \n        commit_set = candidate_set\n    else:\n        pass  # Only must-on units committed\n    \n    # Set commitment status and initial outputs\n    lb_dict = {}\n    ub_dict = {}\n    total_min = 0.0\n    \n    for idx in commit_set:\n        u[idx] = 1\n        if units_info[idx]['u_i_0'] == 1:\n            lb = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            ub = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n        else:\n            lb = units_info[idx]['p_min_i']\n            ub = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n        lb_dict[idx] = lb\n        ub_dict[idx] = ub\n        p[idx] = lb\n        total_min += lb\n    \n    # Distribute residual load\n    residual = load - total_min\n    \n    if residual > tolerance:\n        # Continue until residual is allocated or no more capacity\n        while residual > tolerance:\n            candidates = []\n            for idx in commit_set:\n                if p[idx] < ub_dict[idx] - tolerance:\n                    marginal_cost = 2*units_info[idx]['c_i']*p[idx] + units_info[idx]['b_i']\n                    candidates.append((marginal_cost, idx))\n            \n            if not candidates:\n                break\n                \n            min_mc = min(candidates, key=lambda x: x[0])\n            idx = min_mc[1]\n            step = min(residual, ub_dict[idx] - p[idx])\n            p[idx] += step\n            residual -= step\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085223254,
          "fitness": 0.006846618
     },
     {
          "name": "enhanced_hybrid_dynamic_commitment",
          "algorithm": "1. Classify units into:  \n   - must_on: Units that must remain on (if (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i))  \n   - must_off: Units that must remain off (if abs(t_i_0) < t_off_min_i)  \n   - flexible_on: Online units eligible for shutdown  \n   - flexible_off: Offline units eligible for startup  \n2. Compute min/max bounds for must_on units:  \n   - Lower bound: max(p_min_i, p_i_0 - p_down_i)  \n   - Upper bound: min(p_max_i, p_i_0 + p_up_i)  \n3. Case handling:  \n   a) If load between must_on bounds: Commit only must_on units  \n   b) If load > must_on max:  \n        - Form candidate_set = must_on + flexible_on  \n        - Start flexible_off units by priority: min((s_i + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i)  \n        - After exceeding load, decommit non-must-on units by: max((2 * c_i * p_min_i + b_i) / p_min_i)  \n   c) If load < must_on min: Commit only must_on units  \n4. For committed units:  \n   a) Set power bounds based on state:  \n        - Online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]  \n        - Startup: [p_min_i, min(p_max_i, p_start_i)]  \n   b) Initialize at lower bounds  \n   c) Distribute residual via adaptive marginal cost allocation:  \n        - Create max_increasable_units (units below upper bound)  \n        - While residual > 0 and max_increasable_units:  \n            1. Compute current marginal costs  \n            2. Find unit with min marginal cost and next min cost  \n            3. Calculate max increase before marginal cost match  \n            4. Allocate largest possible step  \n5. Set non-committed units to off-state (u_i=0, p_i=0)  \n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_dynamic_commitment(units_info, load):\n    n = len(units_info)\n    schedules = np.zeros((2, n))\n    u = np.zeros(n)\n    p = np.zeros(n)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        p_min_i = unit['p_min_i']\n        \n        if u_i0 == 1:  # Was online\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Was offline\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Compute must_on bounds\n    total_min_must = 0.0\n    total_max_must = 0.0\n    must_on_lower = [0] * n\n    must_on_upper = [0] * n\n    \n    for i in must_on:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_i0 = unit['p_i_0']\n        \n        lower = max(p_min_i, p_i0 - p_down_i)\n        upper = min(p_max_i, p_i0 + p_up_i)\n        must_on_lower[i] = lower\n        must_on_upper[i] = upper\n        total_min_must += lower\n        total_max_must += upper\n    \n    candidate_set = []\n    \n    # Case handling\n    if total_min_must <= load <= total_max_must:\n        candidate_set = must_on.copy()\n    elif load > total_max_must:\n        candidate_set = must_on + flexible_on\n        total_min_candidate = total_min_must\n        total_max_candidate = total_max_must\n        \n        # Compute flexible_on bounds\n        for i in flexible_on:\n            unit = units_info[i]\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            p_i0 = unit['p_i_0']\n            \n            lower = max(p_min_i, p_i0 - p_down_i)\n            upper = min(p_max_i, p_i0 + p_up_i)\n            total_min_candidate += lower\n            total_max_candidate += upper\n        \n        # Start flexible_off units\n        flexible_off_sorted = sorted(\n            flexible_off,\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                          units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n        )\n        \n        for i in flexible_off_sorted:\n            if total_max_candidate >= load:\n                break\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_candidate += max_i\n            total_min_candidate += unit['p_min_i']\n            candidate_set.append(i)\n        \n        # Decommit non-must-on units\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        non_must_on_sorted = sorted(\n            non_must_on,\n            key=lambda i: (2 * units_info[i]['c_i'] * units_info[i]['p_min_i'] + units_info[i]['b_i']) / units_info[i]['p_min_i'],\n            reverse=True\n        )\n        \n        for i in non_must_on_sorted:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if i in flexible_on else min(unit['p_max_i'], unit['p_start_i'])\n            \n            new_min = total_min_candidate - min_i\n            new_max = total_max_candidate - max_i\n            if new_min <= load <= new_max:\n                total_min_candidate = new_min\n                total_max_candidate = new_max\n                candidate_set.remove(i)\n    else:  # load < total_min_must\n        candidate_set = must_on.copy()\n    \n    # Set power bounds for candidate_set\n    p_lower = [0] * n\n    p_upper = [0] * n\n    \n    for i in candidate_set:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_i0 = unit['p_i_0']\n        \n        if i in must_on or i in flexible_on:\n            p_lower[i] = max(p_min_i, p_i0 - p_down_i)\n            p_upper[i] = min(p_max_i, p_i0 + p_up_i)\n        else:  # Started flexible_off\n            p_lower[i] = p_min_i\n            p_upper[i] = min(p_max_i, unit['p_start_i'])\n    \n    # Initialize outputs\n    total_output = 0.0\n    for i in candidate_set:\n        p[i] = p_lower[i]\n        total_output += p[i]\n        u[i] = 1\n    \n    residual = load - total_output\n    \n    # Distribute residual load\n    if residual > 0:\n        max_increasable_units = [i for i in candidate_set if p[i] < p_upper[i]]\n        \n        while residual > 1e-6 and max_increasable_units:\n            marginal_costs = []\n            for i in max_increasable_units:\n                marginal_costs.append(2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i'])\n            \n            min_idx = max_increasable_units[0]\n            min_mc = marginal_costs[0]\n            next_mc = float('inf')\n            \n            # Find min and next marginal costs\n            for idx, mc_val in zip(max_increasable_units, marginal_costs):\n                if mc_val < min_mc:\n                    next_mc = min_mc\n                    min_mc = mc_val\n                    min_idx = idx\n                elif min_mc < mc_val < next_mc:\n                    next_mc = mc_val\n            \n            # Calculate max possible increase\n            available = p_upper[min_idx] - p[min_idx]\n            if next_mc == float('inf'):\n                step = min(residual, available)\n            else:\n                c_i = units_info[min_idx]['c_i']\n                if c_i == 0:\n                    step = min(residual, available)\n                else:\n                    delta = (next_mc - min_mc) / (2 * c_i)\n                    step = min(delta, available, residual)\n            \n            p[min_idx] += step\n            residual -= step\n            \n            # Update max_increasable_units\n            max_increasable_units = [i for i in candidate_set if p[i] < p_upper[i]]\n    \n    # Finalize schedules\n    for i in candidate_set:\n        u[i] = 1\n    for i in range(n):\n        if i not in candidate_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules[0, :] = u\n    schedules[1, :] = p\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0044798733,
          "gap_price_rate": 0.0092395778,
          "fitness": 0.0068597255
     },
     {
          "name": "enhanced_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (online units that cannot shut down due to min-up time or shutdown constraints), must-off (offline units that cannot start due to min-down time), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for startup).\n2. Calculate total min/max output from must-on units considering ramp constraints.\n3. Handle three load cases:\n   a) Load within must-on range: Commit only must-on units\n   b) Load exceeds must-on capacity:\n        - Form candidate set with must-on + flexible-on units\n        - Start flexible-off units by ascending cost-per-MW priority until capacity >= load\n        - Decommit expensive non-must-on units from the candidate set in descending cost-per-MW order if excess capacity exists\n   c) Load below must-on minimum: Commit only must-on units, allowing overproduction\n4. For committed units:\n        a) Calculate power bounds considering operational state (online/startup)\n        b) Initialize outputs at lower bounds\n        c) Distribute residual load using a priority queue that continuously updates based on marginal costs\n5. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_hybrid_commitment(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    flexible_on = []\n    flexible_off = []\n    for i, unit in enumerate(units_info):\n        if i in must_on or i in must_off:\n            continue\n        if unit['u_i_0'] == 1:\n            flexible_on.append(i)\n        else:\n            flexible_off.append(i)\n    \n    # Calculate must-on bounds\n    total_min_must_on = 0.0\n    total_max_must_on = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_must_on += lb\n        total_max_must_on += ub\n    \n    commit_set = set()\n    # Handle load cases\n    if load <= total_max_must_on and load >= total_min_must_on:\n        commit_set = set(must_on)\n    elif load < total_min_must_on:\n        commit_set = set(must_on)\n    else:  # load > total_max_must_on\n        commit_set = set(must_on) | set(flexible_on)\n        total_max_current = 0.0\n        for i in commit_set:\n            unit = units_info[i]\n            total_max_current += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        # Start flexible-off units\n        candidate_flex_off = []\n        for i in flexible_off:\n            unit = units_info[i]\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n            candidate_flex_off.append((cost_per_mw, i))\n        candidate_flex_off.sort(key=lambda x: x[0])\n        \n        started_units = []\n        for cost, i in candidate_flex_off:\n            if total_max_current >= load:\n                break\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_current += max_i\n            started_units.append(i)\n        \n        commit_set |= set(started_units)\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [i for i in commit_set if i not in must_on]\n        metrics = []\n        cap_dict = {}\n        for i in non_must_on:\n            unit = units_info[i]\n            if i in flexible_on:\n                cap_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                               unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            else:\n                cap_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                               unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            metrics.append((cost_per_mw, i))\n        metrics.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in metrics:\n            if total_max_current - cap_dict[i] >= load:\n                total_max_current -= cap_dict[i]\n                commit_set.remove(i)\n    \n    # Dispatch\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    bounds = {}\n    for i in commit_set:\n        u_arr[i] = 1\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (lb, ub)\n        p_arr[i] = lb\n    \n    total_min = np.sum(p_arr)\n    if total_min < load:\n        heap = []\n        for i in commit_set:\n            lb, ub = bounds[i]\n            current = p_arr[i]\n            marginal_cost = 2 * units_info[i]['c_i'] * current + units_info[i]['b_i']\n            heapq.heappush(heap, (marginal_cost, i, current, lb, ub, units_info[i]['c_i'], units_info[i]['b_i']))\n        \n        residual = load - total_min\n        while residual > 0 and heap:\n            mc, i, current, lb, ub, c_i, b_i = heapq.heappop(heap)\n            max_inc = ub - current\n            if max_inc <= 0:\n                continue\n            delta = min(max_inc, residual)\n            new_output = current + delta\n            residual -= delta\n            p_arr[i] = new_output\n            if new_output < ub:\n                new_mc = 2 * c_i * new_output + b_i\n                heapq.heappush(heap, (new_mc, i, new_output, lb, ub, c_i, b_i))\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "refined_enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into four states: must-on (units violating min up-time/shutdown capacity), must-off (units violating min down-time), flexible-on (eligible online units), flexible-off (eligible offline units)  \n2. Calculate must-on generation bounds incorporating ramp constraints  \n3. Case handling:  \n   a) Load within must-on bounds: commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by ascending cost-per-MW metric  \n      - Decommit expensive flexible-on units using incremental capacity efficiency  \n   c) Load below must-on min: must-on units operate at minimum output  \n4. Compute dynamic power bounds per unit based on commitment history  \n5. Initialize outputs at lower bounds  \n6. Distribute residual load via marginal cost-ordered priority queue  \n7. Set uncommitted units to off-state  \n\n",
          "code": "import heapq\nimport numpy as np\n\ndef refined_enhanced_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Initialize lists for unit classifications\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units based on operational constraints\n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Previously online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Previously offline\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Calculate must-on generation bounds\n    must_on_min = 0.0\n    must_on_max = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        min_bound = max(p_min, p_i_0 - p_down_i)\n        max_bound = min(p_max, p_i_0 + p_up_i)\n        must_on_min += min_bound\n        must_on_max += max_bound\n    \n    # Case handling for load allocation\n    candidate_set = set(must_on)  # Units to be committed\n    \n    if must_on_min <= load <= must_on_max:\n        # Case 3a: Load within must-on bounds\n        candidate_set = set(must_on)\n    \n    elif load > must_on_max:\n        # Case 3b: Load exceeds must-on capacity\n        candidate_set = set(must_on + flexible_on)\n        \n        # Calculate candidate set capacity\n        cand_min = must_on_min\n        cand_max = must_on_max\n        for i in flexible_on:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            \n            min_bound = max(p_min, p_i_0 - p_down_i)\n            max_bound = min(p_max, p_i_0 + p_up_i)\n            cand_min += min_bound\n            cand_max += max_bound\n        \n        # Start flexible-off units if needed (cost-per-MW priority)\n        if cand_max < load:\n            cost_per_mw = []\n            for i in flexible_off:\n                unit = units_info[i]\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                \n                startup_cost = s_i\n                cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n                metric = (startup_cost + cost_at_min) / p_min_i\n                cost_per_mw.append((metric, i))\n            \n            cost_per_mw.sort(key=lambda x: x[0])\n            \n            for metric, i in cost_per_mw:\n                if cand_max >= load:\n                    break\n                \n                unit = units_info[i]\n                p_min_i = unit['p_min_i']\n                p_max_i = unit['p_max_i']\n                p_start_i = unit['p_start_i']\n                \n                max_output = min(p_max_i, p_start_i)\n                cand_min += p_min_i\n                cand_max += max_output\n                candidate_set.add(i)\n        \n        # Decommit expensive flexible-on units\n        cost_efficiency = []\n        for i in candidate_set - set(must_on):\n            unit = units_info[i]\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            \n            min_bound = max(p_min_i, p_i_0 - p_down_i)\n            max_bound = min(unit['p_max_i'], p_i_0 + p_up_i)\n            incremental_cap = max_bound - min_bound\n            cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n            metric = cost_at_min / incremental_cap if incremental_cap > 0 else float('inf')\n            cost_efficiency.append((metric, i, min_bound, max_bound))\n        \n        cost_efficiency.sort(key=lambda x: x[0], reverse=True)\n        \n        for metric, i, min_bound, max_bound in cost_efficiency:\n            if i not in candidate_set:\n                continue\n                \n            new_min = cand_min - min_bound\n            new_max = cand_max - max_bound\n            \n            if new_max >= load:\n                candidate_set.remove(i)\n                cand_min = new_min\n                cand_max = new_max\n    \n    else:  # Case 3c: Load below must-on minimum\n        candidate_set = set(must_on)\n    \n    # Compute power bounds per unit\n    lower_bounds = np.zeros(num_units)\n    upper_bounds = np.zeros(num_units)\n    for i in range(num_units):\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if i in candidate_set:\n            if u_i_0 == 1:  # Continuation from online state\n                lower_bounds[i] = max(p_min_i, p_i_0 - p_down_i)\n                upper_bounds[i] = min(p_max_i, p_i_0 + p_up_i)\n            else:  # Starting from offline state\n                lower_bounds[i] = p_min_i\n                upper_bounds[i] = min(p_max_i, p_start_i)\n        else:\n            lower_bounds[i] = 0\n            upper_bounds[i] = 0\n    \n    # Initialize outputs at lower bounds\n    outputs = lower_bounds.copy()\n    total_output = np.sum(outputs)\n    residual = load - total_output\n    \n    # Economic dispatch via priority queue\n    heap = []\n    for i in candidate_set:\n        if outputs[i] < upper_bounds[i]:\n            marginal_cost = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    while residual > 0 and heap:\n        marginal_cost, i = heapq.heappop(heap)\n        available = upper_bounds[i] - outputs[i]\n        \n        if available > 0:\n            increment = min(available, residual)\n            outputs[i] += increment\n            residual -= increment\n            \n            # Update marginal cost and push back if capacity remains\n            if outputs[i] < upper_bounds[i]:\n                new_marginal = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                heapq.heappush(heap, (new_marginal, i))\n    \n    # Build final schedule\n    for i in range(num_units):\n        schedules[0, i] = 1 if i in candidate_set else 0\n        schedules[1, i] = outputs[i] if i in candidate_set else 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0052449584,
          "gap_price_rate": 0.0085332973,
          "fitness": 0.0068891278
     },
     {
          "name": "refined_adaptive_commitment",
          "algorithm": "1. Classify units into must-on (online and unable to shut down due to min-up time or shutdown constraints), must-off (offline and unable to start due to min-down time), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for startup).  \n2. Calculate must-on min/max outputs with ramp constraints.  \n3. Handle cases:  \n   a) If load \u2264 total must-on min \u2192 Set commit_set=must-on  \n   b) If total must-on min < load \u2264 total must-on max \u2192 Set commit_set=must-on  \n   c) If load > total must-on max:  \n      - Form candidate_set (must-on + flexible-on)  \n      - Start flexible-off units by cost-per-MW priority until max capacity \u2265 load  \n      - Add started units to candidate_set  \n      - Decommit expensive non-must-on units from candidate_set while ensuring capacity \u2265 load  \n4. For each committed unit:  \n   a) Compute power bounds considering current state  \n   b) Initialize outputs at lower bounds  \n   c) Distribute residual load using marginal cost-based greedy allocation  \n5. Set uncommitted units to off state.  \n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_commitment(units_info, load):\n    # Initialize classification lists\n    must_on_units = []\n    must_off_units = []\n    flexible_on_units = []\n    flexible_off_units = []\n    \n    # Step 1: Classify units\n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on_units.append(unit)\n            else:\n                flexible_on_units.append(unit)\n        else:  # Previously offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                flexible_off_units.append(unit)\n    \n    # Initialize commit set and other containers\n    commit_set = []\n    started_units = []\n    \n    # Step 2: Calculate must-on bounds\n    total_must_on_min = 0\n    total_must_on_max = 0\n    for unit in must_on_units:\n        # Compute ramp-constrained bounds\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['min_output'] = min_output\n        unit['max_output'] = max_output\n        total_must_on_min += min_output\n        total_must_on_max += max_output\n    \n    # Step 3: Case handling\n    # Case 1: Load \u2264 total must-on min\n    if load <= total_must_on_min:\n        commit_set = must_on_units\n    \n    # Case 2: Load within must-on range\n    elif total_must_on_min < load <= total_must_on_max:\n        commit_set = must_on_units\n    \n    # Case 3: Load exceeds must-on capacity\n    else:\n        # Compute bounds for flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        for unit in flexible_on_units:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_output'] = min_output\n            unit['max_output'] = max_output\n            flex_on_min += min_output\n            flex_on_max += max_output\n        \n        # Form initial candidate set\n        commit_set = must_on_units + flexible_on_units\n        total_min = total_must_on_min + flex_on_min\n        total_max = total_must_on_max + flex_on_max\n        \n        # Start flexible-off units by cost-per-MW priority\n        if total_max < load:\n            # Calculate cost per MW at min output\n            cost_per_mw = []\n            for unit in flexible_off_units:\n                min_output = unit['p_min_i']\n                cost_at_min = (unit['a_i'] + unit['b_i'] * min_output + \n                              unit['c_i'] * min_output ** 2 + unit['s_i'])\n                cost_per_mw.append(cost_at_min / min_output)\n            \n            # Sort by cost per MW (ascending)\n            sorted_indices = np.argsort(cost_per_mw)\n            sorted_flex_off = [flexible_off_units[i] for i in sorted_indices]\n            \n            # Start units until max capacity \u2265 load\n            for unit in sorted_flex_off:\n                unit_max = min(unit['p_max_i'], unit['p_start_i'])\n                unit['min_output'] = unit['p_min_i']\n                unit['max_output'] = unit_max\n                commit_set.append(unit)\n                started_units.append(unit)\n                total_max += unit_max\n                if total_max >= load:\n                    break\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [u for u in commit_set if u not in must_on_units]\n        if non_must_on:\n            # Calculate marginal cost at min output\n            marginal_costs = []\n            for unit in non_must_on:\n                marginal_costs.append(unit['b_i'] + 2 * unit['c_i'] * unit['min_output'])\n            \n            # Sort by marginal cost (descending)\n            sorted_indices = np.argsort(marginal_costs)[::-1]\n            sorted_non_must_on = [non_must_on[i] for i in sorted_indices]\n            \n            # Decommit units with excess capacity\n            current_min = total_min\n            current_max = total_max\n            for unit in sorted_non_must_on:\n                if current_max - unit['max_output'] >= load:\n                    commit_set.remove(unit)\n                    current_min -= unit['min_output']\n                    current_max -= unit['max_output']\n    \n    # Step 4: Dispatch load to committed units\n    # Initialize each unit's output and bounds\n    for unit in commit_set:\n        if unit in started_units:\n            unit['lb'] = unit['p_min_i']\n            unit['ub'] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            unit['lb'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['ub'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['p_i'] = unit['lb']\n    \n    # Distribute residual load\n    total_allocated = sum(unit['p_i'] for unit in commit_set)\n    residual = load - total_allocated\n    \n    # Greedy allocation based on marginal costs\n    if residual > 0:\n        # Create updatable allocation state\n        while residual > 0:\n            # Find unit with smallest marginal cost that can increase\n            best_unit = None\n            best_marginal_cost = float('inf')\n            for unit in commit_set:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                if unit['p_i'] < unit['ub'] and marginal_cost < best_marginal_cost:\n                    best_marginal_cost = marginal_cost\n                    best_unit = unit\n            \n            if best_unit is None:\n                break  # No more units can increase\n            \n            # Calculate max possible increase for this unit\n            max_increase = best_unit['ub'] - best_unit['p_i']\n            allocation = min(residual, max_increase)\n            \n            # Update allocation and residual\n            best_unit['p_i'] += allocation\n            residual -= allocation\n    \n    # Step 5: Prepare output schedule\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    for i, unit in enumerate(units_info):\n        if unit in commit_set:\n            schedules[0, i] = 1  # u_i = 1\n            schedules[1, i] = unit['p_i']  # p_i allocated\n        else:\n            schedules[0, i] = 0  # u_i = 0\n            schedules[1, i] = 0  # p_i = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0086067699,
          "fitness": 0.0068906524
     },
     {
          "name": "refined_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (online and cannot shut down due to minimum up-time or shutdown constraints), must-off (offline and cannot start due to minimum down-time), flexible-on (online and eligible for shutdown), flexible-off (offline and eligible for startup)  \n2. Calculate total minimum/maximum output from must-on units considering ramp constraints  \n3. Case handling:  \n   a) Load within must-on range: Commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by cost/MW priority until capacity \u2265 load  \n      - Decommit expensive flexible-on/started units if possible while maintaining capacity feasibility  \n   c) Load below must-on minimum: Commit only must-on (overproduction unavoidable)  \n4. For committed units:  \n   a) Calculate power bounds considering online state/startup constraints  \n   b) Initialize outputs at minimum bounds  \n   c) Distribute residual load using greedy marginal cost-based allocation  \n5. Set uncommitted units to off state with zero output  \n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Calculate must-on capacity\n    must_on_min = must_on_max = 0\n    must_on_min_bounds = {}\n    must_on_max_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_min_bounds[idx] = min_bound\n        must_on_max_bounds[idx] = max_bound\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on)\n    elif load > must_on_max:\n        candidate_set = set(must_on + flexible_on)\n        min_candidate = must_on_min\n        max_candidate = must_on_max\n        \n        # Add flexible-on capacity\n        for idx in flexible_on:\n            unit = units_info[idx]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_candidate += min_bound\n            max_candidate += max_bound\n        \n        # Start flexible-off units if needed\n        if max_candidate < load:\n            priority_list = []\n            for idx in flexible_off:\n                unit = units_info[idx]\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                              unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n                priority_list.append((cost_per_mw, idx))\n            priority_list.sort(key=lambda x: x[0])\n            \n            for _, idx in priority_list:\n                if max_candidate >= load:\n                    break\n                unit = units_info[idx]\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n                max_candidate += max_bound\n                candidate_set.add(idx)\n        \n        # Decommit expensive units if excess capacity\n        non_must_on = [idx for idx in candidate_set if idx not in must_on]\n        if max_candidate > load and non_must_on:\n            min_bounds = {}\n            max_bounds = {}\n            for idx in candidate_set:\n                if idx in must_on:\n                    min_bounds[idx] = must_on_min_bounds.get(idx, units_info[idx]['p_min_i'])\n                    max_bounds[idx] = must_on_max_bounds.get(idx, units_info[idx]['p_max_i'])\n                else:\n                    unit = units_info[idx]\n                    if unit['u_i_0'] == 1:  # flexible-on\n                        min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:  # started unit\n                        min_bounds[idx] = unit['p_min_i']\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            cost_per_mw = {}\n            for idx in non_must_on:\n                unit = units_info[idx]\n                cost_per_mw[idx] = (unit['a_i'] + unit['b_i']*min_bounds[idx] + \n                                   unit['c_i']*(min_bounds[idx]**2)) / min_bounds[idx]\n            \n            sorted_non_must = sorted(non_must_on, key=lambda idx: cost_per_mw[idx], reverse=True)\n            \n            for idx in sorted_non_must:\n                if min_candidate - min_bounds[idx] <= load <= max_candidate - max_bounds[idx]:\n                    candidate_set.remove(idx)\n                    min_candidate -= min_bounds[idx]\n                    max_candidate -= max_bounds[idx]\n                    if max_candidate < load:\n                        candidate_set.add(idx)\n                        min_candidate += min_bounds[idx]\n                        max_candidate += max_bounds[idx]\n                        break\n    else:  # load < must_on_min\n        candidate_set = set(must_on)\n    \n    # Calculate bounds for dispatch\n    min_bounds = {}\n    max_bounds = {}\n    outputs = {}\n    for idx in candidate_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # online in previous period\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # starting in current period\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[idx] = min_b\n        max_bounds[idx] = max_b\n        outputs[idx] = min_b\n    \n    # Economic dispatch\n    total_output = sum(outputs.values())\n    residual = load - total_output\n    \n    if residual > 0:\n        active_units = [idx for idx in candidate_set if outputs[idx] < max_bounds[idx]]\n        while residual > 0 and active_units:\n            min_mc = float('inf')\n            best_unit = None\n            for idx in active_units:\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * outputs[idx]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_unit = idx\n            \n            unit = units_info[best_unit]\n            increment = min(residual, max_bounds[best_unit] - outputs[best_unit])\n            outputs[best_unit] += increment\n            residual -= increment\n            \n            if outputs[best_unit] >= max_bounds[best_unit]:\n                active_units.remove(best_unit)\n    \n    # Generate output schedules\n    for idx in range(num_units):\n        if idx in candidate_set:\n            schedules[0, idx] = 1\n            schedules[1, idx] = outputs.get(idx, 0)\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "refined_combined_commitment",
          "algorithm": "1. Classify units into must-on, must-off, flexible-on, flexible-off based on operational constraints:\n   - must-on: units that were online and either haven't satisfied min up-time or previous output exceeds shutdown capacity\n   - must-off: units that were offline and haven't satisfied min down-time\n   - flexible-on: online units eligible for shutdown\n   - flexible-off: offline units eligible for startup\n\n2. Compute total min/max outputs from must-on units considering ramp constraints\n\n3. Handle three load cases:\n   a) Load within must-on range: commit only must-on units\n   b) Load exceeds must-on capacity:\n        - Form candidate set with must-on + flexible-on units\n        - Start flexible-off units by cost-per-MW priority (including startup cost)\n        - After meeting load, decommit non-must-on units by descending operating cost\n   c) Load below must-on min: commit only must-on units (overproduction unavoidable)\n\n4. For committed units:\n   a) Calculate power bounds considering operational state (online/startup)\n   b) Initialize outputs to min bounds\n   c) Distribute residual load using marginal cost-based allocation with:\n        - Priority queue ordering units by marginal cost\n        - Block allocation to minimize iteration count\n\n5. Turn off non-committed units\n",
          "code": "import heapq\nimport numpy as np\n\ndef refined_combined_commitment(units_info, load):\n    n_units = len(units_info)\n    u_arr = [0] * n_units\n    p_arr = [0.0] * n_units\n    \n    must_on_indices = set()\n    must_off_indices = set()\n    flexible_on_indices = set()\n    flexible_off_indices = set()\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                must_on_indices.add(idx)\n            else:\n                flexible_on_indices.add(idx)\n        else:\n            if t_i0 < 0 and (-t_i0 < t_off_min_i):\n                must_off_indices.add(idx)\n            else:\n                flexible_off_indices.add(idx)\n    \n    total_min_must = 0\n    total_max_must = 0\n    for idx in must_on_indices:\n        unit = units_info[idx]\n        p_i0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        min_output_i = max(p_min_i, p_i0 - p_down_i)\n        max_output_i = min(p_max_i, p_i0 + p_up_i)\n        total_min_must += min_output_i\n        total_max_must += max_output_i\n    \n    candidate_set = set()\n    \n    if total_min_must <= load <= total_max_must:\n        candidate_set = must_on_indices.copy()\n    elif load > total_max_must:\n        candidate_set = must_on_indices | flexible_on_indices\n        total_max_candidate = 0\n        for idx in candidate_set:\n            unit = units_info[idx]\n            p_i0 = unit['p_i_0']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            max_output_i = min(p_max_i, p_i0 + p_up_i)\n            total_max_candidate += max_output_i\n        \n        flexible_off_list = []\n        for idx in flexible_off_indices:\n            unit = units_info[idx]\n            s_i = unit['s_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            cost_effectiveness = (s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)) / p_min_i\n            flexible_off_list.append((cost_effectiveness, idx, unit))\n        \n        flexible_off_list.sort(key=lambda x: x[0])\n        \n        for cost_effect, idx, unit in flexible_off_list:\n            if total_max_candidate >= load:\n                break\n            p_max_i = unit['p_max_i']\n            p_start_i = unit['p_start_i']\n            max_output_i = min(p_max_i, p_start_i)\n            candidate_set.add(idx)\n            total_max_candidate += max_output_i\n        \n        non_muston = list(candidate_set - must_on_indices)\n        cost_info = []\n        for idx in non_muston:\n            unit = units_info[idx]\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n            if idx in flexible_on_indices:\n                unit_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                unit_max = min(unit['p_max_i'], unit['p_start_i'])\n            cost_info.append((cost_at_min, idx, unit, unit_max))\n        \n        cost_info.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, idx, unit, unit_max in cost_info:\n            if (total_max_candidate - unit_max) >= load:\n                candidate_set.remove(idx)\n                total_max_candidate -= unit_max\n    else:\n        candidate_set = must_on_indices.copy()\n    \n    candidate_p_min = {}\n    candidate_p_max = {}\n    current_output_arr = [0.0] * n_units\n    \n    for idx in candidate_set:\n        u_arr[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            p_min_i = unit['p_min_i']\n            p_i0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_max_i = unit['p_max_i']\n            p_up_i = unit['p_up_i']\n            min_bound = max(p_min_i, p_i0 - p_down_i)\n            max_bound = min(p_max_i, p_i0 + p_up_i)\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        p_arr[idx] = min_bound\n        current_output_arr[idx] = min_bound\n        candidate_p_min[idx] = min_bound\n        candidate_p_max[idx] = max_bound\n    \n    total_min_bound = sum(candidate_p_min.get(i, 0) for i in range(n_units))\n    residual = load - total_min_bound\n    \n    if residual > 0:\n        heap = []\n        for idx in candidate_set:\n            current_output = current_output_arr[idx]\n            max_bound = candidate_p_max[idx]\n            if current_output < max_bound:\n                unit = units_info[idx]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                marginal_cost = 2 * c_i * current_output + b_i\n                heapq.heappush(heap, (marginal_cost, idx, current_output))\n        \n        while residual > 0 and heap:\n            mc, idx, current_out = heapq.heappop(heap)\n            if abs(current_output_arr[idx] - current_out) > 1e-5:\n                continue\n            if current_out >= candidate_p_max[idx]:\n                continue\n            headroom = candidate_p_max[idx] - current_out\n            if headroom <= 0:\n                continue\n            delta = min(residual, headroom)\n            new_output = current_out + delta\n            current_output_arr[idx] = new_output\n            p_arr[idx] = new_output\n            residual -= delta\n            unit = units_info[idx]\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            new_mc = 2 * c_i * new_output + b_i\n            if new_output < candidate_p_max[idx]:\n                heapq.heappush(heap, (new_mc, idx, new_output))\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051222438,
          "gap_price_rate": 0.008773668,
          "fitness": 0.0069479559
     },
     {
          "name": "refined_hybrid_commitment_v1",
          "algorithm": null,
          "code": "import heapq\nimport numpy as np\n\ndef refined_hybrid_commitment_v1(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n)\n    p = np.zeros(n)\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Calculate must-on bounds\n    total_must_on_min = 0\n    total_must_on_max = 0\n    must_on_min_bounds = {}\n    must_on_max_bounds = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min_bounds[i] = min_bound\n        must_on_max_bounds[i] = max_bound\n        total_must_on_min += min_bound\n        total_must_on_max += max_bound\n    \n    commit_set = []  # Final set of committed units\n    \n    # Case handling\n    if load <= total_must_on_min:  # Case a\n        commit_set = must_on\n        for i in must_on:\n            u[i] = 1\n            p[i] = must_on_min_bounds[i]\n    \n    elif load <= total_must_on_max:  # Case b\n        commit_set = must_on\n        for i in must_on:\n            u[i] = 1\n            p[i] = must_on_min_bounds[i]\n        residual = load - total_must_on_min\n        \n        # Initialize bounds and heap for dispatch\n        pq = []\n        current_output = {i: must_on_min_bounds[i] for i in must_on}\n        max_bounds = {i: must_on_max_bounds[i] for i in must_on}\n        for i in must_on:\n            unit = units_info[i]\n            marginal_cost = 2 * unit['c_i'] * current_output[i] + unit['b_i']\n            heapq.heappush(pq, (marginal_cost, i))\n        \n        # Distribute residual\n        while residual > 0 and pq:\n            mc, i = heapq.heappop(pq)\n            available = max_bounds[i] - current_output[i]\n            if available > 0:\n                increment = min(available, residual)\n                current_output[i] += increment\n                p[i] = current_output[i]\n                residual -= increment\n                new_mc = 2 * units_info[i]['c_i'] * current_output[i] + units_info[i]['b_i']\n                if current_output[i] < max_bounds[i]:\n                    heapq.heappush(pq, (new_mc, i))\n    \n    else:  # Case c: load > total_must_on_max\n        candidate_set = must_on + flexible_on\n        total_max = total_must_on_max\n        flex_on_max_bounds = {}\n        for i in flexible_on:\n            unit = units_info[i]\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            flex_on_max_bounds[i] = max_bound\n            total_max += max_bound\n        \n        # Start flexible-off units\n        flex_off_costs = []\n        for i in flexible_off:\n            unit = units_info[i]\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                          unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            flex_off_costs.append((cost_per_mw, i))\n        flex_off_costs.sort(key=lambda x: x[0])\n        \n        started_units = []\n        start_bounds = {}\n        for cost_per_mw, i in flex_off_costs:\n            if total_max >= load:\n                break\n            unit = units_info[i]\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            start_bounds[i] = max_bound\n            candidate_set.append(i)\n            started_units.append(i)\n            total_max += max_bound\n        \n        # Decommit non-must-on units\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        non_must_on_costs = []\n        for i in non_must_on:\n            unit = units_info[i]\n            if i in flexible_on:\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                              unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            else:  # Started unit\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                              unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            non_must_on_costs.append((cost_per_mw, i))\n        non_must_on_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        to_remove = []\n        current_max = total_max\n        for cost_per_mw, i in non_must_on_costs:\n            if i in flex_on_max_bounds:\n                max_bound_i = flex_on_max_bounds[i]\n            else:\n                max_bound_i = start_bounds[i]\n            if current_max - max_bound_i >= load:\n                to_remove.append(i)\n                current_max -= max_bound_i\n        \n        commit_set = [i for i in candidate_set if i not in to_remove]\n        \n        # Initialize committed units\n        init_p = {}\n        min_bounds = {}\n        max_bounds = {}\n        for i in commit_set:\n            u[i] = 1\n            unit = units_info[i]\n            if i in must_on:\n                min_bound = must_on_min_bounds[i]\n                max_bound = must_on_max_bounds[i]\n            elif i in flexible_on and i not in to_remove:\n                min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound = flex_on_max_bounds[i]\n            else:  # Started units not removed\n                min_bound = unit['p_min_i']\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            min_bounds[i] = min_bound\n            max_bounds[i] = max_bound\n            p[i] = min_bound\n            init_p[i] = min_bound\n        \n        residual = load - sum(init_p.values())\n        pq = []\n        current_output = init_p.copy()\n        for i in commit_set:\n            unit = units_info[i]\n            marginal_cost = 2 * unit['c_i'] * current_output[i] + unit['b_i']\n            heapq.heappush(pq, (marginal_cost, i))\n        \n        # Distribute residual\n        while residual > 0 and pq:\n            mc, i = heapq.heappop(pq)\n            available = max_bounds[i] - current_output[i]\n            if available > 0:\n                increment = min(available, residual)\n                current_output[i] += increment\n                p[i] = current_output[i]\n                residual -= increment\n                new_mc = 2 * units_info[i]['c_i'] * current_output[i] + units_info[i]['b_i']\n                if current_output[i] < max_bounds[i]:\n                    heapq.heappush(pq, (new_mc, i))\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0087378663,
          "fitness": 0.0069543885
     },
     {
          "name": "optimized_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into:  \n   - must-on (online units that violate min-up time or shutdown constraints)  \n   - must-off (offline units violating min-down time)  \n   - flexible-on (eligible online units)  \n   - flexible-off (eligible offline units)  \n2. Calculate must-on generation bounds with ramp constraints:  \n   - min_bound = max(p_min_i, p_i_0 - p_down_i) for online units  \n   - max_bound = min(p_max_i, p_i_0 + p_up_i) for online units  \n3. Handle load cases:  \n   a) Load \u2264 total must-on min:  \n      - Commit only must-on units (overproduction unavoidable)  \n   b) total must-on min < load \u2264 total must-on max:  \n      - Commit only must-on units  \n   c) Load > total must-on max:  \n      - Form candidate set (must-on + flexible-on)  \n      - Start flexible-off units by ascending (s_i + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i  \n      - Add started units to candidate set  \n      - Decommit non-must-on units in descending (a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i order, ensuring feasibility  \n4. For committed units:  \n   a) Compute power bounds accounting for startup constraints:  \n      - Online: [min_bound, max_bound]  \n      - Startup: [p_min_i, min(p_max_i, p_start_i)]  \n   b) Initialize outputs at lower bounds  \n   c) Distribute residual load:  \n      - Create priority queue ordered by marginal cost (2\u00b7c_i\u00b7p_i + b_i)  \n      - Allocate power iteratively to the unit with min marginal cost  \n5. Set uncommitted units to off-state (u_i=0, p_i=0)  \n\n",
          "code": "import numpy as np\n\ndef optimized_hybrid_rolling_commitment(units_info, load):\n    # Initialize containers for unit classifications\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units based on operational constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Currently online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Currently offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Calculate must-on generation bounds\n    total_must_on_min = 0\n    total_must_on_max = 0\n    for i in must_on:\n        unit = units_info[i]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_on_min += min_bound\n        total_must_on_max += max_bound\n    \n    # Initialize commitment set and power outputs\n    commit_set = []\n    p_outputs = np.zeros(len(units_info))\n    \n    # Case a: Load \u2264 total must-on min\n    if load <= total_must_on_min:\n        commit_set = must_on.copy()\n        for i in must_on:\n            unit = units_info[i]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_outputs[i] = min_bound\n    \n    # Case b: Load within must-on range\n    elif total_must_on_min < load <= total_must_on_max:\n        commit_set = must_on.copy()\n        residual = load - total_must_on_min\n        \n        # Initialize must-on units at min bounds\n        min_bounds = {}\n        max_bounds = {}\n        for i in must_on:\n            unit = units_info[i]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_outputs[i] = min_bound\n            min_bounds[i] = min_bound\n            max_bounds[i] = max_bound\n        \n        # Distribute residual using priority queue\n        while residual > 1e-6:\n            min_mc = float('inf')\n            best_unit = None\n            for i in commit_set:\n                current_p = p_outputs[i]\n                if current_p < max_bounds[i]:\n                    mc = 2 * units_info[i]['c_i'] * current_p + units_info[i]['b_i']\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            max_increase = min(max_bounds[best_unit] - p_outputs[best_unit], residual)\n            p_outputs[best_unit] += max_increase\n            residual -= max_increase\n    \n    # Case c: Load > total must-on max\n    else:\n        candidate_set = must_on + flexible_on\n        \n        # Start flexible-off units by cost-per-MW priority\n        startup_costs = []\n        for i in flexible_off:\n            unit = units_info[i]\n            min_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)\n            cost_per_mw = min_cost / unit['p_min_i']\n            startup_costs.append((i, cost_per_mw))\n        \n        startup_costs.sort(key=lambda x: x[1])\n        \n        # Start units until candidate capacity meets load\n        candidate_min = total_must_on_min\n        candidate_max = total_must_on_max\n        for i in flexible_on:\n            unit = units_info[i]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            candidate_min += min_bound\n            candidate_max += max_bound\n        \n        started_units = []\n        for i, cost in startup_costs:\n            unit = units_info[i]\n            candidate_min += unit['p_min_i']\n            candidate_max += min(unit['p_max_i'], unit['p_start_i'])\n            candidate_set.append(i)\n            started_units.append(i)\n            if candidate_max >= load:\n                break\n        \n        # Decommit expensive non-must-on units\n        operating_costs = []\n        for i in candidate_set:\n            if i not in must_on:  # Only consider non-must-on units\n                unit = units_info[i]\n                min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)\n                cost_per_mw = min_cost / unit['p_min_i']\n                operating_costs.append((i, cost_per_mw))\n        \n        operating_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, cost in operating_costs:\n            unit = units_info[i]\n            # Calculate removed capacity (use max power for feasibility check)\n            removed_min = unit['p_min_i'] if i in started_units else max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            removed_max = min(unit['p_max_i'], unit['p_start_i']) if i in started_units else min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            # Check if removal maintains feasibility\n            if candidate_max - removed_max >= load:\n                candidate_min -= removed_min\n                candidate_max -= removed_max\n                candidate_set.remove(i)\n                started_units = [u for u in started_units if u != i]\n        \n        commit_set = candidate_set\n        \n        # Initialize committed units at min bounds\n        min_bounds = {}\n        max_bounds = {}\n        for i in commit_set:\n            unit = units_info[i]\n            if i in must_on or i in flexible_on:  # Already online\n                min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Started units\n                min_bound = unit['p_min_i']\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            \n            p_outputs[i] = min_bound\n            min_bounds[i] = min_bound\n            max_bounds[i] = max_bound\n        \n        # Calculate residual load and distribute\n        residual = load - sum(min_bounds.values())\n        while residual > 1e-6:\n            min_mc = float('inf')\n            best_unit = None\n            for i in commit_set:\n                current_p = p_outputs[i]\n                if current_p < max_bounds[i]:\n                    mc = 2 * units_info[i]['c_i'] * current_p + units_info[i]['b_i']\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_unit = i\n            \n            if best_unit is None:\n                break\n                \n            max_increase = min(max_bounds[best_unit] - p_outputs[best_unit], residual)\n            p_outputs[best_unit] += max_increase\n            residual -= max_increase\n    \n    # Set uncommitted units to off-state\n    u_states = np.zeros(len(units_info))\n    for i in commit_set:\n        u_states[i] = 1\n    \n    # Create schedule output\n    schedule = np.vstack((u_states, p_outputs))\n    return schedule",
          "from": "crossover",
          "gap_power_rate": 0.0055938664,
          "gap_price_rate": 0.008436602,
          "fitness": 0.0070152342
     }
]