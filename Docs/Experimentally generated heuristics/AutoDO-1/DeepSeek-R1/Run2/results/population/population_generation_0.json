[
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and flexible (both online/offline)\n2. For must-on units, compute min/max output bounds based on current state and ramp constraints\n3. Handle three cases:\n   - Case 1 (load between must-on min/max): Keep only must-on units, turn off flexible units\n   - Case 2 (load > must-on max): Keep online flexible units, start additional offline units based on cost-effectiveness until load can be met\n   - Case 3 (load < must-on min): Must-on units at minimum, turn off all flexible units\n4. Economic dispatch for all online units:\n   a. Start at min output bounds\n   b. Sort units by increasing marginal cost\n   c. Increase output of cheapest units until load met or capacity exhausted\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    \n    # Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flex_online_indices = []\n    flex_offline_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flex_online_indices.append(i)\n        else:\n            t_off_abs = abs(unit['t_i_0'])\n            if t_off_abs < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flex_offline_indices.append(i)\n    \n    # Set must-off units to off\n    for i in must_off_indices:\n        u[i] = 0\n        p[i] = 0\n    \n    # Compute bounds for must-on units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_on_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        total_min_must += min_bound\n        total_max_must += max_bound\n        u[i] = 1\n    \n    # Initialize online set with must-on units\n    online_set = set(must_on_indices)\n    \n    if total_min_must <= load <= total_max_must:\n        # Case 1: Only must-on units needed\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    elif load > total_max_must:\n        # Case 2: Need additional units\n        current_capacity = total_max_must\n        deficit = load - total_max_must\n        \n        # Keep flexible online units\n        for i in flex_online_indices:\n            u[i] = 1\n            min_b = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_b = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            min_bounds[i] = min_b\n            max_bounds[i] = max_b\n            current_capacity += max_b\n            online_set.add(i)\n        \n        # Calculate remaining deficit\n        deficit = max(0, load - current_capacity)\n        started_units = []\n        \n        if deficit > 0:\n            # Sort offline flex by cost per MW at min output\n            cost_per_mw = []\n            for i in flex_offline_indices:\n                unit = units_info[i]\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n                cost_per_mw.append(cost / unit['p_min_i'])\n            sorted_indices = [i for _, i in sorted(zip(cost_per_mw, flex_offline_indices))]\n            \n            # Start most economical units first\n            for i in sorted_indices:\n                if deficit <= 0:\n                    break\n                u[i] = 1\n                min_bounds[i] = units_info[i]['p_min_i']\n                max_b = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                max_bounds[i] = max_b\n                online_set.add(i)\n                started_units.append(i)\n                current_capacity += max_b\n                deficit = load - current_capacity\n    \n    else:\n        # Case 3: Load < must-on minimum\n        for i in must_on_indices:\n            p[i] = min_bounds[i]\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    # Economic dispatch for online units\n    online_indices = sorted(online_set)\n    params = [(units_info[i]['b_i'], units_info[i]['c_i'], min_bounds[i], max_bounds[i]) for i in online_indices]\n    b, c, mins, maxs = zip(*params)\n    b = np.array(b)\n    c = np.array(c)\n    mins = np.array(mins)\n    maxs = np.array(maxs)\n    \n    # Start from min outputs\n    p_online = np.array(mins)\n    total_output = np.sum(p_online)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        # Sort by increasing marginal cost\n        marginal_costs = 2 * c * p_online + b\n        order = np.argsort(marginal_costs)\n        headroom = maxs - mins\n        \n        # Allocate deficit\n        for i in order:\n            alloc = min(deficit, headroom[i])\n            p_online[i] += alloc\n            deficit -= alloc\n            if deficit <= 0:\n                break\n    \n    # Update outputs\n    for idx, val in enumerate(online_indices):\n        p[val] = p_online[idx]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0100041649,
          "fitness": 0.0074306418
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and free units based on minimum up/down times and shutdown constraints:\n   - Must-on: units that were on (u_i_0=1) and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or previous output exceeds shutdown capacity (p_i_0 > p_shut_i)\n   - Must-off: units that were off (u_i_0=0) and haven't satisfied minimum down-time (-t_i_0 < t_off_min_i)\n   - Free units: remaining units that can be committed or decommitted\n\n2. Set must-off units to off (u_i=0, p_i=0) and must-on units to on (u_i=1)\n\n3. Calculate total minimum and maximum possible output from must-on units considering ramp constraints\n\n4. For underproduction (load > must-on max output):\n   - Sort free units by average production cost at minimum output\n   - Turn on free units in increasing cost order until cumulative max output >= load\n\n5. For overproduction (load < must-on min output), keep free units off\n\n6. Dispatch power:\n   - For each committed unit, compute power bounds based on current state and history\n   - Initialize power outputs to minimum bounds\n   - Incrementally increase output on units with cheapest marginal cost (b_i + 2*c_i*p_i) until meeting load or hitting constraints\n\n7. Return 2D array with commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Make a copy to avoid modifying original data\n    units = [unit.copy() for unit in units_info]\n    \n    # Classify units\n    must_on_units = []\n    must_off_units = []\n    free_units = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # u_i_0 == 0\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Set must-off units\n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Set must-on units and compute bounds\n    min_must = 0\n    max_must = 0\n    for unit in must_on_units:\n        unit['u_i'] = 1\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_must += low\n        max_must += high\n    \n    # Initialize free units to off\n    for unit in free_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Turn on additional free units for underproduction\n    candidate_set = []\n    if load > max_must:\n        # Sort by average cost at minimum power\n        free_units_sorted = sorted(free_units, key=lambda u: (u['s_i'] + u['a_i'] + \n                                  u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'])\n        \n        current_min = min_must\n        current_max = max_must\n        for unit in free_units_sorted:\n            if current_max >= load:\n                break\n            candidate_set.append(unit)\n            unit['u_i'] = 1\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n            current_min += unit['p_min_i']\n            current_max += high_i\n    elif load < min_must:\n        # Overproduction case\n        candidate_set = []\n    \n    # Collect all committed units\n    committed_units = must_on_units + candidate_set\n    for unit in must_off_units + free_units:\n        if unit not in committed_units:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Power dispatch: Compute bounds for each committed unit\n    bounds = []\n    for unit in committed_units:\n        if unit in must_on_units:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_i = unit['p_min_i']\n                high_i = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((low_i, high_i))\n    \n    # Initialize to min outputs\n    total_output = 0\n    for idx, unit in enumerate(committed_units):\n        low_i, high_i = bounds[idx]\n        unit['p_i'] = low_i\n        total_output += low_i\n    \n    # Incremental power allocation\n    remaining = load - total_output\n    if remaining > 0:\n        avail_units = []\n        for idx, unit in enumerate(committed_units):\n            low_i, high_i = bounds[idx]\n            if unit['p_i'] < high_i:\n                # Store (marginal_cost, index, unit_ref)\n                marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units.append((marg_cost, idx, unit))\n        \n        while remaining > 0 and avail_units:\n            avail_units.sort(key=lambda x: x[0])\n            cost, idx, unit = avail_units[0]\n            low_i, high_i = bounds[idx]\n            amount = min(remaining, high_i - unit['p_i'])\n            unit['p_i'] += amount\n            remaining -= amount\n            \n            # Update availability\n            if unit['p_i'] >= high_i:\n                avail_units.pop(0)\n            else:\n                # Update marginal cost for this unit\n                new_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units[0] = (new_cost, idx, unit)\n    \n    # Format results in original unit order\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "commit_units_by_advanced_heuristic",
          "algorithm": "1. Identify units that must remain on (forced_on) due to min up-time or shutdown capacity constraints.\n2. Identify units that must remain off (forced_off) due to min down-time constraints.\n3. Identify flexible units that can be committed or decommitted (flexible_on and flexible_off).\n4. Ensure flexible_on units that cannot ramp to zero output without violating ramp constraints are included in the commitment.\n5. Form initial committed_set from forced_on and must_include_flex_on.\n6. Add candidate units from flexible and off units to committed_set in increasing average cost order until total max capacity >= load.\n7. Perform economic dispatch for committed_set:\n   - Set initial output to minimum feasible\n   - Allocate remaining load based on increasing marginal cost and headroom\n8. Set uncommitted units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_advanced_heuristic(units_info, load):\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    flexible_on = []\n    flexible_off = []\n    must_include_flex_on = []\n\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        p_down_i = unit['p_down_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on.append(i)\n            else:\n                if p_i_0 > p_down_i:\n                    must_include_flex_on.append(i)\n                else:\n                    flexible_on.append(i)\n        else:\n            if -t_i_0 < t_off_min_i:\n                forced_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    committed_set = forced_on + must_include_flex_on\n    candidate_units = flexible_on + flexible_off\n    total_min, total_max = 0.0, 0.0\n    min_output_vals = []\n    max_output_vals = []\n    \n    for i in committed_set:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        if u_i_0 == 1:\n            min_output = max(p_min_i, p_i_0 - p_down_i)\n            max_output = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_output = p_min_i\n            max_output = min(p_max_i, unit['p_start_i'])\n        \n        min_output_vals.append(min_output)\n        max_output_vals.append(max_output)\n        total_min += min_output\n        total_max += max_output\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        p_min_i = unit['p_min_i']\n        s_i = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        cost = s_i + a + b * p_min_i + c * p_min_i**2\n        cost_per_mw = cost / p_min_i if p_min_i > 0 else float('inf')\n        candidate_list.append((i, cost_per_mw))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    sorted_candidates = [idx for idx, _ in candidate_list]\n    candidate_minmax = []\n    \n    for i in candidate_units:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        if u_i_0 == 1:\n            min_out = max(p_min_i, p_i_0 - p_down_i)\n            max_out = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            min_out = p_min_i\n            max_out = min(p_max_i, unit['p_start_i'])\n        candidate_minmax.append((min_out, max_out))\n    \n    idx = 0\n    while load > total_max and idx < len(sorted_candidates):\n        i = sorted_candidates[idx]\n        min_out, max_out = candidate_minmax[candidate_units.index(i)]\n        committed_set.append(i)\n        min_output_vals.append(min_out)\n        max_output_vals.append(max_out)\n        total_min += min_out\n        total_max += max_out\n        idx += 1\n    \n    schedule_u = np.zeros(n_units)\n    schedule_p = np.zeros(n_units)\n    p_alloc = min_output_vals.copy()\n    remaining = load - sum(p_alloc)\n    if remaining > 0:\n        headroom = [max_val - min_val for min_val, max_val in zip(min_output_vals, max_output_vals)]\n        active_idxs = [j for j in range(len(committed_set)) if headroom[j] > 1e-6]\n        while remaining > 1e-6 and active_idxs:\n            min_marginal = float('inf')\n            best_idx = -1\n            best_inc = 0\n            for j in active_idxs:\n                unit_idx = committed_set[j]\n                unit = units_info[unit_idx]\n                c_val = unit['c_i']\n                b_val = unit['b_i']\n                marginal = 2 * c_val * p_alloc[j] + b_val\n                if marginal < min_marginal:\n                    min_marginal = marginal\n                    best_idx = j\n            if best_idx == -1:\n                break\n            inc = min(remaining, headroom[best_idx])\n            p_alloc[best_idx] += inc\n            headroom[best_idx] -= inc\n            remaining -= inc\n            if headroom[best_idx] <= 1e-6:\n                active_idxs.remove(best_idx)\n    \n    for j, unit_idx in enumerate(committed_set):\n        schedule_u[unit_idx] = 1\n        schedule_p[unit_idx] = p_alloc[j]\n    \n    return np.array([schedule_u, schedule_p])",
          "from": null,
          "gap_power_rate": 0.0005091712,
          "gap_price_rate": 0.0232513196,
          "fitness": 0.0118802454
     },
     {
          "name": "commit_units_by_adaptive_priority",
          "algorithm": "1. Identify must-run units that cannot be shut down (due to minimum up-time or previous output exceeding shutdown ramp limit) and must-remain-off units (insufficient minimum down-time).\n2. Compute min/max output bounds for must-run units based on current state and constraints.\n3. Form priority list of available non-committed units sorted by cost-per-MW at minimum output, considering startup costs for offline units.\n4. Commit additional units from priority list if must-run capacity is insufficient to meet demand.\n5. Perform economic dispatch for committed units using greedy lambda iteration to distribute residual load, respecting individual output constraints.\n6. Set outputs for non-committed units to zero.\n",
          "code": "import numpy as np\n\ndef commit_units_by_adaptive_priority(units_info, load):\n    n = len(units_info)\n    u = [0] * n\n    p = [0] * n\n    must_run = [False] * n\n    must_remain_off = [False] * n\n    \n    # Step 1: Identify must-run and must-remain-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            must_run[i] = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n        else:\n            must_remain_off[i] = abs(unit['t_i_0']) < unit['t_off_min_i']\n    \n    # Precompute bounds and costs for all units\n    bounds = []\n    for i, unit in enumerate(units_info):\n        if must_run[i]:\n            if unit['u_i_0'] == 1:  # Was on\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Must start\n                low_bound = unit['p_min_i']\n                up_bound = min(unit['p_max_i'], unit['p_start_i'])\n            bounds.append((low_bound, up_bound))\n        else:\n            bounds.append((0, 0))\n    \n    # Must-run commitment and bounds\n    must_run_indices = [i for i in range(n) if must_run[i]]\n    if must_run_indices:\n        total_low = sum(bounds[i][0] for i in must_run_indices)\n        total_high = sum(bounds[i][1] for i in must_run_indices)\n    else:\n        total_low = total_high = 0\n    \n    # Form available units list (non must-run, not forced off)\n    available_units = []\n    for i, unit in enumerate(units_info):\n        if must_run[i] or must_remain_off[i]:\n            continue\n        if unit['u_i_0'] == 1:  # Online (Set B)\n            cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            up_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Offline (Set C)\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)\n            low_bound = unit['p_min_i']\n            up_bound = min(unit['p_max_i'], unit['p_start_i'])\n        available_units.append((i, cost, low_bound, up_bound))\n    \n    # Sort by cost-per-MW at minimum output\n    available_units.sort(key=lambda x: x[1])\n    additional_indices = []\n    if total_high < load:\n        T_max = total_high\n        for idx, (i, cost, low_bound, up_bound) in enumerate(available_units):\n            if T_max >= load:\n                break\n            T_max += up_bound\n            additional_indices.append(i)\n            bounds[i] = (low_bound, up_bound)  # Update bounds\n    \n    committed_indices = must_run_indices + additional_indices\n    \n    # Dispatch power to committed units\n    if committed_indices:\n        dispatch_p = [bounds[i][0] for i in committed_indices]\n        residuals = [bounds[i][1] - bounds[i][0] for i in committed_indices]\n        total = sum(dispatch_p)\n        remaining = load - total\n        \n        # Function to compute marginal cost for a unit at current output\n        def marginal_cost(i, current_p):\n            return 2 * units_info[i]['c_i'] * current_p + units_info[i]['b_i']\n        \n        while abs(remaining) > 1e-5:\n            candidates = []\n            for j, i in enumerate(committed_indices):\n                if residuals[j] > 1e-5 and remaining > 0:  # Increase generation\n                    candidates.append((j, marginal_cost(i, dispatch_p[j])))\n                elif dispatch_p[j] > bounds[i][0] + 1e-5 and remaining < 0:  # Decrease generation\n                    candidates.append((j, -marginal_cost(i, dispatch_p[j])))  # Negative for sorting\n            \n            if not candidates:\n                break\n                \n            # Select candidate with most negative/positive marginal cost\n            candidates.sort(key=lambda x: x[1])\n            idx_in_committed = candidates[0][0] if remaining > 0 else candidates[-1][0]\n            unit_idx = committed_indices[idx_in_committed]\n            \n            # Calculate step size\n            if remaining > 0:\n                step = min(remaining, residuals[idx_in_committed])\n                dispatch_p[idx_in_committed] += step\n                residuals[idx_in_committed] -= step\n            else:\n                step = min(-remaining, dispatch_p[idx_in_committed] - bounds[unit_idx][0])\n                dispatch_p[idx_in_committed] -= step\n                residuals[idx_in_committed] += step  # Not used for decreasing but update for clarity\n            \n            remaining -= step if remaining > 0 else -step\n        \n        # Assign dispatch values\n        for j, i in enumerate(committed_indices):\n            p[i] = dispatch_p[j]\n            u[i] = 1\n    \n    # Set states and outputs\n    for i in range(n):\n        if i not in committed_indices:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0059313678,
          "gap_price_rate": 0.0179953764,
          "fitness": 0.0119633721
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run units that cannot be turned off due to minimum up-time or shutdown ramp constraints\n2. Identify must-off units that cannot be turned on due to minimum down-time constraints\n3. For must-run units, calculate minimum and maximum output considering ramp constraints\n4. For non-must-run, non-must-off candidate units:\n   - Calculate min/max output and priority cost (including startup for cold units)\n   - Separate into already-on and off units\n5. Adjust commitments:\n   - Turn off expensive already-on units if possible without causing undercapacity\n   - Turn on prioritized off-candidates if needed to meet load\n6. Dispatch power to committed units:\n   - Initialize to minimum possible output considering ramp constraints\n   - Increase output of units with lowest marginal cost to meet load\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    must_run = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        # Identify must-run units\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        # Identify must-off units\n        if unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n\n    # Calculate must-run power limits\n    must_run_total_min = 0\n    must_run_total_max = 0\n    for i in must_run:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        must_run_total_min += min_output\n        must_run_total_max += max_output\n\n    # Prepare candidate units\n    on_candidates = []\n    off_candidates = []\n    for i in range(n_units):\n        if i in must_run or i in must_off:\n            continue\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2\n            priority = cost / min_output\n            on_candidates.append((priority, i, min_output, max_output))\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n            cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2\n            priority = cost / min_output\n            off_candidates.append((priority, i, min_output, max_output))\n    \n    # Sort candidates\n    on_candidates.sort(key=lambda x: -x[0])\n    off_candidates.sort(key=lambda x: x[0])\n    \n    # Adjust commitments\n    on_list = list(must_run)\n    total_min = must_run_total_min\n    total_max = must_run_total_max\n    for priority, i, min_out, max_out in on_candidates:\n        on_list.append(i)\n        total_min += min_out\n        total_max += max_out\n    \n    # Turn off expensive units if possible\n    turn_off = []\n    for priority, i, min_out, max_out in on_candidates:\n        if total_min > load and (total_max - max_out) >= load:\n            on_list.remove(i)\n            total_min -= min_out\n            total_max -= max_out\n            turn_off.append(i)\n    \n    # Turn on prioritized off-candidates if needed\n    for priority, i, min_out, max_out in off_candidates:\n        if total_max < load:\n            on_list.append(i)\n            total_min += min_out\n            total_max += max_out\n    \n    # Initialize output for all units\n    current_p = np.zeros(n_units)\n    room = np.zeros(n_units)\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if i in on_list:\n            schedules[0, i] = 1\n            if unit['u_i_0'] == 1:\n                current_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                current_p[i] = unit['p_min_i']\n            \n            # Calculate ramp room\n            if unit['u_i_0'] == 1:\n                room[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p[i]\n            else:\n                room[i] = min(unit['p_max_i'], unit['p_start_i']) - current_p[i]\n        else:\n            schedules[0, i] = 0\n            current_p[i] = 0\n    \n    # Economic dispatch\n    total_power = np.sum(current_p)\n    deficit = load - total_power\n\n    while deficit > 1e-5:\n        best_marginal = float('inf')\n        best_idx = None\n        \n        # Find unit with lowest marginal cost and available room\n        for i in on_list:\n            if room[i] > 1e-5:\n                marginal = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p[i]\n                if marginal < best_marginal:\n                    best_marginal = marginal\n                    best_idx = i\n        \n        if best_idx is None:\n            break\n        \n        # Increase power\n        increase = min(deficit, room[best_idx])\n        current_p[best_idx] += increase\n        room[best_idx] -= increase\n        total_power += increase\n        deficit -= increase\n\n    # Set schedule outputs\n    schedules[1, :] = current_p\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. **Identify forced units**: Determine units forced to remain on (insufficient min up-time or previous output > shutdown capacity) or off (insufficient min down-time).  \n2. **Initial commitment**: Inherit commitment states from previous period for non-forced units.  \n3. **Adjust commitment for load**:  \n   a. Start units (from available offline units) prioritized by lowest average cost at min power if current max capacity < load.  \n   b. Stop non-forced online units prioritized by highest average cost at min power if current min capacity > load, ensuring max capacity remains >= load.  \n4. **Economic dispatch**:  \n   a. Set committed units to min possible output based on online status (considering ramp constraints).  \n   b. Distribute remaining load by increasing output of units with lowest marginal cost within their bounds.  \n5. **Set non-committed units to zero**.  \n6. Return schedule: commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    # Initialize forced units lists\n    forced_on_units = []\n    forced_off_units = []\n    \n    # Determine forced units and set initial commitment\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                unit['u_i'] = 1\n                forced_on_units.append(unit)\n            else:\n                unit['u_i'] = unit['u_i_0']\n        else:\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                unit['u_i'] = 0\n                forced_off_units.append(unit)\n            else:\n                unit['u_i'] = unit['u_i_0']\n    \n    # Build committed_units and available_to_start\n    committed_units = [unit for unit in units_info if unit['u_i'] == 1]\n    available_to_start = []\n    for unit in units_info:\n        if unit not in forced_on_units and unit not in forced_off_units and unit['u_i_0'] == 0:\n            available_to_start.append(unit)\n    \n    # Compute current min and max outputs\n    min_output = sum(unit['p_min_i'] for unit in committed_units)\n    max_output = sum(unit['p_max_i'] for unit in committed_units)\n    \n    # Step 3: Start units if max capacity < load\n    if max_output < load:\n        # Sort available_to_start by avg cost at min power\n        available_to_start.sort(key=lambda unit: (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i'])\n        for unit in available_to_start:\n            if max_output >= load:\n                break\n            unit['u_i'] = 1\n            committed_units.append(unit)\n            min_output += unit['p_min_i']\n            max_output += unit['p_max_i']\n    \n    # Step 4: Stop expensive units if min capacity > load\n    available_to_stop = [unit for unit in committed_units if unit not in forced_on_units]\n    if min_output > load:\n        # Sort available_to_stop by avg cost at min power (descending)\n        available_to_stop.sort(key=lambda unit: (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i'], reverse=True)\n        for unit in available_to_stop:\n            if min_output <= load:\n                break\n            new_max = max_output - unit['p_max_i']\n            if new_max >= load:\n                unit['u_i'] = 0\n                committed_units.remove(unit)\n                min_output -= unit['p_min_i']\n                max_output = new_max\n    \n    # Step 5: Dispatch for committed units\n    # Set bounds for each committed unit\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:\n            unit['lower_bound'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['upper_bound'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['lower_bound'] = unit['p_min_i']\n            unit['upper_bound'] = min(unit['p_max_i'], unit['p_start_i'])\n        unit['p_i'] = unit['lower_bound']\n    \n    # Distribute remaining load\n    total_output = sum(unit['p_i'] for unit in committed_units)\n    remaining = load - total_output\n    \n    # Allocate remaining load by increasing most economical units\n    while remaining > 1e-5:  # Tolerance\n        candidate = None\n        min_mc = float('inf')\n        # Find unit with smallest marginal cost that can increase\n        for unit in committed_units:\n            if unit['p_i'] < unit['upper_bound']:\n                marginal_cost = 2 * unit['c_i'] * unit['p_i'] + unit['b_i']\n                if marginal_cost < min_mc:\n                    min_mc = marginal_cost\n                    candidate = unit\n        if candidate is None:  # No unit can increase further\n            break\n        # Increase candidate output\n        increase = min(remaining, candidate['upper_bound'] - candidate['p_i'])\n        candidate['p_i'] += increase\n        remaining -= increase\n    \n    # Set non-committed units to zero\n    for unit in units_info:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0\n    \n    # Build and return schedule\n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0231401898,
          "gap_price_rate": 0.0138037235,
          "fitness": 0.0184719567
     },
     {
          "name": "commit_units_by_priority_and_dispatch",
          "algorithm": "1. Classify units into must_online, must_offline, free_online, free_offline based on min up/downtime and shutdown constraints.\n2. Set must_online units as committed and calculate their power bounds using ramp limits.\n3. Initially commit free_online units and leave free_offline units offline.\n4. If load exceeds maximum possible output, start free_offline units in ascending order of a priority index (startup cost per MW + marginal cost at minimum power).\n5. If load is below minimum possible output, decommit free_online units in descending order of a priority index (marginal cost + min power output) to reduce total minimum capacity.\n6. Perform economic dispatch for committed units using lambda iteration method:\n   a. Use binary search for system lambda that satisfies total generation = load.\n   b. Calculate unit outputs using lambda-based formula, clamped to individual power bounds.\n7. Return schedules: first row is commitment states, second row is dispatched powers.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_and_dispatch(units_info, load):\n    n_units = len(units_info)\n    must_online = []\n    must_offline = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_online.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_offline.append(i)\n            else:\n                free_offline.append(i)\n    \n    u = [0] * n_units\n    p_dispatch = [0] * n_units\n    p_min = [0] * n_units\n    p_max = [0] * n_units\n    committed_units = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Handle must_online units\n    for i in must_online:\n        unit = units_info[i]\n        u[i] = 1\n        p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += p_min[i]\n        total_max += p_max[i]\n        committed_units.append(i)\n    \n    # Set free_online units initially to online\n    for i in free_online:\n        unit = units_info[i]\n        u[i] = 1\n        p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += p_min[i]\n        total_max += p_max[i]\n        committed_units.append(i)\n    \n    # Set must_offline and free_offline units offline\n    for i in must_offline + free_offline:\n        u[i] = 0\n        p_min[i] = 0\n        p_max[i] = 0\n    \n    # Start additional units if needed\n    if load > total_max:\n        def priority_offline(i):\n            unit = units_info[i]\n            return (unit['s_i'] / unit['p_min_i']) + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n        \n        sorted_offline = sorted(free_offline, key=lambda i: priority_offline(i))\n        for i in sorted_offline:\n            unit = units_info[i]\n            if load <= total_max:\n                break\n            u[i] = 1\n            p_min[i] = unit['p_min_i']\n            p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += p_min[i]\n            total_max += p_max[i]\n            committed_units.append(i)\n    \n    # Shutdown free_online units if possible\n    if total_min > load:\n        def priority_online(i):\n            unit = units_info[i]\n            return (unit['b_i'] + 2 * unit['c_i'] * p_min[i]), p_min[i]\n        \n        sorted_online = sorted(free_online, key=lambda i: priority_online(i), reverse=True)\n        for i in sorted_online:\n            if total_min <= load:\n                break\n            u[i] = 0\n            total_min -= p_min[i]\n            total_max -= p_max[i]\n            p_min[i] = 0\n            p_max[i] = 0\n            committed_units.remove(i)\n    \n    # Calculate power bounds for dispatch\n    for i in committed_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            p_min[i] = unit['p_min_i']\n            p_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            p_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min_bound = sum(p_min[i] for i in committed_units)\n    total_max_bound = sum(p_max[i] for i in committed_units)\n    \n    # Economic dispatch\n    if not committed_units:\n        return np.array([u, p_dispatch])\n    \n    if load <= total_min_bound:\n        for i in committed_units:\n            p_dispatch[i] = p_min[i]\n    elif load >= total_max_bound:\n        for i in committed_units:\n            p_dispatch[i] = p_max[i]\n    else:\n        \u03bb_low = 0\n        \u03bb_high = 0\n        for i in committed_units:\n            marginal_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_min[i]\n            marginal_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_max[i]\n            \u03bb_low = min(\u03bb_low, marginal_min)\n            \u03bb_high = max(\u03bb_high, marginal_max)\n        \n        \u03bb_low = \u03bb_low - 1.0\n        \u03bb_high = \u03bb_high + 1.0\n        \n        tol = 0.001\n        iter_count = 0\n        max_iter = 1000\n        \n        while iter_count < max_iter:\n            \u03bb_mid = (\u03bb_low + \u03bb_high) / 2.0\n            total_p = 0.0\n            for i in committed_units:\n                unit = units_info[i]\n                p = (\u03bb_mid - unit['b_i']) / (2 * unit['c_i'])\n                p = max(p_min[i], min(p, p_max[i]))\n                total_p += p\n            \n            if abs(total_p - load) < tol:\n                for i in committed_units:\n                    unit = units_info[i]\n                    p_val = (\u03bb_mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_dispatch[i] = max(p_min[i], min(p_val, p_max[i]))\n                break\n            elif total_p < load:\n                \u03bb_low = \u03bb_mid\n            else:\n                \u03bb_high = \u03bb_mid\n            \n            iter_count += 1\n        else:\n            for i in committed_units:\n                p_dispatch[i] = p_min[i]\n    \n    return np.array([u, p_dispatch])",
          "from": null,
          "gap_power_rate": 7.18145e-05,
          "gap_price_rate": 0.0420039839,
          "fitness": 0.0210378992
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Identify must-on units (online units that haven't satisfied minimum up-time)\n2. Identify must-off units (offline units that haven't satisfied minimum down-time)\n3. Classify remaining units into:\n   - Forced online: Online units that cannot shut down (constraints not met)\n   - Optional offline: Online units that can shut down (constraints met)\n   - Optional online: Offline units that can start up\n4. Start with base_online set (must-on + forced online units)\n5. Start cheapest optional online units until max capacity meets load or min base <= load constraint\n6. Attempt to turn off expensive optional offline units if capacity allows\n7. Dispatch load to committed units:\n   - Set units to min output respecting ramp-down constraints\n   - Increase output on cheapest units until load met (economic dispatch)\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    n = len(units_info)\n    u_list = [0] * n\n    p_list = [0] * n\n    \n    must_on = []\n    must_off = []\n    forced_online = []\n    optional_offline = []\n    optional_online = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and unit['t_i_0'] < unit['t_on_min_i']:\n            must_on.append(i)\n        elif unit['u_i_0'] == 0 and unit['t_i_0'] > -unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            if unit['u_i_0'] == 1:\n                if unit['p_i_0'] <= min(unit['p_down_i'], unit['p_shut_i']):\n                    optional_offline.append(i)\n                else:\n                    forced_online.append(i)\n            else:\n                optional_online.append(i)\n    \n    base_online = must_on + forced_online\n    min_base = sum(units_info[i]['p_min_i'] for i in base_online)\n    max_base = sum(units_info[i]['p_max_i'] for i in base_online)\n    \n    if max_base < load:\n        avg_cost = []\n        for i in optional_online:\n            unit = units_info[i]\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            avg_cost.append((i, cost))\n        \n        avg_cost.sort(key=lambda x: x[1])\n        \n        for i, _ in avg_cost:\n            unit = units_info[i]\n            new_min_base = min_base + unit['p_min_i']\n            if new_min_base <= load:\n                base_online.append(i)\n                min_base += unit['p_min_i']\n                max_base += unit['p_max_i']\n                optional_online.remove(i)\n                if max_base >= load:\n                    break\n    \n    if min_base > load:\n        avg_cost = []\n        for i in optional_offline:\n            unit = units_info[i]\n            cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            avg_cost.append((i, cost))\n        \n        avg_cost.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in avg_cost:\n            unit = units_info[i]\n            new_min_base = min_base - unit['p_min_i']\n            new_max_base = max_base - unit['p_max_i']\n            if new_min_base <= load <= new_max_base:\n                base_online.remove(i)\n                min_base = new_min_base\n                max_base = new_max_base\n    \n    for i in base_online:\n        u_list[i] = 1\n        \n        if units_info[i]['u_i_0'] == 1:\n            lb = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            ub = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lb = units_info[i]['p_min_i']\n            ub = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'], units_info[i]['p_up_i'])\n        \n        p_list[i] = lb\n    \n    residual = load - sum(p_list)\n    \n    if residual > 0:\n        marginal = []\n        for i in base_online:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            \n            if p_list[i] < ub:\n                cost = 2 * unit['c_i'] * p_list[i] + unit['b_i']\n                marginal.append((i, cost))\n        \n        marginal.sort(key=lambda x: x[1])\n        \n        for i, mc in marginal:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            \n            available = min(ub - p_list[i], residual)\n            if available > 0:\n                p_list[i] += available\n                residual -= available\n                if residual <= 0:\n                    break\n    \n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0251005757,
          "gap_price_rate": 0.0188844455,
          "fitness": 0.0219925106
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Initialize commitment states to previous states and enforce minimum up/downtime constraints.\n2. Compute min/max power for each unit considering ramp and startup/shutdown limits.\n3. Calculate total min/max from committed units.\n4. If load exceeds max output, start new units in increasing order of (startup cost, marginal cost at min output).\n5. If load is below total min, decommit most expensive non-forced units sorted by production cost at min output.\n6. Perform economic dispatch on committed units to match load:\n   - Set outputs to min levels\n   - Increase output of unit with lowest marginal cost until load is satisfied or constraints reached.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n = len(units_info)\n    decisions_u = [unit['u_i_0'] for unit in units_info]\n    decisions_p = [0.0] * n\n    \n    # Identify forced online/offline units based on min up/down time\n    forced_online = []\n    forced_offline = []\n    for i, unit in enumerate(units_info):\n        t_i_0 = unit['t_i_0']\n        if unit['u_i_0'] == 1:\n            if t_i_0 < unit['t_on_min_i']:\n                forced_online.append(i)\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                forced_offline.append(i)\n    \n    # Enforce forced commitments\n    for i in forced_online:\n        decisions_u[i] = 1\n    for i in forced_offline:\n        decisions_u[i] = 0\n    \n    # Compute min/max power based on current state\n    min_power = []\n    max_power = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_power.append(min_i)\n        max_power.append(max_i)\n    \n    # Calculate total min/max from committed units\n    total_min = 0\n    total_max = 0\n    for i in range(n):\n        if decisions_u[i] == 1:\n            total_min += min_power[i]\n            total_max += max_power[i]\n    \n    # Start additional units if needed\n    if load > total_max:\n        candidate_units = [\n            i for i in range(n) \n            if decisions_u[i] == 0 \n            and i not in forced_offline\n            and units_info[i]['t_i_0'] <= -units_info[i]['t_off_min_i']\n        ]\n        candidate_units.sort(key=lambda i: (units_info[i]['s_i'], units_info[i]['b_i'] + 2*units_info[i]['c_i']*min_power[i]))\n        \n        for i in candidate_units:\n            decisions_u[i] = 1\n            total_min += min_power[i]\n            total_max += max_power[i]\n            if total_max >= load:\n                break\n    \n    # Decommit expensive units if over-generating\n    if load < total_min:\n        candidate_units_to_off = [\n            i for i in range(n)\n            if decisions_u[i] == 1\n            and i not in forced_online\n        ]\n        candidate_units_to_off.sort(\n            key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*min_power[i] + units_info[i]['c_i']*min_power[i]**2), \n            reverse=True\n        )\n        \n        for i in candidate_units_to_off:\n            if total_min - min_power[i] <= load:\n                decisions_u[i] = 0\n                total_min -= min_power[i]\n                total_max -= max_power[i]\n                if total_min <= load:\n                    break\n    \n    # Economic dispatch for committed units\n    committed_indices = [i for i in range(n) if decisions_u[i] == 1]\n    if committed_indices:\n        current_outputs = {i: min_power[i] for i in committed_indices}\n        total_output = sum(min_power[i] for i in committed_indices)\n        deficit = load - total_output\n        \n        while deficit > 1e-5:\n            candidate_unit = None\n            min_mc = float('inf')\n            \n            for i in committed_indices:\n                if current_outputs[i] < max_power[i]:\n                    marginal_cost = 2*units_info[i]['c_i']*current_outputs[i] + units_info[i]['b_i']\n                    if marginal_cost < min_mc:\n                        min_mc = marginal_cost\n                        candidate_unit = i\n            \n            if candidate_unit is None:\n                break\n                \n            max_increase = max_power[candidate_unit] - current_outputs[candidate_unit]\n            to_increase = min(max_increase, deficit)\n            current_outputs[candidate_unit] += to_increase\n            deficit -= to_increase\n        \n        for i in committed_indices:\n            decisions_p[i] = current_outputs[i]\n    \n    # Prepare output\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        schedules[0, i] = decisions_u[i]\n        schedules[1, i] = decisions_p[i]\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0485260819,
          "fitness": 0.024298887
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    n = len(units_info)\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    min_val = {}\n    max_val = {}\n    \n    # Classify units into must-on, must-off, free-on, free-off\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i'] or \n                unit['p_i_0'] > unit['p_shut_i'] or \n                unit['p_min_i'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Handle must-off units\n    for i in must_off:\n        u_arr[i] = 0\n        p_arr[i] = 0.0\n    \n    # Set must-on and free-on units, compute feasible range and initial output\n    for idx in must_on + free_on:\n        unit = units_info[idx]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_val[idx] = min_p\n        max_val[idx] = max_p\n        u_arr[idx] = 1\n        p_arr[idx] = min_p\n    \n    # Compute residual load\n    committed = must_on + free_on\n    total_min = sum(p_arr)\n    residual = load - total_min\n    \n    # Add free-off units by ascending average cost\n    candidate_free_off = []\n    for i in free_off:\n        unit = units_info[i]\n        if unit['p_min_i'] <= min(unit['p_max_i'], unit['p_start_i']):\n            min_p = unit['p_min_i']\n            startup_cost = unit['s_i']\n            fixed_cost = unit['a_i']\n            variable_cost = unit['b_i'] * min_p + unit['c_i'] * min_p ** 2\n            avg_cost = (startup_cost + fixed_cost + variable_cost) / min_p\n            candidate_free_off.append((avg_cost, i))\n    candidate_free_off.sort(key=lambda x: x[0])\n    \n    to_commit = []\n    for _, i in candidate_free_off:\n        if residual > 0:\n            u_arr[i] = 1\n            min_val[i] = units_info[i]['p_min_i']\n            max_val[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            p_arr[i] = min_val[i]\n            to_commit.append(i)\n            residual -= min_val[i]\n        else:\n            break\n    committed += to_commit\n    \n    # Iterative economic dispatch\n    total_p = sum(p_arr)\n    deficit = load - total_p\n    tol, max_iter = 0.1, 1000\n    iter_count = 0\n    while abs(deficit) > tol and iter_count < max_iter:\n        iter_count += 1\n        if deficit > 0:  # Underproduction: increase output\n            candidate, min_mc = None, float('inf')\n            for i in committed:\n                if p_arr[i] < max_val[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n                    if mc < min_mc:\n                        min_mc, candidate = mc, i\n            if candidate is None:\n                break\n            delta = min(max_val[candidate] - p_arr[candidate], deficit)\n            p_arr[candidate] += delta\n            deficit -= delta\n        else:  # Overproduction: decrease output\n            candidate, max_mc = None, -float('inf')\n            for i in committed:\n                if p_arr[i] > min_val[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n                    if mc > max_mc:\n                        max_mc, candidate = mc, i\n            if candidate is None:\n                break\n            delta = min(p_arr[candidate] - min_val[candidate], -deficit)\n            p_arr[candidate] -= delta\n            deficit += delta\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": null,
          "gap_power_rate": 8.01265e-05,
          "gap_price_rate": 0.0923868685,
          "fitness": 0.0462334975
     }
]