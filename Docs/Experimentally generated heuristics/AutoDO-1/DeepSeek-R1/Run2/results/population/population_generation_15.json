[
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into four states based on constraints and history:\n   - must_on: units violating min-up time (t_i_0 < t_on_min_i) or shutdown capacity (p_i_0 > p_shut_i)\n   - must_off: units violating min-down time (abs(t_i_0) < t_off_min_i)\n   - flexible_on: online units eligible for shutdown\n   - flexible_off: offline units eligible for startup\n2. Compute must_on generation bounds (min/max) considering ramp constraints:\n   - min_out = max(p_min_i, p_i_0 - p_down_i) \n   - max_out = min(p_max_i, p_i_0 + p_up_i)\n3. Case handling for load allocation:\n   a) Load within must_on bounds: commit only must_on units\n   b) Load exceeds must_on capacity:\n      - Form candidate set (must_on \u222a flexible_on)\n      - Start flexible_off units by ascending (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i\n      - Add started units to candidate_set while ensuring total max capacity \u2265 load\n      - Decommit non-must-on units by descending (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i \n        while maintaining total max capacity \u2265 load\n   c) Load below must_on minimum: set must_on units to minimum generation\n4. Calculate power bounds for committed units:\n   - Online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Started units: [p_min_i, min(p_max_i, p_start_i)]\n5. Initialize all committed outputs at lower bounds\n6. Distribute residual load using marginal cost priority:\n   - While residual load > tolerance:\n       1. Find unit with minimal current marginal cost (2*c_i*p_i + b_i)\n       2. Calculate step = min(residual, headroom, marginal cost delta to next unit)\n       3. Increase output and reduce residual\n7. Set uncommitted units to off-state (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    n = len(units_info)\n    tol = 1e-5\n    \n    # Classify units\n    must_on, must_off, flexible_on, flexible_off = set(), set(), set(), set()\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.add(i)\n            else:\n                flexible_on.add(i)\n        else:  # Offline units\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.add(i)\n            else:\n                flexible_off.add(i)\n    \n    # Calculate must_on bounds\n    total_min_must_on, total_max_must_on = 0, 0\n    for i in must_on:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_must_on += lb\n        total_max_must_on += ub\n    \n    # Case handling\n    if load < total_min_must_on - tol:\n        candidate_set = set(must_on)\n    elif abs(load - total_min_must_on) < tol or (total_min_must_on <= load <= total_max_must_on):\n        candidate_set = set(must_on)\n    else:  # load > total_max_must_on\n        candidate_set = must_on | flexible_on\n        total_max = total_max_must_on\n        for i in flexible_on:\n            unit = units_info[i]\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_max += ub\n        \n        # Start flexible_off units\n        flexible_off_sorted = sorted(\n            flexible_off, \n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n        )\n        for i in flexible_off_sorted:\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            if total_max < load:\n                candidate_set.add(i)\n                total_max += max_i\n            else:\n                break\n        \n        # Decommit non-must-on units\n        non_must_on = candidate_set - must_on\n        if non_must_on:\n            cost_priority = sorted(\n                non_must_on,\n                key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                             units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i'],\n                reverse=True\n            )\n            temp_candidate = set(candidate_set)\n            for i in cost_priority:\n                if i in flexible_on:\n                    max_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                if total_max - max_i >= load:\n                    temp_candidate.remove(i)\n                    total_max -= max_i\n            candidate_set = temp_candidate\n    \n    # Calculate power bounds and initialize outputs\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    outputs = [0.0] * n\n    lb_arr = [0.0] * n\n    ub_arr = [0.0] * n\n    \n    for i in candidate_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Online unit\n            lb_arr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started unit\n            lb_arr[i] = unit['p_min_i']\n            ub_arr[i] = min(unit['p_max_i'], unit['p_start_i'])\n        outputs[i] = lb_arr[i]\n        u_arr[i] = 1\n        p_arr[i] = outputs[i]\n    \n    # Distribute residual load\n    total_output = sum(outputs[i] for i in candidate_set)\n    residual = load - total_output\n    \n    if residual > tol:\n        while residual > tol:\n            min_mc = float('inf')\n            min_idx = -1\n            next_min_mc = float('inf')\n            \n            for i in candidate_set:\n                if outputs[i] < ub_arr[i] - tol:\n                    mc = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                    if mc < min_mc:\n                        next_min_mc = min_mc\n                        min_mc = mc\n                        min_idx = i\n                    elif min_mc < mc < next_min_mc:\n                        next_min_mc = mc\n            \n            if min_idx == -1:\n                break\n            \n            unit = units_info[min_idx]\n            headroom = ub_arr[min_idx] - outputs[min_idx]\n            step = min(residual, headroom)\n            \n            if next_min_mc < float('inf') and unit['c_i'] > tol:\n                step = min(step, (next_min_mc - min_mc) / (2 * unit['c_i']))\n            \n            outputs[min_idx] += step\n            p_arr[min_idx] = outputs[min_idx]\n            residual -= step\n    \n    # Set uncommitted units\n    for i in range(n):\n        if i not in candidate_set:\n            u_arr[i] = 0\n            p_arr[i] = 0.0\n    \n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.0044876472,
          "gap_price_rate": 0.0087221821,
          "fitness": 0.0066049146
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into four states based on constraints and history:\n   - must_on: units violating min-up time (t_i_0 < t_on_min_i) or shutdown capacity (p_i_0 > p_shut_i)\n   - must_off: units violating min-down time (|t_i_0| < t_off_min_i)\n   - flexible_on: online units eligible for shutdown\n   - flexible_off: offline units eligible for startup\n2. Compute must_on generation bounds:\n   - min_out_i = max(p_min_i, p_i_0 - p_down_i)\n   - max_out_i = min(p_max_i, p_i_0 + p_up_i)\n   - total_must_on_min = sum(min_out_i for must_on)\n   - total_must_on_max = sum(max_out_i for must_on)\n3. Case handling for load allocation:\n   a) Load within [total_must_on_min, total_must_on_max]: commit only must_on\n   b) Load exceeds total_must_on_max:\n      - Form candidate_set = must_on + flexible_on\n      - Start flexible_off units in ascending order of (s_i + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n        until total_max_capacity >= load\n      - Decommit non-must-on units by descending cost-per-MW metric (accounts for startup costs on started units)\n      while maintaining total_max_capacity >= load\n   c) Load below total_must_on_min: commit only must_on (allow overproduction)\n4. For committed units:\n   - Calculate power bounds:\n        * Started units: [p_min_i, min(p_max_i, p_start_i)]\n        * Online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Initialize outputs at lower bounds\n   - Distribute residual load via adaptive marginal cost allocation:\n        * Find active units with available capacity\n        * While residual load > tolerance and active units exist:\n            - Find unit with smallest marginal cost\n            - Calculate step size: min(residual, headroom, delta to next marginal cost)\n            - Increase output\n            - Remove unit if capacity exhausted\n5. Set uncommitted units to off-state\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # u_i0 == 0\n            if t_i0 < 0 and abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Compute must_on bounds and total capacities\n    total_must_on_min = 0.0\n    total_must_on_max = 0.0\n    must_on_bounds = {}\n    for i in must_on:\n        unit = units_info[i]\n        min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_on_min += min_i\n        total_must_on_max += max_i\n        must_on_bounds[i] = (min_i, max_i)\n    \n    # Initialize solution\n    u_sol = [0] * n\n    p_sol = [0] * n\n    candidate_set = []\n    started_units = []\n    \n    # Load case handling\n    if load < total_must_on_min:\n        candidate_set = must_on.copy()\n    elif total_must_on_min <= load <= total_must_on_max:\n        candidate_set = must_on.copy()\n    else:  # load > total_must_on_max\n        candidate_set = must_on + flexible_on\n        total_max_capacity = total_must_on_max\n        \n        # Compute flexible_on capacities\n        for i in flexible_on:\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_max_capacity += max_i\n        \n        # Sort flexible_off by cost-per-MW (ascending)\n        sorted_flexible_off = sorted(\n            flexible_off,\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                           units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                           units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i']\n        )\n        \n        # Start flexible_off units until total capacity covers load\n        started_units = []\n        for i in sorted_flexible_off:\n            if total_max_capacity >= load:\n                break\n            unit = units_info[i]\n            cap_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_capacity += cap_i\n            candidate_set.append(i)\n            started_units.append(i)\n        \n        # Decommit non-must-on units if excess capacity\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        non_must_on_costs = []\n        \n        for i in non_must_on:\n            unit = units_info[i]\n            if i in started_units:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            cost_per_MW = cost / unit['p_min_i']\n            \n            # Determine capacity for removal\n            if i in started_units:\n                cap_i = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                cap_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            non_must_on_costs.append((i, cost_per_MW, cap_i))\n        \n        # Sort by cost-per-MW (descending) for decommitting expensive units first\n        non_must_on_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, cost_per_MW, cap_i in non_must_on_costs:\n            if total_max_capacity - cap_i >= load:\n                total_max_capacity -= cap_i\n                candidate_set.remove(i)\n                if i in started_units:\n                    started_units.remove(i)\n    \n    # Set initial outputs and bounds for candidate_set\n    min_bound = [0] * n\n    max_bound = [0] * n\n    for i in candidate_set:\n        if i in started_units:\n            min_bound[i] = units_info[i]['p_min_i']\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            min_bound[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_bound[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        p_sol[i] = min_bound[i]\n    \n    # Compute residual load\n    total_p = sum(p_sol)\n    residual = load - total_p\n    \n    # Adaptive marginal cost allocation\n    tolerance = 1e-3\n    if residual > tolerance:\n        active_candidates = [i for i in candidate_set if p_sol[i] < max_bound[i] - tolerance]\n        while residual > tolerance and active_candidates:\n            min_mc = float('inf')\n            candidate_idx = None\n            headroom = 0\n            for i in active_candidates:\n                mc = 2 * units_info[i]['c_i'] * p_sol[i] + units_info[i]['b_i']\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate_idx = i\n                    headroom = max_bound[i] - p_sol[i]\n            \n            if candidate_idx is None:\n                break\n            \n            # Find next smallest marginal cost among active candidates\n            next_mc = float('inf')\n            for i in active_candidates:\n                if i == candidate_idx:\n                    continue\n                mc = 2 * units_info[i]['c_i'] * p_sol[i] + units_info[i]['b_i']\n                if min_mc < mc < next_mc:\n                    next_mc = mc\n            \n            # Calculate step size\n            c_i = units_info[candidate_idx]['c_i']\n            if c_i <= 0 or next_mc == float('inf'):\n                delta = min(residual, headroom)\n            else:\n                delta_p = (next_mc - min_mc) / (2 * c_i)\n                delta = min(residual, headroom, delta_p)\n            \n            # Update output and residual\n            p_sol[candidate_idx] += delta\n            residual -= delta\n            \n            # Remove candidate if capacity exhausted\n            if p_sol[candidate_idx] >= max_bound[candidate_idx] - tolerance:\n                active_candidates.remove(candidate_idx)\n    \n    # Set commitment states\n    for i in candidate_set:\n        u_sol[i] = 1\n    \n    return np.array([u_sol, p_sol], dtype=np.float64)",
          "from": "crossover",
          "gap_power_rate": 0.0044876472,
          "gap_price_rate": 0.0087485988,
          "fitness": 0.006618123
     },
     {
          "name": "new_heuristic",
          "algorithm": "1. Classify units into must_on (online, violate min-up/shutdown limits), must_off (offline, violate min-down time), flexible_on (eligible online), flexible_off (eligible offline)\n2. Compute must_on generation bounds incorporating ramp limits\n3. Case handling:\n   a) Load within must_on range: commit must_on only\n   b) Load exceeds must_on max:\n      - Start flexible_off units by startup+min-output cost per MW priority\n      - Decommit non-must-on units by average operating cost per MW at min output\n      - Maintain feasibility (min_output \u2264 load \u2264 max_output)\n   c) Load below must_on min: commit must_on only (overproduction)\n4. For committed units:\n   a) Calculate power bounds (online: ramp limits; startup: p_min to min(p_max, p_start))\n   b) Initialize outputs at lower bounds\n   c) Distribute residual load using adaptive marginal cost allocation\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef new_heuristic(units_info, load):\n    # Classify units\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                flexible_on.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible_off.append(unit)\n    \n    # Compute must-on generation bounds\n    total_must_on_min = 0\n    total_must_on_max = 0\n    for unit in must_on:\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_on_min += lb\n        total_must_on_max += ub\n    \n    # Case handling\n    if total_must_on_min <= load <= total_must_on_max:\n        commit_set = must_on.copy()\n        started_units = []\n    elif load < total_must_on_min:\n        commit_set = must_on.copy()\n        started_units = []\n    else:  # load > total_must_on_max\n        candidate_set = must_on + flexible_on\n        started_units = []\n        total_max_current = 0\n        \n        # Compute current total_max\n        for unit in candidate_set:\n            if unit in must_on or unit in flexible_on:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                total_max_current += ub\n        \n        # Start flexible_off units if needed\n        if total_max_current < load:\n            flexible_off_sorted = sorted(\n                flexible_off, \n                key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i']\n            )\n            for unit in flexible_off_sorted:\n                ub_start = min(unit['p_max_i'], unit['p_start_i'])\n                total_max_current += ub_start\n                candidate_set.append(unit)\n                started_units.append(unit)\n                if total_max_current >= load:\n                    break\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [u for u in candidate_set if u not in must_on]\n        removed = True\n        while removed and non_must_on:\n            # Compute min/max for candidate_set\n            total_min_candidate = 0\n            total_max_candidate = 0\n            for unit in candidate_set:\n                if unit in must_on:\n                    lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                elif unit in started_units:\n                    lb = unit['p_min_i']\n                    ub = min(unit['p_max_i'], unit['p_start_i'])\n                else:  # flexible_on\n                    lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                total_min_candidate += lb\n                total_max_candidate += ub\n            \n            # Sort non_must_on by average cost per MW at min output (descending)\n            non_must_on_sorted = sorted(\n                non_must_on,\n                key=lambda u: (u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'],\n                reverse=True\n            )\n            \n            removed = False\n            for i, unit in enumerate(non_must_on_sorted):\n                temp_candidate = [u for u in candidate_set if u != unit]\n                # Recompute bounds for temp_candidate\n                total_min_temp = total_min_candidate\n                total_max_temp = total_max_candidate\n                if unit in must_on:\n                    # Should not happen in non_must_on\n                    lb_u = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub_u = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                elif unit in started_units:\n                    lb_u = unit['p_min_i']\n                    ub_u = min(unit['p_max_i'], unit['p_start_i'])\n                else:\n                    lb_u = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub_u = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                \n                total_min_temp -= lb_u\n                total_max_temp -= ub_u\n                \n                if total_min_temp <= load <= total_max_temp:\n                    candidate_set = temp_candidate\n                    if unit in started_units:\n                        started_units.remove(unit)\n                    non_must_on.pop(i)\n                    removed = True\n                    break  # Restart loop\n                    \n        commit_set = candidate_set\n    \n    # Prepare committed units\n    committed_units = []\n    bounds = []\n    for unit in commit_set:\n        if unit in started_units:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        committed_units.append(unit)\n        bounds.append((lb, ub))\n    \n    # Initialize at lower bounds\n    p_alloc = [lb for lb, ub in bounds]\n    residual = load - sum(p_alloc)\n    max_increasable = [i for i, (_, ub) in enumerate(bounds) if p_alloc[i] < ub]\n    \n    # Distribute residual via adaptive marginal cost allocation\n    while residual > 0 and max_increasable:\n        # Compute current marginal costs\n        marginal_costs = [\n            2 * committed_units[i]['c_i'] * p_alloc[i] + committed_units[i]['b_i'] \n            for i in max_increasable\n        ]\n        \n        # Find unit with min marginal cost\n        min_idx_in_list = np.argmin(marginal_costs)\n        min_idx = max_increasable[min_idx_in_list]\n        min_mc = marginal_costs[min_idx_in_list]\n        \n        # Find next min marginal cost\n        next_mc = float('inf')\n        for i, mc in enumerate(marginal_costs):\n            if i == min_idx_in_list:\n                continue\n            if mc < next_mc and mc > min_mc:\n                next_mc = mc\n        \n        # Compute maximum possible increase\n        max_inc_unit = bounds[min_idx][1] - p_alloc[min_idx]\n        if next_mc == float('inf'):\n            step = min(max_inc_unit, residual)\n        else:\n            delta_p = (next_mc - min_mc) / (2 * committed_units[min_idx]['c_i'])\n            step = min(max_inc_unit, delta_p, residual)\n        \n        # Apply step\n        p_alloc[min_idx] += step\n        residual -= step\n        \n        # Remove from max_increasable if at bound\n        if np.isclose(p_alloc[min_idx], bounds[min_idx][1]):\n            max_increasable.remove(min_idx)\n    \n    # Build result\n    u_out = []\n    p_out = []\n    for i, unit in enumerate(units_info):\n        if unit in commit_set:\n            idx = commit_set.index(unit)\n            u_out.append(1)\n            p_out.append(p_alloc[idx])\n        else:\n            u_out.append(0)\n            p_out.append(0.0)\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0044876472,
          "gap_price_rate": 0.0087951792,
          "fitness": 0.0066414132
     },
     {
          "name": "refined_enhanced_combined_rolling",
          "algorithm": "1. Classify units into must-on (online violating min-up/shutdown constraints), must-off (offline violating min-down time), flexible-on (eligible online), and flexible-off (eligible offline)\n2. Compute must-on generation bounds incorporating ramp constraints\n3. Case handling:\n   a) Load within must-on range: commit only must-on units\n   b) Load exceeds must-on capacity:\n        - Form candidate set with must-on and flexible-on\n        - Start flexible-off units by ascending cost-per-MW including startup cost\n        - Decommit expensive non-must-on units (flexible-on/started) by average cost-per-MW at min output\n   c) Load below must-on min: set must-on units to minimum generation\n4. For committed units:\n   a) Calculate power bounds considering online/startup constraints\n   b) Initialize outputs at effective lower bounds\n   c) Distribute residual load via block allocation based on marginal cost\n5. Set uncommitted units to off-state\n",
          "code": "import numpy as np\n\ndef refined_enhanced_combined_rolling(units_info, load):\n    TOL = 1e-6\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    total_must_on_min = 0.0\n    total_must_on_max = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        lower_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        upper_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_on_min += lower_bound\n        total_must_on_max += upper_bound\n        \n    if load >= total_must_on_min - TOL and load <= total_must_on_max + TOL:\n        commit_set = must_on[:]\n    elif load > total_must_on_max + TOL:\n        candidate_set = must_on[:] + flexible_on[:]\n        current_max_output = total_must_on_max\n        for i in flexible_on:\n            unit = units_info[i]\n            current_max_output += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        # Start flexible-off units by ascending cost-per-MW\n        flexible_off_sorted = sorted(flexible_off, key=lambda i: (\n            (units_info[i]['s_i'] + units_info[i]['a_i'] + \n             units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n             units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']))\n        started_units = []\n        for i in flexible_off_sorted:\n            if current_max_output >= load:\n                break\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            current_max_output += max_i\n            candidate_set.append(i)\n            started_units.append(i)\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        non_must_on_sorted = sorted(non_must_on, key=lambda i: (\n            (units_info[i]['s_i'] * (1 if i in started_units else 0) + \n             units_info[i]['a_i'] + \n             units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n             units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']), reverse=True)\n        \n        for i in non_must_on_sorted:\n            if i in flexible_on:\n                max_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            if current_max_output - max_i >= load - TOL:\n                current_max_output -= max_i\n                candidate_set.remove(i)\n                if i in started_units:\n                    started_units.remove(i)\n        commit_set = candidate_set\n    else:  # load < total_must_on_min - TOL\n        commit_set = must_on[:]\n    \n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    bounds = {}\n    total_min = 0.0\n    for i in commit_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (low, high)\n        u_out[i] = 1\n        p_out[i] = low\n        total_min += low\n    \n    residual = load - total_min\n    if residual > TOL:\n        active_units = [i for i in commit_set if p_out[i] < bounds[i][1] - TOL]\n        while residual > TOL and active_units:\n            # Get current marginal costs\n            mc_list = []\n            for i in active_units:\n                mc = 2 * units_info[i]['c_i'] * p_out[i] + units_info[i]['b_i']\n                mc_list.append((mc, i))\n            mc_list.sort(key=lambda x: x[0])\n            \n            i0 = mc_list[0][1]\n            low0, high0 = bounds[i0]\n            unit0 = units_info[i0]\n            current_mc = 2 * unit0['c_i'] * p_out[i0] + unit0['b_i']\n            \n            # Find next highest marginal cost\n            next_mc = None\n            for j in range(1, len(mc_list)):\n                if mc_list[j][0] > current_mc + TOL:\n                    next_mc = mc_list[j][0]\n                    break\n            \n            # Compute possible delta for i0\n            if next_mc is not None and abs(unit0['c_i']) > TOL:\n                delta_mc = (next_mc - current_mc) / (2 * unit0['c_i'])\n            else:\n                delta_mc = float('inf')\n            delta_res = residual\n            delta_cap = high0 - p_out[i0]\n            delta = min(delta_res, delta_cap, delta_mc)\n            \n            p_out[i0] += delta\n            residual -= delta\n            \n            # Remove i0 if at max\n            if abs(p_out[i0] - high0) < TOL:\n                active_units.remove(i0)\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.004627356,
          "gap_price_rate": 0.0087040361,
          "fitness": 0.006665696
     },
     {
          "name": "refined_hybrid_dynamic_commitment",
          "algorithm": "1. Classify units into must_on (online violating min-up/shutdown constraints), must_off (offline violating min-down time), flexible_on (online eligible for shutdown), flexible_off (offline eligible for startup). \n2. Calculate must_on generation bounds with ramp constraints. \n3. Handle load cases:\n   a) Load \u2264 must_on min: commit only must_on units\n   b) Load within must_on min/max: commit must_on units\n   c) Load > must_on max: \n        - Start flexible_off by avg cost/MW priority\n        - Form candidate set (must_on + flexible_on + started)\n        - Decommit non-must-on units by operating cost efficiency\n4. Set power bounds for committed units considering ramp/startup constraints\n5. Initialize outputs at lower bounds\n6. Distribute residual load via adaptive marginal cost allocation\n7. Set uncommitted units to off-state\n",
          "code": "import numpy as np\n\ndef refined_hybrid_dynamic_commitment(units_info, load):\n    # Create working copy of units\n    units = [{\n        'a': u['a_i'], 'b': u['b_i'], 'c': u['c_i'], \n        'u0': u['u_i_0'], 'p0': u['p_i_0'], 't0': u['t_i_0'],\n        'pmin': u['p_min_i'], 'pmax': u['p_max_i'], \n        'p_up': u['p_up_i'], 'p_down': u['p_down_i'],\n        'p_start': u['p_start_i'], 'p_shut': u['p_shut_i'],\n        'min_up': u['t_on_min_i'], 'min_down': u['t_off_min_i'],\n        's': u['s_i'], 'idx': i, \n        'p_i': 0.0, 'u_i': 0, 'committed': False\n    } for i, u in enumerate(units_info)]\n    \n    # Classify units\n    must_on, must_off, flex_on, flex_off = [], [], [], []\n    for unit in units:\n        if unit['u0'] == 1:\n            if unit['t0'] < unit['min_up'] or unit['p0'] > unit['p_shut']:\n                must_on.append(unit)\n            else:\n                flex_on.append(unit)\n        else:\n            if abs(unit['t0']) < unit['min_down']:\n                must_off.append(unit)\n            else:\n                flex_off.append(unit)\n    \n    # Calculate must-on bounds\n    must_on_total_min = 0\n    must_on_total_max = 0\n    for unit in must_on:\n        unit['p_lower'] = max(unit['pmin'], unit['p0'] - unit['p_down'])\n        unit['p_upper'] = min(unit['pmax'], unit['p0'] + unit['p_up'])\n        must_on_total_min += unit['p_lower']\n        must_on_total_max += unit['p_upper']\n    \n    # Case handling\n    commit_set = []\n    if load <= must_on_total_min:  # Case a\n        commit_set = must_on\n    elif load <= must_on_total_max:  # Case b\n        commit_set = must_on\n    else:  # Case c\n        # Start flexible-off units\n        candidate_set = must_on + flex_on\n        flex_off_sorted = sorted(flex_off, \n            key=lambda u: (u['s'] + u['a'] + u['b']*u['pmin'] + u['c']*u['pmin']**2) / u['pmin']\n        )\n        for unit in flex_off_sorted:\n            candidate_set.append(unit)\n            candidate_max = sum(\n                min(u['pmax'], u['p0']+u['p_up']) if u in must_on+flex_on \n                else min(u['pmax'], u['p_start']) \n                for u in candidate_set\n            )\n            if candidate_max >= load:\n                break\n        \n        # Decommit non-must-on units\n        non_must_on = [u for u in candidate_set if u not in must_on]\n        non_must_on_sorted = sorted(non_must_on,\n            key=lambda u: (u['a'] + u['b']*u['pmin'] + u['c']*u['pmin']**2) / u['pmin'],\n            reverse=True\n        )\n        for unit in non_must_on_sorted:\n            candidate_set_temp = [u for u in candidate_set if u != unit]\n            candidate_max = sum(\n                min(u['pmax'], u['p0']+u['p_up']) if u in must_on+flex_on \n                else min(u['pmax'], u['p_start']) \n                for u in candidate_set_temp\n            )\n            if candidate_max >= load:\n                candidate_set = candidate_set_temp\n        commit_set = candidate_set\n    \n    # Set power bounds and initialize outputs\n    total_min = 0\n    for unit in commit_set:\n        unit['committed'] = True\n        if unit['u0'] == 1 or unit in flex_off:  # Online/started units\n            unit['p_lower'] = max(unit['pmin'], unit['p0'] - unit['p_down']) if unit['u0'] == 1 else unit['pmin']\n            unit['p_upper'] = min(unit['pmax'], unit['p0'] + unit['p_up']) if unit['u0'] == 1 else min(unit['pmax'], unit['p_start'])\n        else:\n            unit['p_lower'] = unit['pmin']\n            unit['p_upper'] = min(unit['pmax'], unit['p_start'])\n        unit['p_i'] = unit['p_lower']\n        total_min += unit['p_i']\n    residual = load - total_min\n    \n    # Distribute residual via marginal cost allocation\n    if residual > 1e-6:\n        inc_units = [u for u in commit_set if u['p_i'] < u['p_upper']]\n        while residual > 1e-6 and inc_units:\n            # Calculate marginal costs\n            marginal_costs = [2*u['c']*u['p_i'] + u['b'] for u in inc_units]\n            idx_min = np.argmin(marginal_costs)\n            best_unit = inc_units[idx_min]\n            \n            # Find next smallest marginal cost\n            other_mcs = [mc for i, mc in enumerate(marginal_costs) if i != idx_min]\n            next_mc = min(other_mcs) if other_mcs else float('inf')\n            current_mc = marginal_costs[idx_min]\n            \n            # Calculate max allocation step\n            max_ramp = best_unit['p_upper'] - best_unit['p_i']\n            if best_unit['c'] > 0 and next_mc > current_mc:\n                target_p = (next_mc - best_unit['b']) / (2 * best_unit['c'])\n                max_step = min(max_ramp, target_p - best_unit['p_i'], residual)\n            else:\n                max_step = min(max_ramp, residual)\n            \n            # Allocate power\n            best_unit['p_i'] += max_step\n            residual -= max_step\n            \n            # Remove unit if maxed out\n            if best_unit['p_i'] >= best_unit['p_upper'] - 1e-6:\n                inc_units.pop(idx_min)\n    \n    # Create output array\n    schedules = np.zeros((2, len(units_info)))\n    for unit in units:\n        idx = unit['idx']\n        if unit['committed']:\n            schedules[0, idx] = 1\n            schedules[1, idx] = unit['p_i']\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0052029567,
          "gap_price_rate": 0.0083960895,
          "fitness": 0.0067995231
     },
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "enhanced_combined_rolling_commitment_v1",
          "algorithm": "1. Classify units into must-on (online units violating min up-time/shutdown constraints), must-off (offline units violating min down-time), flexible-on (eligible online units), and flexible-off (eligible offline units)\n2. Compute must-on generation bounds incorporating ramp constraints\n3. Case handling:\n   a) Load within must-on range: commit only must-on units\n   b) Load exceeds must-on capacity:\n      - Start flexible-off units by ascending cost-per-MW including startup costs\n      - Form candidate set with must-on + flexible-on + started units\n      - Decommit expensive non-must-on units using operating cost efficiency\n   c) Load below must-on min: set must-on units to minimum generation\n4. Set power bounds considering online/startup constraints\n5. Initialize outputs at effective lower bounds\n6. Distribute residual load via marginal cost-based greedy allocation\n7. Set uncommitted units to off-state\n",
          "code": "import numpy as np\n\ndef enhanced_combined_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    tolerance = 1e-5\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Compute must-on bounds\n    total_min_must = 0.0\n    total_max_must = 0.0\n    must_on_bounds = {}\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_bounds[idx] = (lb, ub)\n        total_min_must += lb\n        total_max_must += ub\n    \n    # Load case handling\n    commit_set = set(must_on)\n    \n    if load <= total_min_must:\n        pass  # Only must-on units committed\n    elif load > total_max_must:\n        # Compute current capacity\n        candidate_set = set(must_on) | set(flexible_on)\n        total_capacity = total_max_must\n        \n        for idx in flexible_on:\n            unit = units_info[idx]\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_capacity += ub\n        \n        # Start flexible-off units\n        started = []\n        start_candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            start_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*min_p + unit['c_i']*(min_p**2)\n            metric = start_cost / min_p\n            start_candidates.append((metric, idx))\n        \n        start_candidates.sort(key=lambda x: x[0])\n        \n        for metric, idx in start_candidates:\n            if total_capacity >= load:\n                break\n            unit = units_info[idx]\n            max_capacity = min(unit['p_max_i'], unit['p_start_i'])\n            total_capacity += max_capacity\n            candidate_set.add(idx)\n            started.append(idx)\n        \n        # Decommit non-must-on units\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        decommit_candidates = []\n        for idx in non_must_on:\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            op_cost = unit['a_i'] + unit['b_i']*min_p + unit['c_i']*(min_p**2)\n            metric = op_cost / min_p\n            decommit_candidates.append((metric, idx))\n        \n        decommit_candidates.sort(key=lambda x: x[0], reverse=True)\n        \n        for metric, idx in decommit_candidates:\n            if idx in flexible_on:\n                capacity = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n            else:\n                capacity = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            \n            if total_capacity - capacity >= load:\n                total_capacity -= capacity\n                candidate_set.remove(idx)\n        \n        commit_set = candidate_set\n    else:\n        pass  # Only must-on units committed\n    \n    # Set commitment status and initial outputs\n    lb_dict = {}\n    ub_dict = {}\n    total_min = 0.0\n    \n    for idx in commit_set:\n        u[idx] = 1\n        if units_info[idx]['u_i_0'] == 1:\n            lb = max(units_info[idx]['p_min_i'], units_info[idx]['p_i_0'] - units_info[idx]['p_down_i'])\n            ub = min(units_info[idx]['p_max_i'], units_info[idx]['p_i_0'] + units_info[idx]['p_up_i'])\n        else:\n            lb = units_info[idx]['p_min_i']\n            ub = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n        lb_dict[idx] = lb\n        ub_dict[idx] = ub\n        p[idx] = lb\n        total_min += lb\n    \n    # Distribute residual load\n    residual = load - total_min\n    \n    if residual > tolerance:\n        # Continue until residual is allocated or no more capacity\n        while residual > tolerance:\n            candidates = []\n            for idx in commit_set:\n                if p[idx] < ub_dict[idx] - tolerance:\n                    marginal_cost = 2*units_info[idx]['c_i']*p[idx] + units_info[idx]['b_i']\n                    candidates.append((marginal_cost, idx))\n            \n            if not candidates:\n                break\n                \n            min_mc = min(candidates, key=lambda x: x[0])\n            idx = min_mc[1]\n            step = min(residual, ub_dict[idx] - p[idx])\n            p[idx] += step\n            residual -= step\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085223254,
          "fitness": 0.006846618
     },
     {
          "name": "enhanced_hybrid_dynamic_commitment",
          "algorithm": "1. Classify units into:  \n   - must_on: Units that must remain on (if (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i))  \n   - must_off: Units that must remain off (if abs(t_i_0) < t_off_min_i)  \n   - flexible_on: Online units eligible for shutdown  \n   - flexible_off: Offline units eligible for startup  \n2. Compute min/max bounds for must_on units:  \n   - Lower bound: max(p_min_i, p_i_0 - p_down_i)  \n   - Upper bound: min(p_max_i, p_i_0 + p_up_i)  \n3. Case handling:  \n   a) If load between must_on bounds: Commit only must_on units  \n   b) If load > must_on max:  \n        - Form candidate_set = must_on + flexible_on  \n        - Start flexible_off units by priority: min((s_i + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i)  \n        - After exceeding load, decommit non-must-on units by: max((2 * c_i * p_min_i + b_i) / p_min_i)  \n   c) If load < must_on min: Commit only must_on units  \n4. For committed units:  \n   a) Set power bounds based on state:  \n        - Online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]  \n        - Startup: [p_min_i, min(p_max_i, p_start_i)]  \n   b) Initialize at lower bounds  \n   c) Distribute residual via adaptive marginal cost allocation:  \n        - Create max_increasable_units (units below upper bound)  \n        - While residual > 0 and max_increasable_units:  \n            1. Compute current marginal costs  \n            2. Find unit with min marginal cost and next min cost  \n            3. Calculate max increase before marginal cost match  \n            4. Allocate largest possible step  \n5. Set non-committed units to off-state (u_i=0, p_i=0)  \n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_dynamic_commitment(units_info, load):\n    n = len(units_info)\n    schedules = np.zeros((2, n))\n    u = np.zeros(n)\n    p = np.zeros(n)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        p_min_i = unit['p_min_i']\n        \n        if u_i0 == 1:  # Was online\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Was offline\n            if abs(t_i0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Compute must_on bounds\n    total_min_must = 0.0\n    total_max_must = 0.0\n    must_on_lower = [0] * n\n    must_on_upper = [0] * n\n    \n    for i in must_on:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_i0 = unit['p_i_0']\n        \n        lower = max(p_min_i, p_i0 - p_down_i)\n        upper = min(p_max_i, p_i0 + p_up_i)\n        must_on_lower[i] = lower\n        must_on_upper[i] = upper\n        total_min_must += lower\n        total_max_must += upper\n    \n    candidate_set = []\n    \n    # Case handling\n    if total_min_must <= load <= total_max_must:\n        candidate_set = must_on.copy()\n    elif load > total_max_must:\n        candidate_set = must_on + flexible_on\n        total_min_candidate = total_min_must\n        total_max_candidate = total_max_must\n        \n        # Compute flexible_on bounds\n        for i in flexible_on:\n            unit = units_info[i]\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            p_i0 = unit['p_i_0']\n            \n            lower = max(p_min_i, p_i0 - p_down_i)\n            upper = min(p_max_i, p_i0 + p_up_i)\n            total_min_candidate += lower\n            total_max_candidate += upper\n        \n        # Start flexible_off units\n        flexible_off_sorted = sorted(\n            flexible_off,\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                          units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n        )\n        \n        for i in flexible_off_sorted:\n            if total_max_candidate >= load:\n                break\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_candidate += max_i\n            total_min_candidate += unit['p_min_i']\n            candidate_set.append(i)\n        \n        # Decommit non-must-on units\n        non_must_on = [i for i in candidate_set if i not in must_on]\n        non_must_on_sorted = sorted(\n            non_must_on,\n            key=lambda i: (2 * units_info[i]['c_i'] * units_info[i]['p_min_i'] + units_info[i]['b_i']) / units_info[i]['p_min_i'],\n            reverse=True\n        )\n        \n        for i in non_must_on_sorted:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if i in flexible_on else min(unit['p_max_i'], unit['p_start_i'])\n            \n            new_min = total_min_candidate - min_i\n            new_max = total_max_candidate - max_i\n            if new_min <= load <= new_max:\n                total_min_candidate = new_min\n                total_max_candidate = new_max\n                candidate_set.remove(i)\n    else:  # load < total_min_must\n        candidate_set = must_on.copy()\n    \n    # Set power bounds for candidate_set\n    p_lower = [0] * n\n    p_upper = [0] * n\n    \n    for i in candidate_set:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_i0 = unit['p_i_0']\n        \n        if i in must_on or i in flexible_on:\n            p_lower[i] = max(p_min_i, p_i0 - p_down_i)\n            p_upper[i] = min(p_max_i, p_i0 + p_up_i)\n        else:  # Started flexible_off\n            p_lower[i] = p_min_i\n            p_upper[i] = min(p_max_i, unit['p_start_i'])\n    \n    # Initialize outputs\n    total_output = 0.0\n    for i in candidate_set:\n        p[i] = p_lower[i]\n        total_output += p[i]\n        u[i] = 1\n    \n    residual = load - total_output\n    \n    # Distribute residual load\n    if residual > 0:\n        max_increasable_units = [i for i in candidate_set if p[i] < p_upper[i]]\n        \n        while residual > 1e-6 and max_increasable_units:\n            marginal_costs = []\n            for i in max_increasable_units:\n                marginal_costs.append(2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i'])\n            \n            min_idx = max_increasable_units[0]\n            min_mc = marginal_costs[0]\n            next_mc = float('inf')\n            \n            # Find min and next marginal costs\n            for idx, mc_val in zip(max_increasable_units, marginal_costs):\n                if mc_val < min_mc:\n                    next_mc = min_mc\n                    min_mc = mc_val\n                    min_idx = idx\n                elif min_mc < mc_val < next_mc:\n                    next_mc = mc_val\n            \n            # Calculate max possible increase\n            available = p_upper[min_idx] - p[min_idx]\n            if next_mc == float('inf'):\n                step = min(residual, available)\n            else:\n                c_i = units_info[min_idx]['c_i']\n                if c_i == 0:\n                    step = min(residual, available)\n                else:\n                    delta = (next_mc - min_mc) / (2 * c_i)\n                    step = min(delta, available, residual)\n            \n            p[min_idx] += step\n            residual -= step\n            \n            # Update max_increasable_units\n            max_increasable_units = [i for i in candidate_set if p[i] < p_upper[i]]\n    \n    # Finalize schedules\n    for i in candidate_set:\n        u[i] = 1\n    for i in range(n):\n        if i not in candidate_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules[0, :] = u\n    schedules[1, :] = p\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0044798733,
          "gap_price_rate": 0.0092395778,
          "fitness": 0.0068597255
     },
     {
          "name": "enhanced_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (online units that cannot shut down due to min-up time or shutdown constraints), must-off (offline units that cannot start due to min-down time), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for startup).\n2. Calculate total min/max output from must-on units considering ramp constraints.\n3. Handle three load cases:\n   a) Load within must-on range: Commit only must-on units\n   b) Load exceeds must-on capacity:\n        - Form candidate set with must-on + flexible-on units\n        - Start flexible-off units by ascending cost-per-MW priority until capacity >= load\n        - Decommit expensive non-must-on units from the candidate set in descending cost-per-MW order if excess capacity exists\n   c) Load below must-on minimum: Commit only must-on units, allowing overproduction\n4. For committed units:\n        a) Calculate power bounds considering operational state (online/startup)\n        b) Initialize outputs at lower bounds\n        c) Distribute residual load using a priority queue that continuously updates based on marginal costs\n5. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_hybrid_commitment(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n    \n    flexible_on = []\n    flexible_off = []\n    for i, unit in enumerate(units_info):\n        if i in must_on or i in must_off:\n            continue\n        if unit['u_i_0'] == 1:\n            flexible_on.append(i)\n        else:\n            flexible_off.append(i)\n    \n    # Calculate must-on bounds\n    total_min_must_on = 0.0\n    total_max_must_on = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_must_on += lb\n        total_max_must_on += ub\n    \n    commit_set = set()\n    # Handle load cases\n    if load <= total_max_must_on and load >= total_min_must_on:\n        commit_set = set(must_on)\n    elif load < total_min_must_on:\n        commit_set = set(must_on)\n    else:  # load > total_max_must_on\n        commit_set = set(must_on) | set(flexible_on)\n        total_max_current = 0.0\n        for i in commit_set:\n            unit = units_info[i]\n            total_max_current += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        # Start flexible-off units\n        candidate_flex_off = []\n        for i in flexible_off:\n            unit = units_info[i]\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                           unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n            candidate_flex_off.append((cost_per_mw, i))\n        candidate_flex_off.sort(key=lambda x: x[0])\n        \n        started_units = []\n        for cost, i in candidate_flex_off:\n            if total_max_current >= load:\n                break\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max_current += max_i\n            started_units.append(i)\n        \n        commit_set |= set(started_units)\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [i for i in commit_set if i not in must_on]\n        metrics = []\n        cap_dict = {}\n        for i in non_must_on:\n            unit = units_info[i]\n            if i in flexible_on:\n                cap_dict[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                               unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            else:\n                cap_dict[i] = min(unit['p_max_i'], unit['p_start_i'])\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                               unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            metrics.append((cost_per_mw, i))\n        metrics.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, i in metrics:\n            if total_max_current - cap_dict[i] >= load:\n                total_max_current -= cap_dict[i]\n                commit_set.remove(i)\n    \n    # Dispatch\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    bounds = {}\n    for i in commit_set:\n        u_arr[i] = 1\n        unit = units_info[i]\n        if unit['u_i_0'] == 0:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (lb, ub)\n        p_arr[i] = lb\n    \n    total_min = np.sum(p_arr)\n    if total_min < load:\n        heap = []\n        for i in commit_set:\n            lb, ub = bounds[i]\n            current = p_arr[i]\n            marginal_cost = 2 * units_info[i]['c_i'] * current + units_info[i]['b_i']\n            heapq.heappush(heap, (marginal_cost, i, current, lb, ub, units_info[i]['c_i'], units_info[i]['b_i']))\n        \n        residual = load - total_min\n        while residual > 0 and heap:\n            mc, i, current, lb, ub, c_i, b_i = heapq.heappop(heap)\n            max_inc = ub - current\n            if max_inc <= 0:\n                continue\n            delta = min(max_inc, residual)\n            new_output = current + delta\n            residual -= delta\n            p_arr[i] = new_output\n            if new_output < ub:\n                new_mc = 2 * c_i * new_output + b_i\n                heapq.heappush(heap, (new_mc, i, new_output, lb, ub, c_i, b_i))\n    \n    schedules = np.array([u_arr, p_arr])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0085928712,
          "fitness": 0.0068818909
     },
     {
          "name": "refined_enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into four states: must-on (units violating min up-time/shutdown capacity), must-off (units violating min down-time), flexible-on (eligible online units), flexible-off (eligible offline units)  \n2. Calculate must-on generation bounds incorporating ramp constraints  \n3. Case handling:  \n   a) Load within must-on bounds: commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by ascending cost-per-MW metric  \n      - Decommit expensive flexible-on units using incremental capacity efficiency  \n   c) Load below must-on min: must-on units operate at minimum output  \n4. Compute dynamic power bounds per unit based on commitment history  \n5. Initialize outputs at lower bounds  \n6. Distribute residual load via marginal cost-ordered priority queue  \n7. Set uncommitted units to off-state  \n\n",
          "code": "import heapq\nimport numpy as np\n\ndef refined_enhanced_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Initialize lists for unit classifications\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units based on operational constraints\n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Previously online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Previously offline\n            if abs(t_i_0) < t_off_min_i:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Calculate must-on generation bounds\n    must_on_min = 0.0\n    must_on_max = 0.0\n    for i in must_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        \n        min_bound = max(p_min, p_i_0 - p_down_i)\n        max_bound = min(p_max, p_i_0 + p_up_i)\n        must_on_min += min_bound\n        must_on_max += max_bound\n    \n    # Case handling for load allocation\n    candidate_set = set(must_on)  # Units to be committed\n    \n    if must_on_min <= load <= must_on_max:\n        # Case 3a: Load within must-on bounds\n        candidate_set = set(must_on)\n    \n    elif load > must_on_max:\n        # Case 3b: Load exceeds must-on capacity\n        candidate_set = set(must_on + flexible_on)\n        \n        # Calculate candidate set capacity\n        cand_min = must_on_min\n        cand_max = must_on_max\n        for i in flexible_on:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            \n            min_bound = max(p_min, p_i_0 - p_down_i)\n            max_bound = min(p_max, p_i_0 + p_up_i)\n            cand_min += min_bound\n            cand_max += max_bound\n        \n        # Start flexible-off units if needed (cost-per-MW priority)\n        if cand_max < load:\n            cost_per_mw = []\n            for i in flexible_off:\n                unit = units_info[i]\n                s_i = unit['s_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                \n                startup_cost = s_i\n                cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n                metric = (startup_cost + cost_at_min) / p_min_i\n                cost_per_mw.append((metric, i))\n            \n            cost_per_mw.sort(key=lambda x: x[0])\n            \n            for metric, i in cost_per_mw:\n                if cand_max >= load:\n                    break\n                \n                unit = units_info[i]\n                p_min_i = unit['p_min_i']\n                p_max_i = unit['p_max_i']\n                p_start_i = unit['p_start_i']\n                \n                max_output = min(p_max_i, p_start_i)\n                cand_min += p_min_i\n                cand_max += max_output\n                candidate_set.add(i)\n        \n        # Decommit expensive flexible-on units\n        cost_efficiency = []\n        for i in candidate_set - set(must_on):\n            unit = units_info[i]\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            p_min_i = unit['p_min_i']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            \n            min_bound = max(p_min_i, p_i_0 - p_down_i)\n            max_bound = min(unit['p_max_i'], p_i_0 + p_up_i)\n            incremental_cap = max_bound - min_bound\n            cost_at_min = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n            metric = cost_at_min / incremental_cap if incremental_cap > 0 else float('inf')\n            cost_efficiency.append((metric, i, min_bound, max_bound))\n        \n        cost_efficiency.sort(key=lambda x: x[0], reverse=True)\n        \n        for metric, i, min_bound, max_bound in cost_efficiency:\n            if i not in candidate_set:\n                continue\n                \n            new_min = cand_min - min_bound\n            new_max = cand_max - max_bound\n            \n            if new_max >= load:\n                candidate_set.remove(i)\n                cand_min = new_min\n                cand_max = new_max\n    \n    else:  # Case 3c: Load below must-on minimum\n        candidate_set = set(must_on)\n    \n    # Compute power bounds per unit\n    lower_bounds = np.zeros(num_units)\n    upper_bounds = np.zeros(num_units)\n    for i in range(num_units):\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if i in candidate_set:\n            if u_i_0 == 1:  # Continuation from online state\n                lower_bounds[i] = max(p_min_i, p_i_0 - p_down_i)\n                upper_bounds[i] = min(p_max_i, p_i_0 + p_up_i)\n            else:  # Starting from offline state\n                lower_bounds[i] = p_min_i\n                upper_bounds[i] = min(p_max_i, p_start_i)\n        else:\n            lower_bounds[i] = 0\n            upper_bounds[i] = 0\n    \n    # Initialize outputs at lower bounds\n    outputs = lower_bounds.copy()\n    total_output = np.sum(outputs)\n    residual = load - total_output\n    \n    # Economic dispatch via priority queue\n    heap = []\n    for i in candidate_set:\n        if outputs[i] < upper_bounds[i]:\n            marginal_cost = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n            heapq.heappush(heap, (marginal_cost, i))\n    \n    while residual > 0 and heap:\n        marginal_cost, i = heapq.heappop(heap)\n        available = upper_bounds[i] - outputs[i]\n        \n        if available > 0:\n            increment = min(available, residual)\n            outputs[i] += increment\n            residual -= increment\n            \n            # Update marginal cost and push back if capacity remains\n            if outputs[i] < upper_bounds[i]:\n                new_marginal = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                heapq.heappush(heap, (new_marginal, i))\n    \n    # Build final schedule\n    for i in range(num_units):\n        schedules[0, i] = 1 if i in candidate_set else 0\n        schedules[1, i] = outputs[i] if i in candidate_set else 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0052449584,
          "gap_price_rate": 0.0085332973,
          "fitness": 0.0068891278
     }
]