[
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "enhanced_adaptive_commitment",
          "algorithm": "1. Classify units into four groups:\n   a) Must-on: Online units that cannot shut down (inadequate min up-time or previous output > shutdown capacity)\n   b) Must-off: Offline units that cannot start (inadequate min down-time)\n   c) Flexible-on: Online units eligible for shutdown (p_i_0 \u2264 p_down_i)\n   d) Flexible-off: Offline units eligible for start (p_min_i \u2264 min(p_max_i, p_start_i))\n2. Form initial candidate set (must-on + flexible-on). Compute system min/max:\n   a) For must-on/flexible-on: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   b) For flexible-off: min = p_min_i, max = min(p_max_i, p_start_i)\n3. Handle load imbalance:\n   a) Case 1 (load > system max): Commit flexible-off units by ascending (startup cost + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i\n   b) Case 2 (load < system min): Decommit flexible-on units by descending min_output\n   c) Case 3 (system min \u2264 load \u2264 system max): Decommit expensive flexible-on units with output safety (new_min \u2264 load \u2264 new_max after decommit)\n4. Enhanced dispatch for committed units:\n   a) Set initial output = unit-specific min\n   b) Compute residual = load - sum(initial outputs)\n   c) Increase outputs on units with lowest marginal cost while respecting max limits\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Unpack unit info into separate arrays for efficiency\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize commitment and output arrays\n    u_i = np.zeros(num_units, dtype=int)\n    p_i = np.zeros(num_units)\n    \n    # Classify units\n    must_on_mask = (u_i_0 == 1) & ((t_i_0 < t_on_min) | (p_i_0 > p_shut))\n    must_off_mask = (u_i_0 == 0) & (-t_i_0 < t_off_min)\n    flexible_on_mask = (u_i_0 == 1) & ~must_on_mask & (p_i_0 <= p_down)\n    flexible_off_mask = (u_i_0 == 0) & ~must_off_mask & (p_min <= np.minimum(p_max, p_start))\n    \n    # Set must-on/must-off states\n    u_i[must_on_mask] = 1\n    u_i[must_off_mask] = 0\n    \n    # Candidate set (must-on + flexible-on initially)\n    candidate_mask = must_on_mask | flexible_on_mask\n    \n    # Compute min/max boundaries for candidates\n    candidate_min = np.zeros(num_units)\n    candidate_max = np.zeros(num_units)\n    \n    # For online candidates\n    online_candidate = must_on_mask | flexible_on_mask\n    candidate_min[online_candidate] = np.maximum(p_min[online_candidate], p_i_0[online_candidate] - p_down[online_candidate])\n    candidate_max[online_candidate] = np.minimum(p_max[online_candidate], p_i_0[online_candidate] + p_up[online_candidate])\n    \n    # For offline flexible units\n    flexible_off_ids = np.where(flexible_off_mask)[0]\n    candidate_min[flexible_off_ids] = p_min[flexible_off_ids]\n    candidate_max[flexible_off_ids] = np.minimum(p_max[flexible_off_ids], p_start[flexible_off_ids])\n    \n    system_min = np.sum(candidate_min[candidate_mask])\n    system_max = np.sum(candidate_max[candidate_mask])\n    \n    # Handle commitment cases\n    if load > system_max and np.any(flexible_off_mask):\n        # Case 1: Underproduction - start flexible-off units\n        avg_costs = (s[flexible_off_ids] + a[flexible_off_ids] + b[flexible_off_ids] * p_min[flexible_off_ids] \n                   + c[flexible_off_ids] * p_min[flexible_off_ids]**2) / p_min[flexible_off_ids]\n        priority_order = np.argsort(avg_costs)\n        for idx in priority_order:\n            unit_id = flexible_off_ids[idx]\n            candidate_mask[unit_id] = True\n            system_min += p_min[unit_id]\n            system_max += np.minimum(p_max[unit_id], p_start[unit_id])\n            if system_max >= load:\n                break\n                \n    elif load < system_min and np.any(flexible_on_mask):\n        # Case 2: Overproduction - decommit flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        min_outputs = candidate_min[flexible_on_ids]\n        priority_order = np.argsort(min_outputs)[::-1]  # Descending min output\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            if load >= system_min:\n                break\n            candidate_mask[unit_id] = False\n            system_min -= min_outputs[np.where(flexible_on_ids == unit_id)[0][0]]\n            system_max -= candidate_max[unit_id]\n            flexible_on_mask[unit_id] = False\n    \n    elif system_min <= load <= system_max and np.any(flexible_on_mask):\n        # Case 3: Within bounds - decommit expensive flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        avg_costs = (a[flexible_on_ids] + b[flexible_on_ids] * p_min[flexible_on_ids] \n                   + c[flexible_on_ids] * p_min[flexible_on_ids]**2) / p_min[flexible_on_ids]\n        priority_order = np.argsort(avg_costs)[::-1]  # Descending cost\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            new_min = system_min - candidate_min[unit_id]\n            new_max = system_max - candidate_max[unit_id]\n            if new_min <= load <= new_max:\n                candidate_mask[unit_id] = False\n                system_min, system_max = new_min, new_max\n    \n    # Update commitment state\n    u_i[candidate_mask] = 1\n    \n    # Economic dispatch for committed units\n    unit_min = np.zeros(num_units)\n    unit_max = np.zeros(num_units)\n    \n    # Set boundaries based on state\n    for i in range(num_units):\n        if candidate_mask[i]:\n            if u_i_0[i] == 1:  # Already online\n                unit_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                unit_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # Started this period\n                unit_min[i] = p_min[i]\n                unit_max[i] = min(p_max[i], p_start[i])\n    \n    # Initialize outputs at min levels\n    p_i[candidate_mask] = unit_min[candidate_mask]\n    residual = load - np.sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5 and np.any(p_i[candidate_mask] < unit_max[candidate_mask]):\n        # Find cheapest available unit\n        marginal_costs = b + 2 * c * p_i\n        marginal_costs[~candidate_mask] = np.inf\n        marginal_costs[p_i >= unit_max] = np.inf\n        \n        if np.all(marginal_costs == np.inf):\n            break\n            \n        cheapest_id = np.argmin(marginal_costs)\n        \n        # Calculate max possible increase\n        headroom = unit_max[cheapest_id] - p_i[cheapest_id]\n        increment = min(residual, headroom)\n        \n        # Update output and residual\n        p_i[cheapest_id] += increment\n        residual -= increment\n    \n    # Set outputs for non-committed units\n    p_i[~candidate_mask] = 0\n    \n    # Format output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056659523,
          "gap_price_rate": 0.0086261957,
          "fitness": 0.007146074
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and flexible (both online/offline)\n2. For must-on units, compute min/max output bounds based on current state and ramp constraints\n3. Handle three cases:\n   - Case 1 (load between must-on min/max): Keep only must-on units, turn off flexible units\n   - Case 2 (load > must-on max): Keep online flexible units, start additional offline units based on cost-effectiveness until load can be met\n   - Case 3 (load < must-on min): Must-on units at minimum, turn off all flexible units\n4. Economic dispatch for all online units:\n   a. Start at min output bounds\n   b. Sort units by increasing marginal cost\n   c. Increase output of cheapest units until load met or capacity exhausted\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    \n    # Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flex_online_indices = []\n    flex_offline_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flex_online_indices.append(i)\n        else:\n            t_off_abs = abs(unit['t_i_0'])\n            if t_off_abs < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flex_offline_indices.append(i)\n    \n    # Set must-off units to off\n    for i in must_off_indices:\n        u[i] = 0\n        p[i] = 0\n    \n    # Compute bounds for must-on units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_on_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        total_min_must += min_bound\n        total_max_must += max_bound\n        u[i] = 1\n    \n    # Initialize online set with must-on units\n    online_set = set(must_on_indices)\n    \n    if total_min_must <= load <= total_max_must:\n        # Case 1: Only must-on units needed\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    elif load > total_max_must:\n        # Case 2: Need additional units\n        current_capacity = total_max_must\n        deficit = load - total_max_must\n        \n        # Keep flexible online units\n        for i in flex_online_indices:\n            u[i] = 1\n            min_b = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_b = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            min_bounds[i] = min_b\n            max_bounds[i] = max_b\n            current_capacity += max_b\n            online_set.add(i)\n        \n        # Calculate remaining deficit\n        deficit = max(0, load - current_capacity)\n        started_units = []\n        \n        if deficit > 0:\n            # Sort offline flex by cost per MW at min output\n            cost_per_mw = []\n            for i in flex_offline_indices:\n                unit = units_info[i]\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n                cost_per_mw.append(cost / unit['p_min_i'])\n            sorted_indices = [i for _, i in sorted(zip(cost_per_mw, flex_offline_indices))]\n            \n            # Start most economical units first\n            for i in sorted_indices:\n                if deficit <= 0:\n                    break\n                u[i] = 1\n                min_bounds[i] = units_info[i]['p_min_i']\n                max_b = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                max_bounds[i] = max_b\n                online_set.add(i)\n                started_units.append(i)\n                current_capacity += max_b\n                deficit = load - current_capacity\n    \n    else:\n        # Case 3: Load < must-on minimum\n        for i in must_on_indices:\n            p[i] = min_bounds[i]\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    # Economic dispatch for online units\n    online_indices = sorted(online_set)\n    params = [(units_info[i]['b_i'], units_info[i]['c_i'], min_bounds[i], max_bounds[i]) for i in online_indices]\n    b, c, mins, maxs = zip(*params)\n    b = np.array(b)\n    c = np.array(c)\n    mins = np.array(mins)\n    maxs = np.array(maxs)\n    \n    # Start from min outputs\n    p_online = np.array(mins)\n    total_output = np.sum(p_online)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        # Sort by increasing marginal cost\n        marginal_costs = 2 * c * p_online + b\n        order = np.argsort(marginal_costs)\n        headroom = maxs - mins\n        \n        # Allocate deficit\n        for i in order:\n            alloc = min(deficit, headroom[i])\n            p_online[i] += alloc\n            deficit -= alloc\n            if deficit <= 0:\n                break\n    \n    # Update outputs\n    for idx, val in enumerate(online_indices):\n        p[val] = p_online[idx]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0100041649,
          "fitness": 0.0074306418
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Identify must-on units (if unit was online and hasn't satisfied min up-time or previous output exceeds shutdown capacity) and must-off units (if unit was offline and hasn't satisfied min down-time)\n2. Classify remaining units as optional_offline (online units that can be turned off) and optional_online (offline units that can be turned on)\n3. Compute base min/max output from must-on units considering ramp constraints\n4. Handle three cases:\n   a. Case 1 (load between base min/max): Use only must-on units\n   b. Case 2 (load > base max): Add optional_offline units then start optional_online units by average cost priority until max capacity >= load\n   c. Case 3 (load < base min): Use only must-on units (overproduction unavoidable)\n5. Attempt to turn off expensive optional_offline units in Case 2 if excess capacity exists\n6. For committed units:\n   a. Calculate power bounds considering current state and ramp constraints\n   b. Initialize outputs to minimum bounds\n   c. Distribute residual load to units with lowest marginal cost\n7. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    must_on = []\n    must_off = []\n    optional_offline = []\n    optional_online = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                optional_offline.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                optional_online.append(idx)\n                \n    base_min = 0.0\n    base_max = 0.0\n    committed_set = set(must_on)\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min += min_i\n            base_max += max_i\n            \n    if base_min <= load <= base_max:\n        pass  # Case 1: No change to committed_set\n    elif load > base_max:\n        base_min2 = base_min\n        base_max2 = base_max\n        for idx in optional_offline:\n            unit = units_info[idx]\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min2 += min_i\n            base_max2 += max_i\n            committed_set.add(idx)\n            \n        if load > base_max2:\n            sorted_opt_online = sorted(\n                optional_online,\n                key=lambda idx: (units_info[idx]['a_i'] + \n                              units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                              units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2) + \n                              units_info[idx]['s_i']) / units_info[idx]['p_min_i']\n            )\n            for idx in sorted_opt_online:\n                unit = units_info[idx]\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n                if base_max2 + max_i >= load:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    break\n                else:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    \n        temp_set = committed_set.copy()\n        sorted_opt_offline = sorted(\n            [idx for idx in optional_offline if idx in committed_set],\n            key=lambda idx: (units_info[idx]['a_i'] + \n                           units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                           units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2)) / \n                           units_info[idx]['p_min_i'],\n            reverse=True\n        )\n        current_max = base_max2\n        for idx in sorted_opt_offline:\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if current_max - max_i >= load:\n                committed_set.discard(idx)\n                current_max -= max_i\n    else:\n        pass  # Case 3: Overproduction unavoidable with must-on units\n        \n    min_limits = {}\n    max_limits = {}\n    for idx in committed_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_limits[idx] = min_i\n        max_limits[idx] = max_i\n        p_list[idx] = min_i\n        u_list[idx] = 1\n        \n    total_p = sum(p_list)\n    residual = load - total_p\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed_set:\n            if p_list[idx] < max_limits[idx]:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_list[idx]\n                candidates.append((marginal_cost, idx, max_limits[idx]))\n                \n        while residual > 0 and candidates:\n            candidates_sorted = sorted(candidates, key=lambda x: x[0])\n            best_mc, best_idx, best_max = candidates_sorted[0]\n            headroom = best_max - p_list[best_idx]\n            if headroom <= 0:\n                candidates.remove(candidates_sorted[0])\n                continue\n                \n            if headroom > residual:\n                p_list[best_idx] += residual\n                residual = 0\n            else:\n                p_list[best_idx] += headroom\n                residual -= headroom\n                candidates.remove(candidates_sorted[0])\n    \n    for idx in range(n_units):\n        if idx not in committed_set:\n            u_list[idx] = 0\n            p_list[idx] = 0.0\n            \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Identify must-on units (if unit was online and hasn't satisfied min up-time or previous output exceeds shutdown capacity) and must-off units (if unit was offline and hasn't satisfied min down-time)\n2. Classify remaining units as optional_offline (online units that can be turned off) and optional_online (offline units that can be turned on)\n3. Compute base min/max output from must-on units considering ramp constraints\n4. Handle three cases:\n   a. Case 1 (load between base min/max): Use only must-on units\n   b. Case 2 (load > base max): Add optional_offline units then start optional_online units by average cost priority until max capacity >= load\n   c. Case 3 (load < base min): Use only must-on units (overproduction unavoidable)\n5. Attempt to turn off expensive optional_offline units in Case 2 if excess capacity exists\n6. For committed units:\n   a. Calculate power bounds considering current state and ramp constraints\n   b. Initialize outputs to minimum bounds\n   c. Distribute residual load to units with lowest marginal cost\n7. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    must_on = []\n    must_off = []\n    optional_offline = []\n    optional_online = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                optional_offline.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                optional_online.append(idx)\n                \n    base_min = 0.0\n    base_max = 0.0\n    committed_set = set(must_on)\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min += min_i\n            base_max += max_i\n            \n    if base_min <= load <= base_max:\n        pass  # Case 1: No change to committed_set\n    elif load > base_max:\n        base_min2 = base_min\n        base_max2 = base_max\n        for idx in optional_offline:\n            unit = units_info[idx]\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min2 += min_i\n            base_max2 += max_i\n            committed_set.add(idx)\n            \n        if load > base_max2:\n            sorted_opt_online = sorted(\n                optional_online,\n                key=lambda idx: (units_info[idx]['a_i'] + \n                              units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                              units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2) + \n                              units_info[idx]['s_i']) / units_info[idx]['p_min_i']\n            )\n            for idx in sorted_opt_online:\n                unit = units_info[idx]\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n                if base_max2 + max_i >= load:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    break\n                else:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    \n        temp_set = committed_set.copy()\n        sorted_opt_offline = sorted(\n            [idx for idx in optional_offline if idx in committed_set],\n            key=lambda idx: (units_info[idx]['a_i'] + \n                           units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                           units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2)) / \n                           units_info[idx]['p_min_i'],\n            reverse=True\n        )\n        current_max = base_max2\n        for idx in sorted_opt_offline:\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if current_max - max_i >= load:\n                committed_set.discard(idx)\n                current_max -= max_i\n    else:\n        pass  # Case 3: Overproduction unavoidable with must-on units\n        \n    min_limits = {}\n    max_limits = {}\n    for idx in committed_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_limits[idx] = min_i\n        max_limits[idx] = max_i\n        p_list[idx] = min_i\n        u_list[idx] = 1\n        \n    total_p = sum(p_list)\n    residual = load - total_p\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed_set:\n            if p_list[idx] < max_limits[idx]:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_list[idx]\n                candidates.append((marginal_cost, idx, max_limits[idx]))\n                \n        while residual > 0 and candidates:\n            candidates_sorted = sorted(candidates, key=lambda x: x[0])\n            best_mc, best_idx, best_max = candidates_sorted[0]\n            headroom = best_max - p_list[best_idx]\n            if headroom <= 0:\n                candidates.remove(candidates_sorted[0])\n                continue\n                \n            if headroom > residual:\n                p_list[best_idx] += residual\n                residual = 0\n            else:\n                p_list[best_idx] += headroom\n                residual -= headroom\n                candidates.remove(candidates_sorted[0])\n    \n    for idx in range(n_units):\n        if idx not in committed_set:\n            u_list[idx] = 0\n            p_list[idx] = 0.0\n            \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and free units based on minimum up/down times and shutdown constraints:\n   - Must-on: units that were on (u_i_0=1) and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or previous output exceeds shutdown capacity (p_i_0 > p_shut_i)\n   - Must-off: units that were off (u_i_0=0) and haven't satisfied minimum down-time (-t_i_0 < t_off_min_i)\n   - Free units: remaining units that can be committed or decommitted\n\n2. Set must-off units to off (u_i=0, p_i=0) and must-on units to on (u_i=1)\n\n3. Calculate total minimum and maximum possible output from must-on units considering ramp constraints\n\n4. For underproduction (load > must-on max output):\n   - Sort free units by average production cost at minimum output\n   - Turn on free units in increasing cost order until cumulative max output >= load\n\n5. For overproduction (load < must-on min output), keep free units off\n\n6. Dispatch power:\n   - For each committed unit, compute power bounds based on current state and history\n   - Initialize power outputs to minimum bounds\n   - Incrementally increase output on units with cheapest marginal cost (b_i + 2*c_i*p_i) until meeting load or hitting constraints\n\n7. Return 2D array with commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Make a copy to avoid modifying original data\n    units = [unit.copy() for unit in units_info]\n    \n    # Classify units\n    must_on_units = []\n    must_off_units = []\n    free_units = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # u_i_0 == 0\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Set must-off units\n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Set must-on units and compute bounds\n    min_must = 0\n    max_must = 0\n    for unit in must_on_units:\n        unit['u_i'] = 1\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_must += low\n        max_must += high\n    \n    # Initialize free units to off\n    for unit in free_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Turn on additional free units for underproduction\n    candidate_set = []\n    if load > max_must:\n        # Sort by average cost at minimum power\n        free_units_sorted = sorted(free_units, key=lambda u: (u['s_i'] + u['a_i'] + \n                                  u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'])\n        \n        current_min = min_must\n        current_max = max_must\n        for unit in free_units_sorted:\n            if current_max >= load:\n                break\n            candidate_set.append(unit)\n            unit['u_i'] = 1\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n            current_min += unit['p_min_i']\n            current_max += high_i\n    elif load < min_must:\n        # Overproduction case\n        candidate_set = []\n    \n    # Collect all committed units\n    committed_units = must_on_units + candidate_set\n    for unit in must_off_units + free_units:\n        if unit not in committed_units:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Power dispatch: Compute bounds for each committed unit\n    bounds = []\n    for unit in committed_units:\n        if unit in must_on_units:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_i = unit['p_min_i']\n                high_i = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((low_i, high_i))\n    \n    # Initialize to min outputs\n    total_output = 0\n    for idx, unit in enumerate(committed_units):\n        low_i, high_i = bounds[idx]\n        unit['p_i'] = low_i\n        total_output += low_i\n    \n    # Incremental power allocation\n    remaining = load - total_output\n    if remaining > 0:\n        avail_units = []\n        for idx, unit in enumerate(committed_units):\n            low_i, high_i = bounds[idx]\n            if unit['p_i'] < high_i:\n                # Store (marginal_cost, index, unit_ref)\n                marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units.append((marg_cost, idx, unit))\n        \n        while remaining > 0 and avail_units:\n            avail_units.sort(key=lambda x: x[0])\n            cost, idx, unit = avail_units[0]\n            low_i, high_i = bounds[idx]\n            amount = min(remaining, high_i - unit['p_i'])\n            unit['p_i'] += amount\n            remaining -= amount\n            \n            # Update availability\n            if unit['p_i'] >= high_i:\n                avail_units.pop(0)\n            else:\n                # Update marginal cost for this unit\n                new_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units[0] = (new_cost, idx, unit)\n    \n    # Format results in original unit order\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "enhanced_refined_commit_units",
          "algorithm": "1. Classify units:\n   - Must-on: Online units not meeting min up-time or previous output exceeding shutdown capacity\n   - Must-off: Offline units not meeting min down-time\n   - Flexible online: Online units not must-on (can be turned off)\n   - Flexible offline: Offline units not must-off (can be turned on)\n\n2. Compute power bounds for must-on units considering ramp constraints:\n   - min_output = max(p_min_i, p_i_0 - p_down_i)\n   - max_output = min(p_max_i, p_i_0 + p_up_i)\n\n3. Handle three cases:\n   - Case 1 (load within [\u03a3 must_on_min, \u03a3 must_on_max]): Use only must-on units\n   - Case 2 (load > \u03a3 must_on_max): \n        a. Form candidate set with must-on + flexible online\n        b. If capacity insufficient, start flexible offline units by ascending (s_i/p_min_i + b_i + c_i*p_min_i)\n        c. Remove expensive flexible online units from candidate set if capacity permits\n   - Case 3 (load < \u03a3 must_on_min): Use only must-on units (overproduction unavoidable)\n\n4. For committed units in candidate set:\n   - Compute min/max bounds considering state (online: ramp constraints, offline: startup limits)\n   - Initialize outputs to min bounds\n   - Allocate residual load by increasing output of units with smallest (b_i + 2*c_i*p_i)\n\n5. Set non-committed units to off\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_commit_units(units_info, load):\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    # Classification lists\n    must_on_idx = []\n    must_off_idx = []\n    flexible_online_idx = []\n    flexible_offline_idx = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_idx.append(i)\n            else:\n                flexible_online_idx.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off_idx.append(i)\n            else:\n                flexible_offline_idx.append(i)\n    \n    candidate_set = set()\n    must_on_min = 0.0\n    must_on_max = 0.0\n    must_on_min_max = {}\n    \n    # Calculate must-on bounds\n    for i in must_on_idx:\n        unit = units_info[i]\n        min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min_max[i] = (min_out, max_out)\n        must_on_min += min_out\n        must_on_max += max_out\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on_idx)\n    elif load > must_on_max:\n        # Start with must-on + flexible online\n        candidate_set = set(must_on_idx) | set(flexible_online_idx)\n        total_max = must_on_max\n        flex_online_max = []\n        \n        # Calculate bounds for flexible online\n        for i in flexible_online_idx:\n            unit = units_info[i]\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_max += max_out\n            flex_online_max.append(max_out)\n        \n        # Start offline units if needed\n        if total_max < load:\n            offline_units = []\n            for i in flexible_offline_idx:\n                unit = units_info[i]\n                min_power = unit['p_min_i']\n                startup_priority = (\n                    unit['s_i'] / min_power + \n                    unit['b_i'] + \n                    unit['c_i'] * min_power\n                )\n                max_out_start = min(unit['p_max_i'], unit['p_start_i'])\n                offline_units.append((startup_priority, i, max_out_start))\n            \n            offline_units.sort(key=lambda x: x[0])\n            \n            for _, i, max_out in offline_units:\n                candidate_set.add(i)\n                total_max += max_out\n                if total_max >= load:\n                    break\n        \n        # Remove expensive flexible online if possible\n        flex_costs = []\n        for i in flexible_online_idx:\n            if i in candidate_set:\n                unit = units_info[i]\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                cost = unit['b_i'] + 2 * unit['c_i'] * min_out\n                flex_costs.append((cost, i, min_out))\n        \n        if flex_costs:\n            flex_costs.sort(key=lambda x: x[0], reverse=True)\n            for cost, i, min_out in flex_costs:\n                candidate_set_temp = candidate_set - {i}\n                total_max_temp = must_on_max\n                \n                # Recalculate max capacity\n                for j in candidate_set_temp:\n                    if j in flexible_online_idx:\n                        unit = units_info[j]\n                        total_max_temp += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    elif j in flexible_offline_idx:\n                        unit = units_info[j]\n                        total_max_temp += min(unit['p_max_i'], unit['p_start_i'])\n                \n                if total_max_temp >= load:\n                    candidate_set = candidate_set_temp\n    else:  # Case 3: Load < must_on_min\n        candidate_set = set(must_on_idx)\n    \n    # Power bounds for candidate set\n    unit_min_max = {}\n    for i in candidate_set:\n        unit = units_info[i]\n        if i in must_on_idx or i in flexible_online_idx:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started offline unit\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        unit_min_max[i] = (min_out, max_out)\n    \n    # Dispatch initialization\n    p_dispatch = {}\n    total_min_dispatch = 0.0\n    for i in candidate_set:\n        min_out, _ = unit_min_max[i]\n        p_dispatch[i] = min_out\n        total_min_dispatch += min_out\n    \n    # Allocate residual load\n    residual = load - total_min_dispatch\n    if residual > 0:\n        # Sort by marginal cost (b_i + 2*c_i*p)\n        candidate_list = sorted(\n            candidate_set,\n            key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_dispatch[i]\n        )\n        \n        for i in candidate_list:\n            min_out, max_out = unit_min_max[i]\n            headroom = max_out - p_dispatch[i]\n            if headroom <= 0:\n                continue\n            allocation = min(residual, headroom)\n            p_dispatch[i] += allocation\n            residual -= allocation\n            if residual <= 0:\n                break\n    \n    # Set output values\n    for i in range(n_units):\n        if i in candidate_set:\n            u_arr[i] = 1\n            p_arr[i] = p_dispatch.get(i, 0.0)\n        else:\n            u_arr[i] = 0\n            p_arr[i] = 0.0\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0055793389,
          "gap_price_rate": 0.0137930198,
          "fitness": 0.0096861794
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into four categories:\n   - Forced on: Online units with insufficient min-up-time or output exceeding shutdown ramp limit\n   - Forced off: Offline units with insufficient min-down-time\n   - Flexible online: Online units not in forced categories\n   - Flexible offline: Offline units not in forced categories\n\n2. Calculate must-run capacity:\n   - Compute min/max output for forced-on units considering ramp constraints\n   - If load is between min/max must-run capacity:\n        Commit only forced-on units, turn off flexible units\n   - If load exceeds must-run max capacity:\n        Commit flexible online units\n        Start flexible offline units by cost-effectiveness priority\n        (Priority = (startup_cost + production_cost_at_min_output) / min_output)\n   - If load is below must-run min capacity:\n        Turn off all flexible units (overproduction unavoidable)\n\n3. Economic dispatch for committed units:\n   a. Calculate power bounds per unit based on operational state\n   b. Initialize outputs at min production levels\n   c. If underproducing: Increase output on units with cheapest marginal cost\n   d. If overproducing: Keep min outputs (unavoidable overproduction)\n\n4. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n = len(units_info)\n    # Initialize outputs\n    u_current = [0] * n\n    p_current = [0] * n\n    \n    # Step 1: Classify units\n    forced_on_idx = []\n    forced_off_idx = []\n    flex_online_idx = []\n    flex_offline_idx = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_idx.append(i)\n            else:\n                flex_online_idx.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off_idx.append(i)\n            else:\n                flex_offline_idx.append(i)\n    \n    # Step 2: Calculate must-run capacity\n    total_min_forced = 0.0\n    total_max_forced = 0.0\n    min_p_forced = {}\n    max_p_forced = {}\n    \n    for i in forced_on_idx:\n        unit = units_info[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_p_forced[i] = min_p\n        max_p_forced[i] = max_p\n        total_min_forced += min_p\n        total_max_forced += max_p\n    \n    # Case handling\n    committed_set = set(forced_on_idx)  # Always include forced-on units\n    \n    if total_min_forced <= load <= total_max_forced:\n        # Case 1: Must-run units can handle load independently\n        for i in flex_online_idx + flex_offline_idx:\n            u_current[i] = 0\n            p_current[i] = 0\n        \n    elif load > total_max_forced:\n        # Case 2: Underproduction\n        # Commit flexible online units\n        min_p_flex_online = {}\n        max_p_flex_online = {}\n        current_max = total_max_forced\n        \n        for i in flex_online_idx:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_p_flex_online[i] = min_p\n            max_p_flex_online[i] = max_p\n            current_max += max_p\n            committed_set.add(i)\n        \n        # Start additional offline units if needed\n        if current_max < load:\n            # Priority calculation for offline units\n            candidates = []\n            for i in flex_offline_idx:\n                unit = units_info[i]\n                min_p = unit['p_min_i']\n                production_cost = unit['b_i'] * min_p + unit['c_i'] * min_p**2\n                cost_per_mw = (unit['s_i'] + production_cost) / min_p\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n                candidates.append((cost_per_mw, min_p, max_p, i))\n            \n            # Start most cost-effective units first\n            candidates.sort(key=lambda x: x[0])\n            for _, min_p, max_p, i in candidates:\n                if current_max >= load:\n                    break\n                committed_set.add(i)\n                current_max += max_p\n        \n        # Set uncommitted flex_offline to offline\n        for i in flex_offline_idx:\n            if i not in committed_set:\n                u_current[i] = 0\n                p_current[i] = 0\n        \n    else:  # load < total_min_forced\n        # Case 3: Unavoidable overproduction\n        for i in flex_online_idx + flex_offline_idx:\n            u_current[i] = 0\n            p_current[i] = 0\n    \n    # Step 3: Economic dispatch for committed units\n    min_p_vec = {}\n    max_p_vec = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Was offline\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        min_p_vec[i] = min_p\n        max_p_vec[i] = max_p\n        u_current[i] = 1\n        p_current[i] = min_p\n    \n    # Calculate residual load\n    total_p = sum(p_current)\n    residual = load - total_p\n    \n    # Adjust output if possible\n    if residual > 0:  # Underproduction\n        # Priority by marginal cost\n        mc_list = []\n        for i in committed_set:\n            unit = units_info[i]\n            current_p = p_current[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            headroom = max_p_vec[i] - current_p\n            mc_list.append((marginal_cost, headroom, i))\n        \n        mc_list.sort(key=lambda x: x[0])\n        for mc, headroom, i in mc_list:\n            if residual <= 1e-7:\n                break\n            if headroom > 1e-7:\n                alloc = min(headroom, residual)\n                p_current[i] += alloc\n                residual -= alloc\n    \n    # Set non-committed units to off (redundant for safety)\n    for i in set(range(n)) - committed_set:\n        u_current[i] = 0\n        p_current[i] = 0\n    \n    return np.array([u_current, p_current])",
          "from": "mutation",
          "gap_power_rate": 0.005211854,
          "gap_price_rate": 0.0150284964,
          "fitness": 0.0101201752
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot shut down), must-off (cannot start), optional_offline (online flexible units), and optional_online (offline flexible units) based on min up/downtime and shutdown constraints\n2. For must-on units, compute min/max output bounds considering ramp constraints\n3. Handle cases:\n   a. Case 1 (load between must-on min/max): Use only must-on units\n   b. Case 2 (load > must-on max): Commit optional_offline then start optional_online by ascending avg-cost priority until capacity \u2265 load\n   c. Case 3 (load < must-on min): Use only must-on units (overproduction unavoidable)\n4. For Case 2 only: Attempt to turn off expensive optional_offline units (sorted by marginal cost) that can be decommitted without causing under-capacity\n   a. Check min uptime satisfaction and shutdown constraints\n   b. Verify remaining capacity meets load\n5. For committed units:\n   a. Calculate min/max power bounds based on state changes (startup ramps for new units)\n   b. Initialize outputs at min bounds\n   c. Distribute residual load to units with cheapest marginal cost\n6. Set non-committed units to off state (u_i=0, p_i=0)\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    candidate_set = set()\n    \n    # Classify units and identify must-on/must-off\n    must_on_indices = []\n    must_off_indices = []\n    optional_offline = []\n    optional_online = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            must_on_indices.append(i)\n            u[i] = 1\n            candidate_set.add(i)\n        elif unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            must_off_indices.append(i)\n            u[i] = 0\n            p[i] = 0.0\n        else:\n            if unit['u_i_0'] == 1:\n                optional_offline.append(i)\n            else:\n                optional_online.append(i)\n    \n    # Compute must-on min/max outputs\n    total_base_min = 0.0\n    total_base_max = 0.0\n    must_on_minmax = {}\n    \n    for i in must_on_indices:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_minmax[i] = (min_output, max_output)\n        total_base_min += min_output\n        total_base_max += max_output\n\n    # Case handling\n    if total_base_min <= load <= total_base_max:\n        pass  # Case 1: use only must-on\n    elif load > total_base_max:\n        # Case 2: add optional_offline units\n        for i in optional_offline:\n            u[i] = 1\n            candidate_set.add(i)\n        \n        # Add optional_online if needed\n        total_candidate_min = total_base_min\n        total_candidate_max = total_base_max\n        \n        for i in optional_offline:\n            unit = units_info[i]\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_candidate_min += min_output\n            total_candidate_max += max_output\n        \n        if total_candidate_max < load:\n            priority_list = []\n            for i in optional_online:\n                unit = units_info[i]\n                min_output = unit['p_min_i']\n                avg_cost = (unit['s_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2) / min_output\n                priority_list.append((avg_cost, i))\n            priority_list.sort(key=lambda x: x[0])\n            \n            for _, i in priority_list:\n                unit = units_info[i]\n                min_output = unit['p_min_i']\n                max_output = min(unit['p_max_i'], unit['p_start_i'])\n                u[i] = 1\n                candidate_set.add(i)\n                total_candidate_min += min_output\n                total_candidate_max += max_output\n                if total_candidate_max >= load:\n                    break\n        \n        # Attempt to turn off expensive optional_offline units\n        removable = []\n        for i in optional_offline:\n            if i not in candidate_set:\n                continue\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            removable.append((marginal_cost, i))\n        \n        removable.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in removable:\n            unit = units_info[i]\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            # Check decommit conditions\n            decommit_ok = (unit['t_i_0'] >= unit['t_on_min_i'] and \n                           unit['p_i_0'] <= min(unit['p_down_i'], unit['p_shut_i']))\n            if not decommit_ok:\n                continue\n            \n            # Verify capacity after removal\n            new_max = total_candidate_max - max_output\n            if new_max >= load:\n                u[i] = 0\n                p[i] = 0\n                candidate_set.remove(i)\n                total_candidate_min -= min_output\n                total_candidate_max = new_max\n    else:\n        pass  # Case 3: use only must-on (load < total_base_min)\n    \n    # Power bounds calculation\n    min_bound = [0.0] * n_units\n    max_bound = [0.0] * n_units\n    \n    for i in range(n_units):\n        if i in candidate_set:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:  # Already online\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Being started\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initialize outputs and handle residual\n    residual = load\n    for i in candidate_set:\n        p[i] = min_bound[i]\n        residual -= p[i]\n    \n    # Economic dispatch: distribute positive residual\n    if residual > 0:\n        units_to_adjust = []\n        for i in candidate_set:\n            headroom = max_bound[i] - min_bound[i]\n            if headroom > 1e-6:\n                units_to_adjust.append(i)\n        \n        # Sort by marginal cost at min bound\n        def get_marginal_cost(i):\n            return units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p[i]\n        \n        units_to_adjust.sort(key=get_marginal_cost)\n        \n        for i in units_to_adjust:\n            headroom = max_bound[i] - p[i]\n            allocation = min(residual, headroom)\n            p[i] += allocation\n            residual -= allocation\n            if residual <= 1e-6:\n                break\n    \n    # Set non-candidate units to off\n    for i in range(n_units):\n        if i not in candidate_set:\n            u[i] = 0\n            p[i] = 0.0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0055793389,
          "gap_price_rate": 0.0149042992,
          "fitness": 0.0102418191
     },
     {
          "name": "commit_units_refined",
          "algorithm": "**  \n1. Classify units into must-on (cannot shut due to min up-time or shutdown ramp constraint), must-off (cannot start due to min down-time), and flexible (can switch).  \n2. For must-on units: compute min/max power bounds considering ramp constraints from previous state.  \n3. Determine system state:  \n   - **Case 1 (load within must-on bounds):** Turn off all flexible units. Only dispatch must-on units.  \n   - **Case 2 (load > must-on max):** Keep current online flexible units; start new flexible units by ascending priority (startup cost per MW + marginal cost at min power).  \n   - **Case 3 (load < must-on min):** Turn off all flexible units. Must-on units operate at min output (overproduction).  \n4. For committed units:  \n   - Compute min/max bounds based on current state (startup/online ramp constraints).  \n   - Initialize outputs to min bounds.  \n   - Dispatch residual load by increasing output on units with lowest marginal cost (b_i + 2*c_i*p_i) until meeting load or exhausting capacity.  \n5. Set non-committed units to off (u_i=0, p_i=0).  \n\n**",
          "code": "import numpy as np\n\ndef commit_units_refined(units_info, load):\n    n = len(units_info)\n    u_out = np.zeros(n)\n    p_out = np.zeros(n)\n    must_on = [False] * n\n    must_off = [False] * n\n    flexible = [False] * n\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                flexible[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Set initial commitment\n    for i in range(n):\n        if must_on[i]:\n            u_out[i] = 1\n        elif must_off[i]:\n            u_out[i] = 0\n        else:\n            u_out[i] = units_info[i]['u_i_0']\n    \n    # Compute must-on bounds\n    must_on_min_sum = 0\n    must_on_max_sum = 0\n    for i in range(n):\n        if must_on[i]:\n            unit = units_info[i]\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            must_on_min_sum += min_p\n            must_on_max_sum += max_p\n    \n    # Handle cases\n    committed_units = set(i for i in range(n) if must_on[i])\n    flexible_online = [i for i in range(n) if flexible[i] and u_out[i] == 1]\n    \n    if must_on_min_sum <= load <= must_on_max_sum:  # Case 1\n        for i in range(n):\n            if flexible[i]:\n                u_out[i] = 0\n        committed_units = set(i for i in range(n) if must_on[i])\n    elif load > must_on_max_sum:  # Case 2\n        current_max = must_on_max_sum\n        for i in flexible_online:\n            unit = units_info[i]\n            current_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            committed_units.add(i)\n        \n        candidate_units = [i for i in range(n) if flexible[i] and u_out[i] == 0]\n        candidate_units.sort(\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                           units_info[i]['c_i'] * (units_info[i]['p_min_i'] ** 2)) / units_info[i]['p_min_i']\n        )\n        \n        for i in candidate_units:\n            if current_max >= load:\n                break\n            u_out[i] = 1\n            committed_units.add(i)\n            current_max += min(units_info[i]['p_max_i'], units_info[i]['p_up_i'], units_info[i]['p_start_i'])\n    else:  # Case 3: load < must_on_min_sum\n        for i in range(n):\n            if flexible[i]:\n                u_out[i] = 0\n        committed_units = set(i for i in range(n) if must_on[i])\n    \n    # Compute bounds for committed units\n    min_bounds = np.zeros(n)\n    max_bounds = np.zeros(n)\n    for i in committed_units:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1 and u_out[i] == 1:  # Remain online\n            min_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Startup\n            min_bounds[i] = unit['p_min_i']\n            max_bounds[i] = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n    \n    # Dispatch initialization\n    total_base = 0\n    for i in committed_units:\n        p_out[i] = min_bounds[i]\n        total_base += min_bounds[i]\n    \n    residual = max(0, load - total_base)\n    current_outputs = p_out.copy()\n    committed_list = list(committed_units)\n    \n    # Dispatch residual load\n    while residual > 1e-6:\n        best_idx = None\n        best_marginal = float('inf')\n        for i in committed_list:\n            if current_outputs[i] < max_bounds[i] - 1e-6:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_outputs[i]\n                if marginal_cost < best_marginal:\n                    best_marginal = marginal_cost\n                    best_idx = i\n        if best_idx is None:\n            break\n        \n        delta = min(residual, max_bounds[best_idx] - current_outputs[best_idx])\n        current_outputs[best_idx] += delta\n        residual -= delta\n    \n    p_out = current_outputs\n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0062535524,
          "gap_price_rate": 0.0151970712,
          "fitness": 0.0107253118
     }
]