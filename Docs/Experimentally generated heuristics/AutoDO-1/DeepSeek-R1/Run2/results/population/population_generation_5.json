[
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "refined_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (online and cannot shut down due to minimum up-time or shutdown constraints), must-off (offline and cannot start due to minimum down-time), flexible-on (online and eligible for shutdown), flexible-off (offline and eligible for startup)  \n2. Calculate total minimum/maximum output from must-on units considering ramp constraints  \n3. Case handling:  \n   a) Load within must-on range: Commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by cost/MW priority until capacity \u2265 load  \n      - Decommit expensive flexible-on/started units if possible while maintaining capacity feasibility  \n   c) Load below must-on minimum: Commit only must-on (overproduction unavoidable)  \n4. For committed units:  \n   a) Calculate power bounds considering online state/startup constraints  \n   b) Initialize outputs at minimum bounds  \n   c) Distribute residual load using greedy marginal cost-based allocation  \n5. Set uncommitted units to off state with zero output  \n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Calculate must-on capacity\n    must_on_min = must_on_max = 0\n    must_on_min_bounds = {}\n    must_on_max_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_min_bounds[idx] = min_bound\n        must_on_max_bounds[idx] = max_bound\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on)\n    elif load > must_on_max:\n        candidate_set = set(must_on + flexible_on)\n        min_candidate = must_on_min\n        max_candidate = must_on_max\n        \n        # Add flexible-on capacity\n        for idx in flexible_on:\n            unit = units_info[idx]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_candidate += min_bound\n            max_candidate += max_bound\n        \n        # Start flexible-off units if needed\n        if max_candidate < load:\n            priority_list = []\n            for idx in flexible_off:\n                unit = units_info[idx]\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                              unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n                priority_list.append((cost_per_mw, idx))\n            priority_list.sort(key=lambda x: x[0])\n            \n            for _, idx in priority_list:\n                if max_candidate >= load:\n                    break\n                unit = units_info[idx]\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n                max_candidate += max_bound\n                candidate_set.add(idx)\n        \n        # Decommit expensive units if excess capacity\n        non_must_on = [idx for idx in candidate_set if idx not in must_on]\n        if max_candidate > load and non_must_on:\n            min_bounds = {}\n            max_bounds = {}\n            for idx in candidate_set:\n                if idx in must_on:\n                    min_bounds[idx] = must_on_min_bounds.get(idx, units_info[idx]['p_min_i'])\n                    max_bounds[idx] = must_on_max_bounds.get(idx, units_info[idx]['p_max_i'])\n                else:\n                    unit = units_info[idx]\n                    if unit['u_i_0'] == 1:  # flexible-on\n                        min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:  # started unit\n                        min_bounds[idx] = unit['p_min_i']\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            cost_per_mw = {}\n            for idx in non_must_on:\n                unit = units_info[idx]\n                cost_per_mw[idx] = (unit['a_i'] + unit['b_i']*min_bounds[idx] + \n                                   unit['c_i']*(min_bounds[idx]**2)) / min_bounds[idx]\n            \n            sorted_non_must = sorted(non_must_on, key=lambda idx: cost_per_mw[idx], reverse=True)\n            \n            for idx in sorted_non_must:\n                if min_candidate - min_bounds[idx] <= load <= max_candidate - max_bounds[idx]:\n                    candidate_set.remove(idx)\n                    min_candidate -= min_bounds[idx]\n                    max_candidate -= max_bounds[idx]\n                    if max_candidate < load:\n                        candidate_set.add(idx)\n                        min_candidate += min_bounds[idx]\n                        max_candidate += max_bounds[idx]\n                        break\n    else:  # load < must_on_min\n        candidate_set = set(must_on)\n    \n    # Calculate bounds for dispatch\n    min_bounds = {}\n    max_bounds = {}\n    outputs = {}\n    for idx in candidate_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # online in previous period\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # starting in current period\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[idx] = min_b\n        max_bounds[idx] = max_b\n        outputs[idx] = min_b\n    \n    # Economic dispatch\n    total_output = sum(outputs.values())\n    residual = load - total_output\n    \n    if residual > 0:\n        active_units = [idx for idx in candidate_set if outputs[idx] < max_bounds[idx]]\n        while residual > 0 and active_units:\n            min_mc = float('inf')\n            best_unit = None\n            for idx in active_units:\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * outputs[idx]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_unit = idx\n            \n            unit = units_info[best_unit]\n            increment = min(residual, max_bounds[best_unit] - outputs[best_unit])\n            outputs[best_unit] += increment\n            residual -= increment\n            \n            if outputs[best_unit] >= max_bounds[best_unit]:\n                active_units.remove(best_unit)\n    \n    # Generate output schedules\n    for idx in range(num_units):\n        if idx in candidate_set:\n            schedules[0, idx] = 1\n            schedules[1, idx] = outputs.get(idx, 0)\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "refined_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (online and cannot shut down due to minimum up-time or shutdown constraints), must-off (offline and cannot start due to minimum down-time), flexible-on (online and eligible for shutdown), flexible-off (offline and eligible for startup)  \n2. Calculate total minimum/maximum output from must-on units considering ramp constraints  \n3. Case handling:  \n   a) Load within must-on range: Commit only must-on units  \n   b) Load exceeds must-on capacity:  \n      - Form candidate set with must-on + flexible-on units  \n      - Start flexible-off units by cost/MW priority until capacity \u2265 load  \n      - Decommit expensive flexible-on/started units if possible while maintaining capacity feasibility  \n   c) Load below must-on minimum: Commit only must-on (overproduction unavoidable)  \n4. For committed units:  \n   a) Calculate power bounds considering online state/startup constraints  \n   b) Initialize outputs at minimum bounds  \n   c) Distribute residual load using greedy marginal cost-based allocation  \n5. Set uncommitted units to off state with zero output  \n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Calculate must-on capacity\n    must_on_min = must_on_max = 0\n    must_on_min_bounds = {}\n    must_on_max_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_min_bounds[idx] = min_bound\n        must_on_max_bounds[idx] = max_bound\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on)\n    elif load > must_on_max:\n        candidate_set = set(must_on + flexible_on)\n        min_candidate = must_on_min\n        max_candidate = must_on_max\n        \n        # Add flexible-on capacity\n        for idx in flexible_on:\n            unit = units_info[idx]\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            min_candidate += min_bound\n            max_candidate += max_bound\n        \n        # Start flexible-off units if needed\n        if max_candidate < load:\n            priority_list = []\n            for idx in flexible_off:\n                unit = units_info[idx]\n                cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + \n                              unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n                priority_list.append((cost_per_mw, idx))\n            priority_list.sort(key=lambda x: x[0])\n            \n            for _, idx in priority_list:\n                if max_candidate >= load:\n                    break\n                unit = units_info[idx]\n                max_bound = min(unit['p_max_i'], unit['p_start_i'])\n                max_candidate += max_bound\n                candidate_set.add(idx)\n        \n        # Decommit expensive units if excess capacity\n        non_must_on = [idx for idx in candidate_set if idx not in must_on]\n        if max_candidate > load and non_must_on:\n            min_bounds = {}\n            max_bounds = {}\n            for idx in candidate_set:\n                if idx in must_on:\n                    min_bounds[idx] = must_on_min_bounds.get(idx, units_info[idx]['p_min_i'])\n                    max_bounds[idx] = must_on_max_bounds.get(idx, units_info[idx]['p_max_i'])\n                else:\n                    unit = units_info[idx]\n                    if unit['u_i_0'] == 1:  # flexible-on\n                        min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    else:  # started unit\n                        min_bounds[idx] = unit['p_min_i']\n                        max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            cost_per_mw = {}\n            for idx in non_must_on:\n                unit = units_info[idx]\n                cost_per_mw[idx] = (unit['a_i'] + unit['b_i']*min_bounds[idx] + \n                                   unit['c_i']*(min_bounds[idx]**2)) / min_bounds[idx]\n            \n            sorted_non_must = sorted(non_must_on, key=lambda idx: cost_per_mw[idx], reverse=True)\n            \n            for idx in sorted_non_must:\n                if min_candidate - min_bounds[idx] <= load <= max_candidate - max_bounds[idx]:\n                    candidate_set.remove(idx)\n                    min_candidate -= min_bounds[idx]\n                    max_candidate -= max_bounds[idx]\n                    if max_candidate < load:\n                        candidate_set.add(idx)\n                        min_candidate += min_bounds[idx]\n                        max_candidate += max_bounds[idx]\n                        break\n    else:  # load < must_on_min\n        candidate_set = set(must_on)\n    \n    # Calculate bounds for dispatch\n    min_bounds = {}\n    max_bounds = {}\n    outputs = {}\n    for idx in candidate_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # online in previous period\n            min_b = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_b = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # starting in current period\n            min_b = unit['p_min_i']\n            max_b = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[idx] = min_b\n        max_bounds[idx] = max_b\n        outputs[idx] = min_b\n    \n    # Economic dispatch\n    total_output = sum(outputs.values())\n    residual = load - total_output\n    \n    if residual > 0:\n        active_units = [idx for idx in candidate_set if outputs[idx] < max_bounds[idx]]\n        while residual > 0 and active_units:\n            min_mc = float('inf')\n            best_unit = None\n            for idx in active_units:\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * outputs[idx]\n                if mc < min_mc:\n                    min_mc = mc\n                    best_unit = idx\n            \n            unit = units_info[best_unit]\n            increment = min(residual, max_bounds[best_unit] - outputs[best_unit])\n            outputs[best_unit] += increment\n            residual -= increment\n            \n            if outputs[best_unit] >= max_bounds[best_unit]:\n                active_units.remove(best_unit)\n    \n    # Generate output schedules\n    for idx in range(num_units):\n        if idx in candidate_set:\n            schedules[0, idx] = 1\n            schedules[1, idx] = outputs.get(idx, 0)\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "enhanced_adaptive_commitment",
          "algorithm": "1. Classify units into four groups:\n   a) Must-on: Online units that cannot shut down (inadequate min up-time or previous output > shutdown capacity)\n   b) Must-off: Offline units that cannot start (inadequate min down-time)\n   c) Flexible-on: Online units eligible for shutdown (p_i_0 \u2264 p_down_i)\n   d) Flexible-off: Offline units eligible for start (p_min_i \u2264 min(p_max_i, p_start_i))\n2. Form initial candidate set (must-on + flexible-on). Compute system min/max:\n   a) For must-on/flexible-on: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   b) For flexible-off: min = p_min_i, max = min(p_max_i, p_start_i)\n3. Handle load imbalance:\n   a) Case 1 (load > system max): Commit flexible-off units by ascending (startup cost + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i\n   b) Case 2 (load < system min): Decommit flexible-on units by descending min_output\n   c) Case 3 (system min \u2264 load \u2264 system max): Decommit expensive flexible-on units with output safety (new_min \u2264 load \u2264 new_max after decommit)\n4. Enhanced dispatch for committed units:\n   a) Set initial output = unit-specific min\n   b) Compute residual = load - sum(initial outputs)\n   c) Increase outputs on units with lowest marginal cost while respecting max limits\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Unpack unit info into separate arrays for efficiency\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize commitment and output arrays\n    u_i = np.zeros(num_units, dtype=int)\n    p_i = np.zeros(num_units)\n    \n    # Classify units\n    must_on_mask = (u_i_0 == 1) & ((t_i_0 < t_on_min) | (p_i_0 > p_shut))\n    must_off_mask = (u_i_0 == 0) & (-t_i_0 < t_off_min)\n    flexible_on_mask = (u_i_0 == 1) & ~must_on_mask & (p_i_0 <= p_down)\n    flexible_off_mask = (u_i_0 == 0) & ~must_off_mask & (p_min <= np.minimum(p_max, p_start))\n    \n    # Set must-on/must-off states\n    u_i[must_on_mask] = 1\n    u_i[must_off_mask] = 0\n    \n    # Candidate set (must-on + flexible-on initially)\n    candidate_mask = must_on_mask | flexible_on_mask\n    \n    # Compute min/max boundaries for candidates\n    candidate_min = np.zeros(num_units)\n    candidate_max = np.zeros(num_units)\n    \n    # For online candidates\n    online_candidate = must_on_mask | flexible_on_mask\n    candidate_min[online_candidate] = np.maximum(p_min[online_candidate], p_i_0[online_candidate] - p_down[online_candidate])\n    candidate_max[online_candidate] = np.minimum(p_max[online_candidate], p_i_0[online_candidate] + p_up[online_candidate])\n    \n    # For offline flexible units\n    flexible_off_ids = np.where(flexible_off_mask)[0]\n    candidate_min[flexible_off_ids] = p_min[flexible_off_ids]\n    candidate_max[flexible_off_ids] = np.minimum(p_max[flexible_off_ids], p_start[flexible_off_ids])\n    \n    system_min = np.sum(candidate_min[candidate_mask])\n    system_max = np.sum(candidate_max[candidate_mask])\n    \n    # Handle commitment cases\n    if load > system_max and np.any(flexible_off_mask):\n        # Case 1: Underproduction - start flexible-off units\n        avg_costs = (s[flexible_off_ids] + a[flexible_off_ids] + b[flexible_off_ids] * p_min[flexible_off_ids] \n                   + c[flexible_off_ids] * p_min[flexible_off_ids]**2) / p_min[flexible_off_ids]\n        priority_order = np.argsort(avg_costs)\n        for idx in priority_order:\n            unit_id = flexible_off_ids[idx]\n            candidate_mask[unit_id] = True\n            system_min += p_min[unit_id]\n            system_max += np.minimum(p_max[unit_id], p_start[unit_id])\n            if system_max >= load:\n                break\n                \n    elif load < system_min and np.any(flexible_on_mask):\n        # Case 2: Overproduction - decommit flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        min_outputs = candidate_min[flexible_on_ids]\n        priority_order = np.argsort(min_outputs)[::-1]  # Descending min output\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            if load >= system_min:\n                break\n            candidate_mask[unit_id] = False\n            system_min -= min_outputs[np.where(flexible_on_ids == unit_id)[0][0]]\n            system_max -= candidate_max[unit_id]\n            flexible_on_mask[unit_id] = False\n    \n    elif system_min <= load <= system_max and np.any(flexible_on_mask):\n        # Case 3: Within bounds - decommit expensive flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        avg_costs = (a[flexible_on_ids] + b[flexible_on_ids] * p_min[flexible_on_ids] \n                   + c[flexible_on_ids] * p_min[flexible_on_ids]**2) / p_min[flexible_on_ids]\n        priority_order = np.argsort(avg_costs)[::-1]  # Descending cost\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            new_min = system_min - candidate_min[unit_id]\n            new_max = system_max - candidate_max[unit_id]\n            if new_min <= load <= new_max:\n                candidate_mask[unit_id] = False\n                system_min, system_max = new_min, new_max\n    \n    # Update commitment state\n    u_i[candidate_mask] = 1\n    \n    # Economic dispatch for committed units\n    unit_min = np.zeros(num_units)\n    unit_max = np.zeros(num_units)\n    \n    # Set boundaries based on state\n    for i in range(num_units):\n        if candidate_mask[i]:\n            if u_i_0[i] == 1:  # Already online\n                unit_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                unit_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # Started this period\n                unit_min[i] = p_min[i]\n                unit_max[i] = min(p_max[i], p_start[i])\n    \n    # Initialize outputs at min levels\n    p_i[candidate_mask] = unit_min[candidate_mask]\n    residual = load - np.sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5 and np.any(p_i[candidate_mask] < unit_max[candidate_mask]):\n        # Find cheapest available unit\n        marginal_costs = b + 2 * c * p_i\n        marginal_costs[~candidate_mask] = np.inf\n        marginal_costs[p_i >= unit_max] = np.inf\n        \n        if np.all(marginal_costs == np.inf):\n            break\n            \n        cheapest_id = np.argmin(marginal_costs)\n        \n        # Calculate max possible increase\n        headroom = unit_max[cheapest_id] - p_i[cheapest_id]\n        increment = min(residual, headroom)\n        \n        # Update output and residual\n        p_i[cheapest_id] += increment\n        residual -= increment\n    \n    # Set outputs for non-committed units\n    p_i[~candidate_mask] = 0\n    \n    # Format output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056659523,
          "gap_price_rate": 0.0086261957,
          "fitness": 0.007146074
     },
     {
          "name": "enhanced_adaptive_commitment",
          "algorithm": "1. Classify units into four groups:\n   a) Must-on: Online units that cannot shut down (inadequate min up-time or previous output > shutdown capacity)\n   b) Must-off: Offline units that cannot start (inadequate min down-time)\n   c) Flexible-on: Online units eligible for shutdown (p_i_0 \u2264 p_down_i)\n   d) Flexible-off: Offline units eligible for start (p_min_i \u2264 min(p_max_i, p_start_i))\n2. Form initial candidate set (must-on + flexible-on). Compute system min/max:\n   a) For must-on/flexible-on: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   b) For flexible-off: min = p_min_i, max = min(p_max_i, p_start_i)\n3. Handle load imbalance:\n   a) Case 1 (load > system max): Commit flexible-off units by ascending (startup cost + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i\n   b) Case 2 (load < system min): Decommit flexible-on units by descending min_output\n   c) Case 3 (system min \u2264 load \u2264 system max): Decommit expensive flexible-on units with output safety (new_min \u2264 load \u2264 new_max after decommit)\n4. Enhanced dispatch for committed units:\n   a) Set initial output = unit-specific min\n   b) Compute residual = load - sum(initial outputs)\n   c) Increase outputs on units with lowest marginal cost while respecting max limits\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Unpack unit info into separate arrays for efficiency\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize commitment and output arrays\n    u_i = np.zeros(num_units, dtype=int)\n    p_i = np.zeros(num_units)\n    \n    # Classify units\n    must_on_mask = (u_i_0 == 1) & ((t_i_0 < t_on_min) | (p_i_0 > p_shut))\n    must_off_mask = (u_i_0 == 0) & (-t_i_0 < t_off_min)\n    flexible_on_mask = (u_i_0 == 1) & ~must_on_mask & (p_i_0 <= p_down)\n    flexible_off_mask = (u_i_0 == 0) & ~must_off_mask & (p_min <= np.minimum(p_max, p_start))\n    \n    # Set must-on/must-off states\n    u_i[must_on_mask] = 1\n    u_i[must_off_mask] = 0\n    \n    # Candidate set (must-on + flexible-on initially)\n    candidate_mask = must_on_mask | flexible_on_mask\n    \n    # Compute min/max boundaries for candidates\n    candidate_min = np.zeros(num_units)\n    candidate_max = np.zeros(num_units)\n    \n    # For online candidates\n    online_candidate = must_on_mask | flexible_on_mask\n    candidate_min[online_candidate] = np.maximum(p_min[online_candidate], p_i_0[online_candidate] - p_down[online_candidate])\n    candidate_max[online_candidate] = np.minimum(p_max[online_candidate], p_i_0[online_candidate] + p_up[online_candidate])\n    \n    # For offline flexible units\n    flexible_off_ids = np.where(flexible_off_mask)[0]\n    candidate_min[flexible_off_ids] = p_min[flexible_off_ids]\n    candidate_max[flexible_off_ids] = np.minimum(p_max[flexible_off_ids], p_start[flexible_off_ids])\n    \n    system_min = np.sum(candidate_min[candidate_mask])\n    system_max = np.sum(candidate_max[candidate_mask])\n    \n    # Handle commitment cases\n    if load > system_max and np.any(flexible_off_mask):\n        # Case 1: Underproduction - start flexible-off units\n        avg_costs = (s[flexible_off_ids] + a[flexible_off_ids] + b[flexible_off_ids] * p_min[flexible_off_ids] \n                   + c[flexible_off_ids] * p_min[flexible_off_ids]**2) / p_min[flexible_off_ids]\n        priority_order = np.argsort(avg_costs)\n        for idx in priority_order:\n            unit_id = flexible_off_ids[idx]\n            candidate_mask[unit_id] = True\n            system_min += p_min[unit_id]\n            system_max += np.minimum(p_max[unit_id], p_start[unit_id])\n            if system_max >= load:\n                break\n                \n    elif load < system_min and np.any(flexible_on_mask):\n        # Case 2: Overproduction - decommit flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        min_outputs = candidate_min[flexible_on_ids]\n        priority_order = np.argsort(min_outputs)[::-1]  # Descending min output\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            if load >= system_min:\n                break\n            candidate_mask[unit_id] = False\n            system_min -= min_outputs[np.where(flexible_on_ids == unit_id)[0][0]]\n            system_max -= candidate_max[unit_id]\n            flexible_on_mask[unit_id] = False\n    \n    elif system_min <= load <= system_max and np.any(flexible_on_mask):\n        # Case 3: Within bounds - decommit expensive flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        avg_costs = (a[flexible_on_ids] + b[flexible_on_ids] * p_min[flexible_on_ids] \n                   + c[flexible_on_ids] * p_min[flexible_on_ids]**2) / p_min[flexible_on_ids]\n        priority_order = np.argsort(avg_costs)[::-1]  # Descending cost\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            new_min = system_min - candidate_min[unit_id]\n            new_max = system_max - candidate_max[unit_id]\n            if new_min <= load <= new_max:\n                candidate_mask[unit_id] = False\n                system_min, system_max = new_min, new_max\n    \n    # Update commitment state\n    u_i[candidate_mask] = 1\n    \n    # Economic dispatch for committed units\n    unit_min = np.zeros(num_units)\n    unit_max = np.zeros(num_units)\n    \n    # Set boundaries based on state\n    for i in range(num_units):\n        if candidate_mask[i]:\n            if u_i_0[i] == 1:  # Already online\n                unit_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                unit_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # Started this period\n                unit_min[i] = p_min[i]\n                unit_max[i] = min(p_max[i], p_start[i])\n    \n    # Initialize outputs at min levels\n    p_i[candidate_mask] = unit_min[candidate_mask]\n    residual = load - np.sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5 and np.any(p_i[candidate_mask] < unit_max[candidate_mask]):\n        # Find cheapest available unit\n        marginal_costs = b + 2 * c * p_i\n        marginal_costs[~candidate_mask] = np.inf\n        marginal_costs[p_i >= unit_max] = np.inf\n        \n        if np.all(marginal_costs == np.inf):\n            break\n            \n        cheapest_id = np.argmin(marginal_costs)\n        \n        # Calculate max possible increase\n        headroom = unit_max[cheapest_id] - p_i[cheapest_id]\n        increment = min(residual, headroom)\n        \n        # Update output and residual\n        p_i[cheapest_id] += increment\n        residual -= increment\n    \n    # Set outputs for non-committed units\n    p_i[~candidate_mask] = 0\n    \n    # Format output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056659523,
          "gap_price_rate": 0.0086261957,
          "fitness": 0.007146074
     },
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot shut down), must-off (cannot start), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for start) based on minimum up/down times and shutdown ramp constraints\n2. Calculate must-on generation bounds considering ramp constraints\n3. Handle cases:\n   a) If load within must-on bounds: commit only must-on units\n   b) If load exceeds must-on capacity: \n      - Keep flexible-on units and start flexible-off units by cost-effectiveness priority using (startup cost + cost at min output) metric\n      - Iteratively remove expensive flexible-on units if possible without violating capacity constraints\n   c) If load below must-on min: must-on units operate at minimum output\n4. Compute power bounds for committed units considering operational state (online ramp limits or startup limits)\n5. Initialize outputs to lower bounds and distribute residual load using priority queue based on marginal costs\n6. Shut down non-committed units\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    must_on, must_off, flexible_on, flexible_off = [], [], [], []\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Step 2: Compute must-on generation bounds\n    total_must_min, total_must_max = 0.0, 0.0\n    min_bound_must_on = {}\n    max_bound_must_on = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        min_bound_must_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound_must_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_min += min_bound_must_on[i]\n        total_must_max += max_bound_must_on[i]\n    \n    # Initialize candidate set and bounds dictionaries\n    candidate_set = []\n    min_bound_all, max_bound_all = {}, {}\n    \n    # Step 3: Handle cases\n    if total_must_min <= load <= total_must_max:\n        candidate_set = must_on.copy()\n        min_bound_all = min_bound_must_on.copy()\n        max_bound_all = max_bound_must_on.copy()\n        \n    elif load > total_must_max:\n        candidate_set = must_on + flexible_on.copy()\n        min_bound_candidate = min_bound_must_on.copy()\n        max_bound_candidate = max_bound_must_on.copy()\n        \n        # Add bounds for flexible_on units\n        for i in flexible_on:\n            unit = units_info[i]\n            min_bound_candidate[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound_candidate[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n        # Start flexible-off units by cost-effectiveness priority\n        total_min_candidate = sum(min_bound_candidate[i] for i in candidate_set)\n        total_max_candidate = sum(max_bound_candidate[i] for i in candidate_set)\n        \n        remaining_flex_off = flexible_off.copy()\n        remaining_flex_off.sort(\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                           units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                           units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / \n                           units_info[i]['p_min_i'])\n        \n        for i in remaining_flex_off:\n            if total_max_candidate >= load:\n                break\n            candidate_set.append(i)\n            min_i = units_info[i]['p_min_i']\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_bound_candidate[i] = min_i\n            max_bound_candidate[i] = max_i\n            total_min_candidate += min_i\n            total_max_candidate += max_i\n        \n        # Iterative removal of expensive flexible-on units\n        changed = True\n        while changed and flexible_on:\n            changed = False\n            flex_on_in_candidate = [i for i in candidate_set if i in flexible_on]\n            if not flex_on_in_candidate:\n                break\n                \n            flex_on_in_candidate.sort(\n                key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_bound_candidate[i],\n                reverse=True)\n                \n            for i in flex_on_in_candidate:\n                candidate_set_temp = [idx for idx in candidate_set if idx != i]\n                total_min_temp = total_min_candidate - min_bound_candidate[i]\n                total_max_temp = total_max_candidate - max_bound_candidate[i]\n                \n                if total_min_temp <= load <= total_max_temp:\n                    candidate_set = candidate_set_temp\n                    total_min_candidate = total_min_temp\n                    total_max_candidate = total_max_temp\n                    changed = True\n                    break\n        \n        min_bound_all = min_bound_candidate.copy()\n        max_bound_all = max_bound_candidate.copy()\n        \n    else:  # Load below must_on_min\n        candidate_set = must_on.copy()\n        min_bound_all = min_bound_must_on.copy()\n        max_bound_all = max_bound_must_on.copy()\n    \n    # Step 4/5: Initialize outputs and dispatch residual load\n    u_commit = [0] * n_units\n    p_outputs = [0.0] * n_units\n    \n    for i in candidate_set:\n        u_commit[i] = 1\n        p_outputs[i] = min_bound_all[i]\n    \n    total_initial = sum(p_outputs)\n    residual = load - total_initial\n    \n    # Priority queue dispatch for positive residual\n    if residual > 1e-5:\n        heap = []\n        for i in candidate_set:\n            if p_outputs[i] < max_bound_all[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i]\n                heapq.heappush(heap, (mc, i, p_outputs[i]))\n        \n        while residual > 1e-5 and heap:\n            mc, i, current = heapq.heappop(heap)\n            max_add = min(\n                residual, \n                max_bound_all[i] - current\n            )\n            p_outputs[i] += max_add\n            residual -= max_add\n            \n            if p_outputs[i] < max_bound_all[i]:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i]\n                heapq.heappush(heap, (new_mc, i, p_outputs[i]))\n    \n    # Step 6: Return final schedules\n    schedules = np.array([u_commit, p_outputs])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0057279727,
          "gap_price_rate": 0.0088768178,
          "fitness": 0.0073023953
     },
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot shut down), must-off (cannot start), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for start) based on minimum up/down times and shutdown ramp constraints\n2. Calculate must-on generation bounds considering ramp constraints\n3. Handle cases:\n   a) If load within must-on bounds: commit only must-on units\n   b) If load exceeds must-on capacity: \n      - Keep flexible-on units and start flexible-off units by cost-effectiveness priority using (startup cost + cost at min output) metric\n      - Iteratively remove expensive flexible-on units if possible without violating capacity constraints\n   c) If load below must-on min: must-on units operate at minimum output\n4. Compute power bounds for committed units considering operational state (online ramp limits or startup limits)\n5. Initialize outputs to lower bounds and distribute residual load using priority queue based on marginal costs\n6. Shut down non-committed units\n",
          "code": "import numpy as np\nimport heapq\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    must_on, must_off, flexible_on, flexible_off = [], [], [], []\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible_on.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible_off.append(i)\n    \n    # Step 2: Compute must-on generation bounds\n    total_must_min, total_must_max = 0.0, 0.0\n    min_bound_must_on = {}\n    max_bound_must_on = {}\n    \n    for i in must_on:\n        unit = units_info[i]\n        min_bound_must_on[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound_must_on[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_min += min_bound_must_on[i]\n        total_must_max += max_bound_must_on[i]\n    \n    # Initialize candidate set and bounds dictionaries\n    candidate_set = []\n    min_bound_all, max_bound_all = {}, {}\n    \n    # Step 3: Handle cases\n    if total_must_min <= load <= total_must_max:\n        candidate_set = must_on.copy()\n        min_bound_all = min_bound_must_on.copy()\n        max_bound_all = max_bound_must_on.copy()\n        \n    elif load > total_must_max:\n        candidate_set = must_on + flexible_on.copy()\n        min_bound_candidate = min_bound_must_on.copy()\n        max_bound_candidate = max_bound_must_on.copy()\n        \n        # Add bounds for flexible_on units\n        for i in flexible_on:\n            unit = units_info[i]\n            min_bound_candidate[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound_candidate[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n        # Start flexible-off units by cost-effectiveness priority\n        total_min_candidate = sum(min_bound_candidate[i] for i in candidate_set)\n        total_max_candidate = sum(max_bound_candidate[i] for i in candidate_set)\n        \n        remaining_flex_off = flexible_off.copy()\n        remaining_flex_off.sort(\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                           units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                           units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / \n                           units_info[i]['p_min_i'])\n        \n        for i in remaining_flex_off:\n            if total_max_candidate >= load:\n                break\n            candidate_set.append(i)\n            min_i = units_info[i]['p_min_i']\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_bound_candidate[i] = min_i\n            max_bound_candidate[i] = max_i\n            total_min_candidate += min_i\n            total_max_candidate += max_i\n        \n        # Iterative removal of expensive flexible-on units\n        changed = True\n        while changed and flexible_on:\n            changed = False\n            flex_on_in_candidate = [i for i in candidate_set if i in flexible_on]\n            if not flex_on_in_candidate:\n                break\n                \n            flex_on_in_candidate.sort(\n                key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_bound_candidate[i],\n                reverse=True)\n                \n            for i in flex_on_in_candidate:\n                candidate_set_temp = [idx for idx in candidate_set if idx != i]\n                total_min_temp = total_min_candidate - min_bound_candidate[i]\n                total_max_temp = total_max_candidate - max_bound_candidate[i]\n                \n                if total_min_temp <= load <= total_max_temp:\n                    candidate_set = candidate_set_temp\n                    total_min_candidate = total_min_temp\n                    total_max_candidate = total_max_temp\n                    changed = True\n                    break\n        \n        min_bound_all = min_bound_candidate.copy()\n        max_bound_all = max_bound_candidate.copy()\n        \n    else:  # Load below must_on_min\n        candidate_set = must_on.copy()\n        min_bound_all = min_bound_must_on.copy()\n        max_bound_all = max_bound_must_on.copy()\n    \n    # Step 4/5: Initialize outputs and dispatch residual load\n    u_commit = [0] * n_units\n    p_outputs = [0.0] * n_units\n    \n    for i in candidate_set:\n        u_commit[i] = 1\n        p_outputs[i] = min_bound_all[i]\n    \n    total_initial = sum(p_outputs)\n    residual = load - total_initial\n    \n    # Priority queue dispatch for positive residual\n    if residual > 1e-5:\n        heap = []\n        for i in candidate_set:\n            if p_outputs[i] < max_bound_all[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i]\n                heapq.heappush(heap, (mc, i, p_outputs[i]))\n        \n        while residual > 1e-5 and heap:\n            mc, i, current = heapq.heappop(heap)\n            max_add = min(\n                residual, \n                max_bound_all[i] - current\n            )\n            p_outputs[i] += max_add\n            residual -= max_add\n            \n            if p_outputs[i] < max_bound_all[i]:\n                new_mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_outputs[i]\n                heapq.heappush(heap, (new_mc, i, p_outputs[i]))\n    \n    # Step 6: Return final schedules\n    schedules = np.array([u_commit, p_outputs])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0057279727,
          "gap_price_rate": 0.0088768178,
          "fitness": 0.0073023953
     }
]