[
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into four sets: must-on (units that were online and haven't satisfied min up-time or exceed shutdown capacity), must-off (units that were offline and haven't satisfied min down-time), flexible-on (online units not in must-on/must-off), and flexible-off (offline units not in must-on/must-off)\n2. Compute must-on min/max outputs considering ramp constraints\n3. Handle three cases:\n   a) Load between must-on min/max: Commit only must-on units\n   b) Load exceeds must-on max: Keep flexible-on units, start flexible-off units by cost-per-MW priority until capacity >= load, then optionally turn off expensive non-must-on units if excess capacity exists\n   c) Load below must-on min: Overproduction unavoidable; set must-on to min outputs\n4. For committed units:\n   a) Calculate power bounds (considering online/startup constraints)\n   b) Initialize outputs at minimum bounds\n   c) Distribute residual load using marginal cost-based greedy allocation\n5. Turn off non-committed units\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_array = np.zeros(n_units)\n    p_array = np.zeros(n_units)\n    \n    must_on = []       # Must remain on\n    must_off = []      # Must remain off\n    flexible_on = []    # Online and flexible\n    flexible_off = []   # Offline and flexible\n    committed = []      # Final committed units\n\n    # Step 1: Classify units\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        shut_ramp = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > shut_ramp:\n                must_on.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:\n            if -t0 < min_down:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Step 2: Calculate must-on bounds\n    must_on_min = 0\n    must_on_max = 0\n    must_on_bounds = {}\n    for idx in must_on:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        min_bound = max(p_min, p0 - ramp_down)\n        max_bound = min(p_max, p0 + ramp_up)\n        must_on_min += min_bound\n        must_on_max += max_bound\n        must_on_bounds[idx] = (min_bound, max_bound)\n        committed.append(idx)\n        u_array[idx] = 1\n    \n    # Step 3: Case handling\n    if must_on_min <= load <= must_on_max:\n        # Case 1: Load within must-on bounds (turn off all flexible)\n        pass\n    elif load > must_on_max:\n        # Case 2: Need additional capacity\n        # Keep flexible-on units\n        flex_on_min = 0\n        flex_on_max = 0\n        flex_on_bounds = {}\n        for idx in flexible_on:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p0 = unit['p_i_0']\n            ramp_down = unit['p_down_i']\n            ramp_up = unit['p_up_i']\n            \n            min_bound = max(p_min, p0 - ramp_down)\n            max_bound = min(p_max, p0 + ramp_up)\n            flex_on_min += min_bound\n            flex_on_max += max_bound\n            flex_on_bounds[idx] = (min_bound, max_bound)\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        current_max = must_on_max + flex_on_max\n        \n        # Start flexible-off units until meeting capacity\n        candidates = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            startup_cost = unit['s_i']\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            \n            max_bound = min(p_max, start_ramp)\n            min_bound = p_min\n            cost_at_min = a + b*p_min + c*p_min**2\n            cost_per_mw = (startup_cost + cost_at_min) / p_min\n            candidates.append((idx, min_bound, max_bound, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[3])\n        started_units = []\n        for idx, min_bound, max_bound, _ in candidates:\n            if current_max >= load:\n                break\n            current_max += max_bound\n            started_units.append((idx, min_bound, max_bound))\n            committed.append(idx)\n            u_array[idx] = 1\n        \n        # Attempt to turn off expensive non-must-on units\n        non_must_on = flexible_on.copy() + [idx for idx, _, _ in started_units]\n        if len(non_must_on) > 0 and current_max > load:\n            cost_list = []\n            for idx in non_must_on:\n                unit = units_info[idx]\n                a = unit['a_i']\n                b = unit['b_i']\n                c = unit['c_i']\n                p_min = unit['p_min_i'] if idx in flexible_off else flex_on_bounds.get(idx, (0,0))[0]\n                marginal_cost = b + 2*c*p_min\n                cost_list.append((idx, marginal_cost))\n            \n            cost_list.sort(key=lambda x: x[1], reverse=True)\n            for idx, _ in cost_list:\n                unit_max = flex_on_bounds.get(idx, (0,0))[1] if idx in flexible_on else min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n                if current_max - unit_max >= load:\n                    current_max -= unit_max\n                    committed.remove(idx)\n                    u_array[idx] = 0\n                    non_must_on.remove(idx)\n    else:\n        # Case 3: Overproduction unavoidable\n        pass\n    \n    # Step 4: Economic dispatch for committed units\n    bounds = {}\n    dispatch_list = []\n    for idx in committed:\n        unit = units_info[idx]\n        if idx in must_on:\n            min_bound, max_bound = must_on_bounds[idx]\n        elif idx in flexible_on:\n            min_bound, max_bound = flex_on_bounds.get(idx, (unit['p_min_i'], unit['p_max_i']))\n        else:  # Started flexible-off\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            start_ramp = unit['p_start_i']\n            min_bound = p_min\n            max_bound = min(p_max, start_ramp)\n        \n        bounds[idx] = (min_bound, max_bound)\n        p_array[idx] = min_bound\n        # Store unit cost coefficients\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        dispatch_list.append((idx, b, c, min_bound, max_bound))\n    \n    total_min = sum(bounds[idx][0] for idx in committed)\n    residual = load - total_min\n    \n    # Dispatch residual load\n    if residual > 0:\n        # Calculate available headroom per unit\n        headroom = {idx: bounds[idx][1] - p_array[idx] for idx in committed}\n        # Distribute residual using greedy merit-order dispatch\n        while residual > 1e-5 and any(headroom.values()):\n            best_idx = None\n            best_mc = float('inf')\n            for idx in committed:\n                if headroom[idx] <= 0:\n                    continue\n                mc = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_array[idx]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n                \n            increment = min(residual, headroom[best_idx])\n            p_array[best_idx] += increment\n            residual -= increment\n            headroom[best_idx] -= increment\n    \n    # Step 5: Ensure must-off units are off\n    for idx in must_off:\n        u_array[idx] = 0\n        p_array[idx] = 0\n    # Ensure non-committed flexible units are off\n    for idx in flexible_on + flexible_off:\n        if idx not in committed:\n            u_array[idx] = 0\n            p_array[idx] = 0\n    \n    schedules = np.array([u_array, p_array])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051745349,
          "gap_price_rate": 0.0084617748,
          "fitness": 0.0068181548
     },
     {
          "name": "enhanced_adaptive_commitment",
          "algorithm": "1. Classify units into four groups:\n   a) Must-on: Online units that cannot shut down (inadequate min up-time or previous output > shutdown capacity)\n   b) Must-off: Offline units that cannot start (inadequate min down-time)\n   c) Flexible-on: Online units eligible for shutdown (p_i_0 \u2264 p_down_i)\n   d) Flexible-off: Offline units eligible for start (p_min_i \u2264 min(p_max_i, p_start_i))\n2. Form initial candidate set (must-on + flexible-on). Compute system min/max:\n   a) For must-on/flexible-on: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   b) For flexible-off: min = p_min_i, max = min(p_max_i, p_start_i)\n3. Handle load imbalance:\n   a) Case 1 (load > system max): Commit flexible-off units by ascending (startup cost + a_i + b_i\u00b7p_min_i + c_i\u00b7p_min_i\u00b2)/p_min_i\n   b) Case 2 (load < system min): Decommit flexible-on units by descending min_output\n   c) Case 3 (system min \u2264 load \u2264 system max): Decommit expensive flexible-on units with output safety (new_min \u2264 load \u2264 new_max after decommit)\n4. Enhanced dispatch for committed units:\n   a) Set initial output = unit-specific min\n   b) Compute residual = load - sum(initial outputs)\n   c) Increase outputs on units with lowest marginal cost while respecting max limits\n5. Set uncommitted units to off-state\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Unpack unit info into separate arrays for efficiency\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Initialize commitment and output arrays\n    u_i = np.zeros(num_units, dtype=int)\n    p_i = np.zeros(num_units)\n    \n    # Classify units\n    must_on_mask = (u_i_0 == 1) & ((t_i_0 < t_on_min) | (p_i_0 > p_shut))\n    must_off_mask = (u_i_0 == 0) & (-t_i_0 < t_off_min)\n    flexible_on_mask = (u_i_0 == 1) & ~must_on_mask & (p_i_0 <= p_down)\n    flexible_off_mask = (u_i_0 == 0) & ~must_off_mask & (p_min <= np.minimum(p_max, p_start))\n    \n    # Set must-on/must-off states\n    u_i[must_on_mask] = 1\n    u_i[must_off_mask] = 0\n    \n    # Candidate set (must-on + flexible-on initially)\n    candidate_mask = must_on_mask | flexible_on_mask\n    \n    # Compute min/max boundaries for candidates\n    candidate_min = np.zeros(num_units)\n    candidate_max = np.zeros(num_units)\n    \n    # For online candidates\n    online_candidate = must_on_mask | flexible_on_mask\n    candidate_min[online_candidate] = np.maximum(p_min[online_candidate], p_i_0[online_candidate] - p_down[online_candidate])\n    candidate_max[online_candidate] = np.minimum(p_max[online_candidate], p_i_0[online_candidate] + p_up[online_candidate])\n    \n    # For offline flexible units\n    flexible_off_ids = np.where(flexible_off_mask)[0]\n    candidate_min[flexible_off_ids] = p_min[flexible_off_ids]\n    candidate_max[flexible_off_ids] = np.minimum(p_max[flexible_off_ids], p_start[flexible_off_ids])\n    \n    system_min = np.sum(candidate_min[candidate_mask])\n    system_max = np.sum(candidate_max[candidate_mask])\n    \n    # Handle commitment cases\n    if load > system_max and np.any(flexible_off_mask):\n        # Case 1: Underproduction - start flexible-off units\n        avg_costs = (s[flexible_off_ids] + a[flexible_off_ids] + b[flexible_off_ids] * p_min[flexible_off_ids] \n                   + c[flexible_off_ids] * p_min[flexible_off_ids]**2) / p_min[flexible_off_ids]\n        priority_order = np.argsort(avg_costs)\n        for idx in priority_order:\n            unit_id = flexible_off_ids[idx]\n            candidate_mask[unit_id] = True\n            system_min += p_min[unit_id]\n            system_max += np.minimum(p_max[unit_id], p_start[unit_id])\n            if system_max >= load:\n                break\n                \n    elif load < system_min and np.any(flexible_on_mask):\n        # Case 2: Overproduction - decommit flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        min_outputs = candidate_min[flexible_on_ids]\n        priority_order = np.argsort(min_outputs)[::-1]  # Descending min output\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            if load >= system_min:\n                break\n            candidate_mask[unit_id] = False\n            system_min -= min_outputs[np.where(flexible_on_ids == unit_id)[0][0]]\n            system_max -= candidate_max[unit_id]\n            flexible_on_mask[unit_id] = False\n    \n    elif system_min <= load <= system_max and np.any(flexible_on_mask):\n        # Case 3: Within bounds - decommit expensive flexible-on units\n        flexible_on_ids = np.where(flexible_on_mask)[0]\n        avg_costs = (a[flexible_on_ids] + b[flexible_on_ids] * p_min[flexible_on_ids] \n                   + c[flexible_on_ids] * p_min[flexible_on_ids]**2) / p_min[flexible_on_ids]\n        priority_order = np.argsort(avg_costs)[::-1]  # Descending cost\n        \n        for unit_id in flexible_on_ids[priority_order]:\n            new_min = system_min - candidate_min[unit_id]\n            new_max = system_max - candidate_max[unit_id]\n            if new_min <= load <= new_max:\n                candidate_mask[unit_id] = False\n                system_min, system_max = new_min, new_max\n    \n    # Update commitment state\n    u_i[candidate_mask] = 1\n    \n    # Economic dispatch for committed units\n    unit_min = np.zeros(num_units)\n    unit_max = np.zeros(num_units)\n    \n    # Set boundaries based on state\n    for i in range(num_units):\n        if candidate_mask[i]:\n            if u_i_0[i] == 1:  # Already online\n                unit_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                unit_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # Started this period\n                unit_min[i] = p_min[i]\n                unit_max[i] = min(p_max[i], p_start[i])\n    \n    # Initialize outputs at min levels\n    p_i[candidate_mask] = unit_min[candidate_mask]\n    residual = load - np.sum(p_i)\n    \n    # Distribute residual load\n    while residual > 1e-5 and np.any(p_i[candidate_mask] < unit_max[candidate_mask]):\n        # Find cheapest available unit\n        marginal_costs = b + 2 * c * p_i\n        marginal_costs[~candidate_mask] = np.inf\n        marginal_costs[p_i >= unit_max] = np.inf\n        \n        if np.all(marginal_costs == np.inf):\n            break\n            \n        cheapest_id = np.argmin(marginal_costs)\n        \n        # Calculate max possible increase\n        headroom = unit_max[cheapest_id] - p_i[cheapest_id]\n        increment = min(residual, headroom)\n        \n        # Update output and residual\n        p_i[cheapest_id] += increment\n        residual -= increment\n    \n    # Set outputs for non-committed units\n    p_i[~candidate_mask] = 0\n    \n    # Format output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056659523,
          "gap_price_rate": 0.0086261957,
          "fitness": 0.007146074
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and flexible (both online/offline)\n2. For must-on units, compute min/max output bounds based on current state and ramp constraints\n3. Handle three cases:\n   - Case 1 (load between must-on min/max): Keep only must-on units, turn off flexible units\n   - Case 2 (load > must-on max): Keep online flexible units, start additional offline units based on cost-effectiveness until load can be met\n   - Case 3 (load < must-on min): Must-on units at minimum, turn off all flexible units\n4. Economic dispatch for all online units:\n   a. Start at min output bounds\n   b. Sort units by increasing marginal cost\n   c. Increase output of cheapest units until load met or capacity exhausted\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    \n    # Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flex_online_indices = []\n    flex_offline_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flex_online_indices.append(i)\n        else:\n            t_off_abs = abs(unit['t_i_0'])\n            if t_off_abs < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flex_offline_indices.append(i)\n    \n    # Set must-off units to off\n    for i in must_off_indices:\n        u[i] = 0\n        p[i] = 0\n    \n    # Compute bounds for must-on units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_on_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        total_min_must += min_bound\n        total_max_must += max_bound\n        u[i] = 1\n    \n    # Initialize online set with must-on units\n    online_set = set(must_on_indices)\n    \n    if total_min_must <= load <= total_max_must:\n        # Case 1: Only must-on units needed\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    elif load > total_max_must:\n        # Case 2: Need additional units\n        current_capacity = total_max_must\n        deficit = load - total_max_must\n        \n        # Keep flexible online units\n        for i in flex_online_indices:\n            u[i] = 1\n            min_b = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_b = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            min_bounds[i] = min_b\n            max_bounds[i] = max_b\n            current_capacity += max_b\n            online_set.add(i)\n        \n        # Calculate remaining deficit\n        deficit = max(0, load - current_capacity)\n        started_units = []\n        \n        if deficit > 0:\n            # Sort offline flex by cost per MW at min output\n            cost_per_mw = []\n            for i in flex_offline_indices:\n                unit = units_info[i]\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n                cost_per_mw.append(cost / unit['p_min_i'])\n            sorted_indices = [i for _, i in sorted(zip(cost_per_mw, flex_offline_indices))]\n            \n            # Start most economical units first\n            for i in sorted_indices:\n                if deficit <= 0:\n                    break\n                u[i] = 1\n                min_bounds[i] = units_info[i]['p_min_i']\n                max_b = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                max_bounds[i] = max_b\n                online_set.add(i)\n                started_units.append(i)\n                current_capacity += max_b\n                deficit = load - current_capacity\n    \n    else:\n        # Case 3: Load < must-on minimum\n        for i in must_on_indices:\n            p[i] = min_bounds[i]\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    # Economic dispatch for online units\n    online_indices = sorted(online_set)\n    params = [(units_info[i]['b_i'], units_info[i]['c_i'], min_bounds[i], max_bounds[i]) for i in online_indices]\n    b, c, mins, maxs = zip(*params)\n    b = np.array(b)\n    c = np.array(c)\n    mins = np.array(mins)\n    maxs = np.array(maxs)\n    \n    # Start from min outputs\n    p_online = np.array(mins)\n    total_output = np.sum(p_online)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        # Sort by increasing marginal cost\n        marginal_costs = 2 * c * p_online + b\n        order = np.argsort(marginal_costs)\n        headroom = maxs - mins\n        \n        # Allocate deficit\n        for i in order:\n            alloc = min(deficit, headroom[i])\n            p_online[i] += alloc\n            deficit -= alloc\n            if deficit <= 0:\n                break\n    \n    # Update outputs\n    for idx, val in enumerate(online_indices):\n        p[val] = p_online[idx]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0048571187,
          "gap_price_rate": 0.0100041649,
          "fitness": 0.0074306418
     },
     {
          "name": "refined_enhanced_rolling_uc",
          "algorithm": "1. Classify units into must-on (if online and hasn't satisfied min up-time or previous output exceeds shutdown capacity), must-off (if offline and hasn't satisfied min down-time), flexible-on (online not in must-on/must-off), flexible-off (offline not in must-on/must-off)  \n2. Compute base min/max outputs from must-on considering ramp constraints  \n3. Handle three cases:  \n   a. Case 1: load between base min/max \u2192 commit only must-on  \n   b. Case 2: load > base max \u2192 commit flexible-on, then start flexible-off by ascending (startup_cost + fixed_cost + cost_at_min)/min_output priority until capacity >= load  \n   c. Case 3: load < base min \u2192 commit only must-on (overproduction unavoidable)  \n4. If Case 2: attempt to decommit expensive flexible-on units (meeting shutdown constraint) if excess capacity remains  \n5. For committed units:  \n   a. Calculate min/max bounds (considering online/startup constraints)  \n   b. Initialize outputs to min bounds  \n   c. Distribute residual load using greedy marginal cost allocation  \n6. Set non-committed units to off state  \n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_rolling_uc(units_info, load):\n    # Initialize all to off\n    for unit in units_info:\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n\n    # Classify units\n    must_on, must_off, flexible_on, flexible_off = [], [], [], []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(unit)\n            else:\n                flexible_on.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible_off.append(unit)\n\n    # Compute base min/max from must_on\n    base_min, base_max = 0.0, 0.0\n    for unit in must_on:\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        base_min += min_output\n        base_max += max_output\n\n    # Case handling\n    candidate_commit = must_on[:]  # copy\n    if base_min <= load <= base_max:\n        pass  # Case 1: candidate_commit = must_on\n    elif load > base_max:\n        # Case 2: start with must_on + flexible_on\n        candidate_commit = must_on + flexible_on\n        total_max = base_max\n        for unit in flexible_on:\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_max += max_output\n\n        # Start flexible_off by cost-per-MW priority\n        sorted_flex_off = sorted(\n            flexible_off,\n            key=lambda u: (u['s_i'] + u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * (u['p_min_i'] ** 2)) / u['p_min_i']\n        )\n        for unit in sorted_flex_off:\n            if total_max >= load:\n                break\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n            candidate_commit.append(unit)\n            total_max += max_output\n\n        # Decommit expensive flexible_on if excess capacity exists\n        candidate_flex_on = [u for u in candidate_commit if (u in flexible_on) and (u['p_i_0'] <= u['p_shut_i'])]\n        candidate_flex_on.sort(\n            key=lambda u: u['a_i'] + u['b_i'] * u['p_min_i'] + u['c_i'] * (u['p_min_i'] ** 2),\n            reverse=True\n        )\n        for unit in candidate_flex_on:\n            current_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if total_max - current_max >= load:\n                candidate_commit.remove(unit)\n                total_max -= current_max\n    else:  # Case 3: load < base_min\n        candidate_commit = must_on\n\n    # Dispatch for committed units\n    for unit in candidate_commit:\n        if unit['u_i_0'] == 1:\n            min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_output = unit['p_min_i']\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n        unit['p_i'] = min_output\n        unit['min_output'] = min_output\n        unit['max_output'] = max_output\n\n    total_output = sum(unit['p_i'] for unit in candidate_commit)\n    residual = load - total_output\n\n    # Allocate residual load\n    if residual > 0:\n        while residual > 1e-8:\n            best_unit = None\n            min_marginal = float('inf')\n            for unit in candidate_commit:\n                if unit['p_i'] < unit['max_output']:\n                    marginal = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                    if marginal < min_marginal:\n                        min_marginal = marginal\n                        best_unit = unit\n            if best_unit is None:\n                break\n            increment = min(residual, best_unit['max_output'] - best_unit['p_i'])\n            best_unit['p_i'] += increment\n            residual -= increment\n\n    # Set u_i for committed units\n    for unit in candidate_commit:\n        unit['u_i'] = 1\n\n    # Prepare output\n    u_array = [unit['u_i'] for unit in units_info]\n    p_array = [unit['p_i'] for unit in units_info]\n    schedules = np.array([u_array, p_array])\n\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0097674236,
          "fitness": 0.0077241541
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Identify must-on units (if unit was online and hasn't satisfied min up-time or previous output exceeds shutdown capacity) and must-off units (if unit was offline and hasn't satisfied min down-time)\n2. Classify remaining units as optional_offline (online units that can be turned off) and optional_online (offline units that can be turned on)\n3. Compute base min/max output from must-on units considering ramp constraints\n4. Handle three cases:\n   a. Case 1 (load between base min/max): Use only must-on units\n   b. Case 2 (load > base max): Add optional_offline units then start optional_online units by average cost priority until max capacity >= load\n   c. Case 3 (load < base min): Use only must-on units (overproduction unavoidable)\n5. Attempt to turn off expensive optional_offline units in Case 2 if excess capacity exists\n6. For committed units:\n   a. Calculate power bounds considering current state and ramp constraints\n   b. Initialize outputs to minimum bounds\n   c. Distribute residual load to units with lowest marginal cost\n7. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    must_on = []\n    must_off = []\n    optional_offline = []\n    optional_online = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                optional_offline.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                optional_online.append(idx)\n                \n    base_min = 0.0\n    base_max = 0.0\n    committed_set = set(must_on)\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min += min_i\n            base_max += max_i\n            \n    if base_min <= load <= base_max:\n        pass  # Case 1: No change to committed_set\n    elif load > base_max:\n        base_min2 = base_min\n        base_max2 = base_max\n        for idx in optional_offline:\n            unit = units_info[idx]\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min2 += min_i\n            base_max2 += max_i\n            committed_set.add(idx)\n            \n        if load > base_max2:\n            sorted_opt_online = sorted(\n                optional_online,\n                key=lambda idx: (units_info[idx]['a_i'] + \n                              units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                              units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2) + \n                              units_info[idx]['s_i']) / units_info[idx]['p_min_i']\n            )\n            for idx in sorted_opt_online:\n                unit = units_info[idx]\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n                if base_max2 + max_i >= load:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    break\n                else:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    \n        temp_set = committed_set.copy()\n        sorted_opt_offline = sorted(\n            [idx for idx in optional_offline if idx in committed_set],\n            key=lambda idx: (units_info[idx]['a_i'] + \n                           units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                           units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2)) / \n                           units_info[idx]['p_min_i'],\n            reverse=True\n        )\n        current_max = base_max2\n        for idx in sorted_opt_offline:\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if current_max - max_i >= load:\n                committed_set.discard(idx)\n                current_max -= max_i\n    else:\n        pass  # Case 3: Overproduction unavoidable with must-on units\n        \n    min_limits = {}\n    max_limits = {}\n    for idx in committed_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_limits[idx] = min_i\n        max_limits[idx] = max_i\n        p_list[idx] = min_i\n        u_list[idx] = 1\n        \n    total_p = sum(p_list)\n    residual = load - total_p\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed_set:\n            if p_list[idx] < max_limits[idx]:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_list[idx]\n                candidates.append((marginal_cost, idx, max_limits[idx]))\n                \n        while residual > 0 and candidates:\n            candidates_sorted = sorted(candidates, key=lambda x: x[0])\n            best_mc, best_idx, best_max = candidates_sorted[0]\n            headroom = best_max - p_list[best_idx]\n            if headroom <= 0:\n                candidates.remove(candidates_sorted[0])\n                continue\n                \n            if headroom > residual:\n                p_list[best_idx] += residual\n                residual = 0\n            else:\n                p_list[best_idx] += headroom\n                residual -= headroom\n                candidates.remove(candidates_sorted[0])\n    \n    for idx in range(n_units):\n        if idx not in committed_set:\n            u_list[idx] = 0\n            p_list[idx] = 0.0\n            \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "enhanced_rolling_uc_heuristic",
          "algorithm": "1. Identify must-on units (if unit was online and hasn't satisfied min up-time or previous output exceeds shutdown capacity) and must-off units (if unit was offline and hasn't satisfied min down-time)\n2. Classify remaining units as optional_offline (online units that can be turned off) and optional_online (offline units that can be turned on)\n3. Compute base min/max output from must-on units considering ramp constraints\n4. Handle three cases:\n   a. Case 1 (load between base min/max): Use only must-on units\n   b. Case 2 (load > base max): Add optional_offline units then start optional_online units by average cost priority until max capacity >= load\n   c. Case 3 (load < base min): Use only must-on units (overproduction unavoidable)\n5. Attempt to turn off expensive optional_offline units in Case 2 if excess capacity exists\n6. For committed units:\n   a. Calculate power bounds considering current state and ramp constraints\n   b. Initialize outputs to minimum bounds\n   c. Distribute residual load to units with lowest marginal cost\n7. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    must_on = []\n    must_off = []\n    optional_offline = []\n    optional_online = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n            else:\n                optional_offline.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                optional_online.append(idx)\n                \n    base_min = 0.0\n    base_max = 0.0\n    committed_set = set(must_on)\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min += min_i\n            base_max += max_i\n            \n    if base_min <= load <= base_max:\n        pass  # Case 1: No change to committed_set\n    elif load > base_max:\n        base_min2 = base_min\n        base_max2 = base_max\n        for idx in optional_offline:\n            unit = units_info[idx]\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            base_min2 += min_i\n            base_max2 += max_i\n            committed_set.add(idx)\n            \n        if load > base_max2:\n            sorted_opt_online = sorted(\n                optional_online,\n                key=lambda idx: (units_info[idx]['a_i'] + \n                              units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                              units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2) + \n                              units_info[idx]['s_i']) / units_info[idx]['p_min_i']\n            )\n            for idx in sorted_opt_online:\n                unit = units_info[idx]\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n                if base_max2 + max_i >= load:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    break\n                else:\n                    committed_set.add(idx)\n                    base_max2 += max_i\n                    \n        temp_set = committed_set.copy()\n        sorted_opt_offline = sorted(\n            [idx for idx in optional_offline if idx in committed_set],\n            key=lambda idx: (units_info[idx]['a_i'] + \n                           units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n                           units_info[idx]['c_i'] * (units_info[idx]['p_min_i']**2)) / \n                           units_info[idx]['p_min_i'],\n            reverse=True\n        )\n        current_max = base_max2\n        for idx in sorted_opt_offline:\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if current_max - max_i >= load:\n                committed_set.discard(idx)\n                current_max -= max_i\n    else:\n        pass  # Case 3: Overproduction unavoidable with must-on units\n        \n    min_limits = {}\n    max_limits = {}\n    for idx in committed_set:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_limits[idx] = min_i\n        max_limits[idx] = max_i\n        p_list[idx] = min_i\n        u_list[idx] = 1\n        \n    total_p = sum(p_list)\n    residual = load - total_p\n    \n    if residual > 0:\n        candidates = []\n        for idx in committed_set:\n            if p_list[idx] < max_limits[idx]:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p_list[idx]\n                candidates.append((marginal_cost, idx, max_limits[idx]))\n                \n        while residual > 0 and candidates:\n            candidates_sorted = sorted(candidates, key=lambda x: x[0])\n            best_mc, best_idx, best_max = candidates_sorted[0]\n            headroom = best_max - p_list[best_idx]\n            if headroom <= 0:\n                candidates.remove(candidates_sorted[0])\n                continue\n                \n            if headroom > residual:\n                p_list[best_idx] += residual\n                residual = 0\n            else:\n                p_list[best_idx] += headroom\n                residual -= headroom\n                candidates.remove(candidates_sorted[0])\n    \n    for idx in range(n_units):\n        if idx not in committed_set:\n            u_list[idx] = 0\n            p_list[idx] = 0.0\n            \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0056808845,
          "gap_price_rate": 0.0099892924,
          "fitness": 0.0078350884
     },
     {
          "name": "hybrid_rolling_commitment",
          "algorithm": "1. Classify units into must-on (cannot shut down), must-off (cannot start), flexible-on (online units eligible for shutdown), and flexible-off (offline units eligible for start) based on minimum up/down times and shutdown ramp constraints\n2. Calculate must-on generation bounds considering ramp constraints\n3. Handle cases:\n   a) If load within must-on bounds: commit only must-on units\n   b) If load exceeds must-on capacity: commit flexible-on units and start flexible-off units by cost-effectiveness priority\n   c) If load below must-on min: must-on units operate at minimum output\n4. For case 2: remove expensive flexible-on units if possible without causing capacity shortage\n5. Compute power bounds for committed units based on operational state\n6. Initialize outputs to lower bounds then distribute residual load using marginal cost-based allocation\n7. Shut down non-committed units\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment(units_info, load):\n    # Step 1: Classify units\n    must_on, must_off, flex_on, flex_off = [], [], [], []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1: \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                flex_on.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flex_off.append(idx)\n    \n    # Step 2: Calculate must-on generation capacity\n    total_min_must, total_max_must = 0, 0\n    must_on_bounds = []\n    for idx in must_on:\n        unit = units_info[idx]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_must += min_bound\n        total_max_must += max_bound\n        must_on_bounds.append((min_bound, max_bound))\n    \n    # Steps 3-4: Case handling and commitment decisions\n    committed = set(must_on)\n    \n    if load > total_max_must:  # Case 2: Insufficient must-on capacity\n        # Commit all flexible-on units\n        committed.update(flex_on)\n        \n        # Compute available capacity from must-on + flex-on\n        flex_on_capacity = 0\n        for idx in flex_on:\n            unit = units_info[idx]\n            flex_on_capacity += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        available_capacity = total_max_must + flex_on_capacity\n        \n        # Start additional flexible-off units by cost-effectiveness\n        if available_capacity < load:\n            # Calculate cost-effectiveness: (startup + min_gen cost) / min_gen\n            cost_effectiveness = []\n            for idx in flex_off:\n                unit = units_info[idx]\n                min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n                ce = (unit['s_i'] + min_cost) / unit['p_min_i']\n                cost_effectiveness.append((ce, idx))\n            \n            cost_effectiveness.sort(key=lambda x: x[0])\n            \n            for ce, idx in cost_effectiveness:\n                unit = units_info[idx]\n                available_capacity += min(unit['p_max_i'], unit['p_start_i'])\n                committed.add(idx)\n                if available_capacity >= load:\n                    break\n        \n        # Try removing expensive flex-on units\n        removable = []\n        for idx in flex_on:\n            unit = units_info[idx]\n            min_cost = unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2\n            marginal_cost = unit['b_i'] + 2*unit['c_i']*unit['p_min_i']\n            removable.append((marginal_cost, unit['p_min_i'], idx))\n        \n        removable.sort(reverse=True)  # Descending by marginal cost\n        \n        for mc, min_power, idx in removable:\n            if available_capacity - min_power >= load:\n                available_capacity -= min_power\n                committed.remove(idx)\n    \n    elif load < total_min_must:  # Case 3: Overproduction unavoidable\n        # Only must-on units committed\n        pass\n    \n    # Step 5: Set commitment states\n    for idx, unit in enumerate(units_info):\n        unit['u_i'] = 1 if idx in committed else 0\n    \n    # Step 6: Economic dispatch\n    ## 6a: Compute power bounds and initialize outputs\n    min_bounds, max_bounds = {}, {}\n    total_min = 0\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 0:  # Starting unit\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Online unit\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n        min_bounds[idx] = min_bound\n        max_bounds[idx] = max_bound\n        unit['p_i'] = min_bound\n        total_min += min_bound\n    \n    ## 6b: Distribute residual load\n    residual = load - total_min\n    \n    if residual > 0:  # Underproduction case\n        # Get units with capacity headroom\n        dispatchable = [idx for idx in committed if units_info[idx]['p_i'] < max_bounds[idx]]\n        \n        while residual > 0 and dispatchable:\n            # Find unit with cheapest marginal cost\n            best_idx = None\n            best_mc = float('inf')\n            \n            for idx in dispatchable:\n                unit = units_info[idx]\n                mc = unit['b_i'] + 2*unit['c_i']*unit['p_i']\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n            \n            unit = units_info[best_idx]\n            headroom = max_bounds[best_idx] - unit['p_i']\n            increment = min(residual, headroom)\n            \n            # Update output and residual\n            unit['p_i'] += increment\n            residual -= increment\n            \n            # Update dispatchable list\n            dispatchable = [idx for idx in committed \n                            if units_info[idx]['p_i'] < max_bounds[idx]]\n    \n    # Step 7: Set non-committed units to 0 output\n    for idx in set(range(len(units_info))) - committed:\n        units_info[idx]['p_i'] = 0\n    \n    # Prepare output array\n    states = [unit['u_i'] for unit in units_info]\n    outputs = [unit['p_i'] for unit in units_info]\n    \n    return np.array([states, outputs])",
          "from": "crossover",
          "gap_power_rate": 0.0068510873,
          "gap_price_rate": 0.0097378134,
          "fitness": 0.0082944504
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Classify units into must-on, must-off, and free units based on minimum up/down times and shutdown constraints:\n   - Must-on: units that were on (u_i_0=1) and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or previous output exceeds shutdown capacity (p_i_0 > p_shut_i)\n   - Must-off: units that were off (u_i_0=0) and haven't satisfied minimum down-time (-t_i_0 < t_off_min_i)\n   - Free units: remaining units that can be committed or decommitted\n\n2. Set must-off units to off (u_i=0, p_i=0) and must-on units to on (u_i=1)\n\n3. Calculate total minimum and maximum possible output from must-on units considering ramp constraints\n\n4. For underproduction (load > must-on max output):\n   - Sort free units by average production cost at minimum output\n   - Turn on free units in increasing cost order until cumulative max output >= load\n\n5. For overproduction (load < must-on min output), keep free units off\n\n6. Dispatch power:\n   - For each committed unit, compute power bounds based on current state and history\n   - Initialize power outputs to minimum bounds\n   - Incrementally increase output on units with cheapest marginal cost (b_i + 2*c_i*p_i) until meeting load or hitting constraints\n\n7. Return 2D array with commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Make a copy to avoid modifying original data\n    units = [unit.copy() for unit in units_info]\n    \n    # Classify units\n    must_on_units = []\n    must_off_units = []\n    free_units = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # u_i_0 == 0\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Set must-off units\n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Set must-on units and compute bounds\n    min_must = 0\n    max_must = 0\n    for unit in must_on_units:\n        unit['u_i'] = 1\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_must += low\n        max_must += high\n    \n    # Initialize free units to off\n    for unit in free_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Turn on additional free units for underproduction\n    candidate_set = []\n    if load > max_must:\n        # Sort by average cost at minimum power\n        free_units_sorted = sorted(free_units, key=lambda u: (u['s_i'] + u['a_i'] + \n                                  u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'])\n        \n        current_min = min_must\n        current_max = max_must\n        for unit in free_units_sorted:\n            if current_max >= load:\n                break\n            candidate_set.append(unit)\n            unit['u_i'] = 1\n            high_i = min(unit['p_max_i'], unit['p_start_i'])\n            current_min += unit['p_min_i']\n            current_max += high_i\n    elif load < min_must:\n        # Overproduction case\n        candidate_set = []\n    \n    # Collect all committed units\n    committed_units = must_on_units + candidate_set\n    for unit in must_off_units + free_units:\n        if unit not in committed_units:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Power dispatch: Compute bounds for each committed unit\n    bounds = []\n    for unit in committed_units:\n        if unit in must_on_units:\n            low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if unit['u_i_0'] == 1:\n                low_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low_i = unit['p_min_i']\n                high_i = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((low_i, high_i))\n    \n    # Initialize to min outputs\n    total_output = 0\n    for idx, unit in enumerate(committed_units):\n        low_i, high_i = bounds[idx]\n        unit['p_i'] = low_i\n        total_output += low_i\n    \n    # Incremental power allocation\n    remaining = load - total_output\n    if remaining > 0:\n        avail_units = []\n        for idx, unit in enumerate(committed_units):\n            low_i, high_i = bounds[idx]\n            if unit['p_i'] < high_i:\n                # Store (marginal_cost, index, unit_ref)\n                marg_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units.append((marg_cost, idx, unit))\n        \n        while remaining > 0 and avail_units:\n            avail_units.sort(key=lambda x: x[0])\n            cost, idx, unit = avail_units[0]\n            low_i, high_i = bounds[idx]\n            amount = min(remaining, high_i - unit['p_i'])\n            unit['p_i'] += amount\n            remaining -= amount\n            \n            # Update availability\n            if unit['p_i'] >= high_i:\n                avail_units.pop(0)\n            else:\n                # Update marginal cost for this unit\n                new_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_i']\n                avail_units[0] = (new_cost, idx, unit)\n    \n    # Format results in original unit order\n    u_list = [unit['u_i'] for unit in units]\n    p_list = [unit['p_i'] for unit in units]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0107382649,
          "fitness": 0.0084399771
     },
     {
          "name": "enhanced_refined_commit_units",
          "algorithm": "1. Classify units:\n   - Must-on: Online units not meeting min up-time or previous output exceeding shutdown capacity\n   - Must-off: Offline units not meeting min down-time\n   - Flexible online: Online units not must-on (can be turned off)\n   - Flexible offline: Offline units not must-off (can be turned on)\n\n2. Compute power bounds for must-on units considering ramp constraints:\n   - min_output = max(p_min_i, p_i_0 - p_down_i)\n   - max_output = min(p_max_i, p_i_0 + p_up_i)\n\n3. Handle three cases:\n   - Case 1 (load within [\u03a3 must_on_min, \u03a3 must_on_max]): Use only must-on units\n   - Case 2 (load > \u03a3 must_on_max): \n        a. Form candidate set with must-on + flexible online\n        b. If capacity insufficient, start flexible offline units by ascending (s_i/p_min_i + b_i + c_i*p_min_i)\n        c. Remove expensive flexible online units from candidate set if capacity permits\n   - Case 3 (load < \u03a3 must_on_min): Use only must-on units (overproduction unavoidable)\n\n4. For committed units in candidate set:\n   - Compute min/max bounds considering state (online: ramp constraints, offline: startup limits)\n   - Initialize outputs to min bounds\n   - Allocate residual load by increasing output of units with smallest (b_i + 2*c_i*p_i)\n\n5. Set non-committed units to off\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_commit_units(units_info, load):\n    n_units = len(units_info)\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    # Classification lists\n    must_on_idx = []\n    must_off_idx = []\n    flexible_online_idx = []\n    flexible_offline_idx = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_idx.append(i)\n            else:\n                flexible_online_idx.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off_idx.append(i)\n            else:\n                flexible_offline_idx.append(i)\n    \n    candidate_set = set()\n    must_on_min = 0.0\n    must_on_max = 0.0\n    must_on_min_max = {}\n    \n    # Calculate must-on bounds\n    for i in must_on_idx:\n        unit = units_info[i]\n        min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_min_max[i] = (min_out, max_out)\n        must_on_min += min_out\n        must_on_max += max_out\n    \n    # Case handling\n    if must_on_min <= load <= must_on_max:\n        candidate_set = set(must_on_idx)\n    elif load > must_on_max:\n        # Start with must-on + flexible online\n        candidate_set = set(must_on_idx) | set(flexible_online_idx)\n        total_max = must_on_max\n        flex_online_max = []\n        \n        # Calculate bounds for flexible online\n        for i in flexible_online_idx:\n            unit = units_info[i]\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_max += max_out\n            flex_online_max.append(max_out)\n        \n        # Start offline units if needed\n        if total_max < load:\n            offline_units = []\n            for i in flexible_offline_idx:\n                unit = units_info[i]\n                min_power = unit['p_min_i']\n                startup_priority = (\n                    unit['s_i'] / min_power + \n                    unit['b_i'] + \n                    unit['c_i'] * min_power\n                )\n                max_out_start = min(unit['p_max_i'], unit['p_start_i'])\n                offline_units.append((startup_priority, i, max_out_start))\n            \n            offline_units.sort(key=lambda x: x[0])\n            \n            for _, i, max_out in offline_units:\n                candidate_set.add(i)\n                total_max += max_out\n                if total_max >= load:\n                    break\n        \n        # Remove expensive flexible online if possible\n        flex_costs = []\n        for i in flexible_online_idx:\n            if i in candidate_set:\n                unit = units_info[i]\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                cost = unit['b_i'] + 2 * unit['c_i'] * min_out\n                flex_costs.append((cost, i, min_out))\n        \n        if flex_costs:\n            flex_costs.sort(key=lambda x: x[0], reverse=True)\n            for cost, i, min_out in flex_costs:\n                candidate_set_temp = candidate_set - {i}\n                total_max_temp = must_on_max\n                \n                # Recalculate max capacity\n                for j in candidate_set_temp:\n                    if j in flexible_online_idx:\n                        unit = units_info[j]\n                        total_max_temp += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                    elif j in flexible_offline_idx:\n                        unit = units_info[j]\n                        total_max_temp += min(unit['p_max_i'], unit['p_start_i'])\n                \n                if total_max_temp >= load:\n                    candidate_set = candidate_set_temp\n    else:  # Case 3: Load < must_on_min\n        candidate_set = set(must_on_idx)\n    \n    # Power bounds for candidate set\n    unit_min_max = {}\n    for i in candidate_set:\n        unit = units_info[i]\n        if i in must_on_idx or i in flexible_online_idx:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started offline unit\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        unit_min_max[i] = (min_out, max_out)\n    \n    # Dispatch initialization\n    p_dispatch = {}\n    total_min_dispatch = 0.0\n    for i in candidate_set:\n        min_out, _ = unit_min_max[i]\n        p_dispatch[i] = min_out\n        total_min_dispatch += min_out\n    \n    # Allocate residual load\n    residual = load - total_min_dispatch\n    if residual > 0:\n        # Sort by marginal cost (b_i + 2*c_i*p)\n        candidate_list = sorted(\n            candidate_set,\n            key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_dispatch[i]\n        )\n        \n        for i in candidate_list:\n            min_out, max_out = unit_min_max[i]\n            headroom = max_out - p_dispatch[i]\n            if headroom <= 0:\n                continue\n            allocation = min(residual, headroom)\n            p_dispatch[i] += allocation\n            residual -= allocation\n            if residual <= 0:\n                break\n    \n    # Set output values\n    for i in range(n_units):\n        if i in candidate_set:\n            u_arr[i] = 1\n            p_arr[i] = p_dispatch.get(i, 0.0)\n        else:\n            u_arr[i] = 0\n            p_arr[i] = 0.0\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0055793389,
          "gap_price_rate": 0.0137930198,
          "fitness": 0.0096861794
     }
]