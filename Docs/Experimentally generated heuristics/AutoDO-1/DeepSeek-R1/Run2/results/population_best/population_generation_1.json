{
     "name": "commit_units_heuristic",
     "algorithm": "1. Classify units into must-on, must-off, and flexible (both online/offline)\n2. For must-on units, compute min/max output bounds based on current state and ramp constraints\n3. Handle three cases:\n   - Case 1 (load between must-on min/max): Keep only must-on units, turn off flexible units\n   - Case 2 (load > must-on max): Keep online flexible units, start additional offline units based on cost-effectiveness until load can be met\n   - Case 3 (load < must-on min): Must-on units at minimum, turn off all flexible units\n4. Economic dispatch for all online units:\n   a. Start at min output bounds\n   b. Sort units by increasing marginal cost\n   c. Increase output of cheapest units until load met or capacity exhausted\n\n",
     "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    \n    # Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flex_online_indices = []\n    flex_offline_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flex_online_indices.append(i)\n        else:\n            t_off_abs = abs(unit['t_i_0'])\n            if t_off_abs < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flex_offline_indices.append(i)\n    \n    # Set must-off units to off\n    for i in must_off_indices:\n        u[i] = 0\n        p[i] = 0\n    \n    # Compute bounds for must-on units\n    total_min_must = 0\n    total_max_must = 0\n    for i in must_on_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        total_min_must += min_bound\n        total_max_must += max_bound\n        u[i] = 1\n    \n    # Initialize online set with must-on units\n    online_set = set(must_on_indices)\n    \n    if total_min_must <= load <= total_max_must:\n        # Case 1: Only must-on units needed\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    elif load > total_max_must:\n        # Case 2: Need additional units\n        current_capacity = total_max_must\n        deficit = load - total_max_must\n        \n        # Keep flexible online units\n        for i in flex_online_indices:\n            u[i] = 1\n            min_b = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_b = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            min_bounds[i] = min_b\n            max_bounds[i] = max_b\n            current_capacity += max_b\n            online_set.add(i)\n        \n        # Calculate remaining deficit\n        deficit = max(0, load - current_capacity)\n        started_units = []\n        \n        if deficit > 0:\n            # Sort offline flex by cost per MW at min output\n            cost_per_mw = []\n            for i in flex_offline_indices:\n                unit = units_info[i]\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*(unit['p_min_i']**2)\n                cost_per_mw.append(cost / unit['p_min_i'])\n            sorted_indices = [i for _, i in sorted(zip(cost_per_mw, flex_offline_indices))]\n            \n            # Start most economical units first\n            for i in sorted_indices:\n                if deficit <= 0:\n                    break\n                u[i] = 1\n                min_bounds[i] = units_info[i]['p_min_i']\n                max_b = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                max_bounds[i] = max_b\n                online_set.add(i)\n                started_units.append(i)\n                current_capacity += max_b\n                deficit = load - current_capacity\n    \n    else:\n        # Case 3: Load < must-on minimum\n        for i in must_on_indices:\n            p[i] = min_bounds[i]\n        for i in flex_online_indices:\n            u[i] = 0\n        for i in flex_offline_indices:\n            u[i] = 0\n        online_set = set(must_on_indices)\n    \n    # Economic dispatch for online units\n    online_indices = sorted(online_set)\n    params = [(units_info[i]['b_i'], units_info[i]['c_i'], min_bounds[i], max_bounds[i]) for i in online_indices]\n    b, c, mins, maxs = zip(*params)\n    b = np.array(b)\n    c = np.array(c)\n    mins = np.array(mins)\n    maxs = np.array(maxs)\n    \n    # Start from min outputs\n    p_online = np.array(mins)\n    total_output = np.sum(p_online)\n    deficit = load - total_output\n    \n    if deficit > 0:\n        # Sort by increasing marginal cost\n        marginal_costs = 2 * c * p_online + b\n        order = np.argsort(marginal_costs)\n        headroom = maxs - mins\n        \n        # Allocate deficit\n        for i in order:\n            alloc = min(deficit, headroom[i])\n            p_online[i] += alloc\n            deficit -= alloc\n            if deficit <= 0:\n                break\n    \n    # Update outputs\n    for idx, val in enumerate(online_indices):\n        p[val] = p_online[idx]\n    \n    schedules = np.vstack((u, p))\n    return schedules",
     "from": null,
     "gap_power_rate": 0.0048571187,
     "gap_price_rate": 0.0100041649,
     "fitness": 0.0074306418
}