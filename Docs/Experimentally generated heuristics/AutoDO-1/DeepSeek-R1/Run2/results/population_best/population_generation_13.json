{
     "name": "new_heuristic",
     "algorithm": "1. Classify units into must_on (online, violate min-up/shutdown limits), must_off (offline, violate min-down time), flexible_on (eligible online), flexible_off (eligible offline)\n2. Compute must_on generation bounds incorporating ramp limits\n3. Case handling:\n   a) Load within must_on range: commit must_on only\n   b) Load exceeds must_on max:\n      - Start flexible_off units by startup+min-output cost per MW priority\n      - Decommit non-must-on units by average operating cost per MW at min output\n      - Maintain feasibility (min_output \u2264 load \u2264 max_output)\n   c) Load below must_on min: commit must_on only (overproduction)\n4. For committed units:\n   a) Calculate power bounds (online: ramp limits; startup: p_min to min(p_max, p_start))\n   b) Initialize outputs at lower bounds\n   c) Distribute residual load using adaptive marginal cost allocation\n5. Set uncommitted units to off-state\n\n",
     "code": "import numpy as np\n\ndef new_heuristic(units_info, load):\n    # Classify units\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                flexible_on.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible_off.append(unit)\n    \n    # Compute must-on generation bounds\n    total_must_on_min = 0\n    total_must_on_max = 0\n    for unit in must_on:\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_must_on_min += lb\n        total_must_on_max += ub\n    \n    # Case handling\n    if total_must_on_min <= load <= total_must_on_max:\n        commit_set = must_on.copy()\n        started_units = []\n    elif load < total_must_on_min:\n        commit_set = must_on.copy()\n        started_units = []\n    else:  # load > total_must_on_max\n        candidate_set = must_on + flexible_on\n        started_units = []\n        total_max_current = 0\n        \n        # Compute current total_max\n        for unit in candidate_set:\n            if unit in must_on or unit in flexible_on:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                total_max_current += ub\n        \n        # Start flexible_off units if needed\n        if total_max_current < load:\n            flexible_off_sorted = sorted(\n                flexible_off, \n                key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i']\n            )\n            for unit in flexible_off_sorted:\n                ub_start = min(unit['p_max_i'], unit['p_start_i'])\n                total_max_current += ub_start\n                candidate_set.append(unit)\n                started_units.append(unit)\n                if total_max_current >= load:\n                    break\n        \n        # Decommit expensive non-must-on units\n        non_must_on = [u for u in candidate_set if u not in must_on]\n        removed = True\n        while removed and non_must_on:\n            # Compute min/max for candidate_set\n            total_min_candidate = 0\n            total_max_candidate = 0\n            for unit in candidate_set:\n                if unit in must_on:\n                    lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                elif unit in started_units:\n                    lb = unit['p_min_i']\n                    ub = min(unit['p_max_i'], unit['p_start_i'])\n                else:  # flexible_on\n                    lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                total_min_candidate += lb\n                total_max_candidate += ub\n            \n            # Sort non_must_on by average cost per MW at min output (descending)\n            non_must_on_sorted = sorted(\n                non_must_on,\n                key=lambda u: (u['a_i'] + u['b_i']*u['p_min_i'] + u['c_i']*u['p_min_i']**2) / u['p_min_i'],\n                reverse=True\n            )\n            \n            removed = False\n            for i, unit in enumerate(non_must_on_sorted):\n                temp_candidate = [u for u in candidate_set if u != unit]\n                # Recompute bounds for temp_candidate\n                total_min_temp = total_min_candidate\n                total_max_temp = total_max_candidate\n                if unit in must_on:\n                    # Should not happen in non_must_on\n                    lb_u = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub_u = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                elif unit in started_units:\n                    lb_u = unit['p_min_i']\n                    ub_u = min(unit['p_max_i'], unit['p_start_i'])\n                else:\n                    lb_u = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    ub_u = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                \n                total_min_temp -= lb_u\n                total_max_temp -= ub_u\n                \n                if total_min_temp <= load <= total_max_temp:\n                    candidate_set = temp_candidate\n                    if unit in started_units:\n                        started_units.remove(unit)\n                    non_must_on.pop(i)\n                    removed = True\n                    break  # Restart loop\n                    \n        commit_set = candidate_set\n    \n    # Prepare committed units\n    committed_units = []\n    bounds = []\n    for unit in commit_set:\n        if unit in started_units:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        committed_units.append(unit)\n        bounds.append((lb, ub))\n    \n    # Initialize at lower bounds\n    p_alloc = [lb for lb, ub in bounds]\n    residual = load - sum(p_alloc)\n    max_increasable = [i for i, (_, ub) in enumerate(bounds) if p_alloc[i] < ub]\n    \n    # Distribute residual via adaptive marginal cost allocation\n    while residual > 0 and max_increasable:\n        # Compute current marginal costs\n        marginal_costs = [\n            2 * committed_units[i]['c_i'] * p_alloc[i] + committed_units[i]['b_i'] \n            for i in max_increasable\n        ]\n        \n        # Find unit with min marginal cost\n        min_idx_in_list = np.argmin(marginal_costs)\n        min_idx = max_increasable[min_idx_in_list]\n        min_mc = marginal_costs[min_idx_in_list]\n        \n        # Find next min marginal cost\n        next_mc = float('inf')\n        for i, mc in enumerate(marginal_costs):\n            if i == min_idx_in_list:\n                continue\n            if mc < next_mc and mc > min_mc:\n                next_mc = mc\n        \n        # Compute maximum possible increase\n        max_inc_unit = bounds[min_idx][1] - p_alloc[min_idx]\n        if next_mc == float('inf'):\n            step = min(max_inc_unit, residual)\n        else:\n            delta_p = (next_mc - min_mc) / (2 * committed_units[min_idx]['c_i'])\n            step = min(max_inc_unit, delta_p, residual)\n        \n        # Apply step\n        p_alloc[min_idx] += step\n        residual -= step\n        \n        # Remove from max_increasable if at bound\n        if np.isclose(p_alloc[min_idx], bounds[min_idx][1]):\n            max_increasable.remove(min_idx)\n    \n    # Build result\n    u_out = []\n    p_out = []\n    for i, unit in enumerate(units_info):\n        if unit in commit_set:\n            idx = commit_set.index(unit)\n            u_out.append(1)\n            p_out.append(p_alloc[idx])\n        else:\n            u_out.append(0)\n            p_out.append(0.0)\n    \n    return np.array([u_out, p_out])",
     "from": "mutation",
     "gap_power_rate": 0.0044876472,
     "gap_price_rate": 0.0087951792,
     "fitness": 0.0066414132
}