{
     "name": "rolling_unit_commitment",
     "algorithm": "1. Classify units into four states based on constraints and history:\n   - must_on: units violating min-up time (t_i_0 < t_on_min_i) or shutdown capacity (p_i_0 > p_shut_i)\n   - must_off: units violating min-down time (abs(t_i_0) < t_off_min_i)\n   - flexible_on: online units eligible for shutdown\n   - flexible_off: offline units eligible for startup\n2. Compute must_on generation bounds (min/max) considering ramp constraints:\n   - min_out = max(p_min_i, p_i_0 - p_down_i) \n   - max_out = min(p_max_i, p_i_0 + p_up_i)\n3. Case handling for load allocation:\n   a) Load within must_on bounds: commit only must_on units\n   b) Load exceeds must_on capacity:\n      - Form candidate set (must_on \u222a flexible_on)\n      - Start flexible_off units by ascending (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i\n      - Add started units to candidate_set while ensuring total max capacity \u2265 load\n      - Decommit non-must-on units by descending (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i \n        while maintaining total max capacity \u2265 load\n   c) Load below must_on minimum: set must_on units to minimum generation\n4. Calculate power bounds for committed units:\n   - Online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Started units: [p_min_i, min(p_max_i, p_start_i)]\n5. Initialize all committed outputs at lower bounds\n6. Distribute residual load using marginal cost priority:\n   - While residual load > tolerance:\n       1. Find unit with minimal current marginal cost (2*c_i*p_i + b_i)\n       2. Calculate step = min(residual, headroom, marginal cost delta to next unit)\n       3. Increase output and reduce residual\n7. Set uncommitted units to off-state (u_i=0, p_i=0)\n\n",
     "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    n = len(units_info)\n    tol = 1e-5\n    \n    # Classify units\n    must_on, must_off, flexible_on, flexible_off = set(), set(), set(), set()\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online units\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.add(i)\n            else:\n                flexible_on.add(i)\n        else:  # Offline units\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.add(i)\n            else:\n                flexible_off.add(i)\n    \n    # Calculate must_on bounds\n    total_min_must_on, total_max_must_on = 0, 0\n    for i in must_on:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min_must_on += lb\n        total_max_must_on += ub\n    \n    # Case handling\n    if load < total_min_must_on - tol:\n        candidate_set = set(must_on)\n    elif abs(load - total_min_must_on) < tol or (total_min_must_on <= load <= total_max_must_on):\n        candidate_set = set(must_on)\n    else:  # load > total_max_must_on\n        candidate_set = must_on | flexible_on\n        total_max = total_max_must_on\n        for i in flexible_on:\n            unit = units_info[i]\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_max += ub\n        \n        # Start flexible_off units\n        flexible_off_sorted = sorted(\n            flexible_off, \n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n        )\n        for i in flexible_off_sorted:\n            max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            if total_max < load:\n                candidate_set.add(i)\n                total_max += max_i\n            else:\n                break\n        \n        # Decommit non-must-on units\n        non_must_on = candidate_set - must_on\n        if non_must_on:\n            cost_priority = sorted(\n                non_must_on,\n                key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                             units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i'],\n                reverse=True\n            )\n            temp_candidate = set(candidate_set)\n            for i in cost_priority:\n                if i in flexible_on:\n                    max_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                if total_max - max_i >= load:\n                    temp_candidate.remove(i)\n                    total_max -= max_i\n            candidate_set = temp_candidate\n    \n    # Calculate power bounds and initialize outputs\n    u_arr = [0] * n\n    p_arr = [0.0] * n\n    outputs = [0.0] * n\n    lb_arr = [0.0] * n\n    ub_arr = [0.0] * n\n    \n    for i in candidate_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Online unit\n            lb_arr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started unit\n            lb_arr[i] = unit['p_min_i']\n            ub_arr[i] = min(unit['p_max_i'], unit['p_start_i'])\n        outputs[i] = lb_arr[i]\n        u_arr[i] = 1\n        p_arr[i] = outputs[i]\n    \n    # Distribute residual load\n    total_output = sum(outputs[i] for i in candidate_set)\n    residual = load - total_output\n    \n    if residual > tol:\n        while residual > tol:\n            min_mc = float('inf')\n            min_idx = -1\n            next_min_mc = float('inf')\n            \n            for i in candidate_set:\n                if outputs[i] < ub_arr[i] - tol:\n                    mc = 2 * units_info[i]['c_i'] * outputs[i] + units_info[i]['b_i']\n                    if mc < min_mc:\n                        next_min_mc = min_mc\n                        min_mc = mc\n                        min_idx = i\n                    elif min_mc < mc < next_min_mc:\n                        next_min_mc = mc\n            \n            if min_idx == -1:\n                break\n            \n            unit = units_info[min_idx]\n            headroom = ub_arr[min_idx] - outputs[min_idx]\n            step = min(residual, headroom)\n            \n            if next_min_mc < float('inf') and unit['c_i'] > tol:\n                step = min(step, (next_min_mc - min_mc) / (2 * unit['c_i']))\n            \n            outputs[min_idx] += step\n            p_arr[min_idx] = outputs[min_idx]\n            residual -= step\n    \n    # Set uncommitted units\n    for i in range(n):\n        if i not in candidate_set:\n            u_arr[i] = 0\n            p_arr[i] = 0.0\n    \n    return np.array([u_arr, p_arr])",
     "from": "crossover",
     "gap_power_rate": 0.0044876472,
     "gap_price_rate": 0.0087221821,
     "fitness": 0.0066049146
}