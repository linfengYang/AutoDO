{
     "name": "refined_rolling_commitment_v2",
     "algorithm": "1. Precompute ramp-constrained min/max outputs for all units if committed\n2. Identify must-on units (violating min-up time or shutdown ramp)\n3. Identify must-off units (violating min-down time)\n4. Commit must-on units and compute current capacity ranges\n5. Calculate effective cost per MW for flexible units (amortized startup cost + production cost at min output)\n6. Commit flexible units incrementally by ascending effective cost until capacity covers load\n7. Decommit expensive flexible units if min output exceeds load while maintaining capacity feasibility\n8. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load (should not occur)\n   c) Perform lambda iteration for economic dispatch otherwise\n9. Set uncommitted units to off with zero output\n\n",
     "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    min_potential = [0] * n_units\n    max_potential = [0] * n_units\n    \n    # Precompute min/max potential outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_potential[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_potential[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_potential[i] = unit['p_min_i']\n            max_potential[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on_indices = []\n    must_off_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1: \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n        elif unit['u_i_0'] == 0:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n    \n    # Initialize committed units and capacity\n    committed_indices = set(must_on_indices)\n    total_min = sum(min_potential[i] for i in must_on_indices)\n    total_max = sum(max_potential[i] for i in must_on_indices)\n    \n    # Process flexible units\n    flexible_indices = [i for i in range(n_units) if i not in must_on_indices and i not in must_off_indices]\n    cost_data = []\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        min_pwr = min_potential[i]\n        if unit['u_i_0'] == 0:  # Startup required\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        else:  # Already running\n            cost_per_mw = (unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        cost_data.append((cost_per_mw, i))\n    \n    # Commit flexible units by ascending cost\n    cost_data.sort(key=lambda x: x[0])\n    flexible_committed = []\n    \n    for cost_val, i in cost_data:\n        if total_max < load:  # Only add if capacity insufficient\n            committed_indices.add(i)\n            flexible_committed.append(i)\n            total_min += min_potential[i]\n            total_max += max_potential[i]\n    \n    # Decommit expensive units if overgeneration occurs\n    flexible_committed.sort(key=lambda i: cost_data[flexible_indices.index(i)][0], reverse=True)\n    for i in flexible_committed:\n        if i not in committed_indices:\n            continue\n        new_min = total_min - min_potential[i]\n        new_max = total_max - max_potential[i]\n        if new_min <= load and new_max >= load:\n            committed_indices.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch power allocation\n    p_outputs = [0] * n_units\n    \n    # Case 1: Overgeneration unavoidable\n    if total_min > load:\n        for i in committed_indices:\n            p_outputs[i] = min_potential[i]\n    # Case 2: Shouldn't occur due to commitment logic\n    elif total_max < load:\n        for i in committed_indices:\n            p_outputs[i] = max_potential[i]\n    # Case 3: Economic dispatch required\n    else:\n        committed_list = list(committed_indices)\n        low_lambda = 0\n        high_lambda = 0\n        \n        # Set lambda search bounds\n        for i in committed_list:\n            unit = units_info[i]\n            cost_at_min = unit['b_i'] + 2 * unit['c_i'] * min_potential[i]\n            cost_at_max = unit['b_i'] + 2 * unit['c_i'] * max_potential[i]\n            high_lambda = max(high_lambda, cost_at_min, cost_at_max)\n        high_lambda *= 2  # Expand upper bound\n        \n        # Lambda iteration\n        tol = 0.01\n        max_iter = 100\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for i in committed_list:\n                unit = units_info[i]\n                min_p = min_potential[i]\n                max_p = max_potential[i]\n                if unit['c_i'] == 0:  # Linear units\n                    p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n                else:  # Quadratic units\n                    p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(min_p, min(max_p, p_val))\n                total_power += p_val\n            \n            if abs(total_power - load) < tol:\n                break\n            elif total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Apply final dispatch\n        for i in committed_list:\n            unit = units_info[i]\n            min_p = min_potential[i]\n            max_p = max_potential[i]\n            if unit['c_i'] == 0:\n                p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_p, min(max_p, p_val))\n            p_outputs[i] = p_val\n    \n    # Prepare output schedules\n    u_vector = [1 if i in committed_indices else 0 for i in range(n_units)]\n    schedules = np.array([u_vector, p_outputs])\n    \n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.00501,
     "gap_price_rate": 0.00888,
     "fitness": 0.00695
}