{
     "name": "refined_rolling_unit_commitment",
     "algorithm": "1. Categorize units into must-on (must remain on due to min up-time or shutdown ramp constraints), must-off (must remain off due to min down-time constraints), and flexible units.\n2. Precompute ramp-constrained min and max outputs for every unit if committed.\n3. Commit must-on units, calculate current total min and max output.\n4. Compute effective cost for flexible units (amortized startup cost over minimum output) and sort ascending.\n5. Commit flexible units in cost order until total max output >= load.\n6. If total min output > load, decommit expensive flexible units (descending cost order) while maintaining total max >= load.\n7. For final committed set:\n   a) If total min output > load, assign min outputs.\n   b) Else if total max output < load, assign max outputs.\n   c) Else perform economic dispatch via lambda iteration to minimize quadratic production costs.\n8. Set uncommitted units to off with zero output.\n\n",
     "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    # Initialize arrays\n    num_units = len(units_info)\n    u_list = [0.0] * num_units\n    p_list = [0.0] * num_units\n    min_outputs = [0.0] * num_units\n    max_outputs = [0.0] * num_units\n    effective_costs = [0.0] * num_units\n\n    # Step 1: Categorize units and precompute outputs\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Compute ramp-constrained min/max outputs\n        if unit['u_i_0'] == 1:  # Previously online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            \n        min_outputs[i] = min_out\n        max_outputs[i] = max_out\n        \n        # Categorization\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Precompute effective costs\n        if min_out > 0:\n            prod_cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            effective_costs[i] = (prod_cost + unit['s_i']) / min_out\n        else:\n            effective_costs[i] = 1e12  # Large number if min_out=0\n\n    # Step 2: Commit must-on units\n    committed_set = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    \n    # Step 3: Sort flexible units by effective cost\n    flexible = sorted(flexible, key=lambda i: effective_costs[i])\n    \n    # Step 4: Commit flexible until capacity >= load\n    for i in flexible:\n        if total_max < load:\n            committed_set.add(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    # Step 5: Backward pass for over-commitment\n    if total_min > load:\n        expensive_flex = sorted(\n            [i for i in committed_set if i not in must_on],\n            key=lambda i: effective_costs[i],\n            reverse=True\n        )\n        for i in expensive_flex:\n            new_min = total_min - min_outputs[i]\n            new_max = total_max - max_outputs[i]\n            if new_max >= load:\n                committed_set.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= load:\n                    break\n    \n    # Step 6: Assign outputs\n    # Case 1: Overgeneration (set to min)\n    if total_min > load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = min_outputs[i]\n    # Case 2: Undergeneration (set to max)\n    elif total_max < load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = max_outputs[i]\n    # Case 3: Economic dispatch\n    else:\n        # Prepare for dispatch\n        B = []\n        C = []\n        P_MIN = []\n        P_MAX = []\n        commit_indices = sorted(committed_set)\n        \n        for i in commit_indices:\n            unit = units_info[i]\n            B.append(unit['b_i'])\n            C.append(unit['c_i'])\n            P_MIN.append(min_outputs[i])\n            P_MAX.append(max_outputs[i])\n        \n        n = len(commit_indices)\n        if n == 0:  # No units to dispatch\n            pass\n        else:\n            # Lambda iteration setup\n            low_lam = 1e12\n            high_lam = -1e12\n            \n            for i in range(n):\n                b = B[i]\n                c = C[i]\n                p_min = P_MIN[i]\n                p_max = P_MAX[i]\n                if c == 0:  # Linear unit\n                    low_lam = min(low_lam, b)\n                    high_lam = max(high_lam, b)\n                else:  # Quadratic unit\n                    low_lam = min(low_lam, 2*c*p_min + b)\n                    high_lam = max(high_lam, 2*c*p_max + b)\n            \n            # Binary search\n            max_iter = 100\n            tol = 1e-3\n            for _ in range(max_iter):\n                mid_lam = (low_lam + high_lam) / 2.0\n                total_power = 0.0\n                p_dispatch = []\n                \n                for i in range(n):\n                    b = B[i]\n                    c = C[i]\n                    p_min = P_MIN[i]\n                    p_max = P_MAX[i]\n                    \n                    if c == 0:  # Linear\n                        p_i = p_max if mid_lam >= b else p_min\n                    else:  # Quadratic\n                        p_desired = (mid_lam - b) / (2 * c)\n                        p_i = min(max(p_desired, p_min), p_max)\n                    \n                    p_dispatch.append(p_i)\n                    total_power += p_i\n                \n                if abs(total_power - load) < tol:\n                    break\n                if total_power < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n            \n            # Assign dispatch results\n            for idx, i in enumerate(commit_indices):\n                u_list[i] = 1.0\n                p_list[i] = p_dispatch[idx]\n    \n    # Set uncommitted units\n    for i in range(num_units):\n        if i not in committed_set:\n            u_list[i] = 0.0\n            p_list[i] = 0.0\n    \n    return np.array([u_list, p_list])",
     "from": "mutation",
     "gap_power_rate": 0.00539,
     "gap_price_rate": 0.00901,
     "fitness": 0.0072
}