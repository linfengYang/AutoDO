{
     "name": "novel_rolling_commitment_v1",
     "algorithm": "1. Precompute ramp-constrained min/max outputs for all units considering startup/shutdown ramp limits\n2. Classify units:\n   - Must-on: Online units violating min-up time OR offline units exceeding shutdown ramp\n   - Must-off: Offline units violating min-down time\n   - Flexible: Other units\n3. Commit must-on units and set must-off units to offline\n4. Compute effective cost for flexible units (amortizing startup costs over min output)\n5. Commit flexible units incrementally by ascending effective cost until capacity >= load\n6. Decommit expensive flexible units while maintaining capacity coverage\n7. Assign outputs:\n   a) If total min capacity > load: Set outputs to min values\n   b) Else if total max capacity < load: Set outputs to max values\n   c) Else: Perform economic dispatch via lambda iteration\n8. Set uncommitted units offline with zero output\n\n",
     "code": "import numpy as np\n\ndef novel_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Precompute min/max outputs with ramp constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_output[i] = unit['p_min_i']\n            max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize committed units\n    committed = set(must_on)\n    total_min = sum(min_output[i] for i in must_on)\n    total_max = sum(max_output[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    eff_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        min_out = min_output[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        else:\n            cost = (unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        eff_costs.append((cost, i))\n    \n    # Commit flexible units by ascending cost\n    eff_costs_sorted = sorted(eff_costs, key=lambda x: x[0])\n    for cost, i in eff_costs_sorted:\n        if total_max < load:\n            committed.add(i)\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    # Decommit expensive units while maintaining coverage\n    decommit_candidates = sorted(\n        [i for i in committed if i not in must_on],\n        key=lambda i: eff_costs[[idx for c, idx in eff_costs_sorted].index(i)][0],\n        reverse=True\n    )\n    for i in decommit_candidates:\n        if total_max - max_output[i] >= load:\n            committed.remove(i)\n            total_min -= min_output[i]\n            total_max -= max_output[i]\n    \n    # Initialize output arrays\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    # Assign outputs based on commitment status\n    if total_min > load:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = min_output[i]\n    elif total_max < load:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = max_output[i]\n    else:\n        # Economic dispatch via lambda iteration\n        indices = list(committed)\n        low_lam = 0\n        high_lam = 0\n        \n        for i in indices:\n            unit = units_info[i]\n            ic_min = unit['b_i'] + 2 * unit['c_i'] * min_output[i]\n            ic_max = unit['b_i'] + 2 * unit['c_i'] * max_output[i]\n            low_lam = min(low_lam, ic_min) if low_lam != 0 else ic_min\n            high_lam = max(high_lam, ic_max) if high_lam != 0 else ic_max\n        \n        low_lam -= 100\n        high_lam += 100\n        tol = 0.01\n        max_iter = 1000\n        \n        for _ in range(max_iter):\n            lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i in indices:\n                unit = units_info[i]\n                p_opt = max(min_output[i], min(max_output[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n                total_p += p_opt\n            \n            if abs(total_p - load) < tol:\n                break\n            if total_p < load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        for i in indices:\n            unit = units_info[i]\n            p_opt = max(min_output[i], min(max_output[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n            u_out[i] = 1\n            p_out[i] = p_opt\n    \n    # Set uncommitted units to offline\n    schedules = np.vstack((u_out, p_out))\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.00431,
     "gap_price_rate": 0.00817,
     "fitness": 0.00624
}