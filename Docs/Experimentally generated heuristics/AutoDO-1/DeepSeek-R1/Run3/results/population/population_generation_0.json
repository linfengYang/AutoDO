[
     {
          "name": "commit_units_priority_afc",
          "algorithm": "The heuristic uses a priority list based on Average Full-Load Cost (AFLC) for unit commitment. First, units are categorized as forced on (must stay online due to min-up-time or shutdown ramp constraints), forced off (must stay offline due to min-down-time constraints), or free units. Free units are sorted by AFLC. Starting with forced-on units at minimum output, free units are committed in AFLC order until total maximum capacity covers the load. Finally, an economic dispatch minimizes production costs by adjusting outputs within operational constraints to meet the load exactly or as closely as possible.\n",
          "code": "import numpy as np\n\ndef commit_units_priority_afc(units_info, load):\n    n_units = len(units_info)\n    u_arr = [0] * n_units\n    p_arr = [0.0] * n_units\n    lb_arr = [0.0] * n_units\n    ub_arr = [0.0] * n_units\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_indices.append(i)\n            else:\n                free_indices.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                free_indices.append(i)\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in forced_on_indices:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        u_arr[i] = 1\n        p_arr[i] = lb\n        lb_arr[i] = lb\n        ub_arr[i] = ub\n        total_min += lb\n        total_max += ub\n    \n    afc = []\n    for i in free_indices:\n        unit = units_info[i]\n        a, b, c, p_max = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_max_i']\n        full_load_cost = a + b * p_max + c * (p_max ** 2)\n        afc.append(full_load_cost / p_max)\n    sorted_free = [i for _, i in sorted(zip(afc, free_indices))]\n    \n    committed_indices = forced_on_indices[:]\n    \n    for i in sorted_free:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        u_arr[i] = 1\n        p_arr[i] = lb\n        lb_arr[i] = lb\n        ub_arr[i] = ub\n        total_min += lb\n        total_max += ub\n        committed_indices.append(i)\n    \n    current_total = total_min\n    gap = load - current_total\n    \n    while abs(gap) > 1e-8:\n        if gap > 0:\n            candidate = None\n            min_mc = float('inf')\n            for i in committed_indices:\n                if p_arr[i] < ub_arr[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate is None:\n                break\n            increase = min(gap, ub_arr[candidate] - p_arr[candidate])\n            p_arr[candidate] += increase\n            current_total += increase\n            gap = load - current_total\n        else:\n            candidate = None\n            max_mc = -float('inf')\n            for i in committed_indices:\n                if p_arr[i] > lb_arr[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate is None:\n                break\n            decrease = min(-gap, p_arr[candidate] - lb_arr[candidate])\n            p_arr[candidate] -= decrease\n            current_total -= decrease\n            gap = load - current_total\n    \n    return np.array([u_arr, p_arr])",
          "from": null,
          "gap_power_rate": 0.00688,
          "gap_price_rate": 0.01133,
          "fitness": 0.0091
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Categorize units into must-on (must remain on due to constraints), must-off (must remain off due to constraints), and flexible (can be committed based on cost).\n2. Commit must-on units to on and must-off units to off.\n3. For flexible units, calculate an effective incremental cost that amortizes startup costs over minimum power output. Sort units by this cost in ascending order.\n4. Commit flexible units in sorted order until total available capacity meets or exceeds the current load.\n5. For committed units, calculate min/max power outputs considering ramp and startup constraints.\n6. If total minimum output exceeds load, set all committed units to minimum output.\n7. If total maximum output is below load, set all committed units to maximum output.\n8. Otherwise, perform economic dispatch via lambda iteration (binary search) to optimally distribute load among committed units while respecting individual unit constraints.\n9. Set uncommitted units to off with zero output.\n10. Return commitment statuses and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(b, c, min_p, max_p, load, tol=1e-6):\n    n = len(b)\n    total_min = np.sum(min_p)\n    total_max = np.sum(max_p)\n    if total_min >= load:\n        return min_p\n    if total_max <= load:\n        return max_p\n    IC_min = np.min(b + 2 * c * min_p)\n    IC_max = np.max(b + 2 * c * max_p)\n    low = IC_min\n    high = IC_max\n    while high - low > tol:\n        mid = (low + high) / 2.0\n        p_unconstrained = (mid - b) / (2 * c)\n        p_clipped = np.clip(p_unconstrained, min_p, max_p)\n        total = np.sum(p_clipped)\n        if total < load:\n            low = mid\n        else:\n            high = mid\n    mid = (low + high) / 2.0\n    p_unconstrained = (mid - b) / (2 * c)\n    p_clipped = np.clip(p_unconstrained, min_p, max_p)\n    return p_clipped\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_current = np.zeros(n_units)\n    min_p_list = np.zeros(n_units)\n    max_p_list = np.zeros(n_units)\n    \n    must_on_indices = []\n    must_off_indices = []\n    flexible_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flexible_indices.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flexible_indices.append(i)\n    \n    u_current[must_on_indices] = 1\n    \n    def compute_effective_ic(unit):\n        if unit['u_i_0'] == 1:\n            return unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        else:\n            return (unit['s_i'] / unit['p_min_i']) + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n    \n    flexible_units_sorted = sorted(flexible_indices, key=lambda i: compute_effective_ic(units_info[i]))\n    \n    total_min, total_max = 0.0, 0.0\n    for i in must_on_indices:\n        unit = units_info[i]\n        prev_p = unit['p_i_0']\n        min_p_i = max(unit['p_min_i'], prev_p - unit['p_down_i'])\n        max_p_i = min(unit['p_max_i'], prev_p + unit['p_up_i'])\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    committed_flexible = []\n    for i in flexible_units_sorted:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p_i = unit['p_min_i']\n            max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n        if total_max < load:\n            total_min += min_p_i\n            total_max += max_p_i\n            committed_flexible.append(i)\n            u_current[i] = 1\n        else:\n            break\n    \n    for i in range(n_units):\n        if u_current[i] == 0:\n            min_p_list[i] = max_p_list[i] = 0.0\n        else:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_list[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_list[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p_list[i] = unit['p_min_i']\n                max_p_list[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    committed_indices = np.where(u_current == 1)[0]\n    min_p_committed = min_p_list[committed_indices]\n    max_p_committed = max_p_list[committed_indices]\n    total_min_committed = np.sum(min_p_committed)\n    total_max_committed = np.sum(max_p_committed)\n    \n    p_current = np.zeros(n_units)\n    if total_min_committed > load:\n        p_current[committed_indices] = min_p_committed\n    elif total_max_committed < load:\n        p_current[committed_indices] = max_p_committed\n    else:\n        b_committed = np.array([units_info[i]['b_i'] for i in committed_indices])\n        c_committed = np.array([units_info[i]['c_i'] for i in committed_indices])\n        p_committed = economic_dispatch(b_committed, c_committed, min_p_committed, max_p_committed, load)\n        p_current[committed_indices] = p_committed\n    \n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00575,
          "gap_price_rate": 0.0158,
          "fitness": 0.01078
     },
     {
          "name": "commit_units_by_ramp_aware_priority",
          "algorithm": "1. Classify units into must-run (forced online), must-off (forced offline), or flexible using min up/down times and shutdown ramp constraints.\n2. Forward pass: Add available units (sorted by increasing average cost at p_min) to committed set until effective maximum capacity meets load.\n3. Backward pass: Remove expensive non-must-run online units (sorted by decreasing marginal cost at p_min) if feasible while maintaining adequate capacity.\n4. Economic Dispatch:\n   a. For each committed unit, compute feasible output bounds considering ramp limits.\n   b. Compute total feasible min/max outputs.\n   c. Set target output = min(load, total_UB) if load > total_LB; otherwise total_LB.\n   d. Use bisection search to find optimal lambda for economic dispatch with ramp constraints.\n5. Return schedules with commitment states and dispatch outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_ramp_aware_priority(units_info, load):\n    # Extract parameters\n    n_units = len(units_info)\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    u0 = [unit['u_i_0'] for unit in units_info]\n    t0 = [unit['t_i_0'] for unit in units_info]\n    p0 = [unit['p_i_0'] for unit in units_info]\n    \n    # Determine must-run and must-off\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if (t0[i] < t_on_min[i]) or (p0[i] > p_shut[i]):\n                must_run[i] = True\n        else:\n            if abs(t0[i]) < t_off_min[i]:\n                must_off[i] = True\n    \n    # Initial commit must-run units\n    committed = must_run.copy()\n    \n    # Effective max for must-run units\n    total_eff_max = 0.0\n    for i in range(n_units):\n        if committed[i]:\n            eff_max_i = min(p_max[i], p0[i] + p_up[i])\n            total_eff_max += eff_max_i\n    \n    # Candidate units (available, not committed, not must-off)\n    candidate_units = [i for i in range(n_units) \n                       if not committed[i] and not must_off[i]]\n    # Sort by average cost at p_min: (s[i] + b[i]*p_min[i] + c[i]*p_min[i]**2)/p_min[i]\n    candidate_units.sort(key=lambda i: (s[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i])\n    \n    # Forward pass: add candidate units until max capacity >= load\n    for i in candidate_units:\n        if total_eff_max >= load:\n            break\n        eff_max_i = min(p_max[i], p_start[i])\n        total_eff_max += eff_max_i\n        committed[i] = True\n    \n    # Backward pass: try to remove expensive non-must-run online units\n    removable = [i for i in range(n_units) \n                 if committed[i] and not must_run[i] and u0[i]==1]\n    # Sort by decreasing marginal cost at p_min: (2*c[i]*p_min[i] + b[i])\n    removable.sort(key=lambda i: 2*c[i]*p_min[i] + b[i], reverse=True)\n    \n    for i in removable:\n        # Compute min/max without unit i\n        total_min_without = 0.0\n        total_max_without = 0.0\n        for j in range(n_units):\n            if committed[j] and j != i:\n                if u0[j] == 1:\n                    eff_min_j = max(p_min[j], p0[j] - p_down[j])\n                    eff_max_j = min(p_max[j], p0[j] + p_up[j])\n                else:\n                    eff_min_j = p_min[j]\n                    eff_max_j = min(p_max[j], p_start[j])\n                total_min_without += eff_min_j\n                total_max_without += eff_max_j\n        # Check feasibility without unit i\n        if (total_min_without <= load) and (load <= total_max_without):\n            committed[i] = False\n    \n    # Prepare bounds for economic dispatch\n    LB = [0.0] * n_units\n    UB = [0.0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            if u0[i] == 1:\n                LB[i] = max(p_min[i], p0[i] - p_down[i])\n                UB[i] = min(p_max[i], p0[i] + p_up[i])\n            else:\n                LB[i] = p_min[i]\n                UB[i] = min(p_max[i], p_start[i])\n    total_LB = sum(LB)\n    total_UB = sum(UB)\n    \n    # Determine target output\n    if load < total_LB:\n        target = total_LB\n    elif load > total_UB:\n        target = total_UB\n    else:\n        target = load\n    \n    # Initialize outputs to LB\n    p = [LB[i] if committed[i] else 0.0 for i in range(n_units)]\n    \n    # Economic dispatch via bisection if needed\n    n_committed = sum(committed)\n    if n_committed > 0 and abs(total_LB - total_UB) > 1e-3:\n        # Find lambda bounds\n        low_lambda = 1e10\n        high_lambda = -1e10\n        for i in range(n_units):\n            if committed[i]:\n                low_candidate = 2 * c[i] * LB[i] + b[i]\n                high_candidate = 2 * c[i] * UB[i] + b[i]\n                low_lambda = min(low_lambda, low_candidate)\n                high_lambda = max(high_lambda, high_candidate)\n        \n        # Bisection search\n        TOL = 0.1\n        iter_limit = 100\n        for _ in range(iter_limit):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_p = 0.0\n            for i in range(n_units):\n                if committed[i]:\n                    p_desired = (mid_lambda - b[i]) / (2 * c[i])\n                    p_i = max(LB[i], min(UB[i], p_desired))\n                    total_p += p_i\n            if total_p < target:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            if high_lambda - low_lambda < TOL:\n                break\n        \n        # Set final outputs\n        for i in range(n_units):\n            if committed[i]:\n                p_desired = (mid_lambda - b[i]) / (2 * c[i])\n                p[i] = max(LB[i], min(UB[i], p_desired))\n    \n    # Prepare schedules\n    u = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00995,
          "gap_price_rate": 0.01342,
          "fitness": 0.01169
     },
     {
          "name": "roll_uc_priority_list",
          "algorithm": "1. Classify units into must-run, must-off, and flexible (both on and off).\n   - Must-run: Units that must stay online (either violating min-up time or previous output exceeds shutdown capacity).\n   - Must-off: Units that must stay offline (violating min-down time).\n   - Flexible: Units that can toggle state (satisfy min-up/down and shutdown constraints).\n2. Handle surplus (P_min_total \u2265 load):\n   - Start with all flexible-on units kept online.\n   - Sort flexible-on units by cost per MW at min output descending.\n   - Turn off expensive units to reduce over-generation while maintaining feasibility.\n3. Handle deficit (P_min_total < load):\n   - Dispatch by increasing output of online units in economic merit order.\n   - If online capacity insufficient, start offline units with best (startup + min-output cost)/min-output metric.\n4. Assign states and outputs:\n   - Must-run/must-off units fixed based on constraints.\n   - Flexible units determined by greedy allocation.\n   - Respect ramp limits and min/max output bounds.\n\n",
          "code": "import numpy as np\n\ndef roll_uc_priority_list(units_info, load):\n    num_units = len(units_info)\n    must_run = []\n    must_off = []\n    flex_on = []\n    flex_off = []\n    \n    # Classify units\n    for i, u in enumerate(units_info):\n        prev_on = u['u_i_0'] == 1\n        if prev_on:\n            min_up_ok = u['t_i_0'] >= u['t_on_min_i']\n            shut_ok = u['p_i_0'] <= u['p_shut_i']\n            if not (min_up_ok and shut_ok):\n                must_run.append(i)\n            else:\n                flex_on.append(i)\n        else:\n            min_down_ok = -u['t_i_0'] >= u['t_off_min_i']\n            if not min_down_ok:\n                must_off.append(i)\n            else:\n                flex_off.append(i)\n    \n    online_indices = must_run + flex_on\n    offline_indices = must_off + flex_off\n    allocation = {}\n    \n    # Calculate initial min output for online units\n    def get_min(unit):\n        return max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'] if unit['u_i_0'] else 0)\n    \n    def get_max(unit):\n        return min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'] if unit['u_i_0'] else min(unit['p_max_i'], unit['p_start_i']))\n    \n    min_outputs = [get_min(units_info[i]) for i in online_indices]\n    total_min = sum(min_outputs)\n    \n    # Surplus handling\n    if total_min >= load:\n        # Sort flexible-on by cost/MW descending\n        cand_off = []\n        for idx in flex_on:\n            unit = units_info[idx]\n            min_out = get_min(unit)\n            cost_min = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            cand_off.append((idx, min_out, cost_min / min_out))\n        \n        cand_off.sort(key=lambda x: x[2], reverse=True)\n        for idx, min_out, _ in cand_off:\n            if total_min - min_out >= load:\n                online_indices.remove(idx)\n                total_min -= min_out\n    \n    # Deficit handling\n    else:\n        deficit = load - total_min\n        online_data = []\n        for idx in online_indices:\n            unit = units_info[idx]\n            min_val = get_min(unit)\n            max_val = get_max(unit)\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * min_val\n            online_data.append((idx, min_val, max_val, marginal_cost))\n        \n        allocation = {idx: min_val for idx, min_val, _, _ in online_data}\n        online_data.sort(key=lambda x: x[3])\n        \n        # Ramp up online units\n        for idx, min_val, max_val, _ in online_data:\n            room = max_val - min_val\n            if room <= 0 or deficit <= 0:\n                continue\n            add = min(room, deficit)\n            allocation[idx] = min_val + add\n            deficit -= add\n        \n        # Start offline units if needed\n        if deficit > 0:\n            cand_on = []\n            for idx in flex_off:\n                unit = units_info[idx]\n                min_out = unit['p_min_i']\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                if min_out > deficit:\n                    continue\n                start_cost = unit['s_i']\n                cost_min = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n                metric = (start_cost + cost_min) / min_out\n                cand_on.append((idx, min_out, max_out, metric))\n            \n            cand_on.sort(key=lambda x: x[3])\n            for idx, min_out, max_out, _ in cand_on:\n                if deficit <= 0:\n                    break\n                p_set = min(max_out, deficit)\n                if p_set < min_out:\n                    continue\n                allocation[idx] = p_set\n                online_indices.append(idx)\n                deficit -= p_set\n    \n    # Build final schedules\n    u_list = []\n    p_list = []\n    for i, unit in enumerate(units_info):\n        if i in allocation:\n            u_list.append(1)\n            p_list.append(allocation[i])\n        elif i in online_indices:\n            u_list.append(1)\n            p_list.append(get_min(unit))\n        else:\n            u_list.append(0)\n            p_list.append(0.0)\n    \n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00063,
          "gap_price_rate": 0.0341,
          "fitness": 0.01736
     },
     {
          "name": "rolling_priority_list_commitment",
          "algorithm": "1. Determine must-run units: units forced online due to min-up time or exceeding shutdown capacity\n2. Determine must-off units: units forced offline due to min-down time\n3. Initialize commitments: must-run=on, must-off=off, others retain previous state\n4. Compute total min/max power considering ramp and startup/shutdown limits\n5. If load below total min: turn off flexible online units to reduce overproduction\n6. If load above total max: turn on flexible offline units with lowest avg cost\n7. Dispatch committed units using economic dispatch:\n   - Start at lower bounds (ramp-constrained)\n   - Incrementally increase output of units with lowest marginal cost\n   - Respect upper bounds and load requirement\n8. Return schedule: commitment and dispatch decisions\n\n",
          "code": "import numpy as np\n\ndef rolling_priority_list_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    lb = [0.0] * n_units\n    ub = [0.0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        elif -unit['t_i_0'] < unit['t_off_min_i']:\n            must_off[i] = True\n    \n    for i in range(n_units):\n        if must_on[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    total_min = 0.0\n    total_max = 0.0\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:\n                lb[i] = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n                ub[i] = ub_i\n            else:\n                lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += lb[i]\n            total_max += ub[i]\n    \n    if load < total_min:\n        candidates = [i for i in range(n_units) if u[i] == 1 and not must_on[i]]\n        candidates.sort(key=lambda i: lb[i], reverse=True)\n        for i in candidates:\n            u[i] = 0\n            total_min -= lb[i]\n            total_max -= ub[i]\n            lb[i] = ub[i] = 0.0\n            if total_min <= load:\n                break\n                \n    if load > total_max:\n        candidates = [i for i in range(n_units) if u[i] == 0 and not must_off[i]]\n        avg_costs = []\n        for i in candidates:\n            unit = units_info[i]\n            min_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n            avg_costs.append(min_cost / unit['p_min_i'] if unit['p_min_i'] > 0 else float('inf'))\n        sorted_candidates = [x for _, x in sorted(zip(avg_costs, candidates))]\n        for i in sorted_candidates:\n            unit = units_info[i]\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            u[i] = 1\n            lb[i] = lb_i\n            ub[i] = ub_i\n            total_min += lb_i\n            total_max += ub_i\n            if total_max >= load:\n                break\n                \n    for i in range(n_units):\n        if u[i] == 1:\n            p[i] = lb[i]\n    \n    total_gen = sum(p)\n    remaining = load - total_gen\n    if remaining > 1e-5:\n        can_increase = [i for i in range(n_units) if u[i] == 1 and p[i] < ub[i]]\n        while remaining > 1e-5 and can_increase:\n            mc = []\n            for i in can_increase:\n                unit = units_info[i]\n                mc.append(unit['b_i'] + 2 * unit['c_i'] * p[i])\n            min_idx = np.argmin(mc)\n            i_cheap = can_increase[min_idx]\n            avail = min(ub[i_cheap] - p[i_cheap], remaining)\n            p[i_cheap] += avail\n            remaining -= avail\n            if p[i_cheap] >= ub[i_cheap] - 1e-5:\n                can_increase.pop(min_idx)\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00013,
          "gap_price_rate": 0.03464,
          "fitness": 0.01739
     },
     {
          "name": "commit_units_by_heuristic",
          "algorithm": "1. Identify must-run units (forced on) due to minimum up-time or shutdown ramp constraints\n2. Identify must-off units (forced off) due to minimum down-time constraints\n3. Keep currently online non-must-off units committed\n4. If committed units' capacity is insufficient, turn on additional units based on normalized startup cost\n5. Perform economic dispatch respecting power limits and ramp constraints\n6. Dispatch using quadratic programming to minimize production cost\n\n",
          "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef commit_units_by_heuristic(units_info, load):\n    num_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    free_off = []\n    committed = []\n    \n    # Identify forced on/off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n                committed.append(i)\n        elif unit['u_i_0'] == 0:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Add non-forced-off units that are currently online\n    for i, unit in enumerate(units_info):\n        if i not in forced_on and i not in forced_off and unit['u_i_0'] == 1:\n            committed.append(i)\n    \n    # Calculate available capacity\n    total_min = 0\n    total_max = 0\n    bounds = {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (lb, ub)\n        total_min += lb\n        total_max += ub\n    \n    # Start additional units if needed\n    if total_max < load:\n        cost_ranks = []\n        for i in free_off:\n            unit = units_info[i]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * max_i + \n                          unit['c_i'] * max_i**2 + unit['s_i']) / max_i\n            cost_ranks.append((i, cost_per_mw))\n        cost_ranks.sort(key=lambda x: x[1])\n        \n        for idx, _ in cost_ranks:\n            if total_max >= load:\n                break\n            unit = units_info[idx]\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += unit['p_min_i']\n            total_max += max_i\n            bounds[idx] = (unit['p_min_i'], max_i)\n            committed.append(idx)\n    \n    # Prepare economic dispatch\n    comm_idx = sorted(committed)\n    b_arr = np.array([units_info[i]['b_i'] for i in comm_idx])\n    c_arr = np.array([units_info[i]['c_i'] for i in comm_idx])\n    lbs = np.array([bounds[i][0] for i in comm_idx])\n    ubs = np.array([bounds[i][1] for i in comm_idx])\n    x0 = (lbs + ubs) / 2\n    \n    # Define objective and constraints\n    def objective(p):\n        return np.sum(b_arr * p + c_arr * p**2)\n    \n    constraints = (\n        {'type': 'eq', 'fun': lambda p: np.sum(p) - load},\n        {'type': 'ineq', 'fun': lambda p: p - lbs},\n        {'type': 'ineq', 'fun': lambda p: ubs - p}\n    )\n    \n    # Solve quadratic program\n    result = minimize(objective, x0, method='SLSQP', \n                     constraints=constraints, \n                     bounds=list(zip(lbs, ubs)))\n    \n    # Prepare output schedule\n    schedules = np.zeros((2, num_units))\n    for j, i in enumerate(comm_idx):\n        schedules[0, i] = 1\n        schedules[1, i] = max(min(result.x[j], ubs[j]), lbs[j])\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00013,
          "gap_price_rate": 0.03605,
          "fitness": 0.01809
     }
]