[
     {
          "name": "novel_rolling_commitment_v1",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units considering startup/shutdown ramp limits\n2. Classify units:\n   - Must-on: Online units violating min-up time OR offline units exceeding shutdown ramp\n   - Must-off: Offline units violating min-down time\n   - Flexible: Other units\n3. Commit must-on units and set must-off units to offline\n4. Compute effective cost for flexible units (amortizing startup costs over min output)\n5. Commit flexible units incrementally by ascending effective cost until capacity >= load\n6. Decommit expensive flexible units while maintaining capacity coverage\n7. Assign outputs:\n   a) If total min capacity > load: Set outputs to min values\n   b) Else if total max capacity < load: Set outputs to max values\n   c) Else: Perform economic dispatch via lambda iteration\n8. Set uncommitted units offline with zero output\n\n",
          "code": "import numpy as np\n\ndef novel_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Precompute min/max outputs with ramp constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_output[i] = unit['p_min_i']\n            max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize committed units\n    committed = set(must_on)\n    total_min = sum(min_output[i] for i in must_on)\n    total_max = sum(max_output[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    eff_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        min_out = min_output[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        else:\n            cost = (unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        eff_costs.append((cost, i))\n    \n    # Commit flexible units by ascending cost\n    eff_costs_sorted = sorted(eff_costs, key=lambda x: x[0])\n    for cost, i in eff_costs_sorted:\n        if total_max < load:\n            committed.add(i)\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    # Decommit expensive units while maintaining coverage\n    decommit_candidates = sorted(\n        [i for i in committed if i not in must_on],\n        key=lambda i: eff_costs[[idx for c, idx in eff_costs_sorted].index(i)][0],\n        reverse=True\n    )\n    for i in decommit_candidates:\n        if total_max - max_output[i] >= load:\n            committed.remove(i)\n            total_min -= min_output[i]\n            total_max -= max_output[i]\n    \n    # Initialize output arrays\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    # Assign outputs based on commitment status\n    if total_min > load:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = min_output[i]\n    elif total_max < load:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = max_output[i]\n    else:\n        # Economic dispatch via lambda iteration\n        indices = list(committed)\n        low_lam = 0\n        high_lam = 0\n        \n        for i in indices:\n            unit = units_info[i]\n            ic_min = unit['b_i'] + 2 * unit['c_i'] * min_output[i]\n            ic_max = unit['b_i'] + 2 * unit['c_i'] * max_output[i]\n            low_lam = min(low_lam, ic_min) if low_lam != 0 else ic_min\n            high_lam = max(high_lam, ic_max) if high_lam != 0 else ic_max\n        \n        low_lam -= 100\n        high_lam += 100\n        tol = 0.01\n        max_iter = 1000\n        \n        for _ in range(max_iter):\n            lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i in indices:\n                unit = units_info[i]\n                p_opt = max(min_output[i], min(max_output[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n                total_p += p_opt\n            \n            if abs(total_p - load) < tol:\n                break\n            if total_p < load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        for i in indices:\n            unit = units_info[i]\n            p_opt = max(min_output[i], min(max_output[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n            u_out[i] = 1\n            p_out[i] = p_opt\n    \n    # Set uncommitted units to offline\n    schedules = np.vstack((u_out, p_out))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00431,
          "gap_price_rate": 0.00817,
          "fitness": 0.00624
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min and max outputs for each unit considering current state and ramp limits, ensuring feasible operation range\n2. Classify units:\n   - Must-on: Units violating min-up time or shutdown ramp constraints\n   - Must-off: Units violating min-down time constraints\n   - Flexible: Remaining units\n3. Calculate amortized effective cost (fixed + startup + variable costs) using average power (min_max average) for flexible units\n4. Commit must-on units and calculate total capacity\n5. Commit flexible units in ascending cost order until total max capacity >= load\n6. Decommit flexible units in descending cost order while maintaining max capacity >= load\n7. For final committed set:\n   a) Assign min outputs if total min output > load\n   b) Assign max outputs if total max output < load\n   c) Perform lambda iteration for economic dispatch otherwise\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v2(units_info, load):\n    n = len(units_info)\n    u_final = [0] * n\n    p_final = [0.0] * n\n    min_outputs = [0.0] * n\n    max_outputs = [0.0] * n\n\n    # Step 1: Precompute ramp-constrained min/max outputs\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        \n        if u_i_0 == 1:  # Unit was online\n            min_out = max(p_min_i, p_i_0 - unit['p_down_i'])\n            max_out = min(p_max_i, p_i_0 + unit['p_up_i'])\n        else:  # Unit was offline\n            min_out = p_min_i\n            max_out = min(p_max_i, unit['p_start_i'])\n        \n        # Ensure feasibility\n        if min_out > max_out:\n            min_out = max_out = (min_out + max_out) / 2.0\n        \n        min_outputs[i] = min_out\n        max_outputs[i] = max_out\n    \n    # Step 2: Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flexible_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if (t_i_0 > 0 and t_i_0 < t_on_min_i) or p_i_0 > unit['p_shut_i']:\n                must_on_indices.append(i)\n            else:\n                flexible_indices.append(i)\n        else:\n            if t_i_0 < 0 and abs(t_i_0) < t_off_min_i:\n                must_off_indices.append(i)\n            else:\n                flexible_indices.append(i)\n    \n    # Step 3: Compute effective costs for flexible units\n    effective_costs = [float('inf')] * n\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        p_avg = (min_outputs[i] + max_outputs[i]) / 2.0\n        if p_avg == 0:  # Handle zero division\n            effective_costs[i] = float('inf')\n            continue\n        \n        # Calculate fixed + startup costs\n        total_fixed_cost = unit['a_i']\n        if unit['u_i_0'] == 0:  # Only include startup cost if transitioning from off\n            total_fixed_cost += unit['s_i']\n        \n        # Calculate variable costs at average power\n        variable_cost = unit['b_i'] * p_avg + unit['c_i'] * (p_avg ** 2)\n        effective_costs[i] = (total_fixed_cost + variable_cost) / p_avg\n    \n    # Initialize committed set and capacity\n    committed_set = set(must_on_indices)\n    total_min = sum(min_outputs[i] for i in must_on_indices)\n    total_max = sum(max_outputs[i] for i in must_on_indices)\n    \n    # Step 5: Commit flexible units by cost\n    sorted_flex = sorted(flexible_indices, key=lambda i: effective_costs[i])\n    \n    for i in sorted_flex:\n        if total_max >= load:\n            break\n        committed_set.add(i)\n        total_min += min_outputs[i]\n        total_max += max_outputs[i]\n    \n    # Step 6: Decommit expensive flexible units\n    flexible_in_commit = [i for i in committed_set if i in flexible_indices]\n    sorted_decommit = sorted(flexible_in_commit, key=lambda i: effective_costs[i], reverse=True)\n    \n    for i in sorted_decommit:\n        test_max = total_max - max_outputs[i]\n        if test_max >= load:\n            committed_set.remove(i)\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n    \n    # Step 7: Dispatch power\n    comm_min = total_min\n    comm_max = total_max\n    \n    if comm_min > load:  # Over-generation case\n        for i in committed_set:\n            u_final[i] = 1\n            p_final[i] = min_outputs[i]\n    elif comm_max < load:  # Under-generation case\n        for i in committed_set:\n            u_final[i] = 1\n            p_final[i] = max_outputs[i]\n    else:  # Economic dispatch\n        b_list = []\n        c_list = []\n        min_list = []\n        max_list = []\n        idx_list = list(committed_set)\n        \n        for i in idx_list:\n            b_list.append(units_info[i]['b_i'])\n            c_list.append(units_info[i]['c_i'])\n            min_list.append(min_outputs[i])\n            max_list.append(max_outputs[i])\n        \n        # Lambda iteration initialization\n        tolerance = 0.001\n        low_bound = min(b_i + 2 * c_i * min_p for b_i, c_i, min_p in zip(b_list, c_list, min_list))\n        high_bound = max(b_i + 2 * c_i * max_p for b_i, c_i, max_p in zip(b_list, c_list, max_list))\n        mid = (low_bound + high_bound) / 2.0\n        power_sum = 0.0\n        max_iter = 1000\n        iter_count = 0\n        \n        # Iterate until convergence\n        while abs(high_bound - low_bound) > tolerance and iter_count < max_iter:\n            mid = (low_bound + high_bound) / 2.0\n            power_sum = 0.0\n            for j in range(len(b_list)):\n                p_unconstrained = (mid - b_list[j]) / (2 * c_list[j])\n                p_clamped = max(min_list[j], min(max_list[j], p_unconstrained))\n                power_sum += p_clamped\n            \n            if power_sum < load:\n                low_bound = mid\n            else:\n                high_bound = mid\n            iter_count += 1\n        \n        # Final output assignment\n        for j, i in enumerate(idx_list):\n            p_unconstrained = (mid - b_list[j]) / (2 * c_list[j])\n            p_final[i] = max(min_list[j], min(max_list[j], p_unconstrained))\n            u_final[i] = 1\n    \n    # Step 8: Set uncommitted units\n    for i in range(n):\n        if i not in committed_set:\n            u_final[i] = 0\n            p_final[i] = 0.0\n\n    return np.array([u_final, p_final])",
          "from": "mutation",
          "gap_power_rate": 0.00505,
          "gap_price_rate": 0.00881,
          "fitness": 0.00693
     },
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units if committed\n2. Identify must-on units (violating min-up time or shutdown ramp)\n3. Identify must-off units (violating min-down time)\n4. Commit must-on units and compute current capacity ranges\n5. Calculate effective cost per MW for flexible units (amortized startup cost + production cost at min output)\n6. Commit flexible units incrementally by ascending effective cost until capacity covers load\n7. Decommit expensive flexible units if min output exceeds load while maintaining capacity feasibility\n8. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load (should not occur)\n   c) Perform lambda iteration for economic dispatch otherwise\n9. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    min_potential = [0] * n_units\n    max_potential = [0] * n_units\n    \n    # Precompute min/max potential outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_potential[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_potential[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_potential[i] = unit['p_min_i']\n            max_potential[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on_indices = []\n    must_off_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1: \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n        elif unit['u_i_0'] == 0:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n    \n    # Initialize committed units and capacity\n    committed_indices = set(must_on_indices)\n    total_min = sum(min_potential[i] for i in must_on_indices)\n    total_max = sum(max_potential[i] for i in must_on_indices)\n    \n    # Process flexible units\n    flexible_indices = [i for i in range(n_units) if i not in must_on_indices and i not in must_off_indices]\n    cost_data = []\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        min_pwr = min_potential[i]\n        if unit['u_i_0'] == 0:  # Startup required\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        else:  # Already running\n            cost_per_mw = (unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        cost_data.append((cost_per_mw, i))\n    \n    # Commit flexible units by ascending cost\n    cost_data.sort(key=lambda x: x[0])\n    flexible_committed = []\n    \n    for cost_val, i in cost_data:\n        if total_max < load:  # Only add if capacity insufficient\n            committed_indices.add(i)\n            flexible_committed.append(i)\n            total_min += min_potential[i]\n            total_max += max_potential[i]\n    \n    # Decommit expensive units if overgeneration occurs\n    flexible_committed.sort(key=lambda i: cost_data[flexible_indices.index(i)][0], reverse=True)\n    for i in flexible_committed:\n        if i not in committed_indices:\n            continue\n        new_min = total_min - min_potential[i]\n        new_max = total_max - max_potential[i]\n        if new_min <= load and new_max >= load:\n            committed_indices.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch power allocation\n    p_outputs = [0] * n_units\n    \n    # Case 1: Overgeneration unavoidable\n    if total_min > load:\n        for i in committed_indices:\n            p_outputs[i] = min_potential[i]\n    # Case 2: Shouldn't occur due to commitment logic\n    elif total_max < load:\n        for i in committed_indices:\n            p_outputs[i] = max_potential[i]\n    # Case 3: Economic dispatch required\n    else:\n        committed_list = list(committed_indices)\n        low_lambda = 0\n        high_lambda = 0\n        \n        # Set lambda search bounds\n        for i in committed_list:\n            unit = units_info[i]\n            cost_at_min = unit['b_i'] + 2 * unit['c_i'] * min_potential[i]\n            cost_at_max = unit['b_i'] + 2 * unit['c_i'] * max_potential[i]\n            high_lambda = max(high_lambda, cost_at_min, cost_at_max)\n        high_lambda *= 2  # Expand upper bound\n        \n        # Lambda iteration\n        tol = 0.01\n        max_iter = 100\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for i in committed_list:\n                unit = units_info[i]\n                min_p = min_potential[i]\n                max_p = max_potential[i]\n                if unit['c_i'] == 0:  # Linear units\n                    p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n                else:  # Quadratic units\n                    p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(min_p, min(max_p, p_val))\n                total_power += p_val\n            \n            if abs(total_power - load) < tol:\n                break\n            elif total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Apply final dispatch\n        for i in committed_list:\n            unit = units_info[i]\n            min_p = min_potential[i]\n            max_p = max_potential[i]\n            if unit['c_i'] == 0:\n                p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_p, min(max_p, p_val))\n            p_outputs[i] = p_val\n    \n    # Prepare output schedules\n    u_vector = [1 if i in committed_indices else 0 for i in range(n_units)]\n    schedules = np.array([u_vector, p_outputs])\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00501,
          "gap_price_rate": 0.00888,
          "fitness": 0.00695
     },
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for each unit considering its previous state and ramp limits\n2. Classify units as must-on (violating min-up time or shutdown ramp constraints), must-off (violating min-down time constraints), or flexible\n3. For flexible units, calculate effective cost: (a_i + s_i + b_i * p_avg + c_i * p_avg^2) / p_avg, where p_avg = (p_min_cur + p_max_cur)/2\n4. Commit must-on units, then commit flexible units by ascending effective cost until total max output >= load\n5. If total min output > load, decommit expensive flexible units in descending cost order while maintaining total max >= load\n6. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load\n   c) Perform lambda iteration for economic dispatch considering both quadratic and linear costs\n7. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_outputs = [0] * n_units\n    p_outputs = [0.0] * n_units\n    p_min_cur = [0.0] * n_units\n    p_max_cur = [0.0] * n_units\n\n    # Step 1: Precompute ramp-constrained min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            p_min_cur[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Unit was offline\n            p_min_cur[i] = unit['p_min_i']\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 2: Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # Was offline\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 3: Calculate effective cost for flexible units\n    effective_cost = [0.0] * n_units\n    for i in flexible:\n        unit = units_info[i]\n        p_avg = (p_min_cur[i] + p_max_cur[i]) / 2.0\n        if p_avg == 0:\n            effective_cost[i] = float('inf')\n        else:\n            fixed_cost = unit['a_i'] + unit['s_i']\n            variable_cost = unit['b_i'] * p_avg + unit['c_i'] * p_avg**2\n            effective_cost[i] = (fixed_cost + variable_cost) / p_avg\n    \n    # Step 4: Commit units\n    committed = set(must_on)\n    total_min = sum(p_min_cur[i] for i in committed)\n    total_max = sum(p_max_cur[i] for i in committed)\n    \n    sorted_flex = sorted(flexible, key=lambda i: effective_cost[i])\n    for i in sorted_flex:\n        if total_max < load:\n            committed.add(i)\n            total_min += p_min_cur[i]\n            total_max += p_max_cur[i]\n        else:\n            break\n    \n    # Step 5: Decommit if over-committed\n    if total_min > load:\n        committed_flex = [i for i in committed if i in flexible]\n        sorted_flex_decom = sorted(committed_flex, key=lambda i: effective_cost[i], reverse=True)\n        for i in sorted_flex_decom:\n            new_total_max = total_max - p_max_cur[i]\n            if new_total_max >= load:\n                committed.remove(i)\n                total_min -= p_min_cur[i]\n                total_max = new_total_max\n                if total_min <= load:\n                    break\n    \n    # Step 6: Dispatch\n    for i in committed:\n        u_outputs[i] = 1\n    \n    dispatch_min = sum(p_min_cur[i] for i in committed)\n    dispatch_max = sum(p_max_cur[i] for i in committed)\n    \n    if dispatch_min > load:\n        for i in committed:\n            p_outputs[i] = p_min_cur[i]\n    elif dispatch_max < load:\n        for i in committed:\n            p_outputs[i] = p_max_cur[i]\n    else:\n        committed_list = list(committed)\n        n_committed = len(committed_list)\n        mins = [p_min_cur[i] for i in committed_list]\n        maxs = [p_max_cur[i] for i in committed_list]\n        bs = [units_info[i]['b_i'] for i in committed_list]\n        cs = [units_info[i]['c_i'] for i in committed_list]\n        \n        # Find lambda bounds\n        min_inc = float('inf')\n        max_inc = -float('inf')\n        for i in range(n_committed):\n            if cs[i] > 0:\n                low_inc = 2 * cs[i] * mins[i] + bs[i]\n                high_inc = 2 * cs[i] * maxs[i] + bs[i]\n            else:\n                low_inc = high_inc = bs[i]\n            min_inc = min(min_inc, low_inc)\n            max_inc = max(max_inc, high_inc)\n        \n        lambda_low = min_inc - 1\n        lambda_high = max_inc + 1\n        lambda_mid = (lambda_low + lambda_high) / 2\n        tol = 0.0001\n        \n        for _ in range(100):\n            total_p = 0\n            for i in range(n_committed):\n                if cs[i] > 0:\n                    p_ideal = (lambda_mid - bs[i]) / (2 * cs[i])\n                    p_clamped = max(mins[i], min(maxs[i], p_ideal))\n                else:\n                    p_clamped = maxs[i] if lambda_mid > bs[i] else mins[i]\n                total_p += p_clamped\n            \n            if abs(total_p - load) < tol:\n                break\n            if total_p < load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            lambda_mid = (lambda_low + lambda_high) / 2\n        \n        # Assign final outputs\n        for i in range(n_committed):\n            if cs[i] > 0:\n                p_ideal = (lambda_mid - bs[i]) / (2 * cs[i])\n                p_val = max(mins[i], min(maxs[i], p_ideal))\n            else:\n                p_val = maxs[i] if lambda_mid > bs[i] else mins[i]\n            idx = committed_list[i]\n            p_outputs[idx] = p_val\n    \n    # Step 7: Format output\n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u_outputs\n    schedules[1, :] = p_outputs\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00869,
          "fitness": 0.00706
     },
     {
          "name": "enhanced_rolling_uc",
          "algorithm": "1. Classify units into must-on (forced online due to min-up-time or shutdown ramp constraints), must-off (forced offline due to min-down-time constraints), and flexible units\n2. Precompute ramp-constrained output ranges for all units considering their previous state\n3. Commit must-on units and calculate total min/max capacity\n4. Compute effective amortized cost (including startup costs) for flexible units and sort by cost\n5. Commit flexible units in ascending cost order until total max capacity >= load\n6. If total min capacity > load, decommit flexible units in descending cost order while maintaining total max capacity >= load\n7. For final committed set:\n   a) If total min capacity > load, set outputs to min\n   b) Else if total max capacity < load, set outputs to max\n   c) Else perform economic dispatch via lambda iteration to minimize production costs\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc(units_info, load):\n    num_units = len(units_info)\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units)\n    \n    # Precompute ramp-constrained bounds for each unit\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        elif unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Commit must-on units\n    committed = set(must_on)\n    total_min = sum(min_p[i] for i in must_on)\n    total_max = sum(max_p[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        min_cost = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                    unit['c_i'] * min_p[i]**2 + startup_cost)\n        costs.append((min_cost / min_p[i], i))\n    \n    # Commit flexible units in cost order\n    costs.sort(key=lambda x: x[0])\n    for cost_val, i in costs:\n        if total_max >= load:\n            break\n        committed.add(i)\n        total_min += min_p[i]\n        total_max += max_p[i]\n    \n    # Decommit expensive flexible units if overcommitted\n    committed_flex = [i for i in committed if i in flexible]\n    if total_min > load:\n        # Sort committed flexible units by cost descending\n        costs_flex = [(cost_val, i) for cost_val, i in costs if i in committed]\n        costs_flex.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in costs_flex:\n            if total_min - min_p[i] <= load:\n                break\n            if total_max - max_p[i] >= load:\n                committed.remove(i)\n                total_min -= min_p[i]\n                total_max -= max_p[i]\n    \n    # Case 1: Total min output > load\n    if total_min > load:\n        for i in committed:\n            u[i] = 1\n            p[i] = min_p[i]\n        return np.array([u, p])\n    \n    # Case 2: Total max output < load\n    if total_max < load:\n        for i in committed:\n            u[i] = 1\n            p[i] = max_p[i]\n        return np.array([u, p])\n    \n    # Case 3: Perform economic dispatch\n    # Prepare parameters for committed units\n    min_dispatch = []\n    max_dispatch = []\n    b_list = []\n    c_list = []\n    idx_mapping = []\n    for i in committed:\n        min_dispatch.append(min_p[i])\n        max_dispatch.append(max_p[i])\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n        idx_mapping.append(i)\n    \n    # Initialize dispatch parameters\n    n = len(min_dispatch)\n    dispatch_min = np.array(min_dispatch)\n    dispatch_max = np.array(max_dispatch)\n    b_arr = np.array(b_list)\n    c_arr = np.array(c_list)\n    \n    # Find lambda bounds\n    marginal_min = b_arr + 2 * c_arr * dispatch_min\n    marginal_max = b_arr + 2 * c_arr * dispatch_max\n    lambda_low = np.min(marginal_min)\n    lambda_high = np.max(marginal_max)\n    \n    # Lambda iteration\n    tol = 1e-5\n    max_iter = 1000\n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n        total_current = np.sum(p_dispatch)\n        \n        if abs(total_current - load) < tol:\n            break\n        elif total_current < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        # Use the best solution from last iteration\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n    \n    # Assign final dispatch\n    for idx, val in zip(idx_mapping, p_dispatch):\n        u[idx] = 1\n        p[idx] = val\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.0071
     },
     {
          "name": "hybrid_rolling_commitment",
          "algorithm": "1. Precompute ramp-constrained min/max output for each unit considering previous state and ramp limits\n2. Classify units as must-on (due to min-up or shutdown constraints), must-off (min-down constraints), or flexible\n3. For flexible units, calculate effective cost: (fixed + startup + variable costs at min output)/min output\n4. Commit must-on units then cheapest flexible units until max capacity >= load\n5. If over-committed (min output > load), remove costly flexible units while maintaining capacity\n6. Dispatch:\n   a) Total min >= load: assign min outputs\n   b) Total max <= load: assign max outputs\n   c) Otherwise: economic dispatch via lambda iteration\n7. Set uncommitted units to off (0 output)\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment(units_info, load):\n    n = len(units_info)\n    min_outputs = np.zeros(n)\n    max_outputs = np.zeros(n)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            online_time = unit['t_i_0']\n            min_up = unit['t_on_min_i']\n            if online_time < min_up or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_time = -unit['t_i_0']\n            min_down = unit['t_off_min_i']\n            if offline_time < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        cost_at_min = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i] ** 2\n        if unit['u_i_0'] == 0:\n            cost_at_min += unit['s_i']\n        effective_costs.append(cost_at_min / min_outputs[i] if min_outputs[i] > 0 else float('inf'))\n    \n    sorted_flexible = [x for _, x in sorted(zip(effective_costs, flexible))]\n    \n    committed = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    flexible_committed = []\n    \n    for idx in sorted_flexible:\n        if total_max < load:\n            committed.add(idx)\n            flexible_committed.append(idx)\n            total_min += min_outputs[idx]\n            total_max += max_outputs[idx]\n        else:\n            break\n    \n    if total_min > load:\n        temp = []\n        for idx in flexible_committed:\n            unit = units_info[idx]\n            cost_at_min = unit['a_i'] + unit['b_i'] * min_outputs[idx] + unit['c_i'] * min_outputs[idx] ** 2\n            if unit['u_i_0'] == 0:\n                cost_at_min += unit['s_i']\n            ec = cost_at_min / min_outputs[idx] if min_outputs[idx] > 0 else float('inf')\n            temp.append((ec, idx))\n        temp.sort(reverse=True)\n        \n        for ec, idx in temp:\n            if total_min - min_outputs[idx] < load:\n                continue\n            if total_max - max_outputs[idx] >= load:\n                total_min -= min_outputs[idx]\n                total_max -= max_outputs[idx]\n                committed.remove(idx)\n                flexible_committed.remove(idx)\n                if total_min < load:\n                    break\n    \n    u = np.zeros(n, dtype=int)\n    p = np.zeros(n)\n    \n    for i in committed:\n        u[i] = 1\n    \n    if committed:\n        total_min = sum(min_outputs[i] for i in committed)\n        total_max = sum(max_outputs[i] for i in committed)\n        \n        if total_min >= load:\n            for i in committed:\n                p[i] = min_outputs[i]\n        elif total_max <= load:\n            for i in committed:\n                p[i] = max_outputs[i]\n        else:\n            comm_list = list(committed)\n            b_arr = np.array([units_info[i]['b_i'] for i in comm_list])\n            c_arr = np.array([units_info[i]['c_i'] for i in comm_list])\n            min_arr = np.array([min_outputs[i] for i in comm_list])\n            max_arr = np.array([max_outputs[i] for i in comm_list])\n            \n            low_lam = np.min(2 * c_arr * min_arr + b_arr)\n            high_lam = np.max(2 * c_arr * max_arr + b_arr)\n            mid_lam = (low_lam + high_lam) / 2\n            tol = 0.01\n            max_iter = 100\n            \n            for _ in range(max_iter):\n                p_arr = (mid_lam - b_arr) / (2 * c_arr)\n                p_arr = np.clip(p_arr, min_arr, max_arr)\n                total_p = np.sum(p_arr)\n                if abs(total_p - load) < tol:\n                    break\n                if total_p < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n                mid_lam = (low_lam + high_lam) / 2\n            \n            for idx, value in zip(comm_list, p_arr):\n                p[idx] = value\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units\n2. Identify must-on units (violating min-up time or shutdown ramp constraints) and must-off units (violating min-down time constraints)\n3. Commit must-on units, set must-off units to off\n4. Calculate amortized effective cost for flexible units (startup cost + min production cost, scaled by min output)\n5. Commit flexible units incrementally by ascending effective cost until total max capacity covers load\n6. If total min output exceeds load, decommit expensive flexible units while maintaining capacity coverage\n7. Dispatch power:\n   a) Set to min outputs if total min > load\n   b) Set to max outputs if total max < load\n   c) Perform lambda iteration for economic dispatch otherwise (handling quadratic and linear costs with swing units)\n8. Set uncommitted units to off with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    # Precompute ramp-constrained min/max outputs and identify units\n    units = []\n    for idx, unit_dict in enumerate(units_info):\n        u_i_0 = unit_dict['u_i_0']\n        p_i_0 = unit_dict['p_i_0']\n        p_min_i = unit_dict['p_min_i']\n        p_max_i = unit_dict['p_max_i']\n        p_up_i = unit_dict['p_up_i']\n        p_down_i = unit_dict['p_down_i']\n        p_start_i = unit_dict['p_start_i']\n        \n        # Ramp-constrained output limits\n        if u_i_0 == 1:\n            p_min_cur = max(p_min_i, p_i_0 - p_down_i)\n            p_max_cur = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            p_min_cur = p_min_i\n            p_max_cur = min(p_max_i, p_start_i)\n        \n        units.append({\n            'idx': idx,\n            'u_i_0': u_i_0,\n            'p_i_0': p_i_0,\n            't_i_0': unit_dict['t_i_0'],\n            'p_min_i': p_min_i,\n            'p_max_i': p_max_i,\n            'p_min_cur': p_min_cur,\n            'p_max_cur': p_max_cur,\n            't_on_min': unit_dict['t_on_min_i'],\n            't_off_min': unit_dict['t_off_min_i'],\n            'p_shut_i': unit_dict['p_shut_i'],\n            's_i': unit_dict['s_i'],\n            'a_i': unit_dict['a_i'],\n            'b_i': unit_dict['b_i'],\n            'c_i': unit_dict['c_i'],\n            'must_on': False,\n            'must_off': False,\n            'committed': False,\n            'eff_cost': 0.0,\n            'u_i': 0,\n            'p_i': 0.0\n        })\n    \n    # Identify must-on and must-off units\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min'] or unit['p_i_0'] > unit['p_shut_i']:\n                unit['must_on'] = True\n                unit['committed'] = True\n                unit['u_i'] = 1\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min']:\n            unit['must_off'] = True\n            unit['committed'] = False\n            unit['u_i'] = 0\n    \n    # Calculate effective costs for flexible units\n    flex_units = [u for u in units if not u['must_on'] and not u['must_off']]\n    for unit in flex_units:\n        if unit['u_i_0'] == 0:\n            prod_cost = unit['a_i'] + unit['b_i'] * unit['p_min_cur'] + unit['c_i'] * unit['p_min_cur']**2\n            unit['eff_cost'] = (unit['s_i'] + prod_cost) / unit['p_min_cur']\n        else:\n            prod_cost = unit['a_i'] + unit['b_i'] * unit['p_min_cur'] + unit['c_i'] * unit['p_min_cur']**2\n            unit['eff_cost'] = prod_cost / unit['p_min_cur']\n    flex_units_sorted = sorted(flex_units, key=lambda x: x['eff_cost'])\n    \n    # Commit must-on and flexible units\n    tot_min = sum(u['p_min_cur'] for u in units if u['committed'])\n    tot_max = sum(u['p_max_cur'] for u in units if u['committed'])\n    committed_flex = []\n    \n    for unit in flex_units_sorted:\n        if tot_max >= load:\n            break\n        tot_min += unit['p_min_cur']\n        tot_max += unit['p_max_cur']\n        unit['committed'] = True\n        unit['u_i'] = 1\n        committed_flex.append(unit)\n    \n    # Decommit expensive units if over minimum output\n    if tot_min > load:\n        committed_flex_sorted = sorted(committed_flex, key=lambda x: x['eff_cost'], reverse=True)\n        for unit in committed_flex_sorted:\n            new_min = tot_min - unit['p_min_cur']\n            new_max = tot_max - unit['p_max_cur']\n            if new_max >= load:\n                tot_min, tot_max = new_min, new_max\n                unit['committed'] = False\n                unit['u_i'] = 0\n                if tot_min <= load:\n                    break\n    \n    # Dispatch power\n    committed_units = [u for u in units if u['committed']]\n    tot_min = sum(u['p_min_cur'] for u in committed_units)\n    tot_max = sum(u['p_max_cur'] for u in committed_units)\n    \n    if tot_min > load:\n        for u in committed_units:\n            u['p_i'] = u['p_min_cur']\n    elif tot_max < load:\n        for u in committed_units:\n            u['p_i'] = u['p_max_cur']\n    else:\n        # Lambda iteration for economic dispatch\n        low = -1e9\n        high = 1e9\n        tol = 1.0\n        max_iter = 100\n        lambda_mid = 0.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (low + high) / 2.0\n            non_swing_out = 0.0\n            swing_units = []\n            \n            for unit in committed_units:\n                if unit['c_i'] == 0 and abs(lambda_mid - unit['b_i']) < 1e-5:\n                    swing_units.append(unit)\n                elif unit['c_i'] > 0:\n                    p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                    non_swing_out += max(unit['p_min_cur'], min(p_i, unit['p_max_cur']))\n                else:\n                    if lambda_mid < unit['b_i']:\n                        non_swing_out += unit['p_min_cur']\n                    else:\n                        non_swing_out += unit['p_max_cur']\n            \n            swing_min = sum(u['p_min_cur'] for u in swing_units)\n            swing_max = sum(u['p_max_cur'] for u in swing_units)\n            swing_needed = load - non_swing_out\n            \n            if swing_needed < swing_min:\n                total_out = non_swing_out + swing_min\n            elif swing_needed > swing_max:\n                total_out = non_swing_out + swing_max\n            else:\n                total_out = non_swing_out + swing_needed\n            \n            if total_out < load:\n                low = lambda_mid\n            else:\n                high = lambda_mid\n            \n            if abs(total_out - load) < tol:\n                break\n        \n        # Apply final dispatch\n        non_swing_out = 0.0\n        swing_units = []\n        for unit in committed_units:\n            if unit['c_i'] == 0 and abs(lambda_mid - unit['b_i']) < 1e-5:\n                swing_units.append(unit)\n            elif unit['c_i'] > 0:\n                p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                unit['p_i'] = max(unit['p_min_cur'], min(p_i, unit['p_max_cur']))\n                non_swing_out += unit['p_i']\n            else:\n                if lambda_mid < unit['b_i']:\n                    unit['p_i'] = unit['p_min_cur']\n                else:\n                    unit['p_i'] = unit['p_max_cur']\n                non_swing_out += unit['p_i']\n        \n        # Distribute swing load\n        swing_needed = load - non_swing_out\n        if swing_needed <= 0:\n            for unit in swing_units:\n                unit['p_i'] = unit['p_min_cur']\n        else:\n            swing_range = swing_max - swing_min\n            if swing_range > 0:\n                for unit in swing_units:\n                    alloc = min(swing_needed, unit['p_max_cur'] - unit['p_min_cur'])\n                    unit['p_i'] = unit['p_min_cur'] + alloc\n                    swing_needed -= alloc\n                    if swing_needed <= 0:\n                        break\n    \n    # Output schedule\n    schedules = np.zeros((2, len(units_info)))\n    for idx, unit in enumerate(units):\n        schedules[0, idx] = unit['u_i']\n        schedules[1, idx] = unit['p_i']\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00877,
          "fitness": 0.00716
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": "1. Categorize units into must-on (must remain on due to min up-time or shutdown ramp constraints), must-off (must remain off due to min down-time constraints), and flexible units.\n2. Precompute ramp-constrained min and max outputs for every unit if committed.\n3. Commit must-on units, calculate current total min and max output.\n4. Compute effective cost for flexible units (amortized startup cost over minimum output) and sort ascending.\n5. Commit flexible units in cost order until total max output >= load.\n6. If total min output > load, decommit expensive flexible units (descending cost order) while maintaining total max >= load.\n7. For final committed set:\n   a) If total min output > load, assign min outputs.\n   b) Else if total max output < load, assign max outputs.\n   c) Else perform economic dispatch via lambda iteration to minimize quadratic production costs.\n8. Set uncommitted units to off with zero output.\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    # Initialize arrays\n    num_units = len(units_info)\n    u_list = [0.0] * num_units\n    p_list = [0.0] * num_units\n    min_outputs = [0.0] * num_units\n    max_outputs = [0.0] * num_units\n    effective_costs = [0.0] * num_units\n\n    # Step 1: Categorize units and precompute outputs\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Compute ramp-constrained min/max outputs\n        if unit['u_i_0'] == 1:  # Previously online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            \n        min_outputs[i] = min_out\n        max_outputs[i] = max_out\n        \n        # Categorization\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Precompute effective costs\n        if min_out > 0:\n            prod_cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            effective_costs[i] = (prod_cost + unit['s_i']) / min_out\n        else:\n            effective_costs[i] = 1e12  # Large number if min_out=0\n\n    # Step 2: Commit must-on units\n    committed_set = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    \n    # Step 3: Sort flexible units by effective cost\n    flexible = sorted(flexible, key=lambda i: effective_costs[i])\n    \n    # Step 4: Commit flexible until capacity >= load\n    for i in flexible:\n        if total_max < load:\n            committed_set.add(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    # Step 5: Backward pass for over-commitment\n    if total_min > load:\n        expensive_flex = sorted(\n            [i for i in committed_set if i not in must_on],\n            key=lambda i: effective_costs[i],\n            reverse=True\n        )\n        for i in expensive_flex:\n            new_min = total_min - min_outputs[i]\n            new_max = total_max - max_outputs[i]\n            if new_max >= load:\n                committed_set.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= load:\n                    break\n    \n    # Step 6: Assign outputs\n    # Case 1: Overgeneration (set to min)\n    if total_min > load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = min_outputs[i]\n    # Case 2: Undergeneration (set to max)\n    elif total_max < load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = max_outputs[i]\n    # Case 3: Economic dispatch\n    else:\n        # Prepare for dispatch\n        B = []\n        C = []\n        P_MIN = []\n        P_MAX = []\n        commit_indices = sorted(committed_set)\n        \n        for i in commit_indices:\n            unit = units_info[i]\n            B.append(unit['b_i'])\n            C.append(unit['c_i'])\n            P_MIN.append(min_outputs[i])\n            P_MAX.append(max_outputs[i])\n        \n        n = len(commit_indices)\n        if n == 0:  # No units to dispatch\n            pass\n        else:\n            # Lambda iteration setup\n            low_lam = 1e12\n            high_lam = -1e12\n            \n            for i in range(n):\n                b = B[i]\n                c = C[i]\n                p_min = P_MIN[i]\n                p_max = P_MAX[i]\n                if c == 0:  # Linear unit\n                    low_lam = min(low_lam, b)\n                    high_lam = max(high_lam, b)\n                else:  # Quadratic unit\n                    low_lam = min(low_lam, 2*c*p_min + b)\n                    high_lam = max(high_lam, 2*c*p_max + b)\n            \n            # Binary search\n            max_iter = 100\n            tol = 1e-3\n            for _ in range(max_iter):\n                mid_lam = (low_lam + high_lam) / 2.0\n                total_power = 0.0\n                p_dispatch = []\n                \n                for i in range(n):\n                    b = B[i]\n                    c = C[i]\n                    p_min = P_MIN[i]\n                    p_max = P_MAX[i]\n                    \n                    if c == 0:  # Linear\n                        p_i = p_max if mid_lam >= b else p_min\n                    else:  # Quadratic\n                        p_desired = (mid_lam - b) / (2 * c)\n                        p_i = min(max(p_desired, p_min), p_max)\n                    \n                    p_dispatch.append(p_i)\n                    total_power += p_i\n                \n                if abs(total_power - load) < tol:\n                    break\n                if total_power < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n            \n            # Assign dispatch results\n            for idx, i in enumerate(commit_indices):\n                u_list[i] = 1.0\n                p_list[i] = p_dispatch[idx]\n    \n    # Set uncommitted units\n    for i in range(num_units):\n        if i not in committed_set:\n            u_list[i] = 0.0\n            p_list[i] = 0.0\n    \n    return np.array([u_list, p_list])",
          "from": "mutation",
          "gap_power_rate": 0.00539,
          "gap_price_rate": 0.00901,
          "fitness": 0.0072
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for each unit considering its previous state and ramp limits\n2. Classify units as must-on (violating min-up time or shutdown ramp constraints), must-off (violating min-down time constraints), or flexible\n3. For flexible units, calculate effective cost: (s_i + a_i + b_i * p_min_cur_i + c_i * p_min_cur_i^2) / p_min_cur_i\n4. Commit must-on units, then commit flexible units by ascending effective cost until total max output >= load\n5. If total min output > load, decommit expensive flexible units in descending cost order while maintaining total max >= load\n6. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load\n   c) Perform lambda iteration for economic dispatch considering quadratic and linear costs\n7. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    p_min_cur = [0.0] * n_units\n    p_max_cur = [0.0] * n_units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    effective_costs = [0.0] * n_units\n    \n    # Precompute ramp-constrained min/max and classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            p_min_cur[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            p_min_cur[i] = unit['p_min_i']\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if unit['u_i_0'] == 1:  # Must-on conditions\n            must_on[i] = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n        else:  # Must-off conditions\n            down_time = -unit['t_i_0']  # t_i_0 negative for offline\n            must_off[i] = (down_time < unit['t_off_min_i'])\n    \n    # Initialize commitment states\n    committed = must_on[:]  # Must-on units are committed\n    flexible_indices = [i for i in range(n_units) if (not must_on[i] and not must_off[i])]\n    \n    # Calculate effective costs for flexible units\n    for i in flexible_indices:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min_cur[i] + unit['c_i'] * (p_min_cur[i] ** 2)\n        effective_costs[i] = cost / p_min_cur[i]\n    \n    # Sort flexible units by effective cost\n    sorted_flexible = sorted(flexible_indices, key=lambda i: effective_costs[i])\n    \n    # Commit flexible units until capacity >= load\n    total_max = sum(p_max_cur[i] for i in range(n_units) if committed[i])\n    for i in sorted_flexible:\n        if total_max >= load:\n            break\n        committed[i] = True\n        total_max += p_max_cur[i]\n    \n    # Decommit if overcommitted\n    total_min = sum(p_min_cur[i] for i in range(n_units) if committed[i])\n    flexible_committed = [i for i in flexible_indices if committed[i]]\n    if total_min > load:\n        sorted_expensive = sorted(flexible_committed, key=lambda i: effective_costs[i], reverse=True)\n        for i in sorted_expensive:\n            new_total_max = total_max - p_max_cur[i]\n            if new_total_max >= load:\n                committed[i] = False\n                total_min -= p_min_cur[i]\n                total_max = new_total_max\n            else:\n                break\n    \n    # Dispatch power\n    committed_indices = [i for i in range(n_units) if committed[i]]\n    total_min = sum(p_min_cur[i] for i in committed_indices)\n    total_max = sum(p_max_cur[i] for i in committed_indices)\n    \n    if total_min > load:\n        for i in committed_indices:\n            u_list[i] = 1\n            p_list[i] = p_min_cur[i]\n    elif total_max < load:\n        for i in committed_indices:\n            u_list[i] = 1\n            p_list[i] = p_max_cur[i]\n    elif committed_indices:\n        # Lambda iteration for economic dispatch\n        b_list = [units_info[i]['b_i'] for i in committed_indices]\n        c_list = [units_info[i]['c_i'] for i in committed_indices]\n        p_min_list = [p_min_cur[i] for i in committed_indices]\n        p_max_list = [p_max_cur[i] for i in committed_indices]\n        \n        tol = 0.1\n        max_iter = 1000\n        lambda_low = 0\n        lambda_high = 1e6\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for idx, i in enumerate(committed_indices):\n                if c_list[idx] == 0:\n                    if lambda_mid > b_list[idx]:\n                        p_val = p_max_list[idx]\n                    else:\n                        p_val = p_min_list[idx]\n                else:\n                    p_val = (lambda_mid - b_list[idx]) / (2 * c_list[idx])\n                    p_val = max(p_min_list[idx], min(p_max_list[idx], p_val))\n                total_p += p_val\n            \n            if abs(total_p - load) < tol:\n                break\n            if total_p < load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        for idx, i in enumerate(committed_indices):\n            u_list[i] = 1\n            if c_list[idx] == 0:\n                if lambda_mid > b_list[idx]:\n                    p_list[i] = p_max_list[idx]\n                else:\n                    p_list[i] = p_min_list[idx]\n            else:\n                p_val = (lambda_mid - b_list[idx]) / (2 * c_list[idx])\n                p_list[i] = max(p_min_list[idx], min(p_max_list[idx], p_val))\n    \n    return np.array([u_list, p_list])",
          "from": "mutation",
          "gap_power_rate": 0.0054,
          "gap_price_rate": 0.00901,
          "fitness": 0.00721
     }
]