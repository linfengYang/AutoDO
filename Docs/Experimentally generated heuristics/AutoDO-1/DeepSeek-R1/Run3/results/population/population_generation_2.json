[
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units if committed\n2. Identify must-on units (violating min-up time or shutdown ramp)\n3. Identify must-off units (violating min-down time)\n4. Commit must-on units and compute current capacity ranges\n5. Calculate effective cost per MW for flexible units (amortized startup cost + production cost at min output)\n6. Commit flexible units incrementally by ascending effective cost until capacity covers load\n7. Decommit expensive flexible units if min output exceeds load while maintaining capacity feasibility\n8. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load (should not occur)\n   c) Perform lambda iteration for economic dispatch otherwise\n9. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    min_potential = [0] * n_units\n    max_potential = [0] * n_units\n    \n    # Precompute min/max potential outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_potential[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_potential[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_potential[i] = unit['p_min_i']\n            max_potential[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on_indices = []\n    must_off_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1: \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n        elif unit['u_i_0'] == 0:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n    \n    # Initialize committed units and capacity\n    committed_indices = set(must_on_indices)\n    total_min = sum(min_potential[i] for i in must_on_indices)\n    total_max = sum(max_potential[i] for i in must_on_indices)\n    \n    # Process flexible units\n    flexible_indices = [i for i in range(n_units) if i not in must_on_indices and i not in must_off_indices]\n    cost_data = []\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        min_pwr = min_potential[i]\n        if unit['u_i_0'] == 0:  # Startup required\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        else:  # Already running\n            cost_per_mw = (unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        cost_data.append((cost_per_mw, i))\n    \n    # Commit flexible units by ascending cost\n    cost_data.sort(key=lambda x: x[0])\n    flexible_committed = []\n    \n    for cost_val, i in cost_data:\n        if total_max < load:  # Only add if capacity insufficient\n            committed_indices.add(i)\n            flexible_committed.append(i)\n            total_min += min_potential[i]\n            total_max += max_potential[i]\n    \n    # Decommit expensive units if overgeneration occurs\n    flexible_committed.sort(key=lambda i: cost_data[flexible_indices.index(i)][0], reverse=True)\n    for i in flexible_committed:\n        if i not in committed_indices:\n            continue\n        new_min = total_min - min_potential[i]\n        new_max = total_max - max_potential[i]\n        if new_min <= load and new_max >= load:\n            committed_indices.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch power allocation\n    p_outputs = [0] * n_units\n    \n    # Case 1: Overgeneration unavoidable\n    if total_min > load:\n        for i in committed_indices:\n            p_outputs[i] = min_potential[i]\n    # Case 2: Shouldn't occur due to commitment logic\n    elif total_max < load:\n        for i in committed_indices:\n            p_outputs[i] = max_potential[i]\n    # Case 3: Economic dispatch required\n    else:\n        committed_list = list(committed_indices)\n        low_lambda = 0\n        high_lambda = 0\n        \n        # Set lambda search bounds\n        for i in committed_list:\n            unit = units_info[i]\n            cost_at_min = unit['b_i'] + 2 * unit['c_i'] * min_potential[i]\n            cost_at_max = unit['b_i'] + 2 * unit['c_i'] * max_potential[i]\n            high_lambda = max(high_lambda, cost_at_min, cost_at_max)\n        high_lambda *= 2  # Expand upper bound\n        \n        # Lambda iteration\n        tol = 0.01\n        max_iter = 100\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for i in committed_list:\n                unit = units_info[i]\n                min_p = min_potential[i]\n                max_p = max_potential[i]\n                if unit['c_i'] == 0:  # Linear units\n                    p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n                else:  # Quadratic units\n                    p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(min_p, min(max_p, p_val))\n                total_power += p_val\n            \n            if abs(total_power - load) < tol:\n                break\n            elif total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Apply final dispatch\n        for i in committed_list:\n            unit = units_info[i]\n            min_p = min_potential[i]\n            max_p = max_potential[i]\n            if unit['c_i'] == 0:\n                p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_p, min(max_p, p_val))\n            p_outputs[i] = p_val\n    \n    # Prepare output schedules\n    u_vector = [1 if i in committed_indices else 0 for i in range(n_units)]\n    schedules = np.array([u_vector, p_outputs])\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00501,
          "gap_price_rate": 0.00888,
          "fitness": 0.00695
     },
     {
          "name": "enhanced_rolling_uc",
          "algorithm": "1. Classify units into must-on (forced online due to min-up-time or shutdown ramp constraints), must-off (forced offline due to min-down-time constraints), and flexible units\n2. Precompute ramp-constrained output ranges for all units considering their previous state\n3. Commit must-on units and calculate total min/max capacity\n4. Compute effective amortized cost (including startup costs) for flexible units and sort by cost\n5. Commit flexible units in ascending cost order until total max capacity >= load\n6. If total min capacity > load, decommit flexible units in descending cost order while maintaining total max capacity >= load\n7. For final committed set:\n   a) If total min capacity > load, set outputs to min\n   b) Else if total max capacity < load, set outputs to max\n   c) Else perform economic dispatch via lambda iteration to minimize production costs\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc(units_info, load):\n    num_units = len(units_info)\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units)\n    \n    # Precompute ramp-constrained bounds for each unit\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        elif unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Commit must-on units\n    committed = set(must_on)\n    total_min = sum(min_p[i] for i in must_on)\n    total_max = sum(max_p[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        min_cost = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                    unit['c_i'] * min_p[i]**2 + startup_cost)\n        costs.append((min_cost / min_p[i], i))\n    \n    # Commit flexible units in cost order\n    costs.sort(key=lambda x: x[0])\n    for cost_val, i in costs:\n        if total_max >= load:\n            break\n        committed.add(i)\n        total_min += min_p[i]\n        total_max += max_p[i]\n    \n    # Decommit expensive flexible units if overcommitted\n    committed_flex = [i for i in committed if i in flexible]\n    if total_min > load:\n        # Sort committed flexible units by cost descending\n        costs_flex = [(cost_val, i) for cost_val, i in costs if i in committed]\n        costs_flex.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in costs_flex:\n            if total_min - min_p[i] <= load:\n                break\n            if total_max - max_p[i] >= load:\n                committed.remove(i)\n                total_min -= min_p[i]\n                total_max -= max_p[i]\n    \n    # Case 1: Total min output > load\n    if total_min > load:\n        for i in committed:\n            u[i] = 1\n            p[i] = min_p[i]\n        return np.array([u, p])\n    \n    # Case 2: Total max output < load\n    if total_max < load:\n        for i in committed:\n            u[i] = 1\n            p[i] = max_p[i]\n        return np.array([u, p])\n    \n    # Case 3: Perform economic dispatch\n    # Prepare parameters for committed units\n    min_dispatch = []\n    max_dispatch = []\n    b_list = []\n    c_list = []\n    idx_mapping = []\n    for i in committed:\n        min_dispatch.append(min_p[i])\n        max_dispatch.append(max_p[i])\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n        idx_mapping.append(i)\n    \n    # Initialize dispatch parameters\n    n = len(min_dispatch)\n    dispatch_min = np.array(min_dispatch)\n    dispatch_max = np.array(max_dispatch)\n    b_arr = np.array(b_list)\n    c_arr = np.array(c_list)\n    \n    # Find lambda bounds\n    marginal_min = b_arr + 2 * c_arr * dispatch_min\n    marginal_max = b_arr + 2 * c_arr * dispatch_max\n    lambda_low = np.min(marginal_min)\n    lambda_high = np.max(marginal_max)\n    \n    # Lambda iteration\n    tol = 1e-5\n    max_iter = 1000\n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n        total_current = np.sum(p_dispatch)\n        \n        if abs(total_current - load) < tol:\n            break\n        elif total_current < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        # Use the best solution from last iteration\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n    \n    # Assign final dispatch\n    for idx, val in zip(idx_mapping, p_dispatch):\n        u[idx] = 1\n        p[idx] = val\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.0071
     },
     {
          "name": "hybrid_rolling_commitment",
          "algorithm": "1. Precompute ramp-constrained min/max output for each unit considering previous state and ramp limits\n2. Classify units as must-on (due to min-up or shutdown constraints), must-off (min-down constraints), or flexible\n3. For flexible units, calculate effective cost: (fixed + startup + variable costs at min output)/min output\n4. Commit must-on units then cheapest flexible units until max capacity >= load\n5. If over-committed (min output > load), remove costly flexible units while maintaining capacity\n6. Dispatch:\n   a) Total min >= load: assign min outputs\n   b) Total max <= load: assign max outputs\n   c) Otherwise: economic dispatch via lambda iteration\n7. Set uncommitted units to off (0 output)\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment(units_info, load):\n    n = len(units_info)\n    min_outputs = np.zeros(n)\n    max_outputs = np.zeros(n)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            online_time = unit['t_i_0']\n            min_up = unit['t_on_min_i']\n            if online_time < min_up or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_time = -unit['t_i_0']\n            min_down = unit['t_off_min_i']\n            if offline_time < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        cost_at_min = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i] ** 2\n        if unit['u_i_0'] == 0:\n            cost_at_min += unit['s_i']\n        effective_costs.append(cost_at_min / min_outputs[i] if min_outputs[i] > 0 else float('inf'))\n    \n    sorted_flexible = [x for _, x in sorted(zip(effective_costs, flexible))]\n    \n    committed = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    flexible_committed = []\n    \n    for idx in sorted_flexible:\n        if total_max < load:\n            committed.add(idx)\n            flexible_committed.append(idx)\n            total_min += min_outputs[idx]\n            total_max += max_outputs[idx]\n        else:\n            break\n    \n    if total_min > load:\n        temp = []\n        for idx in flexible_committed:\n            unit = units_info[idx]\n            cost_at_min = unit['a_i'] + unit['b_i'] * min_outputs[idx] + unit['c_i'] * min_outputs[idx] ** 2\n            if unit['u_i_0'] == 0:\n                cost_at_min += unit['s_i']\n            ec = cost_at_min / min_outputs[idx] if min_outputs[idx] > 0 else float('inf')\n            temp.append((ec, idx))\n        temp.sort(reverse=True)\n        \n        for ec, idx in temp:\n            if total_min - min_outputs[idx] < load:\n                continue\n            if total_max - max_outputs[idx] >= load:\n                total_min -= min_outputs[idx]\n                total_max -= max_outputs[idx]\n                committed.remove(idx)\n                flexible_committed.remove(idx)\n                if total_min < load:\n                    break\n    \n    u = np.zeros(n, dtype=int)\n    p = np.zeros(n)\n    \n    for i in committed:\n        u[i] = 1\n    \n    if committed:\n        total_min = sum(min_outputs[i] for i in committed)\n        total_max = sum(max_outputs[i] for i in committed)\n        \n        if total_min >= load:\n            for i in committed:\n                p[i] = min_outputs[i]\n        elif total_max <= load:\n            for i in committed:\n                p[i] = max_outputs[i]\n        else:\n            comm_list = list(committed)\n            b_arr = np.array([units_info[i]['b_i'] for i in comm_list])\n            c_arr = np.array([units_info[i]['c_i'] for i in comm_list])\n            min_arr = np.array([min_outputs[i] for i in comm_list])\n            max_arr = np.array([max_outputs[i] for i in comm_list])\n            \n            low_lam = np.min(2 * c_arr * min_arr + b_arr)\n            high_lam = np.max(2 * c_arr * max_arr + b_arr)\n            mid_lam = (low_lam + high_lam) / 2\n            tol = 0.01\n            max_iter = 100\n            \n            for _ in range(max_iter):\n                p_arr = (mid_lam - b_arr) / (2 * c_arr)\n                p_arr = np.clip(p_arr, min_arr, max_arr)\n                total_p = np.sum(p_arr)\n                if abs(total_p - load) < tol:\n                    break\n                if total_p < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n                mid_lam = (low_lam + high_lam) / 2\n            \n            for idx, value in zip(comm_list, p_arr):\n                p[idx] = value\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": "1. Categorize units into must-on (must remain on due to min up-time or shutdown ramp constraints), must-off (must remain off due to min down-time constraints), and flexible units.\n2. Precompute ramp-constrained min and max outputs for every unit if committed.\n3. Commit must-on units, calculate current total min and max output.\n4. Compute effective cost for flexible units (amortized startup cost over minimum output) and sort ascending.\n5. Commit flexible units in cost order until total max output >= load.\n6. If total min output > load, decommit expensive flexible units (descending cost order) while maintaining total max >= load.\n7. For final committed set:\n   a) If total min output > load, assign min outputs.\n   b) Else if total max output < load, assign max outputs.\n   c) Else perform economic dispatch via lambda iteration to minimize quadratic production costs.\n8. Set uncommitted units to off with zero output.\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    # Initialize arrays\n    num_units = len(units_info)\n    u_list = [0.0] * num_units\n    p_list = [0.0] * num_units\n    min_outputs = [0.0] * num_units\n    max_outputs = [0.0] * num_units\n    effective_costs = [0.0] * num_units\n\n    # Step 1: Categorize units and precompute outputs\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Compute ramp-constrained min/max outputs\n        if unit['u_i_0'] == 1:  # Previously online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            \n        min_outputs[i] = min_out\n        max_outputs[i] = max_out\n        \n        # Categorization\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Precompute effective costs\n        if min_out > 0:\n            prod_cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            effective_costs[i] = (prod_cost + unit['s_i']) / min_out\n        else:\n            effective_costs[i] = 1e12  # Large number if min_out=0\n\n    # Step 2: Commit must-on units\n    committed_set = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    \n    # Step 3: Sort flexible units by effective cost\n    flexible = sorted(flexible, key=lambda i: effective_costs[i])\n    \n    # Step 4: Commit flexible until capacity >= load\n    for i in flexible:\n        if total_max < load:\n            committed_set.add(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    # Step 5: Backward pass for over-commitment\n    if total_min > load:\n        expensive_flex = sorted(\n            [i for i in committed_set if i not in must_on],\n            key=lambda i: effective_costs[i],\n            reverse=True\n        )\n        for i in expensive_flex:\n            new_min = total_min - min_outputs[i]\n            new_max = total_max - max_outputs[i]\n            if new_max >= load:\n                committed_set.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= load:\n                    break\n    \n    # Step 6: Assign outputs\n    # Case 1: Overgeneration (set to min)\n    if total_min > load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = min_outputs[i]\n    # Case 2: Undergeneration (set to max)\n    elif total_max < load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = max_outputs[i]\n    # Case 3: Economic dispatch\n    else:\n        # Prepare for dispatch\n        B = []\n        C = []\n        P_MIN = []\n        P_MAX = []\n        commit_indices = sorted(committed_set)\n        \n        for i in commit_indices:\n            unit = units_info[i]\n            B.append(unit['b_i'])\n            C.append(unit['c_i'])\n            P_MIN.append(min_outputs[i])\n            P_MAX.append(max_outputs[i])\n        \n        n = len(commit_indices)\n        if n == 0:  # No units to dispatch\n            pass\n        else:\n            # Lambda iteration setup\n            low_lam = 1e12\n            high_lam = -1e12\n            \n            for i in range(n):\n                b = B[i]\n                c = C[i]\n                p_min = P_MIN[i]\n                p_max = P_MAX[i]\n                if c == 0:  # Linear unit\n                    low_lam = min(low_lam, b)\n                    high_lam = max(high_lam, b)\n                else:  # Quadratic unit\n                    low_lam = min(low_lam, 2*c*p_min + b)\n                    high_lam = max(high_lam, 2*c*p_max + b)\n            \n            # Binary search\n            max_iter = 100\n            tol = 1e-3\n            for _ in range(max_iter):\n                mid_lam = (low_lam + high_lam) / 2.0\n                total_power = 0.0\n                p_dispatch = []\n                \n                for i in range(n):\n                    b = B[i]\n                    c = C[i]\n                    p_min = P_MIN[i]\n                    p_max = P_MAX[i]\n                    \n                    if c == 0:  # Linear\n                        p_i = p_max if mid_lam >= b else p_min\n                    else:  # Quadratic\n                        p_desired = (mid_lam - b) / (2 * c)\n                        p_i = min(max(p_desired, p_min), p_max)\n                    \n                    p_dispatch.append(p_i)\n                    total_power += p_i\n                \n                if abs(total_power - load) < tol:\n                    break\n                if total_power < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n            \n            # Assign dispatch results\n            for idx, i in enumerate(commit_indices):\n                u_list[i] = 1.0\n                p_list[i] = p_dispatch[idx]\n    \n    # Set uncommitted units\n    for i in range(num_units):\n        if i not in committed_set:\n            u_list[i] = 0.0\n            p_list[i] = 0.0\n    \n    return np.array([u_list, p_list])",
          "from": "mutation",
          "gap_power_rate": 0.00539,
          "gap_price_rate": 0.00901,
          "fitness": 0.0072
     },
     {
          "name": "commit_units_priority_afc",
          "algorithm": "The heuristic uses a priority list based on Average Full-Load Cost (AFLC) for unit commitment. First, units are categorized as forced on (must stay online due to min-up-time or shutdown ramp constraints), forced off (must stay offline due to min-down-time constraints), or free units. Free units are sorted by AFLC. Starting with forced-on units at minimum output, free units are committed in AFLC order until total maximum capacity covers the load. Finally, an economic dispatch minimizes production costs by adjusting outputs within operational constraints to meet the load exactly or as closely as possible.\n",
          "code": "import numpy as np\n\ndef commit_units_priority_afc(units_info, load):\n    n_units = len(units_info)\n    u_arr = [0] * n_units\n    p_arr = [0.0] * n_units\n    lb_arr = [0.0] * n_units\n    ub_arr = [0.0] * n_units\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_indices.append(i)\n            else:\n                free_indices.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                free_indices.append(i)\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in forced_on_indices:\n        unit = units_info[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        u_arr[i] = 1\n        p_arr[i] = lb\n        lb_arr[i] = lb\n        ub_arr[i] = ub\n        total_min += lb\n        total_max += ub\n    \n    afc = []\n    for i in free_indices:\n        unit = units_info[i]\n        a, b, c, p_max = unit['a_i'], unit['b_i'], unit['c_i'], unit['p_max_i']\n        full_load_cost = a + b * p_max + c * (p_max ** 2)\n        afc.append(full_load_cost / p_max)\n    sorted_free = [i for _, i in sorted(zip(afc, free_indices))]\n    \n    committed_indices = forced_on_indices[:]\n    \n    for i in sorted_free:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        u_arr[i] = 1\n        p_arr[i] = lb\n        lb_arr[i] = lb\n        ub_arr[i] = ub\n        total_min += lb\n        total_max += ub\n        committed_indices.append(i)\n    \n    current_total = total_min\n    gap = load - current_total\n    \n    while abs(gap) > 1e-8:\n        if gap > 0:\n            candidate = None\n            min_mc = float('inf')\n            for i in committed_indices:\n                if p_arr[i] < ub_arr[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate = i\n            if candidate is None:\n                break\n            increase = min(gap, ub_arr[candidate] - p_arr[candidate])\n            p_arr[candidate] += increase\n            current_total += increase\n            gap = load - current_total\n        else:\n            candidate = None\n            max_mc = -float('inf')\n            for i in committed_indices:\n                if p_arr[i] > lb_arr[i]:\n                    mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_arr[i]\n                    if mc > max_mc:\n                        max_mc = mc\n                        candidate = i\n            if candidate is None:\n                break\n            decrease = min(-gap, p_arr[candidate] - lb_arr[candidate])\n            p_arr[candidate] -= decrease\n            current_total -= decrease\n            gap = load - current_total\n    \n    return np.array([u_arr, p_arr])",
          "from": null,
          "gap_power_rate": 0.00688,
          "gap_price_rate": 0.01133,
          "fitness": 0.0091
     },
     {
          "name": "refined_afc_commitment",
          "algorithm": "1. Classify units: \n   - Must-on: currently online units violating min-up time or shutdown ramp constraints\n   - Must-off: currently offline units violating min-down time constraints\n   - Flexible: all other units (further split into currently on/off subsets)\n2. Precompute ramp-constrained min/max outputs for all non-must-off units\n3. Start with must-on units committed, initialize committed flexible units as:\n   - Flexible-on units currently online\n   - Initially no flexible-off units committed\n4. Compute total min/max output from committed units\n5. Handle capacity deficit:\n   - Sort flexible-off units by ascending amortized startup cost\n   - Commit cheapest flexible-off units until total max >= load\n6. Handle over-commitment:\n   - Sort all committed flexible units by descending amortized cost\n   - Decommit most expensive units while maintaining total max >= load\n7. For final committed set:\n   a) Set uncommitted units to off with zero output\n   b) Perform economic dispatch for committed units via lambda iteration:\n        - Use binary search to find optimal marginal cost lambda\n        - Compute outputs that minimize quadratic production costs\n        - Respect ramp constraints and min/max limits\n        - Handle linear cost units separately\n8. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef refined_afc_commitment(units_info, load):\n    num_units = len(units_info)\n    min_outputs = [0] * num_units\n    max_outputs = [0] * num_units\n    effective_costs = [float('inf')] * num_units\n    \n    # Classify units and precompute ramp constraints\n    must_on = []\n    must_off = []\n    flexible_on = []\n    flexible_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            must_on.append(i)\n            min_outputs[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            must_off.append(i)\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n        # Flexible units (on)\n        elif u_i0 == 1:\n            flexible_on.append(i)\n            min_outputs[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        # Flexible units (off)\n        else:\n            flexible_off.append(i)\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Calculate effective costs (amortized startup + production cost at min output)\n    for i, unit in enumerate(units_info):\n        if i in must_off or min_outputs[i] <= 0:\n            continue\n        cost = unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i]**2\n        if (i in flexible_off) or (i in flexible_on and unit['u_i_0'] == 0):\n            cost += unit['s_i']\n        effective_costs[i] = cost / min_outputs[i]\n\n    # Initialize committed set (must_on + all flexible_on)\n    committed = set(must_on + flexible_on)\n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n\n    # Add flexible-off units if insufficient capacity\n    sorted_off = sorted(flexible_off, key=lambda i: effective_costs[i])\n    for i in sorted_off:\n        if total_max >= load:\n            break\n        committed.add(i)\n        total_min += min_outputs[i]\n        total_max += max_outputs[i]\n\n    # Decommit expensive flexible units if overcommitted\n    all_flex = list(set(flexible_on + flexible_off) & committed)\n    sorted_flex = sorted(all_flex, key=lambda i: effective_costs[i], reverse=True)\n    \n    for i in sorted_flex:\n        new_max = total_max - max_outputs[i]\n        if new_max >= load:\n            committed.discard(i)\n            total_min -= min_outputs[i]\n            total_max = new_max\n\n    # Economic dispatch for committed units\n    p_outputs = [0] * num_units\n    committed_list = list(committed)\n    \n    if committed_list:\n        # Lambda bounds initialization\n        low = min(unit['b_i'] + 2*unit['c_i']*min_outputs[i] \n                 for i in committed_list for unit in [units_info[i]])\n        high = max(unit['b_i'] + 2*unit['c_i']*max_outputs[i] \n                  for i in committed_list for unit in [units_info[i]])\n        \n        # Special case: load outside capacity bounds\n        if total_min >= load:\n            for i in committed:\n                p_outputs[i] = min_outputs[i]\n        elif total_max <= load:\n            for i in committed:\n                p_outputs[i] = max_outputs[i]\n        else:\n            # Lambda iteration for quadratic dispatch\n            tolerance = 1e-2\n            for _ in range(50):\n                lam = (low + high) / 2.0\n                total_p = 0.0\n                \n                # Calculate dispatch for each unit\n                for i in committed_list:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        p_i = max_outputs[i] if lam > unit['b_i'] else min_outputs[i]\n                    else:\n                        p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_i = np.clip(p_i, min_outputs[i], max_outputs[i])\n                    \n                    p_outputs[i] = p_i\n                    total_p += p_i\n                \n                # Adjust lambda based on total load\n                if abs(total_p - load) < tolerance:\n                    break\n                if total_p < load:\n                    low = lam\n                else:\n                    high = lam\n                    \n            # Handle residual for linear units\n            total_p = sum(p_outputs[i] for i in committed)\n            residual = load - total_p\n            if abs(residual) > tolerance:\n                for i in committed_list:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0 and residual != 0:\n                        if residual > 0:\n                            add = min(residual, max_outputs[i] - p_outputs[i])\n                            p_outputs[i] += add\n                            residual -= add\n                        else:\n                            reduce = min(-residual, p_outputs[i] - min_outputs[i])\n                            p_outputs[i] -= reduce\n                            residual += reduce\n\n    # Build output arrays\n    u_out = [1 if i in committed else 0 for i in range(num_units)]\n    return np.array([u_out, p_outputs])",
          "from": "mutation",
          "gap_power_rate": 0.00458,
          "gap_price_rate": 0.01416,
          "fitness": 0.00937
     },
     {
          "name": "hybrid_rolling_commitment",
          "algorithm": "1. Classify units as forced_on (must stay online due to min-up time or shutdown ramp constraints), forced_off (must stay offline due to min-down time), and flexible units.\n2. Compute current feasible output limits considering startup/shutdown ramps and ramp rates for forced_on units.\n3. If forced_on units' combined max output exceeds load, use only forced_on units. Otherwise, sort flexible units by average cost per MW at min output (including startup cost if unit was offline) and commit units until total max output meets/exceeds load.\n4. In forward pass, skip units causing total min output to exceed load. After initial pass, if max output still below load, add cheapest skipped units.\n5. In backward pass, remove expensive non-forced_on units (sorted by descending marginal cost at min output) if removal maintains adequate max output capacity.\n6. Dispatch load among committed units: \n   - If total min output > load, set to min outputs.\n   - If total max output < load, set to max outputs.\n   - Otherwise perform economic dispatch via lambda iteration to minimize costs.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    current_p_min = np.zeros(n_units)\n    current_p_max = np.zeros(n_units)\n    output_p = np.zeros(n_units)\n    committed = np.zeros(n_units, dtype=bool)\n    \n    # Classify units and compute current min/max outputs\n    forced_on = []\n    forced_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # Was offline\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Compute current period output limits\n        if unit['u_i_0'] == 1:\n            p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min = unit['p_min_i']\n            p_max = min(unit['p_max_i'], unit['p_start_i'])\n        current_p_min[i] = p_min\n        current_p_max[i] = p_max\n\n    # Calculate forced_on capacity\n    total_min_forced = current_p_min[forced_on].sum()\n    total_max_forced = current_p_max[forced_on].sum()\n    committed_set = forced_on.copy()\n    total_min = total_min_forced\n    total_max = total_max_forced\n\n    # Commit flexible units if needed\n    if total_max_forced < load:\n        skipped = []\n        flexible_costs = []\n        \n        # Calculate effective costs for flexible units\n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                # Already online - no startup cost\n                cost = unit['b_i'] + unit['c_i'] * current_p_min[i]\n            else:\n                # Offline - include amortized startup cost\n                cost = (unit['s_i'] + unit['b_i'] * current_p_min[i] + \n                        unit['c_i'] * current_p_min[i]**2) / current_p_min[i]\n            flexible_costs.append((cost, i))\n        \n        # Sort by ascending cost\n        flexible_costs.sort(key=lambda x: x[0])\n        \n        # Forward pass: commit without exceeding load at min output\n        for cost_val, i in flexible_costs:\n            new_min = total_min + current_p_min[i]\n            new_max = total_max + current_p_max[i]\n            if new_min <= load:\n                committed_set.append(i)\n                total_min = new_min\n                total_max = new_max\n                if total_max >= load:\n                    break\n            else:\n                skipped.append((cost_val, i))\n                \n        # Add skipped units if capacity insufficient\n        if total_max < load and skipped:\n            skipped.sort(key=lambda x: x[0])\n            for cost_val, i in skipped:\n                committed_set.append(i)\n                total_min += current_p_min[i]\n                total_max += current_p_max[i]\n                if total_max >= load:\n                    break\n                    \n        # Backward pass: remove expensive non-forced units\n        non_forced = [i for i in committed_set if i not in forced_on]\n        non_forced_costs = []\n        \n        for i in non_forced:\n            unit = units_info[i]\n            marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p_min[i]\n            non_forced_costs.append((marginal_cost, i))\n        non_forced_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        removed = True\n        while removed and non_forced_costs:\n            removed = False\n            for idx, (marg_cost, i) in enumerate(non_forced_costs):\n                candidate_set = [u for u in committed_set if u != i]\n                candidate_max = current_p_max[candidate_set].sum()\n                if candidate_max >= load:\n                    committed_set = candidate_set\n                    total_min -= current_p_min[i]\n                    total_max -= current_p_max[i]\n                    non_forced_costs.pop(idx)\n                    removed = True\n                    break\n\n    # Dispatch power to committed units\n    committed[committed_set] = True\n    total_min = current_p_min[committed_set].sum()\n    total_max = current_p_max[committed_set].sum()\n\n    if total_min > load:\n        output_p[committed_set] = current_p_min[committed_set]\n    elif total_max < load:\n        output_p[committed_set] = current_p_max[committed_set]\n    else:\n        # Lambda iteration for economic dispatch\n        low_lambda = 0\n        high_lambda = 0\n        \n        for i in committed_set:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                marginal_max = unit['b_i']\n            else:\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * current_p_max[i]\n            if marginal_max > high_lambda:\n                high_lambda = marginal_max\n        high_lambda = max(high_lambda, 1e6)\n        \n        # Find lower bound of lambda\n        for i in committed_set:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                marginal_min = unit['b_i']\n            else:\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * current_p_min[i]\n            if marginal_min < low_lambda or low_lambda == 0:\n                low_lambda = marginal_min\n\n        # Bisection search\n        n_iter = 0\n        while (high_lambda - low_lambda) > 1e-8 and n_iter < 1000:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0.0\n            for i in committed_set:\n                unit = units_info[i]\n                if unit['c_i'] == 0:\n                    if mid_lambda >= unit['b_i']:\n                        p_i = current_p_max[i]\n                    else:\n                        p_i = current_p_min[i]\n                else:\n                    p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(current_p_min[i], min(current_p_max[i], p_i))\n                total_power += p_i\n                \n            if total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            n_iter += 1\n\n        # Set dispatch values\n        for i in committed_set:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                if mid_lambda >= unit['b_i']:\n                    p_i = current_p_max[i]\n                else:\n                    p_i = current_p_min[i]\n            else:\n                p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(current_p_min[i], min(current_p_max[i], p_i))\n            output_p[i] = p_i\n\n    # Build output schedule\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if i in committed_set else 0\n        schedules[1, i] = output_p[i]\n        \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00515,
          "gap_price_rate": 0.01443,
          "fitness": 0.00979
     },
     {
          "name": "refined_rolling_uc",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_rolling_uc(units_info, load):\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    committed = set(must_on)  # Must-on units initially committed\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    current_min = 0.0\n    current_max = 0.0\n    \n    # Compute bounds for must-on units\n    for i in must_on:\n        if units_info[i]['u_i_0'] == 1:\n            lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lb_i = units_info[i]['p_min_i']\n            ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        current_min += lb_i\n        current_max += ub_i\n    \n    # Create flexible unit list with metrics\n    flexible_list = []\n    for i in flexible:\n        I_off = 1 if units_info[i]['u_i_0'] == 0 else 0\n        a = units_info[i]['a_i']\n        b = units_info[i]['b_i']\n        c = units_info[i]['c_i']\n        s = units_info[i]['s_i']\n        p_min = units_info[i]['p_min_i']\n        metric = (s * I_off + a) / p_min + (b + 2 * c * p_min)\n        flexible_list.append((i, metric))\n    \n    # Sort flexible units by metric\n    flexible_list.sort(key=lambda x: x[1])\n    \n    # Commit flexible units\n    temp_min = current_min\n    temp_max = current_max\n    committed_flex = []\n    \n    for i, _ in flexible_list:\n        if units_info[i]['u_i_0'] == 0:  # currently offline\n            lb_i = units_info[i]['p_min_i']\n            ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:  # currently online\n            lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        \n        if temp_max < load or (temp_min + lb_i <= load and temp_max + ub_i < load) or temp_min + lb_i <= load:\n            committed.add(i)\n            committed_flex.append(i)\n            temp_min += lb_i\n            temp_max += ub_i\n            if temp_max >= load:\n                break\n    \n    # Update current_min and current_max after committing flexible units\n    current_min = sum(\n        max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n        if units_info[i]['u_i_0'] == 1 else units_info[i]['p_min_i']\n        for i in committed if i not in must_off\n    )\n    current_max = sum(\n        min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        if units_info[i]['u_i_0'] == 1 else min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        for i in committed if i not in must_off\n    )\n    \n    # Prepare lists for bounds and cost parameters of committed units\n    lb_list = []\n    ub_list = []\n    b_list = []\n    c_list = []\n    committed_ids = list(committed)\n    \n    for i in committed:\n        u_i0 = units_info[i]['u_i_0']\n        if u_i0 == 1:\n            lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            lb_i = units_info[i]['p_min_i']\n            ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n    \n    # Dispatch power to committed units\n    if current_min >= load:\n        p_vals = lb_list\n    elif current_max <= load:\n        p_vals = ub_list\n    else:\n        # Lambda iteration setup\n        low_lam = min(b + 2*c*lb for b, c, lb in zip(b_list, c_list, lb_list)) - 1\n        high_lam = max(b + 2*c*ub for b, c, ub in zip(b_list, c_list, ub_list)) + 1\n        tol = 1e-5\n        max_iter = 100\n        for _ in range(max_iter):\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for idx in range(len(committed_ids)):\n                b_val = b_list[idx]\n                c_val = c_list[idx]\n                lb_val = lb_list[idx]\n                ub_val = ub_list[idx]\n                if mid_lam <= b_val + 2 * c_val * lb_val:\n                    p_i = lb_val\n                elif mid_lam >= b_val + 2 * c_val * ub_val:\n                    p_i = ub_val\n                else:\n                    p_i = (mid_lam - b_val) / (2 * c_val)\n                total_p += p_i\n            if total_p < load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n            if high_lam - low_lam < tol:\n                break\n        \n        # Final calculation with converged lambda\n        p_vals = []\n        mid_lam = (low_lam + high_lam) / 2\n        for idx in range(len(committed_ids)):\n            b_val = b_list[idx]\n            c_val = c_list[idx]\n            lb_val = lb_list[idx]\n            ub_val = ub_list[idx]\n            if mid_lam <= b_val + 2 * c_val * lb_val:\n                p_i = lb_val\n            elif mid_lam >= b_val + 2 * c_val * ub_val:\n                p_i = ub_val\n            else:\n                p_i = (mid_lam - b_val) / (2 * c_val)\n            p_vals.append(p_i)\n    \n    # Set outputs for committed units\n    for idx, unit_id in enumerate(committed_ids):\n        u_out[unit_id] = 1\n        p_out[unit_id] = p_vals[idx]\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.00488,
          "gap_price_rate": 0.0163,
          "fitness": 0.01059
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Categorize units into must-on (must remain on due to constraints), must-off (must remain off due to constraints), and flexible (can be committed based on cost).\n2. Commit must-on units to on and must-off units to off.\n3. For flexible units, calculate an effective incremental cost that amortizes startup costs over minimum power output. Sort units by this cost in ascending order.\n4. Commit flexible units in sorted order until total available capacity meets or exceeds the current load.\n5. For committed units, calculate min/max power outputs considering ramp and startup constraints.\n6. If total minimum output exceeds load, set all committed units to minimum output.\n7. If total maximum output is below load, set all committed units to maximum output.\n8. Otherwise, perform economic dispatch via lambda iteration (binary search) to optimally distribute load among committed units while respecting individual unit constraints.\n9. Set uncommitted units to off with zero output.\n10. Return commitment statuses and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(b, c, min_p, max_p, load, tol=1e-6):\n    n = len(b)\n    total_min = np.sum(min_p)\n    total_max = np.sum(max_p)\n    if total_min >= load:\n        return min_p\n    if total_max <= load:\n        return max_p\n    IC_min = np.min(b + 2 * c * min_p)\n    IC_max = np.max(b + 2 * c * max_p)\n    low = IC_min\n    high = IC_max\n    while high - low > tol:\n        mid = (low + high) / 2.0\n        p_unconstrained = (mid - b) / (2 * c)\n        p_clipped = np.clip(p_unconstrained, min_p, max_p)\n        total = np.sum(p_clipped)\n        if total < load:\n            low = mid\n        else:\n            high = mid\n    mid = (low + high) / 2.0\n    p_unconstrained = (mid - b) / (2 * c)\n    p_clipped = np.clip(p_unconstrained, min_p, max_p)\n    return p_clipped\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    n_units = len(units_info)\n    u_current = np.zeros(n_units)\n    min_p_list = np.zeros(n_units)\n    max_p_list = np.zeros(n_units)\n    \n    must_on_indices = []\n    must_off_indices = []\n    flexible_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_indices.append(i)\n            else:\n                flexible_indices.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off_indices.append(i)\n            else:\n                flexible_indices.append(i)\n    \n    u_current[must_on_indices] = 1\n    \n    def compute_effective_ic(unit):\n        if unit['u_i_0'] == 1:\n            return unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n        else:\n            return (unit['s_i'] / unit['p_min_i']) + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n    \n    flexible_units_sorted = sorted(flexible_indices, key=lambda i: compute_effective_ic(units_info[i]))\n    \n    total_min, total_max = 0.0, 0.0\n    for i in must_on_indices:\n        unit = units_info[i]\n        prev_p = unit['p_i_0']\n        min_p_i = max(unit['p_min_i'], prev_p - unit['p_down_i'])\n        max_p_i = min(unit['p_max_i'], prev_p + unit['p_up_i'])\n        total_min += min_p_i\n        total_max += max_p_i\n    \n    committed_flexible = []\n    for i in flexible_units_sorted:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_p_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p_i = unit['p_min_i']\n            max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n        if total_max < load:\n            total_min += min_p_i\n            total_max += max_p_i\n            committed_flexible.append(i)\n            u_current[i] = 1\n        else:\n            break\n    \n    for i in range(n_units):\n        if u_current[i] == 0:\n            min_p_list[i] = max_p_list[i] = 0.0\n        else:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                min_p_list[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_list[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p_list[i] = unit['p_min_i']\n                max_p_list[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    committed_indices = np.where(u_current == 1)[0]\n    min_p_committed = min_p_list[committed_indices]\n    max_p_committed = max_p_list[committed_indices]\n    total_min_committed = np.sum(min_p_committed)\n    total_max_committed = np.sum(max_p_committed)\n    \n    p_current = np.zeros(n_units)\n    if total_min_committed > load:\n        p_current[committed_indices] = min_p_committed\n    elif total_max_committed < load:\n        p_current[committed_indices] = max_p_committed\n    else:\n        b_committed = np.array([units_info[i]['b_i'] for i in committed_indices])\n        c_committed = np.array([units_info[i]['c_i'] for i in committed_indices])\n        p_committed = economic_dispatch(b_committed, c_committed, min_p_committed, max_p_committed, load)\n        p_current[committed_indices] = p_committed\n    \n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00575,
          "gap_price_rate": 0.0158,
          "fitness": 0.01078
     }
]