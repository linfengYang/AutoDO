[
     {
          "name": "novel_rolling_commitment_v1",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units considering startup/shutdown ramp limits\n2. Classify units:\n   - Must-on: Online units violating min-up time OR offline units exceeding shutdown ramp\n   - Must-off: Offline units violating min-down time\n   - Flexible: Other units\n3. Commit must-on units and set must-off units to offline\n4. Compute effective cost for flexible units (amortizing startup costs over min output)\n5. Commit flexible units incrementally by ascending effective cost until capacity >= load\n6. Decommit expensive flexible units while maintaining capacity coverage\n7. Assign outputs:\n   a) If total min capacity > load: Set outputs to min values\n   b) Else if total max capacity < load: Set outputs to max values\n   c) Else: Perform economic dispatch via lambda iteration\n8. Set uncommitted units offline with zero output\n\n",
          "code": "import numpy as np\n\ndef novel_rolling_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Precompute min/max outputs with ramp constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_output[i] = unit['p_min_i']\n            max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize committed units\n    committed = set(must_on)\n    total_min = sum(min_output[i] for i in must_on)\n    total_max = sum(max_output[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    eff_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        min_out = min_output[i]\n        if unit['u_i_0'] == 0:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        else:\n            cost = (unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        eff_costs.append((cost, i))\n    \n    # Commit flexible units by ascending cost\n    eff_costs_sorted = sorted(eff_costs, key=lambda x: x[0])\n    for cost, i in eff_costs_sorted:\n        if total_max < load:\n            committed.add(i)\n            total_min += min_output[i]\n            total_max += max_output[i]\n    \n    # Decommit expensive units while maintaining coverage\n    decommit_candidates = sorted(\n        [i for i in committed if i not in must_on],\n        key=lambda i: eff_costs[[idx for c, idx in eff_costs_sorted].index(i)][0],\n        reverse=True\n    )\n    for i in decommit_candidates:\n        if total_max - max_output[i] >= load:\n            committed.remove(i)\n            total_min -= min_output[i]\n            total_max -= max_output[i]\n    \n    # Initialize output arrays\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    # Assign outputs based on commitment status\n    if total_min > load:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = min_output[i]\n    elif total_max < load:\n        for i in committed:\n            u_out[i] = 1\n            p_out[i] = max_output[i]\n    else:\n        # Economic dispatch via lambda iteration\n        indices = list(committed)\n        low_lam = 0\n        high_lam = 0\n        \n        for i in indices:\n            unit = units_info[i]\n            ic_min = unit['b_i'] + 2 * unit['c_i'] * min_output[i]\n            ic_max = unit['b_i'] + 2 * unit['c_i'] * max_output[i]\n            low_lam = min(low_lam, ic_min) if low_lam != 0 else ic_min\n            high_lam = max(high_lam, ic_max) if high_lam != 0 else ic_max\n        \n        low_lam -= 100\n        high_lam += 100\n        tol = 0.01\n        max_iter = 1000\n        \n        for _ in range(max_iter):\n            lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i in indices:\n                unit = units_info[i]\n                p_opt = max(min_output[i], min(max_output[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n                total_p += p_opt\n            \n            if abs(total_p - load) < tol:\n                break\n            if total_p < load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        for i in indices:\n            unit = units_info[i]\n            p_opt = max(min_output[i], min(max_output[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n            u_out[i] = 1\n            p_out[i] = p_opt\n    \n    # Set uncommitted units to offline\n    schedules = np.vstack((u_out, p_out))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00431,
          "gap_price_rate": 0.00817,
          "fitness": 0.00624
     },
     {
          "name": "hybrid_v3_rolling_commitment",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for each unit considering current state and ramp limits\n2. Classify units as must-on (violating min-up time or shutdown ramp constraints), must-off (violating min-down time constraints), or flexible\n3. Commit must-on units and set must-off units to offline\n4. Calculate effective cost for flexible units: (fixed + startup + min production cost) / min output\n5. Commit flexible units in ascending cost order until total max capacity \u2265 load\n6. While total min capacity > load, decommit most expensive flexible units while maintaining total max capacity \u2265 load\n7. Dispatch power: assign min outputs if total min > load; max outputs if total max < load; otherwise perform economic dispatch via lambda iteration\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef hybrid_v3_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    min_cur = np.zeros(num_units)\n    max_cur = np.zeros(num_units)\n    \n    # Precompute ramp-constrained min/max for each unit\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_cur[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_cur[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_cur[i] = unit['p_min_i']\n            max_cur[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Online in previous period\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # Offline in previous period\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Initialize commitment and capacity totals\n    commitment = np.zeros(num_units, dtype=int)\n    total_min = 0\n    total_max = 0\n    \n    # Commit must-on units\n    for i in must_on:\n        commitment[i] = 1\n        total_min += min_cur[i]\n        total_max += max_cur[i]\n    \n    # Process flexible units\n    flexible_costs = []\n    for i in flexible:\n        startup_cost = unit['s_i'] if units_info[i]['u_i_0'] == 0 else 0\n        min_cost = (units_info[i]['a_i'] + startup_cost + \n                    units_info[i]['b_i'] * min_cur[i] + \n                    units_info[i]['c_i'] * min_cur[i]**2)\n        effective_cost = min_cost / min_cur[i] if min_cur[i] > 0 else float('inf')\n        flexible_costs.append((effective_cost, i))\n    \n    flexible_costs.sort(key=lambda x: x[0])\n    \n    # Commit cheapest flexible units\n    committed_flexible = []\n    for cost, i in flexible_costs:\n        if total_max >= load:\n            break\n        commitment[i] = 1\n        total_min += min_cur[i]\n        total_max += max_cur[i]\n        committed_flexible.append((cost, i))\n    \n    # Decommit expensive units if minimum capacity exceeds load\n    committed_flexible.sort(key=lambda x: x[0], reverse=True)\n    idx = 0\n    while total_min > load and idx < len(committed_flexible):\n        cost, i = committed_flexible[idx]\n        if total_max - max_cur[i] >= load:\n            commitment[i] = 0\n            total_min -= min_cur[i]\n            total_max -= max_cur[i]\n            committed_flexible.pop(idx)\n        else:\n            idx += 1\n    \n    # Dispatch power allocation\n    outputs = np.zeros(num_units)\n    committed_idx = [i for i in range(num_units) if commitment[i] == 1]\n    \n    if not committed_idx: \n        return schedules\n    \n    total_committed_min = sum(min_cur[i] for i in committed_idx)\n    total_committed_max = sum(max_cur[i] for i in committed_idx)\n    \n    if total_committed_min > load:\n        for i in committed_idx:\n            outputs[i] = min_cur[i]\n    elif total_committed_max < load:\n        for i in committed_idx:\n            outputs[i] = max_cur[i]\n    else:  # Perform economic dispatch\n        # Lambda iteration setup\n        low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_cur[i] for i in committed_idx)\n        high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_cur[i] for i in committed_idx)\n        \n        # Bisection method\n        max_iter = 100\n        tol = 1e-3\n        for _ in range(max_iter):\n            mid = (low + high) / 2\n            total_power = 0\n            for i in committed_idx:\n                if units_info[i]['c_i'] > 0:\n                    p_i = (mid - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                else:\n                    p_i = max_cur[i] if mid > units_info[i]['b_i'] else min_cur[i]\n                p_i = np.clip(p_i, min_cur[i], max_cur[i])\n                outputs[i] = p_i\n                total_power += p_i\n            \n            if abs(total_power - load) < tol:\n                break\n            elif total_power > load:\n                high = mid\n            else:\n                low = mid\n    \n    # Prepare output\n    for i in committed_idx:\n        schedules[0, i] = 1\n        schedules[1, i] = outputs[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0043,
          "gap_price_rate": 0.00849,
          "fitness": 0.00639
     },
     {
          "name": "enhanced_hybrid_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min and max outputs for each unit considering current state and ramp limits, ensuring feasible operation range\n2. Classify units:\n   - Must-on: Units violating min-up time or shutdown ramp constraints\n   - Must-off: Units violating min-down time constraints\n   - Flexible: Remaining units\n3. Calculate amortized effective cost (fixed + startup + variable costs) using average power (min_max average) for flexible units\n4. Commit must-on units and calculate total capacity\n5. Commit flexible units in ascending cost order until total max capacity >= load\n6. Decommit flexible units in descending cost order while maintaining max capacity >= load\n7. For final committed set:\n   a) Assign min outputs if total min output > load\n   b) Assign max outputs if total max output < load\n   c) Perform lambda iteration for economic dispatch otherwise\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment_v2(units_info, load):\n    n = len(units_info)\n    u_final = [0] * n\n    p_final = [0.0] * n\n    min_outputs = [0.0] * n\n    max_outputs = [0.0] * n\n\n    # Step 1: Precompute ramp-constrained min/max outputs\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        \n        if u_i_0 == 1:  # Unit was online\n            min_out = max(p_min_i, p_i_0 - unit['p_down_i'])\n            max_out = min(p_max_i, p_i_0 + unit['p_up_i'])\n        else:  # Unit was offline\n            min_out = p_min_i\n            max_out = min(p_max_i, unit['p_start_i'])\n        \n        # Ensure feasibility\n        if min_out > max_out:\n            min_out = max_out = (min_out + max_out) / 2.0\n        \n        min_outputs[i] = min_out\n        max_outputs[i] = max_out\n    \n    # Step 2: Classify units\n    must_on_indices = []\n    must_off_indices = []\n    flexible_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if (t_i_0 > 0 and t_i_0 < t_on_min_i) or p_i_0 > unit['p_shut_i']:\n                must_on_indices.append(i)\n            else:\n                flexible_indices.append(i)\n        else:\n            if t_i_0 < 0 and abs(t_i_0) < t_off_min_i:\n                must_off_indices.append(i)\n            else:\n                flexible_indices.append(i)\n    \n    # Step 3: Compute effective costs for flexible units\n    effective_costs = [float('inf')] * n\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        p_avg = (min_outputs[i] + max_outputs[i]) / 2.0\n        if p_avg == 0:  # Handle zero division\n            effective_costs[i] = float('inf')\n            continue\n        \n        # Calculate fixed + startup costs\n        total_fixed_cost = unit['a_i']\n        if unit['u_i_0'] == 0:  # Only include startup cost if transitioning from off\n            total_fixed_cost += unit['s_i']\n        \n        # Calculate variable costs at average power\n        variable_cost = unit['b_i'] * p_avg + unit['c_i'] * (p_avg ** 2)\n        effective_costs[i] = (total_fixed_cost + variable_cost) / p_avg\n    \n    # Initialize committed set and capacity\n    committed_set = set(must_on_indices)\n    total_min = sum(min_outputs[i] for i in must_on_indices)\n    total_max = sum(max_outputs[i] for i in must_on_indices)\n    \n    # Step 5: Commit flexible units by cost\n    sorted_flex = sorted(flexible_indices, key=lambda i: effective_costs[i])\n    \n    for i in sorted_flex:\n        if total_max >= load:\n            break\n        committed_set.add(i)\n        total_min += min_outputs[i]\n        total_max += max_outputs[i]\n    \n    # Step 6: Decommit expensive flexible units\n    flexible_in_commit = [i for i in committed_set if i in flexible_indices]\n    sorted_decommit = sorted(flexible_in_commit, key=lambda i: effective_costs[i], reverse=True)\n    \n    for i in sorted_decommit:\n        test_max = total_max - max_outputs[i]\n        if test_max >= load:\n            committed_set.remove(i)\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n    \n    # Step 7: Dispatch power\n    comm_min = total_min\n    comm_max = total_max\n    \n    if comm_min > load:  # Over-generation case\n        for i in committed_set:\n            u_final[i] = 1\n            p_final[i] = min_outputs[i]\n    elif comm_max < load:  # Under-generation case\n        for i in committed_set:\n            u_final[i] = 1\n            p_final[i] = max_outputs[i]\n    else:  # Economic dispatch\n        b_list = []\n        c_list = []\n        min_list = []\n        max_list = []\n        idx_list = list(committed_set)\n        \n        for i in idx_list:\n            b_list.append(units_info[i]['b_i'])\n            c_list.append(units_info[i]['c_i'])\n            min_list.append(min_outputs[i])\n            max_list.append(max_outputs[i])\n        \n        # Lambda iteration initialization\n        tolerance = 0.001\n        low_bound = min(b_i + 2 * c_i * min_p for b_i, c_i, min_p in zip(b_list, c_list, min_list))\n        high_bound = max(b_i + 2 * c_i * max_p for b_i, c_i, max_p in zip(b_list, c_list, max_list))\n        mid = (low_bound + high_bound) / 2.0\n        power_sum = 0.0\n        max_iter = 1000\n        iter_count = 0\n        \n        # Iterate until convergence\n        while abs(high_bound - low_bound) > tolerance and iter_count < max_iter:\n            mid = (low_bound + high_bound) / 2.0\n            power_sum = 0.0\n            for j in range(len(b_list)):\n                p_unconstrained = (mid - b_list[j]) / (2 * c_list[j])\n                p_clamped = max(min_list[j], min(max_list[j], p_unconstrained))\n                power_sum += p_clamped\n            \n            if power_sum < load:\n                low_bound = mid\n            else:\n                high_bound = mid\n            iter_count += 1\n        \n        # Final output assignment\n        for j, i in enumerate(idx_list):\n            p_unconstrained = (mid - b_list[j]) / (2 * c_list[j])\n            p_final[i] = max(min_list[j], min(max_list[j], p_unconstrained))\n            u_final[i] = 1\n    \n    # Step 8: Set uncommitted units\n    for i in range(n):\n        if i not in committed_set:\n            u_final[i] = 0\n            p_final[i] = 0.0\n\n    return np.array([u_final, p_final])",
          "from": "mutation",
          "gap_power_rate": 0.00505,
          "gap_price_rate": 0.00881,
          "fitness": 0.00693
     },
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units if committed\n2. Identify must-on units (violating min-up time or shutdown ramp)\n3. Identify must-off units (violating min-down time)\n4. Commit must-on units and compute current capacity ranges\n5. Calculate effective cost per MW for flexible units (amortized startup cost + production cost at min output)\n6. Commit flexible units incrementally by ascending effective cost until capacity covers load\n7. Decommit expensive flexible units if min output exceeds load while maintaining capacity feasibility\n8. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load (should not occur)\n   c) Perform lambda iteration for economic dispatch otherwise\n9. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    min_potential = [0] * n_units\n    max_potential = [0] * n_units\n    \n    # Precompute min/max potential outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_potential[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_potential[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_potential[i] = unit['p_min_i']\n            max_potential[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on_indices = []\n    must_off_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1: \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n        elif unit['u_i_0'] == 0:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n    \n    # Initialize committed units and capacity\n    committed_indices = set(must_on_indices)\n    total_min = sum(min_potential[i] for i in must_on_indices)\n    total_max = sum(max_potential[i] for i in must_on_indices)\n    \n    # Process flexible units\n    flexible_indices = [i for i in range(n_units) if i not in must_on_indices and i not in must_off_indices]\n    cost_data = []\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        min_pwr = min_potential[i]\n        if unit['u_i_0'] == 0:  # Startup required\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        else:  # Already running\n            cost_per_mw = (unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        cost_data.append((cost_per_mw, i))\n    \n    # Commit flexible units by ascending cost\n    cost_data.sort(key=lambda x: x[0])\n    flexible_committed = []\n    \n    for cost_val, i in cost_data:\n        if total_max < load:  # Only add if capacity insufficient\n            committed_indices.add(i)\n            flexible_committed.append(i)\n            total_min += min_potential[i]\n            total_max += max_potential[i]\n    \n    # Decommit expensive units if overgeneration occurs\n    flexible_committed.sort(key=lambda i: cost_data[flexible_indices.index(i)][0], reverse=True)\n    for i in flexible_committed:\n        if i not in committed_indices:\n            continue\n        new_min = total_min - min_potential[i]\n        new_max = total_max - max_potential[i]\n        if new_min <= load and new_max >= load:\n            committed_indices.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch power allocation\n    p_outputs = [0] * n_units\n    \n    # Case 1: Overgeneration unavoidable\n    if total_min > load:\n        for i in committed_indices:\n            p_outputs[i] = min_potential[i]\n    # Case 2: Shouldn't occur due to commitment logic\n    elif total_max < load:\n        for i in committed_indices:\n            p_outputs[i] = max_potential[i]\n    # Case 3: Economic dispatch required\n    else:\n        committed_list = list(committed_indices)\n        low_lambda = 0\n        high_lambda = 0\n        \n        # Set lambda search bounds\n        for i in committed_list:\n            unit = units_info[i]\n            cost_at_min = unit['b_i'] + 2 * unit['c_i'] * min_potential[i]\n            cost_at_max = unit['b_i'] + 2 * unit['c_i'] * max_potential[i]\n            high_lambda = max(high_lambda, cost_at_min, cost_at_max)\n        high_lambda *= 2  # Expand upper bound\n        \n        # Lambda iteration\n        tol = 0.01\n        max_iter = 100\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for i in committed_list:\n                unit = units_info[i]\n                min_p = min_potential[i]\n                max_p = max_potential[i]\n                if unit['c_i'] == 0:  # Linear units\n                    p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n                else:  # Quadratic units\n                    p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(min_p, min(max_p, p_val))\n                total_power += p_val\n            \n            if abs(total_power - load) < tol:\n                break\n            elif total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Apply final dispatch\n        for i in committed_list:\n            unit = units_info[i]\n            min_p = min_potential[i]\n            max_p = max_potential[i]\n            if unit['c_i'] == 0:\n                p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_p, min(max_p, p_val))\n            p_outputs[i] = p_val\n    \n    # Prepare output schedules\n    u_vector = [1 if i in committed_indices else 0 for i in range(n_units)]\n    schedules = np.array([u_vector, p_outputs])\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00501,
          "gap_price_rate": 0.00888,
          "fitness": 0.00695
     },
     {
          "name": "enhanced_hybrid_rolling_commitment",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for each unit considering its previous state and ramp limits\n2. Classify units as must-on (violating min-up time or shutdown ramp constraints), must-off (violating min-down time constraints), or flexible\n3. For flexible units, calculate effective cost: (a_i + s_i + b_i * p_avg + c_i * p_avg^2) / p_avg, where p_avg = (p_min_cur + p_max_cur)/2\n4. Commit must-on units, then commit flexible units by ascending effective cost until total max output >= load\n5. If total min output > load, decommit expensive flexible units in descending cost order while maintaining total max >= load\n6. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load\n   c) Perform lambda iteration for economic dispatch considering both quadratic and linear costs\n7. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_outputs = [0] * n_units\n    p_outputs = [0.0] * n_units\n    p_min_cur = [0.0] * n_units\n    p_max_cur = [0.0] * n_units\n\n    # Step 1: Precompute ramp-constrained min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Unit was online\n            p_min_cur[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Unit was offline\n            p_min_cur[i] = unit['p_min_i']\n            p_max_cur[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 2: Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:  # Was offline\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 3: Calculate effective cost for flexible units\n    effective_cost = [0.0] * n_units\n    for i in flexible:\n        unit = units_info[i]\n        p_avg = (p_min_cur[i] + p_max_cur[i]) / 2.0\n        if p_avg == 0:\n            effective_cost[i] = float('inf')\n        else:\n            fixed_cost = unit['a_i'] + unit['s_i']\n            variable_cost = unit['b_i'] * p_avg + unit['c_i'] * p_avg**2\n            effective_cost[i] = (fixed_cost + variable_cost) / p_avg\n    \n    # Step 4: Commit units\n    committed = set(must_on)\n    total_min = sum(p_min_cur[i] for i in committed)\n    total_max = sum(p_max_cur[i] for i in committed)\n    \n    sorted_flex = sorted(flexible, key=lambda i: effective_cost[i])\n    for i in sorted_flex:\n        if total_max < load:\n            committed.add(i)\n            total_min += p_min_cur[i]\n            total_max += p_max_cur[i]\n        else:\n            break\n    \n    # Step 5: Decommit if over-committed\n    if total_min > load:\n        committed_flex = [i for i in committed if i in flexible]\n        sorted_flex_decom = sorted(committed_flex, key=lambda i: effective_cost[i], reverse=True)\n        for i in sorted_flex_decom:\n            new_total_max = total_max - p_max_cur[i]\n            if new_total_max >= load:\n                committed.remove(i)\n                total_min -= p_min_cur[i]\n                total_max = new_total_max\n                if total_min <= load:\n                    break\n    \n    # Step 6: Dispatch\n    for i in committed:\n        u_outputs[i] = 1\n    \n    dispatch_min = sum(p_min_cur[i] for i in committed)\n    dispatch_max = sum(p_max_cur[i] for i in committed)\n    \n    if dispatch_min > load:\n        for i in committed:\n            p_outputs[i] = p_min_cur[i]\n    elif dispatch_max < load:\n        for i in committed:\n            p_outputs[i] = p_max_cur[i]\n    else:\n        committed_list = list(committed)\n        n_committed = len(committed_list)\n        mins = [p_min_cur[i] for i in committed_list]\n        maxs = [p_max_cur[i] for i in committed_list]\n        bs = [units_info[i]['b_i'] for i in committed_list]\n        cs = [units_info[i]['c_i'] for i in committed_list]\n        \n        # Find lambda bounds\n        min_inc = float('inf')\n        max_inc = -float('inf')\n        for i in range(n_committed):\n            if cs[i] > 0:\n                low_inc = 2 * cs[i] * mins[i] + bs[i]\n                high_inc = 2 * cs[i] * maxs[i] + bs[i]\n            else:\n                low_inc = high_inc = bs[i]\n            min_inc = min(min_inc, low_inc)\n            max_inc = max(max_inc, high_inc)\n        \n        lambda_low = min_inc - 1\n        lambda_high = max_inc + 1\n        lambda_mid = (lambda_low + lambda_high) / 2\n        tol = 0.0001\n        \n        for _ in range(100):\n            total_p = 0\n            for i in range(n_committed):\n                if cs[i] > 0:\n                    p_ideal = (lambda_mid - bs[i]) / (2 * cs[i])\n                    p_clamped = max(mins[i], min(maxs[i], p_ideal))\n                else:\n                    p_clamped = maxs[i] if lambda_mid > bs[i] else mins[i]\n                total_p += p_clamped\n            \n            if abs(total_p - load) < tol:\n                break\n            if total_p < load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            lambda_mid = (lambda_low + lambda_high) / 2\n        \n        # Assign final outputs\n        for i in range(n_committed):\n            if cs[i] > 0:\n                p_ideal = (lambda_mid - bs[i]) / (2 * cs[i])\n                p_val = max(mins[i], min(maxs[i], p_ideal))\n            else:\n                p_val = maxs[i] if lambda_mid > bs[i] else mins[i]\n            idx = committed_list[i]\n            p_outputs[idx] = p_val\n    \n    # Step 7: Format output\n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u_outputs\n    schedules[1, :] = p_outputs\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00869,
          "fitness": 0.00706
     },
     {
          "name": "enhanced_rolling_uc",
          "algorithm": "1. Classify units into must-on (forced online due to min-up-time or shutdown ramp constraints), must-off (forced offline due to min-down-time constraints), and flexible units\n2. Precompute ramp-constrained output ranges for all units considering their previous state\n3. Commit must-on units and calculate total min/max capacity\n4. Compute effective amortized cost (including startup costs) for flexible units and sort by cost\n5. Commit flexible units in ascending cost order until total max capacity >= load\n6. If total min capacity > load, decommit flexible units in descending cost order while maintaining total max capacity >= load\n7. For final committed set:\n   a) If total min capacity > load, set outputs to min\n   b) Else if total max capacity < load, set outputs to max\n   c) Else perform economic dispatch via lambda iteration to minimize production costs\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc(units_info, load):\n    num_units = len(units_info)\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units)\n    \n    # Precompute ramp-constrained bounds for each unit\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        elif unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Commit must-on units\n    committed = set(must_on)\n    total_min = sum(min_p[i] for i in must_on)\n    total_max = sum(max_p[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        min_cost = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                    unit['c_i'] * min_p[i]**2 + startup_cost)\n        costs.append((min_cost / min_p[i], i))\n    \n    # Commit flexible units in cost order\n    costs.sort(key=lambda x: x[0])\n    for cost_val, i in costs:\n        if total_max >= load:\n            break\n        committed.add(i)\n        total_min += min_p[i]\n        total_max += max_p[i]\n    \n    # Decommit expensive flexible units if overcommitted\n    committed_flex = [i for i in committed if i in flexible]\n    if total_min > load:\n        # Sort committed flexible units by cost descending\n        costs_flex = [(cost_val, i) for cost_val, i in costs if i in committed]\n        costs_flex.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in costs_flex:\n            if total_min - min_p[i] <= load:\n                break\n            if total_max - max_p[i] >= load:\n                committed.remove(i)\n                total_min -= min_p[i]\n                total_max -= max_p[i]\n    \n    # Case 1: Total min output > load\n    if total_min > load:\n        for i in committed:\n            u[i] = 1\n            p[i] = min_p[i]\n        return np.array([u, p])\n    \n    # Case 2: Total max output < load\n    if total_max < load:\n        for i in committed:\n            u[i] = 1\n            p[i] = max_p[i]\n        return np.array([u, p])\n    \n    # Case 3: Perform economic dispatch\n    # Prepare parameters for committed units\n    min_dispatch = []\n    max_dispatch = []\n    b_list = []\n    c_list = []\n    idx_mapping = []\n    for i in committed:\n        min_dispatch.append(min_p[i])\n        max_dispatch.append(max_p[i])\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n        idx_mapping.append(i)\n    \n    # Initialize dispatch parameters\n    n = len(min_dispatch)\n    dispatch_min = np.array(min_dispatch)\n    dispatch_max = np.array(max_dispatch)\n    b_arr = np.array(b_list)\n    c_arr = np.array(c_list)\n    \n    # Find lambda bounds\n    marginal_min = b_arr + 2 * c_arr * dispatch_min\n    marginal_max = b_arr + 2 * c_arr * dispatch_max\n    lambda_low = np.min(marginal_min)\n    lambda_high = np.max(marginal_max)\n    \n    # Lambda iteration\n    tol = 1e-5\n    max_iter = 1000\n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n        total_current = np.sum(p_dispatch)\n        \n        if abs(total_current - load) < tol:\n            break\n        elif total_current < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        # Use the best solution from last iteration\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n    \n    # Assign final dispatch\n    for idx, val in zip(idx_mapping, p_dispatch):\n        u[idx] = 1\n        p[idx] = val\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.0071
     }
]