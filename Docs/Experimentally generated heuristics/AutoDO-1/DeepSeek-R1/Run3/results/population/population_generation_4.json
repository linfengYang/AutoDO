[
     {
          "name": "refined_rolling_commitment_v2",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units if committed\n2. Identify must-on units (violating min-up time or shutdown ramp)\n3. Identify must-off units (violating min-down time)\n4. Commit must-on units and compute current capacity ranges\n5. Calculate effective cost per MW for flexible units (amortized startup cost + production cost at min output)\n6. Commit flexible units incrementally by ascending effective cost until capacity covers load\n7. Decommit expensive flexible units if min output exceeds load while maintaining capacity feasibility\n8. Dispatch power:\n   a) Assign min outputs if total min > load\n   b) Assign max outputs if total max < load (should not occur)\n   c) Perform lambda iteration for economic dispatch otherwise\n9. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    min_potential = [0] * n_units\n    max_potential = [0] * n_units\n    \n    # Precompute min/max potential outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_potential[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_potential[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_potential[i] = unit['p_min_i']\n            max_potential[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Identify must-on and must-off units\n    must_on_indices = []\n    must_off_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1: \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.append(i)\n        elif unit['u_i_0'] == 0:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_indices.append(i)\n    \n    # Initialize committed units and capacity\n    committed_indices = set(must_on_indices)\n    total_min = sum(min_potential[i] for i in must_on_indices)\n    total_max = sum(max_potential[i] for i in must_on_indices)\n    \n    # Process flexible units\n    flexible_indices = [i for i in range(n_units) if i not in must_on_indices and i not in must_off_indices]\n    cost_data = []\n    \n    for i in flexible_indices:\n        unit = units_info[i]\n        min_pwr = min_potential[i]\n        if unit['u_i_0'] == 0:  # Startup required\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        else:  # Already running\n            cost_per_mw = (unit['a_i'] + unit['b_i']*min_pwr + unit['c_i']*min_pwr**2) / min_pwr\n        cost_data.append((cost_per_mw, i))\n    \n    # Commit flexible units by ascending cost\n    cost_data.sort(key=lambda x: x[0])\n    flexible_committed = []\n    \n    for cost_val, i in cost_data:\n        if total_max < load:  # Only add if capacity insufficient\n            committed_indices.add(i)\n            flexible_committed.append(i)\n            total_min += min_potential[i]\n            total_max += max_potential[i]\n    \n    # Decommit expensive units if overgeneration occurs\n    flexible_committed.sort(key=lambda i: cost_data[flexible_indices.index(i)][0], reverse=True)\n    for i in flexible_committed:\n        if i not in committed_indices:\n            continue\n        new_min = total_min - min_potential[i]\n        new_max = total_max - max_potential[i]\n        if new_min <= load and new_max >= load:\n            committed_indices.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch power allocation\n    p_outputs = [0] * n_units\n    \n    # Case 1: Overgeneration unavoidable\n    if total_min > load:\n        for i in committed_indices:\n            p_outputs[i] = min_potential[i]\n    # Case 2: Shouldn't occur due to commitment logic\n    elif total_max < load:\n        for i in committed_indices:\n            p_outputs[i] = max_potential[i]\n    # Case 3: Economic dispatch required\n    else:\n        committed_list = list(committed_indices)\n        low_lambda = 0\n        high_lambda = 0\n        \n        # Set lambda search bounds\n        for i in committed_list:\n            unit = units_info[i]\n            cost_at_min = unit['b_i'] + 2 * unit['c_i'] * min_potential[i]\n            cost_at_max = unit['b_i'] + 2 * unit['c_i'] * max_potential[i]\n            high_lambda = max(high_lambda, cost_at_min, cost_at_max)\n        high_lambda *= 2  # Expand upper bound\n        \n        # Lambda iteration\n        tol = 0.01\n        max_iter = 100\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for i in committed_list:\n                unit = units_info[i]\n                min_p = min_potential[i]\n                max_p = max_potential[i]\n                if unit['c_i'] == 0:  # Linear units\n                    p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n                else:  # Quadratic units\n                    p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(min_p, min(max_p, p_val))\n                total_power += p_val\n            \n            if abs(total_power - load) < tol:\n                break\n            elif total_power < load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Apply final dispatch\n        for i in committed_list:\n            unit = units_info[i]\n            min_p = min_potential[i]\n            max_p = max_potential[i]\n            if unit['c_i'] == 0:\n                p_val = max_p if mid_lambda >= unit['b_i'] else min_p\n            else:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(min_p, min(max_p, p_val))\n            p_outputs[i] = p_val\n    \n    # Prepare output schedules\n    u_vector = [1 if i in committed_indices else 0 for i in range(n_units)]\n    schedules = np.array([u_vector, p_outputs])\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00501,
          "gap_price_rate": 0.00888,
          "fitness": 0.00695
     },
     {
          "name": "enhanced_rolling_uc",
          "algorithm": "1. Classify units into must-on (forced online due to min-up-time or shutdown ramp constraints), must-off (forced offline due to min-down-time constraints), and flexible units\n2. Precompute ramp-constrained output ranges for all units considering their previous state\n3. Commit must-on units and calculate total min/max capacity\n4. Compute effective amortized cost (including startup costs) for flexible units and sort by cost\n5. Commit flexible units in ascending cost order until total max capacity >= load\n6. If total min capacity > load, decommit flexible units in descending cost order while maintaining total max capacity >= load\n7. For final committed set:\n   a) If total min capacity > load, set outputs to min\n   b) Else if total max capacity < load, set outputs to max\n   c) Else perform economic dispatch via lambda iteration to minimize production costs\n8. Set uncommitted units to off with zero output\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_uc(units_info, load):\n    num_units = len(units_info)\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units)\n    \n    # Precompute ramp-constrained bounds for each unit\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    flexible = []\n    for i, unit in enumerate(units_info):\n        if (unit['u_i_0'] == 1 and \n            (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i'])):\n            must_on.append(i)\n        elif unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            must_off.append(i)\n        else:\n            flexible.append(i)\n    \n    # Commit must-on units\n    committed = set(must_on)\n    total_min = sum(min_p[i] for i in must_on)\n    total_max = sum(max_p[i] for i in must_on)\n    \n    # Calculate effective costs for flexible units\n    costs = []\n    for i in flexible:\n        unit = units_info[i]\n        startup_cost = unit['s_i'] if unit['u_i_0'] == 0 else 0\n        min_cost = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                    unit['c_i'] * min_p[i]**2 + startup_cost)\n        costs.append((min_cost / min_p[i], i))\n    \n    # Commit flexible units in cost order\n    costs.sort(key=lambda x: x[0])\n    for cost_val, i in costs:\n        if total_max >= load:\n            break\n        committed.add(i)\n        total_min += min_p[i]\n        total_max += max_p[i]\n    \n    # Decommit expensive flexible units if overcommitted\n    committed_flex = [i for i in committed if i in flexible]\n    if total_min > load:\n        # Sort committed flexible units by cost descending\n        costs_flex = [(cost_val, i) for cost_val, i in costs if i in committed]\n        costs_flex.sort(key=lambda x: x[0], reverse=True)\n        for cost_val, i in costs_flex:\n            if total_min - min_p[i] <= load:\n                break\n            if total_max - max_p[i] >= load:\n                committed.remove(i)\n                total_min -= min_p[i]\n                total_max -= max_p[i]\n    \n    # Case 1: Total min output > load\n    if total_min > load:\n        for i in committed:\n            u[i] = 1\n            p[i] = min_p[i]\n        return np.array([u, p])\n    \n    # Case 2: Total max output < load\n    if total_max < load:\n        for i in committed:\n            u[i] = 1\n            p[i] = max_p[i]\n        return np.array([u, p])\n    \n    # Case 3: Perform economic dispatch\n    # Prepare parameters for committed units\n    min_dispatch = []\n    max_dispatch = []\n    b_list = []\n    c_list = []\n    idx_mapping = []\n    for i in committed:\n        min_dispatch.append(min_p[i])\n        max_dispatch.append(max_p[i])\n        b_list.append(units_info[i]['b_i'])\n        c_list.append(units_info[i]['c_i'])\n        idx_mapping.append(i)\n    \n    # Initialize dispatch parameters\n    n = len(min_dispatch)\n    dispatch_min = np.array(min_dispatch)\n    dispatch_max = np.array(max_dispatch)\n    b_arr = np.array(b_list)\n    c_arr = np.array(c_list)\n    \n    # Find lambda bounds\n    marginal_min = b_arr + 2 * c_arr * dispatch_min\n    marginal_max = b_arr + 2 * c_arr * dispatch_max\n    lambda_low = np.min(marginal_min)\n    lambda_high = np.max(marginal_max)\n    \n    # Lambda iteration\n    tol = 1e-5\n    max_iter = 1000\n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n        total_current = np.sum(p_dispatch)\n        \n        if abs(total_current - load) < tol:\n            break\n        elif total_current < load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        # Use the best solution from last iteration\n        p_dispatch = np.clip((lambda_mid - b_arr) / (2 * np.maximum(c_arr, 1e-10)), dispatch_min, dispatch_max)\n    \n    # Assign final dispatch\n    for idx, val in zip(idx_mapping, p_dispatch):\n        u[idx] = 1\n        p[idx] = val\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.0071
     },
     {
          "name": "hybrid_rolling_commitment",
          "algorithm": "1. Precompute ramp-constrained min/max output for each unit considering previous state and ramp limits\n2. Classify units as must-on (due to min-up or shutdown constraints), must-off (min-down constraints), or flexible\n3. For flexible units, calculate effective cost: (fixed + startup + variable costs at min output)/min output\n4. Commit must-on units then cheapest flexible units until max capacity >= load\n5. If over-committed (min output > load), remove costly flexible units while maintaining capacity\n6. Dispatch:\n   a) Total min >= load: assign min outputs\n   b) Total max <= load: assign max outputs\n   c) Otherwise: economic dispatch via lambda iteration\n7. Set uncommitted units to off (0 output)\n\n",
          "code": "import numpy as np\n\ndef hybrid_rolling_commitment(units_info, load):\n    n = len(units_info)\n    min_outputs = np.zeros(n)\n    max_outputs = np.zeros(n)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            online_time = unit['t_i_0']\n            min_up = unit['t_on_min_i']\n            if online_time < min_up or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            offline_time = -unit['t_i_0']\n            min_down = unit['t_off_min_i']\n            if offline_time < min_down:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    effective_costs = []\n    for i in flexible:\n        unit = units_info[i]\n        cost_at_min = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i] ** 2\n        if unit['u_i_0'] == 0:\n            cost_at_min += unit['s_i']\n        effective_costs.append(cost_at_min / min_outputs[i] if min_outputs[i] > 0 else float('inf'))\n    \n    sorted_flexible = [x for _, x in sorted(zip(effective_costs, flexible))]\n    \n    committed = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    flexible_committed = []\n    \n    for idx in sorted_flexible:\n        if total_max < load:\n            committed.add(idx)\n            flexible_committed.append(idx)\n            total_min += min_outputs[idx]\n            total_max += max_outputs[idx]\n        else:\n            break\n    \n    if total_min > load:\n        temp = []\n        for idx in flexible_committed:\n            unit = units_info[idx]\n            cost_at_min = unit['a_i'] + unit['b_i'] * min_outputs[idx] + unit['c_i'] * min_outputs[idx] ** 2\n            if unit['u_i_0'] == 0:\n                cost_at_min += unit['s_i']\n            ec = cost_at_min / min_outputs[idx] if min_outputs[idx] > 0 else float('inf')\n            temp.append((ec, idx))\n        temp.sort(reverse=True)\n        \n        for ec, idx in temp:\n            if total_min - min_outputs[idx] < load:\n                continue\n            if total_max - max_outputs[idx] >= load:\n                total_min -= min_outputs[idx]\n                total_max -= max_outputs[idx]\n                committed.remove(idx)\n                flexible_committed.remove(idx)\n                if total_min < load:\n                    break\n    \n    u = np.zeros(n, dtype=int)\n    p = np.zeros(n)\n    \n    for i in committed:\n        u[i] = 1\n    \n    if committed:\n        total_min = sum(min_outputs[i] for i in committed)\n        total_max = sum(max_outputs[i] for i in committed)\n        \n        if total_min >= load:\n            for i in committed:\n                p[i] = min_outputs[i]\n        elif total_max <= load:\n            for i in committed:\n                p[i] = max_outputs[i]\n        else:\n            comm_list = list(committed)\n            b_arr = np.array([units_info[i]['b_i'] for i in comm_list])\n            c_arr = np.array([units_info[i]['c_i'] for i in comm_list])\n            min_arr = np.array([min_outputs[i] for i in comm_list])\n            max_arr = np.array([max_outputs[i] for i in comm_list])\n            \n            low_lam = np.min(2 * c_arr * min_arr + b_arr)\n            high_lam = np.max(2 * c_arr * max_arr + b_arr)\n            mid_lam = (low_lam + high_lam) / 2\n            tol = 0.01\n            max_iter = 100\n            \n            for _ in range(max_iter):\n                p_arr = (mid_lam - b_arr) / (2 * c_arr)\n                p_arr = np.clip(p_arr, min_arr, max_arr)\n                total_p = np.sum(p_arr)\n                if abs(total_p - load) < tol:\n                    break\n                if total_p < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n                mid_lam = (low_lam + high_lam) / 2\n            \n            for idx, value in zip(comm_list, p_arr):\n                p[idx] = value\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "enhanced_rolling_commitment_v3",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units\n2. Identify must-on units (violating min-up time or shutdown ramp constraints) and must-off units (violating min-down time constraints)\n3. Commit must-on units, set must-off units to off\n4. Calculate amortized effective cost for flexible units (startup cost + min production cost, scaled by min output)\n5. Commit flexible units incrementally by ascending effective cost until total max capacity covers load\n6. If total min output exceeds load, decommit expensive flexible units while maintaining capacity coverage\n7. Dispatch power:\n   a) Set to min outputs if total min > load\n   b) Set to max outputs if total max < load\n   c) Perform lambda iteration for economic dispatch otherwise (handling quadratic and linear costs with swing units)\n8. Set uncommitted units to off with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v3(units_info, load):\n    # Precompute ramp-constrained min/max outputs and identify units\n    units = []\n    for idx, unit_dict in enumerate(units_info):\n        u_i_0 = unit_dict['u_i_0']\n        p_i_0 = unit_dict['p_i_0']\n        p_min_i = unit_dict['p_min_i']\n        p_max_i = unit_dict['p_max_i']\n        p_up_i = unit_dict['p_up_i']\n        p_down_i = unit_dict['p_down_i']\n        p_start_i = unit_dict['p_start_i']\n        \n        # Ramp-constrained output limits\n        if u_i_0 == 1:\n            p_min_cur = max(p_min_i, p_i_0 - p_down_i)\n            p_max_cur = min(p_max_i, p_i_0 + p_up_i)\n        else:\n            p_min_cur = p_min_i\n            p_max_cur = min(p_max_i, p_start_i)\n        \n        units.append({\n            'idx': idx,\n            'u_i_0': u_i_0,\n            'p_i_0': p_i_0,\n            't_i_0': unit_dict['t_i_0'],\n            'p_min_i': p_min_i,\n            'p_max_i': p_max_i,\n            'p_min_cur': p_min_cur,\n            'p_max_cur': p_max_cur,\n            't_on_min': unit_dict['t_on_min_i'],\n            't_off_min': unit_dict['t_off_min_i'],\n            'p_shut_i': unit_dict['p_shut_i'],\n            's_i': unit_dict['s_i'],\n            'a_i': unit_dict['a_i'],\n            'b_i': unit_dict['b_i'],\n            'c_i': unit_dict['c_i'],\n            'must_on': False,\n            'must_off': False,\n            'committed': False,\n            'eff_cost': 0.0,\n            'u_i': 0,\n            'p_i': 0.0\n        })\n    \n    # Identify must-on and must-off units\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min'] or unit['p_i_0'] > unit['p_shut_i']:\n                unit['must_on'] = True\n                unit['committed'] = True\n                unit['u_i'] = 1\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min']:\n            unit['must_off'] = True\n            unit['committed'] = False\n            unit['u_i'] = 0\n    \n    # Calculate effective costs for flexible units\n    flex_units = [u for u in units if not u['must_on'] and not u['must_off']]\n    for unit in flex_units:\n        if unit['u_i_0'] == 0:\n            prod_cost = unit['a_i'] + unit['b_i'] * unit['p_min_cur'] + unit['c_i'] * unit['p_min_cur']**2\n            unit['eff_cost'] = (unit['s_i'] + prod_cost) / unit['p_min_cur']\n        else:\n            prod_cost = unit['a_i'] + unit['b_i'] * unit['p_min_cur'] + unit['c_i'] * unit['p_min_cur']**2\n            unit['eff_cost'] = prod_cost / unit['p_min_cur']\n    flex_units_sorted = sorted(flex_units, key=lambda x: x['eff_cost'])\n    \n    # Commit must-on and flexible units\n    tot_min = sum(u['p_min_cur'] for u in units if u['committed'])\n    tot_max = sum(u['p_max_cur'] for u in units if u['committed'])\n    committed_flex = []\n    \n    for unit in flex_units_sorted:\n        if tot_max >= load:\n            break\n        tot_min += unit['p_min_cur']\n        tot_max += unit['p_max_cur']\n        unit['committed'] = True\n        unit['u_i'] = 1\n        committed_flex.append(unit)\n    \n    # Decommit expensive units if over minimum output\n    if tot_min > load:\n        committed_flex_sorted = sorted(committed_flex, key=lambda x: x['eff_cost'], reverse=True)\n        for unit in committed_flex_sorted:\n            new_min = tot_min - unit['p_min_cur']\n            new_max = tot_max - unit['p_max_cur']\n            if new_max >= load:\n                tot_min, tot_max = new_min, new_max\n                unit['committed'] = False\n                unit['u_i'] = 0\n                if tot_min <= load:\n                    break\n    \n    # Dispatch power\n    committed_units = [u for u in units if u['committed']]\n    tot_min = sum(u['p_min_cur'] for u in committed_units)\n    tot_max = sum(u['p_max_cur'] for u in committed_units)\n    \n    if tot_min > load:\n        for u in committed_units:\n            u['p_i'] = u['p_min_cur']\n    elif tot_max < load:\n        for u in committed_units:\n            u['p_i'] = u['p_max_cur']\n    else:\n        # Lambda iteration for economic dispatch\n        low = -1e9\n        high = 1e9\n        tol = 1.0\n        max_iter = 100\n        lambda_mid = 0.0\n        \n        for _ in range(max_iter):\n            lambda_mid = (low + high) / 2.0\n            non_swing_out = 0.0\n            swing_units = []\n            \n            for unit in committed_units:\n                if unit['c_i'] == 0 and abs(lambda_mid - unit['b_i']) < 1e-5:\n                    swing_units.append(unit)\n                elif unit['c_i'] > 0:\n                    p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                    non_swing_out += max(unit['p_min_cur'], min(p_i, unit['p_max_cur']))\n                else:\n                    if lambda_mid < unit['b_i']:\n                        non_swing_out += unit['p_min_cur']\n                    else:\n                        non_swing_out += unit['p_max_cur']\n            \n            swing_min = sum(u['p_min_cur'] for u in swing_units)\n            swing_max = sum(u['p_max_cur'] for u in swing_units)\n            swing_needed = load - non_swing_out\n            \n            if swing_needed < swing_min:\n                total_out = non_swing_out + swing_min\n            elif swing_needed > swing_max:\n                total_out = non_swing_out + swing_max\n            else:\n                total_out = non_swing_out + swing_needed\n            \n            if total_out < load:\n                low = lambda_mid\n            else:\n                high = lambda_mid\n            \n            if abs(total_out - load) < tol:\n                break\n        \n        # Apply final dispatch\n        non_swing_out = 0.0\n        swing_units = []\n        for unit in committed_units:\n            if unit['c_i'] == 0 and abs(lambda_mid - unit['b_i']) < 1e-5:\n                swing_units.append(unit)\n            elif unit['c_i'] > 0:\n                p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                unit['p_i'] = max(unit['p_min_cur'], min(p_i, unit['p_max_cur']))\n                non_swing_out += unit['p_i']\n            else:\n                if lambda_mid < unit['b_i']:\n                    unit['p_i'] = unit['p_min_cur']\n                else:\n                    unit['p_i'] = unit['p_max_cur']\n                non_swing_out += unit['p_i']\n        \n        # Distribute swing load\n        swing_needed = load - non_swing_out\n        if swing_needed <= 0:\n            for unit in swing_units:\n                unit['p_i'] = unit['p_min_cur']\n        else:\n            swing_range = swing_max - swing_min\n            if swing_range > 0:\n                for unit in swing_units:\n                    alloc = min(swing_needed, unit['p_max_cur'] - unit['p_min_cur'])\n                    unit['p_i'] = unit['p_min_cur'] + alloc\n                    swing_needed -= alloc\n                    if swing_needed <= 0:\n                        break\n    \n    # Output schedule\n    schedules = np.zeros((2, len(units_info)))\n    for idx, unit in enumerate(units):\n        schedules[0, idx] = unit['u_i']\n        schedules[1, idx] = unit['p_i']\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00877,
          "fitness": 0.00716
     },
     {
          "name": "refined_rolling_unit_commitment",
          "algorithm": "1. Categorize units into must-on (must remain on due to min up-time or shutdown ramp constraints), must-off (must remain off due to min down-time constraints), and flexible units.\n2. Precompute ramp-constrained min and max outputs for every unit if committed.\n3. Commit must-on units, calculate current total min and max output.\n4. Compute effective cost for flexible units (amortized startup cost over minimum output) and sort ascending.\n5. Commit flexible units in cost order until total max output >= load.\n6. If total min output > load, decommit expensive flexible units (descending cost order) while maintaining total max >= load.\n7. For final committed set:\n   a) If total min output > load, assign min outputs.\n   b) Else if total max output < load, assign max outputs.\n   c) Else perform economic dispatch via lambda iteration to minimize quadratic production costs.\n8. Set uncommitted units to off with zero output.\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_unit_commitment(units_info, load):\n    # Initialize arrays\n    num_units = len(units_info)\n    u_list = [0.0] * num_units\n    p_list = [0.0] * num_units\n    min_outputs = [0.0] * num_units\n    max_outputs = [0.0] * num_units\n    effective_costs = [0.0] * num_units\n\n    # Step 1: Categorize units and precompute outputs\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        # Compute ramp-constrained min/max outputs\n        if unit['u_i_0'] == 1:  # Previously online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            \n        min_outputs[i] = min_out\n        max_outputs[i] = max_out\n        \n        # Categorization\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n                \n        # Precompute effective costs\n        if min_out > 0:\n            prod_cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            effective_costs[i] = (prod_cost + unit['s_i']) / min_out\n        else:\n            effective_costs[i] = 1e12  # Large number if min_out=0\n\n    # Step 2: Commit must-on units\n    committed_set = set(must_on)\n    total_min = sum(min_outputs[i] for i in must_on)\n    total_max = sum(max_outputs[i] for i in must_on)\n    \n    # Step 3: Sort flexible units by effective cost\n    flexible = sorted(flexible, key=lambda i: effective_costs[i])\n    \n    # Step 4: Commit flexible until capacity >= load\n    for i in flexible:\n        if total_max < load:\n            committed_set.add(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    # Step 5: Backward pass for over-commitment\n    if total_min > load:\n        expensive_flex = sorted(\n            [i for i in committed_set if i not in must_on],\n            key=lambda i: effective_costs[i],\n            reverse=True\n        )\n        for i in expensive_flex:\n            new_min = total_min - min_outputs[i]\n            new_max = total_max - max_outputs[i]\n            if new_max >= load:\n                committed_set.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= load:\n                    break\n    \n    # Step 6: Assign outputs\n    # Case 1: Overgeneration (set to min)\n    if total_min > load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = min_outputs[i]\n    # Case 2: Undergeneration (set to max)\n    elif total_max < load:\n        for i in committed_set:\n            u_list[i] = 1.0\n            p_list[i] = max_outputs[i]\n    # Case 3: Economic dispatch\n    else:\n        # Prepare for dispatch\n        B = []\n        C = []\n        P_MIN = []\n        P_MAX = []\n        commit_indices = sorted(committed_set)\n        \n        for i in commit_indices:\n            unit = units_info[i]\n            B.append(unit['b_i'])\n            C.append(unit['c_i'])\n            P_MIN.append(min_outputs[i])\n            P_MAX.append(max_outputs[i])\n        \n        n = len(commit_indices)\n        if n == 0:  # No units to dispatch\n            pass\n        else:\n            # Lambda iteration setup\n            low_lam = 1e12\n            high_lam = -1e12\n            \n            for i in range(n):\n                b = B[i]\n                c = C[i]\n                p_min = P_MIN[i]\n                p_max = P_MAX[i]\n                if c == 0:  # Linear unit\n                    low_lam = min(low_lam, b)\n                    high_lam = max(high_lam, b)\n                else:  # Quadratic unit\n                    low_lam = min(low_lam, 2*c*p_min + b)\n                    high_lam = max(high_lam, 2*c*p_max + b)\n            \n            # Binary search\n            max_iter = 100\n            tol = 1e-3\n            for _ in range(max_iter):\n                mid_lam = (low_lam + high_lam) / 2.0\n                total_power = 0.0\n                p_dispatch = []\n                \n                for i in range(n):\n                    b = B[i]\n                    c = C[i]\n                    p_min = P_MIN[i]\n                    p_max = P_MAX[i]\n                    \n                    if c == 0:  # Linear\n                        p_i = p_max if mid_lam >= b else p_min\n                    else:  # Quadratic\n                        p_desired = (mid_lam - b) / (2 * c)\n                        p_i = min(max(p_desired, p_min), p_max)\n                    \n                    p_dispatch.append(p_i)\n                    total_power += p_i\n                \n                if abs(total_power - load) < tol:\n                    break\n                if total_power < load:\n                    low_lam = mid_lam\n                else:\n                    high_lam = mid_lam\n            \n            # Assign dispatch results\n            for idx, i in enumerate(commit_indices):\n                u_list[i] = 1.0\n                p_list[i] = p_dispatch[idx]\n    \n    # Set uncommitted units\n    for i in range(num_units):\n        if i not in committed_set:\n            u_list[i] = 0.0\n            p_list[i] = 0.0\n    \n    return np.array([u_list, p_list])",
          "from": "mutation",
          "gap_power_rate": 0.00539,
          "gap_price_rate": 0.00901,
          "fitness": 0.0072
     },
     {
          "name": "enhanced_hybrid_uc_v1",
          "algorithm": "1. Precompute ramp-constrained min/max outputs for all units considering previous states and ramp limits\n2. Classify units into:\n   - Must-on: units violating min-up time or shutdown constraints\n   - Must-off: units violating min-down time constraints\n   - Flexible: remaining units\n3. Commit must-on units and precompute total min/max capacity\n4. Calculate effective cost for flexible units (amortized startup cost + production cost at min output)\n5. Commit flexible units in ascending effective cost order until total max output >= load\n6. If total min output > load, decommit expensive flexible units in descending cost order while maintaining sufficient capacity\n7. Perform economic dispatch on committed units:\n   - If total min >= load: assign min outputs\n   - Else: use merit order allocation to distribute remaining load based on marginal costs\n8. Set uncommitted units to off state with zero output\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_uc_v1(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n, dtype=int)\n    p = np.zeros(n)\n    \n    # Initialize lists and dictionaries\n    must_on = []\n    must_off = []\n    flexible = []\n    min_outputs = {}\n    max_outputs = {}\n    eff_costs = {}\n    \n    # Classify units and compute ramp-constrained outputs\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Previously online\n            min_on = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_on = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            \n            # Check min-up and shutdown constraints\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                must_on.append(idx)\n                min_outputs[idx] = min_on\n                max_outputs[idx] = max_on\n            else:\n                flexible.append(idx)\n                min_outputs[idx] = min_on\n                max_outputs[idx] = max_on\n                # Effective cost: no startup cost, include fixed cost\n                cost = unit['a_i'] + unit['b_i'] * min_on + unit['c_i'] * min_on**2\n                eff_costs[idx] = cost / min_on\n                \n        else:  # Previously offline\n            min_on = unit['p_min_i']\n            max_on = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Check min-down constraint\n            if -t0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible.append(idx)\n                min_outputs[idx] = min_on\n                max_outputs[idx] = max_on\n                # Effective cost: include startup cost\n                cost = unit['a_i'] + unit['s_i'] + unit['b_i'] * min_on + unit['c_i'] * min_on**2\n                eff_costs[idx] = cost / min_on\n    \n    # Initialize total capacities\n    total_min = 0.0\n    total_max = 0.0\n    committed = set()\n    \n    # Commit must-on units\n    for idx in must_on:\n        u[idx] = 1\n        committed.add(idx)\n        total_min += min_outputs[idx]\n        total_max += max_outputs[idx]\n    \n    # Set must-off units to off\n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    # Sort flexible units by effective cost\n    flexible_sorted = sorted(flexible, key=lambda i: eff_costs[i])\n    flex_committed = []\n    \n    # Commit flexible units until coverage achieved\n    for idx in flexible_sorted:\n        if total_max < load:\n            u[idx] = 1\n            committed.add(idx)\n            flex_committed.append(idx)\n            total_min += min_outputs[idx]\n            total_max += max_outputs[idx]\n    \n    # Decommit expensive units if overcommitted\n    if total_min > load:\n        flex_committed.sort(key=lambda i: eff_costs[i], reverse=True)\n        for idx in flex_committed:\n            if total_min - min_outputs[idx] >= load:\n                u[idx] = 0\n                committed.discard(idx)\n                total_min -= min_outputs[idx]\n                total_max -= max_outputs[idx]\n            else:\n                break\n    \n    # Initialize dispatch with minimum outputs\n    for idx in committed:\n        p[idx] = min_outputs[idx]\n    \n    # Calculate remaining load to dispatch\n    remaining = load - sum(p[idx] for idx in committed)\n    \n    # Merit-order dispatch for remaining load\n    if remaining > 1e-6:\n        # Get dispatchable units not at max capacity\n        dispatchable = [idx for idx in committed if p[idx] < max_outputs[idx]]\n        remaining_load = remaining\n        \n        while remaining_load > 1e-6 and dispatchable:\n            # Find unit with lowest marginal cost\n            best_idx = None\n            best_cost = float('inf')\n            \n            for idx in dispatchable:\n                marginal_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * p[idx]\n                if marginal_cost < best_cost:\n                    best_cost = marginal_cost\n                    best_idx = idx\n            \n            # Calculate available capacity for best unit\n            available = max_outputs[best_idx] - p[best_idx]\n            dispatch_amount = min(available, remaining_load)\n            \n            # Dispatch and update\n            p[best_idx] += dispatch_amount\n            remaining_load -= dispatch_amount\n            \n            # Remove from dispatchable if at max\n            if p[best_idx] >= max_outputs[best_idx] - 1e-6:\n                dispatchable.remove(best_idx)\n    \n    # Ensure uncommitted units are off\n    for idx in range(n):\n        if u[idx] == 0:\n            p[idx] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00618,
          "gap_price_rate": 0.01024,
          "fitness": 0.00821
     }
]