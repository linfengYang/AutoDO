[
     {
          "name": "amortized_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online and either min up-time not met (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previous state offline and min down-time not met (|t_i_0| < t_off_min_i)).\n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]. Compute total min/max generation capacity.\n3. If load exceeds total max generation capacity:\n   a) Identify startable units not forced on/off that satisfy minimum downtime\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Sort startable units by ascending amortized cost\n   d) Commit units in sorted order, updating total capacity and setting new unit bounds to [p_min_i, min(p_max_i, p_start_i)], until capacity >= load\n4. Set dispatch target = max(total_min, min(total_max, load))\n5. Perform economic dispatch via lambda iteration:\n   a) Initialize lambda bounds and use bisection to find optimal lambda\n   b) For each committed unit:\n        - Quadratic units: set p_i = (\u03bb - b_i)/(2*c_i)\n        - Linear units: set p_i = p_min_i if \u03bb < b_i, else p_max_i\n   c) Clamp power to unit's feasible bounds\n   d) Adjust lambda until generation matches target within tolerance\n   e) Apply proportional adjustment for residual load if needed\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n",
          "code": "import numpy as np\n\ndef amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    committed_mask = [False] * n_units\n    low_bounds = [0.0] * n_units\n    high_bounds = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n                committed_mask[i] = True\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2 & 3: Initialize committed units and commit more if needed\n    total_min = sum(low_bounds)\n    total_max = sum(high_bounds)\n    \n    if load > total_max:\n        startable_units = []\n        for i, unit in enumerate(units_info):\n            if not committed_mask[i] and not forced_off[i] and unit['t_off_min_i'] <= abs(unit['t_i_0']):\n                s_i = unit['s_i']\n                t_up_min = unit['t_on_min_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                amortized_cost = (s_i / min(t_up_min, 24) + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                startable_units.append((i, amortized_cost, p_min_i, unit['p_max_i'], unit['p_start_i']))\n        \n        if startable_units:\n            startable_units.sort(key=lambda x: x[1])\n            for unit_data in startable_units:\n                i, _, p_min_i, p_max_i, p_start_i = unit_data\n                new_high = min(p_max_i, p_start_i)\n                if total_max + new_high >= load:\n                    break\n                committed_mask[i] = True\n                low_bounds[i] = p_min_i\n                high_bounds[i] = new_high\n                total_min += p_min_i\n                total_max += new_high\n    \n    # Step 4: Dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if committed_mask[i]]\n    if committed_indices:\n        low_lambda = 0.0\n        high_lambda = 2000.0\n        tol = 0.01\n        max_iter = 1000\n        n_iter = 0\n        lambda_val = (low_lambda + high_lambda) / 2\n        \n        while n_iter < max_iter and abs(high_lambda - low_lambda) > 1e-5:\n            total_p = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                lb = low_bounds[i]\n                ub = high_bounds[i]\n                if unit['c_i'] > 0:\n                    p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = ub if lambda_val > unit['b_i'] else lb\n                p_val = max(lb, min(ub, p_val))\n                total_p += p_val\n            \n            if total_p < target:\n                low_lambda = lambda_val\n            else:\n                high_lambda = lambda_val\n            lambda_val = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Final assignment\n        total_p = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            lb = low_bounds[i]\n            ub = high_bounds[i]\n            if unit['c_i'] > 0:\n                p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = ub if lambda_val > unit['b_i'] else lb\n            p_val = max(lb, min(ub, p_val))\n            total_p += p_val\n            p_i[i] = p_val\n            u_i[i] = 1\n        \n        # Residual adjustment\n        residual = target - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                headrooms = [high_bounds[i] - p_i[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        add = factor * headrooms[idx]\n                        p_i[i] = min(high_bounds[i], p_i[i] + add)\n            else:\n                headrooms = [p_i[i] - low_bounds[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, -residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        p_i[i] = max(low_bounds[i], p_i[i] - factor * headrooms[idx])\n    \n    # Prepare output\n    schedules = np.vstack([np.array(u_i), np.array(p_i)])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00653,
          "gap_price_rate": 0.00537,
          "fitness": 0.00595
     },
     {
          "name": "refined_adaptive_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                forced_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                forced_off.append(i)\n                \n    committed = set(forced_on)\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        min_output[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n        max_output[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        total_min += min_output[i]\n        total_max += max_output[i]\n        \n    candidates = []\n    \n    for i in range(n):\n        if i in committed or i in forced_off:\n            continue\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            adjusted_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            candidates.append((i, adjusted_cost, 'A', min_bound, max_bound))\n        else:\n            adjusted_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, adjusted_cost, 'B', min_bound, max_bound))\n            \n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        \n    for i, cost, typ, min_b, max_b in candidates:\n        if total_max >= load:\n            break\n        committed.add(i)\n        min_output[i] = min_b\n        max_output[i] = max_b\n        total_min += min_b\n        total_max += max_b\n        \n    dispatch_target = load\n    if total_min >= total_max:\n        dispatch_target = total_min\n    else:\n        if dispatch_target < total_min:\n            dispatch_target = total_min\n        elif dispatch_target > total_max:\n            dispatch_target = total_max\n            \n    p_dispatch = [0.0] * n\n    if committed:\n        low_lambda = 0.0\n        high_lambda = 10000.0\n        tol = 0.01\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = min_output[i]\n                p_max_i = max_output[i]\n                \n                if c_i == 0:\n                    if mid_lambda <= b_i:\n                        power = p_min_i\n                    else:\n                        power = p_max_i\n                else:\n                    unconstrained = (mid_lambda - b_i) / (2 * c_i)\n                    if unconstrained < p_min_i:\n                        power = p_min_i\n                    elif unconstrained > p_max_i:\n                        power = p_max_i\n                    else:\n                        power = unconstrained\n                p_dispatch[i] = power\n                total_power += power\n                \n            if abs(total_power - dispatch_target) <= tol:\n                break\n                \n            if total_power < dispatch_target:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n                \n    u_final = [0] * n\n    p_final = [0.0] * n\n    for i in range(n):\n        if i in committed:\n            u_final[i] = 1\n            p_final[i] = p_dispatch[i]\n            \n    return np.array([u_final, p_final])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "amortized_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previously online and either minimum up-time unsatisfied (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previously offline and minimum down-time unsatisfied (abs(t_i_0) < t_off_min_i)).\n2. Initialize committed units as forced-on units. Compute feasible power ranges:\n   - Forced-on units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Calculate total minimum/maximum generation capacity\n3. If load exceeds total maximum capacity:\n   a) Identify startable units not forced on/off and meeting minimum down-time\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Commit units by ascending amortized cost order until capacity >= load\n   d) Set new unit ranges: [p_min_i, min(p_max_i, p_start_i)]\n4. Set dispatch target to load clamped between updated total min/max capacity\n5. Perform lambda iteration for economic dispatch:\n   a) Initialize lambda bounds based on marginal costs\n   b) For each unit, compute unconstrained power using unit-specific cost function\n   c) Clamp power to unit's feasible range based on operational history\n   d) Adjust lambda via bisection until generation matches target within tolerance\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef amortized_refined_adaptive_commitment(units_info, load):\n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    committed_indices = []\n    \n    # Identify forced on/off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Previously online\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                forced_on_indices.append(idx)\n            else:\n                free_indices.append(idx)\n        else:  # Previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off_indices.append(idx)\n            else:\n                free_indices.append(idx)\n    \n    # Initialize committed units to forced-on units\n    committed_indices = forced_on_indices.copy()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Set power ranges and calculate total capacity for committed units\n    for idx in committed_indices:\n        unit = units_info[idx]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        total_min += lb\n        total_max += ub\n    \n    # Commit additional units if capacity insufficient\n    if total_max < load:\n        candidate_units = []\n        for idx in free_indices:\n            unit = units_info[idx]\n            p_min_i = unit['p_min_i']\n            # Calculate amortized startup cost (spread over min up-time capped at 24h)\n            amort_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n            # Calculate adjusted cost per MW at minimum output\n            adj_cost = (amort_startup + unit['a_i'] + unit['b_i']*p_min_i + unit['c_i']*p_min_i**2) / p_min_i\n            candidate_units.append((adj_cost, idx, unit))\n        \n        # Sort by ascending adjusted cost\n        candidate_units.sort(key=lambda x: x[0])\n        \n        # Commit units until capacity meets demand\n        for _, idx, unit in candidate_units:\n            if total_max >= load:\n                break\n            committed_indices.append(idx)\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            unit['lb'] = lb\n            unit['ub'] = ub\n            total_min += lb\n            total_max += ub\n            free_indices.remove(idx)\n    \n    # Calculate dispatch target\n    target = max(total_min, min(load, total_max))\n    \n    # Lambda iteration for economic dispatch\n    tol = 0.1  # MW tolerance\n    max_iter = 1000\n    iter_count = 0\n    lambda_low = 0.0\n    lambda_high = 0.0\n    \n    # Initialize lambda bounds based on marginal costs\n    for idx in committed_indices:\n        unit = units_info[idx]\n        # Consider marginal cost at bounds\n        if unit['c_i'] != 0:\n            mc_min = 2*unit['c_i']*unit['lb'] + unit['b_i']\n            mc_max = 2*unit['c_i']*unit['ub'] + unit['b_i']\n        else:  # Linear cost\n            mc_min = mc_max = unit['b_i']\n        lambda_low = min(lambda_low, mc_min)\n        lambda_high = max(lambda_high, mc_max)\n    \n    # Expand bounds conservatively\n    lambda_low = max(0, lambda_low - 100)\n    lambda_high += 100\n    \n    # Bisection loop\n    while iter_count < max_iter:\n        total_gen = 0.0\n        lambda_mid = (lambda_low + lambda_high) / 2\n        \n        for idx in committed_indices:\n            unit = units_info[idx]\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            # Calculate unconstrained dispatch\n            if unit['c_i'] != 0:  # Quadratic cost\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                # Clamp to feasible range\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:  # Linear cost\n                # Always operate at bounds based on lambda vs marginal cost\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            total_gen += p_dispatch\n        \n        # Adjust lambda bounds\n        if abs(total_gen - target) < tol:\n            break\n        elif total_gen < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n            \n        iter_count += 1\n    \n    # Final dispatch and set outputs\n    schedules = np.zeros((2, len(units_info)))\n    for idx, unit in enumerate(units_info):\n        if idx in committed_indices:\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            if unit['c_i'] != 0:\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            schedules[0, idx] = 1\n            schedules[1, idx] = p_dispatch\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00792,
          "fitness": 0.00717
     },
     {
          "name": "enhanced_amortized_adaptive_commitment_v2",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time violations or shutdown ramp constraints) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units with forced-on units and set their feasible power ranges using ramp constraints.\n3. If existing capacity is insufficient, identify startable units (non-forced on/off, meeting minimum downtime), calculate amortized cost including startup expenses, and commit units in ascending cost order until capacity meets load, applying startup ramp limits for new units.\n4. Perform decommitment: Identify non-forced-on committed units eligible for shutdown (satisfying ramp down constraints). Calculate operating cost at minimum output, and remove high-cost units in descending order if system capacity remains sufficient without them.\n5. Set dispatch target to load clamped between updated total min/max capacity.\n6. Perform economic dispatch via lambda iteration respecting ramp constraints for existing units, startup ramp limits for new units, and individual unit min/max limits.\n7. Set non-committed units to offline with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = [False] * n\n    forced_off = [False] * n\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on[i] = True\n        elif u0 == 0:\n            if abs(t0) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    low_bound = [0] * n\n    high_bound = [0] * n\n    committed = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Step 2: Initialize with forced-on units\n    for i, unit in enumerate(units_info):\n        if forced_on[i]:\n            low_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            committed.append(i)\n            total_min += low_bound[i]\n            total_max += high_bound[i]\n    \n    # Step 3: Add startable units if capacity insufficient\n    startable = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0_abs = abs(unit['t_i_0'])\n        if not forced_on[i] and not forced_off[i] and u0 == 0 and t0_abs >= unit['t_off_min_i']:\n            startable.append(i)\n    \n    amortized_costs = []\n    for i in startable:\n        unit = units_info[i]\n        t_amort = min(unit['t_on_min_i'], 24)\n        num = (unit['s_i'] / t_amort) + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        amortized_costs.append(num / unit['p_min_i'])\n    \n    sorted_startable = [idx for _, idx in sorted(zip(amortized_costs, startable))]\n    \n    for i in sorted_startable:\n        if total_max < load:\n            low_i = units_info[i]['p_min_i']\n            high_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            low_bound[i] = low_i\n            high_bound[i] = high_i\n            committed.append(i)\n            total_min += low_i\n            total_max += high_i\n    \n    # Step 4: Decommit non-forced-on units if possible\n    changed = True\n    while changed and len(committed) > 0:\n        changed = False\n        decommit_candidates = []\n        op_costs = []\n        for i in committed:\n            if forced_on[i]:\n                continue\n            unit = units_info[i]\n            eligible = False\n            if unit['u_i_0'] == 0:\n                eligible = True\n            elif unit['u_i_0'] == 1 and unit['p_i_0'] <= unit['p_down_i']:\n                eligible = True\n            if eligible:\n                decommit_candidates.append(i)\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n                op_costs.append(cost)\n        \n        if not decommit_candidates:\n            break\n        \n        sorted_indices = [idx for _, idx in sorted(zip(op_costs, decommit_candidates), reverse=True)]\n        \n        for i in sorted_indices:\n            new_min = total_min - low_bound[i]\n            new_max = total_max - high_bound[i]\n            if new_min <= load <= new_max:\n                committed.remove(i)\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n    \n    # Step 5: Set dispatch target\n    dispatch_target = np.clip(load, total_min, total_max)\n    \n    # Step 6: Economic dispatch via lambda iteration\n    p_outputs = [0.0] * n\n    if not committed:\n        return np.zeros((2, n))\n    \n    n_committed = len(committed)\n    lambda_low = 0.0\n    lambda_high = 10000.0\n    tolerance = 0.1\n    max_iter = 1000\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0.0\n        temp_outputs = []\n        \n        for idx in committed:\n            unit = units_info[idx]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            low_i = low_bound[idx]\n            high_i = high_bound[idx]\n            \n            if c_i > 0:\n                p_val = (lambda_mid - b_i) / (2 * c_i)\n                p_val = max(low_i, min(high_i, p_val))\n            else:\n                if lambda_mid < b_i:\n                    p_val = low_i\n                else:\n                    p_val = high_i\n            total_power += p_val\n            temp_outputs.append(p_val)\n        \n        if abs(total_power - dispatch_target) <= tolerance:\n            for j, idx in enumerate(committed):\n                p_outputs[idx] = temp_outputs[j]\n            break\n        \n        if total_power < dispatch_target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        for idx in committed:\n            unit = units_info[idx]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            low_i = low_bound[idx]\n            high_i = high_bound[idx]\n            if c_i > 0:\n                p_val = (lambda_high - b_i) / (2 * c_i)\n                p_val = max(low_i, min(high_i, p_val))\n            else:\n                p_val = high_i if lambda_high >= b_i else low_i\n            p_outputs[idx] = p_val\n    \n    # Step 7: Set schedules\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = p_outputs[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00802,
          "fitness": 0.00722
     },
     {
          "name": "enhanced_amortized_rolling_commitment",
          "algorithm": "1. Identify forced-on units (previous state online with minimum up-time not satisfied or shutdown ramp violation) and forced-off units (previous state offline with minimum down-time not satisfied).  \n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits.  \n3. If load exceeds current maximum capacity:  \n   a) Identify free units (neither forced-on nor forced-off) split into kept-on units (previously online) and startable units (previously offline).  \n   b) For kept-on units, calculate average operating cost per MW at minimum output. For startable units, calculate amortized cost per MW including startup cost amortized over minimum up-time.  \n   c) Combine and sort units by ascending cost.  \n   d) Commit units in sorted order, updating bounds for kept-on and startable units, until capacity suffices.  \n4. Set dispatch target clamped between total minimum and maximum capacity.  \n5. Perform economic dispatch via lambda iteration with bisection to minimize costs, ensuring solutions respect power bounds.  \n6. Adjust residual load distribution using marginal cost priority if necessary.  \n7. Set non-committed units offline with zero output.  \n8. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    commited_status = [False] * n_units\n    p_min_cur = [0.0] * n_units\n    p_max_cur = [0.0] * n_units\n    p_output = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        u_prev = unit['u_i_0']\n        t_prev = unit['t_i_0']\n        p_prev = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_prev == 1:\n            if t_prev < min_up or p_prev > p_shut:\n                forced_on.append(i)\n        else:\n            if abs(t_prev) < min_down:\n                forced_off.append(i)\n    \n    # Step 2: Initialize committed units (forced-on)\n    total_min = 0.0\n    total_max = 0.0\n    for i in forced_on:\n        unit = units_info[i]\n        commited_status[i] = True\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_prev = unit['p_i_0']\n        \n        p_min_cur[i] = max(p_min, p_prev - p_down)\n        p_max_cur[i] = min(p_max, p_prev + p_up)\n        total_min += p_min_cur[i]\n        total_max += p_max_cur[i]\n    \n    # Step 3: Commit additional units if needed\n    if total_max < load:\n        kepton = []\n        startable = []\n        free_units = []\n        \n        # Find free units not forced on/off\n        for i in range(n_units):\n            if commited_status[i] or i in forced_off:\n                continue\n            free_units.append(i)\n        \n        # Split into kepton and startable\n        for i in free_units:\n            u_prev = units_info[i]['u_i_0']\n            if u_prev == 1:\n                kepton.append(i)\n            else:\n                startable.append(i)\n        \n        # Calculate costs\n        unit_costs = []\n        for i in kepton:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            p_min = unit['p_min_i']\n            base_cost = a + b * p_min + c * p_min ** 2\n            cost_per_mw = base_cost / p_min\n            unit_costs.append((cost_per_mw, i, 'kepton'))\n        \n        for i in startable:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            p_min = unit['p_min_i']\n            min_up = unit['t_on_min_i']\n            s_cost = unit['s_i']\n            amortization = min(min_up, 24)\n            base_cost = (s_cost / amortization) + a + b * p_min + c * p_min ** 2\n            cost_per_mw = base_cost / p_min\n            unit_costs.append((cost_per_mw, i, 'startable'))\n        \n        # Sort by cost ascending\n        unit_costs.sort(key=lambda x: x[0])\n        \n        # Commit units until load is satisfied\n        for cost_val, i, unit_type in unit_costs:\n            if total_max >= load:\n                break\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            commited_status[i] = True\n            \n            if unit_type == 'kepton':\n                p_prev = unit['p_i_0']\n                p_down = unit['p_down_i']\n                p_up = unit['p_up_i']\n                p_min_cur[i] = max(p_min, p_prev - p_down)\n                p_max_cur[i] = min(p_max, p_prev + p_up)\n            else:  # startable\n                p_start = unit['p_start_i']\n                p_min_cur[i] = p_min\n                p_max_cur[i] = min(p_max, p_start)\n            \n            total_min += p_min_cur[i]\n            total_max += p_max_cur[i]\n    \n    # Step 4: Dispatch target\n    dispatch_target = min(max(total_min, load), total_max)\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_idxs = [i for i in range(n_units) if commited_status[i]]\n    n_committed = len(committed_idxs)\n    \n    if n_committed == 0:\n        schedules = np.zeros((2, n_units))\n        return schedules\n    \n    # Initialize lambda bounds\n    lambda_low = 0\n    lambda_high = 0\n    for i in committed_idxs:\n        unit = units_info[i]\n        b, c = unit['b_i'], unit['c_i']\n        p_max = p_max_cur[i]\n        if c > 0:\n            marginal_cost = 2 * c * p_max + b\n        else:\n            marginal_cost = b\n        if marginal_cost > lambda_high:\n            lambda_high = marginal_cost\n    lambda_high = max(lambda_high, 100)\n    \n    # Lambda iteration\n    tol = 1e-3\n    max_iter = 1000\n    iter_count = 0\n    total_p = 0\n    \n    # Initialize outputs to minimum\n    for i in committed_idxs:\n        p_output[i] = p_min_cur[i]\n        total_p += p_output[i]\n    \n    if total_p < dispatch_target:\n        while abs(total_p - dispatch_target) > tol and iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i in committed_idxs:\n                unit = units_info[i]\n                low = p_min_cur[i]\n                high = p_max_cur[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                \n                if c > 0:  # Quadratic\n                    p_uncon = (lambda_mid - b) / (2 * c)\n                    p_clamped = np.clip(p_uncon, low, high)\n                else:  # Linear\n                    if lambda_mid < b:\n                        p_clamped = low\n                    else:\n                        p_clamped = high\n                \n                p_output[i] = p_clamped\n                total_p += p_clamped\n            \n            if total_p < dispatch_target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            iter_count += 1\n    \n    # Step 6: Residual adjustment\n    residual = dispatch_target - total_p\n    if abs(residual) > tol:\n        if residual > 0:\n            adjustable = [i for i in committed_idxs if p_output[i] < p_max_cur[i] - tol]\n            marginal_costs = []\n            for i in adjustable:\n                unit = units_info[i]\n                b, c = unit['b_i'], unit['c_i']\n                if c > 0:\n                    mc = 2 * c * p_output[i] + b\n                else:\n                    mc = b\n                marginal_costs.append(mc)\n            sorted_idxs = [i for _, i in sorted(zip(marginal_costs, adjustable))]\n            for i in sorted_idxs:\n                headroom = p_max_cur[i] - p_output[i]\n                adjust = min(headroom, residual)\n                p_output[i] += adjust\n                residual -= adjust\n                if residual <= 0:\n                    break\n        else:\n            residual_abs = -residual\n            adjustable = [i for i in committed_idxs if p_output[i] > p_min_cur[i] + tol]\n            marginal_costs = []\n            for i in adjustable:\n                unit = units_info[i]\n                b, c = unit['b_i'], unit['c_i']\n                if c > 0:\n                    mc = 2 * c * p_output[i] + b\n                else:\n                    mc = b\n                marginal_costs.append(mc)\n            sorted_idxs = [i for _, i in sorted(zip(marginal_costs, adjustable), reverse=True)]\n            for i in sorted_idxs:\n                footroom = p_output[i] - p_min_cur[i]\n                adjust = min(footroom, residual_abs)\n                p_output[i] -= adjust\n                residual_abs -= adjust\n                if residual_abs <= 0:\n                    break\n            residual = -residual_abs\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if commited_status[i]:\n            schedules[0, i] = 1\n            schedules[1, i] = p_output[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00898,
          "fitness": 0.00726
     },
     {
          "name": "hybrid_amortized_adaptive_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time violations or shutdown ramp constraints) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units with ramp-constrained power bounds.\n3. Calculate total generation capacity from committed units. If load exceeds capacity:\n   a. Identify startable units (non-forced, satisfying minimum downtime).\n   b. Compute amortized cost: (s_i/min(t_on_min_i,24) + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i. For units previously offline, include startup cost.\n   c. Commit units by ascending amortized cost until capacity meets load, using startup ramp constraints for new units.\n4. Set dispatch target as load clamped between updated min/max capacity.\n5. Perform economic dispatch via lambda iteration respecting:\n   a. Ramp constraints for existing units\n   b. Startup ramp limits for new units\n   c. Min/max output constraints\n6. Set non-committed units to offline with zero output.\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef hybrid_amortized_adaptive_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=float)\n    p = np.zeros(n_units, dtype=float)\n    lb = np.zeros(n_units, dtype=float)  # Lower bounds\n    ub = np.zeros(n_units, dtype=float)  # Upper bounds\n\n    forced_on = []\n    forced_off = []\n    free = []\n\n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:  # Previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free.append(i)\n    \n    # Initialize forced-on units\n    committed = forced_on.copy()\n    for i in forced_on:\n        unit = units_info[i]\n        u[i] = 1\n        lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min = np.sum(lb[forced_on])\n    total_max = np.sum(ub[forced_on])\n    \n    # Commit additional units if needed\n    if load > total_max and free:\n        costs = []\n        for i in free:\n            unit = units_info[i]\n            base_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n            if unit['u_i_0'] == 0:\n                amort_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n                base_cost += amort_startup / unit['p_min_i']\n            costs.append((base_cost, i))\n        \n        costs.sort(key=lambda x: x[0])\n        sorted_free = [i for _, i in costs]\n        \n        for i in sorted_free:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            u[i] = 1\n            committed.append(i)\n            if unit['u_i_0'] == 1:  # Continuation\n                new_lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                new_ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Startup\n                new_lb = unit['p_min_i']\n                new_ub = min(unit['p_max_i'], unit['p_start_i'])\n            \n            lb[i] = new_lb\n            ub[i] = new_ub\n            total_min += new_lb\n            total_max += new_ub\n    \n    # Set dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Get parameters for committed units\n        b_vec = np.array([units_info[i]['b_i'] for i in committed])\n        c_vec = np.array([units_info[i]['c_i'] for i in committed])\n        lb_comm = lb[committed]\n        ub_comm = ub[committed]\n        \n        # Lambda iteration setup\n        lambda_min = 0\n        lambda_max = 2 * max((b_vec + 2*c_vec*ub_comm).max() if any(c_vec) else max(b_vec), \n                             (b_vec.max() if not any(c_vec) else 0)) + 1000\n        tol = 0.1\n        max_iter = 1000\n        n_iter = 0\n        p_dispatch = np.zeros(len(committed))\n        \n        while n_iter < max_iter and lambda_max - lambda_min > 1e-6:\n            lam = (lambda_min + lambda_max) / 2.0\n            total_gen = 0.0\n            # Calculate power for each unit\n            for idx, i in enumerate(committed):\n                b = units_info[i]['b_i']\n                c = units_info[i]['c_i']\n                if c != 0:\n                    p_uncon = (lam - b) / (2 * c)\n                else:\n                    p_uncon = ub_comm[idx] if lam >= b else lb_comm[idx]\n                p_dispatch[idx] = np.clip(p_uncon, lb_comm[idx], ub_comm[idx])\n            total_gen = np.sum(p_dispatch)\n            \n            if abs(total_gen - target) < tol:\n                break\n            elif total_gen < target:\n                lambda_min = lam\n            else:\n                lambda_max = lam\n            n_iter += 1\n        \n        for idx, i in enumerate(committed):\n            p[i] = p_dispatch[idx]\n    \n    # Set output for non-committed units\n    non_committed = [i for i in range(n_units) if i not in committed]\n    for i in non_committed:\n        u[i] = 0\n        p[i] = 0.0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00555,
          "gap_price_rate": 0.00898,
          "fitness": 0.00727
     },
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online: units that were previously online and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or violate shutdown ramp constraints (p_i_0 > p_shut_i).\n2. Identify forced-off units that must remain offline: units that were previously offline and haven't satisfied minimum down-time (|t_i_0| < t_off_min_i).\n3. Initialize committed units as forced-on units. Calculate feasible power ranges for committed units (ramp-constrained for continuously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]).\n4. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) generation from committed units.\n5. If load exceeds total maximum generation:\n   a. Identify startable units: units not forced-on/off that can be started (satisfy minimum downtime).\n   b. Sort startable units by startup cost-adjusted average cost per MW at minimum output: (s_i + a_i + b_i*p_min_i + c_i*p_min_i**2)/p_min_i.\n   c. Commit units in ascending cost order until generation capacity meets or exceeds load. Newly committed units have output bounds: [p_min_i, min(p_max_i, p_start_i)].\n6. Calculate dispatch target: load clamped between updated total minimum and maximum generation.\n7. Perform economic dispatch using lambda iteration:\n   a. Initialize lambda and bounds. Use bisection to find optimal lambda.\n   b. For each committed unit, calculate unconstrained power: (lambda - b_i)/(2*c_i) if c_i>0. Handle linear costs (c_i=0) based on comparison between b_i and lambda.\n   c. Project power to feasible bounds: continuously online units use ramp constraints, newly committed units use startup ramp limits.\n   d. Adjust lambda until total generation matches target.\n8. Set non-committed units to offline state (u_i=0) with zero output (p_i=0).\n9. Return schedule with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    u_vector = np.zeros(num_units)\n    p_vector = np.zeros(num_units)\n    committed = set()\n    \n    # Identify forced-on and forced-off units\n    forced_on = set()\n    forced_off = set()\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.add(i)\n        else:  # Previously offline\n            if t_i0 > -t_off_min:  # Not satisfied minimum downtime\n                forced_off.add(i)\n    \n    # Initialize committed units (forced-on)\n    committed = forced_on.copy()\n    for i in committed:\n        u_vector[i] = 1\n    \n    # Calculate total min/max power from committed units\n    total_min = 0\n    total_max = 0\n    power_bounds = {}\n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        # Continuously online: apply ramp constraints\n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        power_bounds[i] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    # Handle insufficient capacity by starting units\n    if total_max < load:\n        # Identify startable units (not forced on/off, currently offline)\n        startable = []\n        for i, unit in enumerate(units_info):\n            if i not in committed and i not in forced_off and unit['u_i_0'] == 0:\n                # Check minimum downtime satisfied (t_off_min_i already considered in forced_off)\n                startable.append(i)\n        \n        # Sort by cost per MW: (s_i + cost at p_min) / p_min\n        startable.sort(key=lambda i: (\n            units_info[i]['s_i'] + \n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i']**2\n        ) / units_info[i]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for i in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            high_bound = min(p_max, p_start)\n            \n            committed.add(i)\n            u_vector[i] = 1\n            power_bounds[i] = (p_min, high_bound)\n            total_min += p_min\n            total_max += high_bound\n    \n    # Calculate dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Initial lambda bounds\n        lambda_low = -10000\n        lambda_high = 10000\n        \n        # Bisection parameters\n        max_iter = 1000\n        tol = 1e-3\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            \n            # Calculate outputs and total power\n            for i in committed:\n                unit = units_info[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                low, high = power_bounds[i]\n                \n                # Quadratic cost function\n                if c != 0:\n                    p_unconstrained = (lambda_mid - b) / (2 * c)\n                    p_i = max(low, min(high, p_unconstrained))\n                # Linear cost function (c=0)\n                else:\n                    p_i = high if b < lambda_mid else low\n                \n                total_power += p_i\n            \n            # Check convergence\n            if abs(total_power - target) < tol:\n                break\n            elif total_power < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            iter_count += 1\n        \n        # Update power outputs\n        for i in committed:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            low, high = power_bounds[i]\n            \n            if c != 0:\n                p_unconstrained = (lambda_mid - b) / (2 * c)\n                p_vector[i] = max(low, min(high, p_unconstrained))\n            else:\n                p_vector[i] = high if b < lambda_mid else low\n    else:\n        # No committed units: set all to zero (if load==0)\n        pass\n    \n    # Set non-committed units to offline and zero output\n    for i in range(num_units):\n        if i not in committed:\n            u_vector[i] = 0\n            p_vector[i] = 0\n    \n    return np.array([u_vector, p_vector])",
          "from": "mutation",
          "gap_power_rate": 0.00632,
          "gap_price_rate": 0.0084,
          "fitness": 0.00736
     },
     {
          "name": "enhanced_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units: units previously online that must remain online due to minimum up-time violations or shutdown ramp constraints.\n2. Identify forced-off units: units previously offline that must remain offline due to minimum down-time constraints.\n3. Set committed units to forced-on units with power bounds constrained by ramp limits.\n4. Calculate total min/max generation from committed units.\n5. If load exceeds total max generation:\n   a. Identify startable units not forced on/off and satisfying minimum downtime.\n   b. Sort startable units by startup cost-adjusted average cost at minimum output.\n   c. Commit units in cost order until generation capacity meets load, using startup ramp constraints for new units.\n6. Set dispatch target as load clamped between updated total min/max generation.\n7. Perform economic dispatch via lambda iteration respecting:\n   a. Ramp constraints for existing units\n   b. Startup ramp limits for new units\n   c. Min/max output constraints\n8. Set non-committed units offline with zero output.\n9. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_adaptive_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    committed = []\n    low_bound = [0.0] * n_units\n    high_bound = [0.0] * n_units\n    u = [0] * n_units\n    p = [0.0] * n_units\n\n    # Identify forced-on and forced-off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # previously online\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                forced_on.append(idx)\n        else:  # previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off.append(idx)\n    \n    # Initialize committed units as forced-on units\n    for idx in forced_on:\n        unit = units_info[idx]\n        p_i_0 = unit['p_i_0']\n        low_bound[idx] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n        high_bound[idx] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        u[idx] = 1\n        committed.append(idx)\n    \n    # Calculate total min/max from committed units\n    total_min = sum(low_bound[idx] for idx in committed)\n    total_max = sum(high_bound[idx] for idx in committed)\n    \n    # Commit additional units if needed\n    if total_max < load:\n        startable = [idx for idx, unit in enumerate(units_info) \n                    if idx not in forced_on and idx not in forced_off and unit['u_i_0'] == 0\n                    and abs(unit['t_i_0']) >= unit['t_off_min_i']]\n        \n        # Sort by cost-adjusted average cost per MW at min output\n        startable.sort(key=lambda idx: (\n            units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n            units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n            units_info[idx]['c_i'] * (units_info[idx]['p_min_i'] ** 2)\n        ) / units_info[idx]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for idx in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[idx]\n            low_bound[idx] = unit['p_min_i']\n            high_bound[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low_bound[idx]\n            total_max += high_bound[idx]\n            u[idx] = 1\n            committed.append(idx)\n    \n    # Clamp load to feasible generation range\n    dispatch_target = max(total_min, min(total_max, load))\n    \n    # Lambda iteration for economic dispatch\n    if committed:\n        lambda_low = 0\n        lambda_high = 0\n        tolerance = 0.001\n        max_iter = 100\n        \n        # Initialize lambda bounds\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                mc_min = unit['b_i'] + 2 * unit['c_i'] * low_bound[idx]\n                mc_max = unit['b_i'] + 2 * unit['c_i'] * high_bound[idx]\n            else:\n                mc_min = mc_max = unit['b_i']\n            lambda_high = max(lambda_high, mc_max)\n        \n        # Check if all units are linear with zero cost\n        all_zero_cost = all(units_info[idx]['b_i'] == 0 and units_info[idx]['c_i'] == 0 for idx in committed)\n        if all_zero_cost:\n            # Distribute load proportional to capacity\n            remaining = dispatch_target\n            for idx in committed:\n                p[idx] = low_bound[idx]\n                remaining -= p[idx]\n            for idx in committed:\n                extra = min(remaining, high_bound[idx] - low_bound[idx])\n                p[idx] += extra\n                remaining -= extra\n                if remaining <= tolerance:\n                    break\n        else:\n            # Perform bisection\n            for _ in range(max_iter):\n                if lambda_high - lambda_low < tolerance:\n                    break\n                    \n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_power = 0\n                for idx in committed:\n                    unit = units_info[idx]\n                    if unit['c_i'] > 0:\n                        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                    else:  # Linear case\n                        if lambda_mid < unit['b_i']:\n                            p_uncon = low_bound[idx]\n                        else:\n                            p_uncon = high_bound[idx]\n                    \n                    p_proj = max(low_bound[idx], min(p_uncon, high_bound[idx]))\n                    total_power += p_proj\n                \n                if total_power < dispatch_target:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n            \n            # Calculate final outputs\n            for idx in committed:\n                unit = units_info[idx]\n                if unit['c_i'] > 0:\n                    p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    if lambda_mid < unit['b_i']:\n                        p_uncon = low_bound[idx]\n                    else:\n                        p_uncon = high_bound[idx]\n                p[idx] = max(low_bound[idx], min(p_uncon, high_bound[idx]))\n    \n    # Set outputs for non-committed units\n    schedules = np.zeros((2, n_units))\n    for idx in range(n_units):\n        schedules[0, idx] = u[idx]\n        schedules[1, idx] = p[idx]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00635,
          "gap_price_rate": 0.00841,
          "fitness": 0.00738
     },
     {
          "name": "greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00917,
          "fitness": 0.00748
     }
]