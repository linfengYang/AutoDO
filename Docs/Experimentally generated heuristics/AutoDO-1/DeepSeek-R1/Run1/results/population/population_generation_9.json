[
     {
          "name": "amortized_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online and either min up-time not met (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previous state offline and min down-time not met (|t_i_0| < t_off_min_i)).\n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]. Compute total min/max generation capacity.\n3. If load exceeds total max generation capacity:\n   a) Identify startable units not forced on/off that satisfy minimum downtime\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Sort startable units by ascending amortized cost\n   d) Commit units in sorted order, updating total capacity and setting new unit bounds to [p_min_i, min(p_max_i, p_start_i)], until capacity >= load\n4. Set dispatch target = max(total_min, min(total_max, load))\n5. Perform economic dispatch via lambda iteration:\n   a) Initialize lambda bounds and use bisection to find optimal lambda\n   b) For each committed unit:\n        - Quadratic units: set p_i = (\u03bb - b_i)/(2*c_i)\n        - Linear units: set p_i = p_min_i if \u03bb < b_i, else p_max_i\n   c) Clamp power to unit's feasible bounds\n   d) Adjust lambda until generation matches target within tolerance\n   e) Apply proportional adjustment for residual load if needed\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n",
          "code": "import numpy as np\n\ndef amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    committed_mask = [False] * n_units\n    low_bounds = [0.0] * n_units\n    high_bounds = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n                committed_mask[i] = True\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2 & 3: Initialize committed units and commit more if needed\n    total_min = sum(low_bounds)\n    total_max = sum(high_bounds)\n    \n    if load > total_max:\n        startable_units = []\n        for i, unit in enumerate(units_info):\n            if not committed_mask[i] and not forced_off[i] and unit['t_off_min_i'] <= abs(unit['t_i_0']):\n                s_i = unit['s_i']\n                t_up_min = unit['t_on_min_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                amortized_cost = (s_i / min(t_up_min, 24) + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                startable_units.append((i, amortized_cost, p_min_i, unit['p_max_i'], unit['p_start_i']))\n        \n        if startable_units:\n            startable_units.sort(key=lambda x: x[1])\n            for unit_data in startable_units:\n                i, _, p_min_i, p_max_i, p_start_i = unit_data\n                new_high = min(p_max_i, p_start_i)\n                if total_max + new_high >= load:\n                    break\n                committed_mask[i] = True\n                low_bounds[i] = p_min_i\n                high_bounds[i] = new_high\n                total_min += p_min_i\n                total_max += new_high\n    \n    # Step 4: Dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if committed_mask[i]]\n    if committed_indices:\n        low_lambda = 0.0\n        high_lambda = 2000.0\n        tol = 0.01\n        max_iter = 1000\n        n_iter = 0\n        lambda_val = (low_lambda + high_lambda) / 2\n        \n        while n_iter < max_iter and abs(high_lambda - low_lambda) > 1e-5:\n            total_p = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                lb = low_bounds[i]\n                ub = high_bounds[i]\n                if unit['c_i'] > 0:\n                    p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = ub if lambda_val > unit['b_i'] else lb\n                p_val = max(lb, min(ub, p_val))\n                total_p += p_val\n            \n            if total_p < target:\n                low_lambda = lambda_val\n            else:\n                high_lambda = lambda_val\n            lambda_val = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Final assignment\n        total_p = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            lb = low_bounds[i]\n            ub = high_bounds[i]\n            if unit['c_i'] > 0:\n                p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = ub if lambda_val > unit['b_i'] else lb\n            p_val = max(lb, min(ub, p_val))\n            total_p += p_val\n            p_i[i] = p_val\n            u_i[i] = 1\n        \n        # Residual adjustment\n        residual = target - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                headrooms = [high_bounds[i] - p_i[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        add = factor * headrooms[idx]\n                        p_i[i] = min(high_bounds[i], p_i[i] + add)\n            else:\n                headrooms = [p_i[i] - low_bounds[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, -residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        p_i[i] = max(low_bounds[i], p_i[i] - factor * headrooms[idx])\n    \n    # Prepare output\n    schedules = np.vstack([np.array(u_i), np.array(p_i)])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00653,
          "gap_price_rate": 0.00537,
          "fitness": 0.00595
     },
     {
          "name": "refined_adaptive_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                forced_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                forced_off.append(i)\n                \n    committed = set(forced_on)\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        min_output[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n        max_output[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        total_min += min_output[i]\n        total_max += max_output[i]\n        \n    candidates = []\n    \n    for i in range(n):\n        if i in committed or i in forced_off:\n            continue\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            adjusted_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            candidates.append((i, adjusted_cost, 'A', min_bound, max_bound))\n        else:\n            adjusted_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, adjusted_cost, 'B', min_bound, max_bound))\n            \n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        \n    for i, cost, typ, min_b, max_b in candidates:\n        if total_max >= load:\n            break\n        committed.add(i)\n        min_output[i] = min_b\n        max_output[i] = max_b\n        total_min += min_b\n        total_max += max_b\n        \n    dispatch_target = load\n    if total_min >= total_max:\n        dispatch_target = total_min\n    else:\n        if dispatch_target < total_min:\n            dispatch_target = total_min\n        elif dispatch_target > total_max:\n            dispatch_target = total_max\n            \n    p_dispatch = [0.0] * n\n    if committed:\n        low_lambda = 0.0\n        high_lambda = 10000.0\n        tol = 0.01\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = min_output[i]\n                p_max_i = max_output[i]\n                \n                if c_i == 0:\n                    if mid_lambda <= b_i:\n                        power = p_min_i\n                    else:\n                        power = p_max_i\n                else:\n                    unconstrained = (mid_lambda - b_i) / (2 * c_i)\n                    if unconstrained < p_min_i:\n                        power = p_min_i\n                    elif unconstrained > p_max_i:\n                        power = p_max_i\n                    else:\n                        power = unconstrained\n                p_dispatch[i] = power\n                total_power += power\n                \n            if abs(total_power - dispatch_target) <= tol:\n                break\n                \n            if total_power < dispatch_target:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n                \n    u_final = [0] * n\n    p_final = [0.0] * n\n    for i in range(n):\n        if i in committed:\n            u_final[i] = 1\n            p_final[i] = p_dispatch[i]\n            \n    return np.array([u_final, p_final])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "amortized_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previously online and either minimum up-time unsatisfied (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previously offline and minimum down-time unsatisfied (abs(t_i_0) < t_off_min_i)).\n2. Initialize committed units as forced-on units. Compute feasible power ranges:\n   - Forced-on units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Calculate total minimum/maximum generation capacity\n3. If load exceeds total maximum capacity:\n   a) Identify startable units not forced on/off and meeting minimum down-time\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Commit units by ascending amortized cost order until capacity >= load\n   d) Set new unit ranges: [p_min_i, min(p_max_i, p_start_i)]\n4. Set dispatch target to load clamped between updated total min/max capacity\n5. Perform lambda iteration for economic dispatch:\n   a) Initialize lambda bounds based on marginal costs\n   b) For each unit, compute unconstrained power using unit-specific cost function\n   c) Clamp power to unit's feasible range based on operational history\n   d) Adjust lambda via bisection until generation matches target within tolerance\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef amortized_refined_adaptive_commitment(units_info, load):\n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    committed_indices = []\n    \n    # Identify forced on/off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Previously online\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                forced_on_indices.append(idx)\n            else:\n                free_indices.append(idx)\n        else:  # Previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off_indices.append(idx)\n            else:\n                free_indices.append(idx)\n    \n    # Initialize committed units to forced-on units\n    committed_indices = forced_on_indices.copy()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Set power ranges and calculate total capacity for committed units\n    for idx in committed_indices:\n        unit = units_info[idx]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        total_min += lb\n        total_max += ub\n    \n    # Commit additional units if capacity insufficient\n    if total_max < load:\n        candidate_units = []\n        for idx in free_indices:\n            unit = units_info[idx]\n            p_min_i = unit['p_min_i']\n            # Calculate amortized startup cost (spread over min up-time capped at 24h)\n            amort_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n            # Calculate adjusted cost per MW at minimum output\n            adj_cost = (amort_startup + unit['a_i'] + unit['b_i']*p_min_i + unit['c_i']*p_min_i**2) / p_min_i\n            candidate_units.append((adj_cost, idx, unit))\n        \n        # Sort by ascending adjusted cost\n        candidate_units.sort(key=lambda x: x[0])\n        \n        # Commit units until capacity meets demand\n        for _, idx, unit in candidate_units:\n            if total_max >= load:\n                break\n            committed_indices.append(idx)\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            unit['lb'] = lb\n            unit['ub'] = ub\n            total_min += lb\n            total_max += ub\n            free_indices.remove(idx)\n    \n    # Calculate dispatch target\n    target = max(total_min, min(load, total_max))\n    \n    # Lambda iteration for economic dispatch\n    tol = 0.1  # MW tolerance\n    max_iter = 1000\n    iter_count = 0\n    lambda_low = 0.0\n    lambda_high = 0.0\n    \n    # Initialize lambda bounds based on marginal costs\n    for idx in committed_indices:\n        unit = units_info[idx]\n        # Consider marginal cost at bounds\n        if unit['c_i'] != 0:\n            mc_min = 2*unit['c_i']*unit['lb'] + unit['b_i']\n            mc_max = 2*unit['c_i']*unit['ub'] + unit['b_i']\n        else:  # Linear cost\n            mc_min = mc_max = unit['b_i']\n        lambda_low = min(lambda_low, mc_min)\n        lambda_high = max(lambda_high, mc_max)\n    \n    # Expand bounds conservatively\n    lambda_low = max(0, lambda_low - 100)\n    lambda_high += 100\n    \n    # Bisection loop\n    while iter_count < max_iter:\n        total_gen = 0.0\n        lambda_mid = (lambda_low + lambda_high) / 2\n        \n        for idx in committed_indices:\n            unit = units_info[idx]\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            # Calculate unconstrained dispatch\n            if unit['c_i'] != 0:  # Quadratic cost\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                # Clamp to feasible range\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:  # Linear cost\n                # Always operate at bounds based on lambda vs marginal cost\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            total_gen += p_dispatch\n        \n        # Adjust lambda bounds\n        if abs(total_gen - target) < tol:\n            break\n        elif total_gen < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n            \n        iter_count += 1\n    \n    # Final dispatch and set outputs\n    schedules = np.zeros((2, len(units_info)))\n    for idx, unit in enumerate(units_info):\n        if idx in committed_indices:\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            if unit['c_i'] != 0:\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            schedules[0, idx] = 1\n            schedules[1, idx] = p_dispatch\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00792,
          "fitness": 0.00717
     },
     {
          "name": "hybrid_amortized_adaptive_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time violations or shutdown ramp constraints) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units with ramp-constrained power bounds.\n3. Calculate total generation capacity from committed units. If load exceeds capacity:\n   a. Identify startable units (non-forced, satisfying minimum downtime).\n   b. Compute amortized cost: (s_i/min(t_on_min_i,24) + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i. For units previously offline, include startup cost.\n   c. Commit units by ascending amortized cost until capacity meets load, using startup ramp constraints for new units.\n4. Set dispatch target as load clamped between updated min/max capacity.\n5. Perform economic dispatch via lambda iteration respecting:\n   a. Ramp constraints for existing units\n   b. Startup ramp limits for new units\n   c. Min/max output constraints\n6. Set non-committed units to offline with zero output.\n7. Return commitment states and power outputs.\n",
          "code": "import numpy as np\n\ndef hybrid_amortized_adaptive_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=float)\n    p = np.zeros(n_units, dtype=float)\n    lb = np.zeros(n_units, dtype=float)  # Lower bounds\n    ub = np.zeros(n_units, dtype=float)  # Upper bounds\n\n    forced_on = []\n    forced_off = []\n    free = []\n\n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:  # Previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free.append(i)\n    \n    # Initialize forced-on units\n    committed = forced_on.copy()\n    for i in forced_on:\n        unit = units_info[i]\n        u[i] = 1\n        lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min = np.sum(lb[forced_on])\n    total_max = np.sum(ub[forced_on])\n    \n    # Commit additional units if needed\n    if load > total_max and free:\n        costs = []\n        for i in free:\n            unit = units_info[i]\n            base_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n            if unit['u_i_0'] == 0:\n                amort_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n                base_cost += amort_startup / unit['p_min_i']\n            costs.append((base_cost, i))\n        \n        costs.sort(key=lambda x: x[0])\n        sorted_free = [i for _, i in costs]\n        \n        for i in sorted_free:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            u[i] = 1\n            committed.append(i)\n            if unit['u_i_0'] == 1:  # Continuation\n                new_lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                new_ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Startup\n                new_lb = unit['p_min_i']\n                new_ub = min(unit['p_max_i'], unit['p_start_i'])\n            \n            lb[i] = new_lb\n            ub[i] = new_ub\n            total_min += new_lb\n            total_max += new_ub\n    \n    # Set dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Get parameters for committed units\n        b_vec = np.array([units_info[i]['b_i'] for i in committed])\n        c_vec = np.array([units_info[i]['c_i'] for i in committed])\n        lb_comm = lb[committed]\n        ub_comm = ub[committed]\n        \n        # Lambda iteration setup\n        lambda_min = 0\n        lambda_max = 2 * max((b_vec + 2*c_vec*ub_comm).max() if any(c_vec) else max(b_vec), \n                             (b_vec.max() if not any(c_vec) else 0)) + 1000\n        tol = 0.1\n        max_iter = 1000\n        n_iter = 0\n        p_dispatch = np.zeros(len(committed))\n        \n        while n_iter < max_iter and lambda_max - lambda_min > 1e-6:\n            lam = (lambda_min + lambda_max) / 2.0\n            total_gen = 0.0\n            # Calculate power for each unit\n            for idx, i in enumerate(committed):\n                b = units_info[i]['b_i']\n                c = units_info[i]['c_i']\n                if c != 0:\n                    p_uncon = (lam - b) / (2 * c)\n                else:\n                    p_uncon = ub_comm[idx] if lam >= b else lb_comm[idx]\n                p_dispatch[idx] = np.clip(p_uncon, lb_comm[idx], ub_comm[idx])\n            total_gen = np.sum(p_dispatch)\n            \n            if abs(total_gen - target) < tol:\n                break\n            elif total_gen < target:\n                lambda_min = lam\n            else:\n                lambda_max = lam\n            n_iter += 1\n        \n        for idx, i in enumerate(committed):\n            p[i] = p_dispatch[idx]\n    \n    # Set output for non-committed units\n    non_committed = [i for i in range(n_units) if i not in committed]\n    for i in non_committed:\n        u[i] = 0\n        p[i] = 0.0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00555,
          "gap_price_rate": 0.00898,
          "fitness": 0.00727
     },
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online: units that were previously online and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or violate shutdown ramp constraints (p_i_0 > p_shut_i).\n2. Identify forced-off units that must remain offline: units that were previously offline and haven't satisfied minimum down-time (|t_i_0| < t_off_min_i).\n3. Initialize committed units as forced-on units. Calculate feasible power ranges for committed units (ramp-constrained for continuously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]).\n4. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) generation from committed units.\n5. If load exceeds total maximum generation:\n   a. Identify startable units: units not forced-on/off that can be started (satisfy minimum downtime).\n   b. Sort startable units by startup cost-adjusted average cost per MW at minimum output: (s_i + a_i + b_i*p_min_i + c_i*p_min_i**2)/p_min_i.\n   c. Commit units in ascending cost order until generation capacity meets or exceeds load. Newly committed units have output bounds: [p_min_i, min(p_max_i, p_start_i)].\n6. Calculate dispatch target: load clamped between updated total minimum and maximum generation.\n7. Perform economic dispatch using lambda iteration:\n   a. Initialize lambda and bounds. Use bisection to find optimal lambda.\n   b. For each committed unit, calculate unconstrained power: (lambda - b_i)/(2*c_i) if c_i>0. Handle linear costs (c_i=0) based on comparison between b_i and lambda.\n   c. Project power to feasible bounds: continuously online units use ramp constraints, newly committed units use startup ramp limits.\n   d. Adjust lambda until total generation matches target.\n8. Set non-committed units to offline state (u_i=0) with zero output (p_i=0).\n9. Return schedule with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    u_vector = np.zeros(num_units)\n    p_vector = np.zeros(num_units)\n    committed = set()\n    \n    # Identify forced-on and forced-off units\n    forced_on = set()\n    forced_off = set()\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.add(i)\n        else:  # Previously offline\n            if t_i0 > -t_off_min:  # Not satisfied minimum downtime\n                forced_off.add(i)\n    \n    # Initialize committed units (forced-on)\n    committed = forced_on.copy()\n    for i in committed:\n        u_vector[i] = 1\n    \n    # Calculate total min/max power from committed units\n    total_min = 0\n    total_max = 0\n    power_bounds = {}\n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        # Continuously online: apply ramp constraints\n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        power_bounds[i] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    # Handle insufficient capacity by starting units\n    if total_max < load:\n        # Identify startable units (not forced on/off, currently offline)\n        startable = []\n        for i, unit in enumerate(units_info):\n            if i not in committed and i not in forced_off and unit['u_i_0'] == 0:\n                # Check minimum downtime satisfied (t_off_min_i already considered in forced_off)\n                startable.append(i)\n        \n        # Sort by cost per MW: (s_i + cost at p_min) / p_min\n        startable.sort(key=lambda i: (\n            units_info[i]['s_i'] + \n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i']**2\n        ) / units_info[i]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for i in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            high_bound = min(p_max, p_start)\n            \n            committed.add(i)\n            u_vector[i] = 1\n            power_bounds[i] = (p_min, high_bound)\n            total_min += p_min\n            total_max += high_bound\n    \n    # Calculate dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Initial lambda bounds\n        lambda_low = -10000\n        lambda_high = 10000\n        \n        # Bisection parameters\n        max_iter = 1000\n        tol = 1e-3\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            \n            # Calculate outputs and total power\n            for i in committed:\n                unit = units_info[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                low, high = power_bounds[i]\n                \n                # Quadratic cost function\n                if c != 0:\n                    p_unconstrained = (lambda_mid - b) / (2 * c)\n                    p_i = max(low, min(high, p_unconstrained))\n                # Linear cost function (c=0)\n                else:\n                    p_i = high if b < lambda_mid else low\n                \n                total_power += p_i\n            \n            # Check convergence\n            if abs(total_power - target) < tol:\n                break\n            elif total_power < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            iter_count += 1\n        \n        # Update power outputs\n        for i in committed:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            low, high = power_bounds[i]\n            \n            if c != 0:\n                p_unconstrained = (lambda_mid - b) / (2 * c)\n                p_vector[i] = max(low, min(high, p_unconstrained))\n            else:\n                p_vector[i] = high if b < lambda_mid else low\n    else:\n        # No committed units: set all to zero (if load==0)\n        pass\n    \n    # Set non-committed units to offline and zero output\n    for i in range(num_units):\n        if i not in committed:\n            u_vector[i] = 0\n            p_vector[i] = 0\n    \n    return np.array([u_vector, p_vector])",
          "from": "mutation",
          "gap_power_rate": 0.00632,
          "gap_price_rate": 0.0084,
          "fitness": 0.00736
     },
     {
          "name": "enhanced_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units: units previously online that must remain online due to minimum up-time violations or shutdown ramp constraints.\n2. Identify forced-off units: units previously offline that must remain offline due to minimum down-time constraints.\n3. Set committed units to forced-on units with power bounds constrained by ramp limits.\n4. Calculate total min/max generation from committed units.\n5. If load exceeds total max generation:\n   a. Identify startable units not forced on/off and satisfying minimum downtime.\n   b. Sort startable units by startup cost-adjusted average cost at minimum output.\n   c. Commit units in cost order until generation capacity meets load, using startup ramp constraints for new units.\n6. Set dispatch target as load clamped between updated total min/max generation.\n7. Perform economic dispatch via lambda iteration respecting:\n   a. Ramp constraints for existing units\n   b. Startup ramp limits for new units\n   c. Min/max output constraints\n8. Set non-committed units offline with zero output.\n9. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_adaptive_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    committed = []\n    low_bound = [0.0] * n_units\n    high_bound = [0.0] * n_units\n    u = [0] * n_units\n    p = [0.0] * n_units\n\n    # Identify forced-on and forced-off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # previously online\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                forced_on.append(idx)\n        else:  # previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off.append(idx)\n    \n    # Initialize committed units as forced-on units\n    for idx in forced_on:\n        unit = units_info[idx]\n        p_i_0 = unit['p_i_0']\n        low_bound[idx] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n        high_bound[idx] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        u[idx] = 1\n        committed.append(idx)\n    \n    # Calculate total min/max from committed units\n    total_min = sum(low_bound[idx] for idx in committed)\n    total_max = sum(high_bound[idx] for idx in committed)\n    \n    # Commit additional units if needed\n    if total_max < load:\n        startable = [idx for idx, unit in enumerate(units_info) \n                    if idx not in forced_on and idx not in forced_off and unit['u_i_0'] == 0\n                    and abs(unit['t_i_0']) >= unit['t_off_min_i']]\n        \n        # Sort by cost-adjusted average cost per MW at min output\n        startable.sort(key=lambda idx: (\n            units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n            units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n            units_info[idx]['c_i'] * (units_info[idx]['p_min_i'] ** 2)\n        ) / units_info[idx]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for idx in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[idx]\n            low_bound[idx] = unit['p_min_i']\n            high_bound[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low_bound[idx]\n            total_max += high_bound[idx]\n            u[idx] = 1\n            committed.append(idx)\n    \n    # Clamp load to feasible generation range\n    dispatch_target = max(total_min, min(total_max, load))\n    \n    # Lambda iteration for economic dispatch\n    if committed:\n        lambda_low = 0\n        lambda_high = 0\n        tolerance = 0.001\n        max_iter = 100\n        \n        # Initialize lambda bounds\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                mc_min = unit['b_i'] + 2 * unit['c_i'] * low_bound[idx]\n                mc_max = unit['b_i'] + 2 * unit['c_i'] * high_bound[idx]\n            else:\n                mc_min = mc_max = unit['b_i']\n            lambda_high = max(lambda_high, mc_max)\n        \n        # Check if all units are linear with zero cost\n        all_zero_cost = all(units_info[idx]['b_i'] == 0 and units_info[idx]['c_i'] == 0 for idx in committed)\n        if all_zero_cost:\n            # Distribute load proportional to capacity\n            remaining = dispatch_target\n            for idx in committed:\n                p[idx] = low_bound[idx]\n                remaining -= p[idx]\n            for idx in committed:\n                extra = min(remaining, high_bound[idx] - low_bound[idx])\n                p[idx] += extra\n                remaining -= extra\n                if remaining <= tolerance:\n                    break\n        else:\n            # Perform bisection\n            for _ in range(max_iter):\n                if lambda_high - lambda_low < tolerance:\n                    break\n                    \n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_power = 0\n                for idx in committed:\n                    unit = units_info[idx]\n                    if unit['c_i'] > 0:\n                        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                    else:  # Linear case\n                        if lambda_mid < unit['b_i']:\n                            p_uncon = low_bound[idx]\n                        else:\n                            p_uncon = high_bound[idx]\n                    \n                    p_proj = max(low_bound[idx], min(p_uncon, high_bound[idx]))\n                    total_power += p_proj\n                \n                if total_power < dispatch_target:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n            \n            # Calculate final outputs\n            for idx in committed:\n                unit = units_info[idx]\n                if unit['c_i'] > 0:\n                    p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    if lambda_mid < unit['b_i']:\n                        p_uncon = low_bound[idx]\n                    else:\n                        p_uncon = high_bound[idx]\n                p[idx] = max(low_bound[idx], min(p_uncon, high_bound[idx]))\n    \n    # Set outputs for non-committed units\n    schedules = np.zeros((2, n_units))\n    for idx in range(n_units):\n        schedules[0, idx] = u[idx]\n        schedules[1, idx] = p[idx]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00635,
          "gap_price_rate": 0.00841,
          "fitness": 0.00738
     },
     {
          "name": "greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00917,
          "fitness": 0.00748
     },
     {
          "name": "refined_adaptive_commitment_v1",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online + (min up-time not met or shutdown ramp violation)) and forced-off units that must remain offline (previous state offline + min down-time not met). Initialize committed units as forced-on units.  \n2. Compute feasible power ranges for committed units based on ramp limits: previously online units use [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]; newly committed units use [p_min, min(p_max, p_start)].  \n3. Calculate total min/max generation from committed units. If load exceeds total max:  \n   a) Sort eligible offline units by startup-adjusted cost: (s_i + a_i + b_i\u00b7p_min + c_i\u00b7p_min\u00b2)/p_min  \n   b) Commit lowest-cost units until generation >= load, updating feasible ranges and total capacity  \n4. Set dispatch target = clamp(load, total_min, total_max)  \n5. Perform economic dispatch via lambda iteration with bounds:  \n   a) Compute power for quadratic cost units: p = (\u03bb - b_i)/(2\u00b7c_i) clamped to feasible range  \n   b) For linear cost units: p = p_min if \u03bb < b_i, else p_max  \n   c) Adjust \u03bb via bisection until generation \u2248 target  \n6. Set non-committed units to offline (u=0, p=0)  \n7. Output unit states and power levels  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_commitment_v1(units_info, load):  \n    n_units = len(units_info)  \n    u = np.zeros(n_units, dtype=int)  \n    p = np.zeros(n_units)  \n    low_bounds = np.zeros(n_units)  \n    high_bounds = np.zeros(n_units)  \n    committed = []  \n    \n    # 1. Identify forced-on/forced-off units  \n    forced_on = []  \n    forced_off = []  \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        if u_i0:  \n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:  \n                forced_on.append(i)  \n        else:  \n            if abs(t_i0) < unit['t_off_min_i']:  \n                forced_off.append(i)  \n    \n    # Commit forced-on units  \n    for i in forced_on:  \n        u[i] = 1  \n        committed.append(i)  \n        low_bounds[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])  \n        high_bounds[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])  \n    \n    # Force-off units  \n    for i in forced_off:  \n        u[i] = 0  \n        p[i] = 0  \n    \n    # 2. Initial capacity bounds  \n    total_min = sum(low_bounds[i] for i in committed)  \n    total_max = sum(high_bounds[i] for i in committed)  \n    \n    # 3. Commit additional units if needed  \n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]  \n    if total_max < load:  \n        cost_list = []  \n        for i in free_units:  \n            unit = units_info[i]  \n            min_p = unit['p_min_i']  \n            cost_val = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2) / min_p  \n            cost_list.append((cost_val, i))  \n        \n        cost_list.sort(key=lambda x: x[0])  \n        for _, i in cost_list:  \n            if total_max >= load:  \n                break  \n            u[i] = 1  \n            committed.append(i)  \n            start_bound = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])  \n            low_bounds[i] = units_info[i]['p_min_i']  \n            high_bounds[i] = start_bound  \n            total_min += low_bounds[i]  \n            total_max += high_bounds[i]  \n    \n    # 4. Dispatch target  \n    dispatch_target = max(total_min, min(total_max, load))  \n    \n    # 5. Economic dispatch  \n    if committed:  \n        # Bisection setup  \n        low_lambda, high_lambda = 0, 10**6  \n        tol, max_iter = 1e-3, 1000  \n        iter_count = 0  \n        p_committed = np.zeros(len(committed))  \n        unit_indices = np.array(committed)  \n        cost_factors = [(units_info[i]['b_i'], units_info[i]['c_i'], i) for i in committed]  \n        \n        # Lambda iteration  \n        while abs(high_lambda - low_lambda) > tol and iter_count < max_iter:  \n            mid_lambda = (low_lambda + high_lambda) / 2  \n            total_power = 0  \n            for b, c, idx in cost_factors:  \n                i = np.where(unit_indices == idx)[0][0]  \n                if c > 0:  # Quadratic cost  \n                    unconstrained = (mid_lambda - b) / (2 * c)  \n                    p_committed[i] = np.clip(unconstrained, low_bounds[idx], high_bounds[idx])  \n                else:  # Linear cost  \n                    p_committed[i] = high_bounds[idx] if mid_lambda > b else low_bounds[idx]  \n                total_power += p_committed[i]  \n            \n            if total_power < dispatch_target:  \n                low_lambda = mid_lambda  \n            else:  \n                high_lambda = mid_lambda  \n            iter_count += 1  \n        \n        # Assign computed power  \n        for b, c, idx in cost_factors:  \n            i = np.where(unit_indices == idx)[0][0]  \n            p[idx] = p_committed[i]  \n    \n    # 6. Set non-committed units  \n    for i in range(n_units):  \n        if u[i] == 0:  \n            p[i] = 0  \n    \n    return np.vstack((u, p))  ",
          "from": "mutation",
          "gap_power_rate": 0.00586,
          "gap_price_rate": 0.00917,
          "fitness": 0.00751
     },
     {
          "name": "amortized_enhanced_refined_commitment",
          "algorithm": "1. Identify forced-on units: previously online units violating minimum up-time or shutdown ramp constraints.\n2. Identify forced-off units: previously offline units violating minimum down-time constraints.\n3. Initialize committed units as forced-on units with ramp-constrained power bounds.\n4. If existing capacity is insufficient:\n   a. Identify startable units (neither forced-on/off and satisfying minimum downtime)\n   b. Compute amortized cost: (s_i/min(t_on_min_i,24) + a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i\n   c. Commit units in ascending amortized cost order\n   d. Set new unit bounds: [p_min_i, min(p_max_i, p_start_i)]\n5. Set dispatch target = clamp(load, total_min_capacity, total_max_capacity)\n6. Perform lambda iteration respecting:\n   a. Ramp constraints for existing units\n   b. Startup ramp limits for new units\n   c. Individual unit min/max limits\n7. Set non-committed units to offline with zero output\n",
          "code": "import numpy as np\n\ndef amortized_enhanced_refined_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    committed = np.zeros(n_units, dtype=bool)\n    \n    forced_on = []\n    forced_off = []\n    # Identify forced-on/off units and set initial bounds\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on.append(i)\n                committed[i] = True\n                u[i] = 1\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = unit['p_max_i']\n        else:  # Previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n                committed[i] = False\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                min_p[i] = unit['p_min_i']\n                max_p[i] = unit['p_max_i']\n\n    # Calculate total capacity\n    total_min = sum(min_p[i] for i in range(n_units) if committed[i])\n    total_max = sum(max_p[i] for i in range(n_units) if committed[i])\n    \n    # Handle insufficient capacity\n    if total_max < load:\n        candidate_units = []\n        for i, unit in enumerate(units_info):\n            if not committed[i] and i not in forced_off and unit['u_i_0'] == 0:\n                amortized_cost = (unit['s_i'] / min(unit['t_on_min_i'], 24) + \n                                  unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                                  unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n                candidate_units.append((amortized_cost, i))\n        \n        candidate_units.sort(key=lambda x: x[0])\n        \n        for cost, i in candidate_units:\n            if total_max >= load:\n                break\n                \n            committed[i] = True\n            u[i] = 1\n            min_p[i] = units_info[i]['p_min_i']\n            max_p[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_p[i]\n            total_max += max_p[i]\n\n    # Set dispatch target\n    dispatch_target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if committed[i]]\n    if committed_indices:\n        min_lambda = 0\n        max_lambda = 10000  # Sufficiently large upper bound\n        \n        for _ in range(1000):  # Bisection iterations\n            total_gen = 0\n            lambda_val = (min_lambda + max_lambda) / 2\n            \n            # Calculate power outputs\n            for i in committed_indices:\n                unit = units_info[i]\n                if unit['c_i'] > 0:  # Quadratic cost function\n                    unconstrained = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Handle linear case\n                    unconstrained = unit['p_max_i'] if lambda_val > unit['b_i'] else unit['p_min_i']\n                \n                constrained = max(min_p[i], min(max_p[i], unconstrained))\n                p[i] = constrained\n                total_gen += constrained\n            \n            # Update lambda bounds\n            if abs(total_gen - dispatch_target) < 1e-3:\n                break\n            elif total_gen < dispatch_target:\n                min_lambda = lambda_val\n            else:\n                max_lambda = lambda_val\n    \n    # Set non-committed units\n    for i in range(n_units):\n        if not committed[i]:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.vstack([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.00717,
          "gap_price_rate": 0.00839,
          "fitness": 0.00778
     }
]