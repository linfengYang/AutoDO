[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online: units that were previously online and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or violate shutdown ramp constraints (p_i_0 > p_shut_i).\n2. Identify forced-off units that must remain offline: units that were previously offline and haven't satisfied minimum down-time (|t_i_0| < t_off_min_i).\n3. Initialize committed units as forced-on units. Calculate feasible power ranges for committed units (ramp-constrained for continuously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]).\n4. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) generation from committed units.\n5. If load exceeds total maximum generation:\n   a. Identify startable units: units not forced-on/off that can be started (satisfy minimum downtime).\n   b. Sort startable units by startup cost-adjusted average cost per MW at minimum output: (s_i + a_i + b_i*p_min_i + c_i*p_min_i**2)/p_min_i.\n   c. Commit units in ascending cost order until generation capacity meets or exceeds load. Newly committed units have output bounds: [p_min_i, min(p_max_i, p_start_i)].\n6. Calculate dispatch target: load clamped between updated total minimum and maximum generation.\n7. Perform economic dispatch using lambda iteration:\n   a. Initialize lambda and bounds. Use bisection to find optimal lambda.\n   b. For each committed unit, calculate unconstrained power: (lambda - b_i)/(2*c_i) if c_i>0. Handle linear costs (c_i=0) based on comparison between b_i and lambda.\n   c. Project power to feasible bounds: continuously online units use ramp constraints, newly committed units use startup ramp limits.\n   d. Adjust lambda until total generation matches target.\n8. Set non-committed units to offline state (u_i=0) with zero output (p_i=0).\n9. Return schedule with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    u_vector = np.zeros(num_units)\n    p_vector = np.zeros(num_units)\n    committed = set()\n    \n    # Identify forced-on and forced-off units\n    forced_on = set()\n    forced_off = set()\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.add(i)\n        else:  # Previously offline\n            if t_i0 > -t_off_min:  # Not satisfied minimum downtime\n                forced_off.add(i)\n    \n    # Initialize committed units (forced-on)\n    committed = forced_on.copy()\n    for i in committed:\n        u_vector[i] = 1\n    \n    # Calculate total min/max power from committed units\n    total_min = 0\n    total_max = 0\n    power_bounds = {}\n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        # Continuously online: apply ramp constraints\n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        power_bounds[i] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    # Handle insufficient capacity by starting units\n    if total_max < load:\n        # Identify startable units (not forced on/off, currently offline)\n        startable = []\n        for i, unit in enumerate(units_info):\n            if i not in committed and i not in forced_off and unit['u_i_0'] == 0:\n                # Check minimum downtime satisfied (t_off_min_i already considered in forced_off)\n                startable.append(i)\n        \n        # Sort by cost per MW: (s_i + cost at p_min) / p_min\n        startable.sort(key=lambda i: (\n            units_info[i]['s_i'] + \n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i']**2\n        ) / units_info[i]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for i in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            high_bound = min(p_max, p_start)\n            \n            committed.add(i)\n            u_vector[i] = 1\n            power_bounds[i] = (p_min, high_bound)\n            total_min += p_min\n            total_max += high_bound\n    \n    # Calculate dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Initial lambda bounds\n        lambda_low = -10000\n        lambda_high = 10000\n        \n        # Bisection parameters\n        max_iter = 1000\n        tol = 1e-3\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            \n            # Calculate outputs and total power\n            for i in committed:\n                unit = units_info[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                low, high = power_bounds[i]\n                \n                # Quadratic cost function\n                if c != 0:\n                    p_unconstrained = (lambda_mid - b) / (2 * c)\n                    p_i = max(low, min(high, p_unconstrained))\n                # Linear cost function (c=0)\n                else:\n                    p_i = high if b < lambda_mid else low\n                \n                total_power += p_i\n            \n            # Check convergence\n            if abs(total_power - target) < tol:\n                break\n            elif total_power < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            iter_count += 1\n        \n        # Update power outputs\n        for i in committed:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            low, high = power_bounds[i]\n            \n            if c != 0:\n                p_unconstrained = (lambda_mid - b) / (2 * c)\n                p_vector[i] = max(low, min(high, p_unconstrained))\n            else:\n                p_vector[i] = high if b < lambda_mid else low\n    else:\n        # No committed units: set all to zero (if load==0)\n        pass\n    \n    # Set non-committed units to offline and zero output\n    for i in range(num_units):\n        if i not in committed:\n            u_vector[i] = 0\n            p_vector[i] = 0\n    \n    return np.array([u_vector, p_vector])",
          "from": "mutation",
          "gap_power_rate": 0.00632,
          "gap_price_rate": 0.0084,
          "fitness": 0.00736
     },
     {
          "name": "greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00917,
          "fitness": 0.00748
     },
     {
          "name": "enhanced_greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time constraints or shutdown capacity limitations) and forced-off units (must remain offline due to minimum down-time constraints)  \n2. Set forced-on units to online, compute feasible power ranges respecting ramp limits; set forced-off units to offline  \n3. Calculate total minimum/maximum output from forced-on units  \n4. While total maximum output < load and free units exist, turn on free units sorted by adjusted average cost (including startup cost) at minimum output  \n5. For newly started units, set feasible output range with startup ramp limitations  \n6. Set dispatch target as load clamped between total feasible minimum and maximum outputs  \n7. For committed units, perform economic dispatch via lambda iteration with unit-specific constraints:  \n   - Continuously online units constrained by regular ramp limits  \n   - Newly started units constrained by startup ramp limits  \n8. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_greedy_rolling_commitment(units_info, load):  \n    n_units = len(units_info)  \n    u_schedule = [0] * n_units  \n    p_schedule = [0.0] * n_units  \n    min_feasible = [0.0] * n_units  \n    max_feasible = [0.0] * n_units  \n    committed = [False] * n_units  \n    forced_on_indices = []  \n    forced_off_indices = []  \n    free_indices = []  \n\n    # Classify units based on physical constraints  \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        if u_i0 == 1:  \n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:  \n                forced_on_indices.append(i)  \n            else:  \n                free_indices.append(i)  \n        else:  \n            if abs(t_i0) < unit['t_off_min_i']:  \n                forced_off_indices.append(i)  \n            else:  \n                free_indices.append(i)  \n\n    # Process forced-off units  \n    for i in forced_off_indices:  \n        committed[i] = False  \n        u_schedule[i] = 0  \n        p_schedule[i] = 0.0  \n        min_feasible[i] = 0.0  \n        max_feasible[i] = 0.0  \n\n    # Process forced-on units  \n    for i in forced_on_indices:  \n        unit = units_info[i]  \n        min_feas = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        max_feas = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        min_feasible[i] = min_feas  \n        max_feasible[i] = max_feas  \n        committed[i] = True  \n        u_schedule[i] = 1  \n\n    # Initial total power calculations  \n    total_min = sum(min_feasible[i] for i in forced_on_indices)  \n    total_max = sum(max_feasible[i] for i in forced_on_indices)  \n\n    # Cost-based unit activation  \n    def calc_criterion(unit):  \n        return (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] +  \n                unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']  \n    free_indices_sorted = sorted(free_indices, key=lambda i: calc_criterion(units_info[i]))  \n\n    new_committed = []  \n    for i in free_indices_sorted:  \n        if total_max < load:  \n            unit = units_info[i]  \n            min_feasible[i] = unit['p_min_i']  \n            max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])  \n            u_schedule[i] = 1  \n            committed[i] = True  \n            new_committed.append(i)  \n            total_min += min_feasible[i]  \n            total_max += max_feasible[i]  \n\n    # Calculate dispatch target  \n    target = min(max(total_min, load), total_max)  \n    committed_indices = forced_on_indices + new_committed  \n\n    # Lambda iteration for economic dispatch  \n    if committed_indices:  \n        b_vec = [units_info[i]['b_i'] for i in committed_indices]  \n        c_vec = [units_info[i]['c_i'] for i in committed_indices]  \n        min_vec = [min_feasible[i] for i in committed_indices]  \n        max_vec = [max_feasible[i] for i in committed_indices]  \n        lo = 0  \n        hi = 1e6  \n        tol = 1e-6  \n        iter_count = 0  \n        max_iter = 100  \n        while abs(hi - lo) > tol and iter_count < max_iter:  \n            mid = (lo + hi) / 2  \n            total_p = 0.0  \n            for idx, (b, c, p_min, p_max) in enumerate(zip(b_vec, c_vec, min_vec, max_vec)):  \n                if c == 0:  \n                    p_val = p_max if mid >= b else p_min  \n                else:  \n                    p_uncon = (mid - b) / (2 * c)  \n                    p_val = max(p_min, min(p_max, p_uncon))  \n                total_p += p_val  \n            if total_p < target:  \n                lo = mid  \n            else:  \n                hi = mid  \n            iter_count += 1  \n        lambda_opt = (lo + hi) / 2  \n        for idx, i in enumerate(committed_indices):  \n            b = b_vec[idx]  \n            c = c_vec[idx]  \n            p_min = min_vec[idx]  \n            p_max = max_vec[idx]  \n            if c == 0:  \n                p_val = p_max if lambda_opt >= b else p_min  \n            else:  \n                p_val = (lambda_opt - b) / (2 * c)  \n                p_val = max(p_min, min(p_max, p_val))  \n            p_schedule[i] = p_val  \n    return np.array([u_schedule, p_schedule])  ",
          "from": "crossover",
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00936,
          "fitness": 0.00758
     },
     {
          "name": "adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time constraints or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate total min/max output from committed units accounting for ramp constraints.\n3. If load exceeds maximum available output:\n   - Sort eligible offline units by amortized average cost (startup cost amortized over minimum up-time plus average production cost at minimum output)\n   - Commit units in ascending cost order until sufficient capacity is available\n4. Calculate dispatch target as load clamped between total min and max feasible output.\n5. Perform economic dispatch using lambda iteration to minimize production costs while respecting:\n   - Ramp limits for continuously online units\n   - Startup ramp limits for newly committed units\n   - Minimum/maximum output constraints\n6. Set non-committed units to offline state with zero output.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef adaptive_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    committed = []\n    forced_on = []\n    forced_off = []\n    \n    # Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    committed = forced_on.copy()\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    # Calculate feasible ranges for forced-on units\n    total_min, total_max = 0.0, 0.0\n    for i in committed:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_outputs[i] = min_output\n        max_outputs[i] = max_output\n        total_min += min_output\n        total_max += max_output\n    \n    # Add offline units if needed\n    candidate_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    if total_max < load:\n        amortized_costs = []\n        for i in candidate_units:\n            unit = units_info[i]\n            amort_period = max(1, unit['t_on_min_i'])\n            avg_cost = (unit['s_i'] / amort_period + unit['b_i'] * unit['p_min_i'] + \n                        unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            amortized_costs.append((avg_cost, i))\n        \n        amortized_costs.sort(key=lambda x: x[0])\n        \n        for _, i in amortized_costs:\n            if total_max >= load:\n                break\n            unit = units_info[i]\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            min_outputs[i] = min_out\n            max_outputs[i] = max_out\n            total_min += min_out\n            total_max += max_out\n            committed.append(i)\n    \n    # Calculate dispatch target\n    target = np.clip(load, total_min, total_max)\n    \n    # Lambda iteration for economic dispatch\n    p_alloc = np.zeros(n_units)\n    low_lambda = -1000.0\n    high_lambda = 10000.0\n    tol = 1e-5\n    max_iter = 1000\n    \n    for iter_count in range(max_iter):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0.0\n        \n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                p_alloc[i] = min_outputs[i] if mid_lambda < unit['b_i'] else max_outputs[i]\n            else:\n                p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n            total_power += p_alloc[i]\n        \n        if abs(total_power - target) < tol:\n            break\n        \n        if total_power < target:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = p_alloc[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00644,
          "gap_price_rate": 0.00921,
          "fitness": 0.00782
     },
     {
          "name": "enhanced_adaptive_dispatch",
          "algorithm": "1. Identify must-run units (units that must remain online due to minimum up-time constraints or shutdown ramp violations) and must-off units (units that must remain offline due to minimum down-time constraints).\n2. Initialize online_set as must-run units. Compute current total minimum and maximum outputs for online_set considering ramp constraints.\n3. If total maximum output is insufficient to meet load, add candidate units (sorted by adjusted average cost per MW at minimum output) to online_set until capacity is sufficient.\n4. Calculate target load (clamped between feasible generation limits).\n5. Initialize unit outputs to their minimum values then perform greedy economic dispatch to distribute residual load among online units:\n   - While residual load remains, allocate to unit with lowest marginal cost until capacity limits are reached.\n6. For units not in online_set, set commitment state to 0 and output to 0.\n7. Return schedule array with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_dispatch(units_info, load):\n    # Step 1: Identify must-run and must-off units\n    n_units = len(units_info)\n    must_run_idx = []\n    must_off_idx = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_run_idx.append(idx)\n        else:  # u_i_0 == 0\n            if t_i_0 < 0 and -t_i_0 < unit['t_off_min_i']:\n                must_off_idx.append(idx)\n    \n    # Step 2: Initialize online_set with must-run units and compute power ranges\n    online_set = set(must_run_idx)\n    min_p_arr = np.zeros(n_units)\n    max_p_arr = np.zeros(n_units)\n    outputs = np.zeros(n_units)\n    \n    for idx in online_set:\n        unit = units_info[idx]\n        min_p_arr[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p_arr[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        outputs[idx] = min_p_arr[idx]\n    \n    total_min = sum(min_p_arr[list(online_set)])\n    total_max = sum(max_p_arr[list(online_set)])\n    \n    # Step 3: Add candidate units if insufficient capacity\n    candidate_set = [i for i in range(n_units) \n                   if i not in online_set and i not in must_off_idx]\n    candidate_set.sort(key=lambda i: (\n        (units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n         units_info[i]['c_i'] * units_info[i]['p_min_i']**2 + \n         (units_info[i]['s_i'] if units_info[i]['u_i_0'] == 0 else 0)) \n        / units_info[i]['p_min_i']\n    ))\n    \n    for i in candidate_set:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        \n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        min_p_arr[i] = min_p\n        max_p_arr[i] = max_p\n        outputs[i] = min_p\n        online_set.add(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Step 4: Compute target load within feasible limits\n    target_load = max(total_min, min(total_max, load))\n    \n    # Step 5: Perform economic dispatch using greedy method\n    residual = target_load - total_min\n    if residual > 0:\n        active_units = [i for i in online_set if outputs[i] < max_p_arr[i]]\n        \n        while residual > 0 and active_units:\n            # Find unit with lowest marginal cost\n            min_cost = float('inf')\n            best_idx = None\n            \n            for i in active_units:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                if mc < min_cost:\n                    min_cost = mc\n                    best_idx = i\n            \n            # Calculate maximum possible increase\n            available = max_p_arr[best_idx] - outputs[best_idx]\n            increase = min(available, residual)\n            \n            # Update output and residual\n            outputs[best_idx] += increase\n            residual -= increase\n            \n            # Remove unit if it reaches max output\n            if outputs[best_idx] >= max_p_arr[best_idx]:\n                active_units.remove(best_idx)\n    \n    # Step 6: Set schedules for all units\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set:\n            schedules[0, i] = 1\n            schedules[1, i] = outputs[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00618,
          "gap_price_rate": 0.01024,
          "fitness": 0.00821
     },
     {
          "name": "improved_greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time violation or shutdown ramp constraint violation) and forced-off units (must remain offline due to min down-time violation). \n2. Initialize committed units as forced-on units. Compute total min/max feasible power from committed units respecting ramp limits.\n3. If max feasible power < load demand, activate free units in ascending order of total cost per MW at min output until sufficient capacity. Total cost includes startup cost.\n4. Calculate dispatch target by clamping load between total min and max feasible power.\n5. Perform economic dispatch:\n   - Use sequential quadratic programming (SQP) optimization with constraints\n   - Handle ramp limits for continuously online units\n   - Apply startup ramp limits for newly activated units\n   - Enforce min/max power limits for all units\n6. Deactivate non-committed units (0 output).\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef improved_greedy_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    committed = np.zeros(num_units, dtype=bool)\n    on_states = np.zeros(num_units, dtype=int)\n    outputs = np.zeros(num_units)\n    \n    # Identify forced-on and forced-off units\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Was online\n            if (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i):\n                forced_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < t_off_min_i:\n                forced_off.append(i)\n    \n    # Initialize committed units\n    committed[forced_on] = True\n    \n    # Calculate current min/max power for committed units\n    def get_power_limits():\n        total_min, total_max = 0, 0\n        min_limits = np.zeros(num_units)\n        max_limits = np.zeros(num_units)\n        \n        for i, unit in enumerate(units_info):\n            if committed[i]:\n                if unit['u_i_0'] == 1:\n                    min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    min_limits[i] = unit['p_min_i']\n                    max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n                \n                total_min += min_limits[i]\n                total_max += max_limits[i]\n            else:\n                min_limits[i] = max_limits[i] = 0\n                \n        return total_min, total_max, min_limits, max_limits\n    \n    total_min, total_max, min_limits, max_limits = get_power_limits()\n    \n    # Activate additional units if needed\n    if total_max < load:\n        # Calculate total cost per MW at min output\n        free_units = []\n        costs_per_mw = []\n        for i in range(num_units):\n            if i not in forced_on and i not in forced_off and not committed[i]:\n                unit = units_info[i]\n                min_power = unit['p_min_i']\n                min_cost = unit['a_i'] + unit['b_i']*min_power + unit['c_i']*(min_power**2)\n                if unit['u_i_0'] == 0:\n                    min_cost += unit['s_i']\n                costs_per_mw.append(min_cost / min_power)\n                free_units.append(i)\n        \n        if free_units:\n            # Sort by cost efficiency\n            order = np.argsort(costs_per_mw)\n            free_units = [free_units[i] for i in order]\n            \n            for i in free_units:\n                committed[i] = True\n                total_min, total_max, min_limits, max_limits = get_power_limits()\n                if total_max >= load:\n                    break\n    \n    # Update power limits after activation\n    total_min, total_max, min_limits, max_limits = get_power_limits()\n    \n    # Determine dispatch target\n    target = max(min(load, total_max), total_min)\n    \n    # Economic dispatch via SQP optimization\n    def cost_function(p):\n        total_cost = 0\n        for idx, unit in enumerate(units_info):\n            if committed[idx]:\n                p_i = p[idx]\n                total_cost += (unit['a_i'] + unit['b_i']*p_i + unit['c_i']*p_i**2)\n        return total_cost\n    \n    # Prepare constraints and bounds\n    x0 = min_limits.copy()\n    bounds = [(min_limits[i], max_limits[i]) for i in range(num_units)]\n    cons = {'type': 'eq', 'fun': lambda p: np.sum(p) - target}\n    \n    # Solve optimization\n    res = minimize(cost_function, x0, method='SLSQP', \n                   bounds=bounds, constraints=cons,\n                   options={'ftol': 1e-6, 'maxiter': 100})\n    \n    if res.success:\n        outputs = res.x\n    else:  # Fallback: proportionally adjust output\n        if total_min > 0 and total_max > total_min:\n            outputs = min_limits + (max_limits - min_limits) * (target - total_min) / (total_max - total_min)\n        else:\n            outputs = np.zeros(num_units)\n    \n    # Set final states and outputs\n    on_states = committed.astype(int)\n    for i in range(num_units):\n        if not committed[i]:\n            outputs[i] = 0\n    \n    return np.vstack((on_states, outputs))",
          "from": "mutation",
          "gap_power_rate": 0.00065,
          "gap_price_rate": 0.01598,
          "fitness": 0.00832
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify mandatory on units based on previous state, min up time, and shutdown constraints.\n2. Identify mandatory off units based on min down time constraints.\n3. Compute feasible power ranges for mandatory on units considering ramp limits.\n4. If load is below mandatory units' total min output, set mandatory units to min output.\n5. If load is within mandatory units' output range, dispatch mandatory units economically.\n6. If load exceeds mandatory capacity, turn on discretionary units in cost-effective order.\n7. Dispatch all committed units to meet load as closely as possible while minimizing cost.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Initialize unit parameters\n    n = len(units_info)\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    u_i0 = [u['u_i_0'] for u in units_info]\n    p_i0 = [u['p_i_0'] for u in units_info]\n    t_i0 = [u['t_i_0'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    \n    # Initialize states and outputs\n    u_i = [0] * n\n    p_i = [0] * n\n    min_out = [0] * n\n    max_out = [0] * n\n    \n    # Identify mandatory on and off units\n    mand_on = [False] * n\n    mand_off = [False] * n\n    \n    for i in range(n):\n        if u_i0[i] == 1:\n            if t_i0[i] < t_on_min[i] or p_i0[i] > p_shut[i]:\n                mand_on[i] = True\n                u_i[i] = 1\n        else:\n            if abs(t_i0[i]) < t_off_min[i]:\n                mand_off[i] = True\n                u_i[i] = 0\n    \n    # Set feasible output ranges\n    for i in range(n):\n        if mand_on[i]:\n            min_out[i] = max(p_min[i], p_i0[i] - p_down[i])\n            max_out[i] = min(p_max[i], p_i0[i] + p_up[i])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n    \n    # Calculate mandatory capacity\n    mand_min = sum(min_out[i] for i in range(n) if mand_on[i])\n    mand_max = sum(max_out[i] for i in range(n) if mand_on[i])\n    \n    # Case 1: Load below mandatory minimum\n    if load < mand_min:\n        for i in range(n):\n            if mand_on[i]:\n                p_i[i] = min_out[i]\n        return np.array([u_i, p_i])\n    \n    # Case 2: Load within mandatory capacity\n    if load <= mand_max:\n        committed = [i for i in range(n) if mand_on[i]]\n        p_arr = greedy_dispatch(committed, min_out, max_out, a, b, c, load)\n        for idx, i in enumerate(committed):\n            p_i[i] = p_arr[idx]\n        return np.array([u_i, p_i])\n    \n    # Case 3: Load exceeds mandatory capacity - set mandatory to max\n    for i in range(n):\n        if mand_on[i]:\n            p_i[i] = max_out[i]\n    deficit = load - mand_max\n    \n    # Collect available discretionary units\n    avail_units = []\n    for i in range(n):\n        if not mand_on[i] and not mand_off[i]:\n            min_out[i] = p_min[i]\n            max_out[i] = min(p_max[i], p_start[i])\n            startup_cost = s[i] if u_i0[i] == 0 else 0\n            total_cost = startup_cost + a[i] + b[i] * min_out[i] + c[i] * min_out[i]**2\n            if min_out[i] > 0:\n                avg_cost = total_cost / min_out[i]\n            else:\n                total_cost = startup_cost + a[i] + b[i] * max_out[i] + c[i] * max_out[i]**2\n                avg_cost = total_cost / max_out[i] if max_out[i] > 0 else float('inf')\n            avail_units.append((i, avg_cost, min_out[i]))\n    \n    # Sort by average cost\n    avail_units.sort(key=lambda x: x[1])\n    committed = [i for i in range(n) if mand_on[i]]\n    \n    # Add discretionary units until deficit covered or no more available\n    total_max = mand_max\n    for unit in avail_units:\n        i, _, _ = unit\n        u_i[i] = 1\n        committed.append(i)\n        total_max += max_out[i]\n        deficit = load - total_max\n        if total_max >= load:\n            break\n    \n    # Dispatch all committed units\n    p_arr = greedy_dispatch(committed, min_out, max_out, a, b, c, load)\n    for idx, i in enumerate(committed):\n        p_i[i] = p_arr[idx]\n    \n    return np.array([u_i, p_i])\n\ndef greedy_dispatch(units, min_out, max_out, a, b, c, target_load):\n    n = len(units)\n    p = [min_out[i] for i in units]\n    current_total = sum(p)\n    \n    while current_total < target_load:\n        best_idx = None\n        best_mc = float('inf')\n        for j in range(n):\n            i = units[j]\n            if p[j] < max_out[i]:\n                mc = 2 * c[i] * p[j] + b[i]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = j\n        \n        if best_idx is None:\n            break\n        \n        i = units[best_idx]\n        increase = min(max_out[i] - p[best_idx], target_load - current_total)\n        p[best_idx] += increase\n        current_total += increase\n    \n    return p",
          "from": null,
          "gap_power_rate": 0.0064,
          "gap_price_rate": 0.01046,
          "fitness": 0.00843
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify forced-on units based on minimum up-time constraints and shutdown capacity limitations\n2. Set forced-off units to offline state\n3. Initialize unit outputs to minimum levels for forced-on units\n4. Calculate power deficit (load - current total output)\n5. While deficit remains:\n   a. Find online units with available capacity to increase output\n   b. Find offline units eligible to start\n   c. Select unit with lowest marginal cost (online) or average cost (offline)\n   d. Increase output of selected online unit or start offline unit at minimum capacity\n6. Calculate power surplus (negative deficit)\n7. While surplus remains:\n   a. Find online units that can reduce output below current levels\n   b. Select unit with highest marginal cost\n   c. Reduce output by maximum possible amount\n8. Return commitment and output schedules as a 2D numpy array\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    current_u = np.zeros(n_units, dtype=int)\n    current_p = np.zeros(n_units)\n    forced_on = []\n    forced_off = []\n\n    # Identify forced on/off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Initialize states and outputs\n    for i in forced_on:\n        current_u[i] = 1\n        prev_out = units_info[i]['p_i_0']\n        ramp_min = prev_out - units_info[i]['p_down_i']\n        current_p[i] = max(units_info[i]['p_min_i'], ramp_min)\n    \n    for i in forced_off:\n        current_u[i] = 0\n        current_p[i] = 0.0\n    \n    # Calculate initial deficit\n    total_output = sum(current_p)\n    deficit = load - total_output\n    tol = 1e-5\n    \n    # Handle deficit\n    while deficit > tol:\n        best_online_idx = None\n        best_online_mc = float('inf')\n        best_online_inc = 0.0\n        best_offline_idx = None\n        best_offline_avg_cost = float('inf')\n        best_offline_min_p = 0.0\n        \n        # Find best online unit to increase\n        for i, unit in enumerate(units_info):\n            if current_u[i] == 1:  # Unit is online\n                if unit['u_i_0'] == 1:  # Was previously online\n                    max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:  # Was started this period\n                    max_out = min(unit['p_max_i'], unit['p_start_i'])\n                \n                if current_p[i] < max_out - tol:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p[i]\n                    inc_possible = min(deficit, max_out - current_p[i])\n                    if marginal_cost < best_online_mc and inc_possible > tol:\n                        best_online_mc = marginal_cost\n                        best_online_idx = i\n                        best_online_inc = inc_possible\n        \n        # Find best offline unit to start\n        for i, unit in enumerate(units_info):\n            if current_u[i] == 0 and i not in forced_off:\n                min_p = unit['p_min_i']\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + \n                            unit['c_i'] * min_p**2) / min_p\n                if avg_cost < best_offline_avg_cost:\n                    best_offline_avg_cost = avg_cost\n                    best_offline_idx = i\n                    best_offline_min_p = min_p\n        \n        # Apply best option\n        if best_online_idx is not None and best_offline_idx is not None:\n            if best_online_mc <= best_offline_avg_cost:\n                current_p[best_online_idx] += best_online_inc\n                deficit -= best_online_inc\n            else:\n                current_u[best_offline_idx] = 1\n                current_p[best_offline_idx] = best_offline_min_p\n                deficit -= best_offline_min_p\n        elif best_online_idx is not None:\n            current_p[best_online_idx] += best_online_inc\n            deficit -= best_online_inc\n        elif best_offline_idx is not None:\n            current_u[best_offline_idx] = 1\n            current_p[best_offline_idx] = best_offline_min_p\n            deficit -= best_offline_min_p\n        else:\n            break  # No feasible solution\n    \n    # Handle surplus\n    surplus = -deficit\n    while surplus > tol:\n        best_reduce_idx = None\n        best_reduce_mc = -1\n        best_reduce_amount = 0.0\n        \n        for i, unit in enumerate(units_info):\n            if current_u[i] == 1:\n                if unit['u_i_0'] == 1:\n                    min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    min_p = unit['p_min_i']\n                \n                if current_p[i] > min_p + tol:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p[i]\n                    reduce_possible = min(surplus, current_p[i] - min_p)\n                    if marginal_cost > best_reduce_mc and reduce_possible > tol:\n                        best_reduce_mc = marginal_cost\n                        best_reduce_idx = i\n                        best_reduce_amount = reduce_possible\n        \n        if best_reduce_idx is not None:\n            current_p[best_reduce_idx] -= best_reduce_amount\n            surplus -= best_reduce_amount\n        else:\n            break\n    \n    return np.array([current_u, current_p])",
          "from": null,
          "gap_power_rate": 0.00622,
          "gap_price_rate": 0.01074,
          "fitness": 0.00848
     }
]