[
     {
          "name": "greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00917,
          "fitness": 0.00748
     },
     {
          "name": "enhanced_greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time constraints or shutdown capacity limitations) and forced-off units (must remain offline due to minimum down-time constraints)  \n2. Set forced-on units to online, compute feasible power ranges respecting ramp limits; set forced-off units to offline  \n3. Calculate total minimum/maximum output from forced-on units  \n4. While total maximum output < load and free units exist, turn on free units sorted by adjusted average cost (including startup cost) at minimum output  \n5. For newly started units, set feasible output range with startup ramp limitations  \n6. Set dispatch target as load clamped between total feasible minimum and maximum outputs  \n7. For committed units, perform economic dispatch via lambda iteration with unit-specific constraints:  \n   - Continuously online units constrained by regular ramp limits  \n   - Newly started units constrained by startup ramp limits  \n8. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_greedy_rolling_commitment(units_info, load):  \n    n_units = len(units_info)  \n    u_schedule = [0] * n_units  \n    p_schedule = [0.0] * n_units  \n    min_feasible = [0.0] * n_units  \n    max_feasible = [0.0] * n_units  \n    committed = [False] * n_units  \n    forced_on_indices = []  \n    forced_off_indices = []  \n    free_indices = []  \n\n    # Classify units based on physical constraints  \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        if u_i0 == 1:  \n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:  \n                forced_on_indices.append(i)  \n            else:  \n                free_indices.append(i)  \n        else:  \n            if abs(t_i0) < unit['t_off_min_i']:  \n                forced_off_indices.append(i)  \n            else:  \n                free_indices.append(i)  \n\n    # Process forced-off units  \n    for i in forced_off_indices:  \n        committed[i] = False  \n        u_schedule[i] = 0  \n        p_schedule[i] = 0.0  \n        min_feasible[i] = 0.0  \n        max_feasible[i] = 0.0  \n\n    # Process forced-on units  \n    for i in forced_on_indices:  \n        unit = units_info[i]  \n        min_feas = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        max_feas = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        min_feasible[i] = min_feas  \n        max_feasible[i] = max_feas  \n        committed[i] = True  \n        u_schedule[i] = 1  \n\n    # Initial total power calculations  \n    total_min = sum(min_feasible[i] for i in forced_on_indices)  \n    total_max = sum(max_feasible[i] for i in forced_on_indices)  \n\n    # Cost-based unit activation  \n    def calc_criterion(unit):  \n        return (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] +  \n                unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']  \n    free_indices_sorted = sorted(free_indices, key=lambda i: calc_criterion(units_info[i]))  \n\n    new_committed = []  \n    for i in free_indices_sorted:  \n        if total_max < load:  \n            unit = units_info[i]  \n            min_feasible[i] = unit['p_min_i']  \n            max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])  \n            u_schedule[i] = 1  \n            committed[i] = True  \n            new_committed.append(i)  \n            total_min += min_feasible[i]  \n            total_max += max_feasible[i]  \n\n    # Calculate dispatch target  \n    target = min(max(total_min, load), total_max)  \n    committed_indices = forced_on_indices + new_committed  \n\n    # Lambda iteration for economic dispatch  \n    if committed_indices:  \n        b_vec = [units_info[i]['b_i'] for i in committed_indices]  \n        c_vec = [units_info[i]['c_i'] for i in committed_indices]  \n        min_vec = [min_feasible[i] for i in committed_indices]  \n        max_vec = [max_feasible[i] for i in committed_indices]  \n        lo = 0  \n        hi = 1e6  \n        tol = 1e-6  \n        iter_count = 0  \n        max_iter = 100  \n        while abs(hi - lo) > tol and iter_count < max_iter:  \n            mid = (lo + hi) / 2  \n            total_p = 0.0  \n            for idx, (b, c, p_min, p_max) in enumerate(zip(b_vec, c_vec, min_vec, max_vec)):  \n                if c == 0:  \n                    p_val = p_max if mid >= b else p_min  \n                else:  \n                    p_uncon = (mid - b) / (2 * c)  \n                    p_val = max(p_min, min(p_max, p_uncon))  \n                total_p += p_val  \n            if total_p < target:  \n                lo = mid  \n            else:  \n                hi = mid  \n            iter_count += 1  \n        lambda_opt = (lo + hi) / 2  \n        for idx, i in enumerate(committed_indices):  \n            b = b_vec[idx]  \n            c = c_vec[idx]  \n            p_min = min_vec[idx]  \n            p_max = max_vec[idx]  \n            if c == 0:  \n                p_val = p_max if lambda_opt >= b else p_min  \n            else:  \n                p_val = (lambda_opt - b) / (2 * c)  \n                p_val = max(p_min, min(p_max, p_val))  \n            p_schedule[i] = p_val  \n    return np.array([u_schedule, p_schedule])  ",
          "from": "crossover",
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00936,
          "fitness": 0.00758
     },
     {
          "name": "adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time constraints or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate total min/max output from committed units accounting for ramp constraints.\n3. If load exceeds maximum available output:\n   - Sort eligible offline units by amortized average cost (startup cost amortized over minimum up-time plus average production cost at minimum output)\n   - Commit units in ascending cost order until sufficient capacity is available\n4. Calculate dispatch target as load clamped between total min and max feasible output.\n5. Perform economic dispatch using lambda iteration to minimize production costs while respecting:\n   - Ramp limits for continuously online units\n   - Startup ramp limits for newly committed units\n   - Minimum/maximum output constraints\n6. Set non-committed units to offline state with zero output.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef adaptive_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    committed = []\n    forced_on = []\n    forced_off = []\n    \n    # Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    committed = forced_on.copy()\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    # Calculate feasible ranges for forced-on units\n    total_min, total_max = 0.0, 0.0\n    for i in committed:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_outputs[i] = min_output\n        max_outputs[i] = max_output\n        total_min += min_output\n        total_max += max_output\n    \n    # Add offline units if needed\n    candidate_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    if total_max < load:\n        amortized_costs = []\n        for i in candidate_units:\n            unit = units_info[i]\n            amort_period = max(1, unit['t_on_min_i'])\n            avg_cost = (unit['s_i'] / amort_period + unit['b_i'] * unit['p_min_i'] + \n                        unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            amortized_costs.append((avg_cost, i))\n        \n        amortized_costs.sort(key=lambda x: x[0])\n        \n        for _, i in amortized_costs:\n            if total_max >= load:\n                break\n            unit = units_info[i]\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            min_outputs[i] = min_out\n            max_outputs[i] = max_out\n            total_min += min_out\n            total_max += max_out\n            committed.append(i)\n    \n    # Calculate dispatch target\n    target = np.clip(load, total_min, total_max)\n    \n    # Lambda iteration for economic dispatch\n    p_alloc = np.zeros(n_units)\n    low_lambda = -1000.0\n    high_lambda = 10000.0\n    tol = 1e-5\n    max_iter = 1000\n    \n    for iter_count in range(max_iter):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0.0\n        \n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                p_alloc[i] = min_outputs[i] if mid_lambda < unit['b_i'] else max_outputs[i]\n            else:\n                p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n            total_power += p_alloc[i]\n        \n        if abs(total_power - target) < tol:\n            break\n        \n        if total_power < target:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = p_alloc[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00644,
          "gap_price_rate": 0.00921,
          "fitness": 0.00782
     },
     {
          "name": "enhanced_adaptive_dispatch",
          "algorithm": "1. Identify must-run units (units that must remain online due to minimum up-time constraints or shutdown ramp violations) and must-off units (units that must remain offline due to minimum down-time constraints).\n2. Initialize online_set as must-run units. Compute current total minimum and maximum outputs for online_set considering ramp constraints.\n3. If total maximum output is insufficient to meet load, add candidate units (sorted by adjusted average cost per MW at minimum output) to online_set until capacity is sufficient.\n4. Calculate target load (clamped between feasible generation limits).\n5. Initialize unit outputs to their minimum values then perform greedy economic dispatch to distribute residual load among online units:\n   - While residual load remains, allocate to unit with lowest marginal cost until capacity limits are reached.\n6. For units not in online_set, set commitment state to 0 and output to 0.\n7. Return schedule array with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_dispatch(units_info, load):\n    # Step 1: Identify must-run and must-off units\n    n_units = len(units_info)\n    must_run_idx = []\n    must_off_idx = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_run_idx.append(idx)\n        else:  # u_i_0 == 0\n            if t_i_0 < 0 and -t_i_0 < unit['t_off_min_i']:\n                must_off_idx.append(idx)\n    \n    # Step 2: Initialize online_set with must-run units and compute power ranges\n    online_set = set(must_run_idx)\n    min_p_arr = np.zeros(n_units)\n    max_p_arr = np.zeros(n_units)\n    outputs = np.zeros(n_units)\n    \n    for idx in online_set:\n        unit = units_info[idx]\n        min_p_arr[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p_arr[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        outputs[idx] = min_p_arr[idx]\n    \n    total_min = sum(min_p_arr[list(online_set)])\n    total_max = sum(max_p_arr[list(online_set)])\n    \n    # Step 3: Add candidate units if insufficient capacity\n    candidate_set = [i for i in range(n_units) \n                   if i not in online_set and i not in must_off_idx]\n    candidate_set.sort(key=lambda i: (\n        (units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n         units_info[i]['c_i'] * units_info[i]['p_min_i']**2 + \n         (units_info[i]['s_i'] if units_info[i]['u_i_0'] == 0 else 0)) \n        / units_info[i]['p_min_i']\n    ))\n    \n    for i in candidate_set:\n        if total_max >= load:\n            break\n        unit = units_info[i]\n        \n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        \n        min_p_arr[i] = min_p\n        max_p_arr[i] = max_p\n        outputs[i] = min_p\n        online_set.add(i)\n        total_min += min_p\n        total_max += max_p\n    \n    # Step 4: Compute target load within feasible limits\n    target_load = max(total_min, min(total_max, load))\n    \n    # Step 5: Perform economic dispatch using greedy method\n    residual = target_load - total_min\n    if residual > 0:\n        active_units = [i for i in online_set if outputs[i] < max_p_arr[i]]\n        \n        while residual > 0 and active_units:\n            # Find unit with lowest marginal cost\n            min_cost = float('inf')\n            best_idx = None\n            \n            for i in active_units:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]\n                if mc < min_cost:\n                    min_cost = mc\n                    best_idx = i\n            \n            # Calculate maximum possible increase\n            available = max_p_arr[best_idx] - outputs[best_idx]\n            increase = min(available, residual)\n            \n            # Update output and residual\n            outputs[best_idx] += increase\n            residual -= increase\n            \n            # Remove unit if it reaches max output\n            if outputs[best_idx] >= max_p_arr[best_idx]:\n                active_units.remove(best_idx)\n    \n    # Step 6: Set schedules for all units\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set:\n            schedules[0, i] = 1\n            schedules[1, i] = outputs[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00618,
          "gap_price_rate": 0.01024,
          "fitness": 0.00821
     },
     {
          "name": "improved_greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time violation or shutdown ramp constraint violation) and forced-off units (must remain offline due to min down-time violation). \n2. Initialize committed units as forced-on units. Compute total min/max feasible power from committed units respecting ramp limits.\n3. If max feasible power < load demand, activate free units in ascending order of total cost per MW at min output until sufficient capacity. Total cost includes startup cost.\n4. Calculate dispatch target by clamping load between total min and max feasible power.\n5. Perform economic dispatch:\n   - Use sequential quadratic programming (SQP) optimization with constraints\n   - Handle ramp limits for continuously online units\n   - Apply startup ramp limits for newly activated units\n   - Enforce min/max power limits for all units\n6. Deactivate non-committed units (0 output).\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef improved_greedy_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    committed = np.zeros(num_units, dtype=bool)\n    on_states = np.zeros(num_units, dtype=int)\n    outputs = np.zeros(num_units)\n    \n    # Identify forced-on and forced-off units\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Was online\n            if (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i):\n                forced_on.append(i)\n        else:  # Was offline\n            if -t_i_0 < t_off_min_i:\n                forced_off.append(i)\n    \n    # Initialize committed units\n    committed[forced_on] = True\n    \n    # Calculate current min/max power for committed units\n    def get_power_limits():\n        total_min, total_max = 0, 0\n        min_limits = np.zeros(num_units)\n        max_limits = np.zeros(num_units)\n        \n        for i, unit in enumerate(units_info):\n            if committed[i]:\n                if unit['u_i_0'] == 1:\n                    min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    min_limits[i] = unit['p_min_i']\n                    max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n                \n                total_min += min_limits[i]\n                total_max += max_limits[i]\n            else:\n                min_limits[i] = max_limits[i] = 0\n                \n        return total_min, total_max, min_limits, max_limits\n    \n    total_min, total_max, min_limits, max_limits = get_power_limits()\n    \n    # Activate additional units if needed\n    if total_max < load:\n        # Calculate total cost per MW at min output\n        free_units = []\n        costs_per_mw = []\n        for i in range(num_units):\n            if i not in forced_on and i not in forced_off and not committed[i]:\n                unit = units_info[i]\n                min_power = unit['p_min_i']\n                min_cost = unit['a_i'] + unit['b_i']*min_power + unit['c_i']*(min_power**2)\n                if unit['u_i_0'] == 0:\n                    min_cost += unit['s_i']\n                costs_per_mw.append(min_cost / min_power)\n                free_units.append(i)\n        \n        if free_units:\n            # Sort by cost efficiency\n            order = np.argsort(costs_per_mw)\n            free_units = [free_units[i] for i in order]\n            \n            for i in free_units:\n                committed[i] = True\n                total_min, total_max, min_limits, max_limits = get_power_limits()\n                if total_max >= load:\n                    break\n    \n    # Update power limits after activation\n    total_min, total_max, min_limits, max_limits = get_power_limits()\n    \n    # Determine dispatch target\n    target = max(min(load, total_max), total_min)\n    \n    # Economic dispatch via SQP optimization\n    def cost_function(p):\n        total_cost = 0\n        for idx, unit in enumerate(units_info):\n            if committed[idx]:\n                p_i = p[idx]\n                total_cost += (unit['a_i'] + unit['b_i']*p_i + unit['c_i']*p_i**2)\n        return total_cost\n    \n    # Prepare constraints and bounds\n    x0 = min_limits.copy()\n    bounds = [(min_limits[i], max_limits[i]) for i in range(num_units)]\n    cons = {'type': 'eq', 'fun': lambda p: np.sum(p) - target}\n    \n    # Solve optimization\n    res = minimize(cost_function, x0, method='SLSQP', \n                   bounds=bounds, constraints=cons,\n                   options={'ftol': 1e-6, 'maxiter': 100})\n    \n    if res.success:\n        outputs = res.x\n    else:  # Fallback: proportionally adjust output\n        if total_min > 0 and total_max > total_min:\n            outputs = min_limits + (max_limits - min_limits) * (target - total_min) / (total_max - total_min)\n        else:\n            outputs = np.zeros(num_units)\n    \n    # Set final states and outputs\n    on_states = committed.astype(int)\n    for i in range(num_units):\n        if not committed[i]:\n            outputs[i] = 0\n    \n    return np.vstack((on_states, outputs))",
          "from": "mutation",
          "gap_power_rate": 0.00065,
          "gap_price_rate": 0.01598,
          "fitness": 0.00832
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify mandatory on units based on previous state, min up time, and shutdown constraints.\n2. Identify mandatory off units based on min down time constraints.\n3. Compute feasible power ranges for mandatory on units considering ramp limits.\n4. If load is below mandatory units' total min output, set mandatory units to min output.\n5. If load is within mandatory units' output range, dispatch mandatory units economically.\n6. If load exceeds mandatory capacity, turn on discretionary units in cost-effective order.\n7. Dispatch all committed units to meet load as closely as possible while minimizing cost.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Initialize unit parameters\n    n = len(units_info)\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    u_i0 = [u['u_i_0'] for u in units_info]\n    p_i0 = [u['p_i_0'] for u in units_info]\n    t_i0 = [u['t_i_0'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    \n    # Initialize states and outputs\n    u_i = [0] * n\n    p_i = [0] * n\n    min_out = [0] * n\n    max_out = [0] * n\n    \n    # Identify mandatory on and off units\n    mand_on = [False] * n\n    mand_off = [False] * n\n    \n    for i in range(n):\n        if u_i0[i] == 1:\n            if t_i0[i] < t_on_min[i] or p_i0[i] > p_shut[i]:\n                mand_on[i] = True\n                u_i[i] = 1\n        else:\n            if abs(t_i0[i]) < t_off_min[i]:\n                mand_off[i] = True\n                u_i[i] = 0\n    \n    # Set feasible output ranges\n    for i in range(n):\n        if mand_on[i]:\n            min_out[i] = max(p_min[i], p_i0[i] - p_down[i])\n            max_out[i] = min(p_max[i], p_i0[i] + p_up[i])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n    \n    # Calculate mandatory capacity\n    mand_min = sum(min_out[i] for i in range(n) if mand_on[i])\n    mand_max = sum(max_out[i] for i in range(n) if mand_on[i])\n    \n    # Case 1: Load below mandatory minimum\n    if load < mand_min:\n        for i in range(n):\n            if mand_on[i]:\n                p_i[i] = min_out[i]\n        return np.array([u_i, p_i])\n    \n    # Case 2: Load within mandatory capacity\n    if load <= mand_max:\n        committed = [i for i in range(n) if mand_on[i]]\n        p_arr = greedy_dispatch(committed, min_out, max_out, a, b, c, load)\n        for idx, i in enumerate(committed):\n            p_i[i] = p_arr[idx]\n        return np.array([u_i, p_i])\n    \n    # Case 3: Load exceeds mandatory capacity - set mandatory to max\n    for i in range(n):\n        if mand_on[i]:\n            p_i[i] = max_out[i]\n    deficit = load - mand_max\n    \n    # Collect available discretionary units\n    avail_units = []\n    for i in range(n):\n        if not mand_on[i] and not mand_off[i]:\n            min_out[i] = p_min[i]\n            max_out[i] = min(p_max[i], p_start[i])\n            startup_cost = s[i] if u_i0[i] == 0 else 0\n            total_cost = startup_cost + a[i] + b[i] * min_out[i] + c[i] * min_out[i]**2\n            if min_out[i] > 0:\n                avg_cost = total_cost / min_out[i]\n            else:\n                total_cost = startup_cost + a[i] + b[i] * max_out[i] + c[i] * max_out[i]**2\n                avg_cost = total_cost / max_out[i] if max_out[i] > 0 else float('inf')\n            avail_units.append((i, avg_cost, min_out[i]))\n    \n    # Sort by average cost\n    avail_units.sort(key=lambda x: x[1])\n    committed = [i for i in range(n) if mand_on[i]]\n    \n    # Add discretionary units until deficit covered or no more available\n    total_max = mand_max\n    for unit in avail_units:\n        i, _, _ = unit\n        u_i[i] = 1\n        committed.append(i)\n        total_max += max_out[i]\n        deficit = load - total_max\n        if total_max >= load:\n            break\n    \n    # Dispatch all committed units\n    p_arr = greedy_dispatch(committed, min_out, max_out, a, b, c, load)\n    for idx, i in enumerate(committed):\n        p_i[i] = p_arr[idx]\n    \n    return np.array([u_i, p_i])\n\ndef greedy_dispatch(units, min_out, max_out, a, b, c, target_load):\n    n = len(units)\n    p = [min_out[i] for i in units]\n    current_total = sum(p)\n    \n    while current_total < target_load:\n        best_idx = None\n        best_mc = float('inf')\n        for j in range(n):\n            i = units[j]\n            if p[j] < max_out[i]:\n                mc = 2 * c[i] * p[j] + b[i]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = j\n        \n        if best_idx is None:\n            break\n        \n        i = units[best_idx]\n        increase = min(max_out[i] - p[best_idx], target_load - current_total)\n        p[best_idx] += increase\n        current_total += increase\n    \n    return p",
          "from": null,
          "gap_power_rate": 0.0064,
          "gap_price_rate": 0.01046,
          "fitness": 0.00843
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify forced-on units based on minimum up-time constraints and shutdown capacity limitations\n2. Set forced-off units to offline state\n3. Initialize unit outputs to minimum levels for forced-on units\n4. Calculate power deficit (load - current total output)\n5. While deficit remains:\n   a. Find online units with available capacity to increase output\n   b. Find offline units eligible to start\n   c. Select unit with lowest marginal cost (online) or average cost (offline)\n   d. Increase output of selected online unit or start offline unit at minimum capacity\n6. Calculate power surplus (negative deficit)\n7. While surplus remains:\n   a. Find online units that can reduce output below current levels\n   b. Select unit with highest marginal cost\n   c. Reduce output by maximum possible amount\n8. Return commitment and output schedules as a 2D numpy array\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    current_u = np.zeros(n_units, dtype=int)\n    current_p = np.zeros(n_units)\n    forced_on = []\n    forced_off = []\n\n    # Identify forced on/off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Initialize states and outputs\n    for i in forced_on:\n        current_u[i] = 1\n        prev_out = units_info[i]['p_i_0']\n        ramp_min = prev_out - units_info[i]['p_down_i']\n        current_p[i] = max(units_info[i]['p_min_i'], ramp_min)\n    \n    for i in forced_off:\n        current_u[i] = 0\n        current_p[i] = 0.0\n    \n    # Calculate initial deficit\n    total_output = sum(current_p)\n    deficit = load - total_output\n    tol = 1e-5\n    \n    # Handle deficit\n    while deficit > tol:\n        best_online_idx = None\n        best_online_mc = float('inf')\n        best_online_inc = 0.0\n        best_offline_idx = None\n        best_offline_avg_cost = float('inf')\n        best_offline_min_p = 0.0\n        \n        # Find best online unit to increase\n        for i, unit in enumerate(units_info):\n            if current_u[i] == 1:  # Unit is online\n                if unit['u_i_0'] == 1:  # Was previously online\n                    max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:  # Was started this period\n                    max_out = min(unit['p_max_i'], unit['p_start_i'])\n                \n                if current_p[i] < max_out - tol:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p[i]\n                    inc_possible = min(deficit, max_out - current_p[i])\n                    if marginal_cost < best_online_mc and inc_possible > tol:\n                        best_online_mc = marginal_cost\n                        best_online_idx = i\n                        best_online_inc = inc_possible\n        \n        # Find best offline unit to start\n        for i, unit in enumerate(units_info):\n            if current_u[i] == 0 and i not in forced_off:\n                min_p = unit['p_min_i']\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + \n                            unit['c_i'] * min_p**2) / min_p\n                if avg_cost < best_offline_avg_cost:\n                    best_offline_avg_cost = avg_cost\n                    best_offline_idx = i\n                    best_offline_min_p = min_p\n        \n        # Apply best option\n        if best_online_idx is not None and best_offline_idx is not None:\n            if best_online_mc <= best_offline_avg_cost:\n                current_p[best_online_idx] += best_online_inc\n                deficit -= best_online_inc\n            else:\n                current_u[best_offline_idx] = 1\n                current_p[best_offline_idx] = best_offline_min_p\n                deficit -= best_offline_min_p\n        elif best_online_idx is not None:\n            current_p[best_online_idx] += best_online_inc\n            deficit -= best_online_inc\n        elif best_offline_idx is not None:\n            current_u[best_offline_idx] = 1\n            current_p[best_offline_idx] = best_offline_min_p\n            deficit -= best_offline_min_p\n        else:\n            break  # No feasible solution\n    \n    # Handle surplus\n    surplus = -deficit\n    while surplus > tol:\n        best_reduce_idx = None\n        best_reduce_mc = -1\n        best_reduce_amount = 0.0\n        \n        for i, unit in enumerate(units_info):\n            if current_u[i] == 1:\n                if unit['u_i_0'] == 1:\n                    min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    min_p = unit['p_min_i']\n                \n                if current_p[i] > min_p + tol:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p[i]\n                    reduce_possible = min(surplus, current_p[i] - min_p)\n                    if marginal_cost > best_reduce_mc and reduce_possible > tol:\n                        best_reduce_mc = marginal_cost\n                        best_reduce_idx = i\n                        best_reduce_amount = reduce_possible\n        \n        if best_reduce_idx is not None:\n            current_p[best_reduce_idx] -= best_reduce_amount\n            surplus -= best_reduce_amount\n        else:\n            break\n    \n    return np.array([current_u, current_p])",
          "from": null,
          "gap_power_rate": 0.00622,
          "gap_price_rate": 0.01074,
          "fitness": 0.00848
     },
     {
          "name": "refined_marginal_cost_heuristic",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown constraints) and forced-off units (must remain offline due to min down-time)\n2. Initialize forced-on units to safe operating points considering ramp constraints, set forced-off units offline\n3. Calculate power deficit/surplus relative to current load\n4. While deficit exists:\n   a. Evaluate online units' marginal cost at current output and maximum ramp-up capacity\n   b. Evaluate offline units' average full cost (startup + production) at minimum output\n   c. Select most economical option: ramp up online unit with lowest marginal cost OR start offline unit with lowest average full cost\n   d. Adjust output or start unit accordingly, update total output\n5. If surplus exists:\n   a. Evaluate online units' marginal cost and maximum ramp-down capacity\n   b. Reduce output of most expensive units first until surplus eliminated\n6. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef refined_marginal_cost_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    started_now = [False] * n_units\n    \n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    p_shut_i = [unit['p_shut_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    u_i0 = [unit['u_i_0'] for unit in units_info]\n    p_i0 = [unit['p_i_0'] for unit in units_info]\n    t_i0 = [unit['t_i_0'] for unit in units_info]\n    \n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_i0[i] == 1:\n            if t_i0[i] < t_on_min_i[i] or p_i0[i] > p_shut_i[i]:\n                forced_on[i] = True\n        elif u_i0[i] == 0:\n            if -t_i0[i] < t_off_min_i[i]:\n                forced_off[i] = True\n    \n    total_output = 0.0\n    for i in range(n_units):\n        if forced_off[i]:\n            u[i] = 0\n            p[i] = 0.0\n        elif forced_on[i]:\n            u[i] = 1\n            lb = max(p_min_i[i], p_i0[i] - p_down_i[i])\n            ub = min(p_max_i[i], p_i0[i] + p_up_i[i])\n            p[i] = min(max(lb, p_i0[i]), ub)\n            total_output += p[i]\n    \n    deficit = load - total_output\n    \n    while deficit > 1e-5:\n        candidate_online = []\n        candidate_offline = []\n        \n        for i in range(n_units):\n            if u[i] == 1:\n                if started_now[i] or u_i0[i] == 0:\n                    max_power = min(p_max_i[i], p_start_i[i])\n                else:\n                    max_power = min(p_max_i[i], p_i0[i] + p_up_i[i])\n                \n                if p[i] < max_power:\n                    marginal_cost = 2 * c_i[i] * p[i] + b_i[i]\n                    candidate_online.append((i, marginal_cost, max_power - p[i]))\n        \n        for i in range(n_units):\n            if not forced_off[i] and u[i] == 0:\n                cost_at_min = s_i[i] + a_i[i] + b_i[i] * p_min_i[i] + c_i[i] * p_min_i[i]**2\n                avg_full_cost = cost_at_min / p_min_i[i]\n                candidate_offline.append((i, avg_full_cost, p_min_i[i]))\n        \n        best_online = min(candidate_online, key=lambda x: x[1]) if candidate_online else None\n        best_offline = min(candidate_offline, key=lambda x: x[1]) if candidate_offline else None\n        \n        if best_online is None and best_offline is None:\n            break\n        \n        if best_online and best_offline:\n            action = 'online' if best_online[1] <= best_offline[1] else 'offline'\n        else:\n            action = 'online' if best_online else 'offline'\n        \n        if action == 'online':\n            i, mc, available = best_online\n            increase = min(deficit, available)\n            p[i] += increase\n            total_output += increase\n            deficit -= increase\n        else:\n            i, afc, min_p = best_offline\n            u[i] = 1\n            started_now[i] = True\n            output_set = min(min_p, p_start_i[i], p_max_i[i])\n            p[i] = output_set\n            total_output += output_set\n            deficit -= output_set\n    \n    if deficit < 0:\n        surplus = -deficit\n    else:\n        surplus = 0.0\n    \n    while surplus > 1e-5:\n        candidate_reduce = []\n        \n        for i in range(n_units):\n            if u[i] == 1:\n                if started_now[i] or u_i0[i] == 0:\n                    min_power = p_min_i[i]\n                else:\n                    min_power = max(p_min_i[i], p_i0[i] - p_down_i[i])\n                \n                if p[i] > min_power:\n                    marginal_cost = 2 * c_i[i] * p[i] + b_i[i]\n                    reduction = p[i] - min_power\n                    candidate_reduce.append((i, marginal_cost, reduction))\n        \n        if not candidate_reduce:\n            break\n        \n        i, mc, reduction = max(candidate_reduce, key=lambda x: x[1])\n        amount = min(surplus, reduction)\n        p[i] -= amount\n        total_output -= amount\n        surplus -= amount\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00073,
          "gap_price_rate": 0.02002,
          "fitness": 0.01037
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp constraints) and forced-off units (must remain offline due to minimum down-time constraints). \n2. Initialize committed units as forced-on units, calculating feasible power ranges considering ramp limits. \n3. If total maximum output is insufficient, turn on free units sorted by average total cost (including startup cost) at minimum output. \n4. Set dispatch target to load clamped between total minimum and maximum feasible output. \n5. Perform economic dispatch using merit order: \n   a. Set all committed units to minimum output. \n   b. Distribute remaining load to units with lowest marginal cost until target is met. \n6. Set non-committed units to offline state with zero output. \n7. Return commitment states and power outputs for all units.\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    u_out = [0] * num_units\n    p_out = [0.0] * num_units\n    min_p_arr = [0.0] * num_units\n    max_p_arr = [0.0] * num_units\n    \n    forced_on = []\n    forced_off = []\n    committed = [False] * num_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:  # Previously online\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on.append(i)\n                committed[i] = True\n        else:  # Previously offline\n            if t_i_0 < 0 and -t_i_0 < t_off_min_i:\n                forced_off.append(i)\n                committed[i] = False\n                \n    # Step 2: Initialize committed units and calculate feasible power ranges\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i, unit in enumerate(units_info):\n        if i in forced_on:\n            u_i_0 = unit['u_i_0']\n            p_i_0 = unit['p_i_0']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            \n            min_p = max(p_min_i, p_i_0 - p_down_i)\n            max_p = min(p_max_i, p_i_0 + p_up_i)\n            \n            min_p_arr[i] = min_p\n            max_p_arr[i] = max_p\n            \n            total_min += min_p\n            total_max += max_p\n        else:\n            min_p_arr[i] = 0.0\n            max_p_arr[i] = 0.0\n\n    # Step 3: Commit free units if additional capacity needed\n    free_units = []\n    for i in range(num_units):\n        if i not in forced_on and i not in forced_off and not committed[i]:\n            free_units.append(i)\n    \n    # Sort free units by average total cost at minimum output\n    free_units.sort(key=lambda i: (units_info[i]['s_i'] + \n                                   units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                                   units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i'])\n    \n    for i in free_units:\n        unit = units_info[i]\n        if total_max < load and not committed[i]:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            \n            min_p_arr[i] = min_p\n            max_p_arr[i] = max_p\n            total_min += min_p\n            total_max += max_p\n            committed[i] = True\n            \n            if total_max >= load:\n                break\n    \n    # Step 4: Set dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Step 5a: Set committed units to their minimum outputs\n    current_total = 0.0\n    for i in range(num_units):\n        if committed[i]:\n            p_out[i] = min_p_arr[i]\n            current_total += min_p_arr[i]\n    \n    # Step 5b: Distribute remaining load by merit order\n    residual = target - current_total\n    active_units = [i for i in range(num_units) if committed[i] and p_out[i] < max_p_arr[i]]\n    \n    while residual > 1e-5 and active_units:\n        # Find unit with lowest marginal cost\n        best_idx = -1\n        best_mc = float('inf')\n        for i in active_units:\n            unit = units_info[i]\n            if unit['c_i'] > 0:\n                mc = unit['b_i'] + 2 * unit['c_i'] * p_out[i]\n            else:\n                mc = unit['b_i']\n            if mc < best_mc:\n                best_mc = mc\n                best_idx = i\n        \n        # Increase output of best unit\n        unit = units_info[best_idx]\n        max_increase = max_p_arr[best_idx] - p_out[best_idx]\n        increase = min(residual, max_increase)\n        p_out[best_idx] += increase\n        residual -= increase\n        \n        if p_out[best_idx] >= max_p_arr[best_idx] - 1e-5:\n            active_units.remove(best_idx)\n    \n    # Set commitment states and outputs\n    for i in range(num_units):\n        u_out[i] = 1 if committed[i] else 0\n        if not committed[i]:\n            p_out[i] = 0.0\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.00717,
          "gap_price_rate": 0.01377,
          "fitness": 0.01047
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Initialize units by copying input data and setting initial commitment states\n2. Enforce must-on and must-off constraints based on minimum up/down times and shutdown capacity\n3. Compute min/max power limits for committed units considering ramp constraints\n4. Calculate total min and max power from committed units\n5. Handle surplus load by turning off expensive non-essential units meeting shutdown ramp constraints\n6. Handle deficit load by starting cheapest available units based on cost per MW at minimum output\n7. Perform economic dispatch using greedy merit-order method to meet load within power limits\n8. Format output schedules as numpy array\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    units = [dict(unit) for unit in units_info]\n    num_units = len(units)\n    \n    # Step 1: Set initial commitment state and enforce constraints\n    for i in range(num_units):\n        units[i]['u_i'] = units[i]['u_i_0']\n        if units[i]['u_i_0'] == 1:\n            if units[i]['t_i_0'] < units[i]['t_on_min_i'] or units[i]['p_i_0'] > units[i]['p_shut_i']:\n                units[i]['u_i'] = 1\n        elif units[i]['u_i_0'] == 0:\n            if -units[i]['t_i_0'] < units[i]['t_off_min_i']:\n                units[i]['u_i'] = 0\n    \n    # Initialize min_power and max_power\n    for i in range(num_units):\n        units[i]['min_power'] = 0\n        units[i]['max_power'] = 0\n    \n    # Calculate min and max power for committed units\n    total_min_power = 0\n    total_max_power = 0\n    for i in range(num_units):\n        if units[i]['u_i'] == 1:\n            if units[i]['u_i_0'] == 1:\n                min_p = max(units[i]['p_min_i'], units[i]['p_i_0'] - units[i]['p_down_i'])\n                max_p = min(units[i]['p_max_i'], units[i]['p_i_0'] + units[i]['p_up_i'])\n            else:\n                min_p = units[i]['p_min_i']\n                max_p = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            units[i]['min_power'] = min_p\n            units[i]['max_power'] = max_p\n            total_min_power += min_p\n            total_max_power += max_p\n    \n    # Step 5: Handle surplus (load < total_min_power)\n    if load < total_min_power:\n        surplus_units = []\n        for i in range(num_units):\n            if units[i]['u_i'] == 1:\n                forced_on = (units[i]['u_i_0'] == 1 and \n                            (units[i]['t_i_0'] < units[i]['t_on_min_i'] or units[i]['p_i_0'] > units[i]['p_shut_i']))\n                if not forced_on and units[i]['p_i_0'] <= units[i]['p_down_i']:\n                    full_load_cost = units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + units[i]['c_i'] * (units[i]['p_max_i'] ** 2)\n                    avg_cost = full_load_cost / units[i]['p_max_i']\n                    surplus_units.append((i, avg_cost))\n        \n        surplus_units.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, avg_cost in surplus_units:\n            if total_min_power - units[i]['min_power'] <= load:\n                break\n            units[i]['u_i'] = 0\n            total_min_power -= units[i]['min_power']\n            total_max_power -= units[i]['max_power']\n            units[i]['min_power'] = 0\n            units[i]['max_power'] = 0\n    \n    # Recalculate total after turning off units\n    total_min_power = 0\n    total_max_power = 0\n    for i in range(num_units):\n        if units[i]['u_i'] == 1:\n            total_min_power += units[i]['min_power']\n            total_max_power += units[i]['max_power']\n    \n    # Step 6: Handle deficit (load > total_max_power)\n    if load > total_max_power:\n        deficit_units = []\n        for i in range(num_units):\n            if units[i]['u_i'] == 0:\n                forced_off = (units[i]['u_i_0'] == 0 and -units[i]['t_i_0'] < units[i]['t_off_min_i'])\n                if not forced_off:\n                    cost_at_min = units[i]['a_i'] + units[i]['b_i'] * units[i]['p_min_i'] + units[i]['c_i'] * (units[i]['p_min_i'] ** 2)\n                    total_cost = cost_at_min + units[i]['s_i']\n                    cost_per_mw = total_cost / units[i]['p_min_i']\n                    deficit_units.append((i, cost_per_mw))\n        \n        deficit_units.sort(key=lambda x: x[1])\n        \n        for i, cost_per_mw in deficit_units:\n            units[i]['u_i'] = 1\n            min_p = units[i]['p_min_i']\n            max_p = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            units[i]['min_power'] = min_p\n            units[i]['max_power'] = max_p\n            total_min_power += min_p\n            total_max_power += max_p\n            if total_max_power >= load:\n                break\n    \n    # Step 7: Economic dispatch\n    remaining_load = load\n    for i in range(num_units):\n        if units[i]['u_i'] == 1:\n            units[i]['p_i'] = units[i]['min_power']\n            remaining_load -= units[i]['min_power']\n        else:\n            units[i]['p_i'] = 0\n    \n    while remaining_load > 1e-5:\n        min_cost = float('inf')\n        selected = -1\n        for i in range(num_units):\n            if units[i]['u_i'] == 1 and units[i]['p_i'] < units[i]['max_power']:\n                marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * units[i]['p_i']\n                if marginal_cost < min_cost:\n                    min_cost = marginal_cost\n                    selected = i\n        \n        if selected == -1:\n            break\n        \n        increment = min(remaining_load, units[selected]['max_power'] - units[selected]['p_i'])\n        units[selected]['p_i'] += increment\n        remaining_load -= increment\n    \n    # Step 8: Format output\n    u_out = [units[i]['u_i'] for i in range(num_units)]\n    p_out = [units[i]['p_i'] for i in range(num_units)]\n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00013,
          "gap_price_rate": 0.03464,
          "fitness": 0.01739
     }
]