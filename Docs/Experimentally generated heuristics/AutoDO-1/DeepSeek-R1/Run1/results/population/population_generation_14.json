[
     {
          "name": "amortized_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online and either min up-time not met (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previous state offline and min down-time not met (|t_i_0| < t_off_min_i)).\n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]. Compute total min/max generation capacity.\n3. If load exceeds total max generation capacity:\n   a) Identify startable units not forced on/off that satisfy minimum downtime\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Sort startable units by ascending amortized cost\n   d) Commit units in sorted order, updating total capacity and setting new unit bounds to [p_min_i, min(p_max_i, p_start_i)], until capacity >= load\n4. Set dispatch target = max(total_min, min(total_max, load))\n5. Perform economic dispatch via lambda iteration:\n   a) Initialize lambda bounds and use bisection to find optimal lambda\n   b) For each committed unit:\n        - Quadratic units: set p_i = (\u03bb - b_i)/(2*c_i)\n        - Linear units: set p_i = p_min_i if \u03bb < b_i, else p_max_i\n   c) Clamp power to unit's feasible bounds\n   d) Adjust lambda until generation matches target within tolerance\n   e) Apply proportional adjustment for residual load if needed\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n",
          "code": "import numpy as np\n\ndef amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    committed_mask = [False] * n_units\n    low_bounds = [0.0] * n_units\n    high_bounds = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n                committed_mask[i] = True\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2 & 3: Initialize committed units and commit more if needed\n    total_min = sum(low_bounds)\n    total_max = sum(high_bounds)\n    \n    if load > total_max:\n        startable_units = []\n        for i, unit in enumerate(units_info):\n            if not committed_mask[i] and not forced_off[i] and unit['t_off_min_i'] <= abs(unit['t_i_0']):\n                s_i = unit['s_i']\n                t_up_min = unit['t_on_min_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                amortized_cost = (s_i / min(t_up_min, 24) + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                startable_units.append((i, amortized_cost, p_min_i, unit['p_max_i'], unit['p_start_i']))\n        \n        if startable_units:\n            startable_units.sort(key=lambda x: x[1])\n            for unit_data in startable_units:\n                i, _, p_min_i, p_max_i, p_start_i = unit_data\n                new_high = min(p_max_i, p_start_i)\n                if total_max + new_high >= load:\n                    break\n                committed_mask[i] = True\n                low_bounds[i] = p_min_i\n                high_bounds[i] = new_high\n                total_min += p_min_i\n                total_max += new_high\n    \n    # Step 4: Dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if committed_mask[i]]\n    if committed_indices:\n        low_lambda = 0.0\n        high_lambda = 2000.0\n        tol = 0.01\n        max_iter = 1000\n        n_iter = 0\n        lambda_val = (low_lambda + high_lambda) / 2\n        \n        while n_iter < max_iter and abs(high_lambda - low_lambda) > 1e-5:\n            total_p = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                lb = low_bounds[i]\n                ub = high_bounds[i]\n                if unit['c_i'] > 0:\n                    p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = ub if lambda_val > unit['b_i'] else lb\n                p_val = max(lb, min(ub, p_val))\n                total_p += p_val\n            \n            if total_p < target:\n                low_lambda = lambda_val\n            else:\n                high_lambda = lambda_val\n            lambda_val = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Final assignment\n        total_p = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            lb = low_bounds[i]\n            ub = high_bounds[i]\n            if unit['c_i'] > 0:\n                p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = ub if lambda_val > unit['b_i'] else lb\n            p_val = max(lb, min(ub, p_val))\n            total_p += p_val\n            p_i[i] = p_val\n            u_i[i] = 1\n        \n        # Residual adjustment\n        residual = target - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                headrooms = [high_bounds[i] - p_i[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        add = factor * headrooms[idx]\n                        p_i[i] = min(high_bounds[i], p_i[i] + add)\n            else:\n                headrooms = [p_i[i] - low_bounds[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, -residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        p_i[i] = max(low_bounds[i], p_i[i] - factor * headrooms[idx])\n    \n    # Prepare output\n    schedules = np.vstack([np.array(u_i), np.array(p_i)])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00653,
          "gap_price_rate": 0.00537,
          "fitness": 0.00595
     },
     {
          "name": "combined_amortized_decommitment_v2",
          "algorithm": "1. Identify forced-on units (previous state online with insufficient up-time or shutdown ramp violation) and forced-off units (previous state offline with insufficient down-time)\n2. Initialize committed units as forced-on units and calculate their ramp-constrained power ranges\n3. If capacity is insufficient:\n   a) Split eligible units into kept-on (previously online) and startable (previously offline) groups\n   b) Calculate kept-on cost as operating cost per MW at min output and startable cost as amortized cost including startup\n   c) Combine groups, sort by cost, and commit units until capacity suffices\n   d) Apply startup ramp limits for new units\n4. Perform decommitment of non-forced committed units in descending cost order if excess capacity\n5. Set dispatch target clamped between total min/max capacity\n6. Perform economic dispatch via lambda iteration respecting ramp constraints, with additional adjustment for linear units\n7. Set non-committed units to offline (0,0)\n",
          "code": "import numpy as np\n\ndef combined_amortized_decommitment_v2(units_info, load):\n    n_units = len(units_info)\n    committed = []\n    free = []\n    forced_on = []\n    forced_off = []\n    \n    # Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_min_on = unit['t_on_min_i']\n        t_min_off = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < t_min_on or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:\n            if abs(t0) < t_min_off:\n                forced_off.append(i)\n            else:\n                free.append(i)\n    \n    # Initialize committed units and calculate total capacity\n    committed = forced_on.copy()\n    total_min, total_max = 0, 0\n    bounds = [None] * n_units\n    \n    for i in committed:\n        unit = units_info[i]\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (low, high)\n        total_min += low\n        total_max += high\n    \n    # Split free units into kept-on and startable\n    kept_on = [i for i in free if units_info[i]['u_i_0'] == 1]\n    startable = [i for i in free if units_info[i]['u_i_0'] == 0]\n    \n    # Amortization period setup\n    AMORTIZE_HOURS = 24\n    \n    # Calculate costs for unit selection\n    unit_costs = []\n    for i in kept_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_per_mw = base_cost / p_min\n        unit_costs.append((cost_per_mw, i, 'kept'))\n    \n    for i in startable:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        amortized_startup = unit['s_i'] / min(unit['t_on_min_i'], AMORTIZE_HOURS)\n        base_cost = amortized_startup + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_per_mw = base_cost / p_min\n        unit_costs.append((cost_per_mw, i, 'start'))\n    \n    unit_costs.sort(key=lambda x: x[0])\n    \n    # Commit additional units if needed\n    new_committed = []\n    for cost, i, unit_type in unit_costs:\n        if total_max >= load:\n            break\n            \n        if unit_type == 'kept':\n            unit = units_info[i]\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit = units_info[i]\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if low > high:\n            continue\n            \n        bounds[i] = (low, high)\n        total_min += low\n        total_max += high\n        committed.append(i)\n        new_committed.append(i)\n    \n    # Decommitment: remove non-forced units if possible\n    nf_committed = [i for i in committed if i not in forced_on]\n    decommit_costs = []\n    \n    for i in nf_committed:\n        low, high = bounds[i]\n        if i in kept_on:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n            cost_per_mw = base_cost / p_min\n        else:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n            cost_per_mw = (unit['s_i'] + base_cost) / p_min\n        decommit_costs.append((cost_per_mw, i))\n    \n    decommit_costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in decommit_costs:\n        low, high = bounds[i]\n        if (total_min - low) <= load and (total_max - high) >= load:\n            total_min -= low\n            total_max -= high\n            committed.remove(i)\n            bounds[i] = None\n    \n    # Calculate dispatch target\n    dispatch_target = max(total_min, min(load, total_max))\n    \n    # Economic dispatch via lambda iteration\n    p_values = np.zeros(n_units)\n    lambda_low, lambda_high = 0, 100000\n    tol = 1e-6\n    max_iter = 1000\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        linear_units = []\n        \n        for i in committed:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            p_low, p_high = bounds[i]\n            \n            if c > tol:  # Quadratic unit\n                p_uncon = (lambda_mid - b) / (2 * c)\n                p_val = max(p_low, min(p_high, p_uncon))\n                p_values[i] = p_val\n                total_gen += p_val\n            else:  # Linear unit\n                if lambda_mid < b:\n                    p_values[i] = p_low\n                    total_gen += p_low\n                else:\n                    p_values[i] = p_high\n                    total_gen += p_high\n                linear_units.append(i)\n        \n        if abs(total_gen - dispatch_target) < tol:\n            break\n        elif total_gen < dispatch_target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Additional adjustment for linear units\n    residual = dispatch_target - total_gen\n    if abs(residual) > tol and linear_units:\n        for i in linear_units:\n            if abs(residual) < tol:\n                break\n            p_low, p_high = bounds[i]\n            b = units_info[i]['b_i']\n            delta = min(abs(residual), p_high - p_low) * np.sign(residual)\n            if (p_values[i] == p_low and delta > 0) or (p_values[i] == p_high and delta < 0):\n                p_values[i] += delta\n                residual -= delta\n    \n    # Prepare output arrays\n    u_out = np.array([1 if i in committed else 0 for i in range(n_units)])\n    p_out = np.array([p_values[i] if i in committed else 0.0 for i in range(n_units)])\n    \n    return np.vstack((u_out, p_out))",
          "from": "crossover",
          "gap_power_rate": 0.00506,
          "gap_price_rate": 0.00885,
          "fitness": 0.00695
     },
     {
          "name": "refined_amortized_commitment_v1",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_amortized_commitment_v1(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    n_units = len(units)\n    forced_on = []\n    forced_off = []\n    free = []\n\n    for i, unit in enumerate(units):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free.append(i)\n\n    for i in forced_on:\n        unit = units[i]\n        unit['committed'] = True\n        unit['low_bound'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['high_bound'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n\n    for i in forced_off:\n        unit = units[i]\n        unit['committed'] = False\n        unit['low_bound'] = unit['high_bound'] = 0.0\n\n    kepton = [i for i in free if units[i]['u_i_0'] == 1]\n    startable = [i for i in free if units[i]['u_i_0'] == 0]\n\n    for i in kepton:\n        unit = units[i]\n        pmin = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        unit['cost_per_mw'] = (a + b * pmin + c * pmin**2) / pmin\n\n    for i in startable:\n        unit = units[i]\n        pmin = unit['p_min_i']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        amortized_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n        unit['cost_per_mw'] = (amortized_startup + a + b * pmin + c * pmin**2) / pmin\n\n    free_sorted = sorted(free, key=lambda i: units[i]['cost_per_mw'])\n\n    total_min = sum(units[i]['low_bound'] for i in range(n_units) if units[i].get('committed', False))\n    total_max = sum(units[i]['high_bound'] for i in range(n_units) if units[i].get('committed', False))\n\n    if total_max < load:\n        for i in free_sorted:\n            if total_max >= load:\n                break\n            unit = units[i]\n            if not unit.get('committed', False):\n                unit['committed'] = True\n                if unit['u_i_0'] == 1:\n                    unit['low_bound'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                    unit['high_bound'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    unit['low_bound'] = unit['p_min_i']\n                    unit['high_bound'] = min(unit['p_max_i'], unit['p_start_i'])\n                total_min += unit['low_bound']\n                total_max += unit['high_bound']\n\n    non_forced_committed = [i for i in range(n_units) if units[i].get('committed', False) and i not in forced_on]\n    if total_max > load and non_forced_committed:\n        non_forced_sorted = sorted(non_forced_committed, key=lambda i: units[i]['cost_per_mw'], reverse=True)\n        for i in non_forced_sorted:\n            if units[i].get('committed', False):\n                temp_max = total_max - units[i]['high_bound']\n                if temp_max >= load:\n                    units[i]['committed'] = False\n                    total_min -= units[i]['low_bound']\n                    total_max = temp_max\n                    units[i]['low_bound'] = units[i]['high_bound'] = 0.0\n\n    total_min = sum(units[i]['low_bound'] for i in range(n_units) if units[i].get('committed', False))\n    total_max = sum(units[i]['high_bound'] for i in range(n_units) if units[i].get('committed', False))\n    dispatch_target = max(total_min, min(total_max, load))\n\n    committed_indices = [i for i in range(n_units) if units[i].get('committed', False)]\n    if not committed_indices:\n        schedules = np.zeros((2, n_units))\n        for i, unit in enumerate(units):\n            unit['p_i'] = 0.0\n            unit['u_i'] = 0\n            schedules[0, i], schedules[1, i] = unit['u_i'], unit['p_i']\n        return schedules\n\n    min_marg = float('inf')\n    max_marg = float('-inf')\n    for i in committed_indices:\n        unit = units[i]\n        if unit['c_i'] > 0:\n            marg_min = unit['b_i'] + 2 * unit['c_i'] * unit['low_bound']\n            marg_max = unit['b_i'] + 2 * unit['c_i'] * unit['high_bound']\n        else:\n            marg_min = marg_max = unit['b_i']\n        min_marg = min(min_marg, marg_min)\n        max_marg = max(max_marg, marg_max)\n\n    lambda_min = min_marg - 1\n    lambda_max = max_marg + 1\n    total_gen = 0.0\n    tol = 0.1\n\n    for _ in range(1000):\n        lambda_mid = (lambda_min + lambda_max) / 2\n        total_gen = 0.0\n        for i in committed_indices:\n            unit = units[i]\n            if unit['c_i'] > 0:\n                p_i = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(unit['low_bound'], min(unit['high_bound'], p_i))\n            else:\n                p_i = unit['low_bound'] if lambda_mid < unit['b_i'] else unit['high_bound']\n            unit['p_temp'] = p_i\n            total_gen += p_i\n        \n        diff = total_gen - dispatch_target\n        if abs(diff) < tol:\n            break\n        if diff < 0:\n            lambda_min = lambda_mid\n        else:\n            lambda_max = lambda_mid\n\n    residual = dispatch_target - total_gen\n    if abs(residual) > tol:\n        if residual > 0:\n            candidates = []\n            for i in committed_indices:\n                unit = units[i]\n                if unit['p_temp'] < unit['high_bound'] - 1e-5:\n                    if unit['c_i'] > 0:\n                        marg = unit['b_i'] + 2 * unit['c_i'] * unit['p_temp']\n                    else:\n                        marg = unit['b_i']\n                    candidates.append((marg, i))\n            candidates.sort(key=lambda x: x[0])\n            rem_res = residual\n            for marg, i in candidates:\n                if rem_res <= 0:\n                    break\n                add = min(rem_res, units[i]['high_bound'] - units[i]['p_temp'])\n                units[i]['p_temp'] += add\n                rem_res -= add\n        else:\n            res_abs = abs(residual)\n            candidates = []\n            for i in committed_indices:\n                unit = units[i]\n                if unit['p_temp'] > unit['low_bound'] + 1e-5:\n                    if unit['c_i'] > 0:\n                        marg = unit['b_i'] + 2 * unit['c_i'] * unit['p_temp']\n                    else:\n                        marg = unit['b_i']\n                    candidates.append((marg, i))\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            rem_res = res_abs\n            for marg, i in candidates:\n                if rem_res <= 0:\n                    break\n                reduce_by = min(rem_res, units[i]['p_temp'] - units[i]['low_bound'])\n                units[i]['p_temp'] -= reduce_by\n                rem_res -= reduce_by\n\n    for i in range(n_units):\n        if units[i].get('committed', False):\n            units[i]['p_i'] = units[i]['p_temp']\n            units[i]['u_i'] = 1\n        else:\n            units[i]['p_i'] = 0.0\n            units[i]['u_i'] = 0\n\n    schedules = np.zeros((2, n_units))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n        \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00507,
          "gap_price_rate": 0.00885,
          "fitness": 0.00696
     },
     {
          "name": "refined_adaptive_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                forced_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                forced_off.append(i)\n                \n    committed = set(forced_on)\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        min_output[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n        max_output[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        total_min += min_output[i]\n        total_max += max_output[i]\n        \n    candidates = []\n    \n    for i in range(n):\n        if i in committed or i in forced_off:\n            continue\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            adjusted_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            candidates.append((i, adjusted_cost, 'A', min_bound, max_bound))\n        else:\n            adjusted_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, adjusted_cost, 'B', min_bound, max_bound))\n            \n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        \n    for i, cost, typ, min_b, max_b in candidates:\n        if total_max >= load:\n            break\n        committed.add(i)\n        min_output[i] = min_b\n        max_output[i] = max_b\n        total_min += min_b\n        total_max += max_b\n        \n    dispatch_target = load\n    if total_min >= total_max:\n        dispatch_target = total_min\n    else:\n        if dispatch_target < total_min:\n            dispatch_target = total_min\n        elif dispatch_target > total_max:\n            dispatch_target = total_max\n            \n    p_dispatch = [0.0] * n\n    if committed:\n        low_lambda = 0.0\n        high_lambda = 10000.0\n        tol = 0.01\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = min_output[i]\n                p_max_i = max_output[i]\n                \n                if c_i == 0:\n                    if mid_lambda <= b_i:\n                        power = p_min_i\n                    else:\n                        power = p_max_i\n                else:\n                    unconstrained = (mid_lambda - b_i) / (2 * c_i)\n                    if unconstrained < p_min_i:\n                        power = p_min_i\n                    elif unconstrained > p_max_i:\n                        power = p_max_i\n                    else:\n                        power = unconstrained\n                p_dispatch[i] = power\n                total_power += power\n                \n            if abs(total_power - dispatch_target) <= tol:\n                break\n                \n            if total_power < dispatch_target:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n                \n    u_final = [0] * n\n    p_final = [0.0] * n\n    for i in range(n):\n        if i in committed:\n            u_final[i] = 1\n            p_final[i] = p_dispatch[i]\n            \n    return np.array([u_final, p_final])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "amortized_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previously online and either minimum up-time unsatisfied (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previously offline and minimum down-time unsatisfied (abs(t_i_0) < t_off_min_i)).\n2. Initialize committed units as forced-on units. Compute feasible power ranges:\n   - Forced-on units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Calculate total minimum/maximum generation capacity\n3. If load exceeds total maximum capacity:\n   a) Identify startable units not forced on/off and meeting minimum down-time\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Commit units by ascending amortized cost order until capacity >= load\n   d) Set new unit ranges: [p_min_i, min(p_max_i, p_start_i)]\n4. Set dispatch target to load clamped between updated total min/max capacity\n5. Perform lambda iteration for economic dispatch:\n   a) Initialize lambda bounds based on marginal costs\n   b) For each unit, compute unconstrained power using unit-specific cost function\n   c) Clamp power to unit's feasible range based on operational history\n   d) Adjust lambda via bisection until generation matches target within tolerance\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef amortized_refined_adaptive_commitment(units_info, load):\n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    committed_indices = []\n    \n    # Identify forced on/off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Previously online\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                forced_on_indices.append(idx)\n            else:\n                free_indices.append(idx)\n        else:  # Previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off_indices.append(idx)\n            else:\n                free_indices.append(idx)\n    \n    # Initialize committed units to forced-on units\n    committed_indices = forced_on_indices.copy()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Set power ranges and calculate total capacity for committed units\n    for idx in committed_indices:\n        unit = units_info[idx]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        total_min += lb\n        total_max += ub\n    \n    # Commit additional units if capacity insufficient\n    if total_max < load:\n        candidate_units = []\n        for idx in free_indices:\n            unit = units_info[idx]\n            p_min_i = unit['p_min_i']\n            # Calculate amortized startup cost (spread over min up-time capped at 24h)\n            amort_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n            # Calculate adjusted cost per MW at minimum output\n            adj_cost = (amort_startup + unit['a_i'] + unit['b_i']*p_min_i + unit['c_i']*p_min_i**2) / p_min_i\n            candidate_units.append((adj_cost, idx, unit))\n        \n        # Sort by ascending adjusted cost\n        candidate_units.sort(key=lambda x: x[0])\n        \n        # Commit units until capacity meets demand\n        for _, idx, unit in candidate_units:\n            if total_max >= load:\n                break\n            committed_indices.append(idx)\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            unit['lb'] = lb\n            unit['ub'] = ub\n            total_min += lb\n            total_max += ub\n            free_indices.remove(idx)\n    \n    # Calculate dispatch target\n    target = max(total_min, min(load, total_max))\n    \n    # Lambda iteration for economic dispatch\n    tol = 0.1  # MW tolerance\n    max_iter = 1000\n    iter_count = 0\n    lambda_low = 0.0\n    lambda_high = 0.0\n    \n    # Initialize lambda bounds based on marginal costs\n    for idx in committed_indices:\n        unit = units_info[idx]\n        # Consider marginal cost at bounds\n        if unit['c_i'] != 0:\n            mc_min = 2*unit['c_i']*unit['lb'] + unit['b_i']\n            mc_max = 2*unit['c_i']*unit['ub'] + unit['b_i']\n        else:  # Linear cost\n            mc_min = mc_max = unit['b_i']\n        lambda_low = min(lambda_low, mc_min)\n        lambda_high = max(lambda_high, mc_max)\n    \n    # Expand bounds conservatively\n    lambda_low = max(0, lambda_low - 100)\n    lambda_high += 100\n    \n    # Bisection loop\n    while iter_count < max_iter:\n        total_gen = 0.0\n        lambda_mid = (lambda_low + lambda_high) / 2\n        \n        for idx in committed_indices:\n            unit = units_info[idx]\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            # Calculate unconstrained dispatch\n            if unit['c_i'] != 0:  # Quadratic cost\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                # Clamp to feasible range\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:  # Linear cost\n                # Always operate at bounds based on lambda vs marginal cost\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            total_gen += p_dispatch\n        \n        # Adjust lambda bounds\n        if abs(total_gen - target) < tol:\n            break\n        elif total_gen < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n            \n        iter_count += 1\n    \n    # Final dispatch and set outputs\n    schedules = np.zeros((2, len(units_info)))\n    for idx, unit in enumerate(units_info):\n        if idx in committed_indices:\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            if unit['c_i'] != 0:\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            schedules[0, idx] = 1\n            schedules[1, idx] = p_dispatch\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00792,
          "fitness": 0.00717
     },
     {
          "name": "enhanced_amortized_adaptive_commitment_v2",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time violations or shutdown ramp constraints) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units with forced-on units and set their feasible power ranges using ramp constraints.\n3. If existing capacity is insufficient, identify startable units (non-forced on/off, meeting minimum downtime), calculate amortized cost including startup expenses, and commit units in ascending cost order until capacity meets load, applying startup ramp limits for new units.\n4. Perform decommitment: Identify non-forced-on committed units eligible for shutdown (satisfying ramp down constraints). Calculate operating cost at minimum output, and remove high-cost units in descending order if system capacity remains sufficient without them.\n5. Set dispatch target to load clamped between updated total min/max capacity.\n6. Perform economic dispatch via lambda iteration respecting ramp constraints for existing units, startup ramp limits for new units, and individual unit min/max limits.\n7. Set non-committed units to offline with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = [False] * n\n    forced_off = [False] * n\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on[i] = True\n        elif u0 == 0:\n            if abs(t0) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    low_bound = [0] * n\n    high_bound = [0] * n\n    committed = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Step 2: Initialize with forced-on units\n    for i, unit in enumerate(units_info):\n        if forced_on[i]:\n            low_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            committed.append(i)\n            total_min += low_bound[i]\n            total_max += high_bound[i]\n    \n    # Step 3: Add startable units if capacity insufficient\n    startable = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0_abs = abs(unit['t_i_0'])\n        if not forced_on[i] and not forced_off[i] and u0 == 0 and t0_abs >= unit['t_off_min_i']:\n            startable.append(i)\n    \n    amortized_costs = []\n    for i in startable:\n        unit = units_info[i]\n        t_amort = min(unit['t_on_min_i'], 24)\n        num = (unit['s_i'] / t_amort) + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        amortized_costs.append(num / unit['p_min_i'])\n    \n    sorted_startable = [idx for _, idx in sorted(zip(amortized_costs, startable))]\n    \n    for i in sorted_startable:\n        if total_max < load:\n            low_i = units_info[i]['p_min_i']\n            high_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            low_bound[i] = low_i\n            high_bound[i] = high_i\n            committed.append(i)\n            total_min += low_i\n            total_max += high_i\n    \n    # Step 4: Decommit non-forced-on units if possible\n    changed = True\n    while changed and len(committed) > 0:\n        changed = False\n        decommit_candidates = []\n        op_costs = []\n        for i in committed:\n            if forced_on[i]:\n                continue\n            unit = units_info[i]\n            eligible = False\n            if unit['u_i_0'] == 0:\n                eligible = True\n            elif unit['u_i_0'] == 1 and unit['p_i_0'] <= unit['p_down_i']:\n                eligible = True\n            if eligible:\n                decommit_candidates.append(i)\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n                op_costs.append(cost)\n        \n        if not decommit_candidates:\n            break\n        \n        sorted_indices = [idx for _, idx in sorted(zip(op_costs, decommit_candidates), reverse=True)]\n        \n        for i in sorted_indices:\n            new_min = total_min - low_bound[i]\n            new_max = total_max - high_bound[i]\n            if new_min <= load <= new_max:\n                committed.remove(i)\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n    \n    # Step 5: Set dispatch target\n    dispatch_target = np.clip(load, total_min, total_max)\n    \n    # Step 6: Economic dispatch via lambda iteration\n    p_outputs = [0.0] * n\n    if not committed:\n        return np.zeros((2, n))\n    \n    n_committed = len(committed)\n    lambda_low = 0.0\n    lambda_high = 10000.0\n    tolerance = 0.1\n    max_iter = 1000\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0.0\n        temp_outputs = []\n        \n        for idx in committed:\n            unit = units_info[idx]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            low_i = low_bound[idx]\n            high_i = high_bound[idx]\n            \n            if c_i > 0:\n                p_val = (lambda_mid - b_i) / (2 * c_i)\n                p_val = max(low_i, min(high_i, p_val))\n            else:\n                if lambda_mid < b_i:\n                    p_val = low_i\n                else:\n                    p_val = high_i\n            total_power += p_val\n            temp_outputs.append(p_val)\n        \n        if abs(total_power - dispatch_target) <= tolerance:\n            for j, idx in enumerate(committed):\n                p_outputs[idx] = temp_outputs[j]\n            break\n        \n        if total_power < dispatch_target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        for idx in committed:\n            unit = units_info[idx]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            low_i = low_bound[idx]\n            high_i = high_bound[idx]\n            if c_i > 0:\n                p_val = (lambda_high - b_i) / (2 * c_i)\n                p_val = max(low_i, min(high_i, p_val))\n            else:\n                p_val = high_i if lambda_high >= b_i else low_i\n            p_outputs[idx] = p_val\n    \n    # Step 7: Set schedules\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = p_outputs[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00802,
          "fitness": 0.00722
     }
]