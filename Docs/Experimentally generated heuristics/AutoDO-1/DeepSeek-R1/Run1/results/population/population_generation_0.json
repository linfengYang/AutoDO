[
     {
          "name": "greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00917,
          "fitness": 0.00748
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify mandatory on units based on previous state, min up time, and shutdown constraints.\n2. Identify mandatory off units based on min down time constraints.\n3. Compute feasible power ranges for mandatory on units considering ramp limits.\n4. If load is below mandatory units' total min output, set mandatory units to min output.\n5. If load is within mandatory units' output range, dispatch mandatory units economically.\n6. If load exceeds mandatory capacity, turn on discretionary units in cost-effective order.\n7. Dispatch all committed units to meet load as closely as possible while minimizing cost.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    # Initialize unit parameters\n    n = len(units_info)\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    u_i0 = [u['u_i_0'] for u in units_info]\n    p_i0 = [u['p_i_0'] for u in units_info]\n    t_i0 = [u['t_i_0'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    \n    # Initialize states and outputs\n    u_i = [0] * n\n    p_i = [0] * n\n    min_out = [0] * n\n    max_out = [0] * n\n    \n    # Identify mandatory on and off units\n    mand_on = [False] * n\n    mand_off = [False] * n\n    \n    for i in range(n):\n        if u_i0[i] == 1:\n            if t_i0[i] < t_on_min[i] or p_i0[i] > p_shut[i]:\n                mand_on[i] = True\n                u_i[i] = 1\n        else:\n            if abs(t_i0[i]) < t_off_min[i]:\n                mand_off[i] = True\n                u_i[i] = 0\n    \n    # Set feasible output ranges\n    for i in range(n):\n        if mand_on[i]:\n            min_out[i] = max(p_min[i], p_i0[i] - p_down[i])\n            max_out[i] = min(p_max[i], p_i0[i] + p_up[i])\n        else:\n            min_out[i] = 0\n            max_out[i] = 0\n    \n    # Calculate mandatory capacity\n    mand_min = sum(min_out[i] for i in range(n) if mand_on[i])\n    mand_max = sum(max_out[i] for i in range(n) if mand_on[i])\n    \n    # Case 1: Load below mandatory minimum\n    if load < mand_min:\n        for i in range(n):\n            if mand_on[i]:\n                p_i[i] = min_out[i]\n        return np.array([u_i, p_i])\n    \n    # Case 2: Load within mandatory capacity\n    if load <= mand_max:\n        committed = [i for i in range(n) if mand_on[i]]\n        p_arr = greedy_dispatch(committed, min_out, max_out, a, b, c, load)\n        for idx, i in enumerate(committed):\n            p_i[i] = p_arr[idx]\n        return np.array([u_i, p_i])\n    \n    # Case 3: Load exceeds mandatory capacity - set mandatory to max\n    for i in range(n):\n        if mand_on[i]:\n            p_i[i] = max_out[i]\n    deficit = load - mand_max\n    \n    # Collect available discretionary units\n    avail_units = []\n    for i in range(n):\n        if not mand_on[i] and not mand_off[i]:\n            min_out[i] = p_min[i]\n            max_out[i] = min(p_max[i], p_start[i])\n            startup_cost = s[i] if u_i0[i] == 0 else 0\n            total_cost = startup_cost + a[i] + b[i] * min_out[i] + c[i] * min_out[i]**2\n            if min_out[i] > 0:\n                avg_cost = total_cost / min_out[i]\n            else:\n                total_cost = startup_cost + a[i] + b[i] * max_out[i] + c[i] * max_out[i]**2\n                avg_cost = total_cost / max_out[i] if max_out[i] > 0 else float('inf')\n            avail_units.append((i, avg_cost, min_out[i]))\n    \n    # Sort by average cost\n    avail_units.sort(key=lambda x: x[1])\n    committed = [i for i in range(n) if mand_on[i]]\n    \n    # Add discretionary units until deficit covered or no more available\n    total_max = mand_max\n    for unit in avail_units:\n        i, _, _ = unit\n        u_i[i] = 1\n        committed.append(i)\n        total_max += max_out[i]\n        deficit = load - total_max\n        if total_max >= load:\n            break\n    \n    # Dispatch all committed units\n    p_arr = greedy_dispatch(committed, min_out, max_out, a, b, c, load)\n    for idx, i in enumerate(committed):\n        p_i[i] = p_arr[idx]\n    \n    return np.array([u_i, p_i])\n\ndef greedy_dispatch(units, min_out, max_out, a, b, c, target_load):\n    n = len(units)\n    p = [min_out[i] for i in units]\n    current_total = sum(p)\n    \n    while current_total < target_load:\n        best_idx = None\n        best_mc = float('inf')\n        for j in range(n):\n            i = units[j]\n            if p[j] < max_out[i]:\n                mc = 2 * c[i] * p[j] + b[i]\n                if mc < best_mc:\n                    best_mc = mc\n                    best_idx = j\n        \n        if best_idx is None:\n            break\n        \n        i = units[best_idx]\n        increase = min(max_out[i] - p[best_idx], target_load - current_total)\n        p[best_idx] += increase\n        current_total += increase\n    \n    return p",
          "from": null,
          "gap_power_rate": 0.0064,
          "gap_price_rate": 0.01046,
          "fitness": 0.00843
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify forced-on units based on minimum up-time constraints and shutdown capacity limitations\n2. Set forced-off units to offline state\n3. Initialize unit outputs to minimum levels for forced-on units\n4. Calculate power deficit (load - current total output)\n5. While deficit remains:\n   a. Find online units with available capacity to increase output\n   b. Find offline units eligible to start\n   c. Select unit with lowest marginal cost (online) or average cost (offline)\n   d. Increase output of selected online unit or start offline unit at minimum capacity\n6. Calculate power surplus (negative deficit)\n7. While surplus remains:\n   a. Find online units that can reduce output below current levels\n   b. Select unit with highest marginal cost\n   c. Reduce output by maximum possible amount\n8. Return commitment and output schedules as a 2D numpy array\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    n_units = len(units_info)\n    current_u = np.zeros(n_units, dtype=int)\n    current_p = np.zeros(n_units)\n    forced_on = []\n    forced_off = []\n\n    # Identify forced on/off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    # Initialize states and outputs\n    for i in forced_on:\n        current_u[i] = 1\n        prev_out = units_info[i]['p_i_0']\n        ramp_min = prev_out - units_info[i]['p_down_i']\n        current_p[i] = max(units_info[i]['p_min_i'], ramp_min)\n    \n    for i in forced_off:\n        current_u[i] = 0\n        current_p[i] = 0.0\n    \n    # Calculate initial deficit\n    total_output = sum(current_p)\n    deficit = load - total_output\n    tol = 1e-5\n    \n    # Handle deficit\n    while deficit > tol:\n        best_online_idx = None\n        best_online_mc = float('inf')\n        best_online_inc = 0.0\n        best_offline_idx = None\n        best_offline_avg_cost = float('inf')\n        best_offline_min_p = 0.0\n        \n        # Find best online unit to increase\n        for i, unit in enumerate(units_info):\n            if current_u[i] == 1:  # Unit is online\n                if unit['u_i_0'] == 1:  # Was previously online\n                    max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:  # Was started this period\n                    max_out = min(unit['p_max_i'], unit['p_start_i'])\n                \n                if current_p[i] < max_out - tol:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p[i]\n                    inc_possible = min(deficit, max_out - current_p[i])\n                    if marginal_cost < best_online_mc and inc_possible > tol:\n                        best_online_mc = marginal_cost\n                        best_online_idx = i\n                        best_online_inc = inc_possible\n        \n        # Find best offline unit to start\n        for i, unit in enumerate(units_info):\n            if current_u[i] == 0 and i not in forced_off:\n                min_p = unit['p_min_i']\n                avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + \n                            unit['c_i'] * min_p**2) / min_p\n                if avg_cost < best_offline_avg_cost:\n                    best_offline_avg_cost = avg_cost\n                    best_offline_idx = i\n                    best_offline_min_p = min_p\n        \n        # Apply best option\n        if best_online_idx is not None and best_offline_idx is not None:\n            if best_online_mc <= best_offline_avg_cost:\n                current_p[best_online_idx] += best_online_inc\n                deficit -= best_online_inc\n            else:\n                current_u[best_offline_idx] = 1\n                current_p[best_offline_idx] = best_offline_min_p\n                deficit -= best_offline_min_p\n        elif best_online_idx is not None:\n            current_p[best_online_idx] += best_online_inc\n            deficit -= best_online_inc\n        elif best_offline_idx is not None:\n            current_u[best_offline_idx] = 1\n            current_p[best_offline_idx] = best_offline_min_p\n            deficit -= best_offline_min_p\n        else:\n            break  # No feasible solution\n    \n    # Handle surplus\n    surplus = -deficit\n    while surplus > tol:\n        best_reduce_idx = None\n        best_reduce_mc = -1\n        best_reduce_amount = 0.0\n        \n        for i, unit in enumerate(units_info):\n            if current_u[i] == 1:\n                if unit['u_i_0'] == 1:\n                    min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                else:\n                    min_p = unit['p_min_i']\n                \n                if current_p[i] > min_p + tol:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_p[i]\n                    reduce_possible = min(surplus, current_p[i] - min_p)\n                    if marginal_cost > best_reduce_mc and reduce_possible > tol:\n                        best_reduce_mc = marginal_cost\n                        best_reduce_idx = i\n                        best_reduce_amount = reduce_possible\n        \n        if best_reduce_idx is not None:\n            current_p[best_reduce_idx] -= best_reduce_amount\n            surplus -= best_reduce_amount\n        else:\n            break\n    \n    return np.array([current_u, current_p])",
          "from": null,
          "gap_power_rate": 0.00622,
          "gap_price_rate": 0.01074,
          "fitness": 0.00848
     },
     {
          "name": "commit_units_by_rolling_heuristic",
          "algorithm": "1. Initialize units by copying input data and setting initial commitment states\n2. Enforce must-on and must-off constraints based on minimum up/down times and shutdown capacity\n3. Compute min/max power limits for committed units considering ramp constraints\n4. Calculate total min and max power from committed units\n5. Handle surplus load by turning off expensive non-essential units meeting shutdown ramp constraints\n6. Handle deficit load by starting cheapest available units based on cost per MW at minimum output\n7. Perform economic dispatch using greedy merit-order method to meet load within power limits\n8. Format output schedules as numpy array\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_rolling_heuristic(units_info, load):\n    units = [dict(unit) for unit in units_info]\n    num_units = len(units)\n    \n    # Step 1: Set initial commitment state and enforce constraints\n    for i in range(num_units):\n        units[i]['u_i'] = units[i]['u_i_0']\n        if units[i]['u_i_0'] == 1:\n            if units[i]['t_i_0'] < units[i]['t_on_min_i'] or units[i]['p_i_0'] > units[i]['p_shut_i']:\n                units[i]['u_i'] = 1\n        elif units[i]['u_i_0'] == 0:\n            if -units[i]['t_i_0'] < units[i]['t_off_min_i']:\n                units[i]['u_i'] = 0\n    \n    # Initialize min_power and max_power\n    for i in range(num_units):\n        units[i]['min_power'] = 0\n        units[i]['max_power'] = 0\n    \n    # Calculate min and max power for committed units\n    total_min_power = 0\n    total_max_power = 0\n    for i in range(num_units):\n        if units[i]['u_i'] == 1:\n            if units[i]['u_i_0'] == 1:\n                min_p = max(units[i]['p_min_i'], units[i]['p_i_0'] - units[i]['p_down_i'])\n                max_p = min(units[i]['p_max_i'], units[i]['p_i_0'] + units[i]['p_up_i'])\n            else:\n                min_p = units[i]['p_min_i']\n                max_p = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            units[i]['min_power'] = min_p\n            units[i]['max_power'] = max_p\n            total_min_power += min_p\n            total_max_power += max_p\n    \n    # Step 5: Handle surplus (load < total_min_power)\n    if load < total_min_power:\n        surplus_units = []\n        for i in range(num_units):\n            if units[i]['u_i'] == 1:\n                forced_on = (units[i]['u_i_0'] == 1 and \n                            (units[i]['t_i_0'] < units[i]['t_on_min_i'] or units[i]['p_i_0'] > units[i]['p_shut_i']))\n                if not forced_on and units[i]['p_i_0'] <= units[i]['p_down_i']:\n                    full_load_cost = units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + units[i]['c_i'] * (units[i]['p_max_i'] ** 2)\n                    avg_cost = full_load_cost / units[i]['p_max_i']\n                    surplus_units.append((i, avg_cost))\n        \n        surplus_units.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, avg_cost in surplus_units:\n            if total_min_power - units[i]['min_power'] <= load:\n                break\n            units[i]['u_i'] = 0\n            total_min_power -= units[i]['min_power']\n            total_max_power -= units[i]['max_power']\n            units[i]['min_power'] = 0\n            units[i]['max_power'] = 0\n    \n    # Recalculate total after turning off units\n    total_min_power = 0\n    total_max_power = 0\n    for i in range(num_units):\n        if units[i]['u_i'] == 1:\n            total_min_power += units[i]['min_power']\n            total_max_power += units[i]['max_power']\n    \n    # Step 6: Handle deficit (load > total_max_power)\n    if load > total_max_power:\n        deficit_units = []\n        for i in range(num_units):\n            if units[i]['u_i'] == 0:\n                forced_off = (units[i]['u_i_0'] == 0 and -units[i]['t_i_0'] < units[i]['t_off_min_i'])\n                if not forced_off:\n                    cost_at_min = units[i]['a_i'] + units[i]['b_i'] * units[i]['p_min_i'] + units[i]['c_i'] * (units[i]['p_min_i'] ** 2)\n                    total_cost = cost_at_min + units[i]['s_i']\n                    cost_per_mw = total_cost / units[i]['p_min_i']\n                    deficit_units.append((i, cost_per_mw))\n        \n        deficit_units.sort(key=lambda x: x[1])\n        \n        for i, cost_per_mw in deficit_units:\n            units[i]['u_i'] = 1\n            min_p = units[i]['p_min_i']\n            max_p = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            units[i]['min_power'] = min_p\n            units[i]['max_power'] = max_p\n            total_min_power += min_p\n            total_max_power += max_p\n            if total_max_power >= load:\n                break\n    \n    # Step 7: Economic dispatch\n    remaining_load = load\n    for i in range(num_units):\n        if units[i]['u_i'] == 1:\n            units[i]['p_i'] = units[i]['min_power']\n            remaining_load -= units[i]['min_power']\n        else:\n            units[i]['p_i'] = 0\n    \n    while remaining_load > 1e-5:\n        min_cost = float('inf')\n        selected = -1\n        for i in range(num_units):\n            if units[i]['u_i'] == 1 and units[i]['p_i'] < units[i]['max_power']:\n                marginal_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * units[i]['p_i']\n                if marginal_cost < min_cost:\n                    min_cost = marginal_cost\n                    selected = i\n        \n        if selected == -1:\n            break\n        \n        increment = min(remaining_load, units[selected]['max_power'] - units[selected]['p_i'])\n        units[selected]['p_i'] += increment\n        remaining_load -= increment\n    \n    # Step 8: Format output\n    u_out = [units[i]['u_i'] for i in range(num_units)]\n    p_out = [units[i]['p_i'] for i in range(num_units)]\n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00013,
          "gap_price_rate": 0.03464,
          "fitness": 0.01739
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "1. Classify units into must-on (violates min-up time or shutdown ramp), must-off (violates min-down time), and flexible categories.\n2. Initialize commitment: must-on units on, must-off units off, flexible units retain previous state.\n3. If load < min feasible output, turn off flexible units ranked by highest operating cost at min power.\n4. If load > max feasible output, turn on flexible units ranked by AFLC including startup cost amortized at max power.\n5. Dispatch load economically: allocate min power, then distribute remaining load based on ascending marginal cost.\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    num_units = len(units_info)\n    must_on = [False] * num_units\n    must_off = [False] * num_units\n    \n    # Classify must-on and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize sets\n    set_A = [i for i in range(num_units) if must_on[i]]\n    set_B = [i for i in range(num_units) if must_off[i]]\n    set_C = [i for i in range(num_units) if not must_on[i] and not must_off[i]]\n    \n    # Separate set_C into currently on/off\n    set_C_on = [i for i in set_C if units_info[i]['u_i_0'] == 1]\n    set_C_off = [i for i in set_C if units_info[i]['u_i_0'] == 0]\n    \n    # Initialize commitment\n    u = [0] * num_units\n    p_output = [0] * num_units\n    min_limits = [0] * num_units\n    max_limits = [0] * num_units\n    \n    # Set must-on units\n    for i in set_A:\n        u[i] = 1\n        unit = units_info[i]\n        min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Set must-off units to off\n    for i in set_B:\n        u[i] = 0\n    \n    # Initialize flexible units to previous state\n    for i in set_C_on:\n        u[i] = 1\n        unit = units_info[i]\n        min_limits[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_limits[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    for i in set_C_off:\n        u[i] = 0\n        unit = units_info[i]\n        min_limits[i] = unit['p_min_i']\n        max_limits[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Compute current min/max total power\n    min_total = sum(min_limits[i] for i in range(num_units) if u[i] == 1)\n    max_total = sum(max_limits[i] for i in range(num_units) if u[i] == 1)\n    \n    # Adjust commitment for underload\n    if load < min_total:\n        # Rank flexible-on units by cost at min power (descending)\n        cost_list = []\n        for i in set_C_on:\n            if u[i] == 1:\n                unit = units_info[i]\n                cost = unit['a_i'] + unit['b_i'] * min_limits[i] + unit['c_i'] * min_limits[i] ** 2\n                cost_list.append((cost, i))\n        cost_list.sort(key=lambda x: x[0], reverse=True)\n        \n        # Turn off expensive units\n        for cost_val, i in cost_list:\n            if min_total <= load:\n                break\n            min_total -= min_limits[i]\n            u[i] = 0\n            min_limits[i] = 0\n            max_limits[i] = 0\n    \n    # Adjust commitment for overload\n    elif load > max_total:\n        # Rank flexible-off units by AFLC including startup (ascending)\n        aflc_list = []\n        for i in set_C_off:\n            if u[i] == 0:\n                unit = units_info[i]\n                full_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i'] ** 2\n                aflc = full_cost / unit['p_max_i']\n                aflc_list.append((aflc, i))\n        aflc_list.sort(key=lambda x: x[0])\n        \n        # Turn on cheapest units\n        for aflc_val, i in aflc_list:\n            if max_total >= load:\n                break\n            u[i] = 1\n            min_limits[i] = units_info[i]['p_min_i']\n            max_limits[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            min_total += min_limits[i]\n            max_total += max_limits[i]\n    \n    # Dispatch for committed units\n    committed_indices = [i for i in range(num_units) if u[i] == 1]\n    min_vals = [min_limits[i] for i in committed_indices]\n    max_vals = [max_limits[i] for i in committed_indices]\n    min_sum = sum(min_vals)\n    max_sum = sum(max_vals)\n    \n    # Initialize dispatch at minima\n    p_dispatch = min_vals.copy()\n    \n    # Handle under/over load\n    if load <= min_sum:\n        p_dispatch = min_vals\n    elif load >= max_sum:\n        p_dispatch = max_vals\n    else:\n        # Allocate remaining load by marginal cost\n        remaining = load - min_sum\n        while remaining > 0:\n            min_mc = float('inf')\n            candidate_idx = -1\n            for idx, i in enumerate(committed_indices):\n                if p_dispatch[idx] < max_vals[idx]:\n                    unit = units_info[i]\n                    mc = unit['b_i'] + 2 * unit['c_i'] * p_dispatch[idx]\n                    if mc < min_mc:\n                        min_mc = mc\n                        candidate_idx = idx\n            if candidate_idx == -1:\n                break\n            alloc = min(remaining, max_vals[candidate_idx] - p_dispatch[candidate_idx])\n            p_dispatch[candidate_idx] += alloc\n            remaining -= alloc\n    \n    # Assign dispatch values\n    for idx, i in enumerate(committed_indices):\n        p_output[i] = p_dispatch[idx]\n    \n    # Format output\n    schedules = np.zeros((2, num_units))\n    for i in range(num_units):\n        schedules[0, i] = u[i]\n        schedules[1, i] = p_output[i]\n        \n    return schedules",
          "from": null,
          "gap_power_rate": 7e-05,
          "gap_price_rate": 0.03559,
          "fitness": 0.01783
     },
     {
          "name": "adaptive_priority_dispatch",
          "algorithm": "**\n1. Determine must-run units (units that were previously online and either haven't met minimum up-time or whose previous output exceeded shutdown capacity) and must-stay-off units (units that were previously offline and haven't met minimum down-time).\n2. Initialize commitment states for online units (both must-run and non-must-run) as on, and others as off.\n3. Compute feasible power output ranges for committed units considering ramp constraints (current output for units remaining online, startup limits for units turning on).\n4. Check total generation capacity. If insufficient, commit additional offline units sorted by startup cost per MW at minimum output until capacity meets demand.\n5. Perform economic dispatch using lambda iteration to minimize production cost within feasible power ranges while meeting the load.\n6. If residual load remains after lambda iteration, adjust outputs greedily.\n7. Set non-committed units to off with zero output.\n8. Compile the schedule for all units.\n\n**",
          "code": "import numpy as np\n\ndef adaptive_priority_dispatch(units_info, load):\n    n_units = len(units_info)\n    must_run = []\n    must_stay_off = []\n    u_i = [0] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    p_i = [0.0] * n_units\n    \n    # Determine must-run and must-stay-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n                u_i[i] = 1\n            else:\n                u_i[i] = 1\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_stay_off.append(i)\n                u_i[i] = 0\n            else:\n                u_i[i] = 0\n    \n    # Compute feasible power ranges for committed units\n    committed = []\n    for i, unit in enumerate(units_info):\n        if u_i[i] == 1:\n            committed.append(i)\n            if unit['u_i_0'] == 1:\n                min_p_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                min_p[i] = min_p_val\n                max_p[i] = max_p_val\n            else:\n                min_p_val = unit['p_min_i']\n                max_p_val = min(unit['p_max_i'], unit['p_start_i'])\n                min_p[i] = min_p_val\n                max_p[i] = max_p_val\n        else:\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    T_min = sum(min_p[i] for i in committed)\n    T_max = sum(max_p[i] for i in committed)\n    \n    # Commit additional units if capacity is insufficient\n    if T_max < load:\n        candidate_units = []\n        for i, unit in enumerate(units_info):\n            if i not in committed and i not in must_stay_off and unit['u_i_0'] == 0:\n                min_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n                cost_per_mw = min_cost / unit['p_min_i']\n                candidate_units.append((i, cost_per_mw, unit['p_min_i'], min(unit['p_max_i'], unit['p_start_i'])))\n        \n        candidate_units.sort(key=lambda x: x[1])\n        new_committed = committed.copy()\n        for i, cost_per_mw, p_min, p_max_val in candidate_units:\n            if T_max < load:\n                new_committed.append(i)\n                u_i[i] = 1\n                min_p[i] = p_min\n                max_p[i] = p_max_val\n                T_min += p_min\n                T_max += p_max_val\n            else:\n                break\n        committed = new_committed\n    \n    # Prepare units for economic dispatch\n    dispatch_units = []\n    for i in committed:\n        unit = units_info[i]\n        dispatch_units.append({\n            'min_p': min_p[i],\n            'max_p': max_p[i],\n            'b': unit['b_i'],\n            'c': unit['c_i'],\n            'index': i\n        })\n    \n    # Run economic dispatch using lambda iteration\n    def run_economic_dispatch(units, total_load):\n        tol = 1e-2\n        low_lam = min(unit['b'] + 2 * unit['c'] * unit['min_p'] for unit in units)\n        high_lam = max(unit['b'] + 2 * unit['c'] * unit['max_p'] for unit in units)\n        \n        for _ in range(100):\n            mid_lam = (low_lam + high_lam) / 2\n            total_generation = 0\n            for unit in units:\n                p_val = (mid_lam - unit['b']) / (2 * unit['c']) if unit['c'] != 0 else unit['max_p']\n                p_val = max(unit['min_p'], min(p_val, unit['max_p']))\n                unit['temp_p'] = p_val\n                total_generation += p_val\n            \n            if abs(total_generation - total_load) < tol:\n                break\n            if total_generation < total_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        \n        return [unit['temp_p'] for unit in units]\n    \n    dispatch_results = run_economic_dispatch(dispatch_units, load)\n    \n    # Assign dispatch results\n    for i, unit in enumerate(dispatch_units):\n        p_i[unit['index']] = dispatch_results[i]\n    \n    # Greedy adjustment for residual load\n    current_total = sum(p_i)\n    residual = load - current_total\n    tol = 1e-3\n    \n    if abs(residual) > tol:\n        iterations = 100\n        while abs(residual) > tol and iterations > 0:\n            iterations -= 1\n            if residual > 0:\n                candidate = None\n                min_inc_cost = float('inf')\n                for unit in dispatch_units:\n                    idx = unit['index']\n                    if p_i[idx] < unit['max_p']:\n                        inc_cost = unit['b'] + 2 * unit['c'] * p_i[idx]\n                        if inc_cost < min_inc_cost:\n                            min_inc_cost = inc_cost\n                            candidate = idx, unit\n                if candidate is None:\n                    break\n                idx, unit = candidate\n                increment = min(unit['max_p'] - p_i[idx], residual)\n                p_i[idx] += increment\n                current_total += increment\n                residual = load - current_total\n            else:\n                candidate = None\n                max_inc_cost = -float('inf')\n                for unit in dispatch_units:\n                    idx = unit['index']\n                    if p_i[idx] > unit['min_p']:\n                        inc_cost = unit['b'] + 2 * unit['c'] * p_i[idx]\n                        if inc_cost > max_inc_cost:\n                            max_inc_cost = inc_cost\n                            candidate = idx, unit\n                if candidate is None:\n                    break\n                idx, unit = candidate\n                decrement = min(p_i[idx] - unit['min_p'], -residual)\n                p_i[idx] -= decrement\n                current_total -= decrement\n                residual = load - current_total\n    \n    # Set non-committed units\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    schedules = np.array([u_i, p_i])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00013,
          "gap_price_rate": 0.03605,
          "fitness": 0.01809
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "**\n1. **Identify forced units:**\n   - Units must be forced_on if they were online and haven't met minimum up-time or their previous output exceeds shutdown capacity.\n   - Units must be forced_off if they were offline and haven't met minimum down-time.\n   - Remaining units are flexible (free_units), split into free_on (previously online) and free_off (previously offline).\n\n2. **Calculate power bounds:**\n   - Compute total_min and total_max as the sum of minimum and maximum outputs from forced_on and free_on units.\n\n3. **Adjust commitment for load mismatch:**\n   - **If load > total_max:** Turn on free_off units sorted by ascending (cost at min output + startup cost)/MW until load \u2264 total_max.\n   - **If load < total_min:** Turn off free_on units sorted by descending (production cost at min output)/MW until total_min \u2264 load.\n\n4. **Economic dispatch:**\n   - **Committed units:** All forced_on + adjusted free_on units.\n   - **Set bounds per unit:**\n     - If previously online: lb = max(p_min, p_prev - ramp_down), ub = min(p_max, p_prev + ramp_up).\n     - If newly started: lb = p_min, ub = min(p_max, p_start_limit).\n   - **Dispatch steps:**\n     - Initialize all outputs to lower bounds.\n     - Compute deficit as load minus sum of lower bounds.\n     - Sort units by ascending incremental cost (b + 2*c*current_output).\n     - Allocate deficit to units in sorted order until deficit is met or capacity exhausted.\n\n5. **Return schedules:** 2D array with online status and dispatched power for all units.\n\n**",
          "code": "import numpy as np\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    num_units = len(units_info)\n    forced_on = set()\n    forced_off = set()\n    free_units = set()\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1: \n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on.add(i)\n            else:\n                free_units.add(i)\n        else: \n            if -t_i_0 < t_off_min_i: \n                forced_off.add(i)\n            else:\n                free_units.add(i)\n                \n    free_on = [i for i in free_units if units_info[i]['u_i_0'] == 1]\n    free_off = [i for i in free_units if units_info[i]['u_i_0'] == 0]\n    \n    total_min, total_max = 0.0, 0.0\n    for i in list(forced_on) + free_on:\n        total_min += units_info[i]['p_min_i']\n        total_max += units_info[i]['p_max_i']\n    \n    if load > total_max: \n        candidate_list = []\n        for i in free_off:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            p_min = unit['p_min_i']\n            s = unit['s_i']\n            cost_per_mw = (a + b * p_min + c * p_min**2 + s) / p_min\n            candidate_list.append((cost_per_mw, i))\n        candidate_list.sort(key=lambda x: x[0])\n        \n        for cost, idx in candidate_list:\n            if load <= total_max:\n                break\n            unit = units_info[idx]\n            total_min += unit['p_min_i']\n            total_max += unit['p_max_i']\n            free_on.append(idx)\n            free_off.remove(idx)\n            \n    elif load < total_min: \n        candidate_list = []\n        for i in free_on:\n            unit = units_info[i]\n            a = unit['a_i']\n            b = unit['b_i']\n            c = unit['c_i']\n            p_min = unit['p_min_i']\n            cost_per_mw = (a + b * p_min + c * p_min**2) / p_min\n            candidate_list.append((cost_per_mw, i))\n        candidate_list.sort(key=lambda x: -x[0])\n        \n        for cost, idx in candidate_list:\n            if total_min <= load:\n                break\n            unit = units_info[idx]\n            total_min -= unit['p_min_i']\n            total_max -= unit['p_max_i']\n            free_on.remove(idx)\n            free_off.append(idx)\n            \n    committed_indices = forced_on.union(free_on)\n    units_to_dispatch = []\n    current_outputs = []\n    \n    for i in committed_indices:\n        unit = units_info[i]\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        \n        if u_i_0 == 1:\n            lb = max(p_min, p_i_0 - p_down)\n            ub = min(p_max, p_i_0 + p_up)\n        else:\n            lb = p_min\n            ub = min(p_max, p_start)\n        units_to_dispatch.append((lb, ub, i))\n        current_outputs.append(lb)\n    \n    deficit = load - sum(current_outputs)\n    \n    if units_to_dispatch and deficit > 0:\n        inc_cost_list = []\n        for j, (lb, ub, i) in enumerate(units_to_dispatch):\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_outputs[j]\n            inc_cost_list.append((inc_cost, j, ub - current_outputs[j]))\n        inc_cost_list.sort(key=lambda x: x[0])\n        \n        for inc_cost, j, avail in inc_cost_list:\n            if deficit <= 0:\n                break\n            add = min(deficit, avail)\n            current_outputs[j] += add\n            deficit -= add\n    \n    schedules = np.zeros((2, num_units))\n    for idx, (_, _, i) in enumerate(units_to_dispatch):\n        schedules[0, i] = 1\n        schedules[1, i] = current_outputs[idx]\n        \n    return schedules",
          "from": null,
          "gap_power_rate": 0.02314,
          "gap_price_rate": 0.0138,
          "fitness": 0.01847
     },
     {
          "name": "commit_units_by_priority",
          "algorithm": "1. Classify units into three sets: must-run (Set_A) if units must remain on due to min up-time or shutdown constraints, must-off (Set_C) if units cannot be turned on due to min down-time, and adjustable (Set_D) otherwise.\n2. Initialize must-run units to minimum possible output respecting ramp-down limits.\n3. Compute residual load after must-run unit allocation.\n4. If residual load is positive, turn on adjustable units from Set_D prioritized by average production cost at minimum output to meet residual load.\n5. If residual load remains positive, increase output of committed units with available headroom, prioritizing units with lowest marginal cost.\n6. If residual load is negative, decrease output of committed units, prioritizing units with highest marginal cost while respecting ramp-down limits and minimum outputs.\n7. Return commitment status and power output schedules.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units, dtype=float)\n    Set_A = []\n    Set_C = []\n    Set_D = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                Set_A.append(i)\n            else:\n                Set_D.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                Set_C.append(i)\n            else:\n                Set_D.append(i)\n    \n    # Initialize must-run units\n    for i in Set_A:\n        unit = units_info[i]\n        u[i] = 1\n        p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n    \n    total_power = np.sum(p)\n    R = load - total_power\n    \n    # Start additional units if needed\n    def compute_avg_cost(i):\n        unit = units_info[i]\n        return (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + \n                unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n    \n    Set_D_sorted = sorted(Set_D, key=compute_avg_cost)\n    \n    for i in Set_D_sorted:\n        if R <= 0:\n            break\n        unit = units_info[i]\n        if R >= unit['p_min_i']:\n            u[i] = 1\n            p[i] = unit['p_min_i']\n            R -= p[i]\n    \n    # Increase output if residual load remains positive\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    if R > 0:\n        headroom = np.zeros(n_units)\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                headroom_high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                headroom_high = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n            headroom[i] = max(0, headroom_high - p[i])\n        \n        while R > 0 and np.any(headroom > 0):\n            min_mc = float('inf')\n            best_i = -1\n            for i in committed_indices:\n                if headroom[i] > 0:\n                    mc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                    if mc < min_mc:\n                        min_mc = mc\n                        best_i = i\n            \n            if best_i == -1:\n                break\n            \n            dP = min(R, headroom[best_i])\n            p[best_i] += dP\n            R -= dP\n            headroom[best_i] -= dP\n    \n    # Decrease output if overcommitted\n    if R < 0:\n        R_abs = -R\n        low_bound = np.zeros(n_units)\n        reducible = []\n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound[i] = unit['p_min_i']\n            reduction_capacity = max(0, p[i] - low_bound[i])\n            if reduction_capacity > 0:\n                reducible.append(i)\n        \n        while R_abs > 0 and reducible:\n            max_mc = -1\n            best_i = -1\n            for i in reducible:\n                mc = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if mc > max_mc:\n                    max_mc = mc\n                    best_i = i\n            \n            if best_i == -1:\n                break\n            \n            dP = min(R_abs, p[best_i] - low_bound[best_i])\n            p[best_i] -= dP\n            R_abs -= dP\n            if (p[best_i] - low_bound[best_i]) <= 1e-6:\n                reducible.remove(best_i)\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 8e-05,
          "gap_price_rate": 0.09239,
          "fitness": 0.04623
     }
]