[
     {
          "name": "refined_adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online: units that were previously online and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or violate shutdown ramp constraints (p_i_0 > p_shut_i).\n2. Identify forced-off units that must remain offline: units that were previously offline and haven't satisfied minimum down-time (|t_i_0| < t_off_min_i).\n3. Initialize committed units as forced-on units. Calculate feasible power ranges for committed units (ramp-constrained for continuously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]).\n4. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) generation from committed units.\n5. If load exceeds total maximum generation:\n   a. Identify startable units: units not forced-on/off that can be started (satisfy minimum downtime).\n   b. Sort startable units by startup cost-adjusted average cost per MW at minimum output: (s_i + a_i + b_i*p_min_i + c_i*p_min_i**2)/p_min_i.\n   c. Commit units in ascending cost order until generation capacity meets or exceeds load. Newly committed units have output bounds: [p_min_i, min(p_max_i, p_start_i)].\n6. Calculate dispatch target: load clamped between updated total minimum and maximum generation.\n7. Perform economic dispatch using lambda iteration:\n   a. Initialize lambda and bounds. Use bisection to find optimal lambda.\n   b. For each committed unit, calculate unconstrained power: (lambda - b_i)/(2*c_i) if c_i>0. Handle linear costs (c_i=0) based on comparison between b_i and lambda.\n   c. Project power to feasible bounds: continuously online units use ramp constraints, newly committed units use startup ramp limits.\n   d. Adjust lambda until total generation matches target.\n8. Set non-committed units to offline state (u_i=0) with zero output (p_i=0).\n9. Return schedule with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_adaptive_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    u_vector = np.zeros(num_units)\n    p_vector = np.zeros(num_units)\n    committed = set()\n    \n    # Identify forced-on and forced-off units\n    forced_on = set()\n    forced_off = set()\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.add(i)\n        else:  # Previously offline\n            if t_i0 > -t_off_min:  # Not satisfied minimum downtime\n                forced_off.add(i)\n    \n    # Initialize committed units (forced-on)\n    committed = forced_on.copy()\n    for i in committed:\n        u_vector[i] = 1\n    \n    # Calculate total min/max power from committed units\n    total_min = 0\n    total_max = 0\n    power_bounds = {}\n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        # Continuously online: apply ramp constraints\n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        power_bounds[i] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    # Handle insufficient capacity by starting units\n    if total_max < load:\n        # Identify startable units (not forced on/off, currently offline)\n        startable = []\n        for i, unit in enumerate(units_info):\n            if i not in committed and i not in forced_off and unit['u_i_0'] == 0:\n                # Check minimum downtime satisfied (t_off_min_i already considered in forced_off)\n                startable.append(i)\n        \n        # Sort by cost per MW: (s_i + cost at p_min) / p_min\n        startable.sort(key=lambda i: (\n            units_info[i]['s_i'] + \n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i']**2\n        ) / units_info[i]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for i in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            high_bound = min(p_max, p_start)\n            \n            committed.add(i)\n            u_vector[i] = 1\n            power_bounds[i] = (p_min, high_bound)\n            total_min += p_min\n            total_max += high_bound\n    \n    # Calculate dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Initial lambda bounds\n        lambda_low = -10000\n        lambda_high = 10000\n        \n        # Bisection parameters\n        max_iter = 1000\n        tol = 1e-3\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            \n            # Calculate outputs and total power\n            for i in committed:\n                unit = units_info[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                low, high = power_bounds[i]\n                \n                # Quadratic cost function\n                if c != 0:\n                    p_unconstrained = (lambda_mid - b) / (2 * c)\n                    p_i = max(low, min(high, p_unconstrained))\n                # Linear cost function (c=0)\n                else:\n                    p_i = high if b < lambda_mid else low\n                \n                total_power += p_i\n            \n            # Check convergence\n            if abs(total_power - target) < tol:\n                break\n            elif total_power < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            iter_count += 1\n        \n        # Update power outputs\n        for i in committed:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            low, high = power_bounds[i]\n            \n            if c != 0:\n                p_unconstrained = (lambda_mid - b) / (2 * c)\n                p_vector[i] = max(low, min(high, p_unconstrained))\n            else:\n                p_vector[i] = high if b < lambda_mid else low\n    else:\n        # No committed units: set all to zero (if load==0)\n        pass\n    \n    # Set non-committed units to offline and zero output\n    for i in range(num_units):\n        if i not in committed:\n            u_vector[i] = 0\n            p_vector[i] = 0\n    \n    return np.array([u_vector, p_vector])",
          "from": "mutation",
          "gap_power_rate": 0.00632,
          "gap_price_rate": 0.0084,
          "fitness": 0.00736
     },
     {
          "name": "enhanced_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units: units previously online that must remain online due to minimum up-time violations or shutdown ramp constraints.\n2. Identify forced-off units: units previously offline that must remain offline due to minimum down-time constraints.\n3. Set committed units to forced-on units with power bounds constrained by ramp limits.\n4. Calculate total min/max generation from committed units.\n5. If load exceeds total max generation:\n   a. Identify startable units not forced on/off and satisfying minimum downtime.\n   b. Sort startable units by startup cost-adjusted average cost at minimum output.\n   c. Commit units in cost order until generation capacity meets load, using startup ramp constraints for new units.\n6. Set dispatch target as load clamped between updated total min/max generation.\n7. Perform economic dispatch via lambda iteration respecting:\n   a. Ramp constraints for existing units\n   b. Startup ramp limits for new units\n   c. Min/max output constraints\n8. Set non-committed units offline with zero output.\n9. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_adaptive_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    committed = []\n    low_bound = [0.0] * n_units\n    high_bound = [0.0] * n_units\n    u = [0] * n_units\n    p = [0.0] * n_units\n\n    # Identify forced-on and forced-off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # previously online\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                forced_on.append(idx)\n        else:  # previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off.append(idx)\n    \n    # Initialize committed units as forced-on units\n    for idx in forced_on:\n        unit = units_info[idx]\n        p_i_0 = unit['p_i_0']\n        low_bound[idx] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n        high_bound[idx] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        u[idx] = 1\n        committed.append(idx)\n    \n    # Calculate total min/max from committed units\n    total_min = sum(low_bound[idx] for idx in committed)\n    total_max = sum(high_bound[idx] for idx in committed)\n    \n    # Commit additional units if needed\n    if total_max < load:\n        startable = [idx for idx, unit in enumerate(units_info) \n                    if idx not in forced_on and idx not in forced_off and unit['u_i_0'] == 0\n                    and abs(unit['t_i_0']) >= unit['t_off_min_i']]\n        \n        # Sort by cost-adjusted average cost per MW at min output\n        startable.sort(key=lambda idx: (\n            units_info[idx]['s_i'] + units_info[idx]['a_i'] + \n            units_info[idx]['b_i'] * units_info[idx]['p_min_i'] + \n            units_info[idx]['c_i'] * (units_info[idx]['p_min_i'] ** 2)\n        ) / units_info[idx]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for idx in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[idx]\n            low_bound[idx] = unit['p_min_i']\n            high_bound[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            total_min += low_bound[idx]\n            total_max += high_bound[idx]\n            u[idx] = 1\n            committed.append(idx)\n    \n    # Clamp load to feasible generation range\n    dispatch_target = max(total_min, min(total_max, load))\n    \n    # Lambda iteration for economic dispatch\n    if committed:\n        lambda_low = 0\n        lambda_high = 0\n        tolerance = 0.001\n        max_iter = 100\n        \n        # Initialize lambda bounds\n        for idx in committed:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                mc_min = unit['b_i'] + 2 * unit['c_i'] * low_bound[idx]\n                mc_max = unit['b_i'] + 2 * unit['c_i'] * high_bound[idx]\n            else:\n                mc_min = mc_max = unit['b_i']\n            lambda_high = max(lambda_high, mc_max)\n        \n        # Check if all units are linear with zero cost\n        all_zero_cost = all(units_info[idx]['b_i'] == 0 and units_info[idx]['c_i'] == 0 for idx in committed)\n        if all_zero_cost:\n            # Distribute load proportional to capacity\n            remaining = dispatch_target\n            for idx in committed:\n                p[idx] = low_bound[idx]\n                remaining -= p[idx]\n            for idx in committed:\n                extra = min(remaining, high_bound[idx] - low_bound[idx])\n                p[idx] += extra\n                remaining -= extra\n                if remaining <= tolerance:\n                    break\n        else:\n            # Perform bisection\n            for _ in range(max_iter):\n                if lambda_high - lambda_low < tolerance:\n                    break\n                    \n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_power = 0\n                for idx in committed:\n                    unit = units_info[idx]\n                    if unit['c_i'] > 0:\n                        p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                    else:  # Linear case\n                        if lambda_mid < unit['b_i']:\n                            p_uncon = low_bound[idx]\n                        else:\n                            p_uncon = high_bound[idx]\n                    \n                    p_proj = max(low_bound[idx], min(p_uncon, high_bound[idx]))\n                    total_power += p_proj\n                \n                if total_power < dispatch_target:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n            \n            # Calculate final outputs\n            for idx in committed:\n                unit = units_info[idx]\n                if unit['c_i'] > 0:\n                    p_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    if lambda_mid < unit['b_i']:\n                        p_uncon = low_bound[idx]\n                    else:\n                        p_uncon = high_bound[idx]\n                p[idx] = max(low_bound[idx], min(p_uncon, high_bound[idx]))\n    \n    # Set outputs for non-committed units\n    schedules = np.zeros((2, n_units))\n    for idx in range(n_units):\n        schedules[0, idx] = u[idx]\n        schedules[1, idx] = p[idx]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00635,
          "gap_price_rate": 0.00841,
          "fitness": 0.00738
     },
     {
          "name": "greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00917,
          "fitness": 0.00748
     },
     {
          "name": "refined_adaptive_commitment_v1",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online + (min up-time not met or shutdown ramp violation)) and forced-off units that must remain offline (previous state offline + min down-time not met). Initialize committed units as forced-on units.  \n2. Compute feasible power ranges for committed units based on ramp limits: previously online units use [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]; newly committed units use [p_min, min(p_max, p_start)].  \n3. Calculate total min/max generation from committed units. If load exceeds total max:  \n   a) Sort eligible offline units by startup-adjusted cost: (s_i + a_i + b_i\u00b7p_min + c_i\u00b7p_min\u00b2)/p_min  \n   b) Commit lowest-cost units until generation >= load, updating feasible ranges and total capacity  \n4. Set dispatch target = clamp(load, total_min, total_max)  \n5. Perform economic dispatch via lambda iteration with bounds:  \n   a) Compute power for quadratic cost units: p = (\u03bb - b_i)/(2\u00b7c_i) clamped to feasible range  \n   b) For linear cost units: p = p_min if \u03bb < b_i, else p_max  \n   c) Adjust \u03bb via bisection until generation \u2248 target  \n6. Set non-committed units to offline (u=0, p=0)  \n7. Output unit states and power levels  \n\n",
          "code": "import numpy as np  \n\ndef refined_adaptive_commitment_v1(units_info, load):  \n    n_units = len(units_info)  \n    u = np.zeros(n_units, dtype=int)  \n    p = np.zeros(n_units)  \n    low_bounds = np.zeros(n_units)  \n    high_bounds = np.zeros(n_units)  \n    committed = []  \n    \n    # 1. Identify forced-on/forced-off units  \n    forced_on = []  \n    forced_off = []  \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        if u_i0:  \n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:  \n                forced_on.append(i)  \n        else:  \n            if abs(t_i0) < unit['t_off_min_i']:  \n                forced_off.append(i)  \n    \n    # Commit forced-on units  \n    for i in forced_on:  \n        u[i] = 1  \n        committed.append(i)  \n        low_bounds[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])  \n        high_bounds[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])  \n    \n    # Force-off units  \n    for i in forced_off:  \n        u[i] = 0  \n        p[i] = 0  \n    \n    # 2. Initial capacity bounds  \n    total_min = sum(low_bounds[i] for i in committed)  \n    total_max = sum(high_bounds[i] for i in committed)  \n    \n    # 3. Commit additional units if needed  \n    free_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]  \n    if total_max < load:  \n        cost_list = []  \n        for i in free_units:  \n            unit = units_info[i]  \n            min_p = unit['p_min_i']  \n            cost_val = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2) / min_p  \n            cost_list.append((cost_val, i))  \n        \n        cost_list.sort(key=lambda x: x[0])  \n        for _, i in cost_list:  \n            if total_max >= load:  \n                break  \n            u[i] = 1  \n            committed.append(i)  \n            start_bound = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])  \n            low_bounds[i] = units_info[i]['p_min_i']  \n            high_bounds[i] = start_bound  \n            total_min += low_bounds[i]  \n            total_max += high_bounds[i]  \n    \n    # 4. Dispatch target  \n    dispatch_target = max(total_min, min(total_max, load))  \n    \n    # 5. Economic dispatch  \n    if committed:  \n        # Bisection setup  \n        low_lambda, high_lambda = 0, 10**6  \n        tol, max_iter = 1e-3, 1000  \n        iter_count = 0  \n        p_committed = np.zeros(len(committed))  \n        unit_indices = np.array(committed)  \n        cost_factors = [(units_info[i]['b_i'], units_info[i]['c_i'], i) for i in committed]  \n        \n        # Lambda iteration  \n        while abs(high_lambda - low_lambda) > tol and iter_count < max_iter:  \n            mid_lambda = (low_lambda + high_lambda) / 2  \n            total_power = 0  \n            for b, c, idx in cost_factors:  \n                i = np.where(unit_indices == idx)[0][0]  \n                if c > 0:  # Quadratic cost  \n                    unconstrained = (mid_lambda - b) / (2 * c)  \n                    p_committed[i] = np.clip(unconstrained, low_bounds[idx], high_bounds[idx])  \n                else:  # Linear cost  \n                    p_committed[i] = high_bounds[idx] if mid_lambda > b else low_bounds[idx]  \n                total_power += p_committed[i]  \n            \n            if total_power < dispatch_target:  \n                low_lambda = mid_lambda  \n            else:  \n                high_lambda = mid_lambda  \n            iter_count += 1  \n        \n        # Assign computed power  \n        for b, c, idx in cost_factors:  \n            i = np.where(unit_indices == idx)[0][0]  \n            p[idx] = p_committed[i]  \n    \n    # 6. Set non-committed units  \n    for i in range(n_units):  \n        if u[i] == 0:  \n            p[i] = 0  \n    \n    return np.vstack((u, p))  ",
          "from": "mutation",
          "gap_power_rate": 0.00586,
          "gap_price_rate": 0.00917,
          "fitness": 0.00751
     },
     {
          "name": "enhanced_greedy_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time constraints or shutdown capacity limitations) and forced-off units (must remain offline due to minimum down-time constraints)  \n2. Set forced-on units to online, compute feasible power ranges respecting ramp limits; set forced-off units to offline  \n3. Calculate total minimum/maximum output from forced-on units  \n4. While total maximum output < load and free units exist, turn on free units sorted by adjusted average cost (including startup cost) at minimum output  \n5. For newly started units, set feasible output range with startup ramp limitations  \n6. Set dispatch target as load clamped between total feasible minimum and maximum outputs  \n7. For committed units, perform economic dispatch via lambda iteration with unit-specific constraints:  \n   - Continuously online units constrained by regular ramp limits  \n   - Newly started units constrained by startup ramp limits  \n8. Return commitment states and power outputs for all units  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_greedy_rolling_commitment(units_info, load):  \n    n_units = len(units_info)  \n    u_schedule = [0] * n_units  \n    p_schedule = [0.0] * n_units  \n    min_feasible = [0.0] * n_units  \n    max_feasible = [0.0] * n_units  \n    committed = [False] * n_units  \n    forced_on_indices = []  \n    forced_off_indices = []  \n    free_indices = []  \n\n    # Classify units based on physical constraints  \n    for i, unit in enumerate(units_info):  \n        u_i0 = unit['u_i_0']  \n        t_i0 = unit['t_i_0']  \n        p_i0 = unit['p_i_0']  \n        if u_i0 == 1:  \n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:  \n                forced_on_indices.append(i)  \n            else:  \n                free_indices.append(i)  \n        else:  \n            if abs(t_i0) < unit['t_off_min_i']:  \n                forced_off_indices.append(i)  \n            else:  \n                free_indices.append(i)  \n\n    # Process forced-off units  \n    for i in forced_off_indices:  \n        committed[i] = False  \n        u_schedule[i] = 0  \n        p_schedule[i] = 0.0  \n        min_feasible[i] = 0.0  \n        max_feasible[i] = 0.0  \n\n    # Process forced-on units  \n    for i in forced_on_indices:  \n        unit = units_info[i]  \n        min_feas = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        max_feas = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        min_feasible[i] = min_feas  \n        max_feasible[i] = max_feas  \n        committed[i] = True  \n        u_schedule[i] = 1  \n\n    # Initial total power calculations  \n    total_min = sum(min_feasible[i] for i in forced_on_indices)  \n    total_max = sum(max_feasible[i] for i in forced_on_indices)  \n\n    # Cost-based unit activation  \n    def calc_criterion(unit):  \n        return (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] +  \n                unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']  \n    free_indices_sorted = sorted(free_indices, key=lambda i: calc_criterion(units_info[i]))  \n\n    new_committed = []  \n    for i in free_indices_sorted:  \n        if total_max < load:  \n            unit = units_info[i]  \n            min_feasible[i] = unit['p_min_i']  \n            max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])  \n            u_schedule[i] = 1  \n            committed[i] = True  \n            new_committed.append(i)  \n            total_min += min_feasible[i]  \n            total_max += max_feasible[i]  \n\n    # Calculate dispatch target  \n    target = min(max(total_min, load), total_max)  \n    committed_indices = forced_on_indices + new_committed  \n\n    # Lambda iteration for economic dispatch  \n    if committed_indices:  \n        b_vec = [units_info[i]['b_i'] for i in committed_indices]  \n        c_vec = [units_info[i]['c_i'] for i in committed_indices]  \n        min_vec = [min_feasible[i] for i in committed_indices]  \n        max_vec = [max_feasible[i] for i in committed_indices]  \n        lo = 0  \n        hi = 1e6  \n        tol = 1e-6  \n        iter_count = 0  \n        max_iter = 100  \n        while abs(hi - lo) > tol and iter_count < max_iter:  \n            mid = (lo + hi) / 2  \n            total_p = 0.0  \n            for idx, (b, c, p_min, p_max) in enumerate(zip(b_vec, c_vec, min_vec, max_vec)):  \n                if c == 0:  \n                    p_val = p_max if mid >= b else p_min  \n                else:  \n                    p_uncon = (mid - b) / (2 * c)  \n                    p_val = max(p_min, min(p_max, p_uncon))  \n                total_p += p_val  \n            if total_p < target:  \n                lo = mid  \n            else:  \n                hi = mid  \n            iter_count += 1  \n        lambda_opt = (lo + hi) / 2  \n        for idx, i in enumerate(committed_indices):  \n            b = b_vec[idx]  \n            c = c_vec[idx]  \n            p_min = min_vec[idx]  \n            p_max = max_vec[idx]  \n            if c == 0:  \n                p_val = p_max if lambda_opt >= b else p_min  \n            else:  \n                p_val = (lambda_opt - b) / (2 * c)  \n                p_val = max(p_min, min(p_max, p_val))  \n            p_schedule[i] = p_val  \n    return np.array([u_schedule, p_schedule])  ",
          "from": "crossover",
          "gap_power_rate": 0.0058,
          "gap_price_rate": 0.00936,
          "fitness": 0.00758
     },
     {
          "name": "adaptive_rolling_commitment",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time constraints or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate total min/max output from committed units accounting for ramp constraints.\n3. If load exceeds maximum available output:\n   - Sort eligible offline units by amortized average cost (startup cost amortized over minimum up-time plus average production cost at minimum output)\n   - Commit units in ascending cost order until sufficient capacity is available\n4. Calculate dispatch target as load clamped between total min and max feasible output.\n5. Perform economic dispatch using lambda iteration to minimize production costs while respecting:\n   - Ramp limits for continuously online units\n   - Startup ramp limits for newly committed units\n   - Minimum/maximum output constraints\n6. Set non-committed units to offline state with zero output.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef adaptive_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    committed = []\n    forced_on = []\n    forced_off = []\n    \n    # Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n    \n    committed = forced_on.copy()\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    \n    # Calculate feasible ranges for forced-on units\n    total_min, total_max = 0.0, 0.0\n    for i in committed:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_outputs[i] = min_output\n        max_outputs[i] = max_output\n        total_min += min_output\n        total_max += max_output\n    \n    # Add offline units if needed\n    candidate_units = [i for i in range(n_units) if i not in forced_on and i not in forced_off]\n    if total_max < load:\n        amortized_costs = []\n        for i in candidate_units:\n            unit = units_info[i]\n            amort_period = max(1, unit['t_on_min_i'])\n            avg_cost = (unit['s_i'] / amort_period + unit['b_i'] * unit['p_min_i'] + \n                        unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n            amortized_costs.append((avg_cost, i))\n        \n        amortized_costs.sort(key=lambda x: x[0])\n        \n        for _, i in amortized_costs:\n            if total_max >= load:\n                break\n            unit = units_info[i]\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            min_outputs[i] = min_out\n            max_outputs[i] = max_out\n            total_min += min_out\n            total_max += max_out\n            committed.append(i)\n    \n    # Calculate dispatch target\n    target = np.clip(load, total_min, total_max)\n    \n    # Lambda iteration for economic dispatch\n    p_alloc = np.zeros(n_units)\n    low_lambda = -1000.0\n    high_lambda = 10000.0\n    tol = 1e-5\n    max_iter = 1000\n    \n    for iter_count in range(max_iter):\n        mid_lambda = (low_lambda + high_lambda) / 2\n        total_power = 0.0\n        \n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                p_alloc[i] = min_outputs[i] if mid_lambda < unit['b_i'] else max_outputs[i]\n            else:\n                p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n            total_power += p_alloc[i]\n        \n        if abs(total_power - target) < tol:\n            break\n        \n        if total_power < target:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = p_alloc[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00644,
          "gap_price_rate": 0.00921,
          "fitness": 0.00782
     }
]