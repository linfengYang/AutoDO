[
     {
          "name": "amortized_rolling_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online and either min up-time not met (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previous state offline and min down-time not met (|t_i_0| < t_off_min_i)).\n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]. Compute total min/max generation capacity.\n3. If load exceeds total max generation capacity:\n   a) Identify startable units not forced on/off that satisfy minimum downtime\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Sort startable units by ascending amortized cost\n   d) Commit units in sorted order, updating total capacity and setting new unit bounds to [p_min_i, min(p_max_i, p_start_i)], until capacity >= load\n4. Set dispatch target = max(total_min, min(total_max, load))\n5. Perform economic dispatch via lambda iteration:\n   a) Initialize lambda bounds and use bisection to find optimal lambda\n   b) For each committed unit:\n        - Quadratic units: set p_i = (\u03bb - b_i)/(2*c_i)\n        - Linear units: set p_i = p_min_i if \u03bb < b_i, else p_max_i\n   c) Clamp power to unit's feasible bounds\n   d) Adjust lambda until generation matches target within tolerance\n   e) Apply proportional adjustment for residual load if needed\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n",
          "code": "import numpy as np\n\ndef amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    committed_mask = [False] * n_units\n    low_bounds = [0.0] * n_units\n    high_bounds = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n                committed_mask[i] = True\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2 & 3: Initialize committed units and commit more if needed\n    total_min = sum(low_bounds)\n    total_max = sum(high_bounds)\n    \n    if load > total_max:\n        startable_units = []\n        for i, unit in enumerate(units_info):\n            if not committed_mask[i] and not forced_off[i] and unit['t_off_min_i'] <= abs(unit['t_i_0']):\n                s_i = unit['s_i']\n                t_up_min = unit['t_on_min_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                amortized_cost = (s_i / min(t_up_min, 24) + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                startable_units.append((i, amortized_cost, p_min_i, unit['p_max_i'], unit['p_start_i']))\n        \n        if startable_units:\n            startable_units.sort(key=lambda x: x[1])\n            for unit_data in startable_units:\n                i, _, p_min_i, p_max_i, p_start_i = unit_data\n                new_high = min(p_max_i, p_start_i)\n                if total_max + new_high >= load:\n                    break\n                committed_mask[i] = True\n                low_bounds[i] = p_min_i\n                high_bounds[i] = new_high\n                total_min += p_min_i\n                total_max += new_high\n    \n    # Step 4: Dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if committed_mask[i]]\n    if committed_indices:\n        low_lambda = 0.0\n        high_lambda = 2000.0\n        tol = 0.01\n        max_iter = 1000\n        n_iter = 0\n        lambda_val = (low_lambda + high_lambda) / 2\n        \n        while n_iter < max_iter and abs(high_lambda - low_lambda) > 1e-5:\n            total_p = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                lb = low_bounds[i]\n                ub = high_bounds[i]\n                if unit['c_i'] > 0:\n                    p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = ub if lambda_val > unit['b_i'] else lb\n                p_val = max(lb, min(ub, p_val))\n                total_p += p_val\n            \n            if total_p < target:\n                low_lambda = lambda_val\n            else:\n                high_lambda = lambda_val\n            lambda_val = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Final assignment\n        total_p = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            lb = low_bounds[i]\n            ub = high_bounds[i]\n            if unit['c_i'] > 0:\n                p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = ub if lambda_val > unit['b_i'] else lb\n            p_val = max(lb, min(ub, p_val))\n            total_p += p_val\n            p_i[i] = p_val\n            u_i[i] = 1\n        \n        # Residual adjustment\n        residual = target - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                headrooms = [high_bounds[i] - p_i[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        add = factor * headrooms[idx]\n                        p_i[i] = min(high_bounds[i], p_i[i] + add)\n            else:\n                headrooms = [p_i[i] - low_bounds[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, -residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        p_i[i] = max(low_bounds[i], p_i[i] - factor * headrooms[idx])\n    \n    # Prepare output\n    schedules = np.vstack([np.array(u_i), np.array(p_i)])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00653,
          "gap_price_rate": 0.00537,
          "fitness": 0.00595
     },
     {
          "name": "combined_amortized_decommitment_v2",
          "algorithm": "1. Identify forced-on units (previous state online with insufficient up-time or shutdown ramp violation) and forced-off units (previous state offline with insufficient down-time)\n2. Initialize committed units as forced-on units and calculate their ramp-constrained power ranges\n3. If capacity is insufficient:\n   a) Split eligible units into kept-on (previously online) and startable (previously offline) groups\n   b) Calculate kept-on cost as operating cost per MW at min output and startable cost as amortized cost including startup\n   c) Combine groups, sort by cost, and commit units until capacity suffices\n   d) Apply startup ramp limits for new units\n4. Perform decommitment of non-forced committed units in descending cost order if excess capacity\n5. Set dispatch target clamped between total min/max capacity\n6. Perform economic dispatch via lambda iteration respecting ramp constraints, with additional adjustment for linear units\n7. Set non-committed units to offline (0,0)\n",
          "code": "import numpy as np\n\ndef combined_amortized_decommitment_v2(units_info, load):\n    n_units = len(units_info)\n    committed = []\n    free = []\n    forced_on = []\n    forced_off = []\n    \n    # Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_min_on = unit['t_on_min_i']\n        t_min_off = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < t_min_on or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:\n            if abs(t0) < t_min_off:\n                forced_off.append(i)\n            else:\n                free.append(i)\n    \n    # Initialize committed units and calculate total capacity\n    committed = forced_on.copy()\n    total_min, total_max = 0, 0\n    bounds = [None] * n_units\n    \n    for i in committed:\n        unit = units_info[i]\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (low, high)\n        total_min += low\n        total_max += high\n    \n    # Split free units into kept-on and startable\n    kept_on = [i for i in free if units_info[i]['u_i_0'] == 1]\n    startable = [i for i in free if units_info[i]['u_i_0'] == 0]\n    \n    # Amortization period setup\n    AMORTIZE_HOURS = 24\n    \n    # Calculate costs for unit selection\n    unit_costs = []\n    for i in kept_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_per_mw = base_cost / p_min\n        unit_costs.append((cost_per_mw, i, 'kept'))\n    \n    for i in startable:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        amortized_startup = unit['s_i'] / min(unit['t_on_min_i'], AMORTIZE_HOURS)\n        base_cost = amortized_startup + unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n        cost_per_mw = base_cost / p_min\n        unit_costs.append((cost_per_mw, i, 'start'))\n    \n    unit_costs.sort(key=lambda x: x[0])\n    \n    # Commit additional units if needed\n    new_committed = []\n    for cost, i, unit_type in unit_costs:\n        if total_max >= load:\n            break\n            \n        if unit_type == 'kept':\n            unit = units_info[i]\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit = units_info[i]\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        \n        if low > high:\n            continue\n            \n        bounds[i] = (low, high)\n        total_min += low\n        total_max += high\n        committed.append(i)\n        new_committed.append(i)\n    \n    # Decommitment: remove non-forced units if possible\n    nf_committed = [i for i in committed if i not in forced_on]\n    decommit_costs = []\n    \n    for i in nf_committed:\n        low, high = bounds[i]\n        if i in kept_on:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n            cost_per_mw = base_cost / p_min\n        else:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            base_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2\n            cost_per_mw = (unit['s_i'] + base_cost) / p_min\n        decommit_costs.append((cost_per_mw, i))\n    \n    decommit_costs.sort(key=lambda x: x[0], reverse=True)\n    \n    for cost, i in decommit_costs:\n        low, high = bounds[i]\n        if (total_min - low) <= load and (total_max - high) >= load:\n            total_min -= low\n            total_max -= high\n            committed.remove(i)\n            bounds[i] = None\n    \n    # Calculate dispatch target\n    dispatch_target = max(total_min, min(load, total_max))\n    \n    # Economic dispatch via lambda iteration\n    p_values = np.zeros(n_units)\n    lambda_low, lambda_high = 0, 100000\n    tol = 1e-6\n    max_iter = 1000\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_gen = 0\n        linear_units = []\n        \n        for i in committed:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            p_low, p_high = bounds[i]\n            \n            if c > tol:  # Quadratic unit\n                p_uncon = (lambda_mid - b) / (2 * c)\n                p_val = max(p_low, min(p_high, p_uncon))\n                p_values[i] = p_val\n                total_gen += p_val\n            else:  # Linear unit\n                if lambda_mid < b:\n                    p_values[i] = p_low\n                    total_gen += p_low\n                else:\n                    p_values[i] = p_high\n                    total_gen += p_high\n                linear_units.append(i)\n        \n        if abs(total_gen - dispatch_target) < tol:\n            break\n        elif total_gen < dispatch_target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Additional adjustment for linear units\n    residual = dispatch_target - total_gen\n    if abs(residual) > tol and linear_units:\n        for i in linear_units:\n            if abs(residual) < tol:\n                break\n            p_low, p_high = bounds[i]\n            b = units_info[i]['b_i']\n            delta = min(abs(residual), p_high - p_low) * np.sign(residual)\n            if (p_values[i] == p_low and delta > 0) or (p_values[i] == p_high and delta < 0):\n                p_values[i] += delta\n                residual -= delta\n    \n    # Prepare output arrays\n    u_out = np.array([1 if i in committed else 0 for i in range(n_units)])\n    p_out = np.array([p_values[i] if i in committed else 0.0 for i in range(n_units)])\n    \n    return np.vstack((u_out, p_out))",
          "from": "crossover",
          "gap_power_rate": 0.00506,
          "gap_price_rate": 0.00885,
          "fitness": 0.00695
     },
     {
          "name": "refined_adaptive_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                forced_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                forced_off.append(i)\n                \n    committed = set(forced_on)\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        min_output[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n        max_output[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        total_min += min_output[i]\n        total_max += max_output[i]\n        \n    candidates = []\n    \n    for i in range(n):\n        if i in committed or i in forced_off:\n            continue\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            adjusted_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            candidates.append((i, adjusted_cost, 'A', min_bound, max_bound))\n        else:\n            adjusted_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, adjusted_cost, 'B', min_bound, max_bound))\n            \n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        \n    for i, cost, typ, min_b, max_b in candidates:\n        if total_max >= load:\n            break\n        committed.add(i)\n        min_output[i] = min_b\n        max_output[i] = max_b\n        total_min += min_b\n        total_max += max_b\n        \n    dispatch_target = load\n    if total_min >= total_max:\n        dispatch_target = total_min\n    else:\n        if dispatch_target < total_min:\n            dispatch_target = total_min\n        elif dispatch_target > total_max:\n            dispatch_target = total_max\n            \n    p_dispatch = [0.0] * n\n    if committed:\n        low_lambda = 0.0\n        high_lambda = 10000.0\n        tol = 0.01\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = min_output[i]\n                p_max_i = max_output[i]\n                \n                if c_i == 0:\n                    if mid_lambda <= b_i:\n                        power = p_min_i\n                    else:\n                        power = p_max_i\n                else:\n                    unconstrained = (mid_lambda - b_i) / (2 * c_i)\n                    if unconstrained < p_min_i:\n                        power = p_min_i\n                    elif unconstrained > p_max_i:\n                        power = p_max_i\n                    else:\n                        power = unconstrained\n                p_dispatch[i] = power\n                total_power += power\n                \n            if abs(total_power - dispatch_target) <= tol:\n                break\n                \n            if total_power < dispatch_target:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n                \n    u_final = [0] * n\n    p_final = [0.0] * n\n    for i in range(n):\n        if i in committed:\n            u_final[i] = 1\n            p_final[i] = p_dispatch[i]\n            \n    return np.array([u_final, p_final])",
          "from": "mutation",
          "gap_power_rate": 0.00543,
          "gap_price_rate": 0.00878,
          "fitness": 0.00711
     },
     {
          "name": "amortized_refined_adaptive_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previously online and either minimum up-time unsatisfied (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previously offline and minimum down-time unsatisfied (abs(t_i_0) < t_off_min_i)).\n2. Initialize committed units as forced-on units. Compute feasible power ranges:\n   - Forced-on units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Calculate total minimum/maximum generation capacity\n3. If load exceeds total maximum capacity:\n   a) Identify startable units not forced on/off and meeting minimum down-time\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Commit units by ascending amortized cost order until capacity >= load\n   d) Set new unit ranges: [p_min_i, min(p_max_i, p_start_i)]\n4. Set dispatch target to load clamped between updated total min/max capacity\n5. Perform lambda iteration for economic dispatch:\n   a) Initialize lambda bounds based on marginal costs\n   b) For each unit, compute unconstrained power using unit-specific cost function\n   c) Clamp power to unit's feasible range based on operational history\n   d) Adjust lambda via bisection until generation matches target within tolerance\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef amortized_refined_adaptive_commitment(units_info, load):\n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    committed_indices = []\n    \n    # Identify forced on/off units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        if u_i_0 == 1:  # Previously online\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                forced_on_indices.append(idx)\n            else:\n                free_indices.append(idx)\n        else:  # Previously offline\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off_indices.append(idx)\n            else:\n                free_indices.append(idx)\n    \n    # Initialize committed units to forced-on units\n    committed_indices = forced_on_indices.copy()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Set power ranges and calculate total capacity for committed units\n    for idx in committed_indices:\n        unit = units_info[idx]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['lb'] = lb\n        unit['ub'] = ub\n        total_min += lb\n        total_max += ub\n    \n    # Commit additional units if capacity insufficient\n    if total_max < load:\n        candidate_units = []\n        for idx in free_indices:\n            unit = units_info[idx]\n            p_min_i = unit['p_min_i']\n            # Calculate amortized startup cost (spread over min up-time capped at 24h)\n            amort_startup = unit['s_i'] / min(unit['t_on_min_i'], 24)\n            # Calculate adjusted cost per MW at minimum output\n            adj_cost = (amort_startup + unit['a_i'] + unit['b_i']*p_min_i + unit['c_i']*p_min_i**2) / p_min_i\n            candidate_units.append((adj_cost, idx, unit))\n        \n        # Sort by ascending adjusted cost\n        candidate_units.sort(key=lambda x: x[0])\n        \n        # Commit units until capacity meets demand\n        for _, idx, unit in candidate_units:\n            if total_max >= load:\n                break\n            committed_indices.append(idx)\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            unit['lb'] = lb\n            unit['ub'] = ub\n            total_min += lb\n            total_max += ub\n            free_indices.remove(idx)\n    \n    # Calculate dispatch target\n    target = max(total_min, min(load, total_max))\n    \n    # Lambda iteration for economic dispatch\n    tol = 0.1  # MW tolerance\n    max_iter = 1000\n    iter_count = 0\n    lambda_low = 0.0\n    lambda_high = 0.0\n    \n    # Initialize lambda bounds based on marginal costs\n    for idx in committed_indices:\n        unit = units_info[idx]\n        # Consider marginal cost at bounds\n        if unit['c_i'] != 0:\n            mc_min = 2*unit['c_i']*unit['lb'] + unit['b_i']\n            mc_max = 2*unit['c_i']*unit['ub'] + unit['b_i']\n        else:  # Linear cost\n            mc_min = mc_max = unit['b_i']\n        lambda_low = min(lambda_low, mc_min)\n        lambda_high = max(lambda_high, mc_max)\n    \n    # Expand bounds conservatively\n    lambda_low = max(0, lambda_low - 100)\n    lambda_high += 100\n    \n    # Bisection loop\n    while iter_count < max_iter:\n        total_gen = 0.0\n        lambda_mid = (lambda_low + lambda_high) / 2\n        \n        for idx in committed_indices:\n            unit = units_info[idx]\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            # Calculate unconstrained dispatch\n            if unit['c_i'] != 0:  # Quadratic cost\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                # Clamp to feasible range\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:  # Linear cost\n                # Always operate at bounds based on lambda vs marginal cost\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            total_gen += p_dispatch\n        \n        # Adjust lambda bounds\n        if abs(total_gen - target) < tol:\n            break\n        elif total_gen < target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n            \n        iter_count += 1\n    \n    # Final dispatch and set outputs\n    schedules = np.zeros((2, len(units_info)))\n    for idx, unit in enumerate(units_info):\n        if idx in committed_indices:\n            lb = unit['lb']\n            ub = unit['ub']\n            \n            if unit['c_i'] != 0:\n                p_ideal = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                p_dispatch = max(lb, min(p_ideal, ub))\n            else:\n                p_dispatch = ub if lambda_mid > unit['b_i'] else lb\n                \n            schedules[0, idx] = 1\n            schedules[1, idx] = p_dispatch\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00792,
          "fitness": 0.00717
     },
     {
          "name": "enhanced_amortized_adaptive_commitment_v2",
          "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time violations or shutdown ramp constraints) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units with forced-on units and set their feasible power ranges using ramp constraints.\n3. If existing capacity is insufficient, identify startable units (non-forced on/off, meeting minimum downtime), calculate amortized cost including startup expenses, and commit units in ascending cost order until capacity meets load, applying startup ramp limits for new units.\n4. Perform decommitment: Identify non-forced-on committed units eligible for shutdown (satisfying ramp down constraints). Calculate operating cost at minimum output, and remove high-cost units in descending order if system capacity remains sufficient without them.\n5. Set dispatch target to load clamped between updated total min/max capacity.\n6. Perform economic dispatch via lambda iteration respecting ramp constraints for existing units, startup ramp limits for new units, and individual unit min/max limits.\n7. Set non-committed units to offline with zero output.\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = [False] * n\n    forced_off = [False] * n\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        if u0 == 1:\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                forced_on[i] = True\n        elif u0 == 0:\n            if abs(t0) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    low_bound = [0] * n\n    high_bound = [0] * n\n    committed = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Step 2: Initialize with forced-on units\n    for i, unit in enumerate(units_info):\n        if forced_on[i]:\n            low_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            committed.append(i)\n            total_min += low_bound[i]\n            total_max += high_bound[i]\n    \n    # Step 3: Add startable units if capacity insufficient\n    startable = []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0_abs = abs(unit['t_i_0'])\n        if not forced_on[i] and not forced_off[i] and u0 == 0 and t0_abs >= unit['t_off_min_i']:\n            startable.append(i)\n    \n    amortized_costs = []\n    for i in startable:\n        unit = units_info[i]\n        t_amort = min(unit['t_on_min_i'], 24)\n        num = (unit['s_i'] / t_amort) + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        amortized_costs.append(num / unit['p_min_i'])\n    \n    sorted_startable = [idx for _, idx in sorted(zip(amortized_costs, startable))]\n    \n    for i in sorted_startable:\n        if total_max < load:\n            low_i = units_info[i]['p_min_i']\n            high_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            low_bound[i] = low_i\n            high_bound[i] = high_i\n            committed.append(i)\n            total_min += low_i\n            total_max += high_i\n    \n    # Step 4: Decommit non-forced-on units if possible\n    changed = True\n    while changed and len(committed) > 0:\n        changed = False\n        decommit_candidates = []\n        op_costs = []\n        for i in committed:\n            if forced_on[i]:\n                continue\n            unit = units_info[i]\n            eligible = False\n            if unit['u_i_0'] == 0:\n                eligible = True\n            elif unit['u_i_0'] == 1 and unit['p_i_0'] <= unit['p_down_i']:\n                eligible = True\n            if eligible:\n                decommit_candidates.append(i)\n                cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)) / unit['p_min_i']\n                op_costs.append(cost)\n        \n        if not decommit_candidates:\n            break\n        \n        sorted_indices = [idx for _, idx in sorted(zip(op_costs, decommit_candidates), reverse=True)]\n        \n        for i in sorted_indices:\n            new_min = total_min - low_bound[i]\n            new_max = total_max - high_bound[i]\n            if new_min <= load <= new_max:\n                committed.remove(i)\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                break\n    \n    # Step 5: Set dispatch target\n    dispatch_target = np.clip(load, total_min, total_max)\n    \n    # Step 6: Economic dispatch via lambda iteration\n    p_outputs = [0.0] * n\n    if not committed:\n        return np.zeros((2, n))\n    \n    n_committed = len(committed)\n    lambda_low = 0.0\n    lambda_high = 10000.0\n    tolerance = 0.1\n    max_iter = 1000\n    \n    for _ in range(max_iter):\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0.0\n        temp_outputs = []\n        \n        for idx in committed:\n            unit = units_info[idx]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            low_i = low_bound[idx]\n            high_i = high_bound[idx]\n            \n            if c_i > 0:\n                p_val = (lambda_mid - b_i) / (2 * c_i)\n                p_val = max(low_i, min(high_i, p_val))\n            else:\n                if lambda_mid < b_i:\n                    p_val = low_i\n                else:\n                    p_val = high_i\n            total_power += p_val\n            temp_outputs.append(p_val)\n        \n        if abs(total_power - dispatch_target) <= tolerance:\n            for j, idx in enumerate(committed):\n                p_outputs[idx] = temp_outputs[j]\n            break\n        \n        if total_power < dispatch_target:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    else:\n        for idx in committed:\n            unit = units_info[idx]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            low_i = low_bound[idx]\n            high_i = high_bound[idx]\n            if c_i > 0:\n                p_val = (lambda_high - b_i) / (2 * c_i)\n                p_val = max(low_i, min(high_i, p_val))\n            else:\n                p_val = high_i if lambda_high >= b_i else low_i\n            p_outputs[idx] = p_val\n    \n    # Step 7: Set schedules\n    schedules = np.zeros((2, n))\n    for i in range(n):\n        if i in committed:\n            schedules[0, i] = 1\n            schedules[1, i] = p_outputs[i]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00643,
          "gap_price_rate": 0.00802,
          "fitness": 0.00722
     },
     {
          "name": "enhanced_amortized_rolling_commitment",
          "algorithm": "1. Identify forced-on units (previous state online with minimum up-time not satisfied or shutdown ramp violation) and forced-off units (previous state offline with minimum down-time not satisfied).  \n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits.  \n3. If load exceeds current maximum capacity:  \n   a) Identify free units (neither forced-on nor forced-off) split into kept-on units (previously online) and startable units (previously offline).  \n   b) For kept-on units, calculate average operating cost per MW at minimum output. For startable units, calculate amortized cost per MW including startup cost amortized over minimum up-time.  \n   c) Combine and sort units by ascending cost.  \n   d) Commit units in sorted order, updating bounds for kept-on and startable units, until capacity suffices.  \n4. Set dispatch target clamped between total minimum and maximum capacity.  \n5. Perform economic dispatch via lambda iteration with bisection to minimize costs, ensuring solutions respect power bounds.  \n6. Adjust residual load distribution using marginal cost priority if necessary.  \n7. Set non-committed units offline with zero output.  \n8. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    commited_status = [False] * n_units\n    p_min_cur = [0.0] * n_units\n    p_max_cur = [0.0] * n_units\n    p_output = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    forced_on = []\n    forced_off = []\n    for i, unit in enumerate(units_info):\n        u_prev = unit['u_i_0']\n        t_prev = unit['t_i_0']\n        p_prev = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_prev == 1:\n            if t_prev < min_up or p_prev > p_shut:\n                forced_on.append(i)\n        else:\n            if abs(t_prev) < min_down:\n                forced_off.append(i)\n    \n    # Step 2: Initialize committed units (forced-on)\n    total_min = 0.0\n    total_max = 0.0\n    for i in forced_on:\n        unit = units_info[i]\n        commited_status[i] = True\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_prev = unit['p_i_0']\n        \n        p_min_cur[i] = max(p_min, p_prev - p_down)\n        p_max_cur[i] = min(p_max, p_prev + p_up)\n        total_min += p_min_cur[i]\n        total_max += p_max_cur[i]\n    \n    # Step 3: Commit additional units if needed\n    if total_max < load:\n        kepton = []\n        startable = []\n        free_units = []\n        \n        # Find free units not forced on/off\n        for i in range(n_units):\n            if commited_status[i] or i in forced_off:\n                continue\n            free_units.append(i)\n        \n        # Split into kepton and startable\n        for i in free_units:\n            u_prev = units_info[i]['u_i_0']\n            if u_prev == 1:\n                kepton.append(i)\n            else:\n                startable.append(i)\n        \n        # Calculate costs\n        unit_costs = []\n        for i in kepton:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            p_min = unit['p_min_i']\n            base_cost = a + b * p_min + c * p_min ** 2\n            cost_per_mw = base_cost / p_min\n            unit_costs.append((cost_per_mw, i, 'kepton'))\n        \n        for i in startable:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            p_min = unit['p_min_i']\n            min_up = unit['t_on_min_i']\n            s_cost = unit['s_i']\n            amortization = min(min_up, 24)\n            base_cost = (s_cost / amortization) + a + b * p_min + c * p_min ** 2\n            cost_per_mw = base_cost / p_min\n            unit_costs.append((cost_per_mw, i, 'startable'))\n        \n        # Sort by cost ascending\n        unit_costs.sort(key=lambda x: x[0])\n        \n        # Commit units until load is satisfied\n        for cost_val, i, unit_type in unit_costs:\n            if total_max >= load:\n                break\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            commited_status[i] = True\n            \n            if unit_type == 'kepton':\n                p_prev = unit['p_i_0']\n                p_down = unit['p_down_i']\n                p_up = unit['p_up_i']\n                p_min_cur[i] = max(p_min, p_prev - p_down)\n                p_max_cur[i] = min(p_max, p_prev + p_up)\n            else:  # startable\n                p_start = unit['p_start_i']\n                p_min_cur[i] = p_min\n                p_max_cur[i] = min(p_max, p_start)\n            \n            total_min += p_min_cur[i]\n            total_max += p_max_cur[i]\n    \n    # Step 4: Dispatch target\n    dispatch_target = min(max(total_min, load), total_max)\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_idxs = [i for i in range(n_units) if commited_status[i]]\n    n_committed = len(committed_idxs)\n    \n    if n_committed == 0:\n        schedules = np.zeros((2, n_units))\n        return schedules\n    \n    # Initialize lambda bounds\n    lambda_low = 0\n    lambda_high = 0\n    for i in committed_idxs:\n        unit = units_info[i]\n        b, c = unit['b_i'], unit['c_i']\n        p_max = p_max_cur[i]\n        if c > 0:\n            marginal_cost = 2 * c * p_max + b\n        else:\n            marginal_cost = b\n        if marginal_cost > lambda_high:\n            lambda_high = marginal_cost\n    lambda_high = max(lambda_high, 100)\n    \n    # Lambda iteration\n    tol = 1e-3\n    max_iter = 1000\n    iter_count = 0\n    total_p = 0\n    \n    # Initialize outputs to minimum\n    for i in committed_idxs:\n        p_output[i] = p_min_cur[i]\n        total_p += p_output[i]\n    \n    if total_p < dispatch_target:\n        while abs(total_p - dispatch_target) > tol and iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0\n            for i in committed_idxs:\n                unit = units_info[i]\n                low = p_min_cur[i]\n                high = p_max_cur[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                \n                if c > 0:  # Quadratic\n                    p_uncon = (lambda_mid - b) / (2 * c)\n                    p_clamped = np.clip(p_uncon, low, high)\n                else:  # Linear\n                    if lambda_mid < b:\n                        p_clamped = low\n                    else:\n                        p_clamped = high\n                \n                p_output[i] = p_clamped\n                total_p += p_clamped\n            \n            if total_p < dispatch_target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            iter_count += 1\n    \n    # Step 6: Residual adjustment\n    residual = dispatch_target - total_p\n    if abs(residual) > tol:\n        if residual > 0:\n            adjustable = [i for i in committed_idxs if p_output[i] < p_max_cur[i] - tol]\n            marginal_costs = []\n            for i in adjustable:\n                unit = units_info[i]\n                b, c = unit['b_i'], unit['c_i']\n                if c > 0:\n                    mc = 2 * c * p_output[i] + b\n                else:\n                    mc = b\n                marginal_costs.append(mc)\n            sorted_idxs = [i for _, i in sorted(zip(marginal_costs, adjustable))]\n            for i in sorted_idxs:\n                headroom = p_max_cur[i] - p_output[i]\n                adjust = min(headroom, residual)\n                p_output[i] += adjust\n                residual -= adjust\n                if residual <= 0:\n                    break\n        else:\n            residual_abs = -residual\n            adjustable = [i for i in committed_idxs if p_output[i] > p_min_cur[i] + tol]\n            marginal_costs = []\n            for i in adjustable:\n                unit = units_info[i]\n                b, c = unit['b_i'], unit['c_i']\n                if c > 0:\n                    mc = 2 * c * p_output[i] + b\n                else:\n                    mc = b\n                marginal_costs.append(mc)\n            sorted_idxs = [i for _, i in sorted(zip(marginal_costs, adjustable), reverse=True)]\n            for i in sorted_idxs:\n                footroom = p_output[i] - p_min_cur[i]\n                adjust = min(footroom, residual_abs)\n                p_output[i] -= adjust\n                residual_abs -= adjust\n                if residual_abs <= 0:\n                    break\n            residual = -residual_abs\n    \n    # Prepare output\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if commited_status[i]:\n            schedules[0, i] = 1\n            schedules[1, i] = p_output[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.00898,
          "fitness": 0.00726
     },
     {
          "name": "enhanced_amortized_kepton_commitment",
          "algorithm": "1. Identify forced-on units that must remain online (previous state online with either insufficient up-time or shutdown ramp violation) and forced-off units that must remain offline (previous state offline with insufficient down-time). 2. Initialize committed units as forced-on units, computing ramp-constrained power bounds. 3. If current committed capacity is insufficient: \n   a) Split free units into kept-on (previously online) and startable (previously offline meeting minimum downtime) \n   b) Compute operating cost per MW at minimum output for kept-on units \n   c) Compute amortized cost per MW including startup expenses for startable units \n   d) Combine and sort units by ascending cost \n   e) Commit units in sorted order, updating bounds: \n      - Kept-on: ramp-constrained bounds \n      - Startable: startup ramp-limited bounds \n4. Set dispatch target clamped between total min/max capacity \n5. Perform economic dispatch via lambda iteration respecting unit bounds and cost functions \n6. Return commitment states and power outputs\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_kepton_commitment(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    if not units_info or load <= 0:\n        return schedules\n        \n    # Identify forced-on and forced-off units\n    forced_on_indices = []\n    forced_off_indices = []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on_indices.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n    \n    committed_indices = forced_on_indices.copy()\n    bounds = {}\n    \n    # Initialize forced-on units with ramp constraints\n    total_min, total_max = 0, 0\n    for i in forced_on_indices:\n        unit = units_info[i]\n        low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds[i] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    free_indices = [i for i in range(n_units) if i not in forced_on_indices and i not in forced_off_indices]\n    kept_on = [i for i in free_indices if units_info[i]['u_i_0'] == 1]\n    startable = [i for i in free_indices if units_info[i]['u_i_0'] == 0]\n    \n    # Commit additional units if needed\n    if total_max < load:\n        candidates = []\n        \n        for i in kept_on:\n            unit = units_info[i]\n            base_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            candidates.append((base_cost / unit['p_min_i'], i, 'kept_on'))\n            \n        for i in startable:\n            unit = units_info[i]\n            amortization = min(unit['t_on_min_i'], 24)\n            amortized_startup = unit['s_i'] / amortization\n            base_cost = amortized_startup + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2\n            candidates.append((base_cost / unit['p_min_i'], i, 'startable'))\n        \n        candidates.sort(key=lambda x: x[0])\n        \n        for _, i, typ in candidates:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            if typ == 'kept_on':\n                low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                low = unit['p_min_i']\n                high = min(unit['p_max_i'], unit['p_start_i'])\n                \n            total_min += low\n            total_max += high\n            committed_indices.append(i)\n            bounds[i] = (low, high)\n    \n    # Set dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch\n    power_outputs = [0] * n_units\n    if committed_indices:\n        lambda_low, lambda_high = float('inf'), float('-inf')\n        for i in committed_indices:\n            unit = units_info[i]\n            low, high = bounds[i]\n            mc_low = unit['b_i'] + 2 * unit['c_i'] * low if unit['c_i'] > 0 else unit['b_i']\n            mc_high = unit['b_i'] + 2 * unit['c_i'] * high if unit['c_i'] > 0 else unit['b_i']\n            if mc_low < lambda_low: lambda_low = mc_low\n            if mc_high > lambda_high: lambda_high = mc_high\n        \n        if lambda_low == lambda_high:\n            for i in committed_indices:\n                low, _ = bounds[i]\n                power_outputs[i] = low\n                total_power = sum(power_outputs)\n        else:\n            tolerance = 0.1\n            max_iter = 1000\n            iter_count = 0\n            total_power = 0\n            while iter_count < max_iter:\n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_power = 0\n                for i in committed_indices:\n                    unit = units_info[i]\n                    low, high = bounds[i]\n                    if unit['c_i'] > 0:\n                        p = max(low, min(high, (lambda_mid - unit['b_i']) / (2 * unit['c_i'])))\n                    else:\n                        p = low if lambda_mid < unit['b_i'] else high\n                    power_outputs[i] = p\n                    total_power += p\n                \n                if abs(total_power - target) <= tolerance:\n                    break\n                \n                if total_power < target:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n                \n                iter_count += 1\n    \n    # Build output schedule\n    for i in range(n_units):\n        if i in committed_indices:\n            schedules[0, i] = 1\n            schedules[1, i] = power_outputs[i]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00556,
          "gap_price_rate": 0.00898,
          "fitness": 0.00727
     },
     {
          "name": "hybrid_amortized_commitment",
          "algorithm": "1. Identify forced-on units (previously online with insufficient up-time or shutdown ramp violation) and forced-off units (previously offline with insufficient down-time)  \n2. Initialize committed units as forced-on units plus any non-forced units previously online. Set power bounds for these units using ramp limits  \n3. If total capacity is insufficient:  \n   a) Identify startable units (non-forced, offline, meeting min down-time)  \n   b) Calculate amortized cost: (startup cost/min(up-time limit, 24) + operating cost at min output) / min output  \n   c) Sort startable units by ascending amortized cost  \n   d) Commit units in sorted order until capacity suffices, applying startup ramp limits  \n4. Decommit non-forced units eligible for shutdown (satisfied min up-time) in descending order of cost per MW if removal maintains sufficient capacity  \n5. Set dispatch target as the load  \n6. Perform economic dispatch via lambda iteration:  \n   a) Initialize lambda bounds based on marginal costs  \n   b) For quadratic cost units: set generation at (\u03bb - b)/2c  \n   c) For linear units: set at max output if \u03bb >= b, else min output  \n   d) Clamp generation to unit bounds and adjust lambda via bisection  \n7. Set non-committed units to offline (0,0)  \n",
          "code": "import numpy as np\n\ndef hybrid_amortized_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    committed = [False] * n_units\n    lb = [0.0] * n_units\n    ub = [0.0] * n_units\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 1: Identify forced on/off units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1:  # Previously online\n            forced_on[i] = (t_i0 < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n        else:  # Previously offline\n            forced_off[i] = abs(t_i0) < unit['t_off_min_i']\n    \n    # Step 2: Initialize committed units with ramp constraints\n    total_min, total_max = 0.0, 0.0\n    for i, unit in enumerate(units_info):\n        if forced_on[i]:\n            committed[i] = True\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += lb[i]\n            total_max += ub[i]\n        elif not forced_off[i] and unit['u_i_0'] == 1:\n            committed[i] = True\n            lb[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            total_min += lb[i]\n            total_max += ub[i]\n    \n    # Step 3: Commit startable units if capacity insufficient\n    if total_max < load:\n        startable_units = []\n        amortized_costs = []\n        for i, unit in enumerate(units_info):\n            if not committed[i] and not forced_on[i] and not forced_off[i] and unit['u_i_0'] == 0:\n                if abs(unit['t_i_0']) >= unit['t_off_min_i']:\n                    startable_units.append(i)\n                    amort_period = min(unit['t_on_min_i'], 24)\n                    min_cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2\n                    amort_cost = (unit['s_i'] / amort_period + min_cost) / unit['p_min_i']\n                    amortized_costs.append(amort_cost)\n        \n        if amortized_costs:\n            sorted_indices = np.argsort(amortized_costs)\n            for idx in sorted_indices:\n                i = startable_units[idx]\n                unit = units_info[i]\n                committed[i] = True\n                lb[i] = unit['p_min_i']\n                ub[i] = min(unit['p_max_i'], unit['p_start_i'])\n                total_min += lb[i]\n                total_max += ub[i]\n                if total_max >= load:\n                    break\n    \n    # Step 4: Decommit high-cost non-forced units\n    if total_min <= load <= total_max:\n        non_forced_committed = [i for i in range(n_units) if committed[i] and not forced_on[i]]\n        eligible_decommit = []\n        cost_per_mw = []\n        \n        for i in non_forced_committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                if unit['t_i_0'] + 1 >= unit['t_on_min_i']:\n                    cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n                    cost_per_mw.append(cost)\n                    eligible_decommit.append(i)\n            else:  # Started this period\n                if 1 >= unit['t_on_min_i']:\n                    cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i'] ** 2) / unit['p_min_i']\n                    cost_per_mw.append(cost)\n                    eligible_decommit.append(i)\n        \n        if cost_per_mw:\n            sorted_indices = np.argsort(cost_per_mw)[::-1]\n            for idx in sorted_indices:\n                i = eligible_decommit[idx]\n                if total_max - ub[i] >= load:\n                    committed[i] = False\n                    total_min -= lb[i]\n                    total_max -= ub[i]\n    \n    # Step 6: Economic dispatch for committed units\n    comm_units = [i for i in range(n_units) if committed[i]]\n    if comm_units:\n        marginal_low, marginal_high = [], []\n        for i in comm_units:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                marginal_low.append(unit['b_i'])\n                marginal_high.append(unit['b_i'])\n            else:\n                marginal_low.append(2 * unit['c_i'] * lb[i] + unit['b_i'])\n                marginal_high.append(2 * unit['c_i'] * ub[i] + unit['b_i'])\n        \n        low_lambda, high_lambda = min(marginal_low), max(marginal_high)\n        mid_lambda = (low_lambda + high_lambda) / 2\n        tolerance, max_iter = 0.1, 1000\n        \n        for _ in range(max_iter):\n            total_power = 0.0\n            for i in comm_units:\n                unit = units_info[i]\n                if unit['c_i'] != 0:\n                    p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Linear unit\n                    p_i = ub[i] if mid_lambda >= unit['b_i'] else lb[i]\n                p_i = max(lb[i], min(ub[i], p_i))\n                total_power += p_i\n            \n            if abs(total_power - load) < tolerance:\n                break\n            if total_power > load:\n                high_lambda = mid_lambda\n            else:\n                low_lambda = mid_lambda\n            mid_lambda = (low_lambda + high_lambda) / 2\n        \n        # Assign final dispatch values\n        for i in comm_units:\n            unit = units_info[i]\n            if unit['c_i'] != 0:\n                p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = ub[i] if mid_lambda >= unit['b_i'] else lb[i]\n            p_out[i] = max(lb[i], min(ub[i], p_val))\n            u_out[i] = 1\n    \n    # Step 7: Format output\n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.00555,
          "gap_price_rate": 0.00959,
          "fitness": 0.00757
     }
]