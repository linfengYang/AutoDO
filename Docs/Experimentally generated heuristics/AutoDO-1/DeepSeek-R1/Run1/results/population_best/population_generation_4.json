{
     "name": "refined_adaptive_rolling_commitment",
     "algorithm": "1. Identify forced-on units that must remain online: units that were previously online and either haven't satisfied minimum up-time (t_i_0 < t_on_min_i) or violate shutdown ramp constraints (p_i_0 > p_shut_i).\n2. Identify forced-off units that must remain offline: units that were previously offline and haven't satisfied minimum down-time (|t_i_0| < t_off_min_i).\n3. Initialize committed units as forced-on units. Calculate feasible power ranges for committed units (ramp-constrained for continuously online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]).\n4. Calculate total minimum (sum of lower bounds) and maximum (sum of upper bounds) generation from committed units.\n5. If load exceeds total maximum generation:\n   a. Identify startable units: units not forced-on/off that can be started (satisfy minimum downtime).\n   b. Sort startable units by startup cost-adjusted average cost per MW at minimum output: (s_i + a_i + b_i*p_min_i + c_i*p_min_i**2)/p_min_i.\n   c. Commit units in ascending cost order until generation capacity meets or exceeds load. Newly committed units have output bounds: [p_min_i, min(p_max_i, p_start_i)].\n6. Calculate dispatch target: load clamped between updated total minimum and maximum generation.\n7. Perform economic dispatch using lambda iteration:\n   a. Initialize lambda and bounds. Use bisection to find optimal lambda.\n   b. For each committed unit, calculate unconstrained power: (lambda - b_i)/(2*c_i) if c_i>0. Handle linear costs (c_i=0) based on comparison between b_i and lambda.\n   c. Project power to feasible bounds: continuously online units use ramp constraints, newly committed units use startup ramp limits.\n   d. Adjust lambda until total generation matches target.\n8. Set non-committed units to offline state (u_i=0) with zero output (p_i=0).\n9. Return schedule with commitment states and power outputs.\n\n",
     "code": "import numpy as np\n\ndef refined_adaptive_rolling_commitment(units_info, load):\n    num_units = len(units_info)\n    u_vector = np.zeros(num_units)\n    p_vector = np.zeros(num_units)\n    committed = set()\n    \n    # Identify forced-on and forced-off units\n    forced_on = set()\n    forced_off = set()\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.add(i)\n        else:  # Previously offline\n            if t_i0 > -t_off_min:  # Not satisfied minimum downtime\n                forced_off.add(i)\n    \n    # Initialize committed units (forced-on)\n    committed = forced_on.copy()\n    for i in committed:\n        u_vector[i] = 1\n    \n    # Calculate total min/max power from committed units\n    total_min = 0\n    total_max = 0\n    power_bounds = {}\n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        \n        # Continuously online: apply ramp constraints\n        low_bound = max(p_min, p_i0 - p_down)\n        high_bound = min(p_max, p_i0 + p_up)\n        power_bounds[i] = (low_bound, high_bound)\n        total_min += low_bound\n        total_max += high_bound\n    \n    # Handle insufficient capacity by starting units\n    if total_max < load:\n        # Identify startable units (not forced on/off, currently offline)\n        startable = []\n        for i, unit in enumerate(units_info):\n            if i not in committed and i not in forced_off and unit['u_i_0'] == 0:\n                # Check minimum downtime satisfied (t_off_min_i already considered in forced_off)\n                startable.append(i)\n        \n        # Sort by cost per MW: (s_i + cost at p_min) / p_min\n        startable.sort(key=lambda i: (\n            units_info[i]['s_i'] + \n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i']**2\n        ) / units_info[i]['p_min_i'])\n        \n        # Commit units until sufficient capacity\n        for i in startable:\n            if total_max >= load:\n                break\n                \n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            p_max = unit['p_max_i']\n            p_start = unit['p_start_i']\n            high_bound = min(p_max, p_start)\n            \n            committed.add(i)\n            u_vector[i] = 1\n            power_bounds[i] = (p_min, high_bound)\n            total_min += p_min\n            total_max += high_bound\n    \n    # Calculate dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Initial lambda bounds\n        lambda_low = -10000\n        lambda_high = 10000\n        \n        # Bisection parameters\n        max_iter = 1000\n        tol = 1e-3\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            \n            # Calculate outputs and total power\n            for i in committed:\n                unit = units_info[i]\n                a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n                low, high = power_bounds[i]\n                \n                # Quadratic cost function\n                if c != 0:\n                    p_unconstrained = (lambda_mid - b) / (2 * c)\n                    p_i = max(low, min(high, p_unconstrained))\n                # Linear cost function (c=0)\n                else:\n                    p_i = high if b < lambda_mid else low\n                \n                total_power += p_i\n            \n            # Check convergence\n            if abs(total_power - target) < tol:\n                break\n            elif total_power < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            iter_count += 1\n        \n        # Update power outputs\n        for i in committed:\n            unit = units_info[i]\n            a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n            low, high = power_bounds[i]\n            \n            if c != 0:\n                p_unconstrained = (lambda_mid - b) / (2 * c)\n                p_vector[i] = max(low, min(high, p_unconstrained))\n            else:\n                p_vector[i] = high if b < lambda_mid else low\n    else:\n        # No committed units: set all to zero (if load==0)\n        pass\n    \n    # Set non-committed units to offline and zero output\n    for i in range(num_units):\n        if i not in committed:\n            u_vector[i] = 0\n            p_vector[i] = 0\n    \n    return np.array([u_vector, p_vector])",
     "from": "mutation",
     "gap_power_rate": 0.00632,
     "gap_price_rate": 0.0084,
     "fitness": 0.00736
}