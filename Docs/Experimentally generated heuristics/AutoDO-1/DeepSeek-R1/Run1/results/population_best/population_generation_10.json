{
     "name": "amortized_rolling_commitment",
     "algorithm": "1. Identify forced-on units that must remain online (previous state online and either min up-time not met (t_i_0 < t_on_min_i) or shutdown ramp constraint violated (p_i_0 > p_shut_i)). Identify forced-off units that must remain offline (previous state offline and min down-time not met (|t_i_0| < t_off_min_i)).\n2. Initialize committed units as forced-on units with power bounds constrained by ramp limits [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]. Compute total min/max generation capacity.\n3. If load exceeds total max generation capacity:\n   a) Identify startable units not forced on/off that satisfy minimum downtime\n   b) Calculate amortized cost: (s_i/min(t_on_min_i, 24) + a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n   c) Sort startable units by ascending amortized cost\n   d) Commit units in sorted order, updating total capacity and setting new unit bounds to [p_min_i, min(p_max_i, p_start_i)], until capacity >= load\n4. Set dispatch target = max(total_min, min(total_max, load))\n5. Perform economic dispatch via lambda iteration:\n   a) Initialize lambda bounds and use bisection to find optimal lambda\n   b) For each committed unit:\n        - Quadratic units: set p_i = (\u03bb - b_i)/(2*c_i)\n        - Linear units: set p_i = p_min_i if \u03bb < b_i, else p_max_i\n   c) Clamp power to unit's feasible bounds\n   d) Adjust lambda until generation matches target within tolerance\n   e) Apply proportional adjustment for residual load if needed\n6. Set non-committed units to offline (u_i=0, p_i=0)\n7. Return commitment states and power outputs\n",
     "code": "import numpy as np\n\ndef amortized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    committed_mask = [False] * n_units\n    low_bounds = [0.0] * n_units\n    high_bounds = [0.0] * n_units\n    u_i = [0] * n_units\n    p_i = [0.0] * n_units\n    \n    # Step 1: Identify forced-on and forced-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n                committed_mask[i] = True\n                low_bounds[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                high_bounds[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # previously offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2 & 3: Initialize committed units and commit more if needed\n    total_min = sum(low_bounds)\n    total_max = sum(high_bounds)\n    \n    if load > total_max:\n        startable_units = []\n        for i, unit in enumerate(units_info):\n            if not committed_mask[i] and not forced_off[i] and unit['t_off_min_i'] <= abs(unit['t_i_0']):\n                s_i = unit['s_i']\n                t_up_min = unit['t_on_min_i']\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = unit['p_min_i']\n                amortized_cost = (s_i / min(t_up_min, 24) + a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                startable_units.append((i, amortized_cost, p_min_i, unit['p_max_i'], unit['p_start_i']))\n        \n        if startable_units:\n            startable_units.sort(key=lambda x: x[1])\n            for unit_data in startable_units:\n                i, _, p_min_i, p_max_i, p_start_i = unit_data\n                new_high = min(p_max_i, p_start_i)\n                if total_max + new_high >= load:\n                    break\n                committed_mask[i] = True\n                low_bounds[i] = p_min_i\n                high_bounds[i] = new_high\n                total_min += p_min_i\n                total_max += new_high\n    \n    # Step 4: Dispatch target\n    target = max(total_min, min(total_max, load))\n    \n    # Step 5: Economic dispatch via lambda iteration\n    committed_indices = [i for i in range(n_units) if committed_mask[i]]\n    if committed_indices:\n        low_lambda = 0.0\n        high_lambda = 2000.0\n        tol = 0.01\n        max_iter = 1000\n        n_iter = 0\n        lambda_val = (low_lambda + high_lambda) / 2\n        \n        while n_iter < max_iter and abs(high_lambda - low_lambda) > 1e-5:\n            total_p = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                lb = low_bounds[i]\n                ub = high_bounds[i]\n                if unit['c_i'] > 0:\n                    p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_val = ub if lambda_val > unit['b_i'] else lb\n                p_val = max(lb, min(ub, p_val))\n                total_p += p_val\n            \n            if total_p < target:\n                low_lambda = lambda_val\n            else:\n                high_lambda = lambda_val\n            lambda_val = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Final assignment\n        total_p = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            lb = low_bounds[i]\n            ub = high_bounds[i]\n            if unit['c_i'] > 0:\n                p_val = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n            else:\n                p_val = ub if lambda_val > unit['b_i'] else lb\n            p_val = max(lb, min(ub, p_val))\n            total_p += p_val\n            p_i[i] = p_val\n            u_i[i] = 1\n        \n        # Residual adjustment\n        residual = target - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                headrooms = [high_bounds[i] - p_i[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        add = factor * headrooms[idx]\n                        p_i[i] = min(high_bounds[i], p_i[i] + add)\n            else:\n                headrooms = [p_i[i] - low_bounds[i] for i in committed_indices]\n                total_headroom = sum(headrooms)\n                if total_headroom > 0:\n                    factor = min(1, -residual / total_headroom)\n                    for idx, i in enumerate(committed_indices):\n                        p_i[i] = max(low_bounds[i], p_i[i] - factor * headrooms[idx])\n    \n    # Prepare output\n    schedules = np.vstack([np.array(u_i), np.array(p_i)])\n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.00653,
     "gap_price_rate": 0.00537,
     "fitness": 0.00595
}