{
     "name": "refined_adaptive_commitment_v2",
     "algorithm": null,
     "code": "import numpy as np\n\ndef refined_adaptive_commitment_v2(units_info, load):\n    n = len(units_info)\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min_i) or (p_i0 > p_shut_i):\n                forced_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min_i:\n                forced_off.append(i)\n                \n    committed = set(forced_on)\n    min_output = [0.0] * n\n    max_output = [0.0] * n\n    \n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        min_output[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n        max_output[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        total_min += min_output[i]\n        total_max += max_output[i]\n        \n    candidates = []\n    \n    for i in range(n):\n        if i in committed or i in forced_off:\n            continue\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        if u_i0 == 1:\n            adjusted_cost = (unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            candidates.append((i, adjusted_cost, 'A', min_bound, max_bound))\n        else:\n            adjusted_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i']**2)) / unit['p_min_i']\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, adjusted_cost, 'B', min_bound, max_bound))\n            \n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        \n    for i, cost, typ, min_b, max_b in candidates:\n        if total_max >= load:\n            break\n        committed.add(i)\n        min_output[i] = min_b\n        max_output[i] = max_b\n        total_min += min_b\n        total_max += max_b\n        \n    dispatch_target = load\n    if total_min >= total_max:\n        dispatch_target = total_min\n    else:\n        if dispatch_target < total_min:\n            dispatch_target = total_min\n        elif dispatch_target > total_max:\n            dispatch_target = total_max\n            \n    p_dispatch = [0.0] * n\n    if committed:\n        low_lambda = 0.0\n        high_lambda = 10000.0\n        tol = 0.01\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                a_i = unit['a_i']\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_min_i = min_output[i]\n                p_max_i = max_output[i]\n                \n                if c_i == 0:\n                    if mid_lambda <= b_i:\n                        power = p_min_i\n                    else:\n                        power = p_max_i\n                else:\n                    unconstrained = (mid_lambda - b_i) / (2 * c_i)\n                    if unconstrained < p_min_i:\n                        power = p_min_i\n                    elif unconstrained > p_max_i:\n                        power = p_max_i\n                    else:\n                        power = unconstrained\n                p_dispatch[i] = power\n                total_power += power\n                \n            if abs(total_power - dispatch_target) <= tol:\n                break\n                \n            if total_power < dispatch_target:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n                \n    u_final = [0] * n\n    p_final = [0.0] * n\n    for i in range(n):\n        if i in committed:\n            u_final[i] = 1\n            p_final[i] = p_dispatch[i]\n            \n    return np.array([u_final, p_final])",
     "from": "mutation",
     "gap_power_rate": 0.00543,
     "gap_price_rate": 0.00878,
     "fitness": 0.00711
}