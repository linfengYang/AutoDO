{
     "name": "greedy_rolling_commitment",
     "algorithm": "1. Identify forced-on units (must remain online due to minimum up-time or shutdown ramp violations) and forced-off units (must remain offline due to minimum down-time constraints).\n2. Initialize committed units as forced-on units. Calculate current minimum and maximum feasible output from committed units considering ramp limits.\n3. If current maximum output is insufficient to meet load, turn on free units (sorted by average cost at minimum output) until capacity is sufficient.\n4. Determine dispatch target as load clamped between total minimum and maximum feasible outputs.\n5. Dispatch the target power among committed units using lambda iteration to minimize generation cost:\n   - For units previously online, constrain output by ramp limits.\n   - For newly started units, constrain output by startup ramp limits.\n   - Solve using bisection on lambda to match target load.\n6. For non-committed units, set commitment state to 0 and output to 0.\n7. Return commitment states and power outputs for all units.\n\n",
     "code": "import numpy as np\n\ndef greedy_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    committed = forced_on.copy()\n    P_min = 0.0\n    P_max = 0.0\n    ramp_lows = [0] * n_units\n    ramp_highs = [0] * n_units\n    \n    for i in forced_on:\n        unit = units_info[i]\n        ramp_lows[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ramp_highs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        P_min += ramp_lows[i]\n        P_max += ramp_highs[i]\n    \n    if P_max < load:\n        free_costs = []\n        for i in free_units:\n            unit = units_info[i]\n            if unit['p_min_i'] > 0:\n                avg_cost = (unit['a_i'] + unit['s_i'] + unit['b_i']*unit['p_min_i'] + \n                            unit['c_i']*(unit['p_min_i']**2)) / unit['p_min_i']\n            else:\n                avg_cost = float('inf')\n            free_costs.append((i, avg_cost))\n        free_costs.sort(key=lambda x: x[1])\n        \n        for idx, _ in free_costs:\n            unit = units_info[idx]\n            new_low = unit['p_min_i']\n            new_high = min(unit['p_max_i'], unit['p_start_i'])\n            new_P_min = P_min + new_low\n            new_P_max = P_max + new_high\n            if new_P_max >= load:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n                break\n            else:\n                P_min = new_P_min\n                P_max = new_P_max\n                ramp_lows[idx] = new_low\n                ramp_highs[idx] = new_high\n                committed.append(idx)\n    \n    target = max(P_min, min(P_max, load))\n    if len(committed) > 0:\n        lows = []\n        highs = []\n        bs = []\n        cs = []\n        for i in committed:\n            unit = units_info[i]\n            if unit['u_i_0'] == 0 or i in free_units:\n                new_low = unit['p_min_i']\n                new_high = min(unit['p_max_i'], unit['p_start_i'])\n                ramp_lows[i] = new_low\n                ramp_highs[i] = new_high\n            lows.append(ramp_lows[i])\n            highs.append(ramp_highs[i])\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n        \n        n = len(committed)\n        lambda_low = min(2 * cs[i] * lows[i] + bs[i] for i in range(n))\n        lambda_high = max(2 * cs[i] * highs[i] + bs[i] for i in range(n))\n        lambda_low = max(0, lambda_low - 1000)\n        lambda_high = lambda_high + 1000\n        \n        total_p = 0.0\n        p_alloc = [0.0] * n\n        tol = 1e-3\n        max_iter = 1000\n        iter_count = 0\n        \n        while iter_count < max_iter:\n            total_p = 0.0\n            lambda_val = (lambda_low + lambda_high) / 2.0\n            for i in range(n):\n                if cs[i] == 0:\n                    p_i = highs[i] if lambda_val > bs[i] else lows[i]\n                else:\n                    p_i = (lambda_val - bs[i]) / (2 * cs[i])\n                    if p_i < lows[i]:\n                        p_i = lows[i]\n                    elif p_i > highs[i]:\n                        p_i = highs[i]\n                p_alloc[i] = p_i\n                total_p += p_i\n            \n            if abs(total_p - target) < tol:\n                break\n            elif total_p < target:\n                lambda_low = lambda_val\n            else:\n                lambda_high = lambda_val\n            iter_count += 1\n        \n        for i, idx in enumerate(committed):\n            p_out[idx] = p_alloc[i]\n            u_out[idx] = 1\n    for i in committed:\n        u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
     "from": null,
     "gap_power_rate": 0.0058,
     "gap_price_rate": 0.00917,
     "fitness": 0.00748
}