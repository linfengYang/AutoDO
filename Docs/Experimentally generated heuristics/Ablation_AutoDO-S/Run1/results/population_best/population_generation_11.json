{
     "name": "refined_optimized_rolling_commitment_v3_improved",
     "algorithm": "1. Classify units into must-on (previously online with unfulfilled min up-time or shutdown constraint), must-off (previously offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable)\n2. Commit must-on and free-on units as initial set\n3. Compute effective min/max outputs: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments\n4. Decommit free-on units by descending (a_i + b_i * eff_min_i + c_i * eff_min_i\u00b2)/eff_min_i until total min output \u2264 current load\n5. Commit free-off units by ascending (s_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2)/p_min_i until total max output \u2265 current load\n6. Decommit non-essential free-on units by descending cost/MW at eff_min_i if removal maintains total max \u2265 load\n7. Commit free-off units by ascending startup-adjusted cost at eff_min_i until total max output \u2265 load\n8. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: perform economic dispatch via lambda iteration with 100 bisection steps\n   d) Adjust residual by increasing cheapest marginal cost units first for shortages, decreasing most expensive first for surpluses\n9. Set non-committed units to off (0 output)\n10. Return schedules with commitment states and power outputs\n\n",
     "code": "import numpy as np\n\ndef refined_optimized_rolling_commitment_v3_improved(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed = []\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n                committed.append(i)\n            else:\n                free_on.append(i)\n                committed.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    eff_min = [0] * n_units\n    eff_max = [0] * n_units\n    \n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            eff_min[i] = units_info[i]['p_min_i']\n            eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(eff_min)\n    total_max = sum(eff_max)\n    \n    free_on_committed = [i for i in free_on if i in committed]\n    metric_decommit1 = []\n    for i in free_on_committed:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i]\n        metric_decommit1.append((metric, i))\n    metric_decommit1.sort(key=lambda x: x[0], reverse=True)\n    \n    for metric, i in metric_decommit1:\n        if total_min <= current_load:\n            break\n        committed.remove(i)\n        total_min -= eff_min[i]\n        total_max -= eff_max[i]\n        eff_min[i] = eff_max[i] = 0\n    \n    free_off_not_committed = [i for i in free_off if i not in committed]\n    metric_commit = []\n    for i in free_off_not_committed:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        metric = cost / unit['p_min_i']\n        metric_commit.append((metric, i))\n    metric_commit.sort(key=lambda x: x[0])\n    \n    for metric, i in metric_commit:\n        if total_max >= current_load:\n            break\n        eff_min_i = units_info[i]['p_min_i']\n        eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.append(i)\n        eff_min[i] = eff_min_i\n        eff_max[i] = eff_max_i\n        total_min += eff_min_i\n        total_max += eff_max_i\n    \n    free_on_committed_now = [i for i in free_on if i in committed and i not in must_on]\n    metric_decommit2 = []\n    for i in free_on_committed_now:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i]\n        metric_decommit2.append((metric, i))\n    metric_decommit2.sort(key=lambda x: x[0], reverse=True)\n    \n    for metric, i in metric_decommit2:\n        if total_max - eff_max[i] >= current_load:\n            committed.remove(i)\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            eff_min[i] = eff_max[i] = 0\n    \n    free_off_not_committed_second = [i for i in free_off if i not in committed]\n    metric_commit2 = []\n    for i in free_off_not_committed_second:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        metric_commit2.append((metric, i))\n    metric_commit2.sort(key=lambda x: x[0])\n    \n    for metric, i in metric_commit2:\n        if total_max >= current_load:\n            break\n        eff_min_i = units_info[i]['p_min_i']\n        eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.append(i)\n        eff_min[i] = eff_min_i\n        eff_max[i] = eff_max_i\n        total_min += eff_min_i\n        total_max += eff_max_i\n    \n    p = [0] * n_units\n    \n    if current_load <= total_min:\n        for i in committed:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in committed:\n            p[i] = eff_max[i]\n    else:\n        lambda_low = min(unit['b_i'] + 2 * unit['c_i'] * eff_min[i] for i in committed)\n        lambda_high = max(unit['b_i'] + 2 * unit['c_i'] * eff_max[i] for i in committed)\n        if lambda_low == lambda_high:\n            lambda_high += 1.0\n        \n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_output = 0.0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    p_i_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_i_uncon = eff_min[i] if lambda_mid < unit['b_i'] else eff_max[i]\n                p_i = max(eff_min[i], min(eff_max[i], p_i_uncon))\n                p[i] = p_i\n                total_output += p_i\n            if total_output < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < 1e-5:\n                break\n        \n        total_output = sum(p[i] for i in committed)\n        residual = current_load - total_output\n        \n        if residual > 0:\n            unit_list = []\n            for i in committed:\n                unit = units_info[i]\n                avail = eff_max[i] - p[i]\n                if avail > 1e-3:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    unit_list.append((marginal_cost, avail, i))\n            unit_list.sort(key=lambda x: x[0])\n            for _, avail, i in unit_list:\n                if residual <= 0:\n                    break\n                add = min(residual, avail)\n                p[i] += add\n                residual -= add\n        elif residual < 0:\n            residual = abs(residual)\n            unit_list = []\n            for i in committed:\n                unit = units_info[i]\n                avail = p[i] - eff_min[i]\n                if avail > 1e-3:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    unit_list.append((marginal_cost, avail, i))\n            unit_list.sort(key=lambda x: x[0], reverse=True)\n            for _, avail, i in unit_list:\n                if residual <= 0:\n                    break\n                sub = min(residual, avail)\n                p[i] -= sub\n                residual -= sub\n    \n    u = [1 if i in committed else 0 for i in range(n_units)]\n    schedules = np.array([u, p])\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0033546861,
     "gap_price_rate": 0.0081315629,
     "fitness": 0.0057431245
}