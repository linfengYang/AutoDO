{
     "name": "evolved_rolling_commitment",
     "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), and free-off (offline but commitable)\n2. Commit must-on + free-on units\n3. Compute effective min/max outputs considering:\n   - For prev online units: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - For new starts: [p_min, min(p_max, startup_ramp)]\n4. Decommittable free-on units by highest cost/MW at min output until total min \u2264 load\n5. Committable free-off units by lowest cost/MW including startup until total max \u2265 load\n6. Decommittable free-on units with highest cost/MW at min output if non-essential\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with gradient clipping and residual adjustment\n8. Return schedules (u_i, p_i) for all units\n\n",
     "code": "import numpy as np\n\ndef evolved_rolling_commitment(units_info, load):\n    load0 = load[0]\n    n_units = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_outputs = {}\n    max_outputs = {}\n    \n    # Classify units (Step 1)\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < t_on_min) or (p0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            min_o = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_o = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            min_outputs[i] = min_o\n            max_outputs[i] = max_o\n        else:  # Previously offline\n            if abs(t0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commit (Step 2)\n    committed = set(must_on) | set(free_on)\n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n    \n    # Decommit high-cost free-on if over-committed (Step 4)\n    high_cost_free_on = [i for i in free_on if i in committed]\n    high_cost_free_on.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in high_cost_free_on:\n        if total_min <= load0:\n            break\n        committed.remove(i)\n        total_min -= min_outputs[i]\n        total_max -= max_outputs[i]\n    \n    # Commit low-cost free-off if under-committed (Step 5)\n    low_cost_free_off = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in low_cost_free_off:\n        if total_max >= load0:\n            break\n        if i in committed:\n            continue\n        min_i = units_info[i]['p_min_i']\n        max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        min_outputs[i] = min_i\n        max_outputs[i] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Decommit non-essential high-cost free-on (Step 6)\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_committed:\n        new_min = total_min - min_outputs[i]\n        new_max = total_max - max_outputs[i]\n        if new_min <= load0 <= new_max:\n            committed.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch logic (Step 7)\n    p_alloc = [0] * n_units\n    u_alloc = [1 if i in committed else 0 for i in range(n_units)]\n    \n    if committed:\n        if load0 <= total_min:\n            for i in committed:\n                p_alloc[i] = min_outputs[i]\n        elif load0 >= total_max:\n            for i in committed:\n                p_alloc[i] = max_outputs[i]\n        else:\n            # Lambda iteration setup\n            low = 0\n            high = max(unit['b_i'] + 2 * unit['c_i'] * max_outputs[i] \n                      for i, unit in enumerate(units_info) if i in committed) * 2\n            tol = 0.01\n            iter_max = 100\n            iter_count = 0\n            \n            while iter_count < iter_max:\n                mid = (low + high) / 2.0\n                total_p = 0\n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        unconstrained = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                    else:\n                        unconstrained = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = np.clip(unconstrained, min_outputs[i], max_outputs[i])\n                    total_p += p_i\n                \n                if abs(total_p - load0) <= tol:\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] == 0:\n                            p_i = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                        else:\n                            p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                        p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n                    break\n                \n                if total_p < load0:\n                    low = mid\n                else:\n                    high = mid\n                iter_count += 1\n            \n            # Residual adjustment (if needed)\n            total_p = sum(p_alloc[i] for i in committed)\n            residual = load0 - total_p\n            if residual != 0:\n                candidates = []\n                for i in committed:\n                    if residual > 0 and p_alloc[i] < max_outputs[i]:\n                        margin = max_outputs[i] - p_alloc[i]\n                        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                        candidates.append((i, marginal_cost, margin))\n                    elif residual < 0 and p_alloc[i] > min_outputs[i]:\n                        margin = p_alloc[i] - min_outputs[i]\n                        marginal_cost = -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                        candidates.append((i, marginal_cost, margin))\n                \n                candidates.sort(key=lambda x: x[1])\n                for i, mc, margin in candidates:\n                    adjust = min(abs(residual), margin)\n                    if residual > 0:\n                        p_alloc[i] += adjust\n                        residual -= adjust\n                    else:\n                        p_alloc[i] -= adjust\n                        residual += adjust\n                    if abs(residual) < tol:\n                        break\n    \n    # Non-committed units\n    for i in range(n_units):\n        if not u_alloc[i]:\n            p_alloc[i] = 0\n    \n    return np.array([u_alloc, p_alloc])",
     "from": "crossover",
     "gap_power_rate": 0.0054285387,
     "gap_price_rate": 0.0091401447,
     "fitness": 0.0072843417
}