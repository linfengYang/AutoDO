{
     "name": "refined_evolved_rolling_commitment_v3",
     "algorithm": "1. Classify units into categories: must-on (previously online and violated min up-time or shutdown ramp constraint), must-off (previously offline and violated min down-time), free-on (previously online and commitable), free-off (previously offline and commitable)\n2. Initially commit must-on and free-on units\n3. Compute effective power limits considering ramp constraints:\n   - Previously online: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - New starts: [p_min, min(p_max, startup_ramp)]\n4. Decommit free-on units by highest cost per MW at effective min output ((a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211min_output \u2264 load\n5. Commit free-off units by lowest cost per MW including startup ((s_i + a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211max_output \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW (same metric) if removal maintains \u2211max_output \u2265 load\n7. Dispatch using bisection method to find optimal lambda for economic dispatch with residual adjustment:\n   a) If load \u2264 total min: set all to min output\n   b) If load \u2265 total max: set all to max output\n   c) Else: find \u03bb such that \u2211clamped outputs equals load, then adjust residual by marginal cost order\n8. Set non-committed units to offline (0 output)\n",
     "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    if n_units == 0:\n        return schedules\n        \n    u_0 = [unit['u_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    startup_ramp = [unit['p_start_i'] for unit in units_info]\n    shutdown_cap = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_0[i] == 1: \n            must_on[i] = (t_0[i] < min_up[i]) or (p_0[i] > shutdown_cap[i])\n            free_on[i] = not must_on[i]\n        else:\n            must_off[i] = (-t_0[i] < min_down[i])\n            free_off[i] = not must_off[i]\n    \n    committed = must_on.copy()\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    for i in range(n_units):\n        if free_on[i]:\n            committed[i] = True\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed and total_min > current_load:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_min - eff_min[i] <= current_load:\n                break\n            committed[i] = False\n            eff_min[i] = eff_max[i] = 0.0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n    \n    free_off_available = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_available and total_max < current_load:\n        metric_commit = []\n        for i in free_off_available:\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            cost = s[i] + a[i] + b[i] * eff_min_i + c[i] * eff_min_i**2\n            metric_commit.append(cost / eff_min_i)\n        idx_sorted = np.argsort(metric_commit)\n        \n        for idx in idx_sorted:\n            i = free_off_available[idx]\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            if total_max + eff_max_i >= current_load:\n                break\n            committed[i] = True\n            eff_min[i] = eff_min_i\n            eff_max[i] = eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_max - eff_max[i] >= current_load:\n                committed[i] = False\n                eff_min[i] = eff_max[i] = 0.0\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n    \n    p = [0.0] * n_units\n    if not any(committed):\n        return np.array([committed, p])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    if current_load <= total_min:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_max[i]\n    else:\n        committed_units = [i for i in range(n_units) if committed[i]]\n        low = min(2 * c[i] * eff_min[i] + b[i] for i in committed_units) - 100\n        high = max(2 * c[i] * eff_max[i] + b[i] for i in committed_units) + 100\n        \n        for _ in range(100):\n            lamb = (low + high) / 2\n            p_temp = []\n            total_p = 0.0\n            for i in committed_units:\n                p_i = (lamb - b[i]) / (2 * c[i])\n                p_i = max(eff_min[i], min(eff_max[i], p_i))\n                p_temp.append(p_i)\n                total_p += p_i\n            \n            if total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n        \n        residual = current_load - total_p\n        if residual != 0:\n            if residual > 0:\n                eligible = [(i, p_temp[k], eff_max[i]) for k, i in enumerate(committed_units) if p_temp[k] < eff_max[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]))\n                for i, current, upper in eligible:\n                    available = upper - current\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = upper\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] += residual\n                        residual = 0\n                        break\n            else:\n                residual = abs(residual)\n                eligible = [(i, p_temp[k], eff_min[i]) for k, i in enumerate(committed_units) if p_temp[k] > eff_min[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]), reverse=True)\n                for i, current, lower in eligible:\n                    available = current - lower\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = lower\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] -= residual\n                        residual = 0\n                        break\n            \n            total_p = sum(p_temp)\n            residual_final = current_load - total_p\n            if residual_final != 0:\n                avg_adjust = residual_final / len(committed_units)\n                p_temp = [min(eff_max[i], max(eff_min[i], p_temp[k] + avg_adjust)) for k, i in enumerate(committed_units)]\n                total_p = sum(p_temp)\n                remaining_adjust = current_load - total_p\n                if remaining_adjust > 0:\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, eff_max[i] - p_temp[k])\n                        p_temp[k] += diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n                elif remaining_adjust < 0:\n                    remaining_adjust = abs(remaining_adjust)\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, p_temp[k] - eff_min[i])\n                        p_temp[k] -= diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n        \n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n        else:\n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n    \n    schedules[0] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1] = p\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.00543839,
     "gap_price_rate": 0.0077145078,
     "fitness": 0.0065764489
}