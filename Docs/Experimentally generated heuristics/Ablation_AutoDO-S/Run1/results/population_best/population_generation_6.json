{
     "name": "refined_evolved_rolling_commitment_v2",
     "algorithm": "1. Classify units into must-on (prev online and (min up-time unfulfilled or prev output > shutdown capacity), must-off (prev offline and min down-time unfulfilled), free-on (prev online but decommittable), free-off (prev offline but committable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost/MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + cost at min)/min_output until total max \u2265 load\n6. While possible, decommit free-on units with highest cost/MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection (100 iters) then residual adjustment via merit order\n8. Set non-committed units to offline (0 output)\n",
     "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters and initialize\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed = set()\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Was online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_on.append(i)\n                committed.add(i)\n            else:\n                free_on.append(i)\n                committed.add(i)\n        else:  # Was offline\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Prev online\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # New start (not possible here but safe)\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit free-on units if over-min\n    total_min = np.sum(eff_min[list(committed)])\n    free_on_in_committed = [i for i in free_on if i in committed]\n    \n    # Sort free-on by cost/MW at min desc\n    free_on_in_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        if i in committed:\n            committed.remove(i)\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit free-off units if under-max\n    total_max = np.sum(eff_max[list(committed)])\n    # Precompute new start effective max/min\n    for i in free_off:\n        unit = units_info[i]\n        eff_min[i] = unit['p_min_i']\n        eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Sort free-off by (startup cost + cost at min)/min\n    free_off_sorted = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        if i not in committed:\n            committed.add(i)\n            total_max += eff_max[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    removed = True\n    while removed:\n        removed = False\n        total_max = np.sum(eff_max[list(committed)])\n        free_on_committed = [i for i in free_on if i in committed]\n        free_on_committed.sort(key=lambda i: (\n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n        ) / units_info[i]['p_min_i'], reverse=True)\n        \n        for i in free_on_committed:\n            if total_max - eff_max[i] >= current_load:\n                committed.remove(i)\n                removed = True\n                break\n    \n    # Step 7: Dispatch\n    # Recompute effective min/max for final committed set\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[list(committed)])\n    total_max = np.sum(eff_max[list(committed)])\n    \n    comm_list = list(committed)\n    if current_load <= total_min:\n        for i in comm_list:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in comm_list:\n            p[i] = eff_max[i]\n    else:\n        # Lambda iteration\n        a = [units_info[i]['a_i'] for i in comm_list]\n        b = [units_info[i]['b_i'] for i in comm_list]\n        c = [units_info[i]['c_i'] for i in comm_list]\n        lows = [eff_min[i] for i in comm_list]\n        highs = [eff_max[i] for i in comm_list]\n        n_comm = len(comm_list)\n        \n        # Find lambda range\n        lo = min(b_i + 2*c_i*low_i for (b_i, c_i, low_i) in zip(b, c, lows))\n        hi = max(b_i + 2*c_i*high_i for (b_i, c_i, high_i) in zip(b, c, highs))\n        \n        # Bisection\n        for _ in range(100):\n            lam = (lo + hi) / 2\n            total_p = 0\n            for i in range(n_comm):\n                mc_low = b[i] + 2*c[i]*lows[i]\n                mc_high = b[i] + 2*c[i]*highs[i]\n                if lam < mc_low:\n                    p_i = lows[i]\n                elif lam > mc_high:\n                    p_i = highs[i]\n                else:\n                    p_i = (lam - b[i]) / (2*c[i])\n                total_p += p_i\n            \n            if total_p < current_load:\n                lo = lam\n            else:\n                hi = lam\n        \n        # Calculate p based on final lambda\n        total_p = 0\n        p_dispatch = [0] * n_comm\n        for i in range(n_comm):\n            mc_low = b[i] + 2*c[i]*lows[i]\n            mc_high = b[i] + 2*c[i]*highs[i]\n            if lam < mc_low:\n                p_i = lows[i]\n            elif lam > mc_high:\n                p_i = highs[i]\n            else:\n                p_i = (lam - b[i]) / (2*c[i])\n            p_dispatch[i] = p_i\n            total_p += p_i\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        tol = 1e-5\n        if residual > tol:\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] < highs[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx])\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = highs[idx] - p_dispatch[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] += adjust\n                residual -= adjust\n        elif residual < -tol:\n            residual = -residual\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] > lows[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx], reverse=True)\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = p_dispatch[idx] - lows[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] -= adjust\n                residual -= adjust\n        \n        # Assign dispatched values\n        for ii, i in enumerate(comm_list):\n            p[i] = p_dispatch[ii]\n    \n    # Set commitments and output for non-committed\n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0054285365,
     "gap_price_rate": 0.0091401443,
     "fitness": 0.0072843404
}