{
     "name": "refined_rolling_commitment",
     "algorithm": "1. Classify units into must-run (min up-time/shotdown ramp constraints), must-off (min down-time), free-on (online freely decommitable), and free-off (offline freely commitable)\n2. Commit must-run and free-on units\n3. Compute effective min/max outputs considering ramp constraints (ramp limits, startup/shutdown ramp limits)\n4. If total min output exceeds load:\n   - Decommit free-on units with largest min outputs until feasibility is restored\n5. If total max output is below load:\n   - Commit free-off units with lowest cost per MW at min output until capacity suffices\n6. Decommit unnecessary free-on units with highest operating cost at min output if feasible\n7. Dispatch committed units:\n   - If load <= total min: set to min outputs\n   - If load >= total max: set to max outputs\n   - Else: perform lambda iteration economic dispatch with clamped gradients\n   - Apply final adjustments to balance residual load\n8. Return schedules (u_i, p_i) for all units\n\n",
     "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Initialize classification lists\n    must_on = []\n    free_on = []\n    free_off = []\n    min_eff = [0.0] * n_units\n    max_eff = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                continue  # must_off handled by omission\n            else:\n                free_off.append(i)\n    \n    # Initialize committed set\n    committed = set(must_on)\n    committed.update(free_on)\n    \n    # Step 2 & 3: Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if i in committed and unit['u_i_0'] == 1:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff[i] = 0.0\n            max_eff[i] = 0.0\n    \n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Step 4: Decommit free-on units if overcommitted\n    if total_min > current_load:\n        sorted_free_on = sorted(\n            [i for i in free_on if i in committed],\n            key=lambda i: min_eff[i],\n            reverse=True\n        )\n        for i in sorted_free_on:\n            cand_min = total_min - min_eff[i]\n            cand_max = total_max - max_eff[i]\n            if cand_min <= current_load <= cand_max:\n                committed.remove(i)\n                total_min = cand_min\n                total_max = cand_max\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Commit free-off units if undercommitted\n    if total_max < current_load:\n        def cost_priority(i):\n            unit = units_info[i]\n            startup = unit['s_i']\n            prod_cost = unit['a_i'] + unit['b_i']*min_eff[i] + unit['c_i']*min_eff[i]**2\n            return (startup + prod_cost) / (min_eff[i] + 1e-9)\n        \n        sorted_free_off = sorted(\n            [i for i in free_off if i not in committed],\n            key=cost_priority\n        )\n        for i in sorted_free_off:\n            cand_min = total_min + min_eff[i]\n            cand_max = total_max + max_eff[i]\n            committed.add(i)\n            total_min = cand_min\n            total_max = cand_max\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit unnecessary free-on units by cost\n    def operating_cost(i):\n        unit = units_info[i]\n        return unit['a_i'] + unit['b_i']*min_eff[i] + unit['c_i']*min_eff[i]**2\n    \n    expensive_free_on = sorted(\n        [i for i in free_on if i in committed],\n        key=operating_cost,\n        reverse=True\n    )\n    for i in expensive_free_on:\n        cand_min = total_min - min_eff[i]\n        cand_max = total_max - max_eff[i]\n        if cand_min <= current_load <= cand_max:\n            committed.remove(i)\n            total_min = cand_min\n            total_max = cand_max\n    \n    # Recompute final constraints\n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            min_eff[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:  # Started this period\n            min_eff[i] = units_info[i]['p_min_i']\n            max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Step 7: Dispatch\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = min_eff[i]\n            u[i] = 1\n    elif current_load >= total_max:\n        for i in committed:\n            p[i] = max_eff[i]\n            u[i] = 1\n    else:  # Lambda iteration with clamping\n        # Initialize lambda bounds\n        low = float('inf')\n        high = -float('inf')\n        for i in committed:\n            unit = units_info[i]\n            low = min(low, unit['b_i'] + 2*unit['c_i']*min_eff[i])\n            high = max(high, unit['b_i'] + 2*unit['c_i']*max_eff[i])\n        \n        tol = 1e-3\n        max_iter = 1000\n        for _ in range(max_iter):\n            lambda_mid = (low + high) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                c_val = unit['c_i']\n                b_val = unit['b_i']\n                if c_val == 0:\n                    p_i = max_eff[i] if lambda_mid > b_val else min_eff[i]\n                else:\n                    p_i = (lambda_mid - b_val) / (2 * c_val)\n                    p_i = max(min_eff[i], min(max_eff[i], p_i))\n                p[i] = p_i\n                total_power += p_i\n            \n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                low = lambda_mid\n            else:\n                high = lambda_mid\n        \n        # Residual adjustment\n        total_power = sum(p[i] for i in committed)\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            adjustments = []\n            for i in committed:\n                if residual > 0 and p[i] < max_eff[i]:\n                    headroom = max_eff[i] - p[i]\n                    marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    adjustments.append((marginal, i, headroom))\n                elif residual < 0 and p[i] > min_eff[i]:\n                    headroom = p[i] - min_eff[i]\n                    marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    adjustments.append((marginal, i, headroom))\n            \n            if residual > 0:\n                adjustments.sort(key=lambda x: x[0])\n            else:\n                adjustments.sort(key=lambda x: x[0], reverse=True)\n            \n            for _, i, headroom in adjustments:\n                delta = min(headroom, abs(residual)) * np.sign(residual)\n                p[i] += delta\n                residual -= delta\n                if abs(residual) < tol:\n                    break\n        for i in committed:\n            u[i] = 1\n    \n    # Set non-committed units\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u\n    schedules[1, :] = p\n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0054286362,
     "gap_price_rate": 0.0091472287,
     "fitness": 0.0072879324
}