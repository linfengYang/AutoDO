[
     {
          "name": "refined_evolved_rolling_commitment_v3",
          "algorithm": "1. Classify units into categories: must-on (previously online and violated min up-time or shutdown ramp constraint), must-off (previously offline and violated min down-time), free-on (previously online and commitable), free-off (previously offline and commitable)\n2. Initially commit must-on and free-on units\n3. Compute effective power limits considering ramp constraints:\n   - Previously online: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - New starts: [p_min, min(p_max, startup_ramp)]\n4. Decommit free-on units by highest cost per MW at effective min output ((a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211min_output \u2264 load\n5. Commit free-off units by lowest cost per MW including startup ((s_i + a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211max_output \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW (same metric) if removal maintains \u2211max_output \u2265 load\n7. Dispatch using bisection method to find optimal lambda for economic dispatch with residual adjustment:\n   a) If load \u2264 total min: set all to min output\n   b) If load \u2265 total max: set all to max output\n   c) Else: find \u03bb such that \u2211clamped outputs equals load, then adjust residual by marginal cost order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    if n_units == 0:\n        return schedules\n        \n    u_0 = [unit['u_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    startup_ramp = [unit['p_start_i'] for unit in units_info]\n    shutdown_cap = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_0[i] == 1: \n            must_on[i] = (t_0[i] < min_up[i]) or (p_0[i] > shutdown_cap[i])\n            free_on[i] = not must_on[i]\n        else:\n            must_off[i] = (-t_0[i] < min_down[i])\n            free_off[i] = not must_off[i]\n    \n    committed = must_on.copy()\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    for i in range(n_units):\n        if free_on[i]:\n            committed[i] = True\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed and total_min > current_load:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_min - eff_min[i] <= current_load:\n                break\n            committed[i] = False\n            eff_min[i] = eff_max[i] = 0.0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n    \n    free_off_available = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_available and total_max < current_load:\n        metric_commit = []\n        for i in free_off_available:\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            cost = s[i] + a[i] + b[i] * eff_min_i + c[i] * eff_min_i**2\n            metric_commit.append(cost / eff_min_i)\n        idx_sorted = np.argsort(metric_commit)\n        \n        for idx in idx_sorted:\n            i = free_off_available[idx]\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            if total_max + eff_max_i >= current_load:\n                break\n            committed[i] = True\n            eff_min[i] = eff_min_i\n            eff_max[i] = eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_max - eff_max[i] >= current_load:\n                committed[i] = False\n                eff_min[i] = eff_max[i] = 0.0\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n    \n    p = [0.0] * n_units\n    if not any(committed):\n        return np.array([committed, p])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    if current_load <= total_min:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_max[i]\n    else:\n        committed_units = [i for i in range(n_units) if committed[i]]\n        low = min(2 * c[i] * eff_min[i] + b[i] for i in committed_units) - 100\n        high = max(2 * c[i] * eff_max[i] + b[i] for i in committed_units) + 100\n        \n        for _ in range(100):\n            lamb = (low + high) / 2\n            p_temp = []\n            total_p = 0.0\n            for i in committed_units:\n                p_i = (lamb - b[i]) / (2 * c[i])\n                p_i = max(eff_min[i], min(eff_max[i], p_i))\n                p_temp.append(p_i)\n                total_p += p_i\n            \n            if total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n        \n        residual = current_load - total_p\n        if residual != 0:\n            if residual > 0:\n                eligible = [(i, p_temp[k], eff_max[i]) for k, i in enumerate(committed_units) if p_temp[k] < eff_max[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]))\n                for i, current, upper in eligible:\n                    available = upper - current\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = upper\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] += residual\n                        residual = 0\n                        break\n            else:\n                residual = abs(residual)\n                eligible = [(i, p_temp[k], eff_min[i]) for k, i in enumerate(committed_units) if p_temp[k] > eff_min[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]), reverse=True)\n                for i, current, lower in eligible:\n                    available = current - lower\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = lower\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] -= residual\n                        residual = 0\n                        break\n            \n            total_p = sum(p_temp)\n            residual_final = current_load - total_p\n            if residual_final != 0:\n                avg_adjust = residual_final / len(committed_units)\n                p_temp = [min(eff_max[i], max(eff_min[i], p_temp[k] + avg_adjust)) for k, i in enumerate(committed_units)]\n                total_p = sum(p_temp)\n                remaining_adjust = current_load - total_p\n                if remaining_adjust > 0:\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, eff_max[i] - p_temp[k])\n                        p_temp[k] += diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n                elif remaining_adjust < 0:\n                    remaining_adjust = abs(remaining_adjust)\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, p_temp[k] - eff_min[i])\n                        p_temp[k] -= diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n        \n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n        else:\n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n    \n    schedules[0] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00543839,
          "gap_price_rate": 0.0077145078,
          "fitness": 0.0065764489
     },
     {
          "name": "optimized_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable). \n2. Commit must-on and free-on units as initial set. \n3. Compute effective min/max outputs considering ramp constraints: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments. \n4. Decommit free-on units by highest cost/MW (a_i + b_i * eff_min_i + c_i * eff_min_i^2)/eff_min_i until total min output \u2264 current load. \n5. Commit free-off units by lowest (s_i + a_i + b_i * p_min_i + c_i * p_min_i^2)/p_min_i until total max output \u2265 current load. \n6. Decommit remaining free-on units in descending order of cost/MW at effective min if removal maintains total max \u2265 load. \n7. Dispatch: \n   a) If load \u2264 total min: set outputs to effective min \n   b) If load \u2265 total max: set outputs to effective max \n   c) Else: perform economic dispatch via lambda iteration with bisection (100 iterations) followed by residual adjustment based on marginal cost merit order. \n8. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize units arrays\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    is_must_on = np.zeros(n_units, dtype=bool)\n    is_must_off = np.zeros(n_units, dtype=bool)\n    is_free_on = np.zeros(n_units, dtype=bool)\n    is_free_off = np.zeros(n_units, dtype=bool)\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    headroom = np.zeros(n_units)\n    min_costs = np.zeros(n_units)\n    startup_metrics = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    \n    # Step 1: Classify units\n    is_must_on = (u0 == 1) & ((t0 < min_up) | (p0 > p_shut))\n    is_must_off = (u0 == 0) & (t0 > -min_down)\n    is_free_on = (u0 == 1) & (~is_must_on)\n    is_free_off = (u0 == 0) & (~is_must_off)\n    \n    # Step 2: Initial commit (must-on + free-on)\n    u[is_must_on | is_free_on] = 1\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in range(n_units):\n        if u[i]:\n            if u0[i]:  # Previously online\n                effective_min[i] = max(p_min[i], p0[i] - p_down[i])\n                effective_max[i] = min(p_max[i], p0[i] + p_up[i])\n            else:  # New start\n                effective_min[i] = p_min[i]\n                effective_max[i] = min(p_max[i], p_start[i])\n        else:\n            effective_min[i] = effective_max[i] = 0.0\n    \n    total_min = np.sum(effective_min[u == 1])\n    total_max = np.sum(effective_max[u == 1])\n    \n    # Step 4: Decommit expensive free-on units\n    if total_min > current_load:\n        # Calculate min cost per MW\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            if total_min <= current_load:\n                break\n            unit_idx = free_on_indices[idx]\n            if u[unit_idx]:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 5: Commit cheap free-off units\n    if total_max < current_load:\n        # Calculate startup metric\n        startup_metrics = (startup_cost[is_free_off] + a[is_free_off] +\n                           b[is_free_off] * p_min[is_free_off] + \n                           c[is_free_off] * p_min[is_free_off]**2) / p_min[is_free_off]\n        free_off_indices = np.where(is_free_off)[0]\n        sort_indices = np.argsort(startup_metrics)\n        \n        for idx in sort_indices:\n            unit_idx = free_off_indices[idx]\n            new_min = p_min[unit_idx]\n            new_max = min(p_max[unit_idx], p_start[unit_idx])\n            if total_max + new_max >= current_load:\n                break\n            u[unit_idx] = 1\n            effective_min[unit_idx] = new_min\n            effective_max[unit_idx] = new_max\n            total_min += new_min\n            total_max += new_max\n    \n    # Step 6: Decommit non-essential free-on units\n    if any(is_free_on & u.astype(bool)):\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on & u)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            unit_idx = free_on_indices[idx]\n            if total_max - effective_max[unit_idx] >= current_load:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 7: Dispatch power to committed units\n    if current_load <= total_min:\n        p = np.where(u, effective_min, 0.0)\n    elif current_load >= total_max:\n        p = np.where(u, effective_max, 0.0)\n    else:\n        # Get indices of committed units\n        committed_idx = np.where(u)[0]\n        comm_min = effective_min[committed_idx]\n        comm_max = effective_max[committed_idx]\n        comm_a = a[committed_idx]\n        comm_b = b[committed_idx]\n        comm_c = c[committed_idx]\n        \n        # Bisection method setup\n        lambda_low = np.min(comm_b + 2 * comm_c * comm_min)\n        lambda_high = np.max(comm_b + 2 * comm_c * comm_max)\n        tolerance = 1e-5\n        \n        # Run bisection\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_set = np.clip((lambda_mid - comm_b) / (2 * comm_c + 1e-10), comm_min, comm_max)\n            total_power = np.sum(p_set)\n            \n            if abs(total_power - current_load) < tolerance:\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Residual adjustment\n        deficit = current_load - total_power\n        if abs(deficit) > tolerance:\n            # Compute marginal cost at current setpoints\n            marginal_costs = comm_b + 2 * comm_c * p_set\n            headroom = comm_max - p_set\n            \n            # Merit order for deficit adjustment\n            if deficit > 0:\n                priority_order = np.argsort(marginal_costs)\n                for idx in priority_order:\n                    if deficit <= 0:\n                        break\n                    if headroom[idx] > 0:\n                        adjust = min(headroom[idx], deficit)\n                        p_set[idx] += adjust\n                        deficit -= adjust\n            else:  # surplus (negative deficit)\n                surplus = -deficit\n                priority_order = np.argsort(marginal_costs)[::-1]\n                for idx in priority_order:\n                    if surplus <= 0:\n                        break\n                    avail = p_set[idx] - comm_min[idx]\n                    if avail > 0:\n                        adjust = min(avail, surplus)\n                        p_set[idx] -= adjust\n                        surplus -= adjust\n        \n        # Assign dispatch values\n        p[committed_idx] = p_set\n    \n    # Step 8: Set non-committed units\n    p[u == 0] = 0.0\n    \n    # Prepare output array\n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0061078301,
          "gap_price_rate": 0.0078211476,
          "fitness": 0.0069644889
     },
     {
          "name": "refined_optimized_rolling_commitment",
          "algorithm": "1. Classify units into must_on (previous online and (min up-time unfulfilled or previous output > shutdown capacity), must_off (previous offline and min down-time unfulfilled), free_on (previously online and decommitable), free_off (previously offline and commitable). 2. Initially commit must_on and free_on units. 3. Compute effective min/max: for previously online units use ramp constraints [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]; for free_off units [p_min, min(p_max, startup_ramp)]. 4. Decommit free_on units by highest cost/MW at min_eff until total_min_eff \u2264 load. 5. Commit free_off units by lowest (startup_cost + cost at min_output)/min_output until total_max_eff \u2265 load. 6. Decommit non-essential free_on units by highest cost/MW at min_eff if removal maintains total_max_eff \u2265 load. 7. Decommit committed free_off units by highest cost/MW at min_output if removal maintains total_max_eff \u2265 load. 8. Dispatch: if load \u2264 total_min use min outputs; if load \u2265 total_max use max outputs; else perform lambda iteration (100 bisection steps) with clamping and residual adjustment.\n",
          "code": "import numpy as np\n\ndef refined_optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min) or (p_i0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            u_current[i] = 1\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if t_i0 > -t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            u_current[i] = 0\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commitment\n    u_current[[must_on + free_on]] = 1\n    total_min = sum(min_eff[must_on + free_on])\n    total_max = sum(max_eff[must_on + free_on])\n    \n    # Decommit free_on units if min capacity exceeds load\n    free_on_committed = [i for i in free_on if u_current[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_on_committed[idx]\n            if total_min > current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Commit free_off units if max capacity below load\n    free_off_available = [i for i in free_off if u_current[i] == 0]\n    if free_off_available:\n        cost_per_mw = []\n        eff_mins = []\n        eff_maxs = []\n        for i in free_off_available:\n            cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            eff_mins.append(min_eff[i])\n            eff_maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)\n        for idx in order:\n            i = free_off_available[idx]\n            if total_max < current_load:\n                u_current[i] = 1\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n    \n    # Decommit non-essential free_on units\n    free_on_committed = [i for i in free_on if u_current[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        maxs = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_on_committed[idx]\n            if (total_max - max_eff[i]) >= current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Decommit non-essential free_off units\n    free_off_committed = [i for i in free_off if u_current[i] == 1]\n    if free_off_committed:\n        cost_per_mw = []\n        maxs = []\n        for i in free_off_committed:\n            cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_off_committed[idx]\n            if (total_max - max_eff[i]) >= current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Dispatch\n    committed = np.where(u_current == 1)[0]\n    if not committed.size:\n        return np.array([u_current, p_current])\n    \n    total_committed_min = min_eff[committed].sum()\n    total_committed_max = max_eff[committed].sum()\n    \n    if current_load <= total_committed_min:\n        for i in committed:\n            p_current[i] = min_eff[i]\n    elif current_load >= total_committed_max:\n        for i in committed:\n            p_current[i] = max_eff[i]\n    else:\n        a = np.array([units_info[i]['a_i'] for i in committed])\n        b = np.array([units_info[i]['b_i'] for i in committed])\n        c = np.array([units_info[i]['c_i'] for i in committed])\n        p_min = min_eff[committed]\n        p_max = max_eff[committed]\n        \n        lam_low = np.min(b + 2*c*p_min)\n        lam_high = np.max(b + 2*c*p_max)\n        p = np.zeros(len(committed))\n        iter_count = 100\n        \n        for _ in range(iter_count):\n            lam = (lam_low + lam_high) / 2\n            for j in range(len(committed)):\n                if c[j] == 0:\n                    if lam > b[j]:\n                        p[j] = p_max[j]\n                    else:\n                        p[j] = p_min[j]\n                else:\n                    p_unclamped = (lam - b[j]) / (2*c[j])\n                    p[j] = np.clip(p_unclamped, p_min[j], p_max[j])\n            total_p = np.sum(p)\n            if abs(total_p - current_load) < 1e-6:\n                break\n            if total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > 1e-6:\n            if residual > 0:\n                candidates = [j for j in range(len(committed)) if p[j] < p_max[j]]\n                marginal_costs = b + 2*c*p\n                candidates.sort(key=lambda j: marginal_costs[j])\n                for j in candidates:\n                    if residual <= 0:\n                        break\n                    available = p_max[j] - p[j]\n                    add = min(available, residual)\n                    p[j] += add\n                    residual -= add\n            else:\n                residual = abs(residual)\n                candidates = [j for j in range(len(committed)) if p[j] > p_min[j]]\n                marginal_costs = b + 2*c*p\n                candidates.sort(key=lambda j: marginal_costs[j], reverse=True)\n                for j in candidates:\n                    if residual <= 0:\n                        break\n                    available = p[j] - p_min[j]\n                    reduce_by = min(available, residual)\n                    p[j] -= reduce_by\n                    residual -= reduce_by\n        \n        p_current[committed] = p\n    \n    return np.array([u_current, p_current])",
          "from": "mutation",
          "gap_power_rate": 0.0050015901,
          "gap_price_rate": 0.0092352064,
          "fitness": 0.0071183982
     },
     {
          "name": "refined_evolved_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Preallocate arrays\n    u = np.zeros(n_units)  # Commitment status\n    p = np.zeros(n_units)  # Output power\n    cat = [''] * n_units   # Unit categories\n    eff_min = np.zeros(n_units)  # Effective min output\n    eff_max = np.zeros(n_units)  # Effective max output\n    \n    # Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                cat[i] = 'must_on'\n                u[i] = 1\n            else:\n                cat[i] = 'free_on'\n                u[i] = 1\n        else:  # Previously offline\n            if t0 < 0 and (-t0) < unit['t_off_min_i']:\n                cat[i] = 'must_off'\n                u[i] = 0\n            else:\n                cat[i] = 'free_off'\n                u[i] = 0\n                \n    # Step 4: Decommit high-cost free-on units\n    free_on_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    total_min = sum(eff_min[i] for i in range(n_units) if u[i]==1)\n    \n    # Define cost per MW metric\n    def cost_metric(i, include_startup=False):\n        base = units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \\\n               units_info[i]['c_i'] * eff_min[i]**2\n        if include_startup:\n            base += units_info[i]['s_i']\n        denom = eff_min[i] if eff_min[i] >= 1e-5 else 1.0\n        return base / denom\n    \n    # Decommit free-on units until total_min \u2264 current_load\n    if total_min > current_load:\n        sorted_free_on = sorted(free_on_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit low-cost free-off units\n    total_max = sum(eff_max[i] for i in range(n_units) if u[i]==1)\n    free_off_idx = [i for i in range(n_units) if cat[i]=='free_off' and u[i]==0]\n    \n    if total_max < current_load:\n        sorted_free_off = sorted(free_off_idx, key=lambda i: cost_metric(i, include_startup=True))\n        for i in sorted_free_off:\n            u[i] = 1\n            total_max += eff_max[i]\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_rem_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    curr_total_max = total_max\n    \n    if free_on_rem_idx:\n        sorted_free_on_rem = sorted(free_on_rem_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on_rem:\n            new_total_max = curr_total_max - eff_max[i]\n            if new_total_max >= current_load:\n                u[i] = 0\n                curr_total_max = new_total_max\n    \n    # Dispatch committed units\n    committed_idx = [i for i in range(n_units) if u[i]==1]\n    total_min_comm = sum(eff_min[i] for i in committed_idx)\n    total_max_comm = sum(eff_max[i] for i in committed_idx)\n    \n    if committed_idx:\n        if current_load <= total_min_comm:\n            for i in committed_idx:\n                p[i] = eff_min[i]\n        elif current_load >= total_max_comm:\n            for i in committed_idx:\n                p[i] = eff_max[i]\n        else:\n            # Bisection for lambda\n            low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_min[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_min[i] > 0)\n            high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_max[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_max[i] > 0)\n            \n            for _ in range(100):\n                lam = (low + high) / 2\n                total_p = 0.0\n                for i in committed_idx:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_unclamp = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_i = max(eff_min[i], min(eff_max[i], p_unclamp))\n                    else:\n                        p_i = eff_max[i] if lam > unit['b_i'] else eff_min[i]\n                    p[i] = p_i\n                    total_p += p_i\n                \n                if total_p < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Residual adjustment\n            residual = current_load - total_p\n            if residual > 0:\n                candidates = [i for i in committed_idx if p[i] < eff_max[i]]\n                candidates.sort(key=lambda i: unit['b_i'] + 2 * unit['c_i'] * p[i])\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    inc = min(residual, eff_max[i] - p[i])\n                    p[i] += inc\n                    residual -= inc\n            elif residual < 0:\n                residual = abs(residual)\n                candidates = [i for i in committed_idx if p[i] > eff_min[i]]\n                candidates.sort(key=lambda i: -(unit['b_i'] + 2 * unit['c_i'] * p[i]))\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    dec = min(residual, p[i] - eff_min[i])\n                    p[i] -= dec\n                    residual -= dec\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0046081286,
          "gap_price_rate": 0.0097404235,
          "fitness": 0.0071742761
     },
     {
          "name": "refined_evolved_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on (prev online and (min up-time unfulfilled or prev output > shutdown capacity), must-off (prev offline and min down-time unfulfilled), free-on (prev online but decommittable), free-off (prev offline but committable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost/MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + cost at min)/min_output until total max \u2265 load\n6. While possible, decommit free-on units with highest cost/MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection (100 iters) then residual adjustment via merit order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters and initialize\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed = set()\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Was online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_on.append(i)\n                committed.add(i)\n            else:\n                free_on.append(i)\n                committed.add(i)\n        else:  # Was offline\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Prev online\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # New start (not possible here but safe)\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit free-on units if over-min\n    total_min = np.sum(eff_min[list(committed)])\n    free_on_in_committed = [i for i in free_on if i in committed]\n    \n    # Sort free-on by cost/MW at min desc\n    free_on_in_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        if i in committed:\n            committed.remove(i)\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit free-off units if under-max\n    total_max = np.sum(eff_max[list(committed)])\n    # Precompute new start effective max/min\n    for i in free_off:\n        unit = units_info[i]\n        eff_min[i] = unit['p_min_i']\n        eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Sort free-off by (startup cost + cost at min)/min\n    free_off_sorted = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        if i not in committed:\n            committed.add(i)\n            total_max += eff_max[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    removed = True\n    while removed:\n        removed = False\n        total_max = np.sum(eff_max[list(committed)])\n        free_on_committed = [i for i in free_on if i in committed]\n        free_on_committed.sort(key=lambda i: (\n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n        ) / units_info[i]['p_min_i'], reverse=True)\n        \n        for i in free_on_committed:\n            if total_max - eff_max[i] >= current_load:\n                committed.remove(i)\n                removed = True\n                break\n    \n    # Step 7: Dispatch\n    # Recompute effective min/max for final committed set\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[list(committed)])\n    total_max = np.sum(eff_max[list(committed)])\n    \n    comm_list = list(committed)\n    if current_load <= total_min:\n        for i in comm_list:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in comm_list:\n            p[i] = eff_max[i]\n    else:\n        # Lambda iteration\n        a = [units_info[i]['a_i'] for i in comm_list]\n        b = [units_info[i]['b_i'] for i in comm_list]\n        c = [units_info[i]['c_i'] for i in comm_list]\n        lows = [eff_min[i] for i in comm_list]\n        highs = [eff_max[i] for i in comm_list]\n        n_comm = len(comm_list)\n        \n        # Find lambda range\n        lo = min(b_i + 2*c_i*low_i for (b_i, c_i, low_i) in zip(b, c, lows))\n        hi = max(b_i + 2*c_i*high_i for (b_i, c_i, high_i) in zip(b, c, highs))\n        \n        # Bisection\n        for _ in range(100):\n            lam = (lo + hi) / 2\n            total_p = 0\n            for i in range(n_comm):\n                mc_low = b[i] + 2*c[i]*lows[i]\n                mc_high = b[i] + 2*c[i]*highs[i]\n                if lam < mc_low:\n                    p_i = lows[i]\n                elif lam > mc_high:\n                    p_i = highs[i]\n                else:\n                    p_i = (lam - b[i]) / (2*c[i])\n                total_p += p_i\n            \n            if total_p < current_load:\n                lo = lam\n            else:\n                hi = lam\n        \n        # Calculate p based on final lambda\n        total_p = 0\n        p_dispatch = [0] * n_comm\n        for i in range(n_comm):\n            mc_low = b[i] + 2*c[i]*lows[i]\n            mc_high = b[i] + 2*c[i]*highs[i]\n            if lam < mc_low:\n                p_i = lows[i]\n            elif lam > mc_high:\n                p_i = highs[i]\n            else:\n                p_i = (lam - b[i]) / (2*c[i])\n            p_dispatch[i] = p_i\n            total_p += p_i\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        tol = 1e-5\n        if residual > tol:\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] < highs[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx])\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = highs[idx] - p_dispatch[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] += adjust\n                residual -= adjust\n        elif residual < -tol:\n            residual = -residual\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] > lows[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx], reverse=True)\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = p_dispatch[idx] - lows[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] -= adjust\n                residual -= adjust\n        \n        # Assign dispatched values\n        for ii, i in enumerate(comm_list):\n            p[i] = p_dispatch[ii]\n    \n    # Set commitments and output for non-committed\n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0091401443,
          "fitness": 0.0072843404
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "**  \n1. Classify units:  \n   - must_on: Previously online and (min up-time unfulfilled or previous output > shutdown capacity)  \n   - must_off: Previously offline and min down-time unfulfilled  \n   - free_on: Online and decommittable  \n   - free_off: Offline and committable  \n2. Commit must_on and free_on units.  \n3. Compute effective min/max:  \n   - Previously online: `[max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]`  \n   - New starts: `[p_min, min(p_max, startup_ramp)]`  \n4. Decommit free-on units by highest cost per MW at effective min until total min \u2264 load.  \n5. Commit free-off units by lowest cost per MW at min (including startup) until total max \u2265 load.  \n6. Decommit non-essential free-on units (by same cost metric) if removal maintains total max \u2265 load.  \n7. Dispatch committed units:  \n   a) If load \u2264 total min: Set outputs to min  \n   b) If load \u2265 total max: Set outputs to max  \n   c) Else: Lambda iteration with residual adjustment:  \n      i. Use bisection to find optimal lambda (with clamping)  \n      ii. Adjust residual via marginal cost merit order  \n8. Set non-committed units to off (0 output).  \n\n**",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    def compute_cost_per_MW(unit, eff_min, include_startup=False):\n        if eff_min <= 1e-10:  # Avoid division by zero\n            return float('inf')\n        cost = unit['a_i'] + unit['b_i'] * eff_min + unit['c_i'] * eff_min**2\n        if include_startup:\n            cost += unit['s_i']\n        return cost / eff_min\n\n    units = []\n    for idx, ui in enumerate(units_info):\n        unit = ui.copy()\n        unit['index'] = idx\n        unit['committed'] = False\n        units.append(unit)\n    \n    current_load = load[0]\n    n_units = len(units)\n    \n    # Step 1: Classify units\n    for u in units:\n        if u['u_i_0'] == 1:  # Previously online\n            if u['t_i_0'] < u['t_on_min_i'] or u['p_i_0'] > u['p_shut_i']:\n                u['class'] = 'must_on'\n            else:\n                u['class'] = 'free_on'\n        else:  # Previously offline\n            if -u['t_i_0'] < u['t_off_min_i']:  # Still in min down-time\n                u['class'] = 'must_off'\n            else:\n                u['class'] = 'free_off'\n    \n    # Step 2: Initial commit (must_on + free_on)\n    for u in units:\n        if u['class'] in ['must_on', 'free_on']:\n            u['committed'] = True\n            if u['u_i_0'] == 1:  # Previously online: ramp constraints\n                u['eff_min'] = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n                u['eff_max'] = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n            else:  # New start (shouldn't happen for must_on/free_on)\n                u['eff_min'] = u['p_min_i']\n                u['eff_max'] = min(u['p_max_i'], u['p_start_i'])\n    \n    # Step 3: Compute total min/max\n    total_min = sum(u['eff_min'] for u in units if u['committed'])\n    total_max = sum(u['eff_max'] for u in units if u['committed'])\n    \n    # Step 4: Decommit expensive free-on units\n    free_on = [u for u in units if u['class'] == 'free_on' and u['committed']]\n    for u in free_on:\n        u['cost_per_MW'] = compute_cost_per_MW(u, u['eff_min'])\n    free_on.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    \n    for unit in free_on:\n        if total_min <= current_load:\n            break\n        unit['committed'] = False\n        total_min -= unit['eff_min']\n        total_max -= unit['eff_max']\n    \n    # Step 5: Commit cheap free-off units\n    free_off = [u for u in units if u['class'] == 'free_off' and not u['committed']]\n    for u in free_off:\n        u['eff_min'] = u['p_min_i']\n        u['eff_max'] = min(u['p_max_i'], u['p_start_i'])\n        u['cost_per_MW'] = compute_cost_per_MW(u, u['eff_min'], include_startup=True)\n    free_off.sort(key=lambda x: x['cost_per_MW'])\n    \n    for unit in free_off:\n        if total_max >= current_load:\n            break\n        unit['committed'] = True\n        total_min += unit['eff_min']\n        total_max += unit['eff_max']\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_committed = [u for u in units if u['class'] == 'free_on' and u['committed']]\n    free_on_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    for unit in free_on_committed:\n        if total_max - unit['eff_max'] >= current_load:\n            unit['committed'] = False\n            total_min -= unit['eff_min']\n            total_max -= unit['eff_max']\n    \n    # Collect committed units\n    committed = [u for u in units if u['committed']]\n    total_min = sum(u['eff_min'] for u in committed)\n    total_max = sum(u['eff_max'] for u in committed)\n    \n    # Step 7: Dispatch\n    outputs = [0.0] * n_units\n    \n    if len(committed) == 0:\n        # Edge case: no committed units\n        u_vec = [0] * n_units\n        p_vec = [0.0] * n_units\n        return np.array([u_vec, p_vec])\n    \n    # 7a: Min/Max dispatch\n    if current_load <= total_min:\n        for u in committed:\n            outputs[u['index']] = u['eff_min']\n    elif current_load >= total_max:\n        for u in committed:\n            outputs[u['index']] = u['eff_max']\n    else:\n        # 7c: Lambda iteration (bisection)\n        low_lambda = min(2*u['c_i']*u['eff_min'] + u['b_i'] if u['c_i']>0 else u['b_i'] for u in committed)\n        high_lambda = max(2*u['c_i']*u['eff_max'] + u['b_i'] if u['c_i']>0 else u['b_i'] for u in committed)\n        lambda_ = (low_lambda + high_lambda) / 2\n        \n        n_iter = 0\n        tol = 1e-5\n        total_output = 0\n        temp_outputs = {}\n        \n        # Bisection loop\n        while n_iter < 100 and abs(total_output - current_load) > tol:\n            total_output = 0\n            for u in committed:\n                # Linear units\n                if u['c_i'] == 0:\n                    p_star = u['eff_max'] if lambda_ > u['b_i'] else u['eff_min']\n                # Quadratic units\n                else:\n                    p_star = (lambda_ - u['b_i']) / (2 * u['c_i'])\n                    p_star = max(u['eff_min'], min(u['eff_max'], p_star))\n                temp_outputs[u['index']] = p_star\n                total_output += p_star\n                \n            if abs(total_output - current_load) <= tol:\n                break\n                \n            if total_output < current_load:\n                low_lambda = lambda_\n            else:\n                high_lambda = lambda_\n                \n            lambda_ = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Residual adjustment\n        residual = current_load - total_output\n        if abs(residual) > tol:\n            # Increase needed\n            if residual > 0:\n                candidates = []\n                for u in committed:\n                    if temp_outputs[u['index']] < u['eff_max']:\n                        if u['c_i'] > 0:\n                            mc = 2 * u['c_i'] * temp_outputs[u['index']] + u['b_i']\n                        else:\n                            mc = u['b_i']\n                        candidates.append((mc, u['index']))\n                candidates.sort(key=lambda x: x[0])\n                \n                for mc, idx in candidates:\n                    if abs(residual) < tol:\n                        break\n                    available = units[idx]['eff_max'] - temp_outputs[idx]\n                    delta = min(available, residual)\n                    temp_outputs[idx] += delta\n                    residual -= delta\n                    \n            # Decrease needed\n            elif residual < 0:\n                candidates = []\n                for u in committed:\n                    if temp_outputs[u['index']] > u['eff_min']:\n                        if u['c_i'] > 0:\n                            mc = 2 * u['c_i'] * temp_outputs[u['index']] + u['b_i']\n                        else:\n                            mc = u['b_i']\n                        candidates.append((mc, u['index']))\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                \n                for mc, idx in candidates:\n                    if abs(residual) < tol:\n                        break\n                    available = temp_outputs[idx] - units[idx]['eff_min']\n                    delta = min(available, -residual)\n                    temp_outputs[idx] -= delta\n                    residual += delta\n        \n        for u in committed:\n            outputs[u['index']] = temp_outputs[u['index']]\n    \n    # Final output arrays\n    u_vec = [1 if u['committed'] else 0 for u in units]\n    p_vec = [outputs[i] if u['committed'] else 0.0 for i, u in enumerate(units)]\n    \n    return np.array([u_vec, p_vec])",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "advanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), free-off (offline but commitable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs considering ramp constraints:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost per MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + min_output_cost)/min_output until total max \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection and quadratic/linear handling\n   d) Residual adjustment via marginal cost merit order\n8. Set non-committed units to off state and zero output\n",
          "code": "import numpy as np\n\ndef advanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Precompute min and max for all units\n    min_i = np.zeros(n_units)\n    max_i = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_i[i] = unit['p_min_i']\n            max_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commit\n    committed_units = must_on + free_on\n    total_min = sum(min_i[i] for i in committed_units)\n    total_max = sum(max_i[i] for i in committed_units)\n    \n    # Decommit free-on if min output > load\n    if total_min > current_load:\n        free_on_committed = [i for i in committed_units if i in free_on]\n        if free_on_committed:\n            metrics = []\n            for i in free_on_committed:\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0], reverse=True)\n            for metric, i in metrics:\n                if total_min <= current_load:\n                    break\n                committed_units.remove(i)\n                total_min -= min_i[i]\n                total_max -= max_i[i]\n    \n    # Commit free-off if max output < load\n    if total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed_units]\n        if free_off_available:\n            metrics = []\n            for i in free_off_available:\n                cost = (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                        units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0])\n            for metric, i in metrics:\n                if total_max >= current_load:\n                    break\n                committed_units.append(i)\n                total_min += min_i[i]\n                total_max += max_i[i]\n    \n    # Decommit non-essential free-on\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed_units if i in free_on]\n        if free_on_committed:\n            metrics = []\n            for i in free_on_committed:\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0], reverse=True)\n            for metric, i in metrics:\n                if total_max - max_i[i] >= current_load:\n                    committed_units.remove(i)\n                    total_min -= min_i[i]\n                    total_max -= max_i[i]\n                    changed = True\n                    break\n    \n    # Initialize outputs\n    p_out = np.zeros(n_units)\n    u_out = np.zeros(n_units)\n    \n    if not committed_units:\n        return np.array([u_out, p_out])\n    \n    # Dispatch\n    if current_load <= total_min:\n        for i in committed_units:\n            p_out[i] = min_i[i]\n            u_out[i] = 1\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_out[i] = max_i[i]\n            u_out[i] = 1\n    else:\n        # Lambda iteration\n        min_vals = [min_i[i] for i in committed_units]\n        max_vals = [max_i[i] for i in committed_units]\n        b_vals = [units_info[i]['b_i'] for i in committed_units]\n        c_vals = [units_info[i]['c_i'] for i in committed_units]\n        \n        low = min(2 * c * m + b for c, m, b in zip(c_vals, min_vals, b_vals) if c > 0)\n        high = max(2 * c * M + b for c, M, b in zip(c_vals, max_vals, b_vals) if c > 0)\n        low = min(low, min(b_vals))  # Ensure linear units included\n        high = max(high, max(b_vals))\n        \n        for _ in range(100):\n            lmbda = (low + high) / 2\n            total_p = 0\n            for i, (min_val, max_val, b, c) in enumerate(zip(min_vals, max_vals, b_vals, c_vals)):\n                if c == 0:\n                    p_val = max_val if lmbda > b else min_val\n                else:\n                    p_uncon = (lmbda - b) / (2 * c)\n                    p_val = max(min_val, min(max_val, p_uncon))\n                total_p += p_val\n            if abs(total_p - current_load) < 1e-5:\n                break\n            if total_p > current_load:\n                high = lmbda\n            else:\n                low = lmbda\n        \n        # Apply lambda solution\n        p_temp = {}\n        total_after_iter = 0\n        for idx, (i, min_val, max_val, b, c) in enumerate(zip(committed_units, min_vals, max_vals, b_vals, c_vals)):\n            if c == 0:\n                p_val = max_val if lmbda > b else min_val\n            else:\n                p_uncon = (lmbda - b) / (2 * c)\n                p_val = max(min_val, min(max_val, p_uncon))\n            p_temp[i] = p_val\n            total_after_iter += p_val\n        \n        # Residual adjustment\n        residual = current_load - total_after_iter\n        iter_count = 0\n        max_iter = 1000\n        while abs(residual) > 1e-5 and iter_count < max_iter:\n            if residual > 0:\n                candidates = []\n                for i in committed_units:\n                    if p_temp[i] < max_i[i] - 1e-5:\n                        if units_info[i]['c_i'] == 0:\n                            mc = units_info[i]['b_i']\n                        else:\n                            mc = 2 * units_info[i]['c_i'] * p_temp[i] + units_info[i]['b_i']\n                        candidates.append((mc, i))\n                if not candidates:\n                    break\n                candidates.sort(key=lambda x: x[0])\n                _, i_star = candidates[0]\n                delta = min(residual, max_i[i_star] - p_temp[i_star])\n                p_temp[i_star] += delta\n                residual -= delta\n            else:\n                candidates = []\n                for i in committed_units:\n                    if p_temp[i] > min_i[i] + 1e-5:\n                        if units_info[i]['c_i'] == 0:\n                            mc = units_info[i]['b_i']\n                        else:\n                            mc = 2 * units_info[i]['c_i'] * p_temp[i] + units_info[i]['b_i']\n                        candidates.append((mc, i))\n                if not candidates:\n                    break\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                _, i_star = candidates[0]\n                delta = min(-residual, p_temp[i_star] - min_i[i])\n                p_temp[i_star] -= delta\n                residual += delta\n            iter_count += 1\n        \n        for i in committed_units:\n            p_out[i] = p_temp[i]\n            u_out[i] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0054285375,
          "gap_price_rate": 0.0091401444,
          "fitness": 0.007284341
     },
     {
          "name": "evolved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), and free-off (offline but commitable)\n2. Commit must-on + free-on units\n3. Compute effective min/max outputs considering:\n   - For prev online units: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - For new starts: [p_min, min(p_max, startup_ramp)]\n4. Decommittable free-on units by highest cost/MW at min output until total min \u2264 load\n5. Committable free-off units by lowest cost/MW including startup until total max \u2265 load\n6. Decommittable free-on units with highest cost/MW at min output if non-essential\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with gradient clipping and residual adjustment\n8. Return schedules (u_i, p_i) for all units\n\n",
          "code": "import numpy as np\n\ndef evolved_rolling_commitment(units_info, load):\n    load0 = load[0]\n    n_units = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_outputs = {}\n    max_outputs = {}\n    \n    # Classify units (Step 1)\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < t_on_min) or (p0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            min_o = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_o = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            min_outputs[i] = min_o\n            max_outputs[i] = max_o\n        else:  # Previously offline\n            if abs(t0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commit (Step 2)\n    committed = set(must_on) | set(free_on)\n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n    \n    # Decommit high-cost free-on if over-committed (Step 4)\n    high_cost_free_on = [i for i in free_on if i in committed]\n    high_cost_free_on.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in high_cost_free_on:\n        if total_min <= load0:\n            break\n        committed.remove(i)\n        total_min -= min_outputs[i]\n        total_max -= max_outputs[i]\n    \n    # Commit low-cost free-off if under-committed (Step 5)\n    low_cost_free_off = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in low_cost_free_off:\n        if total_max >= load0:\n            break\n        if i in committed:\n            continue\n        min_i = units_info[i]['p_min_i']\n        max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        min_outputs[i] = min_i\n        max_outputs[i] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Decommit non-essential high-cost free-on (Step 6)\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_committed:\n        new_min = total_min - min_outputs[i]\n        new_max = total_max - max_outputs[i]\n        if new_min <= load0 <= new_max:\n            committed.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch logic (Step 7)\n    p_alloc = [0] * n_units\n    u_alloc = [1 if i in committed else 0 for i in range(n_units)]\n    \n    if committed:\n        if load0 <= total_min:\n            for i in committed:\n                p_alloc[i] = min_outputs[i]\n        elif load0 >= total_max:\n            for i in committed:\n                p_alloc[i] = max_outputs[i]\n        else:\n            # Lambda iteration setup\n            low = 0\n            high = max(unit['b_i'] + 2 * unit['c_i'] * max_outputs[i] \n                      for i, unit in enumerate(units_info) if i in committed) * 2\n            tol = 0.01\n            iter_max = 100\n            iter_count = 0\n            \n            while iter_count < iter_max:\n                mid = (low + high) / 2.0\n                total_p = 0\n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        unconstrained = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                    else:\n                        unconstrained = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = np.clip(unconstrained, min_outputs[i], max_outputs[i])\n                    total_p += p_i\n                \n                if abs(total_p - load0) <= tol:\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] == 0:\n                            p_i = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                        else:\n                            p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                        p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n                    break\n                \n                if total_p < load0:\n                    low = mid\n                else:\n                    high = mid\n                iter_count += 1\n            \n            # Residual adjustment (if needed)\n            total_p = sum(p_alloc[i] for i in committed)\n            residual = load0 - total_p\n            if residual != 0:\n                candidates = []\n                for i in committed:\n                    if residual > 0 and p_alloc[i] < max_outputs[i]:\n                        margin = max_outputs[i] - p_alloc[i]\n                        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                        candidates.append((i, marginal_cost, margin))\n                    elif residual < 0 and p_alloc[i] > min_outputs[i]:\n                        margin = p_alloc[i] - min_outputs[i]\n                        marginal_cost = -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                        candidates.append((i, marginal_cost, margin))\n                \n                candidates.sort(key=lambda x: x[1])\n                for i, mc, margin in candidates:\n                    adjust = min(abs(residual), margin)\n                    if residual > 0:\n                        p_alloc[i] += adjust\n                        residual -= adjust\n                    else:\n                        p_alloc[i] -= adjust\n                        residual += adjust\n                    if abs(residual) < tol:\n                        break\n    \n    # Non-committed units\n    for i in range(n_units):\n        if not u_alloc[i]:\n            p_alloc[i] = 0\n    \n    return np.array([u_alloc, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0054285387,
          "gap_price_rate": 0.0091401447,
          "fitness": 0.0072843417
     },
     {
          "name": "solve_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previously online with unfulfilled min up-time or previous output exceeding shutdown capacity), must-off (previously offline with unfulfilled min down-time), free-on (previously online but decommittable), and free-off (previously offline but committable).\n2. Commit must-on and free-on units initially.\n3. Compute effective min/max outputs: For previously online units, set min_eff = max(p_min, previous_p - ramp_down) and max_eff = min(p_max, previous_p + ramp_up). For free-off units, set min_eff = p_min and max_eff = min(p_max, startup_ramp).\n4. Decommit free-on units in descending order of operating cost per MW at their effective min output until total min_eff \u2264 current load.\n5. Commit free-off units in ascending order of (startup_cost + operating_cost) per MW at their min output until total max_eff \u2265 current load.\n6. Decommit non-essential free-on units in descending order of operating cost per MW at effective min output if removal maintains total max_eff \u2265 current load.\n7. Dispatch committed units:\n   a) Set outputs to min_eff if load \u2264 total min_eff.\n   b) Set outputs to max_eff if load \u2265 total max_eff.\n   c) For intermediate loads: use bisection (100 iterations) to find optimal lambda for economic dispatch respecting ramp constraints, then perform residual adjustment using marginal cost merit order.\n8. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef solve_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i_0 == 1:  # was online\n            if t_i_0 < t_on_min or p_i_0 > p_shut:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:  # was offline\n            if t_i_0 < 0 and abs(t_i_0) < t_off_min:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Step 2: Initial commitment\n    committed = set(must_on) | set(free_on)\n    \n    # Step 3: Precompute effective min/max for all units\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # was online\n            min_eff[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # was offline\n            min_eff[idx] = unit['p_min_i']\n            max_eff[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit expensive free-on units if needed\n    total_min = 0.0\n    total_max = 0.0\n    for i in committed:\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    # Create list of free-on units sorted by cost-per-MW (operating cost at min_eff) descending\n    candidate_free_on = [i for i in free_on if i in committed]\n    candidate_free_on.sort(\n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2) / min_eff[i],\n        reverse=True\n    )\n    \n    for i in candidate_free_on:\n        if total_min <= current_load:\n            break\n        committed.remove(i)\n        total_min -= min_eff[i]\n        total_max -= max_eff[i]\n    \n    # Step 5: Commit cheap free-off units if needed\n    candidate_free_off = free_off[:]  # initially not committed\n    candidate_free_off.sort(\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2) / min_eff[i]\n    )\n    \n    for i in candidate_free_off:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    remaining_free_on = [i for i in free_on if i in committed]\n    remaining_free_on.sort(\n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2) / min_eff[i],\n        reverse=True\n    )\n    \n    for i in remaining_free_on:\n        if total_max - max_eff[i] >= current_load:\n            committed.remove(i)\n            total_min -= min_eff[i]\n            total_max -= max_eff[i]\n    \n    # Prepare committed list and filter min/max constraints\n    committed_list = list(committed)\n    min_eff_comm = [min_eff[i] for i in committed_list]\n    max_eff_comm = [max_eff[i] for i in committed_list]\n    \n    # Step 7: Dispatch\n    n_committed = len(committed_list)\n    \n    if current_load <= total_min:  # Minimum dispatch\n        p_vals = min_eff_comm\n    elif current_load >= total_max:  # Maximum dispatch\n        p_vals = max_eff_comm\n    else:  # Lambda iteration with bisection\n        # Initialize bisection parameters\n        low = float('inf')\n        high = -float('inf')\n        a_list = []\n        b_list = []\n        c_list = []\n        \n        for i in committed_list:\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            a_list.append(a_i)\n            b_list.append(b_i)\n            c_list.append(c_i)\n            \n            mc_low = 2 * c_i * min_eff[i] + b_i\n            mc_high = 2 * c_i * max_eff[i] + b_i\n            low = min(low, mc_low)\n            high = max(high, mc_high)\n        \n        # Bisection iterations\n        n_iter = 100\n        p_vals = np.zeros(n_committed)\n        \n        for _ in range(n_iter):\n            lam = (low + high) / 2\n            total_p = 0.0\n            \n            for j in range(n_committed):\n                idx = committed_list[j]\n                c_val = c_list[j]\n                b_val = b_list[j]\n                min_e = min_eff_comm[j]\n                max_e = max_eff_comm[j]\n                \n                if c_val == 0:  # Handle linear cost\n                    p_val = max_e if lam > b_val else min_e\n                else:\n                    p_val = (lam - b_val) / (2 * c_val)\n                    p_val = max(min_e, min(max_e, p_val))\n                \n                p_vals[j] = p_val\n                total_p += p_val\n            \n            if abs(total_p - current_load) < 1e-4:\n                break\n            elif total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > 1e-4:\n            mc_vals = []\n            for j in range(n_committed):\n                idx = committed_list[j]\n                p_val = p_vals[j]\n                c_val = c_list[j]\n                b_val = b_list[j]\n                mc = 2 * c_val * p_val + b_val\n                mc_vals.append(mc)\n            \n            mc_vals = np.array(mc_vals)\n            if residual > 0:  # Under-generation\n                idx_sorted = np.argsort(mc_vals)\n                for i in idx_sorted:\n                    add = min(residual, max_eff_comm[i] - p_vals[i])\n                    p_vals[i] += add\n                    residual -= add\n                    if residual <= 1e-10:\n                        break\n            else:  # Over-generation\n                residual = abs(residual)\n                idx_sorted = np.argsort(-mc_vals)\n                for i in idx_sorted:\n                    sub = min(residual, p_vals[i] - min_eff_comm[i])\n                    p_vals[i] -= sub\n                    residual -= sub\n                    if residual <= 1e-10:\n                        break\n    \n    # Step 7a & 7b: Assign dispatch values\n    for j, i in enumerate(committed_list):\n        p_arr[i] = p_vals[j]\n        u_arr[i] = 1\n    \n    # Step 8: Set non-committed units to offline\n    for i in range(n_units):\n        if i not in committed:\n            p_arr[i] = 0\n            u_arr[i] = 0\n    \n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.005428548,
          "gap_price_rate": 0.0091401438,
          "fitness": 0.0072843459
     },
     {
          "name": "enhanced_solve_rolling_commitment",
          "algorithm": "1. Classify units:\n   - must_on: Previously online units violating min up-time (t_i_0 < t_on_min_i) or shutdown ramp constraint (p_i_0 > p_shut_i)\n   - must_off: Previously offline units violating min down-time (-t_i_0 < t_off_min_i)\n   - free_on: Previously online units that are decommittable\n   - free_off: Previously offline units that are committable\n2. Commit must_on and free_on units\n3. Compute effective power limits:\n   - Previously online units: min_eff = max(p_min, p_i_0 - p_down_i), max_eff = min(p_max, p_i_0 + p_up_i)\n   - New commitments: min_eff = p_min_i, max_eff = min(p_max_i, p_start_i)\n4. Decommit free-on units in descending order of (a_i + b_i*min_eff + c_i*min_eff\u00b2)/min_eff until total min_eff \u2264 load\n5. Commit free-off units in ascending order of marginal cost metric: \n   [s_i + a_i + b_i*min_eff + c_i*min_eff\u00b2 - (b_i + 2*c_i*min_eff)*min_eff]/min_eff + (b_i + 2*c_i*min_eff)\n6. Decommit non-essential free-on units using original cost metric if removal maintains total max_eff \u2265 load\n7. Dispatch committed units:\n   - Set outputs to min_eff if load \u2264 total min_eff\n   - Set outputs to max_eff if load \u2265 total max_eff\n   - Else: perform lambda-iteration (50 iterations) with residual adjustment via marginal cost merit order\n8. Set non-committed units to off (u_i=0, p_i=0)\n",
          "code": "import numpy as np\n\ndef enhanced_solve_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0] * n_units\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    \n    for i, unit in enumerate(units_info):\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        start_ramp = unit['p_start_i']\n        shut_ramp = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        # Compute effective min/max\n        if u_i0 == 1:\n            min_eff[i] = max(p_min, p_i0 - ramp_down)\n            max_eff[i] = min(p_max, p_i0 + ramp_up)\n            \n            # Check must-on conditions\n            if (t_i0 < min_up) or (p_i0 > shut_ramp):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            min_eff[i] = p_min\n            max_eff[i] = min(p_max, start_ramp)\n            \n            # Check must-off conditions\n            if -t_i0 < min_down:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on + free_on)\n    \n    # Step 4: Decommit free-on units by highest cost per MW\n    total_min = sum(min_eff[i] for i in committed)\n    \n    if total_min > current_load:\n        # Calculate cost per MW metric for free-on units\n        cost_metrics = []\n        for i in free_on:\n            if i in committed:\n                cost = (units_info[i]['a_i'] + \n                        units_info[i]['b_i'] * min_eff[i] + \n                        units_info[i]['c_i'] * min_eff[i]**2)\n                cost_per_mw = cost / min_eff[i] if min_eff[i] > 0 else float('inf')\n                cost_metrics.append((cost_per_mw, i))\n        \n        # Sort descending by cost per MW\n        cost_metrics.sort(reverse=True, key=lambda x: x[0])\n        \n        for _, idx in cost_metrics:\n            if total_min - min_eff[idx] <= current_load:\n                break\n            committed.remove(idx)\n            total_min -= min_eff[idx]\n    \n    # Step 5: Commit free-off units by marginal cost metric\n    total_max = sum(max_eff[i] for i in committed)\n    \n    if total_max < current_load:\n        cost_metrics = []\n        for i in free_off:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c_val = units_info[i]['c_i']\n            s = units_info[i]['s_i']\n            m_eff = min_eff[i]\n            \n            # Modified metric: [startup + fixed_cost - (min_eff * marginal_cost)] / min_eff + marginal_cost\n            fixed_cost = a + b * m_eff + c_val * m_eff**2\n            marginal_cost = b + 2 * c_val * m_eff\n            metric = (s + fixed_cost - marginal_cost * m_eff) / max(m_eff, 1e-6) + marginal_cost\n            cost_metrics.append((metric, i))\n        \n        # Sort ascending by metric\n        cost_metrics.sort(key=lambda x: x[0])\n        \n        for metric_val, idx in cost_metrics:\n            if total_max >= current_load:\n                break\n            committed.add(idx)\n            total_max += max_eff[idx]\n    \n    # Step 6: Decommit non-essential free-on units\n    if free_on:\n        cost_metrics = []\n        for i in free_on:\n            if i in committed:\n                cost = (units_info[i]['a_i'] + \n                        units_info[i]['b_i'] * min_eff[i] + \n                        units_info[i]['c_i'] * min_eff[i]**2)\n                cost_per_mw = cost / min_eff[i] if min_eff[i] > 0 else float('inf')\n                cost_metrics.append((cost_per_mw, i))\n        \n        cost_metrics.sort(reverse=True, key=lambda x: x[0])\n        \n        for _, idx in cost_metrics:\n            new_total_max = total_max - max_eff[idx]\n            if idx in committed and new_total_max >= current_load:\n                committed.remove(idx)\n                total_max = new_total_max\n    \n    # Step 7: Dispatch committed units\n    min_total = sum(min_eff[i] for i in committed)\n    max_total = sum(max_eff[i] for i in committed)\n    \n    # Dispatch cases\n    if current_load <= min_total:\n        for i in committed:\n            p[i] = min_eff[i]\n            u[i] = 1\n    elif current_load >= max_total:\n        for i in committed:\n            p[i] = max_eff[i]\n            u[i] = 1\n    else:\n        # Lambda iteration\n        low = 0\n        high = 1e6\n        tol = 1e-3\n        iter_count = 0\n        \n        while iter_count < 50:  # Reduced to 50 iterations\n            mid = (low + high) / 2\n            total_power = 0\n            for i in committed:\n                unit = units_info[i]\n                b = unit['b_i']\n                c_val = unit['c_i']\n                mc = b + 2 * c_val * min_eff[i]  # Marginal cost at min_eff\n                \n                if c_val == 0:  # Linear cost\n                    if mid >= b:\n                        power = max_eff[i]\n                    else:\n                        power = min_eff[i]\n                else:\n                    # Clamp to effective range\n                    power = (mid - b) / (2 * c_val)\n                    power = max(min_eff[i], min(max_eff[i], power))\n                total_power += power\n            \n            if abs(total_power - current_load) < tol:\n                break\n            elif total_power < current_load:\n                low = mid\n            else:\n                high = mid\n            \n            iter_count += 1\n        \n        # Set power based on final mid value\n        total_power = 0\n        power_outputs = {}\n        for i in committed:\n            unit = units_info[i]\n            b = unit['b_i']\n            c_val = unit['c_i']\n            if c_val == 0:\n                power_outputs[i] = max_eff[i] if mid >= b else min_eff[i]\n            else:\n                power = (mid - b) / (2 * c_val)\n                power_outputs[i] = max(min_eff[i], min(max_eff[i], power))\n            total_power += power_outputs[i]\n        \n        # Residual adjustment\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            if residual > 0:\n                # Sort by increasing marginal cost\n                marginal_costs = []\n                for i in committed:\n                    current_power = power_outputs[i]\n                    unit = units_info[i]\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_power\n                    marginal_costs.append((marginal_cost, current_power, i))\n                marginal_costs.sort(key=lambda x: x[0])\n                \n                for mc, current_power, idx in marginal_costs:\n                    if residual <= 0:\n                        break\n                    headroom = max_eff[idx] - current_power\n                    if headroom > 0:\n                        delta = min(headroom, residual)\n                        power_outputs[idx] += delta\n                        residual -= delta\n            else:\n                # Sort by decreasing marginal cost\n                marginal_costs = []\n                for i in committed:\n                    current_power = power_outputs[i]\n                    unit = units_info[i]\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * current_power\n                    marginal_costs.append((marginal_cost, current_power, i))\n                marginal_costs.sort(key=lambda x: x[0], reverse=True)\n                \n                for mc, current_power, idx in marginal_costs:\n                    if residual >= 0:\n                        break\n                    room = current_power - min_eff[idx]\n                    if room > 0:\n                        delta = min(room, -residual)\n                        power_outputs[idx] -= delta\n                        residual += delta\n        \n        # Set outputs\n        for i in committed:\n            p[i] = power_outputs[i]\n            u[i] = 1\n    \n    # Set non-committed units to off\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0054286413,
          "gap_price_rate": 0.009140139,
          "fitness": 0.0072843902
     }
]