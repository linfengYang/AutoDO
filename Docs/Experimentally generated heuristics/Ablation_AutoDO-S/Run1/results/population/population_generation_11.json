[
     {
          "name": "refined_optimized_rolling_commitment_v3_improved",
          "algorithm": "1. Classify units into must-on (previously online with unfulfilled min up-time or shutdown constraint), must-off (previously offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable)\n2. Commit must-on and free-on units as initial set\n3. Compute effective min/max outputs: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments\n4. Decommit free-on units by descending (a_i + b_i * eff_min_i + c_i * eff_min_i\u00b2)/eff_min_i until total min output \u2264 current load\n5. Commit free-off units by ascending (s_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2)/p_min_i until total max output \u2265 current load\n6. Decommit non-essential free-on units by descending cost/MW at eff_min_i if removal maintains total max \u2265 load\n7. Commit free-off units by ascending startup-adjusted cost at eff_min_i until total max output \u2265 load\n8. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: perform economic dispatch via lambda iteration with 100 bisection steps\n   d) Adjust residual by increasing cheapest marginal cost units first for shortages, decreasing most expensive first for surpluses\n9. Set non-committed units to off (0 output)\n10. Return schedules with commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef refined_optimized_rolling_commitment_v3_improved(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed = []\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n                committed.append(i)\n            else:\n                free_on.append(i)\n                committed.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    eff_min = [0] * n_units\n    eff_max = [0] * n_units\n    \n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            eff_min[i] = units_info[i]['p_min_i']\n            eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(eff_min)\n    total_max = sum(eff_max)\n    \n    free_on_committed = [i for i in free_on if i in committed]\n    metric_decommit1 = []\n    for i in free_on_committed:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i]\n        metric_decommit1.append((metric, i))\n    metric_decommit1.sort(key=lambda x: x[0], reverse=True)\n    \n    for metric, i in metric_decommit1:\n        if total_min <= current_load:\n            break\n        committed.remove(i)\n        total_min -= eff_min[i]\n        total_max -= eff_max[i]\n        eff_min[i] = eff_max[i] = 0\n    \n    free_off_not_committed = [i for i in free_off if i not in committed]\n    metric_commit = []\n    for i in free_off_not_committed:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        metric = cost / unit['p_min_i']\n        metric_commit.append((metric, i))\n    metric_commit.sort(key=lambda x: x[0])\n    \n    for metric, i in metric_commit:\n        if total_max >= current_load:\n            break\n        eff_min_i = units_info[i]['p_min_i']\n        eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.append(i)\n        eff_min[i] = eff_min_i\n        eff_max[i] = eff_max_i\n        total_min += eff_min_i\n        total_max += eff_max_i\n    \n    free_on_committed_now = [i for i in free_on if i in committed and i not in must_on]\n    metric_decommit2 = []\n    for i in free_on_committed_now:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i]\n        metric_decommit2.append((metric, i))\n    metric_decommit2.sort(key=lambda x: x[0], reverse=True)\n    \n    for metric, i in metric_decommit2:\n        if total_max - eff_max[i] >= current_load:\n            committed.remove(i)\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            eff_min[i] = eff_max[i] = 0\n    \n    free_off_not_committed_second = [i for i in free_off if i not in committed]\n    metric_commit2 = []\n    for i in free_off_not_committed_second:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        metric_commit2.append((metric, i))\n    metric_commit2.sort(key=lambda x: x[0])\n    \n    for metric, i in metric_commit2:\n        if total_max >= current_load:\n            break\n        eff_min_i = units_info[i]['p_min_i']\n        eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.append(i)\n        eff_min[i] = eff_min_i\n        eff_max[i] = eff_max_i\n        total_min += eff_min_i\n        total_max += eff_max_i\n    \n    p = [0] * n_units\n    \n    if current_load <= total_min:\n        for i in committed:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in committed:\n            p[i] = eff_max[i]\n    else:\n        lambda_low = min(unit['b_i'] + 2 * unit['c_i'] * eff_min[i] for i in committed)\n        lambda_high = max(unit['b_i'] + 2 * unit['c_i'] * eff_max[i] for i in committed)\n        if lambda_low == lambda_high:\n            lambda_high += 1.0\n        \n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_output = 0.0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    p_i_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_i_uncon = eff_min[i] if lambda_mid < unit['b_i'] else eff_max[i]\n                p_i = max(eff_min[i], min(eff_max[i], p_i_uncon))\n                p[i] = p_i\n                total_output += p_i\n            if total_output < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < 1e-5:\n                break\n        \n        total_output = sum(p[i] for i in committed)\n        residual = current_load - total_output\n        \n        if residual > 0:\n            unit_list = []\n            for i in committed:\n                unit = units_info[i]\n                avail = eff_max[i] - p[i]\n                if avail > 1e-3:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    unit_list.append((marginal_cost, avail, i))\n            unit_list.sort(key=lambda x: x[0])\n            for _, avail, i in unit_list:\n                if residual <= 0:\n                    break\n                add = min(residual, avail)\n                p[i] += add\n                residual -= add\n        elif residual < 0:\n            residual = abs(residual)\n            unit_list = []\n            for i in committed:\n                unit = units_info[i]\n                avail = p[i] - eff_min[i]\n                if avail > 1e-3:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    unit_list.append((marginal_cost, avail, i))\n            unit_list.sort(key=lambda x: x[0], reverse=True)\n            for _, avail, i in unit_list:\n                if residual <= 0:\n                    break\n                sub = min(residual, avail)\n                p[i] -= sub\n                residual -= sub\n    \n    u = [1 if i in committed else 0 for i in range(n_units)]\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0033546861,
          "gap_price_rate": 0.0081315629,
          "fitness": 0.0057431245
     },
     {
          "name": "refined_evolved_rolling_commitment_v3",
          "algorithm": "1. Classify units into categories: must-on (previously online and violated min up-time or shutdown ramp constraint), must-off (previously offline and violated min down-time), free-on (previously online and commitable), free-off (previously offline and commitable)\n2. Initially commit must-on and free-on units\n3. Compute effective power limits considering ramp constraints:\n   - Previously online: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - New starts: [p_min, min(p_max, startup_ramp)]\n4. Decommit free-on units by highest cost per MW at effective min output ((a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211min_output \u2264 load\n5. Commit free-off units by lowest cost per MW including startup ((s_i + a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211max_output \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW (same metric) if removal maintains \u2211max_output \u2265 load\n7. Dispatch using bisection method to find optimal lambda for economic dispatch with residual adjustment:\n   a) If load \u2264 total min: set all to min output\n   b) If load \u2265 total max: set all to max output\n   c) Else: find \u03bb such that \u2211clamped outputs equals load, then adjust residual by marginal cost order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    if n_units == 0:\n        return schedules\n        \n    u_0 = [unit['u_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    startup_ramp = [unit['p_start_i'] for unit in units_info]\n    shutdown_cap = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_0[i] == 1: \n            must_on[i] = (t_0[i] < min_up[i]) or (p_0[i] > shutdown_cap[i])\n            free_on[i] = not must_on[i]\n        else:\n            must_off[i] = (-t_0[i] < min_down[i])\n            free_off[i] = not must_off[i]\n    \n    committed = must_on.copy()\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    for i in range(n_units):\n        if free_on[i]:\n            committed[i] = True\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed and total_min > current_load:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_min - eff_min[i] <= current_load:\n                break\n            committed[i] = False\n            eff_min[i] = eff_max[i] = 0.0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n    \n    free_off_available = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_available and total_max < current_load:\n        metric_commit = []\n        for i in free_off_available:\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            cost = s[i] + a[i] + b[i] * eff_min_i + c[i] * eff_min_i**2\n            metric_commit.append(cost / eff_min_i)\n        idx_sorted = np.argsort(metric_commit)\n        \n        for idx in idx_sorted:\n            i = free_off_available[idx]\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            if total_max + eff_max_i >= current_load:\n                break\n            committed[i] = True\n            eff_min[i] = eff_min_i\n            eff_max[i] = eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_max - eff_max[i] >= current_load:\n                committed[i] = False\n                eff_min[i] = eff_max[i] = 0.0\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n    \n    p = [0.0] * n_units\n    if not any(committed):\n        return np.array([committed, p])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    if current_load <= total_min:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_max[i]\n    else:\n        committed_units = [i for i in range(n_units) if committed[i]]\n        low = min(2 * c[i] * eff_min[i] + b[i] for i in committed_units) - 100\n        high = max(2 * c[i] * eff_max[i] + b[i] for i in committed_units) + 100\n        \n        for _ in range(100):\n            lamb = (low + high) / 2\n            p_temp = []\n            total_p = 0.0\n            for i in committed_units:\n                p_i = (lamb - b[i]) / (2 * c[i])\n                p_i = max(eff_min[i], min(eff_max[i], p_i))\n                p_temp.append(p_i)\n                total_p += p_i\n            \n            if total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n        \n        residual = current_load - total_p\n        if residual != 0:\n            if residual > 0:\n                eligible = [(i, p_temp[k], eff_max[i]) for k, i in enumerate(committed_units) if p_temp[k] < eff_max[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]))\n                for i, current, upper in eligible:\n                    available = upper - current\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = upper\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] += residual\n                        residual = 0\n                        break\n            else:\n                residual = abs(residual)\n                eligible = [(i, p_temp[k], eff_min[i]) for k, i in enumerate(committed_units) if p_temp[k] > eff_min[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]), reverse=True)\n                for i, current, lower in eligible:\n                    available = current - lower\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = lower\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] -= residual\n                        residual = 0\n                        break\n            \n            total_p = sum(p_temp)\n            residual_final = current_load - total_p\n            if residual_final != 0:\n                avg_adjust = residual_final / len(committed_units)\n                p_temp = [min(eff_max[i], max(eff_min[i], p_temp[k] + avg_adjust)) for k, i in enumerate(committed_units)]\n                total_p = sum(p_temp)\n                remaining_adjust = current_load - total_p\n                if remaining_adjust > 0:\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, eff_max[i] - p_temp[k])\n                        p_temp[k] += diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n                elif remaining_adjust < 0:\n                    remaining_adjust = abs(remaining_adjust)\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, p_temp[k] - eff_min[i])\n                        p_temp[k] -= diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n        \n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n        else:\n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n    \n    schedules[0] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00543839,
          "gap_price_rate": 0.0077145078,
          "fitness": 0.0065764489
     },
     {
          "name": "optimized_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable). \n2. Commit must-on and free-on units as initial set. \n3. Compute effective min/max outputs considering ramp constraints: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments. \n4. Decommit free-on units by highest cost/MW (a_i + b_i * eff_min_i + c_i * eff_min_i^2)/eff_min_i until total min output \u2264 current load. \n5. Commit free-off units by lowest (s_i + a_i + b_i * p_min_i + c_i * p_min_i^2)/p_min_i until total max output \u2265 current load. \n6. Decommit remaining free-on units in descending order of cost/MW at effective min if removal maintains total max \u2265 load. \n7. Dispatch: \n   a) If load \u2264 total min: set outputs to effective min \n   b) If load \u2265 total max: set outputs to effective max \n   c) Else: perform economic dispatch via lambda iteration with bisection (100 iterations) followed by residual adjustment based on marginal cost merit order. \n8. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize units arrays\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    is_must_on = np.zeros(n_units, dtype=bool)\n    is_must_off = np.zeros(n_units, dtype=bool)\n    is_free_on = np.zeros(n_units, dtype=bool)\n    is_free_off = np.zeros(n_units, dtype=bool)\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    headroom = np.zeros(n_units)\n    min_costs = np.zeros(n_units)\n    startup_metrics = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    \n    # Step 1: Classify units\n    is_must_on = (u0 == 1) & ((t0 < min_up) | (p0 > p_shut))\n    is_must_off = (u0 == 0) & (t0 > -min_down)\n    is_free_on = (u0 == 1) & (~is_must_on)\n    is_free_off = (u0 == 0) & (~is_must_off)\n    \n    # Step 2: Initial commit (must-on + free-on)\n    u[is_must_on | is_free_on] = 1\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in range(n_units):\n        if u[i]:\n            if u0[i]:  # Previously online\n                effective_min[i] = max(p_min[i], p0[i] - p_down[i])\n                effective_max[i] = min(p_max[i], p0[i] + p_up[i])\n            else:  # New start\n                effective_min[i] = p_min[i]\n                effective_max[i] = min(p_max[i], p_start[i])\n        else:\n            effective_min[i] = effective_max[i] = 0.0\n    \n    total_min = np.sum(effective_min[u == 1])\n    total_max = np.sum(effective_max[u == 1])\n    \n    # Step 4: Decommit expensive free-on units\n    if total_min > current_load:\n        # Calculate min cost per MW\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            if total_min <= current_load:\n                break\n            unit_idx = free_on_indices[idx]\n            if u[unit_idx]:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 5: Commit cheap free-off units\n    if total_max < current_load:\n        # Calculate startup metric\n        startup_metrics = (startup_cost[is_free_off] + a[is_free_off] +\n                           b[is_free_off] * p_min[is_free_off] + \n                           c[is_free_off] * p_min[is_free_off]**2) / p_min[is_free_off]\n        free_off_indices = np.where(is_free_off)[0]\n        sort_indices = np.argsort(startup_metrics)\n        \n        for idx in sort_indices:\n            unit_idx = free_off_indices[idx]\n            new_min = p_min[unit_idx]\n            new_max = min(p_max[unit_idx], p_start[unit_idx])\n            if total_max + new_max >= current_load:\n                break\n            u[unit_idx] = 1\n            effective_min[unit_idx] = new_min\n            effective_max[unit_idx] = new_max\n            total_min += new_min\n            total_max += new_max\n    \n    # Step 6: Decommit non-essential free-on units\n    if any(is_free_on & u.astype(bool)):\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on & u)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            unit_idx = free_on_indices[idx]\n            if total_max - effective_max[unit_idx] >= current_load:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 7: Dispatch power to committed units\n    if current_load <= total_min:\n        p = np.where(u, effective_min, 0.0)\n    elif current_load >= total_max:\n        p = np.where(u, effective_max, 0.0)\n    else:\n        # Get indices of committed units\n        committed_idx = np.where(u)[0]\n        comm_min = effective_min[committed_idx]\n        comm_max = effective_max[committed_idx]\n        comm_a = a[committed_idx]\n        comm_b = b[committed_idx]\n        comm_c = c[committed_idx]\n        \n        # Bisection method setup\n        lambda_low = np.min(comm_b + 2 * comm_c * comm_min)\n        lambda_high = np.max(comm_b + 2 * comm_c * comm_max)\n        tolerance = 1e-5\n        \n        # Run bisection\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_set = np.clip((lambda_mid - comm_b) / (2 * comm_c + 1e-10), comm_min, comm_max)\n            total_power = np.sum(p_set)\n            \n            if abs(total_power - current_load) < tolerance:\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Residual adjustment\n        deficit = current_load - total_power\n        if abs(deficit) > tolerance:\n            # Compute marginal cost at current setpoints\n            marginal_costs = comm_b + 2 * comm_c * p_set\n            headroom = comm_max - p_set\n            \n            # Merit order for deficit adjustment\n            if deficit > 0:\n                priority_order = np.argsort(marginal_costs)\n                for idx in priority_order:\n                    if deficit <= 0:\n                        break\n                    if headroom[idx] > 0:\n                        adjust = min(headroom[idx], deficit)\n                        p_set[idx] += adjust\n                        deficit -= adjust\n            else:  # surplus (negative deficit)\n                surplus = -deficit\n                priority_order = np.argsort(marginal_costs)[::-1]\n                for idx in priority_order:\n                    if surplus <= 0:\n                        break\n                    avail = p_set[idx] - comm_min[idx]\n                    if avail > 0:\n                        adjust = min(avail, surplus)\n                        p_set[idx] -= adjust\n                        surplus -= adjust\n        \n        # Assign dispatch values\n        p[committed_idx] = p_set\n    \n    # Step 8: Set non-committed units\n    p[u == 0] = 0.0\n    \n    # Prepare output array\n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0061078301,
          "gap_price_rate": 0.0078211476,
          "fitness": 0.0069644889
     },
     {
          "name": "refined_optimized_rolling_commitment",
          "algorithm": "1. Classify units into must_on (previous online and (min up-time unfulfilled or previous output > shutdown capacity), must_off (previous offline and min down-time unfulfilled), free_on (previously online and decommitable), free_off (previously offline and commitable). 2. Initially commit must_on and free_on units. 3. Compute effective min/max: for previously online units use ramp constraints [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]; for free_off units [p_min, min(p_max, startup_ramp)]. 4. Decommit free_on units by highest cost/MW at min_eff until total_min_eff \u2264 load. 5. Commit free_off units by lowest (startup_cost + cost at min_output)/min_output until total_max_eff \u2265 load. 6. Decommit non-essential free_on units by highest cost/MW at min_eff if removal maintains total_max_eff \u2265 load. 7. Decommit committed free_off units by highest cost/MW at min_output if removal maintains total_max_eff \u2265 load. 8. Dispatch: if load \u2264 total_min use min outputs; if load \u2265 total_max use max outputs; else perform lambda iteration (100 bisection steps) with clamping and residual adjustment.\n",
          "code": "import numpy as np\n\ndef refined_optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min) or (p_i0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            u_current[i] = 1\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if t_i0 > -t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            u_current[i] = 0\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commitment\n    u_current[[must_on + free_on]] = 1\n    total_min = sum(min_eff[must_on + free_on])\n    total_max = sum(max_eff[must_on + free_on])\n    \n    # Decommit free_on units if min capacity exceeds load\n    free_on_committed = [i for i in free_on if u_current[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_on_committed[idx]\n            if total_min > current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Commit free_off units if max capacity below load\n    free_off_available = [i for i in free_off if u_current[i] == 0]\n    if free_off_available:\n        cost_per_mw = []\n        eff_mins = []\n        eff_maxs = []\n        for i in free_off_available:\n            cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            eff_mins.append(min_eff[i])\n            eff_maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)\n        for idx in order:\n            i = free_off_available[idx]\n            if total_max < current_load:\n                u_current[i] = 1\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n    \n    # Decommit non-essential free_on units\n    free_on_committed = [i for i in free_on if u_current[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        maxs = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_on_committed[idx]\n            if (total_max - max_eff[i]) >= current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Decommit non-essential free_off units\n    free_off_committed = [i for i in free_off if u_current[i] == 1]\n    if free_off_committed:\n        cost_per_mw = []\n        maxs = []\n        for i in free_off_committed:\n            cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_off_committed[idx]\n            if (total_max - max_eff[i]) >= current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Dispatch\n    committed = np.where(u_current == 1)[0]\n    if not committed.size:\n        return np.array([u_current, p_current])\n    \n    total_committed_min = min_eff[committed].sum()\n    total_committed_max = max_eff[committed].sum()\n    \n    if current_load <= total_committed_min:\n        for i in committed:\n            p_current[i] = min_eff[i]\n    elif current_load >= total_committed_max:\n        for i in committed:\n            p_current[i] = max_eff[i]\n    else:\n        a = np.array([units_info[i]['a_i'] for i in committed])\n        b = np.array([units_info[i]['b_i'] for i in committed])\n        c = np.array([units_info[i]['c_i'] for i in committed])\n        p_min = min_eff[committed]\n        p_max = max_eff[committed]\n        \n        lam_low = np.min(b + 2*c*p_min)\n        lam_high = np.max(b + 2*c*p_max)\n        p = np.zeros(len(committed))\n        iter_count = 100\n        \n        for _ in range(iter_count):\n            lam = (lam_low + lam_high) / 2\n            for j in range(len(committed)):\n                if c[j] == 0:\n                    if lam > b[j]:\n                        p[j] = p_max[j]\n                    else:\n                        p[j] = p_min[j]\n                else:\n                    p_unclamped = (lam - b[j]) / (2*c[j])\n                    p[j] = np.clip(p_unclamped, p_min[j], p_max[j])\n            total_p = np.sum(p)\n            if abs(total_p - current_load) < 1e-6:\n                break\n            if total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > 1e-6:\n            if residual > 0:\n                candidates = [j for j in range(len(committed)) if p[j] < p_max[j]]\n                marginal_costs = b + 2*c*p\n                candidates.sort(key=lambda j: marginal_costs[j])\n                for j in candidates:\n                    if residual <= 0:\n                        break\n                    available = p_max[j] - p[j]\n                    add = min(available, residual)\n                    p[j] += add\n                    residual -= add\n            else:\n                residual = abs(residual)\n                candidates = [j for j in range(len(committed)) if p[j] > p_min[j]]\n                marginal_costs = b + 2*c*p\n                candidates.sort(key=lambda j: marginal_costs[j], reverse=True)\n                for j in candidates:\n                    if residual <= 0:\n                        break\n                    available = p[j] - p_min[j]\n                    reduce_by = min(available, residual)\n                    p[j] -= reduce_by\n                    residual -= reduce_by\n        \n        p_current[committed] = p\n    \n    return np.array([u_current, p_current])",
          "from": "mutation",
          "gap_power_rate": 0.0050015901,
          "gap_price_rate": 0.0092352064,
          "fitness": 0.0071183982
     },
     {
          "name": "optimized_rolling_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef optimized_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Precompute effective min and max for each unit\n    effective_min = [0.0] * n_units\n    effective_max = [0.0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            effective_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            effective_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            effective_min[i] = unit['p_min_i']\n            effective_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    # Initialize commitment (u) and power output (p) arrays\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 2: Commit must_on and free_on initially\n    for i in range(n_units):\n        if must_on[i] or free_on[i]:\n            u[i] = 1\n            \n    # Step 4: Decommit expensive free_on units until total_min <= current_load\n    total_min = 0.0\n    for i in range(n_units):\n        if u[i] == 1:\n            total_min += effective_min[i]\n            \n    free_on_indices = [i for i in range(n_units) if free_on[i] and u[i]==1]\n    free_on_indices.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*effective_min[i] + units_info[i]['c_i']*effective_min[i]**2) / effective_min[i], reverse=True)\n    \n    while free_on_indices and total_min > current_load:\n        i = free_on_indices.pop(0)\n        total_min -= effective_min[i]\n        u[i] = 0\n        \n    # Step 5: Commit free_off in ascending order of cost per MW (including startup) until total_max >= load\n    total_max = 0.0\n    for i in range(n_units):\n        if u[i] == 1:\n            total_max += effective_max[i]\n            \n    free_off_indices = [i for i in range(n_units) if free_off[i] and u[i]==0]\n    metric_commit = lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*effective_min[i] + units_info[i]['c_i']*effective_min[i]**2) / effective_min[i]\n    free_off_indices.sort(key=metric_commit)\n    \n    committed_free_off = []\n    while free_off_indices and total_max < current_load:\n        i = free_off_indices.pop(0)\n        u[i] = 1\n        total_max += effective_max[i]\n        committed_free_off.append(i)\n        \n    # Step 5.5: Decommit expensive free_off units if removal still satisfies total_max >= load\n    committed_free_off.sort(key=metric_commit, reverse=True)\n    for i in committed_free_off:\n        if total_max - effective_max[i] >= current_load:\n            u[i] = 0\n            total_max -= effective_max[i]\n            \n    # Step 6: Decommit non-essential free_on in descending order of cost per MW at min\n    free_on_remaining = [i for i in range(n_units) if free_on[i] and u[i]==1]\n    metric_on = lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*effective_min[i] + units_info[i]['c_i']*effective_min[i]**2) / effective_min[i]\n    free_on_remaining.sort(key=metric_on, reverse=True)\n    \n    for i in free_on_remaining:\n        if total_max - effective_max[i] >= current_load:\n            u[i] = 0\n            total_max -= effective_max[i]\n            \n    # Step 7: Dispatch the load to committed units\n    committed_indices = [i for i in range(n_units) if u[i]==1]\n    \n    if not committed_indices:\n        # If no units are committed, set p to 0 and return\n        return np.array([u, p])\n    \n    total_min_dispatch = sum(effective_min[i] for i in committed_indices)\n    total_max_dispatch = sum(effective_max[i] for i in committed_indices)\n    \n    if current_load <= total_min_dispatch:\n        for i in committed_indices:\n            p[i] = effective_min[i]\n    elif current_load >= total_max_dispatch:\n        for i in committed_indices:\n            p[i] = effective_max[i]\n    else:\n        # Lambda iteration\n        low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_min[i] for i in committed_indices)\n        high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_max[i] for i in committed_indices)\n        n_iter = 100\n        tol = 1e-5\n        lam = (low + high) / 2\n        \n        for _ in range(n_iter):\n            total_power = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(effective_min[i], min(effective_max[i], p_i))\n                total_power += p_i\n                \n            diff = total_power - current_load\n            if abs(diff) < tol:\n                break\n                \n            if diff < 0:\n                low = lam\n            else:\n                high = lam\n                \n            lam = (low + high) / 2\n        else:\n            pass\n        \n        # Compute outputs with final lambda\n        outputs = []\n        total_power = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = max(effective_min[i], min(effective_max[i], p_i))\n            outputs.append(p_i)\n            total_power += p_i\n            \n        # Residual adjustment\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            if residual > 0:\n                candidates = [i for i in committed_indices if outputs[committed_indices.index(i)] < effective_max[i]]\n                candidates.sort(key=lambda i: (units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[committed_indices.index(i)]))\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    idx = committed_indices.index(i)\n                    available = effective_max[i] - outputs[idx]\n                    if available > 0:\n                        add = min(available, residual)\n                        outputs[idx] += add\n                        residual -= add\n            else:\n                residual_abs = -residual\n                candidates = [i for i in committed_indices if outputs[committed_indices.index(i)] > effective_min[i]]\n                candidates.sort(key=lambda i: -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[committed_indices.index(i)]))\n                for i in candidates:\n                    if residual_abs <= 0:\n                        break\n                    idx = committed_indices.index(i)\n                    available = outputs[idx] - effective_min[i]\n                    if available > 0:\n                        deduct = min(available, residual_abs)\n                        outputs[idx] -= deduct\n                        residual_abs -= deduct\n                residual = -residual_abs\n                \n        for idx, i in enumerate(committed_indices):\n            p[i] = outputs[idx]\n            \n    # Ensure non-committed units have p_i=0\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0.0\n            \n    return np.array([u, p], dtype=float)",
          "from": "mutation",
          "gap_power_rate": 0.0050015912,
          "gap_price_rate": 0.0092352062,
          "fitness": 0.0071183987
     },
     {
          "name": "optimized_rolling_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef optimized_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract unit parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    u_i0 = [u['u_i_0'] for u in units_info]\n    p_i0 = [u['p_i_0'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    t_i0 = [u['t_i_0'] for u in units_info]\n    \n    # Classify units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_i0[i] == 1:\n            min_up_violated = t_i0[i] < t_on_min[i]\n            shutdown_constraint = p_i0[i] > p_shut[i]\n            must_on[i] = min_up_violated or shutdown_constraint\n            if not must_on[i]:\n                free_on[i] = True\n        else:\n            min_down_violated = -t_i0[i] < t_off_min[i]\n            must_off[i] = min_down_violated\n            if not must_off[i]:\n                free_off[i] = True\n    \n    # Initialize commitment and effective limits\n    committed = [must_on[i] or free_on[i] for i in range(n_units)]\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    for i in range(n_units):\n        if u_i0[i] == 1:\n            min_eff[i] = max(p_min[i], p_i0[i] - p_down[i])\n            max_eff[i] = min(p_max[i], p_i0[i] + p_up[i])\n        else:\n            min_eff[i] = 0\n            max_eff[i] = 0\n    \n    # Candidate limits for free-off units (if committed)\n    candidate_min = [p_min[i] for i in range(n_units)]\n    candidate_max = [min(p_max[i], p_start[i]) for i in range(n_units)]\n    \n    total_min = sum(min_eff)\n    total_max = sum(max_eff)\n    \n    # Step 4: Decommit free-on by highest cost per MW at min_eff\n    free_on_indices = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_indices:\n        cost_per_mw = []\n        for i in free_on_indices:\n            op_cost = a[i] + b[i] * min_eff[i] + c[i] * (min_eff[i] ** 2)\n            cost_per_mw.append(op_cost / min_eff[i] if min_eff[i] > 1e-6 else float('inf'))\n        sorted_indices = sorted(zip(free_on_indices, cost_per_mw), key=lambda x: x[1], reverse=True)\n        \n        for (i, _) in sorted_indices:\n            if total_min <= current_load:\n                break\n            if committed[i]:\n                committed[i] = False\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n                min_eff[i] = 0\n                max_eff[i] = 0\n    \n    # Step 5: Commit free-off by lowest cost per MW at min (including startup)\n    free_off_indices = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_indices:\n        cost_per_mw = []\n        for i in free_off_indices:\n            op_cost = a[i] + b[i] * candidate_min[i] + c[i] * (candidate_min[i] ** 2)\n            total_cost = s[i] + op_cost\n            cost_per_mw.append(total_cost / candidate_min[i] if candidate_min[i] > 1e-6 else float('inf'))\n        sorted_indices = sorted(zip(free_off_indices, cost_per_mw), key=lambda x: x[1])\n        \n        for (i, _) in sorted_indices:\n            if total_max >= current_load:\n                break\n            if not committed[i]:\n                committed[i] = True\n                min_eff[i] = candidate_min[i]\n                max_eff[i] = candidate_max[i]\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n    \n    # Step 6: Decommit non-essential units (free-on or free-off) by highest cost per MW\n    non_must_committed = [i for i in range(n_units) if committed[i] and not must_on[i]]\n    if non_must_committed:\n        cost_per_mw = []\n        for i in non_must_committed:\n            if free_on[i]:\n                op_cost = a[i] + b[i] * min_eff[i] + c[i] * (min_eff[i] ** 2)\n                cost = op_cost / min_eff[i] if min_eff[i] > 1e-6 else float('inf')\n            else:  # free-off\n                op_cost = a[i] + b[i] * min_eff[i] + c[i] * (min_eff[i] ** 2)\n                total_cost = s[i] + op_cost\n                cost = total_cost / min_eff[i] if min_eff[i] > 1e-6 else float('inf')\n            cost_per_mw.append(cost)\n        sorted_indices = sorted(zip(non_must_committed, cost_per_mw), key=lambda x: x[1], reverse=True)\n        \n        for (i, _) in sorted_indices:\n            if total_max - max_eff[i] >= current_load:\n                committed[i] = False\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n                min_eff[i] = 0\n                max_eff[i] = 0\n    \n    # Dispatch\n    p_out = [0.0] * n_units\n    u_out = [0] * n_units\n    I = [i for i in range(n_units) if committed[i]]\n    \n    if I:\n        tot_min = sum(min_eff[i] for i in I)\n        tot_max = sum(max_eff[i] for i in I)\n        \n        if current_load <= tot_min + 1e-6:\n            for i in I:\n                p_out[i] = min_eff[i]\n                u_out[i] = 1\n        elif current_load >= tot_max - 1e-6:\n            for i in I:\n                p_out[i] = max_eff[i]\n                u_out[i] = 1\n        else:\n            # Lambda iteration with bisection\n            low = 0\n            high = max(b[i] + 2 * c[i] * p_max[i] for i in I) * 2\n            n_iter = 100\n            tol = 1e-5\n            p_trial = [0.0] * n_units\n            total_p = 0.0\n            \n            for _ in range(n_iter):\n                lam = (low + high) / 2\n                total_p = 0.0\n                for i in I:\n                    p = (lam - b[i]) / (2 * c[i]) if c[i] > 1e-6 else max_eff[i]\n                    p_clamped = min(max_eff[i], max(min_eff[i], p))\n                    p_trial[i] = p_clamped\n                    total_p += p_clamped\n                \n                if abs(total_p - current_load) < tol:\n                    break\n                if total_p < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Residual adjustment\n            residual = current_load - total_p\n            if abs(residual) > 1e-3:\n                if residual > 0:\n                    # Increase under-max units by MC merit\n                    under_max = [i for i in I if p_trial[i] < max_eff[i] - 1e-3]\n                    under_max.sort(key=lambda i: b[i] + 2 * c[i] * p_trial[i])\n                    for i in under_max:\n                        if residual <= 0:\n                            break\n                        max_add = min(max_eff[i] - p_trial[i], residual)\n                        p_trial[i] += max_add\n                        residual -= max_add\n                else:\n                    # Decrease above-min units by MC merit\n                    above_min = [i for i in I if p_trial[i] > min_eff[i] + 1e-3]\n                    above_min.sort(key=lambda i: b[i] + 2 * c[i] * p_trial[i], reverse=True)\n                    for i in above_min:\n                        if residual >= 0:\n                            break\n                        max_reduce = min(p_trial[i] - min_eff[i], -residual)\n                        p_trial[i] -= max_reduce\n                        residual += max_reduce\n            \n            for i in I:\n                p_out[i] = p_trial[i]\n                u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.005001591,
          "gap_price_rate": 0.0092352065,
          "fitness": 0.0071183988
     },
     {
          "name": "refined_evolved_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Preallocate arrays\n    u = np.zeros(n_units)  # Commitment status\n    p = np.zeros(n_units)  # Output power\n    cat = [''] * n_units   # Unit categories\n    eff_min = np.zeros(n_units)  # Effective min output\n    eff_max = np.zeros(n_units)  # Effective max output\n    \n    # Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                cat[i] = 'must_on'\n                u[i] = 1\n            else:\n                cat[i] = 'free_on'\n                u[i] = 1\n        else:  # Previously offline\n            if t0 < 0 and (-t0) < unit['t_off_min_i']:\n                cat[i] = 'must_off'\n                u[i] = 0\n            else:\n                cat[i] = 'free_off'\n                u[i] = 0\n                \n    # Step 4: Decommit high-cost free-on units\n    free_on_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    total_min = sum(eff_min[i] for i in range(n_units) if u[i]==1)\n    \n    # Define cost per MW metric\n    def cost_metric(i, include_startup=False):\n        base = units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \\\n               units_info[i]['c_i'] * eff_min[i]**2\n        if include_startup:\n            base += units_info[i]['s_i']\n        denom = eff_min[i] if eff_min[i] >= 1e-5 else 1.0\n        return base / denom\n    \n    # Decommit free-on units until total_min \u2264 current_load\n    if total_min > current_load:\n        sorted_free_on = sorted(free_on_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit low-cost free-off units\n    total_max = sum(eff_max[i] for i in range(n_units) if u[i]==1)\n    free_off_idx = [i for i in range(n_units) if cat[i]=='free_off' and u[i]==0]\n    \n    if total_max < current_load:\n        sorted_free_off = sorted(free_off_idx, key=lambda i: cost_metric(i, include_startup=True))\n        for i in sorted_free_off:\n            u[i] = 1\n            total_max += eff_max[i]\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_rem_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    curr_total_max = total_max\n    \n    if free_on_rem_idx:\n        sorted_free_on_rem = sorted(free_on_rem_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on_rem:\n            new_total_max = curr_total_max - eff_max[i]\n            if new_total_max >= current_load:\n                u[i] = 0\n                curr_total_max = new_total_max\n    \n    # Dispatch committed units\n    committed_idx = [i for i in range(n_units) if u[i]==1]\n    total_min_comm = sum(eff_min[i] for i in committed_idx)\n    total_max_comm = sum(eff_max[i] for i in committed_idx)\n    \n    if committed_idx:\n        if current_load <= total_min_comm:\n            for i in committed_idx:\n                p[i] = eff_min[i]\n        elif current_load >= total_max_comm:\n            for i in committed_idx:\n                p[i] = eff_max[i]\n        else:\n            # Bisection for lambda\n            low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_min[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_min[i] > 0)\n            high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_max[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_max[i] > 0)\n            \n            for _ in range(100):\n                lam = (low + high) / 2\n                total_p = 0.0\n                for i in committed_idx:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_unclamp = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_i = max(eff_min[i], min(eff_max[i], p_unclamp))\n                    else:\n                        p_i = eff_max[i] if lam > unit['b_i'] else eff_min[i]\n                    p[i] = p_i\n                    total_p += p_i\n                \n                if total_p < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Residual adjustment\n            residual = current_load - total_p\n            if residual > 0:\n                candidates = [i for i in committed_idx if p[i] < eff_max[i]]\n                candidates.sort(key=lambda i: unit['b_i'] + 2 * unit['c_i'] * p[i])\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    inc = min(residual, eff_max[i] - p[i])\n                    p[i] += inc\n                    residual -= inc\n            elif residual < 0:\n                residual = abs(residual)\n                candidates = [i for i in committed_idx if p[i] > eff_min[i]]\n                candidates.sort(key=lambda i: -(unit['b_i'] + 2 * unit['c_i'] * p[i]))\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    dec = min(residual, p[i] - eff_min[i])\n                    p[i] -= dec\n                    residual -= dec\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0046081286,
          "gap_price_rate": 0.0097404235,
          "fitness": 0.0071742761
     },
     {
          "name": "refined_evolved_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on (prev online and (min up-time unfulfilled or prev output > shutdown capacity), must-off (prev offline and min down-time unfulfilled), free-on (prev online but decommittable), free-off (prev offline but committable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost/MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + cost at min)/min_output until total max \u2265 load\n6. While possible, decommit free-on units with highest cost/MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection (100 iters) then residual adjustment via merit order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters and initialize\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed = set()\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Was online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_on.append(i)\n                committed.add(i)\n            else:\n                free_on.append(i)\n                committed.add(i)\n        else:  # Was offline\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Prev online\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # New start (not possible here but safe)\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit free-on units if over-min\n    total_min = np.sum(eff_min[list(committed)])\n    free_on_in_committed = [i for i in free_on if i in committed]\n    \n    # Sort free-on by cost/MW at min desc\n    free_on_in_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        if i in committed:\n            committed.remove(i)\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit free-off units if under-max\n    total_max = np.sum(eff_max[list(committed)])\n    # Precompute new start effective max/min\n    for i in free_off:\n        unit = units_info[i]\n        eff_min[i] = unit['p_min_i']\n        eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Sort free-off by (startup cost + cost at min)/min\n    free_off_sorted = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        if i not in committed:\n            committed.add(i)\n            total_max += eff_max[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    removed = True\n    while removed:\n        removed = False\n        total_max = np.sum(eff_max[list(committed)])\n        free_on_committed = [i for i in free_on if i in committed]\n        free_on_committed.sort(key=lambda i: (\n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n        ) / units_info[i]['p_min_i'], reverse=True)\n        \n        for i in free_on_committed:\n            if total_max - eff_max[i] >= current_load:\n                committed.remove(i)\n                removed = True\n                break\n    \n    # Step 7: Dispatch\n    # Recompute effective min/max for final committed set\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[list(committed)])\n    total_max = np.sum(eff_max[list(committed)])\n    \n    comm_list = list(committed)\n    if current_load <= total_min:\n        for i in comm_list:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in comm_list:\n            p[i] = eff_max[i]\n    else:\n        # Lambda iteration\n        a = [units_info[i]['a_i'] for i in comm_list]\n        b = [units_info[i]['b_i'] for i in comm_list]\n        c = [units_info[i]['c_i'] for i in comm_list]\n        lows = [eff_min[i] for i in comm_list]\n        highs = [eff_max[i] for i in comm_list]\n        n_comm = len(comm_list)\n        \n        # Find lambda range\n        lo = min(b_i + 2*c_i*low_i for (b_i, c_i, low_i) in zip(b, c, lows))\n        hi = max(b_i + 2*c_i*high_i for (b_i, c_i, high_i) in zip(b, c, highs))\n        \n        # Bisection\n        for _ in range(100):\n            lam = (lo + hi) / 2\n            total_p = 0\n            for i in range(n_comm):\n                mc_low = b[i] + 2*c[i]*lows[i]\n                mc_high = b[i] + 2*c[i]*highs[i]\n                if lam < mc_low:\n                    p_i = lows[i]\n                elif lam > mc_high:\n                    p_i = highs[i]\n                else:\n                    p_i = (lam - b[i]) / (2*c[i])\n                total_p += p_i\n            \n            if total_p < current_load:\n                lo = lam\n            else:\n                hi = lam\n        \n        # Calculate p based on final lambda\n        total_p = 0\n        p_dispatch = [0] * n_comm\n        for i in range(n_comm):\n            mc_low = b[i] + 2*c[i]*lows[i]\n            mc_high = b[i] + 2*c[i]*highs[i]\n            if lam < mc_low:\n                p_i = lows[i]\n            elif lam > mc_high:\n                p_i = highs[i]\n            else:\n                p_i = (lam - b[i]) / (2*c[i])\n            p_dispatch[i] = p_i\n            total_p += p_i\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        tol = 1e-5\n        if residual > tol:\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] < highs[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx])\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = highs[idx] - p_dispatch[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] += adjust\n                residual -= adjust\n        elif residual < -tol:\n            residual = -residual\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] > lows[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx], reverse=True)\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = p_dispatch[idx] - lows[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] -= adjust\n                residual -= adjust\n        \n        # Assign dispatched values\n        for ii, i in enumerate(comm_list):\n            p[i] = p_dispatch[ii]\n    \n    # Set commitments and output for non-committed\n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0091401443,
          "fitness": 0.0072843404
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "**  \n1. Classify units:  \n   - must_on: Previously online and (min up-time unfulfilled or previous output > shutdown capacity)  \n   - must_off: Previously offline and min down-time unfulfilled  \n   - free_on: Online and decommittable  \n   - free_off: Offline and committable  \n2. Commit must_on and free_on units.  \n3. Compute effective min/max:  \n   - Previously online: `[max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]`  \n   - New starts: `[p_min, min(p_max, startup_ramp)]`  \n4. Decommit free-on units by highest cost per MW at effective min until total min \u2264 load.  \n5. Commit free-off units by lowest cost per MW at min (including startup) until total max \u2265 load.  \n6. Decommit non-essential free-on units (by same cost metric) if removal maintains total max \u2265 load.  \n7. Dispatch committed units:  \n   a) If load \u2264 total min: Set outputs to min  \n   b) If load \u2265 total max: Set outputs to max  \n   c) Else: Lambda iteration with residual adjustment:  \n      i. Use bisection to find optimal lambda (with clamping)  \n      ii. Adjust residual via marginal cost merit order  \n8. Set non-committed units to off (0 output).  \n\n**",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    def compute_cost_per_MW(unit, eff_min, include_startup=False):\n        if eff_min <= 1e-10:  # Avoid division by zero\n            return float('inf')\n        cost = unit['a_i'] + unit['b_i'] * eff_min + unit['c_i'] * eff_min**2\n        if include_startup:\n            cost += unit['s_i']\n        return cost / eff_min\n\n    units = []\n    for idx, ui in enumerate(units_info):\n        unit = ui.copy()\n        unit['index'] = idx\n        unit['committed'] = False\n        units.append(unit)\n    \n    current_load = load[0]\n    n_units = len(units)\n    \n    # Step 1: Classify units\n    for u in units:\n        if u['u_i_0'] == 1:  # Previously online\n            if u['t_i_0'] < u['t_on_min_i'] or u['p_i_0'] > u['p_shut_i']:\n                u['class'] = 'must_on'\n            else:\n                u['class'] = 'free_on'\n        else:  # Previously offline\n            if -u['t_i_0'] < u['t_off_min_i']:  # Still in min down-time\n                u['class'] = 'must_off'\n            else:\n                u['class'] = 'free_off'\n    \n    # Step 2: Initial commit (must_on + free_on)\n    for u in units:\n        if u['class'] in ['must_on', 'free_on']:\n            u['committed'] = True\n            if u['u_i_0'] == 1:  # Previously online: ramp constraints\n                u['eff_min'] = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n                u['eff_max'] = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n            else:  # New start (shouldn't happen for must_on/free_on)\n                u['eff_min'] = u['p_min_i']\n                u['eff_max'] = min(u['p_max_i'], u['p_start_i'])\n    \n    # Step 3: Compute total min/max\n    total_min = sum(u['eff_min'] for u in units if u['committed'])\n    total_max = sum(u['eff_max'] for u in units if u['committed'])\n    \n    # Step 4: Decommit expensive free-on units\n    free_on = [u for u in units if u['class'] == 'free_on' and u['committed']]\n    for u in free_on:\n        u['cost_per_MW'] = compute_cost_per_MW(u, u['eff_min'])\n    free_on.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    \n    for unit in free_on:\n        if total_min <= current_load:\n            break\n        unit['committed'] = False\n        total_min -= unit['eff_min']\n        total_max -= unit['eff_max']\n    \n    # Step 5: Commit cheap free-off units\n    free_off = [u for u in units if u['class'] == 'free_off' and not u['committed']]\n    for u in free_off:\n        u['eff_min'] = u['p_min_i']\n        u['eff_max'] = min(u['p_max_i'], u['p_start_i'])\n        u['cost_per_MW'] = compute_cost_per_MW(u, u['eff_min'], include_startup=True)\n    free_off.sort(key=lambda x: x['cost_per_MW'])\n    \n    for unit in free_off:\n        if total_max >= current_load:\n            break\n        unit['committed'] = True\n        total_min += unit['eff_min']\n        total_max += unit['eff_max']\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_committed = [u for u in units if u['class'] == 'free_on' and u['committed']]\n    free_on_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    for unit in free_on_committed:\n        if total_max - unit['eff_max'] >= current_load:\n            unit['committed'] = False\n            total_min -= unit['eff_min']\n            total_max -= unit['eff_max']\n    \n    # Collect committed units\n    committed = [u for u in units if u['committed']]\n    total_min = sum(u['eff_min'] for u in committed)\n    total_max = sum(u['eff_max'] for u in committed)\n    \n    # Step 7: Dispatch\n    outputs = [0.0] * n_units\n    \n    if len(committed) == 0:\n        # Edge case: no committed units\n        u_vec = [0] * n_units\n        p_vec = [0.0] * n_units\n        return np.array([u_vec, p_vec])\n    \n    # 7a: Min/Max dispatch\n    if current_load <= total_min:\n        for u in committed:\n            outputs[u['index']] = u['eff_min']\n    elif current_load >= total_max:\n        for u in committed:\n            outputs[u['index']] = u['eff_max']\n    else:\n        # 7c: Lambda iteration (bisection)\n        low_lambda = min(2*u['c_i']*u['eff_min'] + u['b_i'] if u['c_i']>0 else u['b_i'] for u in committed)\n        high_lambda = max(2*u['c_i']*u['eff_max'] + u['b_i'] if u['c_i']>0 else u['b_i'] for u in committed)\n        lambda_ = (low_lambda + high_lambda) / 2\n        \n        n_iter = 0\n        tol = 1e-5\n        total_output = 0\n        temp_outputs = {}\n        \n        # Bisection loop\n        while n_iter < 100 and abs(total_output - current_load) > tol:\n            total_output = 0\n            for u in committed:\n                # Linear units\n                if u['c_i'] == 0:\n                    p_star = u['eff_max'] if lambda_ > u['b_i'] else u['eff_min']\n                # Quadratic units\n                else:\n                    p_star = (lambda_ - u['b_i']) / (2 * u['c_i'])\n                    p_star = max(u['eff_min'], min(u['eff_max'], p_star))\n                temp_outputs[u['index']] = p_star\n                total_output += p_star\n                \n            if abs(total_output - current_load) <= tol:\n                break\n                \n            if total_output < current_load:\n                low_lambda = lambda_\n            else:\n                high_lambda = lambda_\n                \n            lambda_ = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Residual adjustment\n        residual = current_load - total_output\n        if abs(residual) > tol:\n            # Increase needed\n            if residual > 0:\n                candidates = []\n                for u in committed:\n                    if temp_outputs[u['index']] < u['eff_max']:\n                        if u['c_i'] > 0:\n                            mc = 2 * u['c_i'] * temp_outputs[u['index']] + u['b_i']\n                        else:\n                            mc = u['b_i']\n                        candidates.append((mc, u['index']))\n                candidates.sort(key=lambda x: x[0])\n                \n                for mc, idx in candidates:\n                    if abs(residual) < tol:\n                        break\n                    available = units[idx]['eff_max'] - temp_outputs[idx]\n                    delta = min(available, residual)\n                    temp_outputs[idx] += delta\n                    residual -= delta\n                    \n            # Decrease needed\n            elif residual < 0:\n                candidates = []\n                for u in committed:\n                    if temp_outputs[u['index']] > u['eff_min']:\n                        if u['c_i'] > 0:\n                            mc = 2 * u['c_i'] * temp_outputs[u['index']] + u['b_i']\n                        else:\n                            mc = u['b_i']\n                        candidates.append((mc, u['index']))\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                \n                for mc, idx in candidates:\n                    if abs(residual) < tol:\n                        break\n                    available = temp_outputs[idx] - units[idx]['eff_min']\n                    delta = min(available, -residual)\n                    temp_outputs[idx] -= delta\n                    residual += delta\n        \n        for u in committed:\n            outputs[u['index']] = temp_outputs[u['index']]\n    \n    # Final output arrays\n    u_vec = [1 if u['committed'] else 0 for u in units]\n    p_vec = [outputs[i] if u['committed'] else 0.0 for i, u in enumerate(units)]\n    \n    return np.array([u_vec, p_vec])",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "advanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), free-off (offline but commitable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs considering ramp constraints:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost per MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + min_output_cost)/min_output until total max \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection and quadratic/linear handling\n   d) Residual adjustment via marginal cost merit order\n8. Set non-committed units to off state and zero output\n",
          "code": "import numpy as np\n\ndef advanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Precompute min and max for all units\n    min_i = np.zeros(n_units)\n    max_i = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_i[i] = unit['p_min_i']\n            max_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commit\n    committed_units = must_on + free_on\n    total_min = sum(min_i[i] for i in committed_units)\n    total_max = sum(max_i[i] for i in committed_units)\n    \n    # Decommit free-on if min output > load\n    if total_min > current_load:\n        free_on_committed = [i for i in committed_units if i in free_on]\n        if free_on_committed:\n            metrics = []\n            for i in free_on_committed:\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0], reverse=True)\n            for metric, i in metrics:\n                if total_min <= current_load:\n                    break\n                committed_units.remove(i)\n                total_min -= min_i[i]\n                total_max -= max_i[i]\n    \n    # Commit free-off if max output < load\n    if total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed_units]\n        if free_off_available:\n            metrics = []\n            for i in free_off_available:\n                cost = (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                        units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0])\n            for metric, i in metrics:\n                if total_max >= current_load:\n                    break\n                committed_units.append(i)\n                total_min += min_i[i]\n                total_max += max_i[i]\n    \n    # Decommit non-essential free-on\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed_units if i in free_on]\n        if free_on_committed:\n            metrics = []\n            for i in free_on_committed:\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0], reverse=True)\n            for metric, i in metrics:\n                if total_max - max_i[i] >= current_load:\n                    committed_units.remove(i)\n                    total_min -= min_i[i]\n                    total_max -= max_i[i]\n                    changed = True\n                    break\n    \n    # Initialize outputs\n    p_out = np.zeros(n_units)\n    u_out = np.zeros(n_units)\n    \n    if not committed_units:\n        return np.array([u_out, p_out])\n    \n    # Dispatch\n    if current_load <= total_min:\n        for i in committed_units:\n            p_out[i] = min_i[i]\n            u_out[i] = 1\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_out[i] = max_i[i]\n            u_out[i] = 1\n    else:\n        # Lambda iteration\n        min_vals = [min_i[i] for i in committed_units]\n        max_vals = [max_i[i] for i in committed_units]\n        b_vals = [units_info[i]['b_i'] for i in committed_units]\n        c_vals = [units_info[i]['c_i'] for i in committed_units]\n        \n        low = min(2 * c * m + b for c, m, b in zip(c_vals, min_vals, b_vals) if c > 0)\n        high = max(2 * c * M + b for c, M, b in zip(c_vals, max_vals, b_vals) if c > 0)\n        low = min(low, min(b_vals))  # Ensure linear units included\n        high = max(high, max(b_vals))\n        \n        for _ in range(100):\n            lmbda = (low + high) / 2\n            total_p = 0\n            for i, (min_val, max_val, b, c) in enumerate(zip(min_vals, max_vals, b_vals, c_vals)):\n                if c == 0:\n                    p_val = max_val if lmbda > b else min_val\n                else:\n                    p_uncon = (lmbda - b) / (2 * c)\n                    p_val = max(min_val, min(max_val, p_uncon))\n                total_p += p_val\n            if abs(total_p - current_load) < 1e-5:\n                break\n            if total_p > current_load:\n                high = lmbda\n            else:\n                low = lmbda\n        \n        # Apply lambda solution\n        p_temp = {}\n        total_after_iter = 0\n        for idx, (i, min_val, max_val, b, c) in enumerate(zip(committed_units, min_vals, max_vals, b_vals, c_vals)):\n            if c == 0:\n                p_val = max_val if lmbda > b else min_val\n            else:\n                p_uncon = (lmbda - b) / (2 * c)\n                p_val = max(min_val, min(max_val, p_uncon))\n            p_temp[i] = p_val\n            total_after_iter += p_val\n        \n        # Residual adjustment\n        residual = current_load - total_after_iter\n        iter_count = 0\n        max_iter = 1000\n        while abs(residual) > 1e-5 and iter_count < max_iter:\n            if residual > 0:\n                candidates = []\n                for i in committed_units:\n                    if p_temp[i] < max_i[i] - 1e-5:\n                        if units_info[i]['c_i'] == 0:\n                            mc = units_info[i]['b_i']\n                        else:\n                            mc = 2 * units_info[i]['c_i'] * p_temp[i] + units_info[i]['b_i']\n                        candidates.append((mc, i))\n                if not candidates:\n                    break\n                candidates.sort(key=lambda x: x[0])\n                _, i_star = candidates[0]\n                delta = min(residual, max_i[i_star] - p_temp[i_star])\n                p_temp[i_star] += delta\n                residual -= delta\n            else:\n                candidates = []\n                for i in committed_units:\n                    if p_temp[i] > min_i[i] + 1e-5:\n                        if units_info[i]['c_i'] == 0:\n                            mc = units_info[i]['b_i']\n                        else:\n                            mc = 2 * units_info[i]['c_i'] * p_temp[i] + units_info[i]['b_i']\n                        candidates.append((mc, i))\n                if not candidates:\n                    break\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                _, i_star = candidates[0]\n                delta = min(-residual, p_temp[i_star] - min_i[i])\n                p_temp[i_star] -= delta\n                residual += delta\n            iter_count += 1\n        \n        for i in committed_units:\n            p_out[i] = p_temp[i]\n            u_out[i] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0054285375,
          "gap_price_rate": 0.0091401444,
          "fitness": 0.007284341
     }
]