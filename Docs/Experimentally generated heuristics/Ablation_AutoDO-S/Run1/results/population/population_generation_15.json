[
     {
          "name": "refined_optimized_rolling_commitment_v3_improved",
          "algorithm": "1. Classify units into must-on (previously online with unfulfilled min up-time or shutdown constraint), must-off (previously offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable)\n2. Commit must-on and free-on units as initial set\n3. Compute effective min/max outputs: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments\n4. Decommit free-on units by descending (a_i + b_i * eff_min_i + c_i * eff_min_i\u00b2)/eff_min_i until total min output \u2264 current load\n5. Commit free-off units by ascending (s_i + a_i + b_i * p_min_i + c_i * p_min_i\u00b2)/p_min_i until total max output \u2265 current load\n6. Decommit non-essential free-on units by descending cost/MW at eff_min_i if removal maintains total max \u2265 load\n7. Commit free-off units by ascending startup-adjusted cost at eff_min_i until total max output \u2265 load\n8. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: perform economic dispatch via lambda iteration with 100 bisection steps\n   d) Adjust residual by increasing cheapest marginal cost units first for shortages, decreasing most expensive first for surpluses\n9. Set non-committed units to off (0 output)\n10. Return schedules with commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef refined_optimized_rolling_commitment_v3_improved(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed = []\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n                committed.append(i)\n            else:\n                free_on.append(i)\n                committed.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    eff_min = [0] * n_units\n    eff_max = [0] * n_units\n    \n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            eff_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            eff_min[i] = units_info[i]['p_min_i']\n            eff_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(eff_min)\n    total_max = sum(eff_max)\n    \n    free_on_committed = [i for i in free_on if i in committed]\n    metric_decommit1 = []\n    for i in free_on_committed:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i]\n        metric_decommit1.append((metric, i))\n    metric_decommit1.sort(key=lambda x: x[0], reverse=True)\n    \n    for metric, i in metric_decommit1:\n        if total_min <= current_load:\n            break\n        committed.remove(i)\n        total_min -= eff_min[i]\n        total_max -= eff_max[i]\n        eff_min[i] = eff_max[i] = 0\n    \n    free_off_not_committed = [i for i in free_off if i not in committed]\n    metric_commit = []\n    for i in free_off_not_committed:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        metric = cost / unit['p_min_i']\n        metric_commit.append((metric, i))\n    metric_commit.sort(key=lambda x: x[0])\n    \n    for metric, i in metric_commit:\n        if total_max >= current_load:\n            break\n        eff_min_i = units_info[i]['p_min_i']\n        eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.append(i)\n        eff_min[i] = eff_min_i\n        eff_max[i] = eff_max_i\n        total_min += eff_min_i\n        total_max += eff_max_i\n    \n    free_on_committed_now = [i for i in free_on if i in committed and i not in must_on]\n    metric_decommit2 = []\n    for i in free_on_committed_now:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i]\n        metric_decommit2.append((metric, i))\n    metric_decommit2.sort(key=lambda x: x[0], reverse=True)\n    \n    for metric, i in metric_decommit2:\n        if total_max - eff_max[i] >= current_load:\n            committed.remove(i)\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            eff_min[i] = eff_max[i] = 0\n    \n    free_off_not_committed_second = [i for i in free_off if i not in committed]\n    metric_commit2 = []\n    for i in free_off_not_committed_second:\n        unit = units_info[i]\n        cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * eff_min[i] + unit['c_i'] * (eff_min[i] ** 2)\n        metric = cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        metric_commit2.append((metric, i))\n    metric_commit2.sort(key=lambda x: x[0])\n    \n    for metric, i in metric_commit2:\n        if total_max >= current_load:\n            break\n        eff_min_i = units_info[i]['p_min_i']\n        eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.append(i)\n        eff_min[i] = eff_min_i\n        eff_max[i] = eff_max_i\n        total_min += eff_min_i\n        total_max += eff_max_i\n    \n    p = [0] * n_units\n    \n    if current_load <= total_min:\n        for i in committed:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in committed:\n            p[i] = eff_max[i]\n    else:\n        lambda_low = min(unit['b_i'] + 2 * unit['c_i'] * eff_min[i] for i in committed)\n        lambda_high = max(unit['b_i'] + 2 * unit['c_i'] * eff_max[i] for i in committed)\n        if lambda_low == lambda_high:\n            lambda_high += 1.0\n        \n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_output = 0.0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    p_i_uncon = (lambda_mid - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_i_uncon = eff_min[i] if lambda_mid < unit['b_i'] else eff_max[i]\n                p_i = max(eff_min[i], min(eff_max[i], p_i_uncon))\n                p[i] = p_i\n                total_output += p_i\n            if total_output < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < 1e-5:\n                break\n        \n        total_output = sum(p[i] for i in committed)\n        residual = current_load - total_output\n        \n        if residual > 0:\n            unit_list = []\n            for i in committed:\n                unit = units_info[i]\n                avail = eff_max[i] - p[i]\n                if avail > 1e-3:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    unit_list.append((marginal_cost, avail, i))\n            unit_list.sort(key=lambda x: x[0])\n            for _, avail, i in unit_list:\n                if residual <= 0:\n                    break\n                add = min(residual, avail)\n                p[i] += add\n                residual -= add\n        elif residual < 0:\n            residual = abs(residual)\n            unit_list = []\n            for i in committed:\n                unit = units_info[i]\n                avail = p[i] - eff_min[i]\n                if avail > 1e-3:\n                    marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                    unit_list.append((marginal_cost, avail, i))\n            unit_list.sort(key=lambda x: x[0], reverse=True)\n            for _, avail, i in unit_list:\n                if residual <= 0:\n                    break\n                sub = min(residual, avail)\n                p[i] -= sub\n                residual -= sub\n    \n    u = [1 if i in committed else 0 for i in range(n_units)]\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0033546861,
          "gap_price_rate": 0.0081315629,
          "fitness": 0.0057431245
     },
     {
          "name": "refined_evolved_rolling_commitment_v3",
          "algorithm": "1. Classify units into categories: must-on (previously online and violated min up-time or shutdown ramp constraint), must-off (previously offline and violated min down-time), free-on (previously online and commitable), free-off (previously offline and commitable)\n2. Initially commit must-on and free-on units\n3. Compute effective power limits considering ramp constraints:\n   - Previously online: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - New starts: [p_min, min(p_max, startup_ramp)]\n4. Decommit free-on units by highest cost per MW at effective min output ((a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211min_output \u2264 load\n5. Commit free-off units by lowest cost per MW including startup ((s_i + a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211max_output \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW (same metric) if removal maintains \u2211max_output \u2265 load\n7. Dispatch using bisection method to find optimal lambda for economic dispatch with residual adjustment:\n   a) If load \u2264 total min: set all to min output\n   b) If load \u2265 total max: set all to max output\n   c) Else: find \u03bb such that \u2211clamped outputs equals load, then adjust residual by marginal cost order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    if n_units == 0:\n        return schedules\n        \n    u_0 = [unit['u_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    startup_ramp = [unit['p_start_i'] for unit in units_info]\n    shutdown_cap = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_0[i] == 1: \n            must_on[i] = (t_0[i] < min_up[i]) or (p_0[i] > shutdown_cap[i])\n            free_on[i] = not must_on[i]\n        else:\n            must_off[i] = (-t_0[i] < min_down[i])\n            free_off[i] = not must_off[i]\n    \n    committed = must_on.copy()\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    for i in range(n_units):\n        if free_on[i]:\n            committed[i] = True\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed and total_min > current_load:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_min - eff_min[i] <= current_load:\n                break\n            committed[i] = False\n            eff_min[i] = eff_max[i] = 0.0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n    \n    free_off_available = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_available and total_max < current_load:\n        metric_commit = []\n        for i in free_off_available:\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            cost = s[i] + a[i] + b[i] * eff_min_i + c[i] * eff_min_i**2\n            metric_commit.append(cost / eff_min_i)\n        idx_sorted = np.argsort(metric_commit)\n        \n        for idx in idx_sorted:\n            i = free_off_available[idx]\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            if total_max + eff_max_i >= current_load:\n                break\n            committed[i] = True\n            eff_min[i] = eff_min_i\n            eff_max[i] = eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_max - eff_max[i] >= current_load:\n                committed[i] = False\n                eff_min[i] = eff_max[i] = 0.0\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n    \n    p = [0.0] * n_units\n    if not any(committed):\n        return np.array([committed, p])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    if current_load <= total_min:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_max[i]\n    else:\n        committed_units = [i for i in range(n_units) if committed[i]]\n        low = min(2 * c[i] * eff_min[i] + b[i] for i in committed_units) - 100\n        high = max(2 * c[i] * eff_max[i] + b[i] for i in committed_units) + 100\n        \n        for _ in range(100):\n            lamb = (low + high) / 2\n            p_temp = []\n            total_p = 0.0\n            for i in committed_units:\n                p_i = (lamb - b[i]) / (2 * c[i])\n                p_i = max(eff_min[i], min(eff_max[i], p_i))\n                p_temp.append(p_i)\n                total_p += p_i\n            \n            if total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n        \n        residual = current_load - total_p\n        if residual != 0:\n            if residual > 0:\n                eligible = [(i, p_temp[k], eff_max[i]) for k, i in enumerate(committed_units) if p_temp[k] < eff_max[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]))\n                for i, current, upper in eligible:\n                    available = upper - current\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = upper\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] += residual\n                        residual = 0\n                        break\n            else:\n                residual = abs(residual)\n                eligible = [(i, p_temp[k], eff_min[i]) for k, i in enumerate(committed_units) if p_temp[k] > eff_min[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]), reverse=True)\n                for i, current, lower in eligible:\n                    available = current - lower\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = lower\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] -= residual\n                        residual = 0\n                        break\n            \n            total_p = sum(p_temp)\n            residual_final = current_load - total_p\n            if residual_final != 0:\n                avg_adjust = residual_final / len(committed_units)\n                p_temp = [min(eff_max[i], max(eff_min[i], p_temp[k] + avg_adjust)) for k, i in enumerate(committed_units)]\n                total_p = sum(p_temp)\n                remaining_adjust = current_load - total_p\n                if remaining_adjust > 0:\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, eff_max[i] - p_temp[k])\n                        p_temp[k] += diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n                elif remaining_adjust < 0:\n                    remaining_adjust = abs(remaining_adjust)\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, p_temp[k] - eff_min[i])\n                        p_temp[k] -= diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n        \n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n        else:\n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n    \n    schedules[0] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00543839,
          "gap_price_rate": 0.0077145078,
          "fitness": 0.0065764489
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Classify units into:  \n   - must_on (previously online with unfulfilled min up-time or previous output > shutdown capacity)  \n   - must_off (previously offline with unfulfilled min down-time)  \n   - free_on (previously online and decommittable)  \n   - free_off (previously offline and committable)  \n2. Initially commit must_on and free_on units  \n3. Compute effective min/max outputs:  \n   - Previously online: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]  \n   - New starts: [p_min, min(p_max, startup_ramp)]  \n4. Decommit free_on by descending cost/MW at effective min until total min \u2264 load  \n5. Commit free_off by ascending startup-cost-adjusted cost/MW at effective min until total max \u2265 load  \n6. Decommit non-essential free_on by descending cost/MW if removal maintains total max \u2265 load  \n7. Secondary commit free_off by ascending startup-cost-adjusted cost/MW to cover deficits  \n8. Decommit non-essential free_off by descending startup-cost-adjusted cost/MW if removal maintains total max \u2265 load  \n9. Dispatch:  \n   a) Min outputs if load \u2264 total min  \n   b) Max outputs if load \u2265 total max  \n   c) Economic dispatch via lambda iteration with 100 bisections  \n   d) Adjust residual using marginal cost merit order (increasing cheapest units for shortages, decreasing most expensive for surpluses)  \n10. Set non-committed units to offline (0 output)  \n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    cost_func_coeffs = []\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        s_i = unit['s_i']\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        cost_func_coeffs.append((a_i, b_i, c_i, s_i))\n        \n        if u_i0 == 1:\n            min_eff[i] = max(p_min, p_i0 - p_down)\n            max_eff[i] = min(p_max, p_i0 + p_up)\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            min_eff[i] = p_min\n            max_eff[i] = min(p_max, p_start)\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = set(must_on) | set(free_on)\n    free_on_set = set(free_on)\n    free_off_set = set(free_off)\n    \n    def calculate_metric(unit_idx, include_startup=False):\n        a_i, b_i, c_i, s_i = cost_func_coeffs[unit_idx]\n        min_val = min_eff[unit_idx]\n        if min_val == 0:\n            return 10**18\n        base_cost = a_i + b_i * min_val + c_i * min_val**2\n        if include_startup:\n            base_cost += s_i\n        return base_cost / min_val\n    \n    def total_capacity_bound(committed, use_min=True):\n        bound_val = 0.0\n        for idx in committed:\n            bound_val += min_eff[idx] if use_min else max_eff[idx]\n        return bound_val\n    \n    total_min = total_capacity_bound(committed, True)\n    free_on_sorted = sorted(free_on, key=lambda i: calculate_metric(i), reverse=True)\n    for unit_idx in free_on_sorted:\n        if total_min <= current_load:\n            break\n        committed.remove(unit_idx)\n        total_min -= min_eff[unit_idx]\n    \n    total_max = total_capacity_bound(committed, False)\n    free_off_sorted = sorted(free_off, key=lambda i: calculate_metric(i, True))\n    for unit_idx in free_off_sorted:\n        if total_max >= current_load:\n            break\n        committed.add(unit_idx)\n        total_max += max_eff[unit_idx]\n    \n    active_free_on = [i for i in committed & free_on_set]\n    active_free_on_sorted = sorted(active_free_on, key=lambda i: calculate_metric(i), reverse=True)\n    for unit_idx in active_free_on_sorted:\n        if total_max - max_eff[unit_idx] >= current_load:\n            committed.remove(unit_idx)\n            total_max -= max_eff[unit_idx]\n    \n    remaining_free_off = free_off_set - committed\n    remaining_free_off_sorted = sorted(remaining_free_off, key=lambda i: calculate_metric(i, True))\n    for unit_idx in remaining_free_off_sorted:\n        if total_max >= current_load:\n            break\n        committed.add(unit_idx)\n        total_max += max_eff[unit_idx]\n    \n    committed_free_off = committed & free_off_set\n    active_free_off_sorted = sorted(committed_free_off, key=lambda i: calculate_metric(i, True), reverse=True)\n    for unit_idx in active_free_off_sorted:\n        if total_max - max_eff[unit_idx] >= current_load:\n            committed.remove(unit_idx)\n            total_max -= max_eff[unit_idx]\n    \n    dispatch_set = list(committed)\n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    if current_load <= total_min:\n        for idx in committed:\n            p[idx] = min_eff[idx]\n            u[idx] = 1\n    elif current_load >= total_max:\n        for idx in committed:\n            p[idx] = max_eff[idx]\n            u[idx] = 1\n    else:\n        for idx in committed:\n            p[idx] = min_eff[idx]\n        allocated = total_min\n        \n        low, high = -1e6, 1e6\n        for _ in range(100):\n            mid = (low + high) / 2\n            total_gen = 0\n            for i in dispatch_set:\n                a, b, c, _ = cost_func_coeffs[i]\n                if c == 0:\n                    p_i = max_eff[i] if mid >= b else min_eff[i]\n                else:\n                    unclamped = (mid - b) / (2 * c)\n                    p_i = max(min_eff[i], min(max_eff[i], unclamped))\n                total_gen += p_i\n            if total_gen < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        allocated = 0\n        for i in dispatch_set:\n            a, b, c, _ = cost_func_coeffs[i]\n            if c == 0:\n                p[i] = max_eff[i] if mid >= b else min_eff[i]\n            else:\n                p[i] = max(min_eff[i], min(max_eff[i], (mid - b) / (2 * c)))\n            allocated += p[i]\n            u[i] = 1\n        \n        residual = current_load - allocated\n        if residual > 0:\n            candidates = [(i, b_i + 2 * c_i * p[i]) for i in dispatch_set if p[i] < max_eff[i]]\n            candidates.sort(key=lambda x: x[1])\n            for i, mc in candidates:\n                if residual <= 0:\n                    break\n                add = min(residual, max_eff[i] - p[i])\n                p[i] += add\n                residual -= add\n        elif residual < 0:\n            candidates = [(i, b_i + 2 * c_i * p[i]) for i in dispatch_set if p[i] > min_eff[i]]\n            candidates.sort(key=lambda x: x[1], reverse=True)\n            for i, mc in candidates:\n                if residual >= 0:\n                    break\n                subtract = min(-residual, p[i] - min_eff[i])\n                p[i] -= subtract\n                residual += subtract\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0042374776,
          "gap_price_rate": 0.0095605135,
          "fitness": 0.0068989955
     },
     {
          "name": "hybrid_optimized_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), and free-off (offline and commitable).\n2. Initially commit must-on and free-on units.\n3. Precompute effective min/max outputs considering ramp constraints: for previously online units use [max(p_min_i, p_i_0 - ramp_down), min(p_max_i, p_i_0 + ramp_up)]; for new commitments use [p_min_i, min(p_max_i, startup_ramp)].\n4. Decommit free-on units by descending cost per MW at effective min output until total min \u2264 load.\n5. Commit free-off units by ascending startup-cost-adjusted cost per MW until total max \u2265 load.\n6. Decommit non-essential free-on units by descending cost per MW if removal maintains total max \u2265 load.\n7. Commit additional free-off units by ascending startup-cost-adjusted cost per MW until total max \u2265 load.\n8. Decommit non-essential free-off units by descending startup-cost-adjusted cost per MW if removal maintains total max \u2265 load.\n9. Dispatch committed units:\n   a) Set outputs to min if load \u2264 total min.\n   b) Set outputs to max if load \u2265 total max.\n   c) Else, perform economic dispatch via lambda iteration (100 steps) and adjust residual using marginal-cost-based unit adjustments.\n10. Return schedules with commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_optimized_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Precompute effective min and max possible outputs\n    min_eff_possible = []\n    max_eff_possible = []\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_eff = unit['p_min_i']\n            max_eff = min(unit['p_max_i'], unit['p_start_i'])\n        min_eff_possible.append(min_eff)\n        max_eff_possible.append(max_eff)\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    committed_set = set(must_on) | set(free_on)\n    \n    # Compute total min and max for the initial committed set\n    total_min = sum(min_eff_possible[i] for i in committed_set)\n    total_max = sum(max_eff_possible[i] for i in committed_set)\n    \n    # Step 4: Decommit free-on units\n    free_on_committed = [i for i in free_on if i in committed_set]\n    free_on_committed_sorted = sorted(free_on_committed, \n                                     key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff_possible[i] + \n                                                    units_info[i]['c_i'] * min_eff_possible[i]**2) / min_eff_possible[i], \n                                     reverse=True)\n    for i in free_on_committed_sorted:\n        if total_min - min_eff_possible[i] <= current_load:\n            committed_set.remove(i)\n            total_min -= min_eff_possible[i]\n            total_max -= max_eff_possible[i]\n    \n    # Step 5: Commit free-off units\n    free_off_not_committed = [i for i in free_off if i not in committed_set]\n    free_off_not_committed_sorted = sorted(free_off_not_committed, \n                                          key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                                                         units_info[i]['b_i'] * min_eff_possible[i] + \n                                                         units_info[i]['c_i'] * min_eff_possible[i]**2) / min_eff_possible[i])\n    for i in free_off_not_committed_sorted:\n        if total_max < current_load:\n            committed_set.add(i)\n            total_min += min_eff_possible[i]\n            total_max += max_eff_possible[i]\n        else:\n            break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_committed_remaining = [i for i in free_on if i in committed_set]\n    free_on_committed_remaining_sorted = sorted(free_on_committed_remaining, \n                                               key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff_possible[i] + \n                                                              units_info[i]['c_i'] * min_eff_possible[i]**2) / min_eff_possible[i], \n                                               reverse=True)\n    for i in free_on_committed_remaining_sorted:\n        if total_max - max_eff_possible[i] >= current_load:\n            committed_set.remove(i)\n            total_min -= min_eff_possible[i]\n            total_max -= max_eff_possible[i]\n    \n    # Step 7: Secondary commitment of free-off units\n    free_off_not_committed = [i for i in free_off if i not in committed_set]\n    free_off_not_committed_sorted = sorted(free_off_not_committed, \n                                          key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                                                         units_info[i]['b_i'] * min_eff_possible[i] + \n                                                         units_info[i]['c_i'] * min_eff_possible[i]**2) / min_eff_possible[i])\n    for i in free_off_not_committed_sorted:\n        if total_max < current_load:\n            committed_set.add(i)\n            total_min += min_eff_possible[i]\n            total_max += max_eff_possible[i]\n        else:\n            break\n    \n    # Step 8: Decommit non-essential free-off units\n    free_off_committed = [i for i in free_off if i in committed_set]\n    free_off_committed_sorted = sorted(free_off_committed, \n                                      key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                                                     units_info[i]['b_i'] * min_eff_possible[i] + \n                                                     units_info[i]['c_i'] * min_eff_possible[i]**2) / min_eff_possible[i], \n                                      reverse=True)\n    for i in free_off_committed_sorted:\n        if total_max - max_eff_possible[i] >= current_load:\n            committed_set.remove(i)\n            total_min -= min_eff_possible[i]\n            total_max -= max_eff_possible[i]\n    \n    # Dispatch\n    p_outputs = {}\n    if current_load <= total_min:\n        for i in committed_set:\n            p_outputs[i] = min_eff_possible[i]\n    elif current_load >= total_max:\n        for i in committed_set:\n            p_outputs[i] = max_eff_possible[i]\n    else:\n        # Lambda iteration for economic dispatch\n        low = min(2 * units_info[i]['c_i'] * min_eff_possible[i] + units_info[i]['b_i'] for i in committed_set)\n        high = max(2 * units_info[i]['c_i'] * max_eff_possible[i] + units_info[i]['b_i'] for i in committed_set)\n        \n        for _ in range(100):\n            lam = (low + high) / 2\n            total_p = 0.0\n            for i in committed_set:\n                if units_info[i]['c_i'] == 0:\n                    p_val = max_eff_possible[i] if lam >= units_info[i]['b_i'] else min_eff_possible[i]\n                else:\n                    p_unclamped = (lam - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                    p_val = max(min_eff_possible[i], min(max_eff_possible[i], p_unclamped))\n                total_p += p_val\n                p_outputs[i] = p_val\n            \n            if total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if residual > 0:\n            # Under generation: increase the cheapest available units\n            adjustable = []\n            for i in committed_set:\n                if p_outputs[i] < max_eff_possible[i]:\n                    headroom = max_eff_possible[i] - p_outputs[i]\n                    mc = 2 * units_info[i]['c_i'] * p_outputs[i] + units_info[i]['b_i']\n                    adjustable.append((mc, headroom, i))\n            adjustable.sort(key=lambda x: x[0])\n            \n            for mc, headroom, i in adjustable:\n                if residual <= 0:\n                    break\n                add = min(residual, headroom)\n                p_outputs[i] += add\n                residual -= add\n        elif residual < 0:\n            # Over generation: decrease the most expensive units\n            residual_abs = -residual\n            adjustable = []\n            for i in committed_set:\n                if p_outputs[i] > min_eff_possible[i]:\n                    room = p_outputs[i] - min_eff_possible[i]\n                    mc = 2 * units_info[i]['c_i'] * p_outputs[i] + units_info[i]['b_i']\n                    adjustable.append((mc, room, i))\n            adjustable.sort(key=lambda x: x[0], reverse=True)\n            \n            for mc, room, i in adjustable:\n                if residual_abs <= 0:\n                    break\n                deduct = min(residual_abs, room)\n                p_outputs[i] -= deduct\n                residual_abs -= deduct\n    \n    # Prepare output\n    u_list = np.zeros(n_units, dtype=int)\n    p_list = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if i in committed_set:\n            u_list[i] = 1\n            p_list[i] = p_outputs[i] if i in p_outputs else min_eff_possible[i]\n        else:\n            u_list[i] = 0\n            p_list[i] = 0.0\n    \n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0056257334,
          "gap_price_rate": 0.0082426236,
          "fitness": 0.0069341785
     },
     {
          "name": "optimized_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable). \n2. Commit must-on and free-on units as initial set. \n3. Compute effective min/max outputs considering ramp constraints: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments. \n4. Decommit free-on units by highest cost/MW (a_i + b_i * eff_min_i + c_i * eff_min_i^2)/eff_min_i until total min output \u2264 current load. \n5. Commit free-off units by lowest (s_i + a_i + b_i * p_min_i + c_i * p_min_i^2)/p_min_i until total max output \u2265 current load. \n6. Decommit remaining free-on units in descending order of cost/MW at effective min if removal maintains total max \u2265 load. \n7. Dispatch: \n   a) If load \u2264 total min: set outputs to effective min \n   b) If load \u2265 total max: set outputs to effective max \n   c) Else: perform economic dispatch via lambda iteration with bisection (100 iterations) followed by residual adjustment based on marginal cost merit order. \n8. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize units arrays\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    is_must_on = np.zeros(n_units, dtype=bool)\n    is_must_off = np.zeros(n_units, dtype=bool)\n    is_free_on = np.zeros(n_units, dtype=bool)\n    is_free_off = np.zeros(n_units, dtype=bool)\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    headroom = np.zeros(n_units)\n    min_costs = np.zeros(n_units)\n    startup_metrics = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    \n    # Step 1: Classify units\n    is_must_on = (u0 == 1) & ((t0 < min_up) | (p0 > p_shut))\n    is_must_off = (u0 == 0) & (t0 > -min_down)\n    is_free_on = (u0 == 1) & (~is_must_on)\n    is_free_off = (u0 == 0) & (~is_must_off)\n    \n    # Step 2: Initial commit (must-on + free-on)\n    u[is_must_on | is_free_on] = 1\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in range(n_units):\n        if u[i]:\n            if u0[i]:  # Previously online\n                effective_min[i] = max(p_min[i], p0[i] - p_down[i])\n                effective_max[i] = min(p_max[i], p0[i] + p_up[i])\n            else:  # New start\n                effective_min[i] = p_min[i]\n                effective_max[i] = min(p_max[i], p_start[i])\n        else:\n            effective_min[i] = effective_max[i] = 0.0\n    \n    total_min = np.sum(effective_min[u == 1])\n    total_max = np.sum(effective_max[u == 1])\n    \n    # Step 4: Decommit expensive free-on units\n    if total_min > current_load:\n        # Calculate min cost per MW\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            if total_min <= current_load:\n                break\n            unit_idx = free_on_indices[idx]\n            if u[unit_idx]:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 5: Commit cheap free-off units\n    if total_max < current_load:\n        # Calculate startup metric\n        startup_metrics = (startup_cost[is_free_off] + a[is_free_off] +\n                           b[is_free_off] * p_min[is_free_off] + \n                           c[is_free_off] * p_min[is_free_off]**2) / p_min[is_free_off]\n        free_off_indices = np.where(is_free_off)[0]\n        sort_indices = np.argsort(startup_metrics)\n        \n        for idx in sort_indices:\n            unit_idx = free_off_indices[idx]\n            new_min = p_min[unit_idx]\n            new_max = min(p_max[unit_idx], p_start[unit_idx])\n            if total_max + new_max >= current_load:\n                break\n            u[unit_idx] = 1\n            effective_min[unit_idx] = new_min\n            effective_max[unit_idx] = new_max\n            total_min += new_min\n            total_max += new_max\n    \n    # Step 6: Decommit non-essential free-on units\n    if any(is_free_on & u.astype(bool)):\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on & u)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            unit_idx = free_on_indices[idx]\n            if total_max - effective_max[unit_idx] >= current_load:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 7: Dispatch power to committed units\n    if current_load <= total_min:\n        p = np.where(u, effective_min, 0.0)\n    elif current_load >= total_max:\n        p = np.where(u, effective_max, 0.0)\n    else:\n        # Get indices of committed units\n        committed_idx = np.where(u)[0]\n        comm_min = effective_min[committed_idx]\n        comm_max = effective_max[committed_idx]\n        comm_a = a[committed_idx]\n        comm_b = b[committed_idx]\n        comm_c = c[committed_idx]\n        \n        # Bisection method setup\n        lambda_low = np.min(comm_b + 2 * comm_c * comm_min)\n        lambda_high = np.max(comm_b + 2 * comm_c * comm_max)\n        tolerance = 1e-5\n        \n        # Run bisection\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_set = np.clip((lambda_mid - comm_b) / (2 * comm_c + 1e-10), comm_min, comm_max)\n            total_power = np.sum(p_set)\n            \n            if abs(total_power - current_load) < tolerance:\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Residual adjustment\n        deficit = current_load - total_power\n        if abs(deficit) > tolerance:\n            # Compute marginal cost at current setpoints\n            marginal_costs = comm_b + 2 * comm_c * p_set\n            headroom = comm_max - p_set\n            \n            # Merit order for deficit adjustment\n            if deficit > 0:\n                priority_order = np.argsort(marginal_costs)\n                for idx in priority_order:\n                    if deficit <= 0:\n                        break\n                    if headroom[idx] > 0:\n                        adjust = min(headroom[idx], deficit)\n                        p_set[idx] += adjust\n                        deficit -= adjust\n            else:  # surplus (negative deficit)\n                surplus = -deficit\n                priority_order = np.argsort(marginal_costs)[::-1]\n                for idx in priority_order:\n                    if surplus <= 0:\n                        break\n                    avail = p_set[idx] - comm_min[idx]\n                    if avail > 0:\n                        adjust = min(avail, surplus)\n                        p_set[idx] -= adjust\n                        surplus -= adjust\n        \n        # Assign dispatch values\n        p[committed_idx] = p_set\n    \n    # Step 8: Set non-committed units\n    p[u == 0] = 0.0\n    \n    # Prepare output array\n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0061078301,
          "gap_price_rate": 0.0078211476,
          "fitness": 0.0069644889
     },
     {
          "name": "refined_optimized_rolling_commitment",
          "algorithm": "1. Classify units into must_on (previous online and (min up-time unfulfilled or previous output > shutdown capacity), must_off (previous offline and min down-time unfulfilled), free_on (previously online and decommitable), free_off (previously offline and commitable). 2. Initially commit must_on and free_on units. 3. Compute effective min/max: for previously online units use ramp constraints [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]; for free_off units [p_min, min(p_max, startup_ramp)]. 4. Decommit free_on units by highest cost/MW at min_eff until total_min_eff \u2264 load. 5. Commit free_off units by lowest (startup_cost + cost at min_output)/min_output until total_max_eff \u2265 load. 6. Decommit non-essential free_on units by highest cost/MW at min_eff if removal maintains total_max_eff \u2265 load. 7. Decommit committed free_off units by highest cost/MW at min_output if removal maintains total_max_eff \u2265 load. 8. Dispatch: if load \u2264 total_min use min outputs; if load \u2265 total_max use max outputs; else perform lambda iteration (100 bisection steps) with clamping and residual adjustment.\n",
          "code": "import numpy as np\n\ndef refined_optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min) or (p_i0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            u_current[i] = 1\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if t_i0 > -t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            u_current[i] = 0\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commitment\n    u_current[[must_on + free_on]] = 1\n    total_min = sum(min_eff[must_on + free_on])\n    total_max = sum(max_eff[must_on + free_on])\n    \n    # Decommit free_on units if min capacity exceeds load\n    free_on_committed = [i for i in free_on if u_current[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_on_committed[idx]\n            if total_min > current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Commit free_off units if max capacity below load\n    free_off_available = [i for i in free_off if u_current[i] == 0]\n    if free_off_available:\n        cost_per_mw = []\n        eff_mins = []\n        eff_maxs = []\n        for i in free_off_available:\n            cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            eff_mins.append(min_eff[i])\n            eff_maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)\n        for idx in order:\n            i = free_off_available[idx]\n            if total_max < current_load:\n                u_current[i] = 1\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n    \n    # Decommit non-essential free_on units\n    free_on_committed = [i for i in free_on if u_current[i] == 1]\n    if free_on_committed:\n        cost_per_mw = []\n        maxs = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_on_committed[idx]\n            if (total_max - max_eff[i]) >= current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Decommit non-essential free_off units\n    free_off_committed = [i for i in free_off if u_current[i] == 1]\n    if free_off_committed:\n        cost_per_mw = []\n        maxs = []\n        for i in free_off_committed:\n            cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * (min_eff[i] ** 2)\n            cost_per_mw.append(cost / min_eff[i])\n            maxs.append(max_eff[i])\n        order = np.argsort(cost_per_mw)[::-1]\n        for idx in order:\n            i = free_off_committed[idx]\n            if (total_max - max_eff[i]) >= current_load:\n                u_current[i] = 0\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n    \n    # Dispatch\n    committed = np.where(u_current == 1)[0]\n    if not committed.size:\n        return np.array([u_current, p_current])\n    \n    total_committed_min = min_eff[committed].sum()\n    total_committed_max = max_eff[committed].sum()\n    \n    if current_load <= total_committed_min:\n        for i in committed:\n            p_current[i] = min_eff[i]\n    elif current_load >= total_committed_max:\n        for i in committed:\n            p_current[i] = max_eff[i]\n    else:\n        a = np.array([units_info[i]['a_i'] for i in committed])\n        b = np.array([units_info[i]['b_i'] for i in committed])\n        c = np.array([units_info[i]['c_i'] for i in committed])\n        p_min = min_eff[committed]\n        p_max = max_eff[committed]\n        \n        lam_low = np.min(b + 2*c*p_min)\n        lam_high = np.max(b + 2*c*p_max)\n        p = np.zeros(len(committed))\n        iter_count = 100\n        \n        for _ in range(iter_count):\n            lam = (lam_low + lam_high) / 2\n            for j in range(len(committed)):\n                if c[j] == 0:\n                    if lam > b[j]:\n                        p[j] = p_max[j]\n                    else:\n                        p[j] = p_min[j]\n                else:\n                    p_unclamped = (lam - b[j]) / (2*c[j])\n                    p[j] = np.clip(p_unclamped, p_min[j], p_max[j])\n            total_p = np.sum(p)\n            if abs(total_p - current_load) < 1e-6:\n                break\n            if total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > 1e-6:\n            if residual > 0:\n                candidates = [j for j in range(len(committed)) if p[j] < p_max[j]]\n                marginal_costs = b + 2*c*p\n                candidates.sort(key=lambda j: marginal_costs[j])\n                for j in candidates:\n                    if residual <= 0:\n                        break\n                    available = p_max[j] - p[j]\n                    add = min(available, residual)\n                    p[j] += add\n                    residual -= add\n            else:\n                residual = abs(residual)\n                candidates = [j for j in range(len(committed)) if p[j] > p_min[j]]\n                marginal_costs = b + 2*c*p\n                candidates.sort(key=lambda j: marginal_costs[j], reverse=True)\n                for j in candidates:\n                    if residual <= 0:\n                        break\n                    available = p[j] - p_min[j]\n                    reduce_by = min(available, residual)\n                    p[j] -= reduce_by\n                    residual -= reduce_by\n        \n        p_current[committed] = p\n    \n    return np.array([u_current, p_current])",
          "from": "mutation",
          "gap_power_rate": 0.0050015901,
          "gap_price_rate": 0.0092352064,
          "fitness": 0.0071183982
     },
     {
          "name": "hybrid_advanced_rolling_commitment_v1",
          "algorithm": "1. Classify units into:  \n   - must_on: Previously online with unfulfilled min up-time (t_i_0 < t_on_min_i) or output exceeding shutdown capacity (p_i_0 > p_shut_i)  \n   - must_off: Previously offline with unfulfilled min down-time (abs(t_i_0) < t_off_min_i)  \n   - free_on: Online and decommitable (not must_on)  \n   - free_off: Offline and commitable (not must_off)  \n2. Initially commit must_on and free_on units  \n3. Compute effective min/max outputs:  \n   - Previously online units: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i)  \n   - New commitments: p_min_i to min(p_max_i, p_start_i)  \n4. Decommit free_on units by descending generation cost per MW until total effective min \u2264 current load  \n5. Commit free_off units by ascending (startup cost + generation cost at min) per MW until total effective max \u2265 load  \n6. Decommit non-essential free_on units by descending generation cost per MW if removal maintains total max \u2265 load  \n7. Decommit non-essential free_off units by descending (startup cost + generation cost at min) per MW if removal maintains total max \u2265 load  \n8. Dispatch:  \n   a) Use min outputs if load \u2264 total effective min  \n   b) Use max outputs if load \u2265 total effective max  \n   c) Else: Perform economic dispatch via lambda iteration (100 bisections)  \n   d) Adjust residual by increasing cheapest marginal cost units for shortages, decreasing most expensive for surpluses  \n9. Set non-committed units to off (0 output)  \n\n",
          "code": "import numpy as np\n\ndef hybrid_advanced_rolling_commitment_v1(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    # Initialize output arrays\n    u_vector = np.zeros(num_units)\n    p_vector = np.zeros(num_units)\n    is_committed = np.zeros(num_units, dtype=bool)\n    min_eff = np.zeros(num_units)\n    max_eff = np.zeros(num_units)\n    \n    # Classify units and compute effective limits\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_eff[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(idx)\n                is_committed[idx] = True\n            else:\n                free_on.append(idx)\n        else:\n            min_eff[idx] = unit['p_min_i']\n            max_eff[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    committed_indices = list(must_on)[:]\n    for idx in free_on:\n        committed_indices.append(idx)\n        is_committed[idx] = True\n    \n    # Decommit free_on until total min_eff <= current_load\n    free_on_committed = [idx for idx in free_on if is_committed[idx]]\n    if free_on_committed:\n        total_min = sum(min_eff[committed_indices])\n        while total_min > current_load:\n            # Find most expensive free_on unit (generation cost per MW at min_eff)\n            costs = []\n            for idx in free_on_committed:\n                a = units_info[idx]['a_i']\n                b = units_info[idx]['b_i']\n                c = units_info[idx]['c_i']\n                cost_min = a + b * min_eff[idx] + c * (min_eff[idx] ** 2)\n                cost_per_mw = cost_min / min_eff[idx]\n                costs.append((idx, cost_per_mw))\n            \n            if not costs:\n                break\n                \n            # Remove unit with highest cost per MW\n            idx_to_remove = max(costs, key=lambda x: x[1])[0]\n            free_on_committed.remove(idx_to_remove)\n            committed_indices.remove(idx_to_remove)\n            is_committed[idx_to_remove] = False\n            total_min -= min_eff[idx_to_remove]\n            \n            if not free_on_committed:\n                break\n    \n    # Commit free_off until total max_eff >= current_load\n    free_off_not_committed = free_off[:]\n    free_off_committed = []\n    total_max = sum(max_eff[committed_indices])\n    \n    while total_max < current_load and free_off_not_committed:\n        # Find cheapest free_off unit (startup cost + cost at min per MW)\n        costs = []\n        for idx in free_off_not_committed:\n            a = units_info[idx]['a_i']\n            b = units_info[idx]['b_i']\n            c = units_info[idx]['c_i']\n            s = units_info[idx]['s_i']\n            cost_min = s + a + b * min_eff[idx] + c * (min_eff[idx] ** 2)\n            cost_per_mw = cost_min / min_eff[idx]\n            costs.append((idx, cost_per_mw))\n        \n        if not costs:\n            break\n            \n        # Add unit with lowest cost per MW\n        idx_to_add = min(costs, key=lambda x: x[1])[0]\n        free_off_not_committed.remove(idx_to_add)\n        free_off_committed.append(idx_to_add)\n        committed_indices.append(idx_to_add)\n        is_committed[idx_to_add] = True\n        total_max += max_eff[idx_to_add]\n    \n    # Decommit non-essential free_on\n    free_on_committed = [idx for idx in committed_indices if idx in free_on]\n    if free_on_committed:\n        costs = []\n        for idx in free_on_committed:\n            a = units_info[idx]['a_i']\n            b = units_info[idx]['b_i']\n            c = units_info[idx]['c_i']\n            cost_min = a + b * min_eff[idx] + c * (min_eff[idx] ** 2)\n            cost_per_mw = cost_min / min_eff[idx]\n            costs.append((idx, cost_per_mw))\n        \n        # Sort by descending cost/MW\n        costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for unit_cost in costs:\n            idx = unit_cost[0]\n            if total_max - max_eff[idx] >= current_load:\n                committed_indices.remove(idx)\n                is_committed[idx] = False\n                total_max -= max_eff[idx]\n    \n    # Decommit non-essential free_off\n    free_off_committed = [idx for idx in committed_indices if idx in free_off_committed]\n    if free_off_committed:\n        costs = []\n        for idx in free_off_committed:\n            a = units_info[idx]['a_i']\n            b = units_info[idx]['b_i']\n            c = units_info[idx]['c_i']\n            s = units_info[idx]['s_i']\n            cost_min = s + a + b * min_eff[idx] + c * (min_eff[idx] ** 2)\n            cost_per_mw = cost_min / min_eff[idx]\n            costs.append((idx, cost_per_mw))\n        \n        # Sort by descending cost/MW\n        costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for unit_cost in costs:\n            idx = unit_cost[0]\n            if total_max - max_eff[idx] >= current_load:\n                committed_indices.remove(idx)\n                is_committed[idx] = False\n                total_max -= max_eff[idx]\n    \n    # Calculate total min/max after adjustments\n    total_min_eff = sum(min_eff[committed_indices])\n    total_max_eff = total_max  # Already updated during decommits\n    \n    # Dispatch power\n    p_committed = np.zeros(num_units)\n    if committed_indices:\n        if current_load <= total_min_eff:\n            for idx in committed_indices:\n                p_committed[idx] = min_eff[idx]\n        elif current_load >= total_max_eff:\n            for idx in committed_indices:\n                p_committed[idx] = max_eff[idx]\n        else:\n            # Lambda iteration for economic dispatch\n            low = min(units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * min_eff[idx] for idx in committed_indices) - 1e-6\n            high = max(units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * max_eff[idx] for idx in committed_indices) + 1e-6\n            \n            for _ in range(100):\n                lam = (low + high) / 2\n                total_power = 0.0\n                for idx in committed_indices:\n                    u = units_info[idx]\n                    p_i = min(max_eff[idx], max(min_eff[idx], (lam - u['b_i']) / (2 * u['c_i'])))\n                    total_power += p_i\n                \n                if abs(total_power - current_load) < 1e-3:\n                    break\n                elif total_power < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Set power based on final lambda\n            for idx in committed_indices:\n                u = units_info[idx]\n                p_committed[idx] = min(max_eff[idx], max(min_eff[idx], (lam - u['b_i']) / (2 * u['c_i'])))\n            \n            # Residual adjustment\n            total_power = sum(p_committed[committed_indices])\n            residual = current_load - total_power\n            if residual > 0:  # Shortage\n                # Sort by marginal cost (ascending)\n                marginal_costs = [\n                    (idx, 2 * units_info[idx]['c_i'] * p_committed[idx] + units_info[idx]['b_i']) \n                    for idx in committed_indices\n                ]\n                marginal_costs.sort(key=lambda x: x[1])\n                for mc in marginal_costs:\n                    idx = mc[0]\n                    if residual <= 0:\n                        break\n                    available = max_eff[idx] - p_committed[idx]\n                    adjust = min(available, residual)\n                    p_committed[idx] += adjust\n                    residual -= adjust\n            elif residual < 0:  # Surplus\n                residual = abs(residual)\n                # Sort by marginal cost (descending)\n                marginal_costs = [\n                    (idx, 2 * units_info[idx]['c_i'] * p_committed[idx] + units_info[idx]['b_i']) \n                    for idx in committed_indices\n                ]\n                marginal_costs.sort(key=lambda x: x[1], reverse=True)\n                for mc in marginal_costs:\n                    idx = mc[0]\n                    if residual <= 0:\n                        break\n                    available = p_committed[idx] - min_eff[idx]\n                    adjust = min(available, residual)\n                    p_committed[idx] -= adjust\n                    residual -= adjust\n    \n    # Set outputs for committed units\n    for idx in range(num_units):\n        if is_committed[idx]:\n            u_vector[idx] = 1\n            p_vector[idx] = p_committed[idx]\n    \n    return np.vstack([u_vector, p_vector])",
          "from": "crossover",
          "gap_power_rate": 0.0050015903,
          "gap_price_rate": 0.0092352068,
          "fitness": 0.0071183986
     },
     {
          "name": "optimized_rolling_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef optimized_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Precompute effective min and max for each unit\n    effective_min = [0.0] * n_units\n    effective_max = [0.0] * n_units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            effective_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            effective_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            effective_min[i] = unit['p_min_i']\n            effective_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    # Initialize commitment (u) and power output (p) arrays\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 2: Commit must_on and free_on initially\n    for i in range(n_units):\n        if must_on[i] or free_on[i]:\n            u[i] = 1\n            \n    # Step 4: Decommit expensive free_on units until total_min <= current_load\n    total_min = 0.0\n    for i in range(n_units):\n        if u[i] == 1:\n            total_min += effective_min[i]\n            \n    free_on_indices = [i for i in range(n_units) if free_on[i] and u[i]==1]\n    free_on_indices.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*effective_min[i] + units_info[i]['c_i']*effective_min[i]**2) / effective_min[i], reverse=True)\n    \n    while free_on_indices and total_min > current_load:\n        i = free_on_indices.pop(0)\n        total_min -= effective_min[i]\n        u[i] = 0\n        \n    # Step 5: Commit free_off in ascending order of cost per MW (including startup) until total_max >= load\n    total_max = 0.0\n    for i in range(n_units):\n        if u[i] == 1:\n            total_max += effective_max[i]\n            \n    free_off_indices = [i for i in range(n_units) if free_off[i] and u[i]==0]\n    metric_commit = lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*effective_min[i] + units_info[i]['c_i']*effective_min[i]**2) / effective_min[i]\n    free_off_indices.sort(key=metric_commit)\n    \n    committed_free_off = []\n    while free_off_indices and total_max < current_load:\n        i = free_off_indices.pop(0)\n        u[i] = 1\n        total_max += effective_max[i]\n        committed_free_off.append(i)\n        \n    # Step 5.5: Decommit expensive free_off units if removal still satisfies total_max >= load\n    committed_free_off.sort(key=metric_commit, reverse=True)\n    for i in committed_free_off:\n        if total_max - effective_max[i] >= current_load:\n            u[i] = 0\n            total_max -= effective_max[i]\n            \n    # Step 6: Decommit non-essential free_on in descending order of cost per MW at min\n    free_on_remaining = [i for i in range(n_units) if free_on[i] and u[i]==1]\n    metric_on = lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*effective_min[i] + units_info[i]['c_i']*effective_min[i]**2) / effective_min[i]\n    free_on_remaining.sort(key=metric_on, reverse=True)\n    \n    for i in free_on_remaining:\n        if total_max - effective_max[i] >= current_load:\n            u[i] = 0\n            total_max -= effective_max[i]\n            \n    # Step 7: Dispatch the load to committed units\n    committed_indices = [i for i in range(n_units) if u[i]==1]\n    \n    if not committed_indices:\n        # If no units are committed, set p to 0 and return\n        return np.array([u, p])\n    \n    total_min_dispatch = sum(effective_min[i] for i in committed_indices)\n    total_max_dispatch = sum(effective_max[i] for i in committed_indices)\n    \n    if current_load <= total_min_dispatch:\n        for i in committed_indices:\n            p[i] = effective_min[i]\n    elif current_load >= total_max_dispatch:\n        for i in committed_indices:\n            p[i] = effective_max[i]\n    else:\n        # Lambda iteration\n        low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_min[i] for i in committed_indices)\n        high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_max[i] for i in committed_indices)\n        n_iter = 100\n        tol = 1e-5\n        lam = (low + high) / 2\n        \n        for _ in range(n_iter):\n            total_power = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(effective_min[i], min(effective_max[i], p_i))\n                total_power += p_i\n                \n            diff = total_power - current_load\n            if abs(diff) < tol:\n                break\n                \n            if diff < 0:\n                low = lam\n            else:\n                high = lam\n                \n            lam = (low + high) / 2\n        else:\n            pass\n        \n        # Compute outputs with final lambda\n        outputs = []\n        total_power = 0.0\n        for i in committed_indices:\n            unit = units_info[i]\n            p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n            p_i = max(effective_min[i], min(effective_max[i], p_i))\n            outputs.append(p_i)\n            total_power += p_i\n            \n        # Residual adjustment\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            if residual > 0:\n                candidates = [i for i in committed_indices if outputs[committed_indices.index(i)] < effective_max[i]]\n                candidates.sort(key=lambda i: (units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[committed_indices.index(i)]))\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    idx = committed_indices.index(i)\n                    available = effective_max[i] - outputs[idx]\n                    if available > 0:\n                        add = min(available, residual)\n                        outputs[idx] += add\n                        residual -= add\n            else:\n                residual_abs = -residual\n                candidates = [i for i in committed_indices if outputs[committed_indices.index(i)] > effective_min[i]]\n                candidates.sort(key=lambda i: -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[committed_indices.index(i)]))\n                for i in candidates:\n                    if residual_abs <= 0:\n                        break\n                    idx = committed_indices.index(i)\n                    available = outputs[idx] - effective_min[i]\n                    if available > 0:\n                        deduct = min(available, residual_abs)\n                        outputs[idx] -= deduct\n                        residual_abs -= deduct\n                residual = -residual_abs\n                \n        for idx, i in enumerate(committed_indices):\n            p[i] = outputs[idx]\n            \n    # Ensure non-committed units have p_i=0\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0.0\n            \n    return np.array([u, p], dtype=float)",
          "from": "mutation",
          "gap_power_rate": 0.0050015912,
          "gap_price_rate": 0.0092352062,
          "fitness": 0.0071183987
     },
     {
          "name": "optimized_rolling_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef optimized_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract unit parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    u_i0 = [u['u_i_0'] for u in units_info]\n    p_i0 = [u['p_i_0'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    t_i0 = [u['t_i_0'] for u in units_info]\n    \n    # Classify units\n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_i0[i] == 1:\n            min_up_violated = t_i0[i] < t_on_min[i]\n            shutdown_constraint = p_i0[i] > p_shut[i]\n            must_on[i] = min_up_violated or shutdown_constraint\n            if not must_on[i]:\n                free_on[i] = True\n        else:\n            min_down_violated = -t_i0[i] < t_off_min[i]\n            must_off[i] = min_down_violated\n            if not must_off[i]:\n                free_off[i] = True\n    \n    # Initialize commitment and effective limits\n    committed = [must_on[i] or free_on[i] for i in range(n_units)]\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    for i in range(n_units):\n        if u_i0[i] == 1:\n            min_eff[i] = max(p_min[i], p_i0[i] - p_down[i])\n            max_eff[i] = min(p_max[i], p_i0[i] + p_up[i])\n        else:\n            min_eff[i] = 0\n            max_eff[i] = 0\n    \n    # Candidate limits for free-off units (if committed)\n    candidate_min = [p_min[i] for i in range(n_units)]\n    candidate_max = [min(p_max[i], p_start[i]) for i in range(n_units)]\n    \n    total_min = sum(min_eff)\n    total_max = sum(max_eff)\n    \n    # Step 4: Decommit free-on by highest cost per MW at min_eff\n    free_on_indices = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_indices:\n        cost_per_mw = []\n        for i in free_on_indices:\n            op_cost = a[i] + b[i] * min_eff[i] + c[i] * (min_eff[i] ** 2)\n            cost_per_mw.append(op_cost / min_eff[i] if min_eff[i] > 1e-6 else float('inf'))\n        sorted_indices = sorted(zip(free_on_indices, cost_per_mw), key=lambda x: x[1], reverse=True)\n        \n        for (i, _) in sorted_indices:\n            if total_min <= current_load:\n                break\n            if committed[i]:\n                committed[i] = False\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n                min_eff[i] = 0\n                max_eff[i] = 0\n    \n    # Step 5: Commit free-off by lowest cost per MW at min (including startup)\n    free_off_indices = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_indices:\n        cost_per_mw = []\n        for i in free_off_indices:\n            op_cost = a[i] + b[i] * candidate_min[i] + c[i] * (candidate_min[i] ** 2)\n            total_cost = s[i] + op_cost\n            cost_per_mw.append(total_cost / candidate_min[i] if candidate_min[i] > 1e-6 else float('inf'))\n        sorted_indices = sorted(zip(free_off_indices, cost_per_mw), key=lambda x: x[1])\n        \n        for (i, _) in sorted_indices:\n            if total_max >= current_load:\n                break\n            if not committed[i]:\n                committed[i] = True\n                min_eff[i] = candidate_min[i]\n                max_eff[i] = candidate_max[i]\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n    \n    # Step 6: Decommit non-essential units (free-on or free-off) by highest cost per MW\n    non_must_committed = [i for i in range(n_units) if committed[i] and not must_on[i]]\n    if non_must_committed:\n        cost_per_mw = []\n        for i in non_must_committed:\n            if free_on[i]:\n                op_cost = a[i] + b[i] * min_eff[i] + c[i] * (min_eff[i] ** 2)\n                cost = op_cost / min_eff[i] if min_eff[i] > 1e-6 else float('inf')\n            else:  # free-off\n                op_cost = a[i] + b[i] * min_eff[i] + c[i] * (min_eff[i] ** 2)\n                total_cost = s[i] + op_cost\n                cost = total_cost / min_eff[i] if min_eff[i] > 1e-6 else float('inf')\n            cost_per_mw.append(cost)\n        sorted_indices = sorted(zip(non_must_committed, cost_per_mw), key=lambda x: x[1], reverse=True)\n        \n        for (i, _) in sorted_indices:\n            if total_max - max_eff[i] >= current_load:\n                committed[i] = False\n                total_min -= min_eff[i]\n                total_max -= max_eff[i]\n                min_eff[i] = 0\n                max_eff[i] = 0\n    \n    # Dispatch\n    p_out = [0.0] * n_units\n    u_out = [0] * n_units\n    I = [i for i in range(n_units) if committed[i]]\n    \n    if I:\n        tot_min = sum(min_eff[i] for i in I)\n        tot_max = sum(max_eff[i] for i in I)\n        \n        if current_load <= tot_min + 1e-6:\n            for i in I:\n                p_out[i] = min_eff[i]\n                u_out[i] = 1\n        elif current_load >= tot_max - 1e-6:\n            for i in I:\n                p_out[i] = max_eff[i]\n                u_out[i] = 1\n        else:\n            # Lambda iteration with bisection\n            low = 0\n            high = max(b[i] + 2 * c[i] * p_max[i] for i in I) * 2\n            n_iter = 100\n            tol = 1e-5\n            p_trial = [0.0] * n_units\n            total_p = 0.0\n            \n            for _ in range(n_iter):\n                lam = (low + high) / 2\n                total_p = 0.0\n                for i in I:\n                    p = (lam - b[i]) / (2 * c[i]) if c[i] > 1e-6 else max_eff[i]\n                    p_clamped = min(max_eff[i], max(min_eff[i], p))\n                    p_trial[i] = p_clamped\n                    total_p += p_clamped\n                \n                if abs(total_p - current_load) < tol:\n                    break\n                if total_p < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Residual adjustment\n            residual = current_load - total_p\n            if abs(residual) > 1e-3:\n                if residual > 0:\n                    # Increase under-max units by MC merit\n                    under_max = [i for i in I if p_trial[i] < max_eff[i] - 1e-3]\n                    under_max.sort(key=lambda i: b[i] + 2 * c[i] * p_trial[i])\n                    for i in under_max:\n                        if residual <= 0:\n                            break\n                        max_add = min(max_eff[i] - p_trial[i], residual)\n                        p_trial[i] += max_add\n                        residual -= max_add\n                else:\n                    # Decrease above-min units by MC merit\n                    above_min = [i for i in I if p_trial[i] > min_eff[i] + 1e-3]\n                    above_min.sort(key=lambda i: b[i] + 2 * c[i] * p_trial[i], reverse=True)\n                    for i in above_min:\n                        if residual >= 0:\n                            break\n                        max_reduce = min(p_trial[i] - min_eff[i], -residual)\n                        p_trial[i] -= max_reduce\n                        residual += max_reduce\n            \n            for i in I:\n                p_out[i] = p_trial[i]\n                u_out[i] = 1\n    \n    schedules = np.array([u_out, p_out], dtype=np.float64)\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.005001591,
          "gap_price_rate": 0.0092352065,
          "fitness": 0.0071183988
     },
     {
          "name": "refined_evolved_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Preallocate arrays\n    u = np.zeros(n_units)  # Commitment status\n    p = np.zeros(n_units)  # Output power\n    cat = [''] * n_units   # Unit categories\n    eff_min = np.zeros(n_units)  # Effective min output\n    eff_max = np.zeros(n_units)  # Effective max output\n    \n    # Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                cat[i] = 'must_on'\n                u[i] = 1\n            else:\n                cat[i] = 'free_on'\n                u[i] = 1\n        else:  # Previously offline\n            if t0 < 0 and (-t0) < unit['t_off_min_i']:\n                cat[i] = 'must_off'\n                u[i] = 0\n            else:\n                cat[i] = 'free_off'\n                u[i] = 0\n                \n    # Step 4: Decommit high-cost free-on units\n    free_on_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    total_min = sum(eff_min[i] for i in range(n_units) if u[i]==1)\n    \n    # Define cost per MW metric\n    def cost_metric(i, include_startup=False):\n        base = units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \\\n               units_info[i]['c_i'] * eff_min[i]**2\n        if include_startup:\n            base += units_info[i]['s_i']\n        denom = eff_min[i] if eff_min[i] >= 1e-5 else 1.0\n        return base / denom\n    \n    # Decommit free-on units until total_min \u2264 current_load\n    if total_min > current_load:\n        sorted_free_on = sorted(free_on_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit low-cost free-off units\n    total_max = sum(eff_max[i] for i in range(n_units) if u[i]==1)\n    free_off_idx = [i for i in range(n_units) if cat[i]=='free_off' and u[i]==0]\n    \n    if total_max < current_load:\n        sorted_free_off = sorted(free_off_idx, key=lambda i: cost_metric(i, include_startup=True))\n        for i in sorted_free_off:\n            u[i] = 1\n            total_max += eff_max[i]\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_rem_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    curr_total_max = total_max\n    \n    if free_on_rem_idx:\n        sorted_free_on_rem = sorted(free_on_rem_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on_rem:\n            new_total_max = curr_total_max - eff_max[i]\n            if new_total_max >= current_load:\n                u[i] = 0\n                curr_total_max = new_total_max\n    \n    # Dispatch committed units\n    committed_idx = [i for i in range(n_units) if u[i]==1]\n    total_min_comm = sum(eff_min[i] for i in committed_idx)\n    total_max_comm = sum(eff_max[i] for i in committed_idx)\n    \n    if committed_idx:\n        if current_load <= total_min_comm:\n            for i in committed_idx:\n                p[i] = eff_min[i]\n        elif current_load >= total_max_comm:\n            for i in committed_idx:\n                p[i] = eff_max[i]\n        else:\n            # Bisection for lambda\n            low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_min[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_min[i] > 0)\n            high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_max[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_max[i] > 0)\n            \n            for _ in range(100):\n                lam = (low + high) / 2\n                total_p = 0.0\n                for i in committed_idx:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_unclamp = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_i = max(eff_min[i], min(eff_max[i], p_unclamp))\n                    else:\n                        p_i = eff_max[i] if lam > unit['b_i'] else eff_min[i]\n                    p[i] = p_i\n                    total_p += p_i\n                \n                if total_p < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Residual adjustment\n            residual = current_load - total_p\n            if residual > 0:\n                candidates = [i for i in committed_idx if p[i] < eff_max[i]]\n                candidates.sort(key=lambda i: unit['b_i'] + 2 * unit['c_i'] * p[i])\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    inc = min(residual, eff_max[i] - p[i])\n                    p[i] += inc\n                    residual -= inc\n            elif residual < 0:\n                residual = abs(residual)\n                candidates = [i for i in committed_idx if p[i] > eff_min[i]]\n                candidates.sort(key=lambda i: -(unit['b_i'] + 2 * unit['c_i'] * p[i]))\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    dec = min(residual, p[i] - eff_min[i])\n                    p[i] -= dec\n                    residual -= dec\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0046081286,
          "gap_price_rate": 0.0097404235,
          "fitness": 0.0071742761
     }
]