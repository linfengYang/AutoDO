[
     {
          "name": "refined_evolved_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on (prev online and (min up-time unfulfilled or prev output > shutdown capacity), must-off (prev offline and min down-time unfulfilled), free-on (prev online but decommittable), free-off (prev offline but committable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost/MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + cost at min)/min_output until total max \u2265 load\n6. While possible, decommit free-on units with highest cost/MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection (100 iters) then residual adjustment via merit order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters and initialize\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed = set()\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Was online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_on.append(i)\n                committed.add(i)\n            else:\n                free_on.append(i)\n                committed.add(i)\n        else:  # Was offline\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Prev online\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # New start (not possible here but safe)\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit free-on units if over-min\n    total_min = np.sum(eff_min[list(committed)])\n    free_on_in_committed = [i for i in free_on if i in committed]\n    \n    # Sort free-on by cost/MW at min desc\n    free_on_in_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        if i in committed:\n            committed.remove(i)\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit free-off units if under-max\n    total_max = np.sum(eff_max[list(committed)])\n    # Precompute new start effective max/min\n    for i in free_off:\n        unit = units_info[i]\n        eff_min[i] = unit['p_min_i']\n        eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Sort free-off by (startup cost + cost at min)/min\n    free_off_sorted = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        if i not in committed:\n            committed.add(i)\n            total_max += eff_max[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    removed = True\n    while removed:\n        removed = False\n        total_max = np.sum(eff_max[list(committed)])\n        free_on_committed = [i for i in free_on if i in committed]\n        free_on_committed.sort(key=lambda i: (\n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n        ) / units_info[i]['p_min_i'], reverse=True)\n        \n        for i in free_on_committed:\n            if total_max - eff_max[i] >= current_load:\n                committed.remove(i)\n                removed = True\n                break\n    \n    # Step 7: Dispatch\n    # Recompute effective min/max for final committed set\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[list(committed)])\n    total_max = np.sum(eff_max[list(committed)])\n    \n    comm_list = list(committed)\n    if current_load <= total_min:\n        for i in comm_list:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in comm_list:\n            p[i] = eff_max[i]\n    else:\n        # Lambda iteration\n        a = [units_info[i]['a_i'] for i in comm_list]\n        b = [units_info[i]['b_i'] for i in comm_list]\n        c = [units_info[i]['c_i'] for i in comm_list]\n        lows = [eff_min[i] for i in comm_list]\n        highs = [eff_max[i] for i in comm_list]\n        n_comm = len(comm_list)\n        \n        # Find lambda range\n        lo = min(b_i + 2*c_i*low_i for (b_i, c_i, low_i) in zip(b, c, lows))\n        hi = max(b_i + 2*c_i*high_i for (b_i, c_i, high_i) in zip(b, c, highs))\n        \n        # Bisection\n        for _ in range(100):\n            lam = (lo + hi) / 2\n            total_p = 0\n            for i in range(n_comm):\n                mc_low = b[i] + 2*c[i]*lows[i]\n                mc_high = b[i] + 2*c[i]*highs[i]\n                if lam < mc_low:\n                    p_i = lows[i]\n                elif lam > mc_high:\n                    p_i = highs[i]\n                else:\n                    p_i = (lam - b[i]) / (2*c[i])\n                total_p += p_i\n            \n            if total_p < current_load:\n                lo = lam\n            else:\n                hi = lam\n        \n        # Calculate p based on final lambda\n        total_p = 0\n        p_dispatch = [0] * n_comm\n        for i in range(n_comm):\n            mc_low = b[i] + 2*c[i]*lows[i]\n            mc_high = b[i] + 2*c[i]*highs[i]\n            if lam < mc_low:\n                p_i = lows[i]\n            elif lam > mc_high:\n                p_i = highs[i]\n            else:\n                p_i = (lam - b[i]) / (2*c[i])\n            p_dispatch[i] = p_i\n            total_p += p_i\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        tol = 1e-5\n        if residual > tol:\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] < highs[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx])\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = highs[idx] - p_dispatch[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] += adjust\n                residual -= adjust\n        elif residual < -tol:\n            residual = -residual\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] > lows[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx], reverse=True)\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = p_dispatch[idx] - lows[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] -= adjust\n                residual -= adjust\n        \n        # Assign dispatched values\n        for ii, i in enumerate(comm_list):\n            p[i] = p_dispatch[ii]\n    \n    # Set commitments and output for non-committed\n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0091401443,
          "fitness": 0.0072843404
     },
     {
          "name": "evolved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), and free-off (offline but commitable)\n2. Commit must-on + free-on units\n3. Compute effective min/max outputs considering:\n   - For prev online units: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - For new starts: [p_min, min(p_max, startup_ramp)]\n4. Decommittable free-on units by highest cost/MW at min output until total min \u2264 load\n5. Committable free-off units by lowest cost/MW including startup until total max \u2265 load\n6. Decommittable free-on units with highest cost/MW at min output if non-essential\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with gradient clipping and residual adjustment\n8. Return schedules (u_i, p_i) for all units\n\n",
          "code": "import numpy as np\n\ndef evolved_rolling_commitment(units_info, load):\n    load0 = load[0]\n    n_units = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_outputs = {}\n    max_outputs = {}\n    \n    # Classify units (Step 1)\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < t_on_min) or (p0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            min_o = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_o = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            min_outputs[i] = min_o\n            max_outputs[i] = max_o\n        else:  # Previously offline\n            if abs(t0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commit (Step 2)\n    committed = set(must_on) | set(free_on)\n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n    \n    # Decommit high-cost free-on if over-committed (Step 4)\n    high_cost_free_on = [i for i in free_on if i in committed]\n    high_cost_free_on.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in high_cost_free_on:\n        if total_min <= load0:\n            break\n        committed.remove(i)\n        total_min -= min_outputs[i]\n        total_max -= max_outputs[i]\n    \n    # Commit low-cost free-off if under-committed (Step 5)\n    low_cost_free_off = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in low_cost_free_off:\n        if total_max >= load0:\n            break\n        if i in committed:\n            continue\n        min_i = units_info[i]['p_min_i']\n        max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        min_outputs[i] = min_i\n        max_outputs[i] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Decommit non-essential high-cost free-on (Step 6)\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_committed:\n        new_min = total_min - min_outputs[i]\n        new_max = total_max - max_outputs[i]\n        if new_min <= load0 <= new_max:\n            committed.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch logic (Step 7)\n    p_alloc = [0] * n_units\n    u_alloc = [1 if i in committed else 0 for i in range(n_units)]\n    \n    if committed:\n        if load0 <= total_min:\n            for i in committed:\n                p_alloc[i] = min_outputs[i]\n        elif load0 >= total_max:\n            for i in committed:\n                p_alloc[i] = max_outputs[i]\n        else:\n            # Lambda iteration setup\n            low = 0\n            high = max(unit['b_i'] + 2 * unit['c_i'] * max_outputs[i] \n                      for i, unit in enumerate(units_info) if i in committed) * 2\n            tol = 0.01\n            iter_max = 100\n            iter_count = 0\n            \n            while iter_count < iter_max:\n                mid = (low + high) / 2.0\n                total_p = 0\n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        unconstrained = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                    else:\n                        unconstrained = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = np.clip(unconstrained, min_outputs[i], max_outputs[i])\n                    total_p += p_i\n                \n                if abs(total_p - load0) <= tol:\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] == 0:\n                            p_i = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                        else:\n                            p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                        p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n                    break\n                \n                if total_p < load0:\n                    low = mid\n                else:\n                    high = mid\n                iter_count += 1\n            \n            # Residual adjustment (if needed)\n            total_p = sum(p_alloc[i] for i in committed)\n            residual = load0 - total_p\n            if residual != 0:\n                candidates = []\n                for i in committed:\n                    if residual > 0 and p_alloc[i] < max_outputs[i]:\n                        margin = max_outputs[i] - p_alloc[i]\n                        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                        candidates.append((i, marginal_cost, margin))\n                    elif residual < 0 and p_alloc[i] > min_outputs[i]:\n                        margin = p_alloc[i] - min_outputs[i]\n                        marginal_cost = -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                        candidates.append((i, marginal_cost, margin))\n                \n                candidates.sort(key=lambda x: x[1])\n                for i, mc, margin in candidates:\n                    adjust = min(abs(residual), margin)\n                    if residual > 0:\n                        p_alloc[i] += adjust\n                        residual -= adjust\n                    else:\n                        p_alloc[i] -= adjust\n                        residual += adjust\n                    if abs(residual) < tol:\n                        break\n    \n    # Non-committed units\n    for i in range(n_units):\n        if not u_alloc[i]:\n            p_alloc[i] = 0\n    \n    return np.array([u_alloc, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0054285387,
          "gap_price_rate": 0.0091401447,
          "fitness": 0.0072843417
     },
     {
          "name": "refined_evolved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable).\n2. Commit must-on and free-on units as initial set.\n3. Compute effective min/max outputs considering ramp constraints: max ramp-down/min ramp-up for online units, startup ramp limits for new commitments.\n4. Decommit free-on units by highest cost/MW at effective min until total min output \u2264 current load.\n5. Commit free-off units by lowest cost/MW at min output (including startup costs) until total max output \u2265 current load.\n6. Decommit remaining free-on units if non-essential (removal maintains total max \u2265 load) using the same cost/MW metric.\n7. Dispatch committed units:\n   a) Set outputs to min if load \u2264 total min\n   b) Set outputs to max if load \u2265 total max\n   c) Use bisection to find optimal lambda for economic dispatch\n   d) Adjust residual with priority order if needed\n8. Set non-committed units to off state and zero output.\n\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    categories = []\n    current_load = load[0]\n    \n    # Step 1: Classify units and set initial commitment\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        \n        if u0 == 1:  # Previously online\n            if t0 < t_up_min or p0 > p_shut:\n                categories.append('must-on')\n                u[i] = 1\n            else:\n                categories.append('free-on')\n                u[i] = 1\n        else:  # Previously offline\n            if abs(t0) < t_down_min:\n                categories.append('must-off')\n                u[i] = 0\n            else:\n                categories.append('free-off')\n                u[i] = 0\n                \n    # Step 2 & 3: Compute effective min/max for committed units\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:  # Continuation online\n                eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                eff_min[i] = unit['p_min_i']\n                eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[u == 1])\n    total_max = np.sum(eff_max[u == 1])\n    \n    # Step 4: Decommit free-on units if over-committed\n    free_on_idx = [i for i, cat in enumerate(categories) if cat == 'free-on' and u[i] == 1]\n    cost_per_mw = []\n    for i in free_on_idx:\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        cost_per_mw.append((a + b * eff_min[i] + c * eff_min[i]**2) / eff_min[i])\n    sorted_free_on = [i for _, i in sorted(zip(cost_per_mw, free_on_idx), reverse=True)]\n    \n    for i in sorted_free_on:\n        if total_min <= current_load:\n            break\n        u[i] = 0\n        total_min -= eff_min[i]\n        total_max -= eff_max[i]\n        eff_min[i] = eff_max[i] = 0\n    \n    # Step 5: Commit free-off units if under-committed\n    if total_max < current_load:\n        free_off_idx = [i for i, cat in enumerate(categories) if cat == 'free-off' and u[i] == 0]\n        cost_per_mw = []\n        for i in free_off_idx:\n            a, b, c, s = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i']\n            min_cost = a + b * units_info[i]['p_min_i'] + c * units_info[i]['p_min_i']**2 + s\n            cost_per_mw.append(min_cost / units_info[i]['p_min_i'])\n        sorted_free_off = [i for _, i in sorted(zip(cost_per_mw, free_off_idx))]\n        \n        for i in sorted_free_off:\n            u[i] = 1\n            eff_min_i = units_info[i]['p_min_i']\n            eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            eff_min[i], eff_max[i] = eff_min_i, eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_idx = [i for i, cat in enumerate(categories) if cat == 'free-on' and u[i] == 1]\n    cost_per_mw = []\n    for i in free_on_idx:\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        cost_per_mw.append((a + b * eff_min[i] + c * eff_min[i]**2) / eff_min[i])\n    sorted_free_on = [i for _, i in sorted(zip(cost_per_mw, free_on_idx), reverse=True)]\n    \n    for i in sorted_free_on:\n        if total_max - eff_max[i] >= current_load:\n            u[i] = 0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            eff_min[i] = eff_max[i] = 0\n    \n    # Step 7: Dispatch committed units\n    committed_indices = np.where(u == 1)[0]\n    if len(committed_indices) > 0:\n        current_min = np.sum(eff_min[committed_indices])\n        current_max = np.sum(eff_max[committed_indices])\n        \n        if current_load <= current_min:\n            for i in committed_indices:\n                p[i] = eff_min[i]\n        elif current_load >= current_max:\n            for i in committed_indices:\n                p[i] = eff_max[i]\n        else:\n            # Bisection for lambda\n            low = 0\n            high = 0\n            for i in committed_indices:\n                unit = units_info[i]\n                marginal_low = 2 * unit['c_i'] * eff_min[i] + unit['b_i']\n                marginal_high = 2 * unit['c_i'] * eff_max[i] + unit['b_i']\n                low = min(low, marginal_low) if low != 0 else marginal_low\n                high = max(high, marginal_high) if high != 0 else marginal_high\n            \n            n_iter = 100\n            total_p = 0\n            temp_p = {}\n            for _ in range(n_iter):\n                lam = (low + high) / 2\n                total_p = 0\n                for i in committed_indices:\n                    unit = units_info[i]\n                    p_i = max(eff_min[i], min(eff_max[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n                    temp_p[i] = p_i\n                    total_p += p_i\n                if abs(total_p - current_load) < 1e-3:\n                    break\n                if total_p > current_load:\n                    high = lam\n                else:\n                    low = lam\n            # Set temp_p values to p\n            for i, val in temp_p.items():\n                p[i] = val\n            residual = current_load - total_p\n            if abs(residual) > 1e-2:\n                if residual > 0:\n                    candidates = []\n                    for i in committed_indices:\n                        if p[i] < eff_max[i]:\n                            marginal_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                            headroom = eff_max[i] - p[i]\n                            candidates.append((marginal_cost, headroom, i))\n                    candidates.sort(key=lambda x: x[0])\n                    for mc, hr, idx in candidates:\n                        if residual <= 0:\n                            break\n                        allocation = min(hr, residual)\n                        p[idx] += allocation\n                        residual -= allocation\n                else:\n                    candidates = []\n                    for i in committed_indices:\n                        if p[i] > eff_min[i]:\n                            marginal_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                            headroom = p[i] - eff_min[i]\n                            candidates.append((marginal_cost, headroom, i))\n                    candidates.sort(key=lambda x: x[0], reverse=True)\n                    for mc, hr, idx in candidates:\n                        if residual >= 0:\n                            break\n                        allocation = min(hr, -residual)\n                        p[idx] -= allocation\n                        residual += allocation\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.005428635,
          "gap_price_rate": 0.0091401619,
          "fitness": 0.0072843984
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run (min up-time/shotdown ramp constraints), must-off (min down-time), free-on (online freely decommitable), and free-off (offline freely commitable)\n2. Commit must-run and free-on units\n3. Compute effective min/max outputs considering ramp constraints (ramp limits, startup/shutdown ramp limits)\n4. If total min output exceeds load:\n   - Decommit free-on units with largest min outputs until feasibility is restored\n5. If total max output is below load:\n   - Commit free-off units with lowest cost per MW at min output until capacity suffices\n6. Decommit unnecessary free-on units with highest operating cost at min output if feasible\n7. Dispatch committed units:\n   - If load <= total min: set to min outputs\n   - If load >= total max: set to max outputs\n   - Else: perform lambda iteration economic dispatch with clamped gradients\n   - Apply final adjustments to balance residual load\n8. Return schedules (u_i, p_i) for all units\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Initialize classification lists\n    must_on = []\n    free_on = []\n    free_off = []\n    min_eff = [0.0] * n_units\n    max_eff = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                continue  # must_off handled by omission\n            else:\n                free_off.append(i)\n    \n    # Initialize committed set\n    committed = set(must_on)\n    committed.update(free_on)\n    \n    # Step 2 & 3: Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if i in committed and unit['u_i_0'] == 1:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff[i] = 0.0\n            max_eff[i] = 0.0\n    \n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Step 4: Decommit free-on units if overcommitted\n    if total_min > current_load:\n        sorted_free_on = sorted(\n            [i for i in free_on if i in committed],\n            key=lambda i: min_eff[i],\n            reverse=True\n        )\n        for i in sorted_free_on:\n            cand_min = total_min - min_eff[i]\n            cand_max = total_max - max_eff[i]\n            if cand_min <= current_load <= cand_max:\n                committed.remove(i)\n                total_min = cand_min\n                total_max = cand_max\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Commit free-off units if undercommitted\n    if total_max < current_load:\n        def cost_priority(i):\n            unit = units_info[i]\n            startup = unit['s_i']\n            prod_cost = unit['a_i'] + unit['b_i']*min_eff[i] + unit['c_i']*min_eff[i]**2\n            return (startup + prod_cost) / (min_eff[i] + 1e-9)\n        \n        sorted_free_off = sorted(\n            [i for i in free_off if i not in committed],\n            key=cost_priority\n        )\n        for i in sorted_free_off:\n            cand_min = total_min + min_eff[i]\n            cand_max = total_max + max_eff[i]\n            committed.add(i)\n            total_min = cand_min\n            total_max = cand_max\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit unnecessary free-on units by cost\n    def operating_cost(i):\n        unit = units_info[i]\n        return unit['a_i'] + unit['b_i']*min_eff[i] + unit['c_i']*min_eff[i]**2\n    \n    expensive_free_on = sorted(\n        [i for i in free_on if i in committed],\n        key=operating_cost,\n        reverse=True\n    )\n    for i in expensive_free_on:\n        cand_min = total_min - min_eff[i]\n        cand_max = total_max - max_eff[i]\n        if cand_min <= current_load <= cand_max:\n            committed.remove(i)\n            total_min = cand_min\n            total_max = cand_max\n    \n    # Recompute final constraints\n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            min_eff[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:  # Started this period\n            min_eff[i] = units_info[i]['p_min_i']\n            max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Step 7: Dispatch\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = min_eff[i]\n            u[i] = 1\n    elif current_load >= total_max:\n        for i in committed:\n            p[i] = max_eff[i]\n            u[i] = 1\n    else:  # Lambda iteration with clamping\n        # Initialize lambda bounds\n        low = float('inf')\n        high = -float('inf')\n        for i in committed:\n            unit = units_info[i]\n            low = min(low, unit['b_i'] + 2*unit['c_i']*min_eff[i])\n            high = max(high, unit['b_i'] + 2*unit['c_i']*max_eff[i])\n        \n        tol = 1e-3\n        max_iter = 1000\n        for _ in range(max_iter):\n            lambda_mid = (low + high) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                c_val = unit['c_i']\n                b_val = unit['b_i']\n                if c_val == 0:\n                    p_i = max_eff[i] if lambda_mid > b_val else min_eff[i]\n                else:\n                    p_i = (lambda_mid - b_val) / (2 * c_val)\n                    p_i = max(min_eff[i], min(max_eff[i], p_i))\n                p[i] = p_i\n                total_power += p_i\n            \n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                low = lambda_mid\n            else:\n                high = lambda_mid\n        \n        # Residual adjustment\n        total_power = sum(p[i] for i in committed)\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            adjustments = []\n            for i in committed:\n                if residual > 0 and p[i] < max_eff[i]:\n                    headroom = max_eff[i] - p[i]\n                    marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    adjustments.append((marginal, i, headroom))\n                elif residual < 0 and p[i] > min_eff[i]:\n                    headroom = p[i] - min_eff[i]\n                    marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    adjustments.append((marginal, i, headroom))\n            \n            if residual > 0:\n                adjustments.sort(key=lambda x: x[0])\n            else:\n                adjustments.sort(key=lambda x: x[0], reverse=True)\n            \n            for _, i, headroom in adjustments:\n                delta = min(headroom, abs(residual)) * np.sign(residual)\n                p[i] += delta\n                residual -= delta\n                if abs(residual) < tol:\n                    break\n        for i in committed:\n            u[i] = 1\n    \n    # Set non-committed units\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u\n    schedules[1, :] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054286362,
          "gap_price_rate": 0.0091472287,
          "fitness": 0.0072879324
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "refined_commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize schedules\n    u_vector = [0] * n_units\n    p_vector = [0] * n_units\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        # Must-on conditions\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        # Must-off conditions\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Calculate effective bounds for must-on units\n    must_on_effective_min = {}\n    must_on_effective_max = {}\n    total_min_must = 0\n    total_max_must = 0\n    \n    for idx in must_on:\n        unit = units_info[idx]\n        min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        must_on_effective_min[idx] = min_eff\n        must_on_effective_max[idx] = max_eff\n        total_min_must += min_eff\n        total_max_must += max_eff\n    \n    # Handle must-on over-generation\n    if total_min_must > current_load:\n        # Commit must-on units\n        for idx in must_on:\n            u_vector[idx] = 1\n            p_vector[idx] = must_on_effective_min[idx]  # Over-generation\n        # Free units remain off\n        return np.array([u_vector, p_vector])\n    \n    # Only must-on needed\n    if total_max_must >= current_load:\n        # Commit must-on units\n        committed = set(must_on)\n        # Free units turned off\n        # Dispatch must-on units to meet load\n        target = current_load\n        outputs = {}\n        remaining = target\n        # Initialize to min output\n        for idx in must_on:\n            outputs[idx] = must_on_effective_min[idx]\n            remaining -= outputs[idx]\n        \n        # Distribute remaining load by merit order\n        marginal_costs = []\n        for idx in must_on:\n            unit = units_info[idx]\n            mc = unit['b_i'] + 2 * unit['c_i'] * outputs[idx]\n            marginal_costs.append((mc, idx, must_on_effective_min[idx], must_on_effective_max[idx]))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for mc, idx, min_eff, max_eff in marginal_costs:\n            if remaining <= 0:\n                break\n            allocatable = min(remaining, max_eff - outputs[idx])\n            outputs[idx] += allocatable\n            remaining -= allocatable\n        \n        # Set outputs\n        for idx in must_on:\n            p_vector[idx] = outputs[idx]\n            u_vector[idx] = 1\n        \n        return np.array([u_vector, p_vector])\n    \n    # Case 3: Load exceeds must-on capacity\n    candidates = []  # (cost_at_min, idx, min_eff, max_eff, is_free_off)\n    candidate_eff_min = {}\n    candidate_eff_max = {}\n    \n    # Add free-on units (already online)\n    for idx in free_on:\n        unit = units_info[idx]\n        min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        cost_min = unit['a_i'] + unit['b_i'] * min_eff + unit['c_i'] * (min_eff ** 2)\n        candidates.append((cost_min, idx, min_eff, max_eff, False))\n        candidate_eff_min[idx] = min_eff\n        candidate_eff_max[idx] = max_eff\n    \n    # Add free-off units (startup cost)\n    for idx in free_off:\n        unit = units_info[idx]\n        min_eff = unit['p_min_i']\n        max_eff = min(unit['p_max_i'], unit['p_start_i'])\n        cost_min = (unit['a_i'] + unit['b_i'] * min_eff + \n                    unit['c_i'] * (min_eff ** 2) + unit['s_i'])\n        candidates.append((cost_min, idx, min_eff, max_eff, True))\n        candidate_eff_min[idx] = min_eff\n        candidate_eff_max[idx] = max_eff\n    \n    # Sort candidates by cost at min output\n    candidates.sort(key=lambda x: x[0])\n    \n    committed_set = set(must_on)\n    total_min_c = total_min_must\n    total_max_c = total_max_must\n    \n    # Add candidates until total_max covers load\n    for cost_min, idx, min_eff, max_eff, is_free_off in candidates:\n        if total_max_c >= current_load:\n            break\n        committed_set.add(idx)\n        total_min_c += min_eff\n        total_max_c += max_eff\n    \n    # Determine dispatch target\n    dispatch_target = min(max(total_min_c, current_load), total_max_c)\n    \n    # Initialize all to min\n    for idx in committed_set:\n        if idx in must_on:\n            p_vector[idx] = must_on_effective_min[idx]\n        else:\n            p_vector[idx] = candidate_eff_min[idx]\n        u_vector[idx] = 1\n    current_total = sum(p_vector[idx] for idx in committed_set)\n    remaining = dispatch_target - current_total\n    \n    # Merit-order ramping\n    marginal_costs = []\n    for idx in committed_set:\n        unit = units_info[idx]\n        if idx in must_on:\n            low = must_on_effective_min[idx]\n            high = must_on_effective_max[idx]\n        else:\n            low = candidate_eff_min[idx]\n            high = candidate_eff_max[idx]\n        mc = unit['b_i'] + 2 * unit['c_i'] * p_vector[idx]\n        marginal_costs.append((mc, idx, low, high, p_vector[idx]))\n    \n    # Increase production (if remaining > 0)\n    if remaining > 0:\n        marginal_costs.sort(key=lambda x: x[0])\n        for mc, idx, low, high, current in marginal_costs:\n            if remaining <= 0:\n                break\n            headroom = high - current\n            if headroom > 0:\n                alloc = min(remaining, headroom)\n                p_vector[idx] += alloc\n                remaining -= alloc\n    \n    # Decrease production (if remaining < 0)\n    elif remaining < 0:\n        marginal_costs.sort(key=lambda x: -x[0])\n        for mc, idx, low, high, current in marginal_costs:\n            if remaining >= 0:\n                break\n            headroom = current - low\n            if headroom > 0:\n                alloc = min(-remaining, headroom)\n                p_vector[idx] -= alloc\n                remaining += alloc\n    \n    return np.array([u_vector, p_vector])",
          "from": "mutation",
          "gap_power_rate": 0.0059313678,
          "gap_price_rate": 0.0179953764,
          "fitness": 0.0119633721
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": null,
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]  # Extract current load\n    n_units = len(units_info)\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Extract unit attributes\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    p_shut_i = [unit['p_shut_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n\n    # Classify units\n    for i in range(n_units):\n        if u_i_0[i] == 1:\n            if (t_i_0[i] < t_on_min_i[i]) or (p_i_0[i] > p_shut_i[i]) or (p_i_0[i] > p_down_i[i]):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(t_i_0[i]) < t_off_min_i[i]:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n        u_i[i] = 1 if (i in must_on or i in free_on) else 0\n\n    # Initialize effective min/max for committed units\n    for i in range(n_units):\n        if u_i[i] == 1:\n            if u_i_0[i] == 1:\n                effective_min[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                effective_max[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n            else:\n                effective_min[i] = p_min_i[i]\n                effective_max[i] = min(p_max_i[i], p_start_i[i])\n        else:\n            effective_min[i] = 0\n            effective_max[i] = 0\n\n    total_min = sum(effective_min)\n    total_max = sum(effective_max)\n\n    # Step 3: Decommit free-on units if total_min > current_load\n    committed_free_on = free_on.copy()\n    if total_min > current_load and committed_free_on:\n        # Calculate cost per MW at effective min\n        cost_per_mw = []\n        for i in committed_free_on:\n            cost_val = a_i[i] + b_i[i]*effective_min[i] + c_i[i]*effective_min[i]**2\n            cost_per_mw.append((i, cost_val / effective_min[i]))\n        cost_per_mw.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in cost_per_mw:\n            if total_min <= current_load:\n                break\n            prev_min = effective_min[i]\n            new_min = max(p_min_i[i], p_i_0[i] - p_down_i[i]) if u_i_0[i]==1 else p_min_i[i]\n            if (total_min - prev_min + new_min) <= current_load:\n                u_i[i] = 0\n                p_i[i] = 0\n                total_min -= prev_min\n                total_max -= effective_max[i]\n                effective_min[i] = 0\n                effective_max[i] = 0\n                if i in committed_free_on:\n                    committed_free_on.remove(i)\n\n    # Step 4: Commit free-off units if total_max < current_load\n    if total_max < current_load and free_off:\n        # Calculate cost per MW (including startup)\n        cost_per_mw = []\n        for i in free_off:\n            cost_val = s_i[i] + a_i[i] + b_i[i]*p_min_i[i] + c_i[i]*p_min_i[i]**2\n            cost_per_mw.append((i, cost_val / p_min_i[i]))\n        cost_per_mw.sort(key=lambda x: x[1])\n        \n        for i, _ in cost_per_mw:\n            if total_max >= current_load:\n                break\n            u_i[i] = 1\n            effective_min_i = p_min_i[i]\n            effective_max_i = min(p_max_i[i], p_start_i[i])\n            effective_min[i] = effective_min_i\n            effective_max[i] = effective_max_i\n            total_min += effective_min_i\n            total_max += effective_max_i\n            if i in free_off:\n                free_off.remove(i)\n\n    # Step 5: Decommit non-essential free-on units\n    if committed_free_on:\n        cost_per_mw = []\n        for i in committed_free_on:\n            cost_val = a_i[i] + b_i[i]*effective_min[i] + c_i[i]*effective_min[i]**2\n            cost_per_mw.append((i, cost_val / effective_min[i]))\n        cost_per_mw.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in cost_per_mw:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load <= new_total_max:\n                u_i[i] = 0\n                p_i[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                effective_min[i] = 0\n                effective_max[i] = 0\n                if i in committed_free_on:\n                    committed_free_on.remove(i)\n\n    # Collect committed units\n    committed_units = [i for i in range(n_units) if u_i[i] == 1]\n    \n    # Dispatch\n    if not committed_units:\n        return np.array([u_i, p_i])\n    \n    if current_load <= total_min:\n        for i in committed_units:\n            p_i[i] = effective_min[i]\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_i[i] = effective_max[i]\n    else:\n        # Initialize with effective min\n        for i in committed_units:\n            p_i[i] = effective_min[i]\n        remaining_load = current_load - total_min\n        max_iter = 50\n        tol = 0.1\n        low_lambda = 0\n        high_lambda = 0\n        for i in committed_units:\n            marginal_min = 2 * c_i[i] * effective_min[i] + b_i[i]\n            marginal_max = 2 * c_i[i] * effective_max[i] + b_i[i]\n            if low_lambda == 0 or marginal_min < low_lambda:\n                low_lambda = marginal_min\n            if high_lambda == 0 or marginal_max > high_lambda:\n                high_lambda = marginal_max\n        \n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for i in committed_units:\n                if c_i[i] == 0:\n                    if mid_lambda < b_i[i]:\n                        p_i[i] = effective_min[i]\n                    else:\n                        p_i[i] = effective_max[i]\n                else:\n                    p_i[i] = (mid_lambda - b_i[i]) / (2 * c_i[i])\n                    p_i[i] = max(effective_min[i], min(effective_max[i], p_i[i]))\n                total_power += p_i[i]\n            \n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Adjust residual load\n        residual = current_load - total_power\n        while abs(residual) > tol:\n            if residual > 0:\n                candidates = [i for i in committed_units if p_i[i] < effective_max[i]]\n                if not candidates:\n                    break\n                min_marginal_cost = np.inf\n                best_i = candidates[0]\n                for i in candidates:\n                    marginal_cost = 2 * c_i[i] * p_i[i] + b_i[i]\n                    if marginal_cost < min_marginal_cost:\n                        min_marginal_cost = marginal_cost\n                        best_i = i\n                max_increase = min(effective_max[best_i] - p_i[best_i], residual)\n                p_i[best_i] += max_increase\n                residual -= max_increase\n            else:\n                candidates = [i for i in committed_units if p_i[i] > effective_min[i]]\n                if not candidates:\n                    break\n                max_marginal_cost = -np.inf\n                best_i = candidates[0]\n                for i in candidates:\n                    marginal_cost = 2 * c_i[i] * p_i[i] + b_i[i]\n                    if marginal_cost > max_marginal_cost:\n                        max_marginal_cost = marginal_cost\n                        best_i = i\n                max_decrease = min(p_i[best_i] - effective_min[best_i], -residual)\n                p_i[best_i] -= max_decrease\n                residual += max_decrease\n    \n    # Ensure non-committed units are offline\n    for i in range(n_units):\n        if u_i[i] == 0:\n            p_i[i] = 0.0\n    \n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.0005091869,
          "gap_price_rate": 0.0235416796,
          "fitness": 0.0120254332
     },
     {
          "name": "rolling_unit_commitment_heuristic_refined",
          "algorithm": "1. Classify units into must-on, must-off, free-on, and free-off based on min up/downtime and shutdown constraints\n2. Start with must-on and free-on units committed\n3. Compute effective min/max outputs considering ramp constraints for committed units\n4. Decommit free-on units with highest (min_output \u00d7 cost per MW) if total minimum exceeds load, maintaining feasibility\n5. Commit free-off units with lowest (startup_cost + min_output_cost)/min_output if max capacity is insufficient\n6. Perform economic dispatch by:\n   a. Setting committed units to effective minimum outputs\n   b. Distributing remaining load to units with lowest marginal costs\n   c. Adjusting downwards if over-allocated using highest marginal costs\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\nimport copy\n\ndef rolling_unit_commitment_heuristic_refined(units_info, load):\n    # Create a working copy to avoid modifying input\n    units = copy.deepcopy(units_info)\n    current_load = load[0]\n    \n    # Classify units\n    must_on_units = []\n    must_off_units = []\n    free_on_units = []\n    free_off_units = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:\n            # Check if must remain on\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on_units.append(unit)\n            else:\n                free_on_units.append(unit)\n        else:\n            # Check if must remain off\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off_units.append(unit)\n            else:\n                free_off_units.append(unit)\n    \n    # Initial commitment\n    committed_set = must_on_units + free_on_units\n    for unit in must_off_units:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Compute effective min/max outputs\n    for unit in committed_set:\n        # Online units\n        min_eff = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_eff = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['min_eff'] = min_eff\n        unit['max_eff'] = max_eff\n    \n    for unit in free_off_units:\n        # Offline units that may be started\n        min_eff = unit['p_min_i']\n        max_eff = min(unit['p_max_i'], unit['p_start_i'])\n        unit['min_eff'] = min_eff\n        unit['max_eff'] = max_eff\n    \n    # Calculate total min and max capacity\n    total_min = sum(unit['min_eff'] for unit in committed_set)\n    total_max = sum(unit['max_eff'] for unit in committed_set)\n    \n    # Decommit free-on units if over-committed\n    free_on_units.sort(key=lambda u: (u['min_eff'] * (u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff']), \n                     reverse=True)\n    to_remove = []\n    for unit in free_on_units:\n        if total_min <= current_load:\n            break\n        new_min = total_min - unit['min_eff']\n        new_max = total_max - unit['max_eff']\n        if new_min <= current_load and new_max >= current_load:\n            total_min = new_min\n            total_max = new_max\n            committed_set.remove(unit)\n            to_remove.append(unit)\n    for unit in to_remove:\n        free_on_units.remove(unit)\n    \n    # Commit free-off units if under-capacity\n    if total_max < current_load:\n        free_off_units.sort(key=lambda u: (u['s_i'] + u['a_i'] + u['b_i']*u['min_eff'] + u['c_i']*u['min_eff']**2) / u['min_eff'])\n        to_commit = []\n        for unit in free_off_units:\n            if total_max >= current_load:\n                break\n            total_min += unit['min_eff']\n            total_max += unit['max_eff']\n            committed_set.append(unit)\n            to_commit.append(unit)\n        for unit in to_commit:\n            free_off_units.remove(unit)\n    \n    # Initialize power outputs\n    total_p = 0\n    for unit in committed_set:\n        unit['u_i'] = 1\n        unit['p_i'] = unit['min_eff']\n        total_p += unit['min_eff']\n    \n    # Economic dispatch: allocate remaining load\n    remaining = current_load - total_p\n    if remaining > 0:  # Increase production\n        units_sorted = sorted(committed_set, key=lambda u: u['b_i'] + 2*u['c_i']*u['p_i'])\n        for unit in units_sorted:\n            if remaining <= 0:\n                break\n            avail = unit['max_eff'] - unit['p_i']\n            if avail > 0:\n                amount = min(remaining, avail)\n                unit['p_i'] += amount\n                remaining -= amount\n    elif remaining < 0:  # Decrease production\n        remaining = -remaining\n        units_sorted = sorted(committed_set, key=lambda u: u['b_i'] + 2*u['c_i']*u['p_i'], reverse=True)\n        for unit in units_sorted:\n            if remaining <= 0:\n                break\n            avail = unit['p_i'] - unit['min_eff']\n            if avail > 0:\n                amount = min(remaining, avail)\n                unit['p_i'] -= amount\n                remaining -= amount\n    \n    # Set decommitted units to zero\n    decommitted = free_off_units + must_off_units + free_on_units\n    for unit in decommitted:\n        unit['u_i'] = 0\n        unit['p_i'] = 0\n    \n    # Prepare output\n    schedules = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedules[0, i] = unit['u_i']\n        schedules[1, i] = unit['p_i']\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.018897445,
          "gap_price_rate": 0.0118576912,
          "fitness": 0.0153775681
     },
     {
          "name": "dynamic_priority_dispatch",
          "algorithm": "1. Classify units into must-on (insufficient up-time or above shutdown capacity), must-off (insufficient down-time), free-on (online and can turn off), and free-off (offline and can turn on).\n2. Initial commitment: must-on and free-on units.\n3. While total minimum output > current load and free-on units available, turn off free-on units by descending minimum output (ramp-down constrained).\n4. For free-off units (sorted by ascending (startup cost + production cost at p_min)/p_min), add units if total min \u2264 load. Stop when total max \u2265 load.\n5. Dispatch:\n   a) Compute min/max outputs considering ramp/start constraints.\n   b) Initialize outputs to min. Calculate deficit (load - total min) and headroom (total max - total min).\n   c) If deficit \u2264 headroom, distribute load incrementally using merit order of marginal cost at min output.\n   d) Else, set outputs to max (under-committed).\n6. Return unit states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef dynamic_priority_dispatch(units_info, load):\n    current_load = load[0]  # Current time step load\n    n_units = len(units_info)\n    if n_units == 0:\n        return np.zeros((2, 0))\n    \n    # Initialize sets\n    must_on = set()\n    must_off = set()\n    free_on = set()\n    free_off = set()\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < t_on_min or p0 > p_shut:\n                must_on.add(i)\n            else:\n                free_on.add(i)\n        else:\n            if t0 < 0 and (-t0) < t_off_min:\n                must_off.add(i)\n            else:\n                free_off.add(i)\n    \n    # Initial commitment: must-on and free-on units\n    committed = must_on | free_on\n    \n    # Step 1: Compute initial min outputs for online units (ramp-down constrained)\n    min_i_dict = {}\n    max_i_dict = {}\n    for i in committed:\n        unit = units_info[i]\n        min_output = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_output = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_i_dict[i] = min_output\n        max_i_dict[i] = max_output\n    \n    # Compute total min and max for the committed units\n    total_min = sum(min_i_dict[i] for i in committed)\n    total_max = sum(max_i_dict[i] for i in committed)\n    \n    # Step 2: Turn off free-on units if over-committed (min output > load)\n    free_on_in_committed = [i for i in committed if i in free_on]\n    # Sort free-on by min_output (descending)\n    free_on_in_committed.sort(key=lambda i: min_i_dict[i], reverse=True)\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        committed.remove(i)\n        total_min -= min_i_dict[i]\n        total_max -= max_i_dict[i]\n    \n    # Step 3: Compute min and max for online units in committed set again\n    min_i_dict = {i: min_i_dict[i] for i in committed}\n    max_i_dict = {i: max_i_dict[i] for i in committed}\n    \n    # Compute cost per MW for free-off units: (startup + cost at p_min) / p_min\n    free_off_avail = sorted(free_off, key=lambda i: \n        (units_info[i]['s_i'] + units_info[i]['a_i'] + \n         units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n         units_info[i]['c_i'] * (units_info[i]['p_min_i'] ** 2)) / \n        (units_info[i]['p_min_i'] if units_info[i]['p_min_i'] > 0 else 1e9))\n    \n    # Add free-off units until meeting load, prioritizing low cost per MW\n    total_min_current = total_min\n    total_max_current = total_max\n    \n    for i in free_off_avail:\n        if total_max_current >= current_load:\n            break\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = min(unit['p_max_i'], unit['p_start_i'])\n        if total_min_current + p_min <= current_load: \n            committed.add(i)\n            total_min_current += p_min\n            total_max_current += p_max\n            # Precompute min/max for dispatch\n            min_i_dict[i] = p_min\n            max_i_dict[i] = p_max\n    \n    # Step 4: Dispatch\n    # Compute min/max for final committed set (considering start/ramp constraints)\n    min_dict = {}\n    max_dict = {}\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        min_dict[i] = min_i\n        max_dict[i] = max_i\n    \n    total_min_sum = sum(min_dict.values())\n    total_max_sum = sum(max_dict.values())\n    \n    # Calculate deficit and headroom\n    deficit = current_load - total_min_sum\n    headroom = total_max_sum - total_min_sum\n    p_dict = {i: min_dict[i] for i in committed}\n    \n    # Distribute deficit or handle under-commitment\n    if deficit <= headroom and deficit >= 0:\n        # Sort by marginal cost (incremental at min output)\n        committed_list = sorted(committed, \n                               key=lambda i: units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_dict[i])\n        \n        for i in committed_list:\n            if deficit <= 0:\n                break\n            avail = max_dict[i] - min_dict[i]\n            add_amount = min(avail, deficit)\n            p_dict[i] += add_amount\n            deficit -= add_amount\n    elif deficit > headroom:  # Under-committed: set to max\n        for i in committed:\n            p_dict[i] = max_dict[i]\n    \n    # Build output vectors\n    u_vector = np.zeros(n_units)\n    p_vector = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if i in p_dict:\n            u_vector[i] = 1\n            p_vector[i] = p_dict[i]\n    \n    return np.array([u_vector, p_vector])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     }
]