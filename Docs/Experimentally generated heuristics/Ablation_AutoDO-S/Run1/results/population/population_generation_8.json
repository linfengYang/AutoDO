[
     {
          "name": "refined_evolved_rolling_commitment_v3",
          "algorithm": "1. Classify units into categories: must-on (previously online and violated min up-time or shutdown ramp constraint), must-off (previously offline and violated min down-time), free-on (previously online and commitable), free-off (previously offline and commitable)\n2. Initially commit must-on and free-on units\n3. Compute effective power limits considering ramp constraints:\n   - Previously online: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - New starts: [p_min, min(p_max, startup_ramp)]\n4. Decommit free-on units by highest cost per MW at effective min output ((a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211min_output \u2264 load\n5. Commit free-off units by lowest cost per MW including startup ((s_i + a_i + b_i*p_eff_min + c_i*p_eff_min\u00b2)/p_eff_min) until \u2211max_output \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW (same metric) if removal maintains \u2211max_output \u2265 load\n7. Dispatch using bisection method to find optimal lambda for economic dispatch with residual adjustment:\n   a) If load \u2264 total min: set all to min output\n   b) If load \u2265 total max: set all to max output\n   c) Else: find \u03bb such that \u2211clamped outputs equals load, then adjust residual by marginal cost order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    if n_units == 0:\n        return schedules\n        \n    u_0 = [unit['u_i_0'] for unit in units_info]\n    t_0 = [unit['t_i_0'] for unit in units_info]\n    p_0 = [unit['p_i_0'] for unit in units_info]\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    startup_ramp = [unit['p_start_i'] for unit in units_info]\n    shutdown_cap = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    \n    must_on = [False] * n_units\n    must_off = [False] * n_units\n    free_on = [False] * n_units\n    free_off = [False] * n_units\n    \n    for i in range(n_units):\n        if u_0[i] == 1: \n            must_on[i] = (t_0[i] < min_up[i]) or (p_0[i] > shutdown_cap[i])\n            free_on[i] = not must_on[i]\n        else:\n            must_off[i] = (-t_0[i] < min_down[i])\n            free_off[i] = not must_off[i]\n    \n    committed = must_on.copy()\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for i in range(n_units):\n        if must_on[i]:\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    for i in range(n_units):\n        if free_on[i]:\n            committed[i] = True\n            eff_min[i] = max(p_min[i], p_0[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_0[i] + ramp_up[i])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed and total_min > current_load:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_min - eff_min[i] <= current_load:\n                break\n            committed[i] = False\n            eff_min[i] = eff_max[i] = 0.0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n    \n    free_off_available = [i for i in range(n_units) if free_off[i] and not committed[i]]\n    if free_off_available and total_max < current_load:\n        metric_commit = []\n        for i in free_off_available:\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            cost = s[i] + a[i] + b[i] * eff_min_i + c[i] * eff_min_i**2\n            metric_commit.append(cost / eff_min_i)\n        idx_sorted = np.argsort(metric_commit)\n        \n        for idx in idx_sorted:\n            i = free_off_available[idx]\n            eff_min_i = p_min[i]\n            eff_max_i = min(p_max[i], startup_ramp[i])\n            if total_max + eff_max_i >= current_load:\n                break\n            committed[i] = True\n            eff_min[i] = eff_min_i\n            eff_max[i] = eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n    \n    free_on_committed = [i for i in range(n_units) if free_on[i] and committed[i]]\n    if free_on_committed:\n        metric_decommit = []\n        for i in free_on_committed:\n            cost = a[i] + b[i] * eff_min[i] + c[i] * eff_min[i]**2\n            metric_decommit.append(cost / eff_min[i])\n        idx_sorted = np.argsort(metric_decommit)[::-1]\n        \n        for idx in idx_sorted:\n            i = free_on_committed[idx]\n            if total_max - eff_max[i] >= current_load:\n                committed[i] = False\n                eff_min[i] = eff_max[i] = 0.0\n                total_min -= eff_min[i]\n                total_max -= eff_max[i]\n    \n    p = [0.0] * n_units\n    if not any(committed):\n        return np.array([committed, p])\n    \n    total_min = sum(eff_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(eff_max[i] for i in range(n_units) if committed[i])\n    \n    if current_load <= total_min:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in range(n_units):\n            if committed[i]:\n                p[i] = eff_max[i]\n    else:\n        committed_units = [i for i in range(n_units) if committed[i]]\n        low = min(2 * c[i] * eff_min[i] + b[i] for i in committed_units) - 100\n        high = max(2 * c[i] * eff_max[i] + b[i] for i in committed_units) + 100\n        \n        for _ in range(100):\n            lamb = (low + high) / 2\n            p_temp = []\n            total_p = 0.0\n            for i in committed_units:\n                p_i = (lamb - b[i]) / (2 * c[i])\n                p_i = max(eff_min[i], min(eff_max[i], p_i))\n                p_temp.append(p_i)\n                total_p += p_i\n            \n            if total_p < current_load:\n                low = lamb\n            else:\n                high = lamb\n        \n        residual = current_load - total_p\n        if residual != 0:\n            if residual > 0:\n                eligible = [(i, p_temp[k], eff_max[i]) for k, i in enumerate(committed_units) if p_temp[k] < eff_max[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]))\n                for i, current, upper in eligible:\n                    available = upper - current\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = upper\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] += residual\n                        residual = 0\n                        break\n            else:\n                residual = abs(residual)\n                eligible = [(i, p_temp[k], eff_min[i]) for k, i in enumerate(committed_units) if p_temp[k] > eff_min[i]]\n                eligible.sort(key=lambda x: (2 * c[x[0]] * x[1] + b[x[0]]), reverse=True)\n                for i, current, lower in eligible:\n                    available = current - lower\n                    if available <= residual:\n                        p_temp[committed_units.index(i)] = lower\n                        residual -= available\n                    else:\n                        p_temp[committed_units.index(i)] -= residual\n                        residual = 0\n                        break\n            \n            total_p = sum(p_temp)\n            residual_final = current_load - total_p\n            if residual_final != 0:\n                avg_adjust = residual_final / len(committed_units)\n                p_temp = [min(eff_max[i], max(eff_min[i], p_temp[k] + avg_adjust)) for k, i in enumerate(committed_units)]\n                total_p = sum(p_temp)\n                remaining_adjust = current_load - total_p\n                if remaining_adjust > 0:\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, eff_max[i] - p_temp[k])\n                        p_temp[k] += diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n                elif remaining_adjust < 0:\n                    remaining_adjust = abs(remaining_adjust)\n                    for k in range(len(committed_units)):\n                        i = committed_units[k]\n                        diff = min(remaining_adjust, p_temp[k] - eff_min[i])\n                        p_temp[k] -= diff\n                        remaining_adjust -= diff\n                        if remaining_adjust <= 0:\n                            break\n        \n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n        else:\n            for k, i in enumerate(committed_units):\n                p[i] = p_temp[k]\n    \n    schedules[0] = [1 if committed[i] else 0 for i in range(n_units)]\n    schedules[1] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.00543839,
          "gap_price_rate": 0.0077145078,
          "fitness": 0.0065764489
     },
     {
          "name": "optimized_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable). \n2. Commit must-on and free-on units as initial set. \n3. Compute effective min/max outputs considering ramp constraints: max(p_min_i, p_i_0 - p_down_i) to min(p_max_i, p_i_0 + p_up_i) for previously online units; p_min_i to min(p_max_i, p_start_i) for new commitments. \n4. Decommit free-on units by highest cost/MW (a_i + b_i * eff_min_i + c_i * eff_min_i^2)/eff_min_i until total min output \u2264 current load. \n5. Commit free-off units by lowest (s_i + a_i + b_i * p_min_i + c_i * p_min_i^2)/p_min_i until total max output \u2265 current load. \n6. Decommit remaining free-on units in descending order of cost/MW at effective min if removal maintains total max \u2265 load. \n7. Dispatch: \n   a) If load \u2264 total min: set outputs to effective min \n   b) If load \u2265 total max: set outputs to effective max \n   c) Else: perform economic dispatch via lambda iteration with bisection (100 iterations) followed by residual adjustment based on marginal cost merit order. \n8. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef optimized_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize units arrays\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    is_must_on = np.zeros(n_units, dtype=bool)\n    is_must_off = np.zeros(n_units, dtype=bool)\n    is_free_on = np.zeros(n_units, dtype=bool)\n    is_free_off = np.zeros(n_units, dtype=bool)\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    marginal_cost = np.zeros(n_units)\n    headroom = np.zeros(n_units)\n    min_costs = np.zeros(n_units)\n    startup_metrics = np.zeros(n_units)\n    \n    # Extract unit parameters\n    a = np.array([unit['a_i'] for unit in units_info])\n    b = np.array([unit['b_i'] for unit in units_info])\n    c = np.array([unit['c_i'] for unit in units_info])\n    u0 = np.array([unit['u_i_0'] for unit in units_info])\n    t0 = np.array([unit['t_i_0'] for unit in units_info])\n    p0 = np.array([unit['p_i_0'] for unit in units_info])\n    p_min = np.array([unit['p_min_i'] for unit in units_info])\n    p_max = np.array([unit['p_max_i'] for unit in units_info])\n    p_up = np.array([unit['p_up_i'] for unit in units_info])\n    p_down = np.array([unit['p_down_i'] for unit in units_info])\n    p_start = np.array([unit['p_start_i'] for unit in units_info])\n    p_shut = np.array([unit['p_shut_i'] for unit in units_info])\n    min_up = np.array([unit['t_on_min_i'] for unit in units_info])\n    min_down = np.array([unit['t_off_min_i'] for unit in units_info])\n    startup_cost = np.array([unit['s_i'] for unit in units_info])\n    \n    # Step 1: Classify units\n    is_must_on = (u0 == 1) & ((t0 < min_up) | (p0 > p_shut))\n    is_must_off = (u0 == 0) & (t0 > -min_down)\n    is_free_on = (u0 == 1) & (~is_must_on)\n    is_free_off = (u0 == 0) & (~is_must_off)\n    \n    # Step 2: Initial commit (must-on + free-on)\n    u[is_must_on | is_free_on] = 1\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in range(n_units):\n        if u[i]:\n            if u0[i]:  # Previously online\n                effective_min[i] = max(p_min[i], p0[i] - p_down[i])\n                effective_max[i] = min(p_max[i], p0[i] + p_up[i])\n            else:  # New start\n                effective_min[i] = p_min[i]\n                effective_max[i] = min(p_max[i], p_start[i])\n        else:\n            effective_min[i] = effective_max[i] = 0.0\n    \n    total_min = np.sum(effective_min[u == 1])\n    total_max = np.sum(effective_max[u == 1])\n    \n    # Step 4: Decommit expensive free-on units\n    if total_min > current_load:\n        # Calculate min cost per MW\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            if total_min <= current_load:\n                break\n            unit_idx = free_on_indices[idx]\n            if u[unit_idx]:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 5: Commit cheap free-off units\n    if total_max < current_load:\n        # Calculate startup metric\n        startup_metrics = (startup_cost[is_free_off] + a[is_free_off] +\n                           b[is_free_off] * p_min[is_free_off] + \n                           c[is_free_off] * p_min[is_free_off]**2) / p_min[is_free_off]\n        free_off_indices = np.where(is_free_off)[0]\n        sort_indices = np.argsort(startup_metrics)\n        \n        for idx in sort_indices:\n            unit_idx = free_off_indices[idx]\n            new_min = p_min[unit_idx]\n            new_max = min(p_max[unit_idx], p_start[unit_idx])\n            if total_max + new_max >= current_load:\n                break\n            u[unit_idx] = 1\n            effective_min[unit_idx] = new_min\n            effective_max[unit_idx] = new_max\n            total_min += new_min\n            total_max += new_max\n    \n    # Step 6: Decommit non-essential free-on units\n    if any(is_free_on & u.astype(bool)):\n        min_costs = (a[is_free_on] + b[is_free_on] * effective_min[is_free_on] + \n                     c[is_free_on] * effective_min[is_free_on]**2) / effective_min[is_free_on]\n        free_on_indices = np.where(is_free_on & u)[0]\n        sort_indices = np.argsort(min_costs)[::-1]\n        \n        for idx in sort_indices:\n            unit_idx = free_on_indices[idx]\n            if total_max - effective_max[unit_idx] >= current_load:\n                u[unit_idx] = 0\n                effective_min[unit_idx] = effective_max[unit_idx] = 0.0\n                total_min -= effective_min[unit_idx]\n                total_max -= effective_max[unit_idx]\n    \n    # Step 7: Dispatch power to committed units\n    if current_load <= total_min:\n        p = np.where(u, effective_min, 0.0)\n    elif current_load >= total_max:\n        p = np.where(u, effective_max, 0.0)\n    else:\n        # Get indices of committed units\n        committed_idx = np.where(u)[0]\n        comm_min = effective_min[committed_idx]\n        comm_max = effective_max[committed_idx]\n        comm_a = a[committed_idx]\n        comm_b = b[committed_idx]\n        comm_c = c[committed_idx]\n        \n        # Bisection method setup\n        lambda_low = np.min(comm_b + 2 * comm_c * comm_min)\n        lambda_high = np.max(comm_b + 2 * comm_c * comm_max)\n        tolerance = 1e-5\n        \n        # Run bisection\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_set = np.clip((lambda_mid - comm_b) / (2 * comm_c + 1e-10), comm_min, comm_max)\n            total_power = np.sum(p_set)\n            \n            if abs(total_power - current_load) < tolerance:\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Residual adjustment\n        deficit = current_load - total_power\n        if abs(deficit) > tolerance:\n            # Compute marginal cost at current setpoints\n            marginal_costs = comm_b + 2 * comm_c * p_set\n            headroom = comm_max - p_set\n            \n            # Merit order for deficit adjustment\n            if deficit > 0:\n                priority_order = np.argsort(marginal_costs)\n                for idx in priority_order:\n                    if deficit <= 0:\n                        break\n                    if headroom[idx] > 0:\n                        adjust = min(headroom[idx], deficit)\n                        p_set[idx] += adjust\n                        deficit -= adjust\n            else:  # surplus (negative deficit)\n                surplus = -deficit\n                priority_order = np.argsort(marginal_costs)[::-1]\n                for idx in priority_order:\n                    if surplus <= 0:\n                        break\n                    avail = p_set[idx] - comm_min[idx]\n                    if avail > 0:\n                        adjust = min(avail, surplus)\n                        p_set[idx] -= adjust\n                        surplus -= adjust\n        \n        # Assign dispatch values\n        p[committed_idx] = p_set\n    \n    # Step 8: Set non-committed units\n    p[u == 0] = 0.0\n    \n    # Prepare output array\n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0061078301,
          "gap_price_rate": 0.0078211476,
          "fitness": 0.0069644889
     },
     {
          "name": "refined_evolved_rolling_commitment_v4",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v4(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Preallocate arrays\n    u = np.zeros(n_units)  # Commitment status\n    p = np.zeros(n_units)  # Output power\n    cat = [''] * n_units   # Unit categories\n    eff_min = np.zeros(n_units)  # Effective min output\n    eff_max = np.zeros(n_units)  # Effective max output\n    \n    # Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < unit['t_on_min_i']) or (p0 > unit['p_shut_i']):\n                cat[i] = 'must_on'\n                u[i] = 1\n            else:\n                cat[i] = 'free_on'\n                u[i] = 1\n        else:  # Previously offline\n            if t0 < 0 and (-t0) < unit['t_off_min_i']:\n                cat[i] = 'must_off'\n                u[i] = 0\n            else:\n                cat[i] = 'free_off'\n                u[i] = 0\n                \n    # Step 4: Decommit high-cost free-on units\n    free_on_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    total_min = sum(eff_min[i] for i in range(n_units) if u[i]==1)\n    \n    # Define cost per MW metric\n    def cost_metric(i, include_startup=False):\n        base = units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \\\n               units_info[i]['c_i'] * eff_min[i]**2\n        if include_startup:\n            base += units_info[i]['s_i']\n        denom = eff_min[i] if eff_min[i] >= 1e-5 else 1.0\n        return base / denom\n    \n    # Decommit free-on units until total_min \u2264 current_load\n    if total_min > current_load:\n        sorted_free_on = sorted(free_on_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit low-cost free-off units\n    total_max = sum(eff_max[i] for i in range(n_units) if u[i]==1)\n    free_off_idx = [i for i in range(n_units) if cat[i]=='free_off' and u[i]==0]\n    \n    if total_max < current_load:\n        sorted_free_off = sorted(free_off_idx, key=lambda i: cost_metric(i, include_startup=True))\n        for i in sorted_free_off:\n            u[i] = 1\n            total_max += eff_max[i]\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_rem_idx = [i for i in range(n_units) if cat[i]=='free_on' and u[i]==1]\n    curr_total_max = total_max\n    \n    if free_on_rem_idx:\n        sorted_free_on_rem = sorted(free_on_rem_idx, key=lambda i: cost_metric(i), reverse=True)\n        for i in sorted_free_on_rem:\n            new_total_max = curr_total_max - eff_max[i]\n            if new_total_max >= current_load:\n                u[i] = 0\n                curr_total_max = new_total_max\n    \n    # Dispatch committed units\n    committed_idx = [i for i in range(n_units) if u[i]==1]\n    total_min_comm = sum(eff_min[i] for i in committed_idx)\n    total_max_comm = sum(eff_max[i] for i in committed_idx)\n    \n    if committed_idx:\n        if current_load <= total_min_comm:\n            for i in committed_idx:\n                p[i] = eff_min[i]\n        elif current_load >= total_max_comm:\n            for i in committed_idx:\n                p[i] = eff_max[i]\n        else:\n            # Bisection for lambda\n            low = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_min[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_min[i] > 0)\n            high = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * eff_max[i] \n                      for i in committed_idx if units_info[i]['c_i'] > 0 or eff_max[i] > 0)\n            \n            for _ in range(100):\n                lam = (low + high) / 2\n                total_p = 0.0\n                for i in committed_idx:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_unclamp = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_i = max(eff_min[i], min(eff_max[i], p_unclamp))\n                    else:\n                        p_i = eff_max[i] if lam > unit['b_i'] else eff_min[i]\n                    p[i] = p_i\n                    total_p += p_i\n                \n                if total_p < current_load:\n                    low = lam\n                else:\n                    high = lam\n            \n            # Residual adjustment\n            residual = current_load - total_p\n            if residual > 0:\n                candidates = [i for i in committed_idx if p[i] < eff_max[i]]\n                candidates.sort(key=lambda i: unit['b_i'] + 2 * unit['c_i'] * p[i])\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    inc = min(residual, eff_max[i] - p[i])\n                    p[i] += inc\n                    residual -= inc\n            elif residual < 0:\n                residual = abs(residual)\n                candidates = [i for i in committed_idx if p[i] > eff_min[i]]\n                candidates.sort(key=lambda i: -(unit['b_i'] + 2 * unit['c_i'] * p[i]))\n                for i in candidates:\n                    if residual <= 0:\n                        break\n                    dec = min(residual, p[i] - eff_min[i])\n                    p[i] -= dec\n                    residual -= dec\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0046081286,
          "gap_price_rate": 0.0097404235,
          "fitness": 0.0071742761
     },
     {
          "name": "refined_evolved_rolling_commitment_v2",
          "algorithm": "1. Classify units into must-on (prev online and (min up-time unfulfilled or prev output > shutdown capacity), must-off (prev offline and min down-time unfulfilled), free-on (prev online but decommittable), free-off (prev offline but committable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost/MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + cost at min)/min_output until total max \u2265 load\n6. While possible, decommit free-on units with highest cost/MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection (100 iters) then residual adjustment via merit order\n8. Set non-committed units to offline (0 output)\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters and initialize\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed = set()\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        \n        if u0 == 1:  # Was online\n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:\n                must_on.append(i)\n                committed.add(i)\n            else:\n                free_on.append(i)\n                committed.add(i)\n        else:  # Was offline\n            if abs(t0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 3: Compute effective min/max for committed units\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Prev online\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # New start (not possible here but safe)\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit free-on units if over-min\n    total_min = np.sum(eff_min[list(committed)])\n    free_on_in_committed = [i for i in free_on if i in committed]\n    \n    # Sort free-on by cost/MW at min desc\n    free_on_in_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        if i in committed:\n            committed.remove(i)\n            total_min -= eff_min[i]\n    \n    # Step 5: Commit free-off units if under-max\n    total_max = np.sum(eff_max[list(committed)])\n    # Precompute new start effective max/min\n    for i in free_off:\n        unit = units_info[i]\n        eff_min[i] = unit['p_min_i']\n        eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Sort free-off by (startup cost + cost at min)/min\n    free_off_sorted = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        if i not in committed:\n            committed.add(i)\n            total_max += eff_max[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    removed = True\n    while removed:\n        removed = False\n        total_max = np.sum(eff_max[list(committed)])\n        free_on_committed = [i for i in free_on if i in committed]\n        free_on_committed.sort(key=lambda i: (\n            units_info[i]['a_i'] + \n            units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n            units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n        ) / units_info[i]['p_min_i'], reverse=True)\n        \n        for i in free_on_committed:\n            if total_max - eff_max[i] >= current_load:\n                committed.remove(i)\n                removed = True\n                break\n    \n    # Step 7: Dispatch\n    # Recompute effective min/max for final committed set\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[list(committed)])\n    total_max = np.sum(eff_max[list(committed)])\n    \n    comm_list = list(committed)\n    if current_load <= total_min:\n        for i in comm_list:\n            p[i] = eff_min[i]\n    elif current_load >= total_max:\n        for i in comm_list:\n            p[i] = eff_max[i]\n    else:\n        # Lambda iteration\n        a = [units_info[i]['a_i'] for i in comm_list]\n        b = [units_info[i]['b_i'] for i in comm_list]\n        c = [units_info[i]['c_i'] for i in comm_list]\n        lows = [eff_min[i] for i in comm_list]\n        highs = [eff_max[i] for i in comm_list]\n        n_comm = len(comm_list)\n        \n        # Find lambda range\n        lo = min(b_i + 2*c_i*low_i for (b_i, c_i, low_i) in zip(b, c, lows))\n        hi = max(b_i + 2*c_i*high_i for (b_i, c_i, high_i) in zip(b, c, highs))\n        \n        # Bisection\n        for _ in range(100):\n            lam = (lo + hi) / 2\n            total_p = 0\n            for i in range(n_comm):\n                mc_low = b[i] + 2*c[i]*lows[i]\n                mc_high = b[i] + 2*c[i]*highs[i]\n                if lam < mc_low:\n                    p_i = lows[i]\n                elif lam > mc_high:\n                    p_i = highs[i]\n                else:\n                    p_i = (lam - b[i]) / (2*c[i])\n                total_p += p_i\n            \n            if total_p < current_load:\n                lo = lam\n            else:\n                hi = lam\n        \n        # Calculate p based on final lambda\n        total_p = 0\n        p_dispatch = [0] * n_comm\n        for i in range(n_comm):\n            mc_low = b[i] + 2*c[i]*lows[i]\n            mc_high = b[i] + 2*c[i]*highs[i]\n            if lam < mc_low:\n                p_i = lows[i]\n            elif lam > mc_high:\n                p_i = highs[i]\n            else:\n                p_i = (lam - b[i]) / (2*c[i])\n            p_dispatch[i] = p_i\n            total_p += p_i\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        tol = 1e-5\n        if residual > tol:\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] < highs[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx])\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = highs[idx] - p_dispatch[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] += adjust\n                residual -= adjust\n        elif residual < -tol:\n            residual = -residual\n            indices = [idx for idx in range(n_comm) if p_dispatch[idx] > lows[idx]]\n            indices.sort(key=lambda idx: b[idx] + 2*c[idx]*p_dispatch[idx], reverse=True)\n            for idx in indices:\n                if residual <= tol:\n                    break\n                room = p_dispatch[idx] - lows[idx]\n                adjust = min(residual, room)\n                p_dispatch[idx] -= adjust\n                residual -= adjust\n        \n        # Assign dispatched values\n        for ii, i in enumerate(comm_list):\n            p[i] = p_dispatch[ii]\n    \n    # Set commitments and output for non-committed\n    for i in range(n_units):\n        if i in committed:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Format output\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054285365,
          "gap_price_rate": 0.0091401443,
          "fitness": 0.0072843404
     },
     {
          "name": "rolling_unit_commitment",
          "algorithm": "**  \n1. Classify units:  \n   - must_on: Previously online and (min up-time unfulfilled or previous output > shutdown capacity)  \n   - must_off: Previously offline and min down-time unfulfilled  \n   - free_on: Online and decommittable  \n   - free_off: Offline and committable  \n2. Commit must_on and free_on units.  \n3. Compute effective min/max:  \n   - Previously online: `[max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]`  \n   - New starts: `[p_min, min(p_max, startup_ramp)]`  \n4. Decommit free-on units by highest cost per MW at effective min until total min \u2264 load.  \n5. Commit free-off units by lowest cost per MW at min (including startup) until total max \u2265 load.  \n6. Decommit non-essential free-on units (by same cost metric) if removal maintains total max \u2265 load.  \n7. Dispatch committed units:  \n   a) If load \u2264 total min: Set outputs to min  \n   b) If load \u2265 total max: Set outputs to max  \n   c) Else: Lambda iteration with residual adjustment:  \n      i. Use bisection to find optimal lambda (with clamping)  \n      ii. Adjust residual via marginal cost merit order  \n8. Set non-committed units to off (0 output).  \n\n**",
          "code": "import numpy as np\n\ndef rolling_unit_commitment(units_info, load):\n    def compute_cost_per_MW(unit, eff_min, include_startup=False):\n        if eff_min <= 1e-10:  # Avoid division by zero\n            return float('inf')\n        cost = unit['a_i'] + unit['b_i'] * eff_min + unit['c_i'] * eff_min**2\n        if include_startup:\n            cost += unit['s_i']\n        return cost / eff_min\n\n    units = []\n    for idx, ui in enumerate(units_info):\n        unit = ui.copy()\n        unit['index'] = idx\n        unit['committed'] = False\n        units.append(unit)\n    \n    current_load = load[0]\n    n_units = len(units)\n    \n    # Step 1: Classify units\n    for u in units:\n        if u['u_i_0'] == 1:  # Previously online\n            if u['t_i_0'] < u['t_on_min_i'] or u['p_i_0'] > u['p_shut_i']:\n                u['class'] = 'must_on'\n            else:\n                u['class'] = 'free_on'\n        else:  # Previously offline\n            if -u['t_i_0'] < u['t_off_min_i']:  # Still in min down-time\n                u['class'] = 'must_off'\n            else:\n                u['class'] = 'free_off'\n    \n    # Step 2: Initial commit (must_on + free_on)\n    for u in units:\n        if u['class'] in ['must_on', 'free_on']:\n            u['committed'] = True\n            if u['u_i_0'] == 1:  # Previously online: ramp constraints\n                u['eff_min'] = max(u['p_min_i'], u['p_i_0'] - u['p_down_i'])\n                u['eff_max'] = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n            else:  # New start (shouldn't happen for must_on/free_on)\n                u['eff_min'] = u['p_min_i']\n                u['eff_max'] = min(u['p_max_i'], u['p_start_i'])\n    \n    # Step 3: Compute total min/max\n    total_min = sum(u['eff_min'] for u in units if u['committed'])\n    total_max = sum(u['eff_max'] for u in units if u['committed'])\n    \n    # Step 4: Decommit expensive free-on units\n    free_on = [u for u in units if u['class'] == 'free_on' and u['committed']]\n    for u in free_on:\n        u['cost_per_MW'] = compute_cost_per_MW(u, u['eff_min'])\n    free_on.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    \n    for unit in free_on:\n        if total_min <= current_load:\n            break\n        unit['committed'] = False\n        total_min -= unit['eff_min']\n        total_max -= unit['eff_max']\n    \n    # Step 5: Commit cheap free-off units\n    free_off = [u for u in units if u['class'] == 'free_off' and not u['committed']]\n    for u in free_off:\n        u['eff_min'] = u['p_min_i']\n        u['eff_max'] = min(u['p_max_i'], u['p_start_i'])\n        u['cost_per_MW'] = compute_cost_per_MW(u, u['eff_min'], include_startup=True)\n    free_off.sort(key=lambda x: x['cost_per_MW'])\n    \n    for unit in free_off:\n        if total_max >= current_load:\n            break\n        unit['committed'] = True\n        total_min += unit['eff_min']\n        total_max += unit['eff_max']\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_committed = [u for u in units if u['class'] == 'free_on' and u['committed']]\n    free_on_committed.sort(key=lambda x: x['cost_per_MW'], reverse=True)\n    for unit in free_on_committed:\n        if total_max - unit['eff_max'] >= current_load:\n            unit['committed'] = False\n            total_min -= unit['eff_min']\n            total_max -= unit['eff_max']\n    \n    # Collect committed units\n    committed = [u for u in units if u['committed']]\n    total_min = sum(u['eff_min'] for u in committed)\n    total_max = sum(u['eff_max'] for u in committed)\n    \n    # Step 7: Dispatch\n    outputs = [0.0] * n_units\n    \n    if len(committed) == 0:\n        # Edge case: no committed units\n        u_vec = [0] * n_units\n        p_vec = [0.0] * n_units\n        return np.array([u_vec, p_vec])\n    \n    # 7a: Min/Max dispatch\n    if current_load <= total_min:\n        for u in committed:\n            outputs[u['index']] = u['eff_min']\n    elif current_load >= total_max:\n        for u in committed:\n            outputs[u['index']] = u['eff_max']\n    else:\n        # 7c: Lambda iteration (bisection)\n        low_lambda = min(2*u['c_i']*u['eff_min'] + u['b_i'] if u['c_i']>0 else u['b_i'] for u in committed)\n        high_lambda = max(2*u['c_i']*u['eff_max'] + u['b_i'] if u['c_i']>0 else u['b_i'] for u in committed)\n        lambda_ = (low_lambda + high_lambda) / 2\n        \n        n_iter = 0\n        tol = 1e-5\n        total_output = 0\n        temp_outputs = {}\n        \n        # Bisection loop\n        while n_iter < 100 and abs(total_output - current_load) > tol:\n            total_output = 0\n            for u in committed:\n                # Linear units\n                if u['c_i'] == 0:\n                    p_star = u['eff_max'] if lambda_ > u['b_i'] else u['eff_min']\n                # Quadratic units\n                else:\n                    p_star = (lambda_ - u['b_i']) / (2 * u['c_i'])\n                    p_star = max(u['eff_min'], min(u['eff_max'], p_star))\n                temp_outputs[u['index']] = p_star\n                total_output += p_star\n                \n            if abs(total_output - current_load) <= tol:\n                break\n                \n            if total_output < current_load:\n                low_lambda = lambda_\n            else:\n                high_lambda = lambda_\n                \n            lambda_ = (low_lambda + high_lambda) / 2\n            n_iter += 1\n        \n        # Residual adjustment\n        residual = current_load - total_output\n        if abs(residual) > tol:\n            # Increase needed\n            if residual > 0:\n                candidates = []\n                for u in committed:\n                    if temp_outputs[u['index']] < u['eff_max']:\n                        if u['c_i'] > 0:\n                            mc = 2 * u['c_i'] * temp_outputs[u['index']] + u['b_i']\n                        else:\n                            mc = u['b_i']\n                        candidates.append((mc, u['index']))\n                candidates.sort(key=lambda x: x[0])\n                \n                for mc, idx in candidates:\n                    if abs(residual) < tol:\n                        break\n                    available = units[idx]['eff_max'] - temp_outputs[idx]\n                    delta = min(available, residual)\n                    temp_outputs[idx] += delta\n                    residual -= delta\n                    \n            # Decrease needed\n            elif residual < 0:\n                candidates = []\n                for u in committed:\n                    if temp_outputs[u['index']] > u['eff_min']:\n                        if u['c_i'] > 0:\n                            mc = 2 * u['c_i'] * temp_outputs[u['index']] + u['b_i']\n                        else:\n                            mc = u['b_i']\n                        candidates.append((mc, u['index']))\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                \n                for mc, idx in candidates:\n                    if abs(residual) < tol:\n                        break\n                    available = temp_outputs[idx] - units[idx]['eff_min']\n                    delta = min(available, -residual)\n                    temp_outputs[idx] -= delta\n                    residual += delta\n        \n        for u in committed:\n            outputs[u['index']] = temp_outputs[u['index']]\n    \n    # Final output arrays\n    u_vec = [1 if u['committed'] else 0 for u in units]\n    p_vec = [outputs[i] if u['committed'] else 0.0 for i, u in enumerate(units)]\n    \n    return np.array([u_vec, p_vec])",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "advanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), free-off (offline but commitable)\n2. Commit must-on and free-on units initially\n3. Compute effective min/max outputs considering ramp constraints:\n   - Prev online units: max(p_min, prev_p - ramp_down) to min(p_max, prev_p + ramp_up)\n   - New starts: p_min to min(p_max, startup_ramp)\n4. Decommit free-on units by highest cost per MW at min output until total min \u2264 load\n5. Commit free-off units by lowest (startup_cost + min_output_cost)/min_output until total max \u2265 load\n6. Decommit non-essential free-on units with highest cost per MW at min output if removal maintains total max \u2265 load\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with bisection and quadratic/linear handling\n   d) Residual adjustment via marginal cost merit order\n8. Set non-committed units to off state and zero output\n",
          "code": "import numpy as np\n\ndef advanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Precompute min and max for all units\n    min_i = np.zeros(n_units)\n    max_i = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            min_i[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Previously offline\n            min_i[i] = unit['p_min_i']\n            max_i[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commit\n    committed_units = must_on + free_on\n    total_min = sum(min_i[i] for i in committed_units)\n    total_max = sum(max_i[i] for i in committed_units)\n    \n    # Decommit free-on if min output > load\n    if total_min > current_load:\n        free_on_committed = [i for i in committed_units if i in free_on]\n        if free_on_committed:\n            metrics = []\n            for i in free_on_committed:\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0], reverse=True)\n            for metric, i in metrics:\n                if total_min <= current_load:\n                    break\n                committed_units.remove(i)\n                total_min -= min_i[i]\n                total_max -= max_i[i]\n    \n    # Commit free-off if max output < load\n    if total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed_units]\n        if free_off_available:\n            metrics = []\n            for i in free_off_available:\n                cost = (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                        units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0])\n            for metric, i in metrics:\n                if total_max >= current_load:\n                    break\n                committed_units.append(i)\n                total_min += min_i[i]\n                total_max += max_i[i]\n    \n    # Decommit non-essential free-on\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed_units if i in free_on]\n        if free_on_committed:\n            metrics = []\n            for i in free_on_committed:\n                cost = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_i[i] + \n                        units_info[i]['c_i'] * min_i[i]**2)\n                metric_val = cost / min_i[i] if min_i[i] > 1e-5 else 1e15\n                metrics.append((metric_val, i))\n            metrics.sort(key=lambda x: x[0], reverse=True)\n            for metric, i in metrics:\n                if total_max - max_i[i] >= current_load:\n                    committed_units.remove(i)\n                    total_min -= min_i[i]\n                    total_max -= max_i[i]\n                    changed = True\n                    break\n    \n    # Initialize outputs\n    p_out = np.zeros(n_units)\n    u_out = np.zeros(n_units)\n    \n    if not committed_units:\n        return np.array([u_out, p_out])\n    \n    # Dispatch\n    if current_load <= total_min:\n        for i in committed_units:\n            p_out[i] = min_i[i]\n            u_out[i] = 1\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_out[i] = max_i[i]\n            u_out[i] = 1\n    else:\n        # Lambda iteration\n        min_vals = [min_i[i] for i in committed_units]\n        max_vals = [max_i[i] for i in committed_units]\n        b_vals = [units_info[i]['b_i'] for i in committed_units]\n        c_vals = [units_info[i]['c_i'] for i in committed_units]\n        \n        low = min(2 * c * m + b for c, m, b in zip(c_vals, min_vals, b_vals) if c > 0)\n        high = max(2 * c * M + b for c, M, b in zip(c_vals, max_vals, b_vals) if c > 0)\n        low = min(low, min(b_vals))  # Ensure linear units included\n        high = max(high, max(b_vals))\n        \n        for _ in range(100):\n            lmbda = (low + high) / 2\n            total_p = 0\n            for i, (min_val, max_val, b, c) in enumerate(zip(min_vals, max_vals, b_vals, c_vals)):\n                if c == 0:\n                    p_val = max_val if lmbda > b else min_val\n                else:\n                    p_uncon = (lmbda - b) / (2 * c)\n                    p_val = max(min_val, min(max_val, p_uncon))\n                total_p += p_val\n            if abs(total_p - current_load) < 1e-5:\n                break\n            if total_p > current_load:\n                high = lmbda\n            else:\n                low = lmbda\n        \n        # Apply lambda solution\n        p_temp = {}\n        total_after_iter = 0\n        for idx, (i, min_val, max_val, b, c) in enumerate(zip(committed_units, min_vals, max_vals, b_vals, c_vals)):\n            if c == 0:\n                p_val = max_val if lmbda > b else min_val\n            else:\n                p_uncon = (lmbda - b) / (2 * c)\n                p_val = max(min_val, min(max_val, p_uncon))\n            p_temp[i] = p_val\n            total_after_iter += p_val\n        \n        # Residual adjustment\n        residual = current_load - total_after_iter\n        iter_count = 0\n        max_iter = 1000\n        while abs(residual) > 1e-5 and iter_count < max_iter:\n            if residual > 0:\n                candidates = []\n                for i in committed_units:\n                    if p_temp[i] < max_i[i] - 1e-5:\n                        if units_info[i]['c_i'] == 0:\n                            mc = units_info[i]['b_i']\n                        else:\n                            mc = 2 * units_info[i]['c_i'] * p_temp[i] + units_info[i]['b_i']\n                        candidates.append((mc, i))\n                if not candidates:\n                    break\n                candidates.sort(key=lambda x: x[0])\n                _, i_star = candidates[0]\n                delta = min(residual, max_i[i_star] - p_temp[i_star])\n                p_temp[i_star] += delta\n                residual -= delta\n            else:\n                candidates = []\n                for i in committed_units:\n                    if p_temp[i] > min_i[i] + 1e-5:\n                        if units_info[i]['c_i'] == 0:\n                            mc = units_info[i]['b_i']\n                        else:\n                            mc = 2 * units_info[i]['c_i'] * p_temp[i] + units_info[i]['b_i']\n                        candidates.append((mc, i))\n                if not candidates:\n                    break\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                _, i_star = candidates[0]\n                delta = min(-residual, p_temp[i_star] - min_i[i])\n                p_temp[i_star] -= delta\n                residual += delta\n            iter_count += 1\n        \n        for i in committed_units:\n            p_out[i] = p_temp[i]\n            u_out[i] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0054285375,
          "gap_price_rate": 0.0091401444,
          "fitness": 0.007284341
     },
     {
          "name": "evolved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (prev online + (min up-time unfulfilled or prev output > shutdown capacity)), must-off (prev offline + min down-time unfulfilled), free-on (online but decommitable), and free-off (offline but commitable)\n2. Commit must-on + free-on units\n3. Compute effective min/max outputs considering:\n   - For prev online units: [max(p_min, prev_p - ramp_down), min(p_max, prev_p + ramp_up)]\n   - For new starts: [p_min, min(p_max, startup_ramp)]\n4. Decommittable free-on units by highest cost/MW at min output until total min \u2264 load\n5. Committable free-off units by lowest cost/MW including startup until total max \u2265 load\n6. Decommittable free-on units with highest cost/MW at min output if non-essential\n7. Dispatch committed units:\n   a) Min dispatch if load \u2264 total min\n   b) Max dispatch if load \u2265 total max\n   c) Else: lambda iteration with gradient clipping and residual adjustment\n8. Return schedules (u_i, p_i) for all units\n\n",
          "code": "import numpy as np\n\ndef evolved_rolling_commitment(units_info, load):\n    load0 = load[0]\n    n_units = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_outputs = {}\n    max_outputs = {}\n    \n    # Classify units (Step 1)\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u0 == 1:  # Previously online\n            if (t0 < t_on_min) or (p0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            min_o = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_o = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            min_outputs[i] = min_o\n            max_outputs[i] = max_o\n        else:  # Previously offline\n            if abs(t0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Initial commit (Step 2)\n    committed = set(must_on) | set(free_on)\n    total_min = sum(min_outputs[i] for i in committed)\n    total_max = sum(max_outputs[i] for i in committed)\n    \n    # Decommit high-cost free-on if over-committed (Step 4)\n    high_cost_free_on = [i for i in free_on if i in committed]\n    high_cost_free_on.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in high_cost_free_on:\n        if total_min <= load0:\n            break\n        committed.remove(i)\n        total_min -= min_outputs[i]\n        total_max -= max_outputs[i]\n    \n    # Commit low-cost free-off if under-committed (Step 5)\n    low_cost_free_off = sorted(free_off, key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'])\n    \n    for i in low_cost_free_off:\n        if total_max >= load0:\n            break\n        if i in committed:\n            continue\n        min_i = units_info[i]['p_min_i']\n        max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        min_outputs[i] = min_i\n        max_outputs[i] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Decommit non-essential high-cost free-on (Step 6)\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_committed.sort(key=lambda i: (\n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2\n    ) / units_info[i]['p_min_i'], reverse=True)\n    \n    for i in free_on_committed:\n        new_min = total_min - min_outputs[i]\n        new_max = total_max - max_outputs[i]\n        if new_min <= load0 <= new_max:\n            committed.remove(i)\n            total_min = new_min\n            total_max = new_max\n    \n    # Dispatch logic (Step 7)\n    p_alloc = [0] * n_units\n    u_alloc = [1 if i in committed else 0 for i in range(n_units)]\n    \n    if committed:\n        if load0 <= total_min:\n            for i in committed:\n                p_alloc[i] = min_outputs[i]\n        elif load0 >= total_max:\n            for i in committed:\n                p_alloc[i] = max_outputs[i]\n        else:\n            # Lambda iteration setup\n            low = 0\n            high = max(unit['b_i'] + 2 * unit['c_i'] * max_outputs[i] \n                      for i, unit in enumerate(units_info) if i in committed) * 2\n            tol = 0.01\n            iter_max = 100\n            iter_count = 0\n            \n            while iter_count < iter_max:\n                mid = (low + high) / 2.0\n                total_p = 0\n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        unconstrained = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                    else:\n                        unconstrained = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = np.clip(unconstrained, min_outputs[i], max_outputs[i])\n                    total_p += p_i\n                \n                if abs(total_p - load0) <= tol:\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] == 0:\n                            p_i = unit['p_max_i'] if mid >= unit['b_i'] else unit['p_min_i']\n                        else:\n                            p_i = (mid - unit['b_i']) / (2 * unit['c_i'])\n                        p_alloc[i] = np.clip(p_i, min_outputs[i], max_outputs[i])\n                    break\n                \n                if total_p < load0:\n                    low = mid\n                else:\n                    high = mid\n                iter_count += 1\n            \n            # Residual adjustment (if needed)\n            total_p = sum(p_alloc[i] for i in committed)\n            residual = load0 - total_p\n            if residual != 0:\n                candidates = []\n                for i in committed:\n                    if residual > 0 and p_alloc[i] < max_outputs[i]:\n                        margin = max_outputs[i] - p_alloc[i]\n                        marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                        candidates.append((i, marginal_cost, margin))\n                    elif residual < 0 and p_alloc[i] > min_outputs[i]:\n                        margin = p_alloc[i] - min_outputs[i]\n                        marginal_cost = -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i])\n                        candidates.append((i, marginal_cost, margin))\n                \n                candidates.sort(key=lambda x: x[1])\n                for i, mc, margin in candidates:\n                    adjust = min(abs(residual), margin)\n                    if residual > 0:\n                        p_alloc[i] += adjust\n                        residual -= adjust\n                    else:\n                        p_alloc[i] -= adjust\n                        residual += adjust\n                    if abs(residual) < tol:\n                        break\n    \n    # Non-committed units\n    for i in range(n_units):\n        if not u_alloc[i]:\n            p_alloc[i] = 0\n    \n    return np.array([u_alloc, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0054285387,
          "gap_price_rate": 0.0091401447,
          "fitness": 0.0072843417
     },
     {
          "name": "solve_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previously online with unfulfilled min up-time or previous output exceeding shutdown capacity), must-off (previously offline with unfulfilled min down-time), free-on (previously online but decommittable), and free-off (previously offline but committable).\n2. Commit must-on and free-on units initially.\n3. Compute effective min/max outputs: For previously online units, set min_eff = max(p_min, previous_p - ramp_down) and max_eff = min(p_max, previous_p + ramp_up). For free-off units, set min_eff = p_min and max_eff = min(p_max, startup_ramp).\n4. Decommit free-on units in descending order of operating cost per MW at their effective min output until total min_eff \u2264 current load.\n5. Commit free-off units in ascending order of (startup_cost + operating_cost) per MW at their min output until total max_eff \u2265 current load.\n6. Decommit non-essential free-on units in descending order of operating cost per MW at effective min output if removal maintains total max_eff \u2265 current load.\n7. Dispatch committed units:\n   a) Set outputs to min_eff if load \u2264 total min_eff.\n   b) Set outputs to max_eff if load \u2265 total max_eff.\n   c) For intermediate loads: use bisection (100 iterations) to find optimal lambda for economic dispatch respecting ramp constraints, then perform residual adjustment using marginal cost merit order.\n8. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef solve_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_arr = np.zeros(n_units, dtype=int)\n    p_arr = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i_0 == 1:  # was online\n            if t_i_0 < t_on_min or p_i_0 > p_shut:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:  # was offline\n            if t_i_0 < 0 and abs(t_i_0) < t_off_min:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Step 2: Initial commitment\n    committed = set(must_on) | set(free_on)\n    \n    # Step 3: Precompute effective min/max for all units\n    min_eff = np.zeros(n_units)\n    max_eff = np.zeros(n_units)\n    \n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # was online\n            min_eff[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # was offline\n            min_eff[idx] = unit['p_min_i']\n            max_eff[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit expensive free-on units if needed\n    total_min = 0.0\n    total_max = 0.0\n    for i in committed:\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    # Create list of free-on units sorted by cost-per-MW (operating cost at min_eff) descending\n    candidate_free_on = [i for i in free_on if i in committed]\n    candidate_free_on.sort(\n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2) / min_eff[i],\n        reverse=True\n    )\n    \n    for i in candidate_free_on:\n        if total_min <= current_load:\n            break\n        committed.remove(i)\n        total_min -= min_eff[i]\n        total_max -= max_eff[i]\n    \n    # Step 5: Commit cheap free-off units if needed\n    candidate_free_off = free_off[:]  # initially not committed\n    candidate_free_off.sort(\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2) / min_eff[i]\n    )\n    \n    for i in candidate_free_off:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    # Step 6: Decommit non-essential free-on units\n    remaining_free_on = [i for i in free_on if i in committed]\n    remaining_free_on.sort(\n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_eff[i] + units_info[i]['c_i'] * min_eff[i] ** 2) / min_eff[i],\n        reverse=True\n    )\n    \n    for i in remaining_free_on:\n        if total_max - max_eff[i] >= current_load:\n            committed.remove(i)\n            total_min -= min_eff[i]\n            total_max -= max_eff[i]\n    \n    # Prepare committed list and filter min/max constraints\n    committed_list = list(committed)\n    min_eff_comm = [min_eff[i] for i in committed_list]\n    max_eff_comm = [max_eff[i] for i in committed_list]\n    \n    # Step 7: Dispatch\n    n_committed = len(committed_list)\n    \n    if current_load <= total_min:  # Minimum dispatch\n        p_vals = min_eff_comm\n    elif current_load >= total_max:  # Maximum dispatch\n        p_vals = max_eff_comm\n    else:  # Lambda iteration with bisection\n        # Initialize bisection parameters\n        low = float('inf')\n        high = -float('inf')\n        a_list = []\n        b_list = []\n        c_list = []\n        \n        for i in committed_list:\n            a_i = units_info[i]['a_i']\n            b_i = units_info[i]['b_i']\n            c_i = units_info[i]['c_i']\n            a_list.append(a_i)\n            b_list.append(b_i)\n            c_list.append(c_i)\n            \n            mc_low = 2 * c_i * min_eff[i] + b_i\n            mc_high = 2 * c_i * max_eff[i] + b_i\n            low = min(low, mc_low)\n            high = max(high, mc_high)\n        \n        # Bisection iterations\n        n_iter = 100\n        p_vals = np.zeros(n_committed)\n        \n        for _ in range(n_iter):\n            lam = (low + high) / 2\n            total_p = 0.0\n            \n            for j in range(n_committed):\n                idx = committed_list[j]\n                c_val = c_list[j]\n                b_val = b_list[j]\n                min_e = min_eff_comm[j]\n                max_e = max_eff_comm[j]\n                \n                if c_val == 0:  # Handle linear cost\n                    p_val = max_e if lam > b_val else min_e\n                else:\n                    p_val = (lam - b_val) / (2 * c_val)\n                    p_val = max(min_e, min(max_e, p_val))\n                \n                p_vals[j] = p_val\n                total_p += p_val\n            \n            if abs(total_p - current_load) < 1e-4:\n                break\n            elif total_p < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Residual adjustment\n        residual = current_load - total_p\n        if abs(residual) > 1e-4:\n            mc_vals = []\n            for j in range(n_committed):\n                idx = committed_list[j]\n                p_val = p_vals[j]\n                c_val = c_list[j]\n                b_val = b_list[j]\n                mc = 2 * c_val * p_val + b_val\n                mc_vals.append(mc)\n            \n            mc_vals = np.array(mc_vals)\n            if residual > 0:  # Under-generation\n                idx_sorted = np.argsort(mc_vals)\n                for i in idx_sorted:\n                    add = min(residual, max_eff_comm[i] - p_vals[i])\n                    p_vals[i] += add\n                    residual -= add\n                    if residual <= 1e-10:\n                        break\n            else:  # Over-generation\n                residual = abs(residual)\n                idx_sorted = np.argsort(-mc_vals)\n                for i in idx_sorted:\n                    sub = min(residual, p_vals[i] - min_eff_comm[i])\n                    p_vals[i] -= sub\n                    residual -= sub\n                    if residual <= 1e-10:\n                        break\n    \n    # Step 7a & 7b: Assign dispatch values\n    for j, i in enumerate(committed_list):\n        p_arr[i] = p_vals[j]\n        u_arr[i] = 1\n    \n    # Step 8: Set non-committed units to offline\n    for i in range(n_units):\n        if i not in committed:\n            p_arr[i] = 0\n            u_arr[i] = 0\n    \n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.005428548,
          "gap_price_rate": 0.0091401438,
          "fitness": 0.0072843459
     },
     {
          "name": "refined_evolved_rolling_commitment",
          "algorithm": "1. Classify units into must-on (previous online with unfulfilled min up-time or shutdown constraint), must-off (previous offline with unfulfilled min down-time), free-on (online and decommitable), free-off (offline and commitable).\n2. Commit must-on and free-on units as initial set.\n3. Compute effective min/max outputs considering ramp constraints: max ramp-down/min ramp-up for online units, startup ramp limits for new commitments.\n4. Decommit free-on units by highest cost/MW at effective min until total min output \u2264 current load.\n5. Commit free-off units by lowest cost/MW at min output (including startup costs) until total max output \u2265 current load.\n6. Decommit remaining free-on units if non-essential (removal maintains total max \u2265 load) using the same cost/MW metric.\n7. Dispatch committed units:\n   a) Set outputs to min if load \u2264 total min\n   b) Set outputs to max if load \u2265 total max\n   c) Use bisection to find optimal lambda for economic dispatch\n   d) Adjust residual with priority order if needed\n8. Set non-committed units to off state and zero output.\n\n",
          "code": "import numpy as np\n\ndef refined_evolved_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    categories = []\n    current_load = load[0]\n    \n    # Step 1: Classify units and set initial commitment\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_up_min = unit['t_on_min_i']\n        t_down_min = unit['t_off_min_i']\n        \n        if u0 == 1:  # Previously online\n            if t0 < t_up_min or p0 > p_shut:\n                categories.append('must-on')\n                u[i] = 1\n            else:\n                categories.append('free-on')\n                u[i] = 1\n        else:  # Previously offline\n            if abs(t0) < t_down_min:\n                categories.append('must-off')\n                u[i] = 0\n            else:\n                categories.append('free-off')\n                u[i] = 0\n                \n    # Step 2 & 3: Compute effective min/max for committed units\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:  # Continuation online\n                eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                eff_min[i] = unit['p_min_i']\n                eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = np.sum(eff_min[u == 1])\n    total_max = np.sum(eff_max[u == 1])\n    \n    # Step 4: Decommit free-on units if over-committed\n    free_on_idx = [i for i, cat in enumerate(categories) if cat == 'free-on' and u[i] == 1]\n    cost_per_mw = []\n    for i in free_on_idx:\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        cost_per_mw.append((a + b * eff_min[i] + c * eff_min[i]**2) / eff_min[i])\n    sorted_free_on = [i for _, i in sorted(zip(cost_per_mw, free_on_idx), reverse=True)]\n    \n    for i in sorted_free_on:\n        if total_min <= current_load:\n            break\n        u[i] = 0\n        total_min -= eff_min[i]\n        total_max -= eff_max[i]\n        eff_min[i] = eff_max[i] = 0\n    \n    # Step 5: Commit free-off units if under-committed\n    if total_max < current_load:\n        free_off_idx = [i for i, cat in enumerate(categories) if cat == 'free-off' and u[i] == 0]\n        cost_per_mw = []\n        for i in free_off_idx:\n            a, b, c, s = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i']\n            min_cost = a + b * units_info[i]['p_min_i'] + c * units_info[i]['p_min_i']**2 + s\n            cost_per_mw.append(min_cost / units_info[i]['p_min_i'])\n        sorted_free_off = [i for _, i in sorted(zip(cost_per_mw, free_off_idx))]\n        \n        for i in sorted_free_off:\n            u[i] = 1\n            eff_min_i = units_info[i]['p_min_i']\n            eff_max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            eff_min[i], eff_max[i] = eff_min_i, eff_max_i\n            total_min += eff_min_i\n            total_max += eff_max_i\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit non-essential free-on units\n    free_on_idx = [i for i, cat in enumerate(categories) if cat == 'free-on' and u[i] == 1]\n    cost_per_mw = []\n    for i in free_on_idx:\n        a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n        cost_per_mw.append((a + b * eff_min[i] + c * eff_min[i]**2) / eff_min[i])\n    sorted_free_on = [i for _, i in sorted(zip(cost_per_mw, free_on_idx), reverse=True)]\n    \n    for i in sorted_free_on:\n        if total_max - eff_max[i] >= current_load:\n            u[i] = 0\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            eff_min[i] = eff_max[i] = 0\n    \n    # Step 7: Dispatch committed units\n    committed_indices = np.where(u == 1)[0]\n    if len(committed_indices) > 0:\n        current_min = np.sum(eff_min[committed_indices])\n        current_max = np.sum(eff_max[committed_indices])\n        \n        if current_load <= current_min:\n            for i in committed_indices:\n                p[i] = eff_min[i]\n        elif current_load >= current_max:\n            for i in committed_indices:\n                p[i] = eff_max[i]\n        else:\n            # Bisection for lambda\n            low = 0\n            high = 0\n            for i in committed_indices:\n                unit = units_info[i]\n                marginal_low = 2 * unit['c_i'] * eff_min[i] + unit['b_i']\n                marginal_high = 2 * unit['c_i'] * eff_max[i] + unit['b_i']\n                low = min(low, marginal_low) if low != 0 else marginal_low\n                high = max(high, marginal_high) if high != 0 else marginal_high\n            \n            n_iter = 100\n            total_p = 0\n            temp_p = {}\n            for _ in range(n_iter):\n                lam = (low + high) / 2\n                total_p = 0\n                for i in committed_indices:\n                    unit = units_info[i]\n                    p_i = max(eff_min[i], min(eff_max[i], (lam - unit['b_i']) / (2 * unit['c_i'])))\n                    temp_p[i] = p_i\n                    total_p += p_i\n                if abs(total_p - current_load) < 1e-3:\n                    break\n                if total_p > current_load:\n                    high = lam\n                else:\n                    low = lam\n            # Set temp_p values to p\n            for i, val in temp_p.items():\n                p[i] = val\n            residual = current_load - total_p\n            if abs(residual) > 1e-2:\n                if residual > 0:\n                    candidates = []\n                    for i in committed_indices:\n                        if p[i] < eff_max[i]:\n                            marginal_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                            headroom = eff_max[i] - p[i]\n                            candidates.append((marginal_cost, headroom, i))\n                    candidates.sort(key=lambda x: x[0])\n                    for mc, hr, idx in candidates:\n                        if residual <= 0:\n                            break\n                        allocation = min(hr, residual)\n                        p[idx] += allocation\n                        residual -= allocation\n                else:\n                    candidates = []\n                    for i in committed_indices:\n                        if p[i] > eff_min[i]:\n                            marginal_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                            headroom = p[i] - eff_min[i]\n                            candidates.append((marginal_cost, headroom, i))\n                    candidates.sort(key=lambda x: x[0], reverse=True)\n                    for mc, hr, idx in candidates:\n                        if residual >= 0:\n                            break\n                        allocation = min(hr, -residual)\n                        p[idx] -= allocation\n                        residual += allocation\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.005428635,
          "gap_price_rate": 0.0091401619,
          "fitness": 0.0072843984
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-run (min up-time/shotdown ramp constraints), must-off (min down-time), free-on (online freely decommitable), and free-off (offline freely commitable)\n2. Commit must-run and free-on units\n3. Compute effective min/max outputs considering ramp constraints (ramp limits, startup/shutdown ramp limits)\n4. If total min output exceeds load:\n   - Decommit free-on units with largest min outputs until feasibility is restored\n5. If total max output is below load:\n   - Commit free-off units with lowest cost per MW at min output until capacity suffices\n6. Decommit unnecessary free-on units with highest operating cost at min output if feasible\n7. Dispatch committed units:\n   - If load <= total min: set to min outputs\n   - If load >= total max: set to max outputs\n   - Else: perform lambda iteration economic dispatch with clamped gradients\n   - Apply final adjustments to balance residual load\n8. Return schedules (u_i, p_i) for all units\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Initialize classification lists\n    must_on = []\n    free_on = []\n    free_off = []\n    min_eff = [0.0] * n_units\n    max_eff = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                continue  # must_off handled by omission\n            else:\n                free_off.append(i)\n    \n    # Initialize committed set\n    committed = set(must_on)\n    committed.update(free_on)\n    \n    # Step 2 & 3: Compute effective min/max outputs\n    for i, unit in enumerate(units_info):\n        if i in committed and unit['u_i_0'] == 1:\n            min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_off:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_eff[i] = 0.0\n            max_eff[i] = 0.0\n    \n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Step 4: Decommit free-on units if overcommitted\n    if total_min > current_load:\n        sorted_free_on = sorted(\n            [i for i in free_on if i in committed],\n            key=lambda i: min_eff[i],\n            reverse=True\n        )\n        for i in sorted_free_on:\n            cand_min = total_min - min_eff[i]\n            cand_max = total_max - max_eff[i]\n            if cand_min <= current_load <= cand_max:\n                committed.remove(i)\n                total_min = cand_min\n                total_max = cand_max\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Commit free-off units if undercommitted\n    if total_max < current_load:\n        def cost_priority(i):\n            unit = units_info[i]\n            startup = unit['s_i']\n            prod_cost = unit['a_i'] + unit['b_i']*min_eff[i] + unit['c_i']*min_eff[i]**2\n            return (startup + prod_cost) / (min_eff[i] + 1e-9)\n        \n        sorted_free_off = sorted(\n            [i for i in free_off if i not in committed],\n            key=cost_priority\n        )\n        for i in sorted_free_off:\n            cand_min = total_min + min_eff[i]\n            cand_max = total_max + max_eff[i]\n            committed.add(i)\n            total_min = cand_min\n            total_max = cand_max\n            if total_max >= current_load:\n                break\n    \n    # Step 6: Decommit unnecessary free-on units by cost\n    def operating_cost(i):\n        unit = units_info[i]\n        return unit['a_i'] + unit['b_i']*min_eff[i] + unit['c_i']*min_eff[i]**2\n    \n    expensive_free_on = sorted(\n        [i for i in free_on if i in committed],\n        key=operating_cost,\n        reverse=True\n    )\n    for i in expensive_free_on:\n        cand_min = total_min - min_eff[i]\n        cand_max = total_max - max_eff[i]\n        if cand_min <= current_load <= cand_max:\n            committed.remove(i)\n            total_min = cand_min\n            total_max = cand_max\n    \n    # Recompute final constraints\n    for i in committed:\n        if units_info[i]['u_i_0'] == 1:\n            min_eff[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:  # Started this period\n            min_eff[i] = units_info[i]['p_min_i']\n            max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(min_eff[i] for i in committed)\n    total_max = sum(max_eff[i] for i in committed)\n    \n    # Step 7: Dispatch\n    if current_load <= total_min:\n        for i in committed:\n            p[i] = min_eff[i]\n            u[i] = 1\n    elif current_load >= total_max:\n        for i in committed:\n            p[i] = max_eff[i]\n            u[i] = 1\n    else:  # Lambda iteration with clamping\n        # Initialize lambda bounds\n        low = float('inf')\n        high = -float('inf')\n        for i in committed:\n            unit = units_info[i]\n            low = min(low, unit['b_i'] + 2*unit['c_i']*min_eff[i])\n            high = max(high, unit['b_i'] + 2*unit['c_i']*max_eff[i])\n        \n        tol = 1e-3\n        max_iter = 1000\n        for _ in range(max_iter):\n            lambda_mid = (low + high) / 2.0\n            total_power = 0.0\n            for i in committed:\n                unit = units_info[i]\n                c_val = unit['c_i']\n                b_val = unit['b_i']\n                if c_val == 0:\n                    p_i = max_eff[i] if lambda_mid > b_val else min_eff[i]\n                else:\n                    p_i = (lambda_mid - b_val) / (2 * c_val)\n                    p_i = max(min_eff[i], min(max_eff[i], p_i))\n                p[i] = p_i\n                total_power += p_i\n            \n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                low = lambda_mid\n            else:\n                high = lambda_mid\n        \n        # Residual adjustment\n        total_power = sum(p[i] for i in committed)\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            adjustments = []\n            for i in committed:\n                if residual > 0 and p[i] < max_eff[i]:\n                    headroom = max_eff[i] - p[i]\n                    marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    adjustments.append((marginal, i, headroom))\n                elif residual < 0 and p[i] > min_eff[i]:\n                    headroom = p[i] - min_eff[i]\n                    marginal = units_info[i]['b_i'] + 2*units_info[i]['c_i']*p[i]\n                    adjustments.append((marginal, i, headroom))\n            \n            if residual > 0:\n                adjustments.sort(key=lambda x: x[0])\n            else:\n                adjustments.sort(key=lambda x: x[0], reverse=True)\n            \n            for _, i, headroom in adjustments:\n                delta = min(headroom, abs(residual)) * np.sign(residual)\n                p[i] += delta\n                residual -= delta\n                if abs(residual) < tol:\n                    break\n        for i in committed:\n            u[i] = 1\n    \n    # Set non-committed units\n    for i in range(n_units):\n        if i not in committed:\n            u[i] = 0\n            p[i] = 0.0\n    \n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u\n    schedules[1, :] = p\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054286362,
          "gap_price_rate": 0.0091472287,
          "fitness": 0.0072879324
     }
]