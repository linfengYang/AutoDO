[
     {
          "name": "rolling_commit_dispatch",
          "algorithm": "1. Classify units into must-run (violating min-up/shutdown ramp), must-off (violating min-down), and flexible categories\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible maintain previous state\n3. Compute maximum deliverable power considering ramp limits and startup constraints\n4. If insufficient capacity, turn on flexible units sorted by average cost at minimum output\n5. If over-committed, turn off highest average-cost flexible units while maintaining sufficient capacity\n6. Dispatch load using greedy incremental cost optimization:\n   a) Set each committed unit to its feasible minimum output\n   b) Incrementally increase output of cheapest units first until meeting demand\n   c) Respect individual unit ramp and output constraints\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units and set initial commitment\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Initial commitment states\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate current available capacity\n    max_cap = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # Newly started\n                max_cap[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                max_cap[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_max = np.sum(max_cap)\n    \n    # Add units if capacity insufficient\n    candidates = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 0:  # Flexible and currently off\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2 + unit['s_i']) / p_min\n            cap = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, cost, cap))\n    \n    candidates.sort(key=lambda x: x[1])\n    for idx, cost, cap in candidates:\n        if total_max < current_load:\n            u[idx] = 1\n            total_max += cap\n        else:\n            break\n    \n    # Remove expensive units if over-committed\n    candidates_off = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 1:  # Flexible and online\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            \n            if unit['u_i_0'] == 0:  # Newly started\n                cap = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            candidates_off.append((i, cost, cap))\n    \n    candidates_off.sort(key=lambda x: x[1], reverse=True)\n    for idx, cost, cap in candidates_off:\n        if total_max - cap >= current_load:\n            u[idx] = 0\n            total_max -= cap\n    \n    # Economic dispatch\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    p_dispatch = np.zeros(n_units)\n    allocated = 0.0\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # New start\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_dispatch[i] = min_bound[i]\n            allocated += min_bound[i]\n    \n    remaining = current_load - allocated\n    if remaining < 0:\n        return np.vstack((u, p_dispatch))\n    \n    # Distribute remaining load\n    while remaining > 0:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and p_dispatch[i] < max_bound[i]:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_dispatch[i]\n                headroom = max_bound[i] - p_dispatch[i]\n                candidates.append((i, inc_cost, headroom))\n        \n        if not candidates:\n            break\n            \n        candidates.sort(key=lambda x: x[1])\n        i, inc_cost, headroom = candidates[0]\n        amount = min(remaining, headroom)\n        p_dispatch[i] += amount\n        allocated += amount\n        remaining -= amount\n    \n    return np.vstack((u, p_dispatch))",
          "from": "mutation",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "enhanced_refined_commit_dispatch",
          "algorithm": "1. Classify units as must-run (if online and (min-up time unfulfilled or previous output exceeds shutdown capacity)), must-off (if offline and min-down time unfulfilled), or flexible (others)\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible units retain previous state\n3. Compute feasible output ranges (considering ramp and startup constraints) and total min/max capacity\n4. If current load > total max capacity:\n    a. Calculate activation priority as (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n    b. Activate offline flexible units in ascending priority order until sufficient capacity\n5. If total min capacity > current load:\n    a. Calculate deactivation priority as (a_i + b_i*min_i + c_i*min_i\u00b2) / min_i\n    b. Deactivate online flexible units in descending priority order while maintaining load coverage\n6. Dispatch load via incremental cost optimization:\n    a. Set committed units to min feasible output\n    b. Allocate remaining load by ascending incremental cost within unit constraints\n7. Return commitment states and power outputs as 2D array\n",
          "code": "import numpy as np\n\ndef enhanced_refined_commit_dispatch(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    load_current = load[0]\n    \n    # Step 1: Classify units and initialize commitment\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:  # previously online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:  # previously offline\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n    for unit in flexible:\n        unit['u_i'] = unit['u_i_0']\n    \n    # Reset dispatch parameters\n    for unit in units:\n        unit['min_i'] = 0.0\n        unit['max_i'] = 0.0\n        unit['dispatch'] = 0.0\n    \n    # Compute feasible ranges for committed units\n    committed_units = [u for u in units if u['u_i'] == 1]\n    total_min, total_max = 0.0, 0.0\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:  # Continuously online\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started in current period\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Activation for insufficient capacity\n    offline_flex = [u for u in flexible if u['u_i'] == 0]\n    activation_candidates = []\n    for unit in offline_flex:\n        p_min = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2\n        avg_cost = total_cost / p_min\n        activation_candidates.append((avg_cost, unit))\n    \n    activation_candidates.sort(key=lambda x: x[0])\n    for _, unit in activation_candidates:\n        if total_max >= load_current:\n            break\n        unit['u_i'] = 1\n        min_i = unit['p_min_i']\n        max_i = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        total_min += min_i\n        total_max += max_i\n        committed_units.append(unit)\n    \n    # Deactivation for over-commitment\n    online_flex = [u for u in committed_units if u in flexible]\n    deactivation_candidates = []\n    for unit in online_flex:\n        min_i = unit['min_i']\n        base_cost = unit['a_i'] + unit['b_i']*min_i + unit['c_i']*min_i**2\n        avg_cost = base_cost / min_i\n        deactivation_candidates.append((avg_cost, unit))\n    \n    deactivation_candidates.sort(key=lambda x: x[0], reverse=True)\n    for _, unit in deactivation_candidates:\n        new_min = total_min - unit['min_i']\n        new_max = total_max - unit['max_i']\n        if new_max < load_current:\n            continue\n        if new_min >= load_current:\n            continue  # Over-commitment remains\n        unit['u_i'] = 0\n        unit['min_i'] = 0.0\n        unit['max_i'] = 0.0\n        total_min = new_min\n        total_max = new_max\n        committed_units.remove(unit)\n    \n    # Dispatch among committed units\n    for unit in committed_units:\n        unit['dispatch'] = unit['min_i']\n    current_total = total_min\n    remaining = load_current - current_total\n    \n    available_units = [u for u in committed_units if u['dispatch'] < u['max_i'] - 1e-5]\n    while remaining > 1e-5 and available_units:\n        inc_costs = []\n        for unit in available_units:\n            inc = unit['b_i'] + 2 * unit['c_i'] * unit['dispatch']\n            inc_costs.append((inc, unit))\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_unit = inc_costs[0][1]\n        max_addition = cheapest_unit['max_i'] - cheapest_unit['dispatch']\n        allocation = min(remaining, max_addition)\n        cheapest_unit['dispatch'] += allocation\n        remaining -= allocation\n        if cheapest_unit['dispatch'] >= cheapest_unit['max_i'] - 1e-5:\n            available_units.remove(cheapest_unit)\n    \n    # Set outputs for uncommitted units\n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['dispatch'] = 0.0\n    \n    u_vector = [unit['u_i'] for unit in units]\n    p_vector = [unit['dispatch'] for unit in units]\n    schedules = np.array([u_vector, p_vector], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0060521947,
          "gap_price_rate": 0.0089602466,
          "fitness": 0.0075062207
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "improved_rolling_commit",
          "algorithm": "1. Classify units as must-run, must-off, or flexible based on min up/down times and shutdown constraints.\n2. Compute feasible output ranges for online units considering ramp constraints.\n3. If current load exceeds online capacity, activate offline units in cost-merit order with next-period penalty handling.\n4. If minimum output exceeds load, handle over-generation by setting to minimum outputs.\n5. Dispatch load among online units using merit-order by incremental cost within feasible ranges.\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commit(units_info, load):\n    # Step 0: Parse inputs\n    current_load = load[0]\n    forecast_next = load[1]\n    \n    # Convert units_info to list of dicts for mutability\n    units = [dict(unit) for unit in units_info]\n    n_units = len(units)\n    \n    # Initialize schedules\n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible_online = []  # Currently online\n    flexible_offline = []  # Currently offline\n    \n    for i, unit in enumerate(units):\n        # Compute absolute down time\n        abs_down_time = -unit['t_i_0'] if unit['t_i_0'] < 0 else 0\n        \n        if unit['u_i_0'] == 1:\n            must_run_condition = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n            if must_run_condition:\n                must_run.append(i)\n            else:\n                flexible_online.append(i)\n        else:\n            must_off_condition = (abs_down_time < unit['t_off_min_i'])\n            if must_off_condition:\n                must_off.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Step 2: Compute feasible output ranges for already online units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    total_min, total_max = 0.0, 0.0\n    \n    # Process must-run and flexible_online\n    for i in must_run + flexible_online:\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_output[i] = min_p\n        max_output[i] = max_p\n        total_min += min_p\n        total_max += max_p\n    \n    # Track activated units\n    activated_offline = []\n    \n    # Step 3: Check generation capacity\n    if total_max < current_load:\n        # Need to activate offline units\n        deficit = current_load - total_max\n        # Precompute next period must-run minimum\n        next_period_must_run_min = 0\n        for i in must_run + flexible_online:\n            unit = units[i]\n            if (unit['t_i_0'] + 1) < unit['t_on_min_i']:\n                next_period_must_run_min += unit['p_min_i']\n        \n        # Calculate activation priority metric (amortized cost)\n        candidates_safe = []\n        candidates_penalized = []\n        \n        for i in flexible_offline:\n            unit = units[i]\n            # Metric: Amortized cost per MW over minimum up time\n            min_up = max(1, unit['t_on_min_i'])\n            cost_min_output = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            amortized_cost = (unit['s_i'] + cost_min_output * min_up) / (unit['p_min_i'] * min_up)\n            \n            max_gen = min(unit['p_max_i'], unit['p_start_i'])\n            next_add = unit['p_min_i'] if unit['t_on_min_i'] > 1 else 0\n            \n            candidate = (amortized_cost, i, max_gen, next_add)\n            if (next_period_must_run_min + next_add) <= forecast_next:\n                candidates_safe.append(candidate)\n            else:\n                candidates_penalized.append(candidate)\n        \n        # Sort candidates\n        candidates_safe.sort(key=lambda x: x[0])\n        candidates_penalized.sort(key=lambda x: x[0])\n        candidates = candidates_safe + candidates_penalized\n        \n        # Activate units until deficit is covered\n        for cost, idx, max_gen, next_add in candidates:\n            if deficit <= 0:\n                break\n            activated_offline.append(idx)\n            min_output[idx] = units[idx]['p_min_i']\n            max_output[idx] = min(units[idx]['p_max_i'], units[idx]['p_start_i'])\n            total_min += min_output[idx]\n            total_max += max_output[idx]\n            deficit -= max_gen\n            # Update next period must-run min for subsequent candidates\n            next_period_must_run_min += next_add\n    \n    # Identify online units\n    online_units = must_run + flexible_online + activated_offline\n    # If over-generation (current_load < total_min), still proceed to dispatch\n    # Step 5: Economic dispatch\n    # Initialize dispatch at minimum output\n    for i in online_units:\n        u_schedule[i] = 1\n        p_schedule[i] = min_output[i]\n        units[i]['current_p'] = min_output[i]  # Track for increment\n    \n    remaining_load = current_load - total_min\n    \n    # Only dispatch if positive load to distribute\n    if remaining_load > 0:\n        # Priority list: incremental cost at current assignment\n        priority_list = []\n        for i in online_units:\n            if max_output[i] > min_output[i]:\n                # Derivative of cost: 2*c_i*p_i + b_i\n                incremental_cost = 2 * units[i]['c_i'] * units[i]['current_p'] + units[i]['b_i']\n                priority_list.append((incremental_cost, i))\n        \n        priority_list.sort(key=lambda x: x[0])\n        \n        # Distribute remaining load\n        for _, i in priority_list:\n            if remaining_load <= 0:\n                break\n            capacity_available = max_output[i] - units[i]['current_p']\n            allocate = min(remaining_load, capacity_available)\n            p_schedule[i] += allocate\n            units[i]['current_p'] += allocate\n            remaining_load -= allocate\n    \n    # Step 4 & 6: If under total_min (over-generation) or after dispatch\n    # If load < total_min, units already set to min_output\n    \n    # Format output\n    schedules = np.array([\n        u_schedule,\n        p_schedule\n    ], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Identify must-run units (online units that haven't met min-up time or have power exceeding shutdown limit) and must-off units (offline units that haven't met min-down time)  \n2. Initialize commitment: must-run to on, must-off to off, flexible units keep previous state  \n3. Calculate total min/max power considering ramp constraints (startup/shutdown ramp limits for state changes)  \n4. While total max power < current load:  \n   - Turn on flexible offline units with lowest average cost at min output (including startup cost)  \n   - Recalculate total min/max power with new commitment  \n5. While total min power > current load:  \n   - Turn off flexible online units with highest production cost at min output if previous output \u2264 ramp-down limit  \n   - Recalculate total min/max power  \n6. Set offline units' output to 0  \n7. For online units:  \n   - If load \u2264 total min power, set all to min output  \n   - If load \u2265 total max power, set all to max output  \n   - Else perform ramp-constrained economic dispatch by incremental cost ordering  \n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    load_current = load[0]\n    \n    # Extract units info\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    min_uptime = [unit['t_on_min_i'] for unit in units_info]\n    min_downtime = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n\n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_state[i] < min_uptime[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n        else:\n            if abs(t_state[i]) < min_downtime[i]:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = u_prev[i]\n    \n    # Calculate current min and max outputs considering ramp constraints\n    min_cap = np.zeros(n_units)\n    max_cap = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if u_prev[i] == 1:\n                min_cap[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_cap[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_cap[i] = p_min[i]\n                max_cap[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(min_cap)\n    total_max = np.sum(max_cap)\n    \n    # Add units if under-committed\n    if total_max < load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 0]\n        avg_costs = []\n        for i in candidates:\n            cost = s[i] + a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            avg_costs.append((cost / p_min[i], i))\n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, idx in avg_costs:\n            if total_max >= load_current:\n                break\n            u[idx] = 1\n            min_cap[idx] = p_min[idx]\n            max_cap[idx] = min(p_max[idx], p_start[idx])\n            total_min += min_cap[idx]\n            total_max += max_cap[idx]\n    \n    # Remove units if over-committed\n    if total_min > load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 1 \n                     and p_prev[i] <= p_down[i]]\n        prod_costs = []\n        for i in candidates:\n            cost = a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            prod_costs.append((cost / p_min[i], i))\n        prod_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, idx in prod_costs:\n            if total_min <= load_current:\n                break\n            u[idx] = 0\n            total_min -= min_cap[idx]\n            total_max -= max_cap[idx]\n            min_cap[idx] = max_cap[idx] = 0\n    \n    # Set outputs\n    committed = [i for i in range(n_units) if u[i] == 1]\n    if not committed:\n        return np.array([u, p_output])\n    \n    total_min = sum(min_cap[i] for i in committed)\n    total_max = sum(max_cap[i] for i in committed)\n    \n    # Case 1: Load below total min capacity\n    if load_current <= total_min:\n        for i in committed:\n            p_output[i] = min_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 2: Load above total max capacity\n    if load_current >= total_max:\n        for i in committed:\n            p_output[i] = max_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 3: Economic dispatch\n    current_load = np.zeros(len(committed))\n    min_arr = [min_cap[i] for i in committed]\n    max_arr = [max_cap[i] for i in committed]\n    b_arr = [b[i] for i in committed]\n    c_arr = [c[i] for i in committed]\n    idx_to_global = {local: global_idx for local, global_idx in enumerate(committed)}\n    \n    # Initialize at min capacity\n    for local, i in enumerate(committed):\n        current_load[local] = min_cap[i]\n    remaining = load_current - total_min\n    \n    # Dispatch by incremental cost\n    while remaining > 0:\n        inc_costs = []\n        for local in range(len(committed)):\n            if current_load[local] < max_arr[local]:\n                inc_cost = b_arr[local] + 2 * c_arr[local] * current_load[local]\n                inc_costs.append((inc_cost, local))\n        \n        if not inc_costs:\n            break\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_idx = inc_costs[0][1]\n        \n        max_increase = max_arr[cheapest_idx] - current_load[cheapest_idx]\n        increase = min(remaining, max_increase)\n        current_load[cheapest_idx] += increase\n        remaining -= increase\n    \n    # Map dispatch to original units\n    for local, global_idx in idx_to_global.items():\n        p_output[global_idx] = current_load[local]\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Classify units into must-run (units forced online by min uptime/shutdown ramp), must-off (units forced offline by min downtime), and flexible units\n2. For committed units, compute feasible generation ranges using ramp constraints and min/max limits\n3. If undercommitted, activate additional flexible units by ascending average cost per MW at max output \n4. If overcommitted, deactivate expensive flexible units by descending average cost per MW at min output\n5. Perform constrained economic dispatch: \n   a) Set initial outputs at minimum feasible levels\n   b) Allocate remaining load by ascending incremental cost within ramp/output constraints\n6. Return schedule as 2D array with commitment states and dispatch levels\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    \n    # Extract unit attributes\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n\n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flex_on = []  # Flexible and currently online\n    flex_off = []  # Flexible and currently offline\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Previously online\n            if t_prev[i] < t_on_min[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n            else:\n                flex_on.append(i)\n        else:  # Previously offline\n            if -t_prev[i] < t_off_min[i]:\n                must_off.append(i)\n            else:\n                flex_off.append(i)\n\n    # Initially commit must-run and flexible online units\n    committed = set(must_run + flex_on)\n\n    # Step 2: Compute feasible output ranges\n    min_feasible = [0] * n_units\n    max_feasible = [0] * n_units\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Online in previous period\n            min_feasible[i] = max(p_min[i], p_prev[i] - p_down[i])\n            max_feasible[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:  # Offline in previous period\n            min_feasible[i] = p_min[i]\n            max_feasible[i] = min(p_max[i], p_start[i])\n\n    # Step 3: Under-commitment handling\n    total_min = sum(min_feasible[i] for i in committed)\n    total_max = sum(max_feasible[i] for i in committed)\n    \n    if total_max < current_load:\n        # Calculate average cost per MW at max output\n        avg_costs = []\n        for i in flex_off:\n            total_cost = s[i] + a[i] + b[i] * p_max[i] + c[i] * (p_max[i] ** 2)\n            avg_cost = total_cost / p_max[i]\n            avg_costs.append((i, avg_cost))\n        \n        # Sort flexible offline units by cost ascending\n        avg_costs.sort(key=lambda x: x[1])\n        \n        # Activate units until meeting load\n        for i, _ in avg_costs:\n            if total_max >= current_load:\n                break\n            committed.add(i)\n            flex_off.remove(i)\n            total_min += min_feasible[i]\n            total_max += max_feasible[i]\n\n    # Step 4: Over-commitment handling\n    if total_min > current_load:\n        # Calculate average cost per MW at min output\n        avg_costs = []\n        for i in flex_on:\n            total_cost = a[i] + b[i] * p_min[i] + c[i] * (p_min[i] ** 2)\n            avg_cost = total_cost / p_min[i]\n            avg_costs.append((i, avg_cost))\n        \n        # Sort flexible online units by cost descending\n        avg_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        # Deactivate expensive units\n        for i, _ in avg_costs:\n            new_min = total_min - min_feasible[i]\n            new_max = total_max - max_feasible[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed.remove(i)\n                flex_on.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= current_load:\n                    break\n\n    # Step 5a: Initialize dispatch at minimum feasible levels\n    p_dispatch = {}\n    remaining_load = current_load\n    for i in committed:\n        p_dispatch[i] = min_feasible[i]\n        remaining_load -= min_feasible[i]\n    \n    # Step 5b: Allocate remaining load by incremental cost\n    while remaining_load > 0:\n        candidates = []\n        for i in committed:\n            if p_dispatch[i] < max_feasible[i]:\n                inc_cost = 2 * c[i] * p_dispatch[i] + b[i]\n                candidates.append((i, inc_cost))\n        \n        if not candidates:\n            break\n            \n        # Find unit with smallest incremental cost\n        i, _ = min(candidates, key=lambda x: x[1])\n        \n        # Increase output within limits\n        max_increase = max_feasible[i] - p_dispatch[i]\n        increase = min(remaining_load, max_increase)\n        p_dispatch[i] += increase\n        remaining_load -= increase\n\n    # Step 6: Build output schedule\n    for i in range(n_units):\n        if i in committed:\n            u_out[i] = 1\n            p_out[i] = p_dispatch.get(i, 0)\n        else:\n            u_out[i] = 0\n            p_out[i] = 0\n\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0355884996,
          "fitness": 0.0178300959
     },
     {
          "name": "refined_commit_dispatch_amortized",
          "algorithm": "1. Classify units into:\n   - Must-run: Online units not meeting min-up time or shutdown ramp constraints\n   - Must-off: Offline units not meeting min-down time constraints\n   - Flexible: Units not bound by operational constraints\n2. Initialize commitments:\n   - Must-run: Commit (u_i=1)\n   - Must-off: Decommit (u_i=0)\n   - Flexible: Maintain previous state (u_i_0)\n3. Calculate feasible generation ranges considering:\n   - Min/max generation limits\n   - Startup ramp limits for newly activated units\n   - Standard ramp limits for continuously online units\n4. If under-committed (total max capacity < load):\n   - Activate offline flexible units by ascending amortized average cost:\n     (a_i + b_i*p_max_i + c_i*p_max_i\u00b2)/p_max_i + s_i/(t_on_min_i * p_max_i)\n   - Update capacity after each activation\n5. If over-committed (total min capacity > load):\n   - Deactivate online flexible units by descending average cost at min output:\n     (a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i\n   - Ensure sufficient max capacity remains after each deactivation\n6. Perform constrained economic dispatch for committed units:\n   a) Initialize outputs to feasible minimums\n   b) Distribute remaining load using bisection method:\n      - Set lambda bounds based on incremental costs\n      - Compute outputs at midpoint lambda\n      - Adjust bounds until load is matched\n      - Apply headroom constraints during bisection\n7. Set decommitted units to offline state (u_i=0, p_i=0)\n8. Return schedule as commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef refined_commit_dispatch_amortized(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    # Initialize commitment and output arrays\n    u_commit = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units, dtype=float)\n    \n    must_run = []\n    must_off = []\n    flexible = []\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        \n        if u_i_0 == 1:  # Previously online\n            if t_i_0 < t_on_min_i - 1 or p_i_0 > p_shut_i:\n                must_run.append(i)\n            else:\n                flexible.append(i)\n        else:  # Previously offline\n            if abs(t_i_0) < t_off_min_i:  # t_i_0 negative for offline\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Step 2: Set initial commitments\n    committed = []\n    for i in must_run:\n        u_commit[i] = 1\n        committed.append(i)\n    for i in must_off:\n        u_commit[i] = 0\n    for i in flexible:\n        u_commit[i] = units_info[i]['u_i_0']\n        if u_commit[i] == 1:\n            committed.append(i)\n    \n    # Step 3: Compute feasible generation ranges\n    lower_bounds = np.zeros(n_units)\n    upper_bounds = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_i_0 = unit['p_i_0']\n        u_i_0 = unit['u_i_0']\n        p_start_i = unit['p_start_i']\n        \n        if u_i_0 == 0 and u_commit[i] == 1:  # Starting up\n            lower_bounds[i] = p_min_i\n            upper_bounds[i] = min(p_max_i, p_start_i)\n        else:  # Previously online\n            lower_bounds[i] = max(p_min_i, p_i_0 - p_down_i)\n            upper_bounds[i] = min(p_max_i, p_i_0 + p_up_i)\n    \n    # Compute total capacity metrics\n    total_min = np.sum(lower_bounds[committed])\n    total_max = np.sum(upper_bounds[committed])\n    \n    # Step 4: Handle under-commitment\n    offline_flexible = [i for i in flexible if u_commit[i] == 0]\n    if total_max < current_load:\n        # Calculate amortized costs\n        costs = []\n        for i in offline_flexible:\n            unit = units_info[i]\n            s_i = unit['s_i']\n            t_on_min_i = unit['t_on_min_i']\n            p_max_i = unit['p_max_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost = (a_i + b_i*p_max_i + c_i*p_max_i**2) / p_max_i\n            amortized_cost = cost + s_i / (t_on_min_i * p_max_i)\n            costs.append((i, amortized_cost))\n        \n        # Activate by ascending amortized cost\n        costs.sort(key=lambda x: x[1])\n        for i, _ in costs:\n            if total_max >= current_load:\n                break\n            u_commit[i] = 1\n            committed.append(i)\n            lower_bounds[i] = units_info[i]['p_min_i']\n            upper_bounds[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += lower_bounds[i]\n            total_max += upper_bounds[i]\n    \n    # Step 5: Handle over-commitment\n    online_flexible = [i for i in flexible if u_commit[i] == 1]\n    if total_min > current_load:\n        # Calculate deactivation costs\n        costs = []\n        for i in online_flexible:\n            unit = units_info[i]\n            p_min_i = unit['p_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            cost = (a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i\n            costs.append((i, cost))\n        \n        # Deactivate by descending cost\n        costs.sort(key=lambda x: x[1], reverse=True)\n        for i, _ in costs:\n            if total_min <= current_load:\n                break\n            # Check capacity retention\n            new_min = total_min - lower_bounds[i]\n            new_max = total_max - upper_bounds[i]\n            if new_max >= current_load:  # Ensure sufficient capacity\n                u_commit[i] = 0\n                committed.remove(i)\n                total_min = new_min\n                total_max = new_max\n    \n    # Prepare for dispatch\n    p_output = np.copy(lower_bounds)\n    rem_load = current_load - total_min\n    headroom = upper_bounds - p_output\n    \n    # Step 6: Economic dispatch for committed units\n    if abs(rem_load) > 1e-6 and np.sum(headroom[committed]) > 1e-6:\n        tol = 1e-6\n        comm_arr = np.array(committed)\n        b = np.array([units_info[i]['b_i'] for i in comm_arr])\n        c = np.array([units_info[i]['c_i'] for i in comm_arr])\n        p_cur = p_output[comm_arr]\n        hr = headroom[comm_arr]\n        \n        # Lambda bounds based on incremental costs\n        low = np.min(b + 2*c*p_cur)\n        high = np.max(b + 2*c*(p_cur + hr))\n        \n        # Lambda iteration\n        while high - low > tol:\n            lam = (low + high) / 2\n            total_p = 0\n            for idx, i in enumerate(comm_arr):\n                unit_min = p_cur[idx]\n                unit_max = p_cur[idx] + hr[idx]\n                inc_low = b[idx] + 2*c[idx]*unit_min\n                inc_high = b[idx] + 2*c[idx]*unit_max\n                \n                if lam < inc_low:\n                    p_assigned = unit_min\n                elif lam > inc_high:\n                    p_assigned = unit_max\n                else:\n                    p_assigned = (lam - b[idx]) / (2*c[idx])\n                total_p += p_assigned\n            \n            if total_p < total_min + rem_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Set outputs at optimal lambda\n        lam_final = (low + high) / 2\n        for idx, i in enumerate(comm_arr):\n            inc_low = b[idx] + 2*c[idx]*p_cur[idx]\n            inc_high = b[idx] + 2*c[idx]*(p_cur[idx] + hr[idx])\n            \n            if lam_final < inc_low:\n                p_output[i] = p_cur[idx]\n            elif lam_final > inc_high:\n                p_output[i] = p_cur[idx] + hr[idx]\n            else:\n                p_output[i] = (lam_final - b[idx]) / (2*c[idx])\n    \n    # Step 7: Handle decommitted units\n    for i in range(n_units):\n        if u_commit[i] == 0:\n            p_output[i] = 0\n    \n    # Prepare and return schedule\n    return np.array([u_commit, p_output])",
          "from": "mutation",
          "gap_power_rate": 7.17222e-05,
          "gap_price_rate": 0.0369229127,
          "fitness": 0.0184973174
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run (unsatisfied min-up time or unable to shutdown due to ramp constraints), flexible on units, and offline units.\n2. Form initial commitment of must-run and flexible on units.\n3. Compute feasible min/max outputs considering ramp limits for committed units.\n4. If load < total min output:\n   - Set must-run/flexible-on units to min outputs (over-generation unavoidable)\n5. If load > total max output:\n   - Activate additional offline units sorted by incremental cost at their min output\n   - Update total capacity after each activation\n   - If still insufficient, set all committed units to max outputs\n6. Else (load within feasible range):\n   - Allocate min outputs to all committed units\n   - Distribute remaining load among committed units sorted by incremental cost\n7. Set uncommitted units to offline state (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    committed_indices = []\n    must_run_indices = []\n    \n    # Step 1: Classify must-run units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run_indices.append(i)\n            else:\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_shutdown = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'], unit['p_shut_i'])\n                if min_out > max_shutdown:\n                    must_run_indices.append(i)\n    \n    # Form initial commitment (must-run + flexible on units)\n    committed_indices = must_run_indices.copy()\n    for i in range(n_units):\n        if i not in must_run_indices and units_info[i]['u_i_0'] == 1:\n            committed_indices.append(i)\n    \n    # Compute min/max outputs for all units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_outputs[i] for i in committed_indices)\n    total_max = sum(max_outputs[i] for i in committed_indices)\n    current_load = load[0]\n    \n    # Step 4: Over-generation case\n    if current_load < total_min:\n        for i in committed_indices:\n            u_out[i] = 1\n            p_out[i] = min_outputs[i]\n        return np.array([u_out, p_out])\n    \n    # Step 5: Under-generation case\n    if current_load > total_max:\n        candidate_units = []\n        for i in range(n_units):\n            if i not in committed_indices and units_info[i]['u_i_0'] == 0:\n                if -units_info[i]['t_i_0'] >= units_info[i]['t_off_min_i']:\n                    candidate_units.append(i)\n        \n        # Sort candidates by incremental cost at min output\n        candidate_units.sort(key=lambda i: 2*units_info[i]['c_i']*min_outputs[i] + units_info[i]['b_i'])\n        \n        # Activate units until capacity sufficient or none left\n        for i in candidate_units:\n            committed_indices.append(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            if total_max >= current_load:\n                break\n        \n        # If still insufficient, set to max output\n        if total_max < current_load:\n            for i in committed_indices:\n                u_out[i] = 1\n                p_out[i] = max_outputs[i]\n            return np.array([u_out, p_out])\n    \n    # Step 6: Dispatch within feasible range\n    # Allocate min outputs\n    for i in committed_indices:\n        u_out[i] = 1\n        p_out[i] = min_outputs[i]\n    residual = current_load - total_min\n    \n    # Sort by incremental cost\n    disp_order = sorted(committed_indices, key=lambda i: 2*units_info[i]['c_i']*p_out[i] + units_info[i]['b_i'])\n    \n    # Distribute residual load\n    for i in disp_order:\n        if residual <= 0:\n            break\n        headroom = max_outputs[i] - p_out[i]\n        add_load = min(headroom, residual)\n        p_out[i] += add_load\n        residual -= add_load\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0375214362,
          "fitness": 0.0187965642
     }
]