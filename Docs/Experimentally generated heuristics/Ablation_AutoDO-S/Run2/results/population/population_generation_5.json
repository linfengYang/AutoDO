[
     {
          "name": "rolling_commit_dispatch",
          "algorithm": "1. Classify units into must-run (violating min-up/shutdown ramp), must-off (violating min-down), and flexible categories\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible maintain previous state\n3. Compute maximum deliverable power considering ramp limits and startup constraints\n4. If insufficient capacity, turn on flexible units sorted by average cost at minimum output\n5. If over-committed, turn off highest average-cost flexible units while maintaining sufficient capacity\n6. Dispatch load using greedy incremental cost optimization:\n   a) Set each committed unit to its feasible minimum output\n   b) Incrementally increase output of cheapest units first until meeting demand\n   c) Respect individual unit ramp and output constraints\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units and set initial commitment\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Initial commitment states\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate current available capacity\n    max_cap = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # Newly started\n                max_cap[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                max_cap[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_max = np.sum(max_cap)\n    \n    # Add units if capacity insufficient\n    candidates = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 0:  # Flexible and currently off\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2 + unit['s_i']) / p_min\n            cap = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, cost, cap))\n    \n    candidates.sort(key=lambda x: x[1])\n    for idx, cost, cap in candidates:\n        if total_max < current_load:\n            u[idx] = 1\n            total_max += cap\n        else:\n            break\n    \n    # Remove expensive units if over-committed\n    candidates_off = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 1:  # Flexible and online\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            \n            if unit['u_i_0'] == 0:  # Newly started\n                cap = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            candidates_off.append((i, cost, cap))\n    \n    candidates_off.sort(key=lambda x: x[1], reverse=True)\n    for idx, cost, cap in candidates_off:\n        if total_max - cap >= current_load:\n            u[idx] = 0\n            total_max -= cap\n    \n    # Economic dispatch\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    p_dispatch = np.zeros(n_units)\n    allocated = 0.0\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # New start\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_dispatch[i] = min_bound[i]\n            allocated += min_bound[i]\n    \n    remaining = current_load - allocated\n    if remaining < 0:\n        return np.vstack((u, p_dispatch))\n    \n    # Distribute remaining load\n    while remaining > 0:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and p_dispatch[i] < max_bound[i]:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_dispatch[i]\n                headroom = max_bound[i] - p_dispatch[i]\n                candidates.append((i, inc_cost, headroom))\n        \n        if not candidates:\n            break\n            \n        candidates.sort(key=lambda x: x[1])\n        i, inc_cost, headroom = candidates[0]\n        amount = min(remaining, headroom)\n        p_dispatch[i] += amount\n        allocated += amount\n        remaining -= amount\n    \n    return np.vstack((u, p_dispatch))",
          "from": "mutation",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "enhanced_refined_commit_dispatch",
          "algorithm": "1. Classify units as must-run (if online and (min-up time unfulfilled or previous output exceeds shutdown capacity)), must-off (if offline and min-down time unfulfilled), or flexible (others)\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible units retain previous state\n3. Compute feasible output ranges (considering ramp and startup constraints) and total min/max capacity\n4. If current load > total max capacity:\n    a. Calculate activation priority as (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n    b. Activate offline flexible units in ascending priority order until sufficient capacity\n5. If total min capacity > current load:\n    a. Calculate deactivation priority as (a_i + b_i*min_i + c_i*min_i\u00b2) / min_i\n    b. Deactivate online flexible units in descending priority order while maintaining load coverage\n6. Dispatch load via incremental cost optimization:\n    a. Set committed units to min feasible output\n    b. Allocate remaining load by ascending incremental cost within unit constraints\n7. Return commitment states and power outputs as 2D array\n",
          "code": "import numpy as np\n\ndef enhanced_refined_commit_dispatch(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    load_current = load[0]\n    \n    # Step 1: Classify units and initialize commitment\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:  # previously online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:  # previously offline\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n    for unit in flexible:\n        unit['u_i'] = unit['u_i_0']\n    \n    # Reset dispatch parameters\n    for unit in units:\n        unit['min_i'] = 0.0\n        unit['max_i'] = 0.0\n        unit['dispatch'] = 0.0\n    \n    # Compute feasible ranges for committed units\n    committed_units = [u for u in units if u['u_i'] == 1]\n    total_min, total_max = 0.0, 0.0\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:  # Continuously online\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started in current period\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Activation for insufficient capacity\n    offline_flex = [u for u in flexible if u['u_i'] == 0]\n    activation_candidates = []\n    for unit in offline_flex:\n        p_min = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2\n        avg_cost = total_cost / p_min\n        activation_candidates.append((avg_cost, unit))\n    \n    activation_candidates.sort(key=lambda x: x[0])\n    for _, unit in activation_candidates:\n        if total_max >= load_current:\n            break\n        unit['u_i'] = 1\n        min_i = unit['p_min_i']\n        max_i = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        total_min += min_i\n        total_max += max_i\n        committed_units.append(unit)\n    \n    # Deactivation for over-commitment\n    online_flex = [u for u in committed_units if u in flexible]\n    deactivation_candidates = []\n    for unit in online_flex:\n        min_i = unit['min_i']\n        base_cost = unit['a_i'] + unit['b_i']*min_i + unit['c_i']*min_i**2\n        avg_cost = base_cost / min_i\n        deactivation_candidates.append((avg_cost, unit))\n    \n    deactivation_candidates.sort(key=lambda x: x[0], reverse=True)\n    for _, unit in deactivation_candidates:\n        new_min = total_min - unit['min_i']\n        new_max = total_max - unit['max_i']\n        if new_max < load_current:\n            continue\n        if new_min >= load_current:\n            continue  # Over-commitment remains\n        unit['u_i'] = 0\n        unit['min_i'] = 0.0\n        unit['max_i'] = 0.0\n        total_min = new_min\n        total_max = new_max\n        committed_units.remove(unit)\n    \n    # Dispatch among committed units\n    for unit in committed_units:\n        unit['dispatch'] = unit['min_i']\n    current_total = total_min\n    remaining = load_current - current_total\n    \n    available_units = [u for u in committed_units if u['dispatch'] < u['max_i'] - 1e-5]\n    while remaining > 1e-5 and available_units:\n        inc_costs = []\n        for unit in available_units:\n            inc = unit['b_i'] + 2 * unit['c_i'] * unit['dispatch']\n            inc_costs.append((inc, unit))\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_unit = inc_costs[0][1]\n        max_addition = cheapest_unit['max_i'] - cheapest_unit['dispatch']\n        allocation = min(remaining, max_addition)\n        cheapest_unit['dispatch'] += allocation\n        remaining -= allocation\n        if cheapest_unit['dispatch'] >= cheapest_unit['max_i'] - 1e-5:\n            available_units.remove(cheapest_unit)\n    \n    # Set outputs for uncommitted units\n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['dispatch'] = 0.0\n    \n    u_vector = [unit['u_i'] for unit in units]\n    p_vector = [unit['dispatch'] for unit in units]\n    schedules = np.array([u_vector, p_vector], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0060521947,
          "gap_price_rate": 0.0089602466,
          "fitness": 0.0075062207
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "improved_rolling_commit",
          "algorithm": "1. Classify units as must-run, must-off, or flexible based on min up/down times and shutdown constraints.\n2. Compute feasible output ranges for online units considering ramp constraints.\n3. If current load exceeds online capacity, activate offline units in cost-merit order with next-period penalty handling.\n4. If minimum output exceeds load, handle over-generation by setting to minimum outputs.\n5. Dispatch load among online units using merit-order by incremental cost within feasible ranges.\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commit(units_info, load):\n    # Step 0: Parse inputs\n    current_load = load[0]\n    forecast_next = load[1]\n    \n    # Convert units_info to list of dicts for mutability\n    units = [dict(unit) for unit in units_info]\n    n_units = len(units)\n    \n    # Initialize schedules\n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible_online = []  # Currently online\n    flexible_offline = []  # Currently offline\n    \n    for i, unit in enumerate(units):\n        # Compute absolute down time\n        abs_down_time = -unit['t_i_0'] if unit['t_i_0'] < 0 else 0\n        \n        if unit['u_i_0'] == 1:\n            must_run_condition = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n            if must_run_condition:\n                must_run.append(i)\n            else:\n                flexible_online.append(i)\n        else:\n            must_off_condition = (abs_down_time < unit['t_off_min_i'])\n            if must_off_condition:\n                must_off.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Step 2: Compute feasible output ranges for already online units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    total_min, total_max = 0.0, 0.0\n    \n    # Process must-run and flexible_online\n    for i in must_run + flexible_online:\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_output[i] = min_p\n        max_output[i] = max_p\n        total_min += min_p\n        total_max += max_p\n    \n    # Track activated units\n    activated_offline = []\n    \n    # Step 3: Check generation capacity\n    if total_max < current_load:\n        # Need to activate offline units\n        deficit = current_load - total_max\n        # Precompute next period must-run minimum\n        next_period_must_run_min = 0\n        for i in must_run + flexible_online:\n            unit = units[i]\n            if (unit['t_i_0'] + 1) < unit['t_on_min_i']:\n                next_period_must_run_min += unit['p_min_i']\n        \n        # Calculate activation priority metric (amortized cost)\n        candidates_safe = []\n        candidates_penalized = []\n        \n        for i in flexible_offline:\n            unit = units[i]\n            # Metric: Amortized cost per MW over minimum up time\n            min_up = max(1, unit['t_on_min_i'])\n            cost_min_output = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            amortized_cost = (unit['s_i'] + cost_min_output * min_up) / (unit['p_min_i'] * min_up)\n            \n            max_gen = min(unit['p_max_i'], unit['p_start_i'])\n            next_add = unit['p_min_i'] if unit['t_on_min_i'] > 1 else 0\n            \n            candidate = (amortized_cost, i, max_gen, next_add)\n            if (next_period_must_run_min + next_add) <= forecast_next:\n                candidates_safe.append(candidate)\n            else:\n                candidates_penalized.append(candidate)\n        \n        # Sort candidates\n        candidates_safe.sort(key=lambda x: x[0])\n        candidates_penalized.sort(key=lambda x: x[0])\n        candidates = candidates_safe + candidates_penalized\n        \n        # Activate units until deficit is covered\n        for cost, idx, max_gen, next_add in candidates:\n            if deficit <= 0:\n                break\n            activated_offline.append(idx)\n            min_output[idx] = units[idx]['p_min_i']\n            max_output[idx] = min(units[idx]['p_max_i'], units[idx]['p_start_i'])\n            total_min += min_output[idx]\n            total_max += max_output[idx]\n            deficit -= max_gen\n            # Update next period must-run min for subsequent candidates\n            next_period_must_run_min += next_add\n    \n    # Identify online units\n    online_units = must_run + flexible_online + activated_offline\n    # If over-generation (current_load < total_min), still proceed to dispatch\n    # Step 5: Economic dispatch\n    # Initialize dispatch at minimum output\n    for i in online_units:\n        u_schedule[i] = 1\n        p_schedule[i] = min_output[i]\n        units[i]['current_p'] = min_output[i]  # Track for increment\n    \n    remaining_load = current_load - total_min\n    \n    # Only dispatch if positive load to distribute\n    if remaining_load > 0:\n        # Priority list: incremental cost at current assignment\n        priority_list = []\n        for i in online_units:\n            if max_output[i] > min_output[i]:\n                # Derivative of cost: 2*c_i*p_i + b_i\n                incremental_cost = 2 * units[i]['c_i'] * units[i]['current_p'] + units[i]['b_i']\n                priority_list.append((incremental_cost, i))\n        \n        priority_list.sort(key=lambda x: x[0])\n        \n        # Distribute remaining load\n        for _, i in priority_list:\n            if remaining_load <= 0:\n                break\n            capacity_available = max_output[i] - units[i]['current_p']\n            allocate = min(remaining_load, capacity_available)\n            p_schedule[i] += allocate\n            units[i]['current_p'] += allocate\n            remaining_load -= allocate\n    \n    # Step 4 & 6: If under total_min (over-generation) or after dispatch\n    # If load < total_min, units already set to min_output\n    \n    # Format output\n    schedules = np.array([\n        u_schedule,\n        p_schedule\n    ], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Identify must-run units (online units that haven't met min-up time or have power exceeding shutdown limit) and must-off units (offline units that haven't met min-down time)  \n2. Initialize commitment: must-run to on, must-off to off, flexible units keep previous state  \n3. Calculate total min/max power considering ramp constraints (startup/shutdown ramp limits for state changes)  \n4. While total max power < current load:  \n   - Turn on flexible offline units with lowest average cost at min output (including startup cost)  \n   - Recalculate total min/max power with new commitment  \n5. While total min power > current load:  \n   - Turn off flexible online units with highest production cost at min output if previous output \u2264 ramp-down limit  \n   - Recalculate total min/max power  \n6. Set offline units' output to 0  \n7. For online units:  \n   - If load \u2264 total min power, set all to min output  \n   - If load \u2265 total max power, set all to max output  \n   - Else perform ramp-constrained economic dispatch by incremental cost ordering  \n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    load_current = load[0]\n    \n    # Extract units info\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    min_uptime = [unit['t_on_min_i'] for unit in units_info]\n    min_downtime = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n\n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_state[i] < min_uptime[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n        else:\n            if abs(t_state[i]) < min_downtime[i]:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = u_prev[i]\n    \n    # Calculate current min and max outputs considering ramp constraints\n    min_cap = np.zeros(n_units)\n    max_cap = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if u_prev[i] == 1:\n                min_cap[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_cap[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_cap[i] = p_min[i]\n                max_cap[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(min_cap)\n    total_max = np.sum(max_cap)\n    \n    # Add units if under-committed\n    if total_max < load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 0]\n        avg_costs = []\n        for i in candidates:\n            cost = s[i] + a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            avg_costs.append((cost / p_min[i], i))\n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, idx in avg_costs:\n            if total_max >= load_current:\n                break\n            u[idx] = 1\n            min_cap[idx] = p_min[idx]\n            max_cap[idx] = min(p_max[idx], p_start[idx])\n            total_min += min_cap[idx]\n            total_max += max_cap[idx]\n    \n    # Remove units if over-committed\n    if total_min > load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 1 \n                     and p_prev[i] <= p_down[i]]\n        prod_costs = []\n        for i in candidates:\n            cost = a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            prod_costs.append((cost / p_min[i], i))\n        prod_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, idx in prod_costs:\n            if total_min <= load_current:\n                break\n            u[idx] = 0\n            total_min -= min_cap[idx]\n            total_max -= max_cap[idx]\n            min_cap[idx] = max_cap[idx] = 0\n    \n    # Set outputs\n    committed = [i for i in range(n_units) if u[i] == 1]\n    if not committed:\n        return np.array([u, p_output])\n    \n    total_min = sum(min_cap[i] for i in committed)\n    total_max = sum(max_cap[i] for i in committed)\n    \n    # Case 1: Load below total min capacity\n    if load_current <= total_min:\n        for i in committed:\n            p_output[i] = min_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 2: Load above total max capacity\n    if load_current >= total_max:\n        for i in committed:\n            p_output[i] = max_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 3: Economic dispatch\n    current_load = np.zeros(len(committed))\n    min_arr = [min_cap[i] for i in committed]\n    max_arr = [max_cap[i] for i in committed]\n    b_arr = [b[i] for i in committed]\n    c_arr = [c[i] for i in committed]\n    idx_to_global = {local: global_idx for local, global_idx in enumerate(committed)}\n    \n    # Initialize at min capacity\n    for local, i in enumerate(committed):\n        current_load[local] = min_cap[i]\n    remaining = load_current - total_min\n    \n    # Dispatch by incremental cost\n    while remaining > 0:\n        inc_costs = []\n        for local in range(len(committed)):\n            if current_load[local] < max_arr[local]:\n                inc_cost = b_arr[local] + 2 * c_arr[local] * current_load[local]\n                inc_costs.append((inc_cost, local))\n        \n        if not inc_costs:\n            break\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_idx = inc_costs[0][1]\n        \n        max_increase = max_arr[cheapest_idx] - current_load[cheapest_idx]\n        increase = min(remaining, max_increase)\n        current_load[cheapest_idx] += increase\n        remaining -= increase\n    \n    # Map dispatch to original units\n    for local, global_idx in idx_to_global.items():\n        p_output[global_idx] = current_load[local]\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "refined_rolling_commit_dispatch",
          "algorithm": "1. Classify units into must-run (online violating min-up time or shutdown ramp), must-off (offline violating min-down time), and flexible\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible retain prior state\n3. Compute feasible outputs for committed units (ramp constraints for online units, startup limits for activated units)\n4. If total max capacity < load:\n   a. Calculate amortized startup cost for flexible offline units: avg_cost + startup_cost/(min_output * min_up_time)\n   b. Activate units by ascending amortized cost until sufficient capacity\n5. If total min output > load:\n   a. Deactivate flexible online units by descending avg cost at min output\n   b. Maintain sufficient max capacity for current load\n6. Dispatch using lambda iteration:\n   a. If load within feasible range, use bisection on incremental costs\n   b. Otherwise set outputs to min/max limits\n7. Output commitment states and power allocations\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    # Classify units\n    must_run, must_off, flexible = [], [], []\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(idx)\n            else:\n                flexible.append(idx)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible.append(idx)\n    \n    # Initialize commitments\n    committed = set()\n    for idx in must_run:\n        committed.add(idx)\n    for idx in flexible:\n        if units_info[idx]['u_i_0'] == 1:\n            committed.add(idx)\n    \n    # Compute feasible outputs\n    min_outputs = [0] * n\n    max_outputs = [0] * n\n    total_min, total_max = 0, 0\n    \n    for idx in committed:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        min_outputs[idx] = min_out\n        max_outputs[idx] = max_out\n        total_min += min_out\n        total_max += max_out\n    \n    # Activation for under-committed\n    offline_flex = [idx for idx in flexible if not units_info[idx]['u_i_0'] and idx not in committed]\n    activate_candidates = []\n    for idx in offline_flex:\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        avg_cost = (unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n        amortized_cost = avg_cost + unit['s_i'] / (p_min * unit['t_on_min_i'])\n        activate_candidates.append((amortized_cost, idx))\n    activate_candidates.sort(key=lambda x: x[0])\n    \n    activated = []\n    for cost, idx in activate_candidates:\n        if total_max >= current_load:\n            break\n        unit = units_info[idx]\n        min_candidate = unit['p_min_i']\n        max_candidate = min(unit['p_max_i'], unit['p_start_i'])\n        min_outputs[idx] = min_candidate\n        max_outputs[idx] = max_candidate\n        total_min += min_candidate\n        total_max += max_candidate\n        activated.append(idx)\n        committed.add(idx)\n    \n    # Deactivation for over-committed\n    online_flex = [idx for idx in flexible if units_info[idx]['u_i_0'] == 1 and idx in committed]\n    deactivate_candidates = []\n    for idx in online_flex:\n        min_out = min_outputs[idx]\n        unit = units_info[idx]\n        avg_cost = (unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2) / min_out\n        deactivate_candidates.append((avg_cost, idx))\n    deactivate_candidates.sort(key=lambda x: x[0], reverse=True)\n    \n    deactivated = []\n    for cost, idx in deactivate_candidates:\n        if total_min <= current_load:\n            break\n        if total_max - max_outputs[idx] < current_load:\n            continue\n        total_min -= min_outputs[idx]\n        total_max -= max_outputs[idx]\n        deactivated.append(idx)\n        committed.remove(idx)\n    \n    # Dispatch using lambda iteration\n    p_alloc = [0.0] * n\n    if current_load <= total_min:\n        for idx in committed:\n            p_alloc[idx] = min_outputs[idx]\n    elif current_load >= total_max:\n        for idx in committed:\n            p_alloc[idx] = max_outputs[idx]\n    else:\n        low_lambda = min(units_info[idx]['b_i'] + 2*units_info[idx]['c_i']*min_outputs[idx] for idx in committed)\n        high_lambda = max(units_info[idx]['b_i'] + 2*units_info[idx]['c_i']*max_outputs[idx] for idx in committed)\n        tolerance = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0.0\n            for idx in committed:\n                ic_min = units_info[idx]['b_i'] + 2*units_info[idx]['c_i']*min_outputs[idx]\n                ic_max = units_info[idx]['b_i'] + 2*units_info[idx]['c_i']*max_outputs[idx]\n                if mid_lambda < ic_min:\n                    p = min_outputs[idx]\n                elif mid_lambda > ic_max:\n                    p = max_outputs[idx]\n                else:\n                    p = (mid_lambda - units_info[idx]['b_i']) / (2*units_info[idx]['c_i'])\n                p_alloc[idx] = p\n                total_power += p\n            if abs(total_power - current_load) < tolerance:\n                break\n            if total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n    \n    # Build output\n    u_vec = [1 if idx in committed else 0 for idx in range(n)]\n    p_vec = [p_alloc[idx] if idx in committed else 0.0 for idx in range(n)]\n    \n    return np.array([u_vec, p_vec])",
          "from": "mutation",
          "gap_power_rate": 0.0001296798,
          "gap_price_rate": 0.0352005135,
          "fitness": 0.0176650967
     },
     {
          "name": "rolling_commit_dispatch_refined",
          "algorithm": "1. Classify units:\n   - Must-run: Online units violating minimum up-time or shutdown ramp constraints\n   - Must-off: Offline units violating minimum down-time constraints\n   - Flexible: Units not bound by operational constraints\n2. Initialize commitments:\n   - Must-run: u_i = 1\n   - Must-off: u_i = 0\n   - Flexible: Maintain previous state (u_i = u_i_0)\n3. Calculate feasible power ranges for committed units considering ramp constraints and startup/shutdown limitations\n4. If under-committed (max capacity < load):\n   - Activate offline flexible units using amortized cost metric:\n     (s_i/(t_on_min_i * p_min_i) + (a_i + b_i * p_min_i + c_i * p_min_i**2)/p_min_i\n   - Prioritize units with lowest metric\n5. If over-committed (min capacity > load):\n   - Deactivate online flexible units using average cost metric:\n     (a_i + b_i * p_min_i + c_i * p_min_i**2)/p_min_i\n   - Prioritize units with highest metric while maintaining sufficient capacity\n6. Perform constrained economic dispatch for committed units:\n   a) Set outputs to feasible minimums\n   b) Distribute residual load using bisection method to find optimal lambda\n   c) Respect individual unit output constraints\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_refined(units_info, load):\n    current_load = load[0]\n    # Initialize outputs\n    n_units = len(units_info)\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    \n    # Classify units and initialize commitments\n    must_run = []\n    must_off = []\n    flexible_idx = []\n    \n    for i, unit in enumerate(units_info):\n        # Extract parameters\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        # Classify must-run units\n        if u_i0 == 1 and (t_i0 < t_on_min or (p_i0 > p_shut and p_i0 - p_down > p_shut)):\n            must_run.append(i)\n        # Classify must-off units\n        elif u_i0 == 0 and abs(t_i0) < t_off_min:\n            must_off.append(i)\n        else:\n            flexible_idx.append(i)\n    \n    # Set commitments based on classification\n    u_out[must_run] = 1\n    u_out[must_off] = 0\n    u_out[flexible_idx] = [units_info[i]['u_i_0'] for i in flexible_idx]\n    \n    # Compute feasible ranges\n    committed = np.where(u_out == 1)[0]\n    total_min_capacity = 0\n    total_max_capacity = 0\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        \n        if u_out[i] == 0:  # Offline\n            min_output[i] = 0\n            max_output[i] = 0\n        elif u_i0 == 1:  # Previously online\n            min_output[i] = max(p_min, p_i0 - p_down)\n            max_output[i] = min(p_max, p_i0 + p_up)\n            if u_out[i] == 0:  # Shutting down\n                max_output[i] = min(max_output[i], p_shut)\n        else:  # Started in this period\n            min_output[i] = p_min\n            max_output[i] = min(p_max, p_start)\n        \n        if u_out[i] == 1:\n            total_min_capacity += min_output[i]\n            total_max_capacity += max_output[i]\n    \n    # Activation for under-committed\n    if total_max_capacity < current_load:\n        offline_flexible = [i for i in flexible_idx if units_info[i]['u_i_0'] == 0]\n        # Calculate amortized cost metric\n        activation_metric = []\n        for i in offline_flexible:\n            unit = units_info[i]\n            s_i = unit['s_i']\n            t_on_min_i = unit['t_on_min_i']\n            p_min_i = unit['p_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            metric = s_i/(t_on_min_i * p_min_i) + (a_i + b_i * p_min_i + c_i * p_min_i**2)/p_min_i\n            activation_metric.append((metric, i))\n        \n        # Sort and activate\n        activation_metric.sort(key=lambda x: x[0])\n        for metric, i in activation_metric:\n            if total_max_capacity >= current_load:\n                break\n            u_out[i] = 1\n            min_output[i] = units_info[i]['p_min_i']\n            max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min_capacity += min_output[i]\n            total_max_capacity += max_output[i]\n    \n    # Deactivation for over-committed\n    if total_min_capacity > current_load:\n        online_flexible = [i for i in flexible_idx if u_out[i] == 1]\n        # Calculate average cost at min output\n        deactivation_metric = []\n        for i in online_flexible:\n            unit = units_info[i]\n            p_min_i = unit['p_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            metric = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n            deactivation_metric.append((metric, i))\n        \n        # Sort and deactivate\n        deactivation_metric.sort(key=lambda x: x[0], reverse=True)\n        for metric, i in deactivation_metric:\n            new_min_cap = total_min_capacity - min_output[i]\n            new_max_cap = total_max_capacity - max_output[i]\n            if new_min_cap <= current_load <= new_max_cap:\n                u_out[i] = 0\n                min_output[i] = 0\n                max_output[i] = 0\n                total_min_capacity = new_min_cap\n                total_max_capacity = new_max_cap\n            if total_min_capacity <= current_load:\n                break\n    \n    # Set outputs for offline units\n    offline_units = np.where(u_out == 0)[0]\n    p_out[offline_units] = 0\n    \n    # Dispatch for online units\n    online_units = np.where(u_out == 1)[0]\n    if len(online_units) == 0:\n        return np.vstack((u_out, p_out))\n    \n    # Set initial output to minimum\n    p_out[online_units] = [min_output[i] for i in online_units]\n    residual = current_load - p_out[online_units].sum()\n    \n    # Case 1: Residual too low - set to minimum feasible\n    if residual < 0:\n        p_out[online_units] = [min_output[i] for i in online_units]\n        return np.vstack((u_out, p_out))\n    \n    # Case 2: Residual within feasible range - dispatch using bisection\n    if abs(residual) < 1e-6:\n        return np.vstack((u_out, p_out))\n    \n    # Case 3: Residual too high - set to maximum feasible\n    max_feasible = max_output[online_units].sum()\n    if residual > max_feasible - min_output[online_units].sum():\n        p_out[online_units] = [max_output[i] for i in online_units]\n        return np.vstack((u_out, p_out))\n    \n    # Bisection method dispatch\n    low_lambda = 0\n    high_lambda = 0\n    for i in online_units:\n        b_i = units_info[i]['b_i']\n        c_i = max(units_info[i]['c_i'], 1e-9)  # Avoid zero\n        inc_min = 2 * c_i * min_output[i] + b_i\n        inc_max = 2 * c_i * max_output[i] + b_i\n        low_lambda = min(low_lambda, inc_min)\n        high_lambda = max(high_lambda, inc_max)\n    \n    # Expand lambda bounds for robustness\n    low_lambda -= 100\n    high_lambda += 100\n    \n    # Bisection iterations\n    tol = 1e-4\n    max_iter = 100\n    n_iter = 0\n    while n_iter < max_iter and abs(residual) > tol:\n        lambda_mid = (low_lambda + high_lambda) / 2\n        total_output = 0\n        for i in online_units:\n            unit = units_info[i]\n            b_i = unit['b_i']\n            c_i = max(unit['c_i'], 1e-9)\n            p_i_target = (lambda_mid - b_i) / (2 * c_i)\n            p_i = np.clip(p_i_target, min_output[i], max_output[i])\n            p_out[i] = p_i\n            total_output += p_i\n        \n        if total_output < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n        \n        residual = current_load - total_output\n        n_iter += 1\n    \n    return np.vstack((u_out, p_out))",
          "from": "mutation",
          "gap_power_rate": 0.0001296894,
          "gap_price_rate": 0.0352005151,
          "fitness": 0.0176651022
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Classify units into must-run (units forced online by min uptime/shutdown ramp), must-off (units forced offline by min downtime), and flexible units\n2. For committed units, compute feasible generation ranges using ramp constraints and min/max limits\n3. If undercommitted, activate additional flexible units by ascending average cost per MW at max output \n4. If overcommitted, deactivate expensive flexible units by descending average cost per MW at min output\n5. Perform constrained economic dispatch: \n   a) Set initial outputs at minimum feasible levels\n   b) Allocate remaining load by ascending incremental cost within ramp/output constraints\n6. Return schedule as 2D array with commitment states and dispatch levels\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    \n    # Extract unit attributes\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n\n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flex_on = []  # Flexible and currently online\n    flex_off = []  # Flexible and currently offline\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Previously online\n            if t_prev[i] < t_on_min[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n            else:\n                flex_on.append(i)\n        else:  # Previously offline\n            if -t_prev[i] < t_off_min[i]:\n                must_off.append(i)\n            else:\n                flex_off.append(i)\n\n    # Initially commit must-run and flexible online units\n    committed = set(must_run + flex_on)\n\n    # Step 2: Compute feasible output ranges\n    min_feasible = [0] * n_units\n    max_feasible = [0] * n_units\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Online in previous period\n            min_feasible[i] = max(p_min[i], p_prev[i] - p_down[i])\n            max_feasible[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:  # Offline in previous period\n            min_feasible[i] = p_min[i]\n            max_feasible[i] = min(p_max[i], p_start[i])\n\n    # Step 3: Under-commitment handling\n    total_min = sum(min_feasible[i] for i in committed)\n    total_max = sum(max_feasible[i] for i in committed)\n    \n    if total_max < current_load:\n        # Calculate average cost per MW at max output\n        avg_costs = []\n        for i in flex_off:\n            total_cost = s[i] + a[i] + b[i] * p_max[i] + c[i] * (p_max[i] ** 2)\n            avg_cost = total_cost / p_max[i]\n            avg_costs.append((i, avg_cost))\n        \n        # Sort flexible offline units by cost ascending\n        avg_costs.sort(key=lambda x: x[1])\n        \n        # Activate units until meeting load\n        for i, _ in avg_costs:\n            if total_max >= current_load:\n                break\n            committed.add(i)\n            flex_off.remove(i)\n            total_min += min_feasible[i]\n            total_max += max_feasible[i]\n\n    # Step 4: Over-commitment handling\n    if total_min > current_load:\n        # Calculate average cost per MW at min output\n        avg_costs = []\n        for i in flex_on:\n            total_cost = a[i] + b[i] * p_min[i] + c[i] * (p_min[i] ** 2)\n            avg_cost = total_cost / p_min[i]\n            avg_costs.append((i, avg_cost))\n        \n        # Sort flexible online units by cost descending\n        avg_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        # Deactivate expensive units\n        for i, _ in avg_costs:\n            new_min = total_min - min_feasible[i]\n            new_max = total_max - max_feasible[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed.remove(i)\n                flex_on.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= current_load:\n                    break\n\n    # Step 5a: Initialize dispatch at minimum feasible levels\n    p_dispatch = {}\n    remaining_load = current_load\n    for i in committed:\n        p_dispatch[i] = min_feasible[i]\n        remaining_load -= min_feasible[i]\n    \n    # Step 5b: Allocate remaining load by incremental cost\n    while remaining_load > 0:\n        candidates = []\n        for i in committed:\n            if p_dispatch[i] < max_feasible[i]:\n                inc_cost = 2 * c[i] * p_dispatch[i] + b[i]\n                candidates.append((i, inc_cost))\n        \n        if not candidates:\n            break\n            \n        # Find unit with smallest incremental cost\n        i, _ = min(candidates, key=lambda x: x[1])\n        \n        # Increase output within limits\n        max_increase = max_feasible[i] - p_dispatch[i]\n        increase = min(remaining_load, max_increase)\n        p_dispatch[i] += increase\n        remaining_load -= increase\n\n    # Step 6: Build output schedule\n    for i in range(n_units):\n        if i in committed:\n            u_out[i] = 1\n            p_out[i] = p_dispatch.get(i, 0)\n        else:\n            u_out[i] = 0\n            p_out[i] = 0\n\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0355884996,
          "fitness": 0.0178300959
     }
]