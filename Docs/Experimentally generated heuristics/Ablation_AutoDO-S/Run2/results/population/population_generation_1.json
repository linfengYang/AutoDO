[
     {
          "name": "rolling_commit_dispatch",
          "algorithm": "1. Classify units into must-run (violating min-up/shutdown ramp), must-off (violating min-down), and flexible categories\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible maintain previous state\n3. Compute maximum deliverable power considering ramp limits and startup constraints\n4. If insufficient capacity, turn on flexible units sorted by average cost at minimum output\n5. If over-committed, turn off highest average-cost flexible units while maintaining sufficient capacity\n6. Dispatch load using greedy incremental cost optimization:\n   a) Set each committed unit to its feasible minimum output\n   b) Incrementally increase output of cheapest units first until meeting demand\n   c) Respect individual unit ramp and output constraints\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units and set initial commitment\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Initial commitment states\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate current available capacity\n    max_cap = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # Newly started\n                max_cap[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                max_cap[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_max = np.sum(max_cap)\n    \n    # Add units if capacity insufficient\n    candidates = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 0:  # Flexible and currently off\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2 + unit['s_i']) / p_min\n            cap = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, cost, cap))\n    \n    candidates.sort(key=lambda x: x[1])\n    for idx, cost, cap in candidates:\n        if total_max < current_load:\n            u[idx] = 1\n            total_max += cap\n        else:\n            break\n    \n    # Remove expensive units if over-committed\n    candidates_off = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 1:  # Flexible and online\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            \n            if unit['u_i_0'] == 0:  # Newly started\n                cap = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            candidates_off.append((i, cost, cap))\n    \n    candidates_off.sort(key=lambda x: x[1], reverse=True)\n    for idx, cost, cap in candidates_off:\n        if total_max - cap >= current_load:\n            u[idx] = 0\n            total_max -= cap\n    \n    # Economic dispatch\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    p_dispatch = np.zeros(n_units)\n    allocated = 0.0\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # New start\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_dispatch[i] = min_bound[i]\n            allocated += min_bound[i]\n    \n    remaining = current_load - allocated\n    if remaining < 0:\n        return np.vstack((u, p_dispatch))\n    \n    # Distribute remaining load\n    while remaining > 0:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and p_dispatch[i] < max_bound[i]:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_dispatch[i]\n                headroom = max_bound[i] - p_dispatch[i]\n                candidates.append((i, inc_cost, headroom))\n        \n        if not candidates:\n            break\n            \n        candidates.sort(key=lambda x: x[1])\n        i, inc_cost, headroom = candidates[0]\n        amount = min(remaining, headroom)\n        p_dispatch[i] += amount\n        allocated += amount\n        remaining -= amount\n    \n    return np.vstack((u, p_dispatch))",
          "from": "mutation",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "improved_rolling_commit",
          "algorithm": "1. Classify units as must-run, must-off, or flexible based on min up/down times and shutdown constraints.\n2. Compute feasible output ranges for online units considering ramp constraints.\n3. If current load exceeds online capacity, activate offline units in cost-merit order with next-period penalty handling.\n4. If minimum output exceeds load, handle over-generation by setting to minimum outputs.\n5. Dispatch load among online units using merit-order by incremental cost within feasible ranges.\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commit(units_info, load):\n    # Step 0: Parse inputs\n    current_load = load[0]\n    forecast_next = load[1]\n    \n    # Convert units_info to list of dicts for mutability\n    units = [dict(unit) for unit in units_info]\n    n_units = len(units)\n    \n    # Initialize schedules\n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible_online = []  # Currently online\n    flexible_offline = []  # Currently offline\n    \n    for i, unit in enumerate(units):\n        # Compute absolute down time\n        abs_down_time = -unit['t_i_0'] if unit['t_i_0'] < 0 else 0\n        \n        if unit['u_i_0'] == 1:\n            must_run_condition = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n            if must_run_condition:\n                must_run.append(i)\n            else:\n                flexible_online.append(i)\n        else:\n            must_off_condition = (abs_down_time < unit['t_off_min_i'])\n            if must_off_condition:\n                must_off.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Step 2: Compute feasible output ranges for already online units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    total_min, total_max = 0.0, 0.0\n    \n    # Process must-run and flexible_online\n    for i in must_run + flexible_online:\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_output[i] = min_p\n        max_output[i] = max_p\n        total_min += min_p\n        total_max += max_p\n    \n    # Track activated units\n    activated_offline = []\n    \n    # Step 3: Check generation capacity\n    if total_max < current_load:\n        # Need to activate offline units\n        deficit = current_load - total_max\n        # Precompute next period must-run minimum\n        next_period_must_run_min = 0\n        for i in must_run + flexible_online:\n            unit = units[i]\n            if (unit['t_i_0'] + 1) < unit['t_on_min_i']:\n                next_period_must_run_min += unit['p_min_i']\n        \n        # Calculate activation priority metric (amortized cost)\n        candidates_safe = []\n        candidates_penalized = []\n        \n        for i in flexible_offline:\n            unit = units[i]\n            # Metric: Amortized cost per MW over minimum up time\n            min_up = max(1, unit['t_on_min_i'])\n            cost_min_output = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            amortized_cost = (unit['s_i'] + cost_min_output * min_up) / (unit['p_min_i'] * min_up)\n            \n            max_gen = min(unit['p_max_i'], unit['p_start_i'])\n            next_add = unit['p_min_i'] if unit['t_on_min_i'] > 1 else 0\n            \n            candidate = (amortized_cost, i, max_gen, next_add)\n            if (next_period_must_run_min + next_add) <= forecast_next:\n                candidates_safe.append(candidate)\n            else:\n                candidates_penalized.append(candidate)\n        \n        # Sort candidates\n        candidates_safe.sort(key=lambda x: x[0])\n        candidates_penalized.sort(key=lambda x: x[0])\n        candidates = candidates_safe + candidates_penalized\n        \n        # Activate units until deficit is covered\n        for cost, idx, max_gen, next_add in candidates:\n            if deficit <= 0:\n                break\n            activated_offline.append(idx)\n            min_output[idx] = units[idx]['p_min_i']\n            max_output[idx] = min(units[idx]['p_max_i'], units[idx]['p_start_i'])\n            total_min += min_output[idx]\n            total_max += max_output[idx]\n            deficit -= max_gen\n            # Update next period must-run min for subsequent candidates\n            next_period_must_run_min += next_add\n    \n    # Identify online units\n    online_units = must_run + flexible_online + activated_offline\n    # If over-generation (current_load < total_min), still proceed to dispatch\n    # Step 5: Economic dispatch\n    # Initialize dispatch at minimum output\n    for i in online_units:\n        u_schedule[i] = 1\n        p_schedule[i] = min_output[i]\n        units[i]['current_p'] = min_output[i]  # Track for increment\n    \n    remaining_load = current_load - total_min\n    \n    # Only dispatch if positive load to distribute\n    if remaining_load > 0:\n        # Priority list: incremental cost at current assignment\n        priority_list = []\n        for i in online_units:\n            if max_output[i] > min_output[i]:\n                # Derivative of cost: 2*c_i*p_i + b_i\n                incremental_cost = 2 * units[i]['c_i'] * units[i]['current_p'] + units[i]['b_i']\n                priority_list.append((incremental_cost, i))\n        \n        priority_list.sort(key=lambda x: x[0])\n        \n        # Distribute remaining load\n        for _, i in priority_list:\n            if remaining_load <= 0:\n                break\n            capacity_available = max_output[i] - units[i]['current_p']\n            allocate = min(remaining_load, capacity_available)\n            p_schedule[i] += allocate\n            units[i]['current_p'] += allocate\n            remaining_load -= allocate\n    \n    # Step 4 & 6: If under total_min (over-generation) or after dispatch\n    # If load < total_min, units already set to min_output\n    \n    # Format output\n    schedules = np.array([\n        u_schedule,\n        p_schedule\n    ], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Identify must-run units (online units that haven't met min-up time or have power exceeding shutdown limit) and must-off units (offline units that haven't met min-down time)  \n2. Initialize commitment: must-run to on, must-off to off, flexible units keep previous state  \n3. Calculate total min/max power considering ramp constraints (startup/shutdown ramp limits for state changes)  \n4. While total max power < current load:  \n   - Turn on flexible offline units with lowest average cost at min output (including startup cost)  \n   - Recalculate total min/max power with new commitment  \n5. While total min power > current load:  \n   - Turn off flexible online units with highest production cost at min output if previous output \u2264 ramp-down limit  \n   - Recalculate total min/max power  \n6. Set offline units' output to 0  \n7. For online units:  \n   - If load \u2264 total min power, set all to min output  \n   - If load \u2265 total max power, set all to max output  \n   - Else perform ramp-constrained economic dispatch by incremental cost ordering  \n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    load_current = load[0]\n    \n    # Extract units info\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    min_uptime = [unit['t_on_min_i'] for unit in units_info]\n    min_downtime = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n\n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_state[i] < min_uptime[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n        else:\n            if abs(t_state[i]) < min_downtime[i]:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = u_prev[i]\n    \n    # Calculate current min and max outputs considering ramp constraints\n    min_cap = np.zeros(n_units)\n    max_cap = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if u_prev[i] == 1:\n                min_cap[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_cap[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_cap[i] = p_min[i]\n                max_cap[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(min_cap)\n    total_max = np.sum(max_cap)\n    \n    # Add units if under-committed\n    if total_max < load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 0]\n        avg_costs = []\n        for i in candidates:\n            cost = s[i] + a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            avg_costs.append((cost / p_min[i], i))\n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, idx in avg_costs:\n            if total_max >= load_current:\n                break\n            u[idx] = 1\n            min_cap[idx] = p_min[idx]\n            max_cap[idx] = min(p_max[idx], p_start[idx])\n            total_min += min_cap[idx]\n            total_max += max_cap[idx]\n    \n    # Remove units if over-committed\n    if total_min > load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 1 \n                     and p_prev[i] <= p_down[i]]\n        prod_costs = []\n        for i in candidates:\n            cost = a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            prod_costs.append((cost / p_min[i], i))\n        prod_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, idx in prod_costs:\n            if total_min <= load_current:\n                break\n            u[idx] = 0\n            total_min -= min_cap[idx]\n            total_max -= max_cap[idx]\n            min_cap[idx] = max_cap[idx] = 0\n    \n    # Set outputs\n    committed = [i for i in range(n_units) if u[i] == 1]\n    if not committed:\n        return np.array([u, p_output])\n    \n    total_min = sum(min_cap[i] for i in committed)\n    total_max = sum(max_cap[i] for i in committed)\n    \n    # Case 1: Load below total min capacity\n    if load_current <= total_min:\n        for i in committed:\n            p_output[i] = min_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 2: Load above total max capacity\n    if load_current >= total_max:\n        for i in committed:\n            p_output[i] = max_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 3: Economic dispatch\n    current_load = np.zeros(len(committed))\n    min_arr = [min_cap[i] for i in committed]\n    max_arr = [max_cap[i] for i in committed]\n    b_arr = [b[i] for i in committed]\n    c_arr = [c[i] for i in committed]\n    idx_to_global = {local: global_idx for local, global_idx in enumerate(committed)}\n    \n    # Initialize at min capacity\n    for local, i in enumerate(committed):\n        current_load[local] = min_cap[i]\n    remaining = load_current - total_min\n    \n    # Dispatch by incremental cost\n    while remaining > 0:\n        inc_costs = []\n        for local in range(len(committed)):\n            if current_load[local] < max_arr[local]:\n                inc_cost = b_arr[local] + 2 * c_arr[local] * current_load[local]\n                inc_costs.append((inc_cost, local))\n        \n        if not inc_costs:\n            break\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_idx = inc_costs[0][1]\n        \n        max_increase = max_arr[cheapest_idx] - current_load[cheapest_idx]\n        increase = min(remaining, max_increase)\n        current_load[cheapest_idx] += increase\n        remaining -= increase\n    \n    # Map dispatch to original units\n    for local, global_idx in idx_to_global.items():\n        p_output[global_idx] = current_load[local]\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Classify units into must-run (units forced online by min uptime/shutdown ramp), must-off (units forced offline by min downtime), and flexible units\n2. For committed units, compute feasible generation ranges using ramp constraints and min/max limits\n3. If undercommitted, activate additional flexible units by ascending average cost per MW at max output \n4. If overcommitted, deactivate expensive flexible units by descending average cost per MW at min output\n5. Perform constrained economic dispatch: \n   a) Set initial outputs at minimum feasible levels\n   b) Allocate remaining load by ascending incremental cost within ramp/output constraints\n6. Return schedule as 2D array with commitment states and dispatch levels\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    current_load = load[0]\n    next_load = load[1] if len(load) > 1 else current_load\n\n    n_units = len(units_info)\n    u_out = [0] * n_units\n    p_out = [0] * n_units\n    \n    # Extract unit attributes\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    t_on_min = [u['t_on_min_i'] for u in units_info]\n    t_off_min = [u['t_off_min_i'] for u in units_info]\n    s = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n\n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flex_on = []  # Flexible and currently online\n    flex_off = []  # Flexible and currently offline\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Previously online\n            if t_prev[i] < t_on_min[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n            else:\n                flex_on.append(i)\n        else:  # Previously offline\n            if -t_prev[i] < t_off_min[i]:\n                must_off.append(i)\n            else:\n                flex_off.append(i)\n\n    # Initially commit must-run and flexible online units\n    committed = set(must_run + flex_on)\n\n    # Step 2: Compute feasible output ranges\n    min_feasible = [0] * n_units\n    max_feasible = [0] * n_units\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Online in previous period\n            min_feasible[i] = max(p_min[i], p_prev[i] - p_down[i])\n            max_feasible[i] = min(p_max[i], p_prev[i] + p_up[i])\n        else:  # Offline in previous period\n            min_feasible[i] = p_min[i]\n            max_feasible[i] = min(p_max[i], p_start[i])\n\n    # Step 3: Under-commitment handling\n    total_min = sum(min_feasible[i] for i in committed)\n    total_max = sum(max_feasible[i] for i in committed)\n    \n    if total_max < current_load:\n        # Calculate average cost per MW at max output\n        avg_costs = []\n        for i in flex_off:\n            total_cost = s[i] + a[i] + b[i] * p_max[i] + c[i] * (p_max[i] ** 2)\n            avg_cost = total_cost / p_max[i]\n            avg_costs.append((i, avg_cost))\n        \n        # Sort flexible offline units by cost ascending\n        avg_costs.sort(key=lambda x: x[1])\n        \n        # Activate units until meeting load\n        for i, _ in avg_costs:\n            if total_max >= current_load:\n                break\n            committed.add(i)\n            flex_off.remove(i)\n            total_min += min_feasible[i]\n            total_max += max_feasible[i]\n\n    # Step 4: Over-commitment handling\n    if total_min > current_load:\n        # Calculate average cost per MW at min output\n        avg_costs = []\n        for i in flex_on:\n            total_cost = a[i] + b[i] * p_min[i] + c[i] * (p_min[i] ** 2)\n            avg_cost = total_cost / p_min[i]\n            avg_costs.append((i, avg_cost))\n        \n        # Sort flexible online units by cost descending\n        avg_costs.sort(key=lambda x: x[1], reverse=True)\n        \n        # Deactivate expensive units\n        for i, _ in avg_costs:\n            new_min = total_min - min_feasible[i]\n            new_max = total_max - max_feasible[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed.remove(i)\n                flex_on.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= current_load:\n                    break\n\n    # Step 5a: Initialize dispatch at minimum feasible levels\n    p_dispatch = {}\n    remaining_load = current_load\n    for i in committed:\n        p_dispatch[i] = min_feasible[i]\n        remaining_load -= min_feasible[i]\n    \n    # Step 5b: Allocate remaining load by incremental cost\n    while remaining_load > 0:\n        candidates = []\n        for i in committed:\n            if p_dispatch[i] < max_feasible[i]:\n                inc_cost = 2 * c[i] * p_dispatch[i] + b[i]\n                candidates.append((i, inc_cost))\n        \n        if not candidates:\n            break\n            \n        # Find unit with smallest incremental cost\n        i, _ = min(candidates, key=lambda x: x[1])\n        \n        # Increase output within limits\n        max_increase = max_feasible[i] - p_dispatch[i]\n        increase = min(remaining_load, max_increase)\n        p_dispatch[i] += increase\n        remaining_load -= increase\n\n    # Step 6: Build output schedule\n    for i in range(n_units):\n        if i in committed:\n            u_out[i] = 1\n            p_out[i] = p_dispatch.get(i, 0)\n        else:\n            u_out[i] = 0\n            p_out[i] = 0\n\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0355884996,
          "fitness": 0.0178300959
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-run (unsatisfied min-up time or unable to shutdown due to ramp constraints), flexible on units, and offline units.\n2. Form initial commitment of must-run and flexible on units.\n3. Compute feasible min/max outputs considering ramp limits for committed units.\n4. If load < total min output:\n   - Set must-run/flexible-on units to min outputs (over-generation unavoidable)\n5. If load > total max output:\n   - Activate additional offline units sorted by incremental cost at their min output\n   - Update total capacity after each activation\n   - If still insufficient, set all committed units to max outputs\n6. Else (load within feasible range):\n   - Allocate min outputs to all committed units\n   - Distribute remaining load among committed units sorted by incremental cost\n7. Set uncommitted units to offline state (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    committed_indices = []\n    must_run_indices = []\n    \n    # Step 1: Classify must-run units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run_indices.append(i)\n            else:\n                min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_shutdown = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'], unit['p_shut_i'])\n                if min_out > max_shutdown:\n                    must_run_indices.append(i)\n    \n    # Form initial commitment (must-run + flexible on units)\n    committed_indices = must_run_indices.copy()\n    for i in range(n_units):\n        if i not in must_run_indices and units_info[i]['u_i_0'] == 1:\n            committed_indices.append(i)\n    \n    # Compute min/max outputs for all units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(min_outputs[i] for i in committed_indices)\n    total_max = sum(max_outputs[i] for i in committed_indices)\n    current_load = load[0]\n    \n    # Step 4: Over-generation case\n    if current_load < total_min:\n        for i in committed_indices:\n            u_out[i] = 1\n            p_out[i] = min_outputs[i]\n        return np.array([u_out, p_out])\n    \n    # Step 5: Under-generation case\n    if current_load > total_max:\n        candidate_units = []\n        for i in range(n_units):\n            if i not in committed_indices and units_info[i]['u_i_0'] == 0:\n                if -units_info[i]['t_i_0'] >= units_info[i]['t_off_min_i']:\n                    candidate_units.append(i)\n        \n        # Sort candidates by incremental cost at min output\n        candidate_units.sort(key=lambda i: 2*units_info[i]['c_i']*min_outputs[i] + units_info[i]['b_i'])\n        \n        # Activate units until capacity sufficient or none left\n        for i in candidate_units:\n            committed_indices.append(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            if total_max >= current_load:\n                break\n        \n        # If still insufficient, set to max output\n        if total_max < current_load:\n            for i in committed_indices:\n                u_out[i] = 1\n                p_out[i] = max_outputs[i]\n            return np.array([u_out, p_out])\n    \n    # Step 6: Dispatch within feasible range\n    # Allocate min outputs\n    for i in committed_indices:\n        u_out[i] = 1\n        p_out[i] = min_outputs[i]\n    residual = current_load - total_min\n    \n    # Sort by incremental cost\n    disp_order = sorted(committed_indices, key=lambda i: 2*units_info[i]['c_i']*p_out[i] + units_info[i]['b_i'])\n    \n    # Distribute residual load\n    for i in disp_order:\n        if residual <= 0:\n            break\n        headroom = max_outputs[i] - p_out[i]\n        add_load = min(headroom, residual)\n        p_out[i] += add_load\n        residual -= add_load\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0375214362,
          "fitness": 0.0187965642
     },
     {
          "name": "refined_commit_units_heuristic",
          "algorithm": "1. Classify units into must-run (based on min up-time and shutdown ramp limits), must-off (based on min down-time), and flexible units.\n2. Compute feasible output ranges for must-run and committed flexible units considering ramp constraints.\n3. If load exceeds available capacity, activate flexible units by ascending order of average cost at min output (including startup cost).\n4. Perform constrained economic dispatch using incremental cost sorting to allocate load within feasible ranges.\n5. Handle under/over-generation by adjusting committed units and ensuring physical constraints are satisfied.\n\n",
          "code": "import numpy as np\n\ndef refined_commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    next_load = load[1]  # Forecasted for next period (consideration only)\n\n    # Initialize data structures\n    n_units = len(units_info)\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        # Must-run if online and (min uptime not satisfied or output > shutdown ramp)\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        # Must-off if offline and min downtime not satisfied\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n        # Exception: Must-off also has min downtime not satisfied\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            must_off[i] = True\n            flexible[i] = False\n\n    # Default: Keep flexible units in previous state\n    u = np.array([1 if must_run[i] or (flexible[i] and unit['u_i_0']==1) else 0 \n                  for i, unit in enumerate(units_info)])\n    p = np.zeros(n_units)\n\n    # Compute min/max power considering current state\n    min_power, max_power = np.zeros(n_units), np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if must_run[i] or (flexible[i] and unit['u_i_0'] == 1):\n            min_power[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_power[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif flexible[i] and unit['u_i_0'] == 0 and u[i] == 1:  # Newly activated\n            min_power[i] = unit['p_min_i']\n            max_power[i] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Check capacity constraints\n    total_min = sum(min_power)\n    total_max = sum(max_power)\n\n    # If under-committed, activate additional units\n    if total_max < current_load:\n        # Calculate power deficit\n        deficit = current_load - total_max\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if flexible[i] and not u[i] and not must_off[i]:\n                # Startup ramp constraint\n                max_activation = min(unit['p_max_i'], unit['p_start_i'])\n                # Avoid negative min values\n                min_activation = max(unit['p_min_i'], 0)\n                avg_cost = (unit['s_i'] + unit['b_i'] * min_activation + \n                            unit['c_i'] * min_activation**2) / min_activation if min_activation > 0 else float('inf')\n                # Store for sorting\n                candidates.append((i, max_activation, avg_cost))\n\n        # Sort by average cost ascending\n        candidates.sort(key=lambda x: x[2])\n        for i, max_act, cost in candidates:\n            if deficit <= 0:\n                break\n            u[i] = 1\n            min_power[i] = max(units_info[i]['p_min_i'], 0)\n            max_power[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            total_min += min_power[i]\n            total_max += max_act\n            deficit -= max_act\n\n    # If over-committed, adjust outputs within constraints\n    if current_load < total_min:\n        # This may leave a gap if minimum outputs are enforced\n        for i in range(n_units):\n            p[i] = min_power[i] if u[i] else 0\n    else:\n        # Calculate surplus load to distribute\n        surplus = current_load - total_min\n        if surplus < 0:\n            surplus = 0  # Already handled by previous condition, defensive\n        # Calculate available headroom per unit\n        headrooms = [max_power[i] - min_power[i] for i in range(n_units)]\n        total_headroom = sum(headrooms)\n        \n        # Initialize outputs to minimum\n        p = min_power.copy()\n        \n        # Use incremental cost for allocation\n        costs = []\n        for i, unit in enumerate(units_info):\n            if u[i]:\n                # Current incremental cost at min output (using derivative)\n                inc_cost = 2 * unit['c_i'] * min_power[i] + unit['b_i']\n                costs.append((i, inc_cost))\n        \n        # Sort by incremental cost ascending\n        costs.sort(key=lambda x: x[1])\n        for i, ic in costs:\n            if surplus <= 0:\n                break\n            to_allocate = min(surplus, headrooms[i])\n            p[i] += to_allocate\n            surplus -= to_allocate\n\n        # Final adjustment if distribution was insufficient\n        if surplus > 0:\n            # Distribute remaining to units with available capacity\n            for i, headroom in enumerate(headrooms):\n                if p[i] < max_power[i]:\n                    additional = min(surplus, max_power[i] - p[i])\n                    p[i] += additional\n                    surplus -= additional\n                    if surplus <= 0:\n                        break\n            # If still surplus, we have under-generation (shouldn't happen normally)\n            if surplus > 0:\n                print(f\"Warning: Couldn't allocate {surplus} MW\")\n\n    # Build output array\n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.041064632,
          "fitness": 0.0205681621
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n  2. Initialize commitment states for must-run (on), must-off (off), and flexible (maintain current state)\n  3. Adjust commitment for flexible units if needed: turn on additional units by full-load average cost if undercommitted, turn off flexible units by average cost if overcommitted\n  4. Perform constrained economic dispatch using incremental cost sorting to allocate load within ramp and output limits\n  5. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    min_up = [u['t_on_min_i'] for u in units_info]\n    min_down = [u['t_off_min_i'] for u in units_info]\n    startup_cost = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    \n    # Initialize arrays\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    # Classify units\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if abs(t_prev[i]) < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    for i in range(n_units):\n        if must_run[i]:\n            u_current[i] = 1\n        elif must_off[i]:\n            u_current[i] = 0\n        else:\n            u_current[i] = u_prev[i]\n    \n    # Calculate available capacity for committed units\n    min_outputs = [0] * n_units\n    max_outputs = [0] * n_units\n    for i in range(n_units):\n        if u_current[i] == 1:\n            if u_prev[i] == 1:\n                min_outputs[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_outputs[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_outputs[i] = p_min[i]\n                max_outputs[i] = min(p_max[i], p_start[i])\n        else:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    total_min = sum(min_outputs)\n    total_max = sum(max_outputs)\n    \n    # Adjust commitment if needed\n    committed_indices = [i for i in range(n_units) if u_current[i] == 1]\n    flexible_off = [i for i in range(n_units) if not must_run[i] and not must_off[i] and u_current[i] == 0]\n    flexible_on = [i for i in range(n_units) if not must_run[i] and u_current[i] == 1]\n    \n    # Under-commitment case\n    if total_max < current_load:\n        # Sort by full-load average cost including startup\n        costs = []\n        for i in flexible_off:\n            avg_cost = (a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2) + startup_cost[i]) / p_max[i]\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1])\n        \n        for i, _ in costs:\n            if total_max >= current_load:\n                break\n            u_current[i] = 1\n            min_outputs[i] = p_min[i]\n            max_outputs[i] = min(p_max[i], p_start[i])\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            flexible_on.append(i)\n    \n    # Over-commitment case\n    if total_min > current_load:\n        # Sort by average cost at min output\n        costs = []\n        for i in flexible_on:\n            cost_val = a[i] + b[i]*min_outputs[i] + c[i]*(min_outputs[i]**2)\n            avg_cost = cost_val / min_outputs[i] if min_outputs[i] > 0 else float('inf')\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in costs:\n            if total_min <= current_load:\n                break\n            u_current[i] = 0\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    # Economic dispatch\n    committed_idx = [i for i in range(n_units) if u_current[i] == 1]\n    # Set initial output to min\n    for i in committed_idx:\n        p_current[i] = min_outputs[i]\n    \n    remaining_load = current_load - sum(min_outputs)\n    # Calculate incremental costs\n    inc_costs = []\n    for i in committed_idx:\n        inc_cost = b[i] + 2*c[i]*min_outputs[i]\n        inc_costs.append((i, inc_cost))\n    inc_costs.sort(key=lambda x: x[1])\n    \n    # Distribute remaining load\n    for i, _ in inc_costs:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, max_outputs[i] - min_outputs[i])\n        p_current[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Format output\n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.0515,
          "fitness": 0.02584
     }
]