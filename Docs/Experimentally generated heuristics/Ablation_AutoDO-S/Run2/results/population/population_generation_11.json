[
     {
          "name": "rolling_commit_dispatch",
          "algorithm": "1. Classify units into must-run (violating min-up/shutdown ramp), must-off (violating min-down), and flexible categories\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible maintain previous state\n3. Compute maximum deliverable power considering ramp limits and startup constraints\n4. If insufficient capacity, turn on flexible units sorted by average cost at minimum output\n5. If over-committed, turn off highest average-cost flexible units while maintaining sufficient capacity\n6. Dispatch load using greedy incremental cost optimization:\n   a) Set each committed unit to its feasible minimum output\n   b) Incrementally increase output of cheapest units first until meeting demand\n   c) Respect individual unit ramp and output constraints\n7. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units and set initial commitment\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Initial commitment states\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate current available capacity\n    max_cap = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # Newly started\n                max_cap[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                max_cap[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_max = np.sum(max_cap)\n    \n    # Add units if capacity insufficient\n    candidates = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 0:  # Flexible and currently off\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2 + unit['s_i']) / p_min\n            cap = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, cost, cap))\n    \n    candidates.sort(key=lambda x: x[1])\n    for idx, cost, cap in candidates:\n        if total_max < current_load:\n            u[idx] = 1\n            total_max += cap\n        else:\n            break\n    \n    # Remove expensive units if over-committed\n    candidates_off = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 1:  # Flexible and online\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            \n            if unit['u_i_0'] == 0:  # Newly started\n                cap = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            candidates_off.append((i, cost, cap))\n    \n    candidates_off.sort(key=lambda x: x[1], reverse=True)\n    for idx, cost, cap in candidates_off:\n        if total_max - cap >= current_load:\n            u[idx] = 0\n            total_max -= cap\n    \n    # Economic dispatch\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    p_dispatch = np.zeros(n_units)\n    allocated = 0.0\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # New start\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_dispatch[i] = min_bound[i]\n            allocated += min_bound[i]\n    \n    remaining = current_load - allocated\n    if remaining < 0:\n        return np.vstack((u, p_dispatch))\n    \n    # Distribute remaining load\n    while remaining > 0:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and p_dispatch[i] < max_bound[i]:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_dispatch[i]\n                headroom = max_bound[i] - p_dispatch[i]\n                candidates.append((i, inc_cost, headroom))\n        \n        if not candidates:\n            break\n            \n        candidates.sort(key=lambda x: x[1])\n        i, inc_cost, headroom = candidates[0]\n        amount = min(remaining, headroom)\n        p_dispatch[i] += amount\n        allocated += amount\n        remaining -= amount\n    \n    return np.vstack((u, p_dispatch))",
          "from": "mutation",
          "gap_power_rate": 0.0051709106,
          "gap_price_rate": 0.0086673205,
          "fitness": 0.0069191156
     },
     {
          "name": "enhanced_refined_commit_dispatch",
          "algorithm": "1. Classify units as must-run (if online and (min-up time unfulfilled or previous output exceeds shutdown capacity)), must-off (if offline and min-down time unfulfilled), or flexible (others)\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible units retain previous state\n3. Compute feasible output ranges (considering ramp and startup constraints) and total min/max capacity\n4. If current load > total max capacity:\n    a. Calculate activation priority as (s_i + a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i\n    b. Activate offline flexible units in ascending priority order until sufficient capacity\n5. If total min capacity > current load:\n    a. Calculate deactivation priority as (a_i + b_i*min_i + c_i*min_i\u00b2) / min_i\n    b. Deactivate online flexible units in descending priority order while maintaining load coverage\n6. Dispatch load via incremental cost optimization:\n    a. Set committed units to min feasible output\n    b. Allocate remaining load by ascending incremental cost within unit constraints\n7. Return commitment states and power outputs as 2D array\n",
          "code": "import numpy as np\n\ndef enhanced_refined_commit_dispatch(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    load_current = load[0]\n    \n    # Step 1: Classify units and initialize commitment\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for unit in units:\n        if unit['u_i_0'] == 1:  # previously online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(unit)\n            else:\n                flexible.append(unit)\n        else:  # previously offline\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_run:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n    for unit in flexible:\n        unit['u_i'] = unit['u_i_0']\n    \n    # Reset dispatch parameters\n    for unit in units:\n        unit['min_i'] = 0.0\n        unit['max_i'] = 0.0\n        unit['dispatch'] = 0.0\n    \n    # Compute feasible ranges for committed units\n    committed_units = [u for u in units if u['u_i'] == 1]\n    total_min, total_max = 0.0, 0.0\n    for unit in committed_units:\n        if unit['u_i_0'] == 1:  # Continuously online\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Started in current period\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    # Activation for insufficient capacity\n    offline_flex = [u for u in flexible if u['u_i'] == 0]\n    activation_candidates = []\n    for unit in offline_flex:\n        p_min = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2\n        avg_cost = total_cost / p_min\n        activation_candidates.append((avg_cost, unit))\n    \n    activation_candidates.sort(key=lambda x: x[0])\n    for _, unit in activation_candidates:\n        if total_max >= load_current:\n            break\n        unit['u_i'] = 1\n        min_i = unit['p_min_i']\n        max_i = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        total_min += min_i\n        total_max += max_i\n        committed_units.append(unit)\n    \n    # Deactivation for over-commitment\n    online_flex = [u for u in committed_units if u in flexible]\n    deactivation_candidates = []\n    for unit in online_flex:\n        min_i = unit['min_i']\n        base_cost = unit['a_i'] + unit['b_i']*min_i + unit['c_i']*min_i**2\n        avg_cost = base_cost / min_i\n        deactivation_candidates.append((avg_cost, unit))\n    \n    deactivation_candidates.sort(key=lambda x: x[0], reverse=True)\n    for _, unit in deactivation_candidates:\n        new_min = total_min - unit['min_i']\n        new_max = total_max - unit['max_i']\n        if new_max < load_current:\n            continue\n        if new_min >= load_current:\n            continue  # Over-commitment remains\n        unit['u_i'] = 0\n        unit['min_i'] = 0.0\n        unit['max_i'] = 0.0\n        total_min = new_min\n        total_max = new_max\n        committed_units.remove(unit)\n    \n    # Dispatch among committed units\n    for unit in committed_units:\n        unit['dispatch'] = unit['min_i']\n    current_total = total_min\n    remaining = load_current - current_total\n    \n    available_units = [u for u in committed_units if u['dispatch'] < u['max_i'] - 1e-5]\n    while remaining > 1e-5 and available_units:\n        inc_costs = []\n        for unit in available_units:\n            inc = unit['b_i'] + 2 * unit['c_i'] * unit['dispatch']\n            inc_costs.append((inc, unit))\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_unit = inc_costs[0][1]\n        max_addition = cheapest_unit['max_i'] - cheapest_unit['dispatch']\n        allocation = min(remaining, max_addition)\n        cheapest_unit['dispatch'] += allocation\n        remaining -= allocation\n        if cheapest_unit['dispatch'] >= cheapest_unit['max_i'] - 1e-5:\n            available_units.remove(cheapest_unit)\n    \n    # Set outputs for uncommitted units\n    for unit in units:\n        if unit['u_i'] == 0:\n            unit['dispatch'] = 0.0\n    \n    u_vector = [unit['u_i'] for unit in units]\n    p_vector = [unit['dispatch'] for unit in units]\n    schedules = np.array([u_vector, p_vector], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0060521947,
          "gap_price_rate": 0.0089602466,
          "fitness": 0.0075062207
     },
     {
          "name": "refined_rolling_commit_dispatch",
          "algorithm": "1. Classify units into must-run (violating min-up or shutdown ramp limits), must-off (violating min-down), and flexible categories\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible units retain prior state\n3. Compute feasible power ranges considering ramp constraints and startup/shutdown limitations\n4. For under-commitment (total max capacity < load):\n   a. Activate flexible offline units by ascending amortized cost metric:\n      (s_i/(t_on_min_i * p_min_i) + (a_i + b_i * p_min_i + c_i * p_min_i\u00b2)/p_min_i\n   b. Update unit ranges: new units have [p_min_i, min(p_max_i, p_start_i)]\n5. For over-commitment (total min output > load):\n   a. Deactivate flexible online units by descending average cost at min output\n   b. Maintain sufficient max capacity (\u2265 load) after deactivation\n6. Dispatch load using greedy incremental cost optimization:\n   a. Set committed units to their feasible minimum outputs\n   b. Allocate residual load to units with lowest marginal cost:\n      b_i + 2*c_i*p_i\n   c. Increase outputs until meeting load or reaching unit limits\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    \n    # Initialize arrays\n    n_units = len(units_info)\n    u = [0] * n_units\n    min_output = [0] * n_units\n    max_output = [0] * n_units\n    p_out = [0] * n_units\n    must_run = []\n    must_off = []\n\n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitments\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate initial feasible ranges\n    for i in range(n_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                min_output[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                min_output[i] = units_info[i]['p_min_i']\n                max_output[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            min_output[i] = max_output[i] = 0\n    \n    total_min = sum(min_output)\n    total_max = sum(max_output)\n\n    # Handle under-commitment\n    flexible_offline = [i for i in range(n_units) if (i not in must_run) and (i not in must_off) and (u[i] == 0)]\n    activation_list = []\n    for i in flexible_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        if p_min <= 0:\n            metric = float('inf')\n        else:\n            startup_component = unit['s_i'] / (unit['t_on_min_i'] * p_min)\n            prod_cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            metric = startup_component + prod_cost\n        activation_list.append((i, metric))\n    \n    activation_list.sort(key=lambda x: x[1])\n    \n    activated_units = []\n    for idx, metric in activation_list:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        min_output[idx] = units_info[idx]['p_min_i']\n        max_output[idx] = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n        total_min += min_output[idx]\n        total_max += max_output[idx]\n        activated_units.append(idx)\n    \n    # Handle over-commitment\n    flexible_online = [i for i in range(n_units) if (i not in must_run) and (i not in must_off) and (u[i] == 1) and i not in activated_units]\n    deactivation_list = []\n    for i in flexible_online:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        if p_min <= 0:\n            metric = float('-inf')\n        else:\n            metric = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n        deactivation_list.append((i, metric))\n    \n    deactivation_list.sort(key=lambda x: x[1], reverse=True)\n    \n    for idx, metric in deactivation_list:\n        if total_min - min_output[idx] <= current_load and total_max - max_output[idx] >= current_load:\n            u[idx] = 0\n            total_min -= min_output[idx]\n            total_max -= max_output[idx]\n            min_output[idx] = max_output[idx] = 0\n        if total_min <= current_load:\n            break\n\n    # Set initial outputs\n    for i in range(n_units):\n        p_out[i] = min_output[i] if u[i] else 0\n    \n    residual = current_load - sum(p_out)\n    candidates = [i for i in range(n_units) if u[i] == 1 and p_out[i] < max_output[i]]\n    \n    # Greedy incremental cost allocation\n    while residual > 0 and candidates:\n        cost_list = []\n        for i in candidates:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n            cost_list.append((i, marginal_cost))\n        \n        cost_list.sort(key=lambda x: x[1])\n        idx = cost_list[0][0]\n        headroom = min(residual, max_output[idx] - p_out[idx])\n        p_out[idx] += headroom\n        residual -= headroom\n        if residual <= 0:\n            break\n        if p_out[idx] >= max_output[idx] - 1e-5:\n            candidates.remove(idx)\n    \n    return np.array([u, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0004196099,
          "gap_price_rate": 0.0172514453,
          "fitness": 0.0088355276
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "enhanced_amortized_commit_dispatch",
          "algorithm": "1. Classify units:  \n   - Must-run: online units with unsatisfied min-up time OR previous output > ramp-down limit  \n   - Must-off: offline units with unsatisfied min-down time  \n   - Flexible: remaining units  \n2. Initialize commitments: must-run=ON, must-off=OFF, flexible=previous state  \n3. Compute feasible output ranges considering ramp constraints and startup limitations  \n4. If under-committed:  \n   - Activate offline flexible units using amortized startup cost metric (startup cost spread over min-up time)  \n   - Prioritize units with lowest amortized cost  \n   - Limit new units to startup ramp capacity  \n5. If over-committed:  \n   - Deactivate online flexible units  \n   - Prioritize units with highest average cost at minimum output  \n   - Maintain sufficient capacity  \n6. Dispatch load via economic dispatch:  \n   - Set committed units to feasible minimum output  \n   - Allocate residual load by ascending marginal cost  \n   - Enforce individual unit constraints in dispatch  \n\n",
          "code": "import numpy as np\n\ndef enhanced_amortized_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units and initialize commitments\n    must_run = []\n    must_off = []\n    flexible = []\n    \n    for i, unit in enumerate(units_info):\n        t_i_0 = unit['t_i_0']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        \n        # Must-run: online with unsatisfied min-up time OR can't ramp down safely\n        if u_i_0 == 1 and (t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_down_i']):\n            u[i] = 1\n            must_run.append(i)\n        # Must-off: offline with unsatisfied min-down time\n        elif u_i_0 == 0 and -t_i_0 < unit['t_off_min_i']:\n            u[i] = 0\n            must_off.append(i)\n        # Flexible units\n        else:\n            u[i] = u_i_0\n            flexible.append(i)\n    \n    # Initialize feasible power ranges for committed units\n    min_feasible = np.zeros(n_units)\n    max_feasible = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:  # Was online\n                min_feasible[i] = max(units_info[i]['p_min_i'], \n                                      units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                max_feasible[i] = min(units_info[i]['p_max_i'], \n                                      units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:  # Newly started\n                min_feasible[i] = units_info[i]['p_min_i']\n                max_feasible[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n    \n    total_min = np.sum(min_feasible)\n    total_max = np.sum(max_feasible)\n    \n    # Handle under-commitment\n    offline_flex = [i for i in flexible if u[i] == 0]\n    if total_max < current_load and offline_flex:\n        # Calculate amortized cost metric\n        amortized_costs = []\n        for i in offline_flex:\n            startup_cost = units_info[i]['s_i']\n            p_min_i = units_info[i]['p_min_i']\n            a_i, b_i, c_i = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            min_up = max(1, units_info[i]['t_on_min_i'])  # Avoid division by zero\n            prod_cost = a_i + b_i * p_min_i + c_i * p_min_i ** 2\n            amortized_costs.append((startup_cost/min_up + prod_cost) / p_min_i)\n        \n        # Activate by ascending amortized cost\n        priority_order = np.argsort(amortized_costs)\n        for idx in priority_order:\n            i = offline_flex[idx]\n            u[i] = 1\n            min_feasible[i] = units_info[i]['p_min_i']\n            max_feasible[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            \n            total_min = total_min - min_feasible[i] + units_info[i]['p_min_i']\n            total_max = total_max + min_feasible[i] + max_feasible[i]\n            \n            if total_max >= current_load:\n                break\n    \n    # Handle over-commitment\n    online_flex = [i for i in flexible if u[i] == 1]\n    if total_min > current_load and online_flex:\n        # Calculate average cost at min output\n        avg_costs = []\n        for i in online_flex:\n            a_i, b_i, c_i = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            p_min_i = min_feasible[i]\n            avg_costs.append((a_i + b_i * p_min_i + c_i * p_min_i ** 2) / p_min_i)\n        \n        # Deactivate by descending average cost\n        priority_order = np.argsort(avg_costs)[::-1]\n        for idx in priority_order:\n            i = online_flex[idx]\n            # Check if we can maintain sufficient capacity\n            remaining_max = total_max - max_feasible[i]\n            if remaining_max >= current_load:\n                u[i] = 0\n                min_feasible[i] = 0\n                max_feasible[i] = 0\n                total_min -= units_info[i]['p_min_i']\n                total_max = remaining_max\n                \n                if total_min <= current_load:\n                    break\n    \n    # Economic dispatch for committed units\n    committed_idx = [i for i in range(n_units) if u[i] == 1]\n    p[:] = min_feasible  # Set to minimum feasible\n    \n    residual = current_load - np.sum(p)\n    \n    # Dispatch residual load by marginal cost\n    while residual > 1e-6:  # Tolerance for floating point\n        mc = []  # Marginal costs\n        capacities = []\n        indices = []\n        \n        for i in committed_idx:\n            current_p = p[i]\n            if current_p < max_feasible[i]:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_p\n                mc.append(marginal_cost)\n                capacities.append(max_feasible[i] - current_p)\n                indices.append(i)\n        \n        if not mc: break  # No capacity to increase\n        \n        min_mc = np.min(mc)\n        min_mc_idx = np.argmin(mc)\n        i_best = indices[min_mc_idx]\n        \n        # Increase output by minimum needed or full capacity\n        delta = min(residual, capacities[min_mc_idx])\n        p[i_best] += delta\n        residual -= delta\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0043142423,
          "gap_price_rate": 0.0217001489,
          "fitness": 0.0130071956
     },
     {
          "name": "enhanced_rolling_commit_dispatch",
          "algorithm": "1. Classify units as must-run if they are online and haven't met min-up time or exceed shutdown capacity\n2. Classify units as must-off if they are offline and haven't met min-down time\n3. Initialize commitments: must-run to ON, must-off to OFF, flexible maintain prior state\n4. Compute feasible output ranges considering ramp limits and startup/shutdown constraints\n5. If under-committed:\n   a. Activate offline units by amortized cost metric over min-up time \n   b. Cap new units at startup ramp limit\n6. If over-committed:\n   a. Deactivate flexible online units by descending average cost\n   b. Verify sufficient capacity remains after deactivation\n7. Perform ramp-constrained economic dispatch:\n   a. Set units to min feasible output\n   b. Distribute residual load by ascending marginal cost\n   c. Strictly respect ramp rate limits\n8. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Initialize state arrays\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units)\n    min_feasible = np.zeros(num_units)\n    max_feasible = np.zeros(num_units)\n    must_run = np.zeros(num_units, dtype=bool)\n    must_off = np.zeros(num_units, dtype=bool)\n    flexible = np.zeros(num_units, dtype=bool)\n    \n    # Classify units and set initial commitment\n    for i, unit in enumerate(units_info):\n        # Must-run conditions\n        if unit['u_i_0'] == 1 and (unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']):\n            u[i] = 1\n            must_run[i] = True\n        # Must-off conditions\n        elif unit['u_i_0'] == 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n            u[i] = 0\n            must_off[i] = True\n        # Flexible units retain prior state\n        else:\n            u[i] = unit['u_i_0']\n            flexible[i] = True\n    \n    # Calculate feasible output ranges\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:  # Committed units\n            if unit['u_i_0'] == 1:  # Previously online\n                min_feasible[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_feasible[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Newly started\n                min_feasible[i] = unit['p_min_i']\n                max_feasible[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # Offline units\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n    \n    # Check system capacity\n    total_min = np.sum(min_feasible)\n    total_max = np.sum(max_feasible)\n    \n    # Handle under-commitment\n    if total_max < current_load:\n        # Create list of candidate units for activation\n        activation_candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 0 and flexible[i]:\n                amortized_cost = (unit['s_i']/(unit['t_on_min_i']*unit['p_min_i']) +\n                                (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2)/unit['p_min_i'])\n                activation_candidates.append((amortized_cost, i))\n        \n        # Activate by ascending amortized cost\n        activation_candidates.sort()\n        for _, idx in activation_candidates:\n            u[idx] = 1\n            min_feasible[idx] = units_info[idx]['p_min_i']\n            max_feasible[idx] = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            total_min += min_feasible[idx]\n            total_max += max_feasible[idx]\n            if total_max >= current_load:\n                break\n    \n    # Handle over-commitment\n    if total_min > current_load:\n        # Create list of candidate units for deactivation\n        deactivation_candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and flexible[i]:\n                avg_cost = (unit['a_i'] + unit['b_i']*min_feasible[i] + unit['c_i']*min_feasible[i]**2) / min_feasible[i]\n                deactivation_candidates.append((avg_cost, i))\n        \n        # Deactivate by descending average cost\n        deactivation_candidates.sort(reverse=True)\n        for _, idx in deactivation_candidates:\n            # Check if deactivation maintains feasibility\n            if (total_min - min_feasible[idx] <= current_load and\n                total_max - max_feasible[idx] >= current_load):\n                u[idx] = 0\n                min_feasible[idx] = 0\n                max_feasible[idx] = 0\n                total_min -= units_info[idx]['p_min_i']\n                total_max -= max_feasible[idx]\n            if total_min <= current_load:\n                break\n    \n    # Economic dispatch\n    residual_load = current_load - np.sum(min_feasible)\n    \n    # Initialize outputs to minimum feasible\n    p = min_feasible.copy()\n    \n    # Distribute residual load by incremental cost\n    while residual_load > 0:\n        min_increment = float('inf')\n        best_unit = -1\n        \n        # Find unit with smallest marginal cost\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and p[i] < max_feasible[i]:\n                marginal_cost = unit['b_i'] + 2 * unit['c_i'] * p[i]\n                if marginal_cost < min_increment:\n                    min_increment = marginal_cost\n                    best_unit = i\n        \n        # Allocate to best unit\n        if best_unit >= 0:\n            unit_increment = min(residual_load,\n                                max_feasible[best_unit] - p[best_unit],\n                                units_info[best_unit]['p_up_i'])\n            p[best_unit] += unit_increment\n            residual_load -= unit_increment\n        else:\n            break\n    \n    # Set offline units to zero\n    for i in range(num_units):\n        if u[i] == 0:\n            p[i] = 0\n    \n    # Prepare output array\n    schedules[0] = u\n    schedules[1] = p\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0338022138,
          "fitness": 0.0169659461
     },
     {
          "name": "improved_rolling_commit",
          "algorithm": "1. Classify units as must-run, must-off, or flexible based on min up/down times and shutdown constraints.\n2. Compute feasible output ranges for online units considering ramp constraints.\n3. If current load exceeds online capacity, activate offline units in cost-merit order with next-period penalty handling.\n4. If minimum output exceeds load, handle over-generation by setting to minimum outputs.\n5. Dispatch load among online units using merit-order by incremental cost within feasible ranges.\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commit(units_info, load):\n    # Step 0: Parse inputs\n    current_load = load[0]\n    forecast_next = load[1]\n    \n    # Convert units_info to list of dicts for mutability\n    units = [dict(unit) for unit in units_info]\n    n_units = len(units)\n    \n    # Initialize schedules\n    u_schedule = [0] * n_units\n    p_schedule = [0.0] * n_units\n    \n    # Step 1: Classify units\n    must_run = []\n    must_off = []\n    flexible_online = []  # Currently online\n    flexible_offline = []  # Currently offline\n    \n    for i, unit in enumerate(units):\n        # Compute absolute down time\n        abs_down_time = -unit['t_i_0'] if unit['t_i_0'] < 0 else 0\n        \n        if unit['u_i_0'] == 1:\n            must_run_condition = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n            if must_run_condition:\n                must_run.append(i)\n            else:\n                flexible_online.append(i)\n        else:\n            must_off_condition = (abs_down_time < unit['t_off_min_i'])\n            if must_off_condition:\n                must_off.append(i)\n            else:\n                flexible_offline.append(i)\n    \n    # Step 2: Compute feasible output ranges for already online units\n    min_output = [0.0] * n_units\n    max_output = [0.0] * n_units\n    total_min, total_max = 0.0, 0.0\n    \n    # Process must-run and flexible_online\n    for i in must_run + flexible_online:\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_output[i] = min_p\n        max_output[i] = max_p\n        total_min += min_p\n        total_max += max_p\n    \n    # Track activated units\n    activated_offline = []\n    \n    # Step 3: Check generation capacity\n    if total_max < current_load:\n        # Need to activate offline units\n        deficit = current_load - total_max\n        # Precompute next period must-run minimum\n        next_period_must_run_min = 0\n        for i in must_run + flexible_online:\n            unit = units[i]\n            if (unit['t_i_0'] + 1) < unit['t_on_min_i']:\n                next_period_must_run_min += unit['p_min_i']\n        \n        # Calculate activation priority metric (amortized cost)\n        candidates_safe = []\n        candidates_penalized = []\n        \n        for i in flexible_offline:\n            unit = units[i]\n            # Metric: Amortized cost per MW over minimum up time\n            min_up = max(1, unit['t_on_min_i'])\n            cost_min_output = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n            amortized_cost = (unit['s_i'] + cost_min_output * min_up) / (unit['p_min_i'] * min_up)\n            \n            max_gen = min(unit['p_max_i'], unit['p_start_i'])\n            next_add = unit['p_min_i'] if unit['t_on_min_i'] > 1 else 0\n            \n            candidate = (amortized_cost, i, max_gen, next_add)\n            if (next_period_must_run_min + next_add) <= forecast_next:\n                candidates_safe.append(candidate)\n            else:\n                candidates_penalized.append(candidate)\n        \n        # Sort candidates\n        candidates_safe.sort(key=lambda x: x[0])\n        candidates_penalized.sort(key=lambda x: x[0])\n        candidates = candidates_safe + candidates_penalized\n        \n        # Activate units until deficit is covered\n        for cost, idx, max_gen, next_add in candidates:\n            if deficit <= 0:\n                break\n            activated_offline.append(idx)\n            min_output[idx] = units[idx]['p_min_i']\n            max_output[idx] = min(units[idx]['p_max_i'], units[idx]['p_start_i'])\n            total_min += min_output[idx]\n            total_max += max_output[idx]\n            deficit -= max_gen\n            # Update next period must-run min for subsequent candidates\n            next_period_must_run_min += next_add\n    \n    # Identify online units\n    online_units = must_run + flexible_online + activated_offline\n    # If over-generation (current_load < total_min), still proceed to dispatch\n    # Step 5: Economic dispatch\n    # Initialize dispatch at minimum output\n    for i in online_units:\n        u_schedule[i] = 1\n        p_schedule[i] = min_output[i]\n        units[i]['current_p'] = min_output[i]  # Track for increment\n    \n    remaining_load = current_load - total_min\n    \n    # Only dispatch if positive load to distribute\n    if remaining_load > 0:\n        # Priority list: incremental cost at current assignment\n        priority_list = []\n        for i in online_units:\n            if max_output[i] > min_output[i]:\n                # Derivative of cost: 2*c_i*p_i + b_i\n                incremental_cost = 2 * units[i]['c_i'] * units[i]['current_p'] + units[i]['b_i']\n                priority_list.append((incremental_cost, i))\n        \n        priority_list.sort(key=lambda x: x[0])\n        \n        # Distribute remaining load\n        for _, i in priority_list:\n            if remaining_load <= 0:\n                break\n            capacity_available = max_output[i] - units[i]['current_p']\n            allocate = min(remaining_load, capacity_available)\n            p_schedule[i] += allocate\n            units[i]['current_p'] += allocate\n            remaining_load -= allocate\n    \n    # Step 4 & 6: If under total_min (over-generation) or after dispatch\n    # If load < total_min, units already set to min_output\n    \n    # Format output\n    schedules = np.array([\n        u_schedule,\n        p_schedule\n    ], dtype=float)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0340369197,
          "fitness": 0.0170832991
     },
     {
          "name": "two_period_rolling_commit_dispatch",
          "algorithm": "1. Classify units as must-run (online violating min-up time or previous output > shutdown capacity), must-off (offline violating min-down time), or flexible\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible units retain prior state\n3. Compute feasible power ranges considering ramp constraints and startup/shutdown limitations\n4. For under-commitment (total max capacity < current load):\n   a. Calculate two-period amortized cost for offline flexible units: \n      (startup_cost + 2*a_i + 2*b_i*p_min_i + 2*c_i*p_min_i**2) / (2*p_min_i)\n   b. Activate units by ascending two-period cost until sufficient capacity\n   c. Update unit ranges: newly activated units have [p_min_i, min(p_max_i, p_start_i)]\n5. For over-commitment (total min output > current load):\n   a. Identify flexible online units that can be deactivated while maintaining:\n      - Remaining capacity >= current load\n      - Total min output after deactivation <= current load\n   b. Deactivate units by descending average production cost at min output\n6. Dispatch load using marginal cost optimization:\n   a. Set committed units to feasible minimum outputs\n   b. Allocate residual load to units with lowest marginal costs (b_i + 2*c_i*p_i)\n   c. Respect individual unit maximum limits and ramp constraints\n7. Return commitment states and power outputs for all units\n",
          "code": "import numpy as np\n\ndef two_period_rolling_commit_dispatch(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    u = [0] * n\n    min_p = [0] * n\n    max_p = [0] * n\n    must_run = [False] * n\n    must_off = [False] * n\n    flexible = [False] * n\n    online_units = []\n    \n    # Step 1: Classify units and initialize commitments\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run[i] = True\n                u[i] = 1\n            else:\n                flexible[i] = True\n                u[i] = 1\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off[i] = True\n                u[i] = 0\n            else:\n                flexible[i] = True\n                u[i] = 0\n    \n    # Step 2: Compute feasible output ranges\n    total_min, total_max = 0, 0\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:  # Online in previous period\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Newly activated\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            online_units.append(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Step 3: Under-commitment handling\n    offline_flexible = [i for i, unit in enumerate(units_info) if flexible[i] and u[i] == 0]\n    \n    if total_max < current_load and offline_flexible:\n        candidates = []\n        for i in offline_flexible:\n            unit = units_info[i]\n            min_val = unit['p_min_i']\n            cost1 = unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * (min_val ** 2)\n            cost2 = cost1  # Next period cost assumption\n            total_cost = unit['s_i'] + cost1 + cost2\n            amortized_cost = total_cost / (2 * min_val)\n            candidates.append((amortized_cost, i, min_val))\n        \n        candidates.sort(key=lambda x: x[0])\n        \n        for _, i, min_val in candidates:\n            if total_max >= current_load:\n                break\n                \n            max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            u[i] = 1\n            min_p[i] = min_val\n            max_p[i] = max_val\n            online_units.append(i)\n            total_min += min_val\n            total_max += max_val\n\n    # Step 4: Over-commitment handling\n    candidate_deact = []\n    for i in online_units:\n        if flexible[i] and not must_run[i]:\n            unit = units_info[i]\n            new_total_min = total_min - min_p[i]\n            new_total_max = total_max - max_p[i]\n            avg_cost = (unit['a_i'] + unit['b_i'] * min_p[i] + unit['c_i'] * min_p[i] ** 2) / min_p[i]\n            \n            if new_total_max >= current_load and new_total_min <= current_load:\n                candidate_deact.append((avg_cost, i))\n    \n    if candidate_deact and total_min > current_load:\n        candidate_deact.sort(key=lambda x: x[0], reverse=True)\n        deactivated = []\n        \n        for avg_cost, i in candidate_deact:\n            if total_min <= current_load:\n                break\n            u[i] = 0\n            deactivated.append(i)\n            total_min -= min_p[i]\n            total_max -= max_p[i]\n            min_p[i] = max_p[i] = 0\n            \n        online_units = [i for i in online_units if i not in deactivated]\n    \n    # Step 5: Dispatch\n    p_out = [0] * n\n    total_current = 0\n    \n    # Set all offline units to 0 and online units to min_p\n    for i in range(n):\n        if u[i] == 1:\n            p_out[i] = min_p[i]\n            total_current += min_p[i]\n    \n    residual = current_load - total_current\n    \n    # Increase output for residual load\n    if residual > 0:\n        marginal_costs = []\n        for i in online_units:\n            marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n            marginal_costs.append((marginal_cost, i, max_p[i] - p_out[i]))\n        \n        marginal_costs.sort(key=lambda x: x[0])\n        \n        for mc, i, headroom in marginal_costs:\n            if residual <= 0:\n                break\n            if headroom > 0:\n                increase = min(headroom, residual)\n                p_out[i] += increase\n                residual -= increase\n    \n    # Step 6: Format output\n    schedules = np.zeros((2, n))\n    schedules[0, :] = u\n    schedules[1, :] = p_out\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0342821913,
          "fitness": 0.0172059349
     },
     {
          "name": "rolling_commit_dispatch_heuristic",
          "algorithm": "1. Identify must-run units (online units that haven't met min-up time or have power exceeding shutdown limit) and must-off units (offline units that haven't met min-down time)  \n2. Initialize commitment: must-run to on, must-off to off, flexible units keep previous state  \n3. Calculate total min/max power considering ramp constraints (startup/shutdown ramp limits for state changes)  \n4. While total max power < current load:  \n   - Turn on flexible offline units with lowest average cost at min output (including startup cost)  \n   - Recalculate total min/max power with new commitment  \n5. While total min power > current load:  \n   - Turn off flexible online units with highest production cost at min output if previous output \u2264 ramp-down limit  \n   - Recalculate total min/max power  \n6. Set offline units' output to 0  \n7. For online units:  \n   - If load \u2264 total min power, set all to min output  \n   - If load \u2265 total max power, set all to max output  \n   - Else perform ramp-constrained economic dispatch by incremental cost ordering  \n\n",
          "code": "import numpy as np\n\ndef rolling_commit_dispatch_heuristic(units_info, load):\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    load_current = load[0]\n    \n    # Extract units info\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    min_uptime = [unit['t_on_min_i'] for unit in units_info]\n    min_downtime = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n\n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_state[i] < min_uptime[i] or p_prev[i] > p_shut[i]:\n                must_run.append(i)\n        else:\n            if abs(t_state[i]) < min_downtime[i]:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = u_prev[i]\n    \n    # Calculate current min and max outputs considering ramp constraints\n    min_cap = np.zeros(n_units)\n    max_cap = np.zeros(n_units)\n    for i in range(n_units):\n        if u[i] == 1:\n            if u_prev[i] == 1:\n                min_cap[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_cap[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_cap[i] = p_min[i]\n                max_cap[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(min_cap)\n    total_max = np.sum(max_cap)\n    \n    # Add units if under-committed\n    if total_max < load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 0]\n        avg_costs = []\n        for i in candidates:\n            cost = s[i] + a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            avg_costs.append((cost / p_min[i], i))\n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, idx in avg_costs:\n            if total_max >= load_current:\n                break\n            u[idx] = 1\n            min_cap[idx] = p_min[idx]\n            max_cap[idx] = min(p_max[idx], p_start[idx])\n            total_min += min_cap[idx]\n            total_max += max_cap[idx]\n    \n    # Remove units if over-committed\n    if total_min > load_current:\n        candidates = [i for i in range(n_units) \n                     if i not in must_run and i not in must_off and u[i] == 1 \n                     and p_prev[i] <= p_down[i]]\n        prod_costs = []\n        for i in candidates:\n            cost = a[i] + b[i] * p_min[i] + c[i] * p_min[i]**2\n            prod_costs.append((cost / p_min[i], i))\n        prod_costs.sort(key=lambda x: x[0], reverse=True)\n        \n        for cost, idx in prod_costs:\n            if total_min <= load_current:\n                break\n            u[idx] = 0\n            total_min -= min_cap[idx]\n            total_max -= max_cap[idx]\n            min_cap[idx] = max_cap[idx] = 0\n    \n    # Set outputs\n    committed = [i for i in range(n_units) if u[i] == 1]\n    if not committed:\n        return np.array([u, p_output])\n    \n    total_min = sum(min_cap[i] for i in committed)\n    total_max = sum(max_cap[i] for i in committed)\n    \n    # Case 1: Load below total min capacity\n    if load_current <= total_min:\n        for i in committed:\n            p_output[i] = min_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 2: Load above total max capacity\n    if load_current >= total_max:\n        for i in committed:\n            p_output[i] = max_cap[i]\n        return np.array([u, p_output])\n    \n    # Case 3: Economic dispatch\n    current_load = np.zeros(len(committed))\n    min_arr = [min_cap[i] for i in committed]\n    max_arr = [max_cap[i] for i in committed]\n    b_arr = [b[i] for i in committed]\n    c_arr = [c[i] for i in committed]\n    idx_to_global = {local: global_idx for local, global_idx in enumerate(committed)}\n    \n    # Initialize at min capacity\n    for local, i in enumerate(committed):\n        current_load[local] = min_cap[i]\n    remaining = load_current - total_min\n    \n    # Dispatch by incremental cost\n    while remaining > 0:\n        inc_costs = []\n        for local in range(len(committed)):\n            if current_load[local] < max_arr[local]:\n                inc_cost = b_arr[local] + 2 * c_arr[local] * current_load[local]\n                inc_costs.append((inc_cost, local))\n        \n        if not inc_costs:\n            break\n        inc_costs.sort(key=lambda x: x[0])\n        cheapest_idx = inc_costs[0][1]\n        \n        max_increase = max_arr[cheapest_idx] - current_load[cheapest_idx]\n        increase = min(remaining, max_increase)\n        current_load[cheapest_idx] += increase\n        remaining -= increase\n    \n    # Map dispatch to original units\n    for local, global_idx in idx_to_global.items():\n        p_output[global_idx] = current_load[local]\n    \n    return np.array([u, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     }
]