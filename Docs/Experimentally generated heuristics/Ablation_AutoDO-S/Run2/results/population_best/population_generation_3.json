{
     "name": "rolling_commit_dispatch",
     "algorithm": "1. Classify units into must-run (violating min-up/shutdown ramp), must-off (violating min-down), and flexible categories\n2. Initialize commitments: must-run units ON, must-off units OFF, flexible maintain previous state\n3. Compute maximum deliverable power considering ramp limits and startup constraints\n4. If insufficient capacity, turn on flexible units sorted by average cost at minimum output\n5. If over-committed, turn off highest average-cost flexible units while maintaining sufficient capacity\n6. Dispatch load using greedy incremental cost optimization:\n   a) Set each committed unit to its feasible minimum output\n   b) Incrementally increase output of cheapest units first until meeting demand\n   c) Respect individual unit ramp and output constraints\n7. Return commitment states and power outputs for all units\n\n",
     "code": "import numpy as np\n\ndef rolling_commit_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units and set initial commitment\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    flexible = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_run[i] = True\n            else:\n                flexible[i] = True\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                flexible[i] = True\n    \n    # Initial commitment states\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Calculate current available capacity\n    max_cap = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # Newly started\n                max_cap[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                max_cap[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_max = np.sum(max_cap)\n    \n    # Add units if capacity insufficient\n    candidates = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 0:  # Flexible and currently off\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2 + unit['s_i']) / p_min\n            cap = min(unit['p_max_i'], unit['p_start_i'])\n            candidates.append((i, cost, cap))\n    \n    candidates.sort(key=lambda x: x[1])\n    for idx, cost, cap in candidates:\n        if total_max < current_load:\n            u[idx] = 1\n            total_max += cap\n        else:\n            break\n    \n    # Remove expensive units if over-committed\n    candidates_off = []\n    for i in range(n_units):\n        if flexible[i] and u[i] == 1:  # Flexible and online\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            cost = (unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * p_min**2) / p_min\n            \n            if unit['u_i_0'] == 0:  # Newly started\n                cap = min(unit['p_max_i'], unit['p_start_i'])\n            else:\n                cap = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            candidates_off.append((i, cost, cap))\n    \n    candidates_off.sort(key=lambda x: x[1], reverse=True)\n    for idx, cost, cap in candidates_off:\n        if total_max - cap >= current_load:\n            u[idx] = 0\n            total_max -= cap\n    \n    # Economic dispatch\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    p_dispatch = np.zeros(n_units)\n    allocated = 0.0\n    \n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 0:  # New start\n                min_bound[i] = unit['p_min_i']\n                max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n            else:  # Was online\n                min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            p_dispatch[i] = min_bound[i]\n            allocated += min_bound[i]\n    \n    remaining = current_load - allocated\n    if remaining < 0:\n        return np.vstack((u, p_dispatch))\n    \n    # Distribute remaining load\n    while remaining > 0:\n        candidates = []\n        for i, unit in enumerate(units_info):\n            if u[i] == 1 and p_dispatch[i] < max_bound[i]:\n                inc_cost = unit['b_i'] + 2 * unit['c_i'] * p_dispatch[i]\n                headroom = max_bound[i] - p_dispatch[i]\n                candidates.append((i, inc_cost, headroom))\n        \n        if not candidates:\n            break\n            \n        candidates.sort(key=lambda x: x[1])\n        i, inc_cost, headroom = candidates[0]\n        amount = min(remaining, headroom)\n        p_dispatch[i] += amount\n        allocated += amount\n        remaining -= amount\n    \n    return np.vstack((u, p_dispatch))",
     "from": "mutation",
     "gap_power_rate": 0.0051709106,
     "gap_price_rate": 0.0086673205,
     "fitness": 0.0069191156
}