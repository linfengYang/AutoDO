[
     {
          "name": "adaptive_amortized_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time constraints), and free units.\n2. Compute feasible power bounds for forced-on and free units considering:\n   - For currently online units: min_output = max(p_min_i, p_i_0 - p_down_i), max_output = min(p_max_i, p_i_0 + p_up_i)\n   - For offline free units: min_output = p_min_i, max_output = min(p_max_i, p_start_i)\n3. Calculate priority index for free units with startup cost amortized over min(2, min_up_time) periods:\n   - Online free: (a_i + b_i * min_output + c_i * min_output\u00b2) / min_output\n   - Offline free: (a_i + b_i * min_output + c_i * min_output\u00b2 + s_i / min(2, min_up_time)) / min_output\n4. Initialize committed_set with forced-on units and accumulate min/max outputs.\n5. Add free units to committed_set in ascending priority order until total_max >= current load.\n6. Remove highest-cost free units if total_min > load while maintaining total_max >= load.\n7. Set effective_load = min(total_max, max(total_min, current_load)).\n8. Perform economic dispatch via lambda iteration:\n   a. Separate quadratic and linear cost units\n   b. Use bisection to find optimal lambda within unit bounds\n   c. Adjust outputs via marginal-cost merit order for residual\n9. Set uncommitted units to offline with zero output.\n10. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef adaptive_amortized_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_i = np.zeros(n)\n    p_i = np.zeros(n)\n    min_bound = [0] * n\n    max_bound = [0] * n\n    priority_index = [0] * n\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    current_load = load[0]\n    \n    # Classify units and compute feasible bounds\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                forced_on_indices.append(i)\n            else:\n                free_indices.append(i)\n            min_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                free_indices.append(i)\n            min_bound[i] = unit['p_min_i']\n            max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate priority index for free units\n    for i in free_indices:\n        unit = units_info[i]\n        a = unit['a_i']\n        b_val = unit['b_i']\n        c_val = unit['c_i']\n        if unit['u_i_0'] == 1:\n            cost = a + b_val * min_bound[i] + c_val * min_bound[i] ** 2\n            priority_index[i] = cost / min_bound[i] if min_bound[i] > 0 else float('inf')\n        else:\n            amortized = unit['s_i'] / min(2, unit['t_on_min_i'])\n            cost = a + b_val * min_bound[i] + c_val * min_bound[i] ** 2 + amortized\n            priority_index[i] = cost / min_bound[i] if min_bound[i] > 0 else float('inf')\n    \n    # Build commitment set\n    committed_set = forced_on_indices[:]\n    total_min = sum(min_bound[i] for i in forced_on_indices)\n    total_max = sum(max_bound[i] for i in forced_on_indices)\n    \n    free_sorted = sorted(free_indices, key=lambda i: priority_index[i])\n    new_committed = []\n    \n    for i in free_sorted:\n        if total_max >= current_load:\n            break\n        committed_set.append(i)\n        new_committed.append(i)\n        total_min += min_bound[i]\n        total_max += max_bound[i]\n    \n    # Remove expensive units if needed\n    if total_min > current_load and new_committed:\n        new_committed_sorted = sorted(new_committed, key=lambda i: priority_index[i], reverse=True)\n        for i in new_committed_sorted:\n            test_min = total_min - min_bound[i]\n            test_max = total_max - max_bound[i]\n            if test_max >= current_load:\n                committed_set.remove(i)\n                total_min = test_min\n                total_max = test_max\n                if total_min <= current_load:\n                    break\n    \n    # Set effective load\n    effective_load = min(total_max, max(total_min, current_load))\n    \n    # Economic dispatch preparation\n    n_committed = len(committed_set)\n    a_arr = np.zeros(n_committed)\n    b_arr = np.zeros(n_committed)\n    c_arr = np.zeros(n_committed)\n    lb_arr = np.zeros(n_committed)\n    ub_arr = np.zeros(n_committed)\n    \n    for idx, i in enumerate(committed_set):\n        unit = units_info[i]\n        a_arr[idx] = unit['a_i']\n        b_arr[idx] = unit['b_i']\n        c_arr[idx] = unit['c_i']\n        lb_arr[idx] = min_bound[i]\n        ub_arr[idx] = max_bound[i]\n    \n    # Lambda iteration dispatch\n    p_dispatch = np.zeros(n_committed)\n    tol = 1e-5\n    max_iter = 100\n    lam_low = 0\n    lam_high = 1e6\n    lam_mid = 0\n    \n    if n_committed > 0:\n        for _ in range(max_iter):\n            lam_mid = (lam_low + lam_high) / 2\n            total_p = 0\n            for i in range(n_committed):\n                if c_arr[i] > 0:\n                    p_val = (lam_mid - b_arr[i]) / (2 * c_arr[i])\n                else:\n                    p_val = lb_arr[i] if lam_mid < b_arr[i] else ub_arr[i]\n                p_val = np.clip(p_val, lb_arr[i], ub_arr[i])\n                p_dispatch[i] = p_val\n                total_p += p_val\n            \n            if total_p < effective_load:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n                \n            if abs(lam_high - lam_low) < tol:\n                break\n        \n        # Residual adjustment\n        residual = effective_load - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                adjustable = []\n                for i in range(n_committed):\n                    if p_dispatch[i] < ub_arr[i]:\n                        mc = b_arr[i] + 2*c_arr[i]*p_dispatch[i] if c_arr[i]>0 else b_arr[i]\n                        adjustable.append((i, mc))\n                adjustable.sort(key=lambda x: x[1])\n                res_remaining = residual\n                for idx, (i, mc) in enumerate(adjustable):\n                    if res_remaining <= 0:\n                        break\n                    headroom = ub_arr[i] - p_dispatch[i]\n                    add = min(headroom, res_remaining / (len(adjustable) - idx))\n                    p_dispatch[i] += add\n                    res_remaining -= add\n            \n            elif residual < 0:\n                res_abs = abs(residual)\n                adjustable = []\n                for i in range(n_committed):\n                    if p_dispatch[i] > lb_arr[i]:\n                        mc = b_arr[i] + 2*c_arr[i]*p_dispatch[i] if c_arr[i]>0 else b_arr[i]\n                        adjustable.append((i, mc))\n                adjustable.sort(key=lambda x: x[1], reverse=True)\n                for idx, (i, mc) in enumerate(adjustable):\n                    if res_abs <= 0:\n                        break\n                    headroom = p_dispatch[i] - lb_arr[i]\n                    reduce = min(headroom, res_abs / (len(adjustable) - idx))\n                    p_dispatch[i] -= reduce\n                    res_abs -= reduce\n    \n    # Final assignments\n    for idx, i in enumerate(committed_set):\n        p_i[i] = p_dispatch[idx]\n        u_i[i] = 1\n    \n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.0047890014,
          "gap_price_rate": 0.0082519398,
          "fitness": 0.0065204706
     },
     {
          "name": "combined_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), and free units.\n2. Compute min_bound and max_bound for forced-on and free units considering ramp limits and startup constraints.\n3. Calculate priority index for free units: amortize startup costs over min(2, min up-time) periods for offline units, then compute (amortized startup cost + production cost at min_bound) / min_bound.\n4. Initialize committed_set with forced-on units. Calculate total_min and total_max.\n5. Add free units to committed_set by ascending priority index until total_max >= current load.\n6. Remove highest-priority (most expensive) free units if total_min > load, ensuring total_max remains >= load.\n7. Recompute bounds for all committed units and determine effective_load = min(total_max, max(total_min, load)).\n8. Perform economic dispatch via lambda iteration for committed units to minimize total cost within individual bounds:\n   a. Separate quadratic and linear cost units\n   b. Use bisection to find optimal lambda\n   c. Adjust outputs via merit-order distribution of residual\n9. Set uncommitted units to offline (u_i=0, p_i=0).\n10. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    free = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(unit)\n            else:\n                free.append(unit)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free.append(unit)\n    \n    committed = forced_on.copy()\n    \n    def compute_bounds(unit):\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'], unit['p_start_i'])\n        return min_bound, max_bound\n    \n    for unit in forced_on + free:\n        min_b, max_b = compute_bounds(unit)\n        unit['min_bound'] = min_b\n        unit['max_bound'] = max_b\n    \n    total_min = sum(unit['min_bound'] for unit in forced_on)\n    total_max = sum(unit['max_bound'] for unit in forced_on)\n    \n    for unit in free:\n        if unit['min_bound'] <= 0:\n            priority = float('inf')\n        else:\n            amortized_startup = unit['s_i'] / min(2, unit['t_on_min_i'])\n            base_cost = unit['a_i'] + unit['b_i'] * unit['min_bound'] + unit['c_i'] * unit['min_bound'] ** 2\n            priority = (base_cost + amortized_startup) / unit['min_bound'] if unit['u_i_0'] == 0 else base_cost / unit['min_bound']\n        unit['priority'] = priority\n    \n    free_sorted = sorted(free, key=lambda x: x['priority'])\n    free_committed = []\n    \n    for unit in free_sorted:\n        if total_max >= current_load:\n            break\n        committed.append(unit)\n        free_committed.append(unit)\n        total_min += unit['min_bound']\n        total_max += unit['max_bound']\n    \n    free_committed.sort(key=lambda x: x['priority'], reverse=True)\n    i = 0\n    while i < len(free_committed) and total_min > current_load:\n        unit = free_committed[i]\n        if total_max - unit['max_bound'] >= current_load:\n            committed.remove(unit)\n            free_committed.pop(i)\n            total_min -= unit['min_bound']\n            total_max -= unit['max_bound']\n            i = 0\n        else:\n            i += 1\n    \n    if committed:\n        for unit in committed:\n            min_b, max_b = compute_bounds(unit)\n            unit['min_bound'] = min_b\n            unit['max_bound'] = max_b\n        total_min = sum(unit['min_bound'] for unit in committed)\n        total_max = sum(unit['max_bound'] for unit in committed)\n        effective_load = min(total_max, max(total_min, current_load))\n        \n        def calc_power(lambd):\n            total = 0\n            for unit in committed:\n                if unit['c_i'] == 0:\n                    unit['temp_p'] = unit['min_bound'] if lambd < unit['b_i'] else unit['max_bound']\n                else:\n                    p = (lambd - unit['b_i']) / (2 * unit['c_i'])\n                    unit['temp_p'] = max(unit['min_bound'], min(unit['max_bound'], p))\n                total += unit['temp_p']\n            return total\n        \n        min_mc = float('inf')\n        max_mc = -float('inf')\n        for unit in committed:\n            if unit['c_i'] == 0:\n                mc = unit['b_i']\n            else:\n                mc_min = 2 * unit['c_i'] * unit['min_bound'] + unit['b_i']\n                mc_max = 2 * unit['c_i'] * unit['max_bound'] + unit['b_i']\n                mc = (mc_min, mc_max)\n                min_mc = min(min_mc, mc_min)\n                max_mc = max(max_mc, mc_max)\n            if unit['c_i'] == 0:\n                min_mc = min(min_mc, unit['b_i'])\n                max_mc = max(max_mc, unit['b_i'])\n        \n        lambd_low, lambd_high = min_mc, max_mc\n        tol, max_iter = 0.1, 100\n        for _ in range(max_iter):\n            lambd_mid = (lambd_low + lambd_high) / 2\n            total_power = calc_power(lambd_mid)\n            if abs(total_power - effective_load) < tol:\n                break\n            if total_power < effective_load:\n                lambd_low = lambd_mid\n            else:\n                lambd_high = lambd_mid\n        \n        for unit in committed:\n            unit['p_i'] = unit['temp_p']\n            unit['u_i'] = 1\n        total_power = sum(unit['p_i'] for unit in committed)\n        residual = effective_load - total_power\n        \n        if abs(residual) > tol:\n            if residual > 0:\n                adjust_units = [u for u in committed if u['p_i'] < u['max_bound']]\n                if adjust_units:\n                    adjust_units.sort(key=lambda u: (u['b_i'] + 2 * u['c_i'] * u['p_i']) if u['c_i'] != 0 else u['b_i'])\n                    i = 0\n                    while residual > tol and i < len(adjust_units):\n                        unit = adjust_units[i]\n                        inc = min(residual, unit['max_bound'] - unit['p_i'])\n                        unit['p_i'] += inc\n                        residual -= inc\n                        i += 1\n            else:\n                residual = -residual\n                adjust_units = [u for u in committed if u['p_i'] > u['min_bound']]\n                if adjust_units:\n                    adjust_units.sort(key=lambda u: (u['b_i'] + 2 * u['c_i'] * u['p_i']) if u['c_i'] != 0 else u['b_i'], reverse=True)\n                    i = 0\n                    while residual > tol and i < len(adjust_units):\n                        unit = adjust_units[i]\n                        dec = min(residual, unit['p_i'] - unit['min_bound'])\n                        unit['p_i'] -= dec\n                        residual -= dec\n                        i += 1\n    \n    for unit in units:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    schedule_arr = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedule_arr[0, i] = unit['u_i']\n        schedule_arr[1, i] = unit['p_i']\n    \n    return schedule_arr",
          "from": "crossover",
          "gap_power_rate": 0.0053991636,
          "gap_price_rate": 0.0080400593,
          "fitness": 0.0067196114
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. For free units, split into previously on/off. Compute priority index:\n   - For free units currently on: cost rate at min output (without startup cost)\n   - For free units currently off: amortize startup cost over min(2, min up-time) periods\n3. Form candidate list: forced-on units + free units sorted by priority index.\n4. Build committed set by adding candidates in ascending priority order until total capacity meets/exceeds current load, ensuring total minimum output <= load (remove expensive units if needed).\n5. For units not in committed set, set u_i=0, p_i=0.\n6. For committed units, perform constrained economic dispatch:\n   a. Compute feasible power ranges considering ramp constraints\n   b. Use lambda iteration to determine optimal generation\n   c. Adjust outputs to exactly match load by merit-order adjustment\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    priority_index = [0.0] * n_units\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > unit['p_shut_i']:\n                forced_on_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n            else:\n                free_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                cost = b_val * min_p_i + c_val * min_p_i**2\n                priority_index[i] = cost / min_p_i\n        else:\n            if abs(t_i_0) < t_off_min:\n                forced_off_indices.append(i)\n                min_p[i] = 0.0\n                max_p[i] = 0.0\n            else:\n                free_indices.append(i)\n                min_p_i = p_min\n                max_p_i = min(p_max, p_start, p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                s_val = unit['s_i']\n                periods = min(2, t_on_min)\n                cost = s_val + periods * (a + b_val * min_p_i + c_val * min_p_i**2)\n                priority_index[i] = cost / (min_p_i * periods)\n    \n    candidate_free = [(priority_index[i], i) for i in free_indices]\n    candidate_free.sort(key=lambda x: x[0])\n    committed_set = forced_on_indices.copy()\n    total_min = sum(min_p[i] for i in forced_on_indices)\n    total_max = sum(max_p[i] for i in forced_on_indices)\n    added_free = []\n    \n    for cost_val, idx in candidate_free:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        added_free.append(idx)\n        committed_set.append(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    while total_min > current_load and added_free:\n        idx = added_free.pop()\n        committed_set.remove(idx)\n        total_min -= min_p[idx]\n        total_max -= max_p[idx]\n    \n    for i in range(n_units):\n        if i in committed_set:\n            schedules[0, i] = 1\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0.0\n    \n    if not committed_set:\n        return schedules\n    \n    dispatch_units = []\n    dispatch_min = []\n    dispatch_max = []\n    for i in committed_set:\n        dispatch_units.append(units_info[i])\n        dispatch_min.append(min_p[i])\n        dispatch_max.append(max_p[i])\n    \n    powers = _dispatch(dispatch_units, dispatch_min, dispatch_max, current_load)\n    for j, idx in enumerate(committed_set):\n        schedules[1, idx] = powers[j]\n    \n    return schedules\n\ndef _dispatch(units, min_ps, max_ps, load):\n    n = len(units)\n    if n == 0:\n        return []\n    tol = 0.1\n    iter_max = 1000\n    lb = min(2 * u['c_i'] * min_ps[i] + u['b_i'] for i, u in enumerate(units))\n    ub = max(2 * u['c_i'] * max_ps[i] + u['b_i'] for i, u in enumerate(units))\n    mid = (lb + ub) / 2.0\n    total_gen = 0.0\n    \n    for it in range(iter_max):\n        powers = []\n        total_gen = 0.0\n        for i, u in enumerate(units):\n            c = u['c_i']\n            b = u['b_i']\n            if abs(c) < 1e-6:\n                if mid >= b:\n                    p = max_ps[i]\n                else:\n                    p = min_ps[i]\n            else:\n                p = (mid - b) / (2 * c)\n                p = max(min_ps[i], min(p, max_ps[i]))\n            powers.append(p)\n            total_gen += p\n        \n        if abs(total_gen - load) < tol:\n            break\n        if total_gen < load:\n            lb = mid\n        else:\n            ub = mid\n        mid = (lb + ub) / 2.0\n    \n    gap = load - total_gen\n    if gap > 0:\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] < max_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = max_ps[i] - powers[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            add = min(gap, headroom)\n            powers[i] += add\n            gap -= add\n    elif gap < 0:\n        gap = -gap\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] > min_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = powers[i] - min_ps[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            remove = min(gap, headroom)\n            powers[i] -= remove\n            gap -= remove\n    \n    return powers",
          "from": "crossover",
          "gap_power_rate": 0.0051591332,
          "gap_price_rate": 0.0083347383,
          "fitness": 0.0067469358
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (online units violating min-up time or shutdown ramp limits), forced-off (offline units violating min-down time), and free units.\n2. Compute feasible power ranges:\n   - Forced-on/free online: min_output = max(p_min_i, p_i_0 - p_down_i), max_output = min(p_max_i, p_i_0 + p_up_i)\n   - Free offline: min_output = p_min_i, max_output = min(p_max_i, p_start_i)\n3. Calculate amortized cost rate for free units:\n   - Free online: (a_i + b_i*min_output + c_i*min_output\u00b2) / min_output\n   - Free offline: (a_i + b_i*min_output + c_i*min_output\u00b2 + s_i/max(1,t_on_min_i)) / min_output\n4. Commit forced-on units and free units sorted by amortized cost rate until total max_output >= load.\n5. Remove highest-cost free units until total min_output <= load while maintaining total max_output >= load.\n6. Perform lambda iteration economic dispatch with ramp-constrained bounds:\n   - Bisect lambda to find optimal outputs\n   - Adjust linear-cost units at critical lambda to meet residual load\n7. Set uncommitted units to off state with zero output.\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Classification and initial setup\n    forced_on, forced_off, free_units = [], [], []\n    for unit in units:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_down, p_up = unit['p_down_i'], unit['p_up_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            unit['min_output'] = max(p_min, p_i_0 - p_down)\n            unit['max_output'] = min(p_max, p_i_0 + p_up)\n            if t_i_0 < t_on_min or p_i_0 > p_shut:\n                forced_on.append(unit)\n            else:\n                free_units.append(unit)\n        else:\n            if -t_i_0 < t_off_min:\n                forced_off.append(unit)\n                unit['min_output'] = unit['max_output'] = 0\n            else:\n                unit['min_output'] = p_min\n                unit['max_output'] = min(p_max, p_start)\n                free_units.append(unit)\n    \n    # Cost calculation for free units\n    for unit in free_units:\n        min_out = unit['min_output']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        \n        production_cost = a + b*min_out + c*min_out**2\n        if unit['u_i_0'] == 0:  # Amortize startup cost\n            t_on_min_val = max(1, unit['t_on_min_i'])\n            production_cost += s / t_on_min_val\n        \n        unit['cost_rate'] = production_cost / min_out if min_out > 0 else 1e12\n    \n    # Unit commitment\n    committed = forced_on.copy()\n    free_sorted = sorted(free_units, key=lambda u: u['cost_rate'])\n    total_min = sum(u['min_output'] for u in committed)\n    total_max = sum(u['max_output'] for u in committed)\n    \n    # Add units until capacity meets load\n    for unit in free_sorted:\n        if total_max < current_load:\n            committed.append(unit)\n            total_min += unit['min_output']\n            total_max += unit['max_output']\n    \n    # Remove expensive units if min output exceeds load\n    free_in_commit = [u for u in committed if u in free_units]\n    free_in_commit.sort(key=lambda u: u['cost_rate'], reverse=True)\n    \n    for unit in free_in_commit:\n        new_min = total_min - unit['min_output']\n        new_max = total_max - unit['max_output']\n        if new_min <= current_load and new_max >= current_load:\n            committed.remove(unit)\n            total_min, total_max = new_min, new_max\n    \n    # Initialize outputs\n    for unit in units:\n        if unit in committed:\n            unit['u_i'] = 1\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Lambda iteration setup\n        low, high = 0.0, 1e6\n        tol, max_iter = 1e-5, 1000\n        committed = [u for u in committed if u['max_output'] > 0]\n        \n        # Bisection method\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_power = 0.0\n            for unit in committed:\n                p_min = unit['min_output']\n                p_max = unit['max_output']\n                b, c = unit['b_i'], unit['c_i']\n                \n                if c > 0:\n                    p_unbounded = (lam - b) / (2 * c)\n                    p_i = min(max(p_unbounded, p_min), p_max)\n                else:\n                    p_i = p_max if lam > b else p_min\n                \n                unit['temp_p'] = p_i\n                total_power += p_i\n            \n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Assign temporary power values\n        total_power = 0\n        for unit in committed:\n            total_power += unit['temp_p']\n        \n        # Adjust linear units at critical lambda\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            linear_units = [u for u in committed if u['c_i'] == 0 and \n                            abs(u['b_i'] - lam) < 1e-5 and \n                            u['min_output'] < u['max_output']]\n            \n            if linear_units:\n                adjustments = []\n                for unit in linear_units:\n                    if residual > 0:\n                        adj_range = unit['max_output'] - unit['temp_p']\n                    else:\n                        adj_range = unit['temp_p'] - unit['min_output']\n                    adjustments.append(adj_range)\n                \n                total_adj = sum(adjustments)\n                if total_adj:\n                    scale = residual / total_adj\n                    for i, unit in enumerate(linear_units):\n                        unit['temp_p'] += scale * adjustments[i]\n        \n        # Assign final power values\n        for unit in committed:\n            unit['p_i'] = max(unit['min_output'], min(unit['max_output'], unit['temp_p']))\n    \n    # Prepare output\n    u_list = [u['u_i'] for u in units]\n    p_list = [u.get('p_i', 0.0) for u in units]\n    \n    return np.array([u_list, p_list])",
          "from": "mutation",
          "gap_power_rate": 0.0050587661,
          "gap_price_rate": 0.0088502477,
          "fitness": 0.0069545069
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), and free units.\n2. Compute feasible power bounds considering ramp limits and startup constraints:\n   - For online units: min_bound = max(p_min_i, p_i_0 - p_down_i), max_bound = min(p_max_i, p_i_0 + p_up_i)\n   - For offline free units: min_bound = p_min_i, max_bound = min(p_max_i, p_start_i)\n3. Calculate priority index for free units amortizing startup costs over min(2, min_up_time) periods for offline units.\n4. Initialize committed_set with forced-on units and their total min/max.\n5. Add free units to committed_set by ascending priority index until total_max >= current load.\n6. Remove highest-priority (most expensive) free units if total_min > load while maintaining total_max >= load.\n7. Set effective_load = min(total_max, max(total_min, load)).\n8. Perform economic dispatch via lambda iteration for committed units to minimize cost:\n   a. Separate quadratic and linear cost units\n   b. Use bisection to find optimal lambda within unit bounds\n   c. Adjust outputs via merit-order distribution for residual load\n9. Set uncommitted units to offline with zero output.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    # Extract current load\n    current_load = load[0]\n    n_units = len(units_info)\n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    min_bound = [0.0] * n_units\n    max_bound = [0.0] * n_units\n    priority_index = [0.0] * n_units\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i_0 == 1:  # Unit was online\n            forced_on[i] = (t_i_0 < t_on_min_i) or (p_i_0 > p_shut_i)\n        else:  # Unit was offline\n            forced_off[i] = -t_i_0 < t_off_min_i\n    \n    # Step 2: Compute power bounds\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        \n        if u_i_0 == 1:  # Online units\n            min_bound[i] = max(p_min_i, p_i_0 - unit['p_down_i'])\n            max_bound[i] = min(p_max_i, p_i_0 + unit['p_up_i'])\n        elif not forced_off[i]:  # Offline free units\n            min_bound[i] = p_min_i\n            max_bound[i] = min(p_max_i, unit['p_start_i'])\n        # Forced-off units remain at default bounds (0)\n    \n    # Step 3: Priority index for free units\n    for i, unit in enumerate(units_info):\n        if not forced_on[i] and not forced_off[i]:\n            base_cost = (unit['a_i'] + \n                         unit['b_i'] * min_bound[i] + \n                         unit['c_i'] * min_bound[i] ** 2)\n            if unit['u_i_0'] == 0:  # Offline free unit\n                amortized_startup = unit['s_i'] / min(2, unit['t_on_min_i'])\n                base_cost += amortized_startup\n            priority_index[i] = base_cost / min_bound[i] if min_bound[i] > 0 else float('inf')\n    \n    # Steps 4-6: Build committed set\n    committed_set = set()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Add forced-on units\n    for i in range(n_units):\n        if forced_on[i]:\n            committed_set.add(i)\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Free units sorted by priority index (ascending)\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    free_units_sorted = sorted(free_units, key=lambda i: priority_index[i])\n    \n    # Add free units until total_max >= current_load\n    for i in free_units_sorted:\n        if total_max < current_load:\n            committed_set.add(i)\n            total_min += min_bound[i]\n            total_max += max_bound[i]\n    \n    # Remove expensive free units if total_min > current_load\n    free_in_committed = [i for i in committed_set if not forced_on[i]]\n    free_in_committed_sorted = sorted(free_in_committed, key=lambda i: priority_index[i], reverse=True)\n    \n    for i in free_in_committed_sorted:\n        new_total_min = total_min - min_bound[i]\n        new_total_max = total_max - max_bound[i]\n        if new_total_min <= current_load and new_total_max >= current_load:\n            committed_set.remove(i)\n            total_min = new_total_min\n            total_max = new_total_max\n    \n    # Step 7: Effective load\n    effective_load = min(total_max, max(total_min, current_load))\n    \n    # Step 8: Economic dispatch\n    if total_min > total_max:  # Check feasibility\n        effective_load = 0\n    \n    # Initialize outputs to min_bound for committed units\n    outputs = {}\n    for i in committed_set:\n        outputs[i] = min_bound[i]\n    \n    if committed_set:\n        quad_units = []\n        linear_units = []\n        \n        for i in committed_set:\n            if units_info[i]['c_i'] > 1e-6:  # Quadratic unit\n                quad_units.append(i)\n            else:\n                linear_units.append(i)\n        \n        # Set tolerance and max iterations for bisection\n        tol = 0.01\n        max_iter = 1000\n        \n        # Find min and max lambda bounds\n        low = float('inf')\n        high = -float('inf')\n        for i in committed_set:\n            unit = units_info[i]\n            min_val = min_bound[i]\n            max_val = max_bound[i]\n            c_i = unit['c_i']\n            b_i = unit['b_i']\n            if c_i > 1e-6:  # Quadratic\n                low = min(low, b_i + 2 * c_i * min_val)\n                high = max(high, b_i + 2 * c_i * max_val)\n            else:  # Linear\n                low = min(low, b_i)\n                high = max(high, b_i)\n        \n        # Bisection\n        total_gen = total_min\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_gen = 0\n            \n            # Dispatch quadratic units\n            for i in quad_units:\n                unit = units_info[i]\n                min_b = min_bound[i]\n                max_b = max_bound[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                p_unconstrained = max(min_b, min(max_b, (lam - b_i) / (2 * c_i)))\n                outputs[i] = p_unconstrained\n                total_gen += p_unconstrained\n            \n            # Dispatch linear units\n            for i in linear_units:\n                unit = units_info[i]\n                min_b = min_bound[i]\n                max_b = max_bound[i]\n                b_i = unit['b_i']\n                if lam >= b_i:\n                    outputs[i] = max_b\n                else:\n                    outputs[i] = min_b\n                total_gen += outputs[i]\n            \n            if abs(total_gen - effective_load) < tol:\n                break\n            \n            if total_gen < effective_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Residual distribution\n        residual = effective_load - total_gen\n        tol = 1e-4\n        if abs(residual) > tol:\n            if residual > 0:  # Need to increase generation\n                candidate_units = [i for i in committed_set if outputs[i] < max_bound[i]]\n                candidate_units.sort(key=lambda i: (units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]))\n                while residual > tol and candidate_units:\n                    i = candidate_units[0]\n                    gap = max_bound[i] - outputs[i]\n                    delta = min(residual, gap)\n                    outputs[i] += delta\n                    residual -= delta\n                    if outputs[i] >= max_bound[i] - tol:\n                        candidate_units.pop(0)\n                    else:\n                        candidate_units.sort(key=lambda i: (units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]))\n            else:  # Need to decrease generation\n                residual = abs(residual)\n                candidate_units = [i for i in committed_set if outputs[i] > min_bound[i]]\n                candidate_units.sort(key=lambda i: -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]))\n                while residual > tol and candidate_units:\n                    i = candidate_units[0]\n                    gap = outputs[i] - min_bound[i]\n                    delta = min(residual, gap)\n                    outputs[i] -= delta\n                    residual -= delta\n                    if outputs[i] <= min_bound[i] + tol:\n                        candidate_units.pop(0)\n                    else:\n                        candidate_units.sort(key=lambda i: -(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * outputs[i]))\n    \n    # Set outputs for all units\n    for i in range(n_units):\n        if i in committed_set:\n            u_list[i] = 1\n            p_list[i] = outputs.get(i, min_bound[i])\n        else:\n            u_list[i] = 0\n            p_list[i] = 0.0\n    \n    return np.array([u_list, p_list], dtype=np.float64)",
          "from": "mutation",
          "gap_power_rate": 0.0050587633,
          "gap_price_rate": 0.0088632258,
          "fitness": 0.0069609945
     },
     {
          "name": "enhanced_combined_commitment",
          "algorithm": "**  \n1. Classify units into forced-on (min up-time/shutdown constraints), forced-off (min down-time), and free units based on prior state.  \n2. Compute feasible power bounds for forced-on and free units:  \n   - Online units: min_bound = max(p_min, p_prev - ramp_down), max_bound = min(p_max, p_prev + ramp_up)  \n   - Offline free units: min_bound = p_min, max_bound = min(p_max, p_start)  \n3. Calculate priority index for free units:  \n   - Online: `(a + b*min_bound + c*min_bound\u00b2) / min_bound`  \n   - Offline: `(a + b*min_bound + c*min_bound\u00b2 + startup_cost / min(2, min_up_time)) / min_bound`  \n4. Start with forced-on units. Add free units in ascending priority order until total max output \u2265 current load.  \n5. Remove most expensive free units (highest priority index) if total min output > load while maintaining total max \u2265 load.  \n6. Perform economic dispatch via lambda iteration:  \n   - Separate quadratic and linear cost units  \n   - Use bisection to find optimal lambda with unit-specific bounds  \n   - Adjust outputs via marginal-cost merit order for residual load  \n7. Set uncommitted units offline (u_i=0, p_i=0).  \n\n**",
          "code": "import numpy as np\n\ndef enhanced_combined_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on, forced_off, free = [], [], []\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    priority_idx = np.full(n_units, np.inf)\n    committed_set = []\n    total_min, total_max = 0.0, 0.0\n\n    # Classify units and compute bounds\n    for idx, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1 and (t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']):\n            forced_on.append(idx)\n            min_bound[idx] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            max_bound[idx] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        elif u0 == 0 and abs(t0) < unit['t_off_min_i']:\n            forced_off.append(idx)\n            min_bound[idx] = max_bound[idx] = 0\n        else:\n            free.append(idx)\n            if u0 == 1:\n                min_bound[idx] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n                max_bound[idx] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n            else:\n                min_bound[idx] = unit['p_min_i']\n                max_bound[idx] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Calculate priority for free units\n    for idx in free:\n        unit = units_info[idx]\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        cost_min = a + b * min_bound[idx] + c * min_bound[idx] ** 2\n        \n        if unit['u_i_0'] == 0:\n            amortized_startup = unit['s_i'] / min(2, unit['t_on_min_i'])\n            cost_min += amortized_startup\n        \n        priority_idx[idx] = cost_min / min_bound[idx] if min_bound[idx] > 0 else np.inf\n\n    # Build initial commitment (forced-on)\n    for idx in forced_on:\n        committed_set.append(idx)\n        total_min += min_bound[idx]\n        total_max += max_bound[idx]\n    \n    # Add free units by ascending priority\n    sorted_free = sorted(free, key=lambda x: priority_idx[x])\n    for idx in sorted_free:\n        if total_max < current_load:\n            committed_set.append(idx)\n            total_min += min_bound[idx]\n            total_max += max_bound[idx]\n    \n    # Remove expensive units if min capacity exceeds load\n    committed_free = [idx for idx in committed_set if idx in free]\n    committed_free.sort(key=lambda x: -priority_idx[x])\n    temp_set = committed_set.copy()\n    for idx in committed_free:\n        new_min = total_min - min_bound[idx]\n        new_max = total_max - max_bound[idx]\n        if new_min >= current_load or new_max >= current_load:\n            temp_set.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    committed_set = temp_set\n\n    # Economic dispatch for committed units\n    quad_units = []\n    lin_units = []\n    outputs = {idx: 0.0 for idx in committed_set}\n    \n    for idx in committed_set:\n        unit = units_info[idx]\n        outputs[idx] = min_bound[idx]\n        if unit['c_i'] != 0:\n            quad_units.append(idx)\n        else:\n            lin_units.append(idx)\n    \n    # Lambda iteration for quadratic units\n    load_remaining = current_load - sum(outputs.values())\n    if quad_units and abs(load_remaining) > 1e-6:\n        lo = min(units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * min_bound[idx] for idx in quad_units)\n        hi = max(units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * max_bound[idx] for idx in quad_units)\n        tol = 1e-6\n        \n        for _ in range(100):\n            lam = (lo + hi) / 2\n            total_gen = 0\n            for idx in quad_units:\n                unit = units_info[idx]\n                p_opt = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_clamped = np.clip(p_opt, min_bound[idx], max_bound[idx])\n                outputs[idx] = p_clamped\n                total_gen += p_clamped\n            \n            residual = current_load - total_gen - sum(outputs[idx] for idx in lin_units)\n            if abs(residual) < tol:\n                break\n            if residual > 0:\n                lo = lam\n            else:\n                hi = lam\n        load_remaining = current_load - sum(outputs.values())\n\n    # Allocate remaining load using merit order\n    all_units = committed_set.copy()\n    all_units.sort(key=lambda idx: units_info[idx]['b_i'] + (2 * units_info[idx]['c_i'] * outputs[idx] if units_info[idx]['c_i'] != 0 else 0))\n    \n    if load_remaining > 0:\n        for idx in all_units:\n            spare = max_bound[idx] - outputs[idx]\n            alloc = min(spare, load_remaining)\n            outputs[idx] += alloc\n            load_remaining -= alloc\n            if load_remaining <= 0:\n                break\n    else:\n        load_remaining = abs(load_remaining)\n        for idx in reversed(all_units):\n            spare = outputs[idx] - min_bound[idx]\n            alloc = min(spare, load_remaining)\n            outputs[idx] -= alloc\n            load_remaining -= alloc\n            if load_remaining <= 0:\n                break\n\n    # Set outputs and commitment states\n    for idx in range(n_units):\n        if idx in committed_set:\n            u[idx] = 1\n            p[idx] = outputs[idx]\n        else:\n            u[idx] = 0\n            p[idx] = 0.0\n\n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.005058765,
          "gap_price_rate": 0.0088632256,
          "fitness": 0.0069609953
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Classify units into forced-on, forced-off, and free based on minimum up/down times and shutdown ramp constraints.\n   - Forced-on: Units that were online in the previous period and either haven't satisfied minimum up-time or their previous output exceeds the shutdown capacity.\n   - Forced-off: Units that were offline in the previous period and haven't satisfied minimum down-time.\n   - Free: All other units eligible for commitment decisions.\n2. Initialize the committed set with forced-on units. Calculate their feasible power outputs considering ramp constraints.\n3. For free units, calculate average cost per MW at minimum output, including amortized startup costs for offline units.\n4. Sort free units by average cost in ascending order and add them to the committed set until total maximum output meets or exceeds the current load and total minimum output is less than or equal to the load.\n5. If total minimum output exceeds load after step 4, remove the most expensive free units (highest average cost) until feasible.\n6. Perform constrained economic dispatch on the committed set using lambda iteration to minimize production costs while respecting power bounds and ramp constraints.\n7. Set uncommitted units to off state with zero output.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Classify units into forced-on, forced-off, and free\n    forced_on_units = []\n    forced_off_units = []\n    free_units = []\n    \n    for unit in units_info:\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Helper function to compute feasible power range\n    def get_feasible_range(unit, will_commit):\n        if not will_commit:\n            return (0, 0)\n        if unit['u_i_0'] == 1:  # Was online, remains on\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Turning on\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        return (min_out, max_out)\n    \n    # Initialize committed set with forced-on units\n    committed_set = []\n    total_min = 0\n    total_max = 0\n    \n    for unit in forced_on_units:\n        min_u, max_u = get_feasible_range(unit, True)\n        unit['_min_current'] = min_u\n        unit['_max_current'] = max_u\n        total_min += min_u\n        total_max += max_u\n        committed_set.append(unit)\n    \n    # Calculate average cost for free units\n    for unit in free_units:\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Already online\n            total_cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        else:  # Offline, include startup cost\n            total_cost = unit['a_i'] + unit['s_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        unit['_avg_cost'] = total_cost / min_p if min_p > 0 else float('inf')\n    \n    # Sort free units by average cost\n    sorted_free_units = sorted(free_units, key=lambda x: x['_avg_cost'])\n    \n    # Add free units to committed set in cost order\n    new_committed = []\n    for unit in sorted_free_units:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        min_u, max_u = get_feasible_range(unit, True)\n        candidate_min = total_min + min_u\n        candidate_max = total_max + max_u\n        \n        # Always add if needed for capacity, check min later\n        unit['_min_current'] = min_u\n        unit['_max_current'] = max_u\n        total_min = candidate_min\n        total_max = candidate_max\n        new_committed.append(unit)\n        if total_max >= current_load and total_min <= current_load:\n            break\n    \n    committed_set += new_committed\n    \n    # Remove expensive units if minimum output exceeds load\n    if total_min > current_load:\n        # Sort new_committed by cost descending\n        new_committed_sorted = sorted(new_committed, key=lambda x: x['_avg_cost'], reverse=True)\n        temp_min = total_min\n        temp_max = total_max\n        to_remove = []\n        for unit in new_committed_sorted:\n            if temp_min <= current_load:\n                break\n            temp_min -= unit['_min_current']\n            temp_max -= unit['_max_current']\n            to_remove.append(unit)\n        # Update committed set and totals\n        for unit in to_remove:\n            new_committed.remove(unit)\n            committed_set.remove(unit)\n            total_min -= unit['_min_current']\n            total_max -= unit['_max_current']\n    \n    # Economic dispatch via lambda iteration\n    u_list = np.zeros(n_units)\n    p_list = np.zeros(n_units)\n    \n    if committed_set:\n        # Get bounds for lambda\n        lows = []\n        highs = []\n        for unit in committed_set:\n            lows.append(unit['b_i'] + 2 * unit['c_i'] * unit['_min_current'])\n            highs.append(unit['b_i'] + 2 * unit['c_i'] * unit['_max_current'])\n        low_lam = min(lows) - 1.0\n        high_lam = max(highs) + 1.0\n        \n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low_lam + high_lam) / 2.0\n            total_p = 0.0\n            dispatch_vals = []\n            for unit in committed_set:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(unit['_min_current'], min(unit['_max_current'], p_i))\n                dispatch_vals.append(p_i)\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        # Assign dispatch values\n        for unit, p_val in zip(committed_set, dispatch_vals):\n            idx = units_info.index(unit)\n            u_list[idx] = 1\n            p_list[idx] = p_val\n    \n    # Set uncommitted units to off\n    for unit in forced_off_units + free_units:\n        if unit not in committed_set:\n            idx = units_info.index(unit)\n            u_list[idx] = 0\n            p_list[idx] = 0\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0087811082,
          "fitness": 0.0071048229
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units based on prior state and constraints.\n2. Calculate priority index for free units: amortize startup costs over min(2, min uptime) periods for offline units. Priority is (amortized cost + production cost) / min output.\n3. Build committed set by adding forced-on units first, then free units by ascending priority until cumulative max output \u2265 current load.\n4. Remove most expensive free units (highest priority index) if cumulative min output > load, ensuring cumulative max remains \u2265 load.\n5. Calculate unit-specific power bounds for committed units using ramp constraints and startup/shutdown capacities.\n6. Clamp total output to feasible range [total_min, total_max] and dispatch via bisection:\n   a. Apply lambda iteration with unit-specific bounds and cost functions\n   b. Adjust outputs via merit-based residual distribution if needed.\n7. Set uncommitted units to off state with zero output.\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    forced_on = [False] * n\n    forced_off = [False] * n\n    free = [False] * n\n\n    # Classify units\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < t_on_min or p0 > p_shut:\n                forced_on[i] = True\n            else:\n                free[i] = True\n        else:\n            if -t0 < t_off_min:\n                forced_off[i] = True\n            else:\n                free[i] = True\n    \n    committed = [i for i in range(n) if forced_on[i]]\n    free_units = []\n    free_indices = [i for i in range(n) if free[i]]\n    \n    # Compute priority index for free units\n    for i in free_indices:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            priority = cost / min_out\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            amortized_startup = unit['s_i'] / min(2, unit['t_on_min_i'])\n            cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2 + amortized_startup\n            priority = cost / min_out\n        free_units.append((i, priority, min_out, max_out))\n    \n    free_units_sorted = sorted(free_units, key=lambda x: x[1])\n    \n    # Add forced-on units\n    total_min, total_max = 0.0, 0.0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n\n    # Add free units until max meets or exceeds load\n    added_free = []\n    for fu in free_units_sorted:\n        if total_max >= current_load:\n            break\n        i, prio, min_out, max_out = fu\n        added_free.append(fu)\n        total_min += min_out\n        total_max += max_out\n    \n    # Remove expensive units if min > load\n    if added_free and total_min > current_load:\n        added_free_sorted_desc = sorted(added_free, key=lambda x: x[1], reverse=True)\n        for idx in range(len(added_free_sorted_desc)):\n            i, prio, min_out, max_out = added_free_sorted_desc[idx]\n            if total_min - min_out <= current_load and total_max - max_out >= current_load:\n                total_min -= min_out\n                total_max -= max_out\n                added_free_sorted_desc.pop(idx)\n                added_free = [af for af in added_free if af[0] != i]\n                if total_min <= current_load:\n                    break\n\n    # Final committed set\n    committed += [fu[0] for fu in added_free]\n    u_out = np.zeros(n)\n    p_out = np.zeros(n)\n    for i in committed:\n        u_out[i] = 1\n    \n    # Calculate bounds for committed units\n    min_limits = np.zeros(len(committed))\n    max_limits = np.zeros(len(committed))\n    b_vals = np.zeros(len(committed))\n    c_vals = np.zeros(len(committed))\n    \n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_limits[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_limits[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_limits[idx] = unit['p_min_i']\n            max_limits[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        b_vals[idx] = unit['b_i']\n        c_vals[idx] = unit['c_i']\n    \n    total_min = min_limits.sum()\n    total_max = max_limits.sum()\n    P = min(max(current_load, total_min), total_max)\n    \n    # Dispatch using bisection and residual adjustment\n    n_units = len(committed)\n    if n_units == 0:\n        schedules = np.array([u_out, p_out])\n        return schedules\n    \n    p_temp = min_limits.copy()\n    if total_min != total_max:\n        # Find lambda bounds\n        lambda_low = float('inf')\n        lambda_high = -float('inf')\n        for i in range(n_units):\n            if c_vals[i] > 0:\n                mc_low = b_vals[i] + 2 * c_vals[i] * min_limits[i]\n                mc_high = b_vals[i] + 2 * c_vals[i] * max_limits[i]\n            else:\n                mc_low = mc_high = b_vals[i]\n            lambda_low = min(lambda_low, mc_low)\n            lambda_high = max(lambda_high, mc_high)\n        \n        tol = 1e-5\n        for _ in range(100):\n            if abs(lambda_high - lambda_low) < tol:\n                break\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0.0\n            for i in range(n_units):\n                if c_vals[i] > 0:\n                    p_uncon = (lambda_mid - b_vals[i]) / (2 * c_vals[i])\n                else:\n                    if lambda_mid > b_vals[i]:\n                        p_uncon = max_limits[i]\n                    elif lambda_mid < b_vals[i]:\n                        p_uncon = min_limits[i]\n                    else:\n                        p_uncon = min_limits[i]\n                p_temp[i] = min(max_limits[i], max(min_limits[i], p_uncon))\n                total_gen += p_temp[i]\n            \n            if total_gen < P:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Residual adjustment\n        residual = P - np.sum(p_temp)\n        if abs(residual) > tol:\n            if residual > 0:\n                candidates = [(i, b_vals[i] + 2 * c_vals[i] * p_temp[i]) \n                             for i in range(n_units) if p_temp[i] < max_limits[i]]\n                candidates.sort(key=lambda x: x[1])\n                for i, mc in candidates:\n                    increase = min(residual, max_limits[i] - p_temp[i])\n                    p_temp[i] += increase\n                    residual -= increase\n                    if residual <= 0:\n                        break\n            else:\n                residual = abs(residual)\n                candidates = [(i, b_vals[i] + 2 * c_vals[i] * p_temp[i]) \n                             for i in range(n_units) if p_temp[i] > min_limits[i]]\n                candidates.sort(key=lambda x: x[1], reverse=True)\n                for i, mc in candidates:\n                    decrease = min(residual, p_temp[i] - min_limits[i])\n                    p_temp[i] -= decrease\n                    residual -= decrease\n                    if residual <= 0:\n                        break\n    \n    # Assign outputs\n    for idx, i in enumerate(committed):\n        p_out[i] = p_temp[idx]\n    \n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054684562,
          "gap_price_rate": 0.0088119113,
          "fitness": 0.0071401837
     },
     {
          "name": "refined_enhanced_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to min uptime or shutdown constraints), forced-off (must remain offline due to min downtime), and free units\n2. For each free unit, compute feasible power bounds and priority index with startup cost amortized over min(2, min-up-time) periods\n3. Build commitment candidate list: forced-on units + free units sorted by priority index (ascending cost per MW at min output)\n4. Add candidates to committed set until total max output \u2265 current load\n5. While total min output > current load:\n   - Remove most expensive free units from committed set if their removal maintains total max \u2265 load\n6. For units not in committed set, set offline (u_i=0, p_i=0)\n7. For committed units, compute feasible power bounds considering ramp/startup constraints\n8. Perform constrained economic dispatch using \u03bb iteration:\n   a. Initialize \u03bb bounds based on marginal costs at min/max outputs\n   b. Bisect until generation-load difference < tolerance\n   c. Adjust linear-cost units at critical \u03bb\n   d. Distribute any residual using merit order\n9. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_commitment(units_info, load):\n    current_load = load[0]\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    # Classify units based on operational constraints\n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(unit)\n            else:\n                free_units.append(unit)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free_units.append(unit)\n\n    # Compute priority index for free units\n    for unit in free_units:\n        if unit['u_i_0'] == 1:  # Online free unit\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_at_min = unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2\n            priority_index = cost_at_min / min_out\n        else:  # Offline free unit\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n            periods = min(2, unit['t_on_min_i'])\n            amortized_startup = unit['s_i'] / periods if periods > 0 else unit['s_i']\n            cost_at_min = unit['a_i'] + unit['b_i']*min_out + unit['c_i']*min_out**2 + amortized_startup\n            priority_index = cost_at_min / min_out\n        \n        unit['min_out'] = min_out\n        unit['max_out'] = max_out\n        unit['priority'] = priority_index\n    \n    # Compute bounds for forced on units\n    for unit in forced_on:\n        min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        unit['min_out'] = min_out\n        unit['max_out'] = max_out\n\n    # Build committed set\n    committed_set = forced_on[:]\n    total_min = sum(unit['min_out'] for unit in committed_set)\n    total_max = sum(unit['max_out'] for unit in committed_set)\n    \n    # Sort free units by priority and add to committed set\n    sorted_free = sorted(free_units, key=lambda x: x['priority'])\n    for unit in sorted_free:\n        if total_max >= current_load:\n            break\n        committed_set.append(unit)\n        total_min += unit['min_out']\n        total_max += unit['max_out']\n    \n    # Remove expensive units if total_min exceeds load\n    free_in_committed = [u for u in committed_set if u in free_units]\n    free_in_committed.sort(key=lambda x: x['priority'], reverse=True)\n    while total_min > current_load:\n        removed = False\n        for unit in free_in_committed:\n            new_total_max = total_max - unit['max_out']\n            if new_total_max >= current_load:\n                committed_set.remove(unit)\n                free_in_committed.remove(unit)\n                total_min -= unit['min_out']\n                total_max -= unit['max_out']\n                removed = True\n                break\n        if not removed:\n            break\n    \n    # Initialize output array\n    n = len(units_info)\n    schedules = np.zeros((2, n))\n    \n    # Set uncommitted units offline\n    for idx, unit in enumerate(units_info):\n        if unit not in committed_set:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0\n    \n    # Handle committed units\n    if committed_set:\n        # Prepare for economic dispatch\n        min_limits = []\n        max_limits = []\n        b_coeffs = []\n        c_coeffs = []\n        is_linear = []\n        \n        # Collect parameters for dispatch\n        for unit in committed_set:\n            min_out = unit['min_out']\n            max_out = unit['max_out']\n            min_limits.append(min_out)\n            max_limits.append(max_out)\n            b_coeffs.append(unit['b_i'])\n            c_coeffs.append(unit['c_i'])\n            is_linear.append(unit['c_i'] == 0)\n        \n        # Lambda iteration initialization\n        min_limits = np.array(min_limits)\n        max_limits = np.array(max_limits)\n        b_coeffs = np.array(b_coeffs)\n        c_coeffs = np.array(c_coeffs)\n        n_units = len(committed_set)\n        \n        # Initialize lambda bounds\n        mc_min = np.zeros(n_units)\n        mc_max = np.zeros(n_units)\n        for i in range(n_units):\n            if is_linear[i]:\n                mc_min[i] = mc_max[i] = b_coeffs[i]\n            else:\n                mc_min[i] = b_coeffs[i] + 2 * c_coeffs[i] * min_limits[i]\n                mc_max[i] = b_coeffs[i] + 2 * c_coeffs[i] * max_limits[i]\n        \n        lambda_low = min(mc_min)\n        lambda_high = max(mc_max)\n        tol = 1e-5\n        p_outputs = np.zeros(n_units)\n        \n        # Bisection algorithm\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_p = 0.0\n            \n            for i in range(n_units):\n                if is_linear[i]:\n                    p_outputs[i] = max_limits[i] if lambda_mid > b_coeffs[i] else min_limits[i]\n                else:\n                    p_i = (lambda_mid - b_coeffs[i]) / (2 * c_coeffs[i])\n                    p_outputs[i] = np.clip(p_i, min_limits[i], max_limits[i])\n            \n            total_p = np.sum(p_outputs)\n            if total_p < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < tol:\n                break\n        \n        # Adjust residual\n        residual = current_load - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                adjustable = [i for i in range(n_units) if p_outputs[i] < max_limits[i]]\n                marginal_costs = []\n                for i in adjustable:\n                    if is_linear[i]:\n                        marginal_costs.append(b_coeffs[i])\n                    else:\n                        marginal_costs.append(b_coeffs[i] + 2*c_coeffs[i]*p_outputs[i])\n                sorted_indices = np.argsort(marginal_costs)\n            else:\n                adjustable = [i for i in range(n_units) if p_outputs[i] > min_limits[i]]\n                marginal_costs = []\n                for i in adjustable:\n                    if is_linear[i]:\n                        marginal_costs.append(b_coeffs[i])\n                    else:\n                        marginal_costs.append(b_coeffs[i] + 2*c_coeffs[i]*p_outputs[i])\n                sorted_indices = np.argsort(marginal_costs)[::-1]\n            \n            # Distribute residual\n            res = abs(residual)\n            for idx in sorted_indices:\n                if res <= tol:\n                    break\n                i = adjustable[idx]\n                if residual > 0:\n                    room = max_limits[i] - p_outputs[i]\n                    add = min(room, res)\n                    p_outputs[i] += add\n                    res -= add\n                else:\n                    room = p_outputs[i] - min_limits[i]\n                    reduce = min(room, res)\n                    p_outputs[i] -= reduce\n                    res -= reduce\n        \n        # Assign outputs to committed units\n        for idx, unit in enumerate(units_info):\n            if unit in committed_set:\n                pos = committed_set.index(unit)\n                schedules[0, idx] = 1\n                schedules[1, idx] = p_outputs[pos]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054684565,
          "gap_price_rate": 0.0088119114,
          "fitness": 0.007140184
     }
]