[
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. For free units, split into previously on/off. Compute priority index:\n   - For free units currently on: cost rate at min output (without startup cost)\n   - For free units currently off: amortize startup cost over min(2, min up-time) periods\n3. Form candidate list: forced-on units + free units sorted by priority index.\n4. Build committed set by adding candidates in ascending priority order until total capacity meets/exceeds current load, ensuring total minimum output <= load (remove expensive units if needed).\n5. For units not in committed set, set u_i=0, p_i=0.\n6. For committed units, perform constrained economic dispatch:\n   a. Compute feasible power ranges considering ramp constraints\n   b. Use lambda iteration to determine optimal generation\n   c. Adjust outputs to exactly match load by merit-order adjustment\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    priority_index = [0.0] * n_units\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > unit['p_shut_i']:\n                forced_on_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n            else:\n                free_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                cost = b_val * min_p_i + c_val * min_p_i**2\n                priority_index[i] = cost / min_p_i\n        else:\n            if abs(t_i_0) < t_off_min:\n                forced_off_indices.append(i)\n                min_p[i] = 0.0\n                max_p[i] = 0.0\n            else:\n                free_indices.append(i)\n                min_p_i = p_min\n                max_p_i = min(p_max, p_start, p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                s_val = unit['s_i']\n                periods = min(2, t_on_min)\n                cost = s_val + periods * (a + b_val * min_p_i + c_val * min_p_i**2)\n                priority_index[i] = cost / (min_p_i * periods)\n    \n    candidate_free = [(priority_index[i], i) for i in free_indices]\n    candidate_free.sort(key=lambda x: x[0])\n    committed_set = forced_on_indices.copy()\n    total_min = sum(min_p[i] for i in forced_on_indices)\n    total_max = sum(max_p[i] for i in forced_on_indices)\n    added_free = []\n    \n    for cost_val, idx in candidate_free:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        added_free.append(idx)\n        committed_set.append(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    while total_min > current_load and added_free:\n        idx = added_free.pop()\n        committed_set.remove(idx)\n        total_min -= min_p[idx]\n        total_max -= max_p[idx]\n    \n    for i in range(n_units):\n        if i in committed_set:\n            schedules[0, i] = 1\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0.0\n    \n    if not committed_set:\n        return schedules\n    \n    dispatch_units = []\n    dispatch_min = []\n    dispatch_max = []\n    for i in committed_set:\n        dispatch_units.append(units_info[i])\n        dispatch_min.append(min_p[i])\n        dispatch_max.append(max_p[i])\n    \n    powers = _dispatch(dispatch_units, dispatch_min, dispatch_max, current_load)\n    for j, idx in enumerate(committed_set):\n        schedules[1, idx] = powers[j]\n    \n    return schedules\n\ndef _dispatch(units, min_ps, max_ps, load):\n    n = len(units)\n    if n == 0:\n        return []\n    tol = 0.1\n    iter_max = 1000\n    lb = min(2 * u['c_i'] * min_ps[i] + u['b_i'] for i, u in enumerate(units))\n    ub = max(2 * u['c_i'] * max_ps[i] + u['b_i'] for i, u in enumerate(units))\n    mid = (lb + ub) / 2.0\n    total_gen = 0.0\n    \n    for it in range(iter_max):\n        powers = []\n        total_gen = 0.0\n        for i, u in enumerate(units):\n            c = u['c_i']\n            b = u['b_i']\n            if abs(c) < 1e-6:\n                if mid >= b:\n                    p = max_ps[i]\n                else:\n                    p = min_ps[i]\n            else:\n                p = (mid - b) / (2 * c)\n                p = max(min_ps[i], min(p, max_ps[i]))\n            powers.append(p)\n            total_gen += p\n        \n        if abs(total_gen - load) < tol:\n            break\n        if total_gen < load:\n            lb = mid\n        else:\n            ub = mid\n        mid = (lb + ub) / 2.0\n    \n    gap = load - total_gen\n    if gap > 0:\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] < max_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = max_ps[i] - powers[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            add = min(gap, headroom)\n            powers[i] += add\n            gap -= add\n    elif gap < 0:\n        gap = -gap\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] > min_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = powers[i] - min_ps[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            remove = min(gap, headroom)\n            powers[i] -= remove\n            gap -= remove\n    \n    return powers",
          "from": "crossover",
          "gap_power_rate": 0.0051591332,
          "gap_price_rate": 0.0083347383,
          "fitness": 0.0067469358
     },
     {
          "name": "improved_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (online units violating min-up time or shutdown ramp limits), forced-off (offline units violating min-down time), and free units.\n2. Compute feasible power ranges:\n   - Forced-on/free online: min_output = max(p_min_i, p_i_0 - p_down_i), max_output = min(p_max_i, p_i_0 + p_up_i)\n   - Free offline: min_output = p_min_i, max_output = min(p_max_i, p_start_i)\n3. Calculate amortized cost rate for free units:\n   - Free online: (a_i + b_i*min_output + c_i*min_output\u00b2) / min_output\n   - Free offline: (a_i + b_i*min_output + c_i*min_output\u00b2 + s_i/max(1,t_on_min_i)) / min_output\n4. Commit forced-on units and free units sorted by amortized cost rate until total max_output >= load.\n5. Remove highest-cost free units until total min_output <= load while maintaining total max_output >= load.\n6. Perform lambda iteration economic dispatch with ramp-constrained bounds:\n   - Bisect lambda to find optimal outputs\n   - Adjust linear-cost units at critical lambda to meet residual load\n7. Set uncommitted units to off state with zero output.\n\n",
          "code": "import numpy as np\n\ndef improved_rolling_commitment(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Classification and initial setup\n    forced_on, forced_off, free_units = [], [], []\n    for unit in units:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min, p_max = unit['p_min_i'], unit['p_max_i']\n        p_down, p_up = unit['p_down_i'], unit['p_up_i']\n        p_start, p_shut = unit['p_start_i'], unit['p_shut_i']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            unit['min_output'] = max(p_min, p_i_0 - p_down)\n            unit['max_output'] = min(p_max, p_i_0 + p_up)\n            if t_i_0 < t_on_min or p_i_0 > p_shut:\n                forced_on.append(unit)\n            else:\n                free_units.append(unit)\n        else:\n            if -t_i_0 < t_off_min:\n                forced_off.append(unit)\n                unit['min_output'] = unit['max_output'] = 0\n            else:\n                unit['min_output'] = p_min\n                unit['max_output'] = min(p_max, p_start)\n                free_units.append(unit)\n    \n    # Cost calculation for free units\n    for unit in free_units:\n        min_out = unit['min_output']\n        a, b, c = unit['a_i'], unit['b_i'], unit['c_i']\n        s = unit['s_i']\n        \n        production_cost = a + b*min_out + c*min_out**2\n        if unit['u_i_0'] == 0:  # Amortize startup cost\n            t_on_min_val = max(1, unit['t_on_min_i'])\n            production_cost += s / t_on_min_val\n        \n        unit['cost_rate'] = production_cost / min_out if min_out > 0 else 1e12\n    \n    # Unit commitment\n    committed = forced_on.copy()\n    free_sorted = sorted(free_units, key=lambda u: u['cost_rate'])\n    total_min = sum(u['min_output'] for u in committed)\n    total_max = sum(u['max_output'] for u in committed)\n    \n    # Add units until capacity meets load\n    for unit in free_sorted:\n        if total_max < current_load:\n            committed.append(unit)\n            total_min += unit['min_output']\n            total_max += unit['max_output']\n    \n    # Remove expensive units if min output exceeds load\n    free_in_commit = [u for u in committed if u in free_units]\n    free_in_commit.sort(key=lambda u: u['cost_rate'], reverse=True)\n    \n    for unit in free_in_commit:\n        new_min = total_min - unit['min_output']\n        new_max = total_max - unit['max_output']\n        if new_min <= current_load and new_max >= current_load:\n            committed.remove(unit)\n            total_min, total_max = new_min, new_max\n    \n    # Initialize outputs\n    for unit in units:\n        if unit in committed:\n            unit['u_i'] = 1\n        else:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    # Economic dispatch for committed units\n    if committed:\n        # Lambda iteration setup\n        low, high = 0.0, 1e6\n        tol, max_iter = 1e-5, 1000\n        committed = [u for u in committed if u['max_output'] > 0]\n        \n        # Bisection method\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_power = 0.0\n            for unit in committed:\n                p_min = unit['min_output']\n                p_max = unit['max_output']\n                b, c = unit['b_i'], unit['c_i']\n                \n                if c > 0:\n                    p_unbounded = (lam - b) / (2 * c)\n                    p_i = min(max(p_unbounded, p_min), p_max)\n                else:\n                    p_i = p_max if lam > b else p_min\n                \n                unit['temp_p'] = p_i\n                total_power += p_i\n            \n            if abs(total_power - current_load) < tol:\n                break\n            if total_power < current_load:\n                low = lam\n            else:\n                high = lam\n        \n        # Assign temporary power values\n        total_power = 0\n        for unit in committed:\n            total_power += unit['temp_p']\n        \n        # Adjust linear units at critical lambda\n        residual = current_load - total_power\n        if abs(residual) > tol:\n            linear_units = [u for u in committed if u['c_i'] == 0 and \n                            abs(u['b_i'] - lam) < 1e-5 and \n                            u['min_output'] < u['max_output']]\n            \n            if linear_units:\n                adjustments = []\n                for unit in linear_units:\n                    if residual > 0:\n                        adj_range = unit['max_output'] - unit['temp_p']\n                    else:\n                        adj_range = unit['temp_p'] - unit['min_output']\n                    adjustments.append(adj_range)\n                \n                total_adj = sum(adjustments)\n                if total_adj:\n                    scale = residual / total_adj\n                    for i, unit in enumerate(linear_units):\n                        unit['temp_p'] += scale * adjustments[i]\n        \n        # Assign final power values\n        for unit in committed:\n            unit['p_i'] = max(unit['min_output'], min(unit['max_output'], unit['temp_p']))\n    \n    # Prepare output\n    u_list = [u['u_i'] for u in units]\n    p_list = [u.get('p_i', 0.0) for u in units]\n    \n    return np.array([u_list, p_list])",
          "from": "mutation",
          "gap_power_rate": 0.0050587661,
          "gap_price_rate": 0.0088502477,
          "fitness": 0.0069545069
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Classify units into forced-on, forced-off, and free based on minimum up/down times and shutdown ramp constraints.\n   - Forced-on: Units that were online in the previous period and either haven't satisfied minimum up-time or their previous output exceeds the shutdown capacity.\n   - Forced-off: Units that were offline in the previous period and haven't satisfied minimum down-time.\n   - Free: All other units eligible for commitment decisions.\n2. Initialize the committed set with forced-on units. Calculate their feasible power outputs considering ramp constraints.\n3. For free units, calculate average cost per MW at minimum output, including amortized startup costs for offline units.\n4. Sort free units by average cost in ascending order and add them to the committed set until total maximum output meets or exceeds the current load and total minimum output is less than or equal to the load.\n5. If total minimum output exceeds load after step 4, remove the most expensive free units (highest average cost) until feasible.\n6. Perform constrained economic dispatch on the committed set using lambda iteration to minimize production costs while respecting power bounds and ramp constraints.\n7. Set uncommitted units to off state with zero output.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Classify units into forced-on, forced-off, and free\n    forced_on_units = []\n    forced_off_units = []\n    free_units = []\n    \n    for unit in units_info:\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Helper function to compute feasible power range\n    def get_feasible_range(unit, will_commit):\n        if not will_commit:\n            return (0, 0)\n        if unit['u_i_0'] == 1:  # Was online, remains on\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Turning on\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        return (min_out, max_out)\n    \n    # Initialize committed set with forced-on units\n    committed_set = []\n    total_min = 0\n    total_max = 0\n    \n    for unit in forced_on_units:\n        min_u, max_u = get_feasible_range(unit, True)\n        unit['_min_current'] = min_u\n        unit['_max_current'] = max_u\n        total_min += min_u\n        total_max += max_u\n        committed_set.append(unit)\n    \n    # Calculate average cost for free units\n    for unit in free_units:\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Already online\n            total_cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        else:  # Offline, include startup cost\n            total_cost = unit['a_i'] + unit['s_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        unit['_avg_cost'] = total_cost / min_p if min_p > 0 else float('inf')\n    \n    # Sort free units by average cost\n    sorted_free_units = sorted(free_units, key=lambda x: x['_avg_cost'])\n    \n    # Add free units to committed set in cost order\n    new_committed = []\n    for unit in sorted_free_units:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        min_u, max_u = get_feasible_range(unit, True)\n        candidate_min = total_min + min_u\n        candidate_max = total_max + max_u\n        \n        # Always add if needed for capacity, check min later\n        unit['_min_current'] = min_u\n        unit['_max_current'] = max_u\n        total_min = candidate_min\n        total_max = candidate_max\n        new_committed.append(unit)\n        if total_max >= current_load and total_min <= current_load:\n            break\n    \n    committed_set += new_committed\n    \n    # Remove expensive units if minimum output exceeds load\n    if total_min > current_load:\n        # Sort new_committed by cost descending\n        new_committed_sorted = sorted(new_committed, key=lambda x: x['_avg_cost'], reverse=True)\n        temp_min = total_min\n        temp_max = total_max\n        to_remove = []\n        for unit in new_committed_sorted:\n            if temp_min <= current_load:\n                break\n            temp_min -= unit['_min_current']\n            temp_max -= unit['_max_current']\n            to_remove.append(unit)\n        # Update committed set and totals\n        for unit in to_remove:\n            new_committed.remove(unit)\n            committed_set.remove(unit)\n            total_min -= unit['_min_current']\n            total_max -= unit['_max_current']\n    \n    # Economic dispatch via lambda iteration\n    u_list = np.zeros(n_units)\n    p_list = np.zeros(n_units)\n    \n    if committed_set:\n        # Get bounds for lambda\n        lows = []\n        highs = []\n        for unit in committed_set:\n            lows.append(unit['b_i'] + 2 * unit['c_i'] * unit['_min_current'])\n            highs.append(unit['b_i'] + 2 * unit['c_i'] * unit['_max_current'])\n        low_lam = min(lows) - 1.0\n        high_lam = max(highs) + 1.0\n        \n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low_lam + high_lam) / 2.0\n            total_p = 0.0\n            dispatch_vals = []\n            for unit in committed_set:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(unit['_min_current'], min(unit['_max_current'], p_i))\n                dispatch_vals.append(p_i)\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        # Assign dispatch values\n        for unit, p_val in zip(committed_set, dispatch_vals):\n            idx = units_info.index(unit)\n            u_list[idx] = 1\n            p_list[idx] = p_val\n    \n    # Set uncommitted units to off\n    for unit in forced_off_units + free_units:\n        if unit not in committed_set:\n            idx = units_info.index(unit)\n            u_list[idx] = 0\n            p_list[idx] = 0\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0087811082,
          "fitness": 0.0071048229
     },
     {
          "name": "hybrid_enhanced_commitment",
          "algorithm": "1. Classify units into forced-on (must remain online due to min uptime or shutdown constraints), forced-off (must remain offline due to min downtime), and free units.\n2. For free units, compute min/max output considering ramp constraints and amortize startup cost over min(2, min up-time) periods for offline units.\n3. Calculate priority index: running cost rate at min output for online units; (amortized startup cost + running cost at min output) / min output for offline units.\n4. Form commitment candidate list: forced-on units + free units sorted by priority index in ascending order.\n5. Build committed set: add candidates in priority order until total max output \u2265 current load, while ensuring total min output \u2264 load by removing highest-priority free units if necessary.\n6. Set uncommitted units to off state (u_i=0, p_i=0).\n7. For committed units, calculate feasible power bounds using ramp limits and startup capacities.\n8. Perform constrained economic dispatch via lambda iteration to minimize running costs while meeting clamped load (within feasible generation range).\n\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_outputs = np.zeros(n_units)\n    max_outputs = np.zeros(n_units)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    free_priority = [0] * n_units\n    prev_states = [unit['u_i_0'] for unit in units_info]\n    \n    # Precompute min/max feasible outputs and commitment constraints\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            min_outputs[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_outputs[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            forced_on[i] = (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i'])\n        else:\n            min_outputs[i] = unit['p_min_i']\n            max_outputs[i] = min(unit['p_max_i'], unit['p_start_i'])\n            forced_off[i] = abs(unit['t_i_0']) < unit['t_off_min_i']\n    \n    # Compute priority indices for free units\n    for i, unit in enumerate(units_info):\n        if not forced_on[i] and not forced_off[i]:\n            base_cost = unit['a_i'] + unit['b_i'] * min_outputs[i] + unit['c_i'] * min_outputs[i] ** 2\n            if prev_states[i] == 1:\n                free_priority[i] = base_cost / min_outputs[i]\n            else:\n                amort_periods = max(min(2, unit['t_on_min_i']), 1)\n                amort_startup_cost = unit['s_i'] / amort_periods\n                free_priority[i] = (base_cost + amort_startup_cost) / min_outputs[i]\n    \n    # Build committed set\n    committed_indices = [i for i in range(n_units) if forced_on[i]]\n    free_indices = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    free_indices.sort(key=lambda i: free_priority[i])\n    \n    total_min = sum(min_outputs[i] for i in committed_indices)\n    total_max = sum(max_outputs[i] for i in committed_indices)\n    \n    for i in free_indices:\n        if total_max < current_load:\n            committed_indices.append(i)\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n    \n    # Ensure feasibility by removing expensive units if needed\n    if total_min > current_load:\n        free_committed = [i for i in committed_indices if not forced_on[i]]\n        free_committed.sort(key=lambda i: free_priority[i], reverse=True)\n        for i in free_committed:\n            if total_min - min_outputs[i] <= current_load:\n                committed_indices.remove(i)\n                total_min -= min_outputs[i]\n                total_max -= max_outputs[i]\n            if total_min <= current_load:\n                break\n    \n    # Economic dispatch preparation\n    low_bounds = [min_outputs[i] for i in committed_indices]\n    high_bounds = [max_outputs[i] for i in committed_indices]\n    b_list = [units_info[i]['b_i'] for i in committed_indices]\n    c_list = [units_info[i]['c_i'] for i in committed_indices]\n    P_total = np.clip(current_load, total_min, total_max)\n    \n    # Lambda iteration for dispatch\n    n_committed = len(committed_indices)\n    p_alloc = low_bounds.copy()\n    if abs(P_total - total_min) < 1e-6:\n        p_alloc = low_bounds\n    elif abs(P_total - total_max) < 1e-6:\n        p_alloc = high_bounds\n    else:\n        lambda_min = min(b_list) - 1\n        lambda_max = max(b + 2 * c * h if c > 0 else b \n                         for b, c, h in zip(b_list, c_list, high_bounds)) + 1\n        \n        for _ in range(100):\n            lambda_mid = (lambda_min + lambda_max) / 2\n            total_gen = 0\n            for j in range(n_committed):\n                if c_list[j] > 0:\n                    p_val = (lambda_mid - b_list[j]) / (2 * c_list[j])\n                    p_alloc[j] = np.clip(p_val, low_bounds[j], high_bounds[j])\n                else:\n                    p_alloc[j] = high_bounds[j] if lambda_mid >= b_list[j] else low_bounds[j]\n                total_gen += p_alloc[j]\n            \n            if abs(total_gen - P_total) < 1e-6:\n                break\n            if total_gen > P_total:\n                lambda_max = lambda_mid\n            else:\n                lambda_min = lambda_mid\n    \n    # Set final schedules\n    for i in range(n_units):\n        if i in committed_indices:\n            idx = committed_indices.index(i)\n            schedules[0, i] = 1\n            schedules[1, i] = p_alloc[idx]\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054684569,
          "gap_price_rate": 0.0088119119,
          "fitness": 0.0071401844
     },
     {
          "name": "two_period_amortized_commitment",
          "algorithm": "1. Identify forced-on and forced-off units based on min up/downtime and shutdown constraints.\n2. Initialize committed set with forced-on units, calculate their min/max feasible outputs.\n3. For free units, compute two-period amortized cost (startup cost spread over min(2, min-up-time) periods plus production costs) for commitment priority.\n4. Add free units to committed set in ascending amortized cost order until total max output \u2265 current load.\n5. If total min output > load, remove most expensive free units until feasible while maintaining max output \u2265 load.\n6. Perform constrained economic dispatch using lambda iteration with bounds from ramp/startup constraints and step adjustment for linear units.\n7. Set uncommitted units to off state with zero output.\n\n",
          "code": "import numpy as np\n\ndef two_period_amortized_commitment(units_info, load):\n    n_units = len(units_info)\n    committed = np.zeros(n_units, dtype=bool)\n    p_outputs = np.zeros(n_units)\n    \n    # Step 1: Identify forced-on/off units\n    forced_on, forced_off, free = [], [], []\n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:  # Previously offline\n            if (-unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free.append(i)\n    \n    # Step 2: Initialize with forced-on units\n    total_min, total_max = 0, 0\n    min_bounds = {}\n    max_bounds = {}\n    \n    for i in forced_on:\n        unit = units_info[i]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        total_min += min_bound\n        total_max += max_bound\n        committed[i] = True\n    \n    # Step 3: Compute amortized costs for free units\n    amortized_costs = {}\n    for i in free:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        \n        # Calculate feasible bounds\n        if unit['u_i_0'] == 1:\n            min_bound = max(p_min, unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Current cost only for online units\n            avg_cost = (unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n        else:\n            min_bound = p_min\n            max_bound = min(unit['p_max_i'], unit['p_start_i'])\n            # Two-period amortization for offline units\n            cost_period = unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2\n            startup_amort = unit['s_i'] / min(2, unit['t_on_min_i'])\n            avg_cost = (cost_period + startup_amort) / p_min\n        \n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n        amortized_costs[i] = avg_cost\n    \n    # Step 4: Commit free units by cost priority\n    sorted_free = sorted(free, key=lambda i: amortized_costs[i])\n    committed_free = []\n    \n    for i in sorted_free:\n        if total_max >= current_load:\n            break\n        total_min += min_bounds[i]\n        total_max += max_bounds[i]\n        committed[i] = True\n        committed_free.append(i)\n    \n    # Step 5: Remove expensive units if min output exceeds load\n    committed_free.sort(key=lambda i: amortized_costs[i], reverse=True)\n    removal_list = committed_free[:]\n    for i in removal_list:\n        if total_min <= current_load:\n            break\n        new_min = total_min - min_bounds[i]\n        new_max = total_max - max_bounds[i]\n        if new_min <= current_load <= new_max:\n            total_min = new_min\n            total_max = new_max\n            committed[i] = False\n            committed_free.remove(i)\n    \n    # Step 6: Constrained economic dispatch\n    dispatch_units = [i for i in range(n_units) if committed[i]]\n    tol = 1e-5\n    max_iter = 1000\n    iter_count = 0\n    \n    # Initialize outputs at min bounds\n    current_p = {i: min_bounds[i] for i in dispatch_units}\n    total_output = sum(current_p.values())\n    residual = current_load - total_output\n    \n    # Lambda iteration setup\n    lambda_low = 0\n    lambda_high = 1e6\n    \n    while abs(residual) > tol and iter_count < max_iter:\n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_p = 0\n        grad_residual = 0\n        \n        # Calculate power outputs for given lambda\n        for i in dispatch_units:\n            unit = units_info[i]\n            p_min, p_max = min_bounds[i], max_bounds[i]\n            b, c = unit['b_i'], unit['c_i']\n            \n            if c > 0:  # Quadratic unit\n                p_unc = (lambda_mid - b) / (2 * c)\n                p_opt = min(p_max, max(p_min, p_unc))\n            else:  # Linear unit\n                if lambda_mid < b:\n                    p_opt = p_min\n                elif lambda_mid > b:\n                    p_opt = p_max\n                else:\n                    p_opt = current_p[i]  # Keep last valid\n            \n            current_p[i] = p_opt\n            total_p += p_opt\n        \n        residual = current_load - total_p\n        \n        if residual > 0:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        \n        iter_count += 1\n    \n    # Step adjustment for linear units if needed\n    if abs(residual) > tol:\n        # Find linear units not at bounds\n        linear_units = [i for i in dispatch_units if units_info[i]['c_i'] == 0]\n        if residual > 0:\n            # Sort by marginal cost (b_i) ascending\n            linear_units.sort(key=lambda i: units_info[i]['b_i'])\n            for i in linear_units:\n                p_opt = current_p[i]\n                avail_up = max_bounds[i] - p_opt\n                if avail_up > 0:\n                    delta = min(avail_up, residual)\n                    current_p[i] += delta\n                    residual -= delta\n                    if residual <= 0:\n                        break\n        else:\n            # Sort by marginal cost (b_i) descending\n            linear_units.sort(key=lambda i: units_info[i]['b_i'], reverse=True)\n            for i in linear_units:\n                p_opt = current_p[i]\n                avail_down = p_opt - min_bounds[i]\n                if avail_down > 0:\n                    delta = min(avail_down, abs(residual))\n                    current_p[i] -= delta\n                    residual += delta\n                    if residual >= 0:\n                        break\n    \n    # Prepare output array\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if committed[i]:\n            schedules[0, i] = 1\n            schedules[1, i] = current_p.get(i, min_bounds.get(i, units_info[i]['p_min_i']))\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n            \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054684578,
          "gap_price_rate": 0.0088119119,
          "fitness": 0.0071401848
     },
     {
          "name": "enhanced_priority_dispatch",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown constraints), forced-off units (must remain offline due to min down-time), and free units.  \n2. Precompute feasible power bounds for all units considering ramp limits and startup/shutdown constraints:  \n   - For units previously online: min_out = max(p_min_i, p_i_0 - p_down_i), max_out = min(p_max_i, p_i_0 + p_up_i)  \n   - For free offline units: min_out = p_min_i, max_out = min(p_max_i, p_start_i)  \n3. Calculate cost rates for free units amortizing startup cost over min(2, min up-time) periods:  \n   - Free online: (a_i + b_i*min_out + c_i*min_out\u00b2) / min_out  \n   - Free offline: (s_i/min(2,t_on_min_i) + a_i + b_i*min_out + c_i*min_out\u00b2) / min_out  \n4. Initialize committed_set with forced-on units. Add free units by ascending cost rate until total max_out \u2265 current load.  \n5. If total min_out > load, remove most expensive free units until feasible.  \n6. For committed units, perform constrained economic dispatch:  \n   a. Compute lambda bounds using marginal costs at min/max outputs  \n   b. Apply bisection to find optimal lambda  \n   c. Assign clipped outputs to units and resolve residual  \n7. Set uncommitted units to offline with zero output.  \n",
          "code": "import numpy as np\n\ndef enhanced_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Classify units into forced-on, forced-off, and free\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    free = [False] * n_units\n    min_out = [0.0] * n_units\n    max_out = [0.0] * n_units\n    cost_rate = [float('inf')] * n_units\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                free[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n            else:\n                free[i] = True\n                \n    # Precompute feasible bounds and cost rates for free units\n    for i, unit in enumerate(units_info):\n        if free[i]:\n            if unit['u_i_0'] == 1:\n                min_out[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_out[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                cost_rate[i] = (unit['a_i'] + unit['b_i']*min_out[i] + unit['c_i']*min_out[i]**2) / min_out[i]\n            else:\n                min_out[i] = unit['p_min_i']\n                max_out[i] = min(unit['p_max_i'], unit['p_start_i'])\n                amortization = min(2, unit['t_on_min_i'])\n                amortized_startup = unit['s_i'] / amortization\n                cost_rate[i] = (unit['a_i'] + unit['b_i']*min_out[i] + unit['c_i']*min_out[i]**2 + amortized_startup) / min_out[i]\n                \n    # Build commitment set\n    committed = [i for i in range(n_units) if forced_on[i]]\n    free_indices = [i for i in range(n_units) if free[i]]\n    free_indices.sort(key=lambda i: cost_rate[i])\n    \n    total_min = sum(min_out[i] for i in committed)\n    total_max = sum(max_out[i] for i in committed)\n    \n    for i in free_indices:\n        if total_max < current_load:\n            committed.append(i)\n            total_min += min_out[i]\n            total_max += max_out[i]\n        else:\n            break\n            \n    free_in_committed = [i for i in committed if free[i]]\n    free_in_committed.sort(key=lambda i: cost_rate[i], reverse=True)\n    \n    while total_min > current_load and free_in_committed:\n        candidate = free_in_committed[0]\n        if total_max - max_out[candidate] >= current_load:\n            committed.remove(candidate)\n            free_in_committed.remove(candidate)\n            total_min -= min_out[candidate]\n            total_max -= max_out[candidate]\n        else:\n            free_in_committed = free_in_committed[1:]\n            \n    # Initialize dispatch with zeros\n    u_dispatch = np.zeros(n_units, dtype=int)\n    p_dispatch = np.zeros(n_units)\n    \n    # Perform economic dispatch for committed units\n    comm_indices = committed\n    if comm_indices:\n        # Compute lambda bounds\n        low_lambda = float('inf')\n        high_lambda = 0.0\n        for i in comm_indices:\n            min_p = min_out[i]\n            max_p = max_out[i]\n            if units_info[i]['c_i'] > 0:\n                low_i = 2 * units_info[i]['c_i'] * min_p + units_info[i]['b_i']\n                high_i = 2 * units_info[i]['c_i'] * max_p + units_info[i]['b_i']\n            else:\n                low_i = high_i = units_info[i]['b_i']\n            low_lambda = min(low_lambda, low_i)\n            high_lambda = max(high_lambda, high_i)\n            \n        # Bisection method\n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2.0\n            total_power = 0.0\n            for i in comm_indices:\n                unit = units_info[i]\n                p_min = min_out[i]\n                p_max = max_out[i]\n                if unit['c_i'] > 0:\n                    p_set = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_set = max(p_min, min(p_max, p_set))\n                else:\n                    if mid_lambda < unit['b_i']:\n                        p_set = p_min\n                    else:\n                        p_set = p_max\n                total_power += p_set\n                \n            if abs(total_power - current_load) < tol:\n                break\n            elif total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n                \n        # Assign dispatch values\n        p_dispatch_temp = {}\n        total_power = 0.0\n        for i in comm_indices:\n            unit = units_info[i]\n            p_min = min_out[i]\n            p_max = max_out[i]\n            if unit['c_i'] > 0:\n                p_set = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_set = max(p_min, min(p_max, p_set))\n            else:\n                if mid_lambda < unit['b_i']:\n                    p_set = p_min\n                else:\n                    p_set = p_max\n            p_dispatch_temp[i] = p_set\n            total_power += p_set\n            \n        # Resolve residual\n        residual = current_load - total_power\n        tol_res = 1e-3\n        while abs(residual) > tol_res:\n            if residual > 0:\n                candidates = []\n                for i in comm_indices:\n                    if p_dispatch_temp[i] < max_out[i] - tol_res:\n                        if units_info[i]['c_i'] > 0:\n                            cost = 2 * units_info[i]['c_i'] * p_dispatch_temp[i] + units_info[i]['b_i']\n                        else:\n                            cost = units_info[i]['b_i']\n                        candidates.append((i, cost))\n                if not candidates: \n                    break\n                candidates.sort(key=lambda x: x[1])\n                idx = candidates[0][0]\n                room = max_out[idx] - p_dispatch_temp[idx]\n                inc = min(room, residual)\n                p_dispatch_temp[idx] += inc\n                residual -= inc\n            else:\n                candidates = []\n                for i in comm_indices:\n                    if p_dispatch_temp[i] > min_out[i] + tol_res:\n                        if units_info[i]['c_i'] > 0:\n                            cost = 2 * units_info[i]['c_i'] * p_dispatch_temp[i] + units_info[i]['b_i']\n                        else:\n                            cost = units_info[i]['b_i']\n                        candidates.append((i, cost))\n                if not candidates: \n                    break\n                candidates.sort(key=lambda x: x[1], reverse=True)\n                idx = candidates[0][0]\n                room = p_dispatch_temp[idx] - min_out[idx]\n                dec = min(room, -residual)\n                p_dispatch_temp[idx] -= dec\n                residual += dec\n                \n        # Update final dispatch values\n        for i in comm_indices:\n            u_dispatch[i] = 1\n            p_dispatch[i] = p_dispatch_temp[i]\n            \n    return np.array([u_dispatch, p_dispatch])",
          "from": "mutation",
          "gap_power_rate": 0.005468458,
          "gap_price_rate": 0.008811912,
          "fitness": 0.007140185
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Preprocess units to determine forced commitment states based on minimum up/down times, shutdown ramp limits, and previous state.\n2. Compute available capacity from initially committed units.\n3. Turn on additional candidate units (not forced off) based on two-period average incremental cost until available capacity meets or exceeds current load.\n4. Turn off non-essential candidate units (those not forced on) based on highest operating cost to minimize total cost.\n5. Perform economic dispatch using bisection method to allocate load to committed units, respecting ramp limits and power bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    \n    forced_committed = []\n    candidate_off = []\n    candidate_on = []\n    \n    # Step 1: Determine forced commitment and candidate units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_committed.append(idx)\n            else:\n                candidate_off.append(idx)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                continue\n            else:\n                candidate_on.append(idx)\n    \n    # Helper function to get available capacity\n    def get_available_capacity(unit_indices):\n        total = 0.0\n        for idx in unit_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total += min(unit['p_max_i'], unit['p_start_i'])\n        return total\n    \n    # Initially committed units (forced on and candidate_off)\n    committed_units = forced_committed + candidate_off\n    total_available = get_available_capacity(committed_units)\n    \n    # Step 2: Turn on candidate units if needed\n    candidate_on_info = []\n    for idx in candidate_on:\n        unit = units_info[idx]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        \n        cost_current = s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        cost_next = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        total_cost = cost_current + cost_next\n        power_two_periods = 2 * p_min_i\n        aic_per_mw = total_cost / power_two_periods\n        \n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidate_on_info.append((idx, aic_per_mw, avail))\n    \n    candidate_on_info.sort(key=lambda x: x[1])\n    \n    for idx, _, avail in candidate_on_info:\n        if total_available >= current_load:\n            break\n        total_available += avail\n        committed_units.append(idx)\n    \n    # Step 3: Turn off non-essential candidate_off units\n    candidate_off_info = []\n    for idx in candidate_off:\n        if idx not in committed_units:\n            continue\n        unit = units_info[idx]\n        min_power = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_off_info.append((idx, cost, avail))\n    \n    candidate_off_info.sort(key=lambda x: x[1], reverse=True)\n    \n    new_committed = list(committed_units)\n    total_available_new = total_available\n    for idx, _, avail in candidate_off_info:\n        if (total_available_new - avail) >= current_load:\n            total_available_new -= avail\n            new_committed.remove(idx)\n    committed_units = new_committed\n    \n    # Prepare schedules array\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    for idx in committed_units:\n        schedules[0, idx] = 1\n    \n    # Step 4: Economic Dispatch\n    unit_bounds = []\n    for idx in committed_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        unit_bounds.append((idx, low_bound, high_bound))\n    \n    low_total = sum(low for _, low, _ in unit_bounds)\n    high_total = sum(high for _, _, high in unit_bounds)\n    \n    # If load not feasible, use bounds\n    if current_load < low_total or current_load > high_total:\n        for idx, low, high in unit_bounds:\n            if current_load < low_total:\n                schedules[1, idx] = low\n            else:\n                schedules[1, idx] = high\n        return schedules\n    \n    # Dispatch parameters\n    dispatch_list = []\n    min_ic = float('inf')\n    max_ic = -float('inf')\n    \n    for idx, low, high in unit_bounds:\n        unit = units_info[idx]\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        ic_low = b_i + 2 * c_i * low\n        ic_high = b_i + 2 * c_i * high\n        min_ic = min(min_ic, ic_low)\n        max_ic = max(max_ic, ic_high)\n        dispatch_list.append((idx, b_i, c_i, low, high))\n    \n    # Lambda iteration\n    lambda_low = min_ic\n    lambda_high = max_ic\n    p_values = [low for _, _, _, low, _ in dispatch_list]\n    \n    if abs(high_total - low_total) > 1e-6:\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_power = 0.0\n            new_p_values = []\n            for idx, b_i, c_i, low, high in dispatch_list:\n                if c_i == 0:\n                    if lambda_mid < b_i:\n                        p_i = low\n                    else:\n                        p_i = high\n                else:\n                    p_i = (lambda_mid - b_i) / (2 * c_i)\n                    p_i = max(low, min(high, p_i))\n                new_p_values.append(p_i)\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                p_values = new_p_values\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            p_values = new_p_values\n    \n    # Assign dispatch results\n    for (idx, _, _, _, _), power in zip(dispatch_list, p_values):\n        schedules[1, idx] = power\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054685553,
          "gap_price_rate": 0.0092084548,
          "fitness": 0.0073385051
     },
     {
          "name": "enhanced_rolling_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (must run due to min uptime/shutdown constraints), forced-off (must remain off due to min downtime), free online (currently on but can be turned off), and free offline (currently off but can be started). \n2. For free units, compute a priority index (average cost per MW) at minimum feasible output:\n   - Free online units: (production cost at min output)/min output\n   - Free offline units: (amortized startup cost + production cost at min output)/min output, with startup cost amortized over min(2, min up-time) periods\n3. Build committed set by:\n   a. Starting with forced-on units\n   b. Adding free units in ascending priority order until total maximum output \u2265 current load\n   c. Removing the most expensive free units (highest priority index) until total minimum output \u2264 current load, ensuring removal doesn't violate total max output \u2265 load requirement\n4. For non-committed units, set commitment state=0 and output=0\n5. For committed units, calculate feasible output ranges considering ramp limits:\n   - Previously online: [max(p_min, p_prev - ramp_down), min(p_max, p_prev + ramp_up)]\n   - New starts: [p_min, min(p_max, start_capacity)]\n6. Perform constrained economic dispatch using lambda iteration:\n   a. Use bisection to find lambda that minimizes total production costs\n   b. Account for linear cost units (c_i=0) with constant marginal cost\n   c. Adjust outputs to exactly match load with merit-based residual distribution\n7. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_priority_dispatch(units_info, load):\n    current_load = load[0]  # We only use the current load for this period\n    \n    n_units = len(units_info)\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    # If there are no units, return zeros\n    if n_units == 0:\n        return np.array([u_arr, p_arr])\n    \n    forced_on_set = set()\n    free_online = []  # (index, min_output, max_output, priority)\n    free_offline = []  # (index, min_output, max_output, priority)\n    \n    # Calculate initial min/max outputs and classify units\n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        # Forced on: online and either not satisfied min uptime or can't shutdown\n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_on_set.add(i)\n        # Forced off: offline and not satisfied min downtime\n        elif u_i_0 == 0 and t_i_0 < 0 and abs(t_i_0) < t_off_min_i:\n            # Unit remains off\n            continue\n        # Free units\n        else:\n            if u_i_0 == 1:\n                min_out = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                max_out = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n                cost = unit['a_i'] + unit['b_i']*min_out + unit['c_i']*(min_out**2)\n                priority = cost / min_out\n                free_online.append((i, min_out, max_out, priority))\n            else:  # u_i_0==0\n                min_out = unit['p_min_i']\n                max_out = min(unit['p_max_i'], unit['p_start_i'])\n                n = min(2, t_on_min_i)  # Amortization periods\n                cost = unit['a_i'] + unit['b_i']*min_out + unit['c_i']*(min_out**2) + unit['s_i'] / n\n                priority = cost / min_out\n                free_offline.append((i, min_out, max_out, priority))\n    \n    # Combined free list sorted by priority (cheapest first)\n    free_list = free_online + free_offline\n    free_list.sort(key=lambda x: x[3])\n    \n    committed_set = set(forced_on_set)\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Calculate initial min/max from forced-on units\n    for i in forced_on_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_out\n        total_max += max_out\n    \n    # Add free units until max capacity >= load\n    for idx, min_out, max_out, _ in free_list:\n        if total_max < current_load:\n            committed_set.add(idx)\n            total_min += min_out\n            total_max += max_out\n        else:\n            break\n    \n    # Remove most expensive free units until min output <= load\n    free_committed = [x for x in free_list if x[0] in committed_set]\n    free_committed.sort(key=lambda x: x[3], reverse=True)  # Most expensive first\n    \n    for idx, min_out, max_out, _ in free_committed:\n        if total_min <= current_load:\n            break\n        if (total_min - min_out) <= current_load and (total_max - max_out) >= current_load:\n            committed_set.remove(idx)\n            total_min -= min_out\n            total_max -= max_out\n    \n    # Set non-committed units to off\n    for i in range(n_units):\n        if i not in committed_set:\n            u_arr[i] = 0\n            p_arr[i] = 0.0\n    \n    # Prepare dispatch for committed units\n    dispatch_units = []\n    bounds = {}\n    cost_params = {}\n    for i in committed_set:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        bounds[i] = (min_out, max_out)\n        cost_params[i] = (unit['b_i'], unit['c_i'])\n        dispatch_units.append(i)\n    \n    # Initialize outputs to minimums\n    p_outputs = {i: bounds[i][0] for i in committed_set}\n    total_gen = sum(p_outputs.values())\n    residual = current_load - total_gen\n    \n    # Dispatch using lambda iteration for quadratic costs\n    low_lambda = -1000000.0\n    high_lambda = 1000000.0\n    tol = 1e-5\n    max_iter = 1000\n    iter_count = 0\n    \n    # Find lambda boundaries\n    for i in committed_set:\n        b, c = cost_params[i]\n        min_i, max_i = bounds[i]\n        if c > 0:\n            marginal_min = b + 2 * c * min_i\n            marginal_max = b + 2 * c * max_i\n        else:\n            marginal_min = b\n            marginal_max = b\n        low_lambda = min(low_lambda, marginal_min)\n        high_lambda = max(high_lambda, marginal_max)\n    \n    low_lambda -= 100\n    high_lambda += 100\n    \n    # Lambda iteration\n    for _ in range(max_iter):\n        mid_lambda = (low_lambda + high_lambda) / 2.0\n        total_power = 0.0\n        for i in committed_set:\n            min_i, max_i = bounds[i]\n            b, c = cost_params[i]\n            if c > 0:\n                p = (mid_lambda - b) / (2 * c)\n                p = max(min_i, min(max_i, p))\n            else:\n                if mid_lambda < b:\n                    p = min_i\n                else:\n                    p = max_i\n            total_power += p\n        \n        if total_power < current_load:\n            low_lambda = mid_lambda\n        else:\n            high_lambda = mid_lambda\n        \n        if high_lambda - low_lambda < tol:\n            break\n    \n    # Set outputs from converged lambda\n    for i in committed_set:\n        min_i, max_i = bounds[i]\n        b, c = cost_params[i]\n        if c > 0:\n            p = (mid_lambda - b) / (2 * c)\n            p = max(min_i, min(max_i, p))\n        else:\n            if mid_lambda < b:\n                p = min_i\n            else:\n                p = max_i\n        p_outputs[i] = p\n    \n    total_gen = sum(p_outputs.values())\n    residual = current_load - total_gen\n    \n    # Adjust residual using merit order\n    iter_count = 0\n    while abs(residual) > 1e-3 and iter_count < 1000:\n        marginal_costs = {}\n        # Increase generation for positive residual\n        if residual > 0:\n            for i in committed_set:\n                if p_outputs[i] < bounds[i][1]:\n                    b, c = cost_params[i]\n                    if c > 0:\n                        marginal_costs[i] = b + 2*c*p_outputs[i]\n                    else:\n                        marginal_costs[i] = b\n            if marginal_costs:\n                idx_min = min(marginal_costs, key=marginal_costs.get)\n                max_adjust = bounds[idx_min][1] - p_outputs[idx_min]\n                adjust = min(residual, max_adjust)\n                p_outputs[idx_min] += adjust\n                residual -= adjust\n        # Decrease generation for negative residual\n        elif residual < 0:\n            for i in committed_set:\n                if p_outputs[i] > bounds[i][0]:\n                    b, c = cost_params[i]\n                    if c > 0:\n                        marginal_costs[i] = b + 2*c*p_outputs[i]\n                    else:\n                        marginal_costs[i] = b\n            if marginal_costs:\n                idx_max = max(marginal_costs, key=marginal_costs.get)\n                min_adjust = p_outputs[idx_max] - bounds[idx_max][0]\n                adjust = min(-residual, min_adjust)\n                p_outputs[idx_max] -= adjust\n                residual += adjust\n        iter_count += 1\n    \n    # Set final outputs\n    for i in committed_set:\n        u_arr[i] = 1\n        p_arr[i] = p_outputs[i]\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0063561409,
          "gap_price_rate": 0.0083857088,
          "fitness": 0.0073709249
     },
     {
          "name": "enhanced_adaptive_commitment_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units (eligible for commitment decisions).\n2. Calculate priority index for free units:\n   - For free units currently on: (a_i + b_i * min_output + c_i * min_output\u00b2) / min_output\n   - For free units currently off: (s_i/min(2,t_on_min_i) + a_i + b_i * min_output + c_i * min_output\u00b2) / min_output\n3. Initialize committed set with forced-on units. Add free units sorted by priority index until total max output \u2265 current load.\n4. Remove highest priority index free units until total min output \u2264 load, while maintaining total max output \u2265 load.\n5. Compute feasible power ranges for committed units considering ramp constraints and startup/shutdown limits.\n6. Perform constrained economic dispatch using lambda iteration for cost minimization:\n   a. Initialize lambda bounds based on marginal costs\n   b. Use bisection method to determine optimal generation\n   c. Apply merit-order adjustment for exact load matching if needed\n7. Set uncommitted units to off state (u_i=0, p_i=0).\n8. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    free_units = []\n    \n    # Classify units\n    for idx, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Previously online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(idx)\n            else:\n                free_units.append(idx)\n        else:  # Previously offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(idx)\n            else:\n                free_units.append(idx)\n    \n    # Calculate priority index for free units\n    priorities = {}\n    min_outputs = {}\n    max_outputs = {}\n    for idx in free_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:  # Free & currently online\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            min_outputs[idx] = min_out\n            max_outputs[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            priorities[idx] = cost / min_out\n        else:  # Free & currently offline\n            min_out = unit['p_min_i']\n            min_outputs[idx] = min_out\n            max_outputs[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            amortization = min(2, unit['t_on_min_i'])\n            cost = (unit['s_i'] / amortization) + unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n            priorities[idx] = cost / min_out\n    \n    # Build committed set\n    committed = set(forced_on)\n    free_sorted = sorted(free_units, key=lambda idx: priorities[idx])\n    \n    # Calculate total min/max for forced-on units\n    total_min = sum(min(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) \n                   if unit['u_i_0'] == 1 else unit['p_min_i'] for idx, unit in enumerate(units_info) if idx in forced_on)\n    total_max = sum(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) \n                   if unit['u_i_0'] == 1 else unit['p_start_i'] for idx, unit in enumerate(units_info) if idx in forced_on)\n    \n    # Add free units until load can be met\n    for idx in free_sorted:\n        if total_max < current_load:\n            committed.add(idx)\n            total_min += min_outputs[idx]\n            total_max += max_outputs[idx]\n    \n    # Remove expensive units if over-committed\n    removable = sorted((idx for idx in committed if idx in free_units), \n                      key=lambda idx: priorities[idx], reverse=True)\n    for idx in removable:\n        new_min = total_min - min_outputs[idx]\n        new_max = total_max - max_outputs[idx]\n        if new_min <= current_load and new_max >= current_load:\n            committed.remove(idx)\n            total_min = new_min\n            total_max = new_max\n    \n    # Precompute feasible power ranges for all committed units\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    for idx in range(n_units):\n        unit = units_info[idx]\n        if idx in committed:\n            if unit['u_i_0'] == 1:  # Previously online\n                feasible_min[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                feasible_max[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Starting up\n                feasible_min[idx] = unit['p_min_i']\n                feasible_max[idx] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            feasible_min[idx] = 0\n            feasible_max[idx] = 0\n    \n    # Economic dispatch for committed units\n    p_optimal = np.zeros(n_units)\n    active_units = [idx for idx in committed if feasible_max[idx] > feasible_min[idx]]\n    \n    if active_units:\n        # Initial dispatch at minimum output\n        for idx in committed:\n            p_optimal[idx] = feasible_min[idx]\n        total_gen = sum(p_optimal)\n        deficit = current_load - total_gen\n        \n        # Lambda iteration setup\n        low = min(unit['b_i'] + 2*unit['c_i']*feasible_min[idx] \n                  for idx, unit in enumerate(units_info) if idx in committed)\n        high = max(unit['b_i'] + 2*unit['c_i']*feasible_max[idx] \n                   for idx, unit in enumerate(units_info) if idx in committed)\n        \n        # Bisection method\n        tol = 1e-6\n        max_iter = 100\n        iter_count = 0\n        while abs(total_gen - current_load) > tol and iter_count < max_iter:\n            lam = (low + high) / 2\n            total_gen = 0\n            for idx in active_units:\n                unit = units_info[idx]\n                if unit['c_i'] > 0:\n                    p = (lam - unit['b_i']) / (2 * unit['c_i'])\n                    p = np.clip(p, feasible_min[idx], feasible_max[idx])\n                else:\n                    p = feasible_max[idx] if lam > unit['b_i'] else feasible_min[idx]\n                p_optimal[idx] = p\n                total_gen += p\n            \n            if total_gen < current_load:\n                low = lam\n            else:\n                high = lam\n            iter_count += 1\n        \n        # Merit-order adjustment if needed\n        deficit = current_load - total_gen\n        while abs(deficit) > tol:\n            if deficit > 0:  # Under generation\n                candidates = [idx for idx in active_units \n                              if p_optimal[idx] < feasible_max[idx]]\n                if not candidates:\n                    break\n                candidates.sort(key=lambda idx: units_info[idx]['b_i'] + 2*units_info[idx]['c_i']*p_optimal[idx])\n                for idx in candidates:\n                    space = min(deficit, feasible_max[idx] - p_optimal[idx])\n                    p_optimal[idx] += space\n                    deficit -= space\n                    if deficit <= 0:\n                        break\n            else:  # Over generation\n                candidates = [idx for idx in active_units \n                              if p_optimal[idx] > feasible_min[idx]]\n                if not candidates:\n                    break\n                candidates.sort(key=lambda idx: -(units_info[idx]['b_i'] + 2*units_info[idx]['c_i']*p_optimal[idx]))\n                for idx in candidates:\n                    space = min(-deficit, p_optimal[idx] - feasible_min[idx])\n                    p_optimal[idx] -= space\n                    deficit += space\n                    if deficit >= 0:\n                        break\n            total_gen = sum(p_optimal[idx] for idx in active_units)\n            deficit = current_load - total_gen\n    \n    # Prepare output schedule\n    u_schedule = np.zeros(n_units)\n    p_schedule = np.zeros(n_units)\n    for idx in range(n_units):\n        if idx in committed:\n            u_schedule[idx] = 1\n            p_schedule[idx] = p_optimal[idx]\n    \n    return np.vstack((u_schedule, p_schedule))",
          "from": "crossover",
          "gap_power_rate": 0.0058252224,
          "gap_price_rate": 0.0090085496,
          "fitness": 0.007416886
     }
]