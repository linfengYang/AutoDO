[
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. For free units, split into previously on/off. Compute priority index:\n   - For free units currently on: cost rate at min output (without startup cost)\n   - For free units currently off: amortize startup cost over min(2, min up-time) periods\n3. Form candidate list: forced-on units + free units sorted by priority index.\n4. Build committed set by adding candidates in ascending priority order until total capacity meets/exceeds current load, ensuring total minimum output <= load (remove expensive units if needed).\n5. For units not in committed set, set u_i=0, p_i=0.\n6. For committed units, perform constrained economic dispatch:\n   a. Compute feasible power ranges considering ramp constraints\n   b. Use lambda iteration to determine optimal generation\n   c. Adjust outputs to exactly match load by merit-order adjustment\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    priority_index = [0.0] * n_units\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > unit['p_shut_i']:\n                forced_on_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n            else:\n                free_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                cost = b_val * min_p_i + c_val * min_p_i**2\n                priority_index[i] = cost / min_p_i\n        else:\n            if abs(t_i_0) < t_off_min:\n                forced_off_indices.append(i)\n                min_p[i] = 0.0\n                max_p[i] = 0.0\n            else:\n                free_indices.append(i)\n                min_p_i = p_min\n                max_p_i = min(p_max, p_start, p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                s_val = unit['s_i']\n                periods = min(2, t_on_min)\n                cost = s_val + periods * (a + b_val * min_p_i + c_val * min_p_i**2)\n                priority_index[i] = cost / (min_p_i * periods)\n    \n    candidate_free = [(priority_index[i], i) for i in free_indices]\n    candidate_free.sort(key=lambda x: x[0])\n    committed_set = forced_on_indices.copy()\n    total_min = sum(min_p[i] for i in forced_on_indices)\n    total_max = sum(max_p[i] for i in forced_on_indices)\n    added_free = []\n    \n    for cost_val, idx in candidate_free:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        added_free.append(idx)\n        committed_set.append(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    while total_min > current_load and added_free:\n        idx = added_free.pop()\n        committed_set.remove(idx)\n        total_min -= min_p[idx]\n        total_max -= max_p[idx]\n    \n    for i in range(n_units):\n        if i in committed_set:\n            schedules[0, i] = 1\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0.0\n    \n    if not committed_set:\n        return schedules\n    \n    dispatch_units = []\n    dispatch_min = []\n    dispatch_max = []\n    for i in committed_set:\n        dispatch_units.append(units_info[i])\n        dispatch_min.append(min_p[i])\n        dispatch_max.append(max_p[i])\n    \n    powers = _dispatch(dispatch_units, dispatch_min, dispatch_max, current_load)\n    for j, idx in enumerate(committed_set):\n        schedules[1, idx] = powers[j]\n    \n    return schedules\n\ndef _dispatch(units, min_ps, max_ps, load):\n    n = len(units)\n    if n == 0:\n        return []\n    tol = 0.1\n    iter_max = 1000\n    lb = min(2 * u['c_i'] * min_ps[i] + u['b_i'] for i, u in enumerate(units))\n    ub = max(2 * u['c_i'] * max_ps[i] + u['b_i'] for i, u in enumerate(units))\n    mid = (lb + ub) / 2.0\n    total_gen = 0.0\n    \n    for it in range(iter_max):\n        powers = []\n        total_gen = 0.0\n        for i, u in enumerate(units):\n            c = u['c_i']\n            b = u['b_i']\n            if abs(c) < 1e-6:\n                if mid >= b:\n                    p = max_ps[i]\n                else:\n                    p = min_ps[i]\n            else:\n                p = (mid - b) / (2 * c)\n                p = max(min_ps[i], min(p, max_ps[i]))\n            powers.append(p)\n            total_gen += p\n        \n        if abs(total_gen - load) < tol:\n            break\n        if total_gen < load:\n            lb = mid\n        else:\n            ub = mid\n        mid = (lb + ub) / 2.0\n    \n    gap = load - total_gen\n    if gap > 0:\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] < max_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = max_ps[i] - powers[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            add = min(gap, headroom)\n            powers[i] += add\n            gap -= add\n    elif gap < 0:\n        gap = -gap\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] > min_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = powers[i] - min_ps[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            remove = min(gap, headroom)\n            powers[i] -= remove\n            gap -= remove\n    \n    return powers",
          "from": "crossover",
          "gap_power_rate": 0.0051591332,
          "gap_price_rate": 0.0083347383,
          "fitness": 0.0067469358
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Classify units into forced-on, forced-off, and free based on minimum up/down times and shutdown ramp constraints.\n   - Forced-on: Units that were online in the previous period and either haven't satisfied minimum up-time or their previous output exceeds the shutdown capacity.\n   - Forced-off: Units that were offline in the previous period and haven't satisfied minimum down-time.\n   - Free: All other units eligible for commitment decisions.\n2. Initialize the committed set with forced-on units. Calculate their feasible power outputs considering ramp constraints.\n3. For free units, calculate average cost per MW at minimum output, including amortized startup costs for offline units.\n4. Sort free units by average cost in ascending order and add them to the committed set until total maximum output meets or exceeds the current load and total minimum output is less than or equal to the load.\n5. If total minimum output exceeds load after step 4, remove the most expensive free units (highest average cost) until feasible.\n6. Perform constrained economic dispatch on the committed set using lambda iteration to minimize production costs while respecting power bounds and ramp constraints.\n7. Set uncommitted units to off state with zero output.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Classify units into forced-on, forced-off, and free\n    forced_on_units = []\n    forced_off_units = []\n    free_units = []\n    \n    for unit in units_info:\n        if unit['u_i_0'] == 1:  # Was online\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on_units.append(unit)\n            else:\n                free_units.append(unit)\n        else:  # Was offline\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off_units.append(unit)\n            else:\n                free_units.append(unit)\n    \n    # Helper function to compute feasible power range\n    def get_feasible_range(unit, will_commit):\n        if not will_commit:\n            return (0, 0)\n        if unit['u_i_0'] == 1:  # Was online, remains on\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Turning on\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        return (min_out, max_out)\n    \n    # Initialize committed set with forced-on units\n    committed_set = []\n    total_min = 0\n    total_max = 0\n    \n    for unit in forced_on_units:\n        min_u, max_u = get_feasible_range(unit, True)\n        unit['_min_current'] = min_u\n        unit['_max_current'] = max_u\n        total_min += min_u\n        total_max += max_u\n        committed_set.append(unit)\n    \n    # Calculate average cost for free units\n    for unit in free_units:\n        min_p = unit['p_min_i']\n        if unit['u_i_0'] == 1:  # Already online\n            total_cost = unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        else:  # Offline, include startup cost\n            total_cost = unit['a_i'] + unit['s_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        unit['_avg_cost'] = total_cost / min_p if min_p > 0 else float('inf')\n    \n    # Sort free units by average cost\n    sorted_free_units = sorted(free_units, key=lambda x: x['_avg_cost'])\n    \n    # Add free units to committed set in cost order\n    new_committed = []\n    for unit in sorted_free_units:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        min_u, max_u = get_feasible_range(unit, True)\n        candidate_min = total_min + min_u\n        candidate_max = total_max + max_u\n        \n        # Always add if needed for capacity, check min later\n        unit['_min_current'] = min_u\n        unit['_max_current'] = max_u\n        total_min = candidate_min\n        total_max = candidate_max\n        new_committed.append(unit)\n        if total_max >= current_load and total_min <= current_load:\n            break\n    \n    committed_set += new_committed\n    \n    # Remove expensive units if minimum output exceeds load\n    if total_min > current_load:\n        # Sort new_committed by cost descending\n        new_committed_sorted = sorted(new_committed, key=lambda x: x['_avg_cost'], reverse=True)\n        temp_min = total_min\n        temp_max = total_max\n        to_remove = []\n        for unit in new_committed_sorted:\n            if temp_min <= current_load:\n                break\n            temp_min -= unit['_min_current']\n            temp_max -= unit['_max_current']\n            to_remove.append(unit)\n        # Update committed set and totals\n        for unit in to_remove:\n            new_committed.remove(unit)\n            committed_set.remove(unit)\n            total_min -= unit['_min_current']\n            total_max -= unit['_max_current']\n    \n    # Economic dispatch via lambda iteration\n    u_list = np.zeros(n_units)\n    p_list = np.zeros(n_units)\n    \n    if committed_set:\n        # Get bounds for lambda\n        lows = []\n        highs = []\n        for unit in committed_set:\n            lows.append(unit['b_i'] + 2 * unit['c_i'] * unit['_min_current'])\n            highs.append(unit['b_i'] + 2 * unit['c_i'] * unit['_max_current'])\n        low_lam = min(lows) - 1.0\n        high_lam = max(highs) + 1.0\n        \n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low_lam + high_lam) / 2.0\n            total_p = 0.0\n            dispatch_vals = []\n            for unit in committed_set:\n                p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(unit['_min_current'], min(unit['_max_current'], p_i))\n                dispatch_vals.append(p_i)\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        # Assign dispatch values\n        for unit, p_val in zip(committed_set, dispatch_vals):\n            idx = units_info.index(unit)\n            u_list[idx] = 1\n            p_list[idx] = p_val\n    \n    # Set uncommitted units to off\n    for unit in forced_off_units + free_units:\n        if unit not in committed_set:\n            idx = units_info.index(unit)\n            u_list[idx] = 0\n            p_list[idx] = 0\n    \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0087811082,
          "fitness": 0.0071048229
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Preprocess units to determine forced commitment states based on minimum up/down times, shutdown ramp limits, and previous state.\n2. Compute available capacity from initially committed units.\n3. Turn on additional candidate units (not forced off) based on two-period average incremental cost until available capacity meets or exceeds current load.\n4. Turn off non-essential candidate units (those not forced on) based on highest operating cost to minimize total cost.\n5. Perform economic dispatch using bisection method to allocate load to committed units, respecting ramp limits and power bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    \n    forced_committed = []\n    candidate_off = []\n    candidate_on = []\n    \n    # Step 1: Determine forced commitment and candidate units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_committed.append(idx)\n            else:\n                candidate_off.append(idx)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                continue\n            else:\n                candidate_on.append(idx)\n    \n    # Helper function to get available capacity\n    def get_available_capacity(unit_indices):\n        total = 0.0\n        for idx in unit_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total += min(unit['p_max_i'], unit['p_start_i'])\n        return total\n    \n    # Initially committed units (forced on and candidate_off)\n    committed_units = forced_committed + candidate_off\n    total_available = get_available_capacity(committed_units)\n    \n    # Step 2: Turn on candidate units if needed\n    candidate_on_info = []\n    for idx in candidate_on:\n        unit = units_info[idx]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        \n        cost_current = s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        cost_next = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        total_cost = cost_current + cost_next\n        power_two_periods = 2 * p_min_i\n        aic_per_mw = total_cost / power_two_periods\n        \n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidate_on_info.append((idx, aic_per_mw, avail))\n    \n    candidate_on_info.sort(key=lambda x: x[1])\n    \n    for idx, _, avail in candidate_on_info:\n        if total_available >= current_load:\n            break\n        total_available += avail\n        committed_units.append(idx)\n    \n    # Step 3: Turn off non-essential candidate_off units\n    candidate_off_info = []\n    for idx in candidate_off:\n        if idx not in committed_units:\n            continue\n        unit = units_info[idx]\n        min_power = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_off_info.append((idx, cost, avail))\n    \n    candidate_off_info.sort(key=lambda x: x[1], reverse=True)\n    \n    new_committed = list(committed_units)\n    total_available_new = total_available\n    for idx, _, avail in candidate_off_info:\n        if (total_available_new - avail) >= current_load:\n            total_available_new -= avail\n            new_committed.remove(idx)\n    committed_units = new_committed\n    \n    # Prepare schedules array\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    for idx in committed_units:\n        schedules[0, idx] = 1\n    \n    # Step 4: Economic Dispatch\n    unit_bounds = []\n    for idx in committed_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        unit_bounds.append((idx, low_bound, high_bound))\n    \n    low_total = sum(low for _, low, _ in unit_bounds)\n    high_total = sum(high for _, _, high in unit_bounds)\n    \n    # If load not feasible, use bounds\n    if current_load < low_total or current_load > high_total:\n        for idx, low, high in unit_bounds:\n            if current_load < low_total:\n                schedules[1, idx] = low\n            else:\n                schedules[1, idx] = high\n        return schedules\n    \n    # Dispatch parameters\n    dispatch_list = []\n    min_ic = float('inf')\n    max_ic = -float('inf')\n    \n    for idx, low, high in unit_bounds:\n        unit = units_info[idx]\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        ic_low = b_i + 2 * c_i * low\n        ic_high = b_i + 2 * c_i * high\n        min_ic = min(min_ic, ic_low)\n        max_ic = max(max_ic, ic_high)\n        dispatch_list.append((idx, b_i, c_i, low, high))\n    \n    # Lambda iteration\n    lambda_low = min_ic\n    lambda_high = max_ic\n    p_values = [low for _, _, _, low, _ in dispatch_list]\n    \n    if abs(high_total - low_total) > 1e-6:\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_power = 0.0\n            new_p_values = []\n            for idx, b_i, c_i, low, high in dispatch_list:\n                if c_i == 0:\n                    if lambda_mid < b_i:\n                        p_i = low\n                    else:\n                        p_i = high\n                else:\n                    p_i = (lambda_mid - b_i) / (2 * c_i)\n                    p_i = max(low, min(high, p_i))\n                new_p_values.append(p_i)\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                p_values = new_p_values\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            p_values = new_p_values\n    \n    # Assign dispatch results\n    for (idx, _, _, _, _), power in zip(dispatch_list, p_values):\n        schedules[1, idx] = power\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054685553,
          "gap_price_rate": 0.0092084548,
          "fitness": 0.0073385051
     },
     {
          "name": "enhanced_adaptive_priority_dispatch",
          "algorithm": "**  \n1. Identify forced-on units (must remain on due to min uptime or shutdown constraints), forced-off units (must remain off due to min downtime), and free units.  \n2. Precompute min/max current-period outputs for all units considering ramp constraints:  \n   - For previously online units: min_output = max(p_min_i, p_i_0 - p_down_i), max_output = min(p_max_i, p_i_0 + p_up_i)  \n   - For free offline units: min_output = p_min_i, max_output = min(p_max_i, p_start_i)  \n3. Calculate cost rates for free units:  \n   - Free online: (a_i + b_i * min_output + c_i * min_output\u00b2) / min_output  \n   - Free offline: (s_i + a_i + b_i * min_output + c_i * min_output\u00b2) / min_output  \n4. Initialize committed_set with forced-on units. Add free units in ascending cost-rate order until total max_output \u2265 current load.  \n5. Remove highest-cost free units from committed_set (descending order) until total min_output \u2264 load, while ensuring total max_output \u2265 load after removal.  \n6. Set non-committed units to off (u_i=0, p_i=0).  \n7. For committed units, perform constrained economic dispatch:  \n   - Use lambda iteration to allocate load within min/max outputs, minimizing \u2211(a_i*u_i + b_i*p_i + c_i*p_i\u00b2)  \n   - Handle linear cost units (c_i=0) with priority to avoid lambda calculation  \n   - Scale outputs if needed to meet load within tolerance  \n8. Return commitment states and power outputs as a 2D NumPy array.  \n\n**",
          "code": "import numpy as np\n\ndef enhanced_adaptive_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on, forced_off, free = [], [], []\n    min_output, max_output = [0]*n_units, [0]*n_units\n    cost_rate = [np.inf] * n_units\n\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        if u_i0 == 1:\n            min_output[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_output[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:\n            min_output[i] = unit['p_min_i']\n            max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free.append(i)\n\n    for i in free:\n        unit = units_info[i]\n        production_cost = unit['a_i'] + unit['b_i']*min_output[i] + unit['c_i']*min_output[i]**2\n        if unit['u_i_0'] == 0:\n            production_cost += unit['s_i']\n        cost_rate[i] = production_cost / min_output[i]\n\n    committed_set = forced_on.copy()\n    total_min = sum(min_output[i] for i in committed_set)\n    total_max = sum(max_output[i] for i in committed_set)\n    sorted_free = sorted(free, key=lambda i: cost_rate[i])\n    added_free = []\n    \n    for i in sorted_free:\n        if total_max < current_load:\n            committed_set.append(i)\n            added_free.append(i)\n            total_min += min_output[i]\n            total_max += max_output[i]\n        else:\n            break\n    \n    if total_min > current_load:\n        sorted_removable = sorted(added_free, key=lambda i: cost_rate[i], reverse=True)\n        for i in sorted_removable:\n            new_min = total_min - min_output[i]\n            new_max = total_max - max_output[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed_set.remove(i)\n                total_min, total_max = new_min, new_max\n                if total_min <= current_load:\n                    break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i not in committed_set:\n            schedules[0, i], schedules[1, i] = 0, 0.0\n    \n    if not committed_set:\n        return schedules\n    \n    dispatch_units = []\n    indices = []\n    for i in committed_set:\n        unit = units_info[i]\n        dispatch_units.append({\n            'p_min': min_output[i],\n            'p_max': max_output[i],\n            'a': unit['a_i'],\n            'b': unit['b_i'],\n            'c': unit['c_i']\n        })\n        indices.append(i)\n    \n    n_committed = len(committed_set)\n    p_out = [min_output[i] for i in committed_set]\n    if abs(total_min - current_load) < 1e-6:\n        for idx, i in enumerate(committed_set):\n            schedules[0, i], schedules[1, i] = 1, min_output[i]\n        return schedules\n    \n    if total_min > current_load:\n        for i in committed_set:\n            schedules[0, i], schedules[1, i] = 1, min_output[i]\n        return schedules\n    \n    load_diff = current_load - total_min\n    incremental_cost = []\n    for data in dispatch_units:\n        if data['c'] == 0:\n            incremental_cost.append(data['b'])\n        else:\n            incremental_cost.append(2 * data['c'] * data['p_min'] + data['b'])\n    \n    order = np.argsort(incremental_cost)\n    headroom = [data['p_max'] - data['p_min'] for data in dispatch_units]\n    \n    for idx in order:\n        alloc = min(load_diff, headroom[idx])\n        p_out[idx] += alloc\n        load_diff -= alloc\n        if load_diff <= 0:\n            break\n    \n    if load_diff > 0:\n        scale_factor = current_load / sum(p_out)\n        p_out = [min(p * scale_factor, data['p_max']) for p, data in zip(p_out, dispatch_units)]\n        p_out = [max(p, data['p_min']) for p, data in zip(p_out, dispatch_units)]\n    \n    if abs(sum(p_out) - current_load) > 1e-3:\n        remaining_diff = current_load - sum(p_out)\n        if abs(remaining_diff) > 1e-3:\n            for j in range(n_committed):\n                current_val = p_out[j]\n                if remaining_diff > 0:\n                    new_val = min(current_val + remaining_diff, dispatch_units[j]['p_max'])\n                else:\n                    new_val = max(current_val + remaining_diff, dispatch_units[j]['p_min'])\n                p_out[j] = new_val\n                remaining_diff -= (new_val - current_val)\n                if abs(remaining_diff) < 1e-3:\n                    break\n    \n    for idx, unit_idx in enumerate(committed_set):\n        schedules[0, unit_idx] = 1\n        schedules[1, unit_idx] = p_out[idx]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.006183861,
          "gap_price_rate": 0.0102360276,
          "fitness": 0.0082099443
     },
     {
          "name": "refined_commitment_dispatch",
          "algorithm": "1. Identify forced-on units (must remain online due to min up-time or shutdown constraints), forced-off units (must remain offline due to min down-time), and free units (eligible for commitment decisions).\n2. For free units, compute average cost per MW at minimum feasible output (amortizing startup costs over min up-time for offline units) and sort by ascending cost.\n3. Start with forced-on units in the committed set. Add free units in cost-ascending order until total maximum capacity (considering ramp limits) meets or exceeds current load.\n4. Ensure total minimum output \u2264 load by removing most expensive free units if necessary.\n5. For committed units, calculate feasible power bounds using ramp limits, startup/shutdown constraints, and previous states.\n6. Perform economic dispatch:\n   a. Initialize each committed unit at its minimum feasible output.\n   b. Distribute any remaining load deficit to units with lowest incremental cost, respecting power bounds.\n7. Set uncommitted units offline with zero output.\n8. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef refined_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    free = []\n    \n    # Classify units (Step 1)\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                forced_on.append(i)\n            else:\n                free.append(i)\n        else:\n            if -t_i0 < t_off_min:\n                forced_off.append(i)\n            else:\n                free.append(i)\n    \n    # Precompute min_p, max_p for free units and average cost (Step 2)\n    min_p_free = {}\n    max_p_free = {}\n    avg_cost_free = []\n    \n    for i in free:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        p_start = unit['p_start_i']\n        \n        if u_i0 == 1:\n            min_p_val = max(p_min, p_i0 - p_down)\n            max_p_val = min(p_max, p_i0 + p_up)\n        else:\n            min_p_val = p_min\n            max_p_val = min(p_max, p_start, p_up)\n            \n        min_p_free[i] = min_p_val\n        max_p_free[i] = max_p_val\n        \n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        t_on_min = unit['t_on_min_i']\n        \n        if u_i0 == 1:\n            cost_per_mw = (a + b * min_p_val + c * min_p_val**2) / min_p_val\n        else:\n            amortization = s / max(1, min(5, t_on_min))\n            cost_per_mw = (a + amortization + b * min_p_val + c * min_p_val**2) / min_p_val\n            \n        avg_cost_free.append((cost_per_mw, i))\n    \n    # Sort free units by average cost (ascending)\n    avg_cost_free.sort(key=lambda x: x[0])\n    free_sorted = [i for _, i in avg_cost_free]\n    \n    # Initialize with forced-on units (Step 3)\n    committed = forced_on.copy()\n    total_min = 0.0\n    total_max = 0.0\n    min_p_forced = {}\n    max_p_forced = {}\n    \n    for i in forced_on:\n        unit = units_info[i]\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_up = unit['p_up_i']\n        p_down = unit['p_down_i']\n        min_p_val = max(p_min, p_i0 - p_down)\n        max_p_val = min(p_max, p_i0 + p_up)\n        min_p_forced[i] = min_p_val\n        max_p_forced[i] = max_p_val\n        total_min += min_p_val\n        total_max += max_p_val\n    \n    # Add free units until capacity meets/exceeds load\n    for i in free_sorted:\n        if total_max >= current_load:\n            break\n        committed.append(i)\n        total_min += min_p_free[i]\n        total_max += max_p_free[i]\n    \n    # Remove expensive units if min output exceeds load (Step 4)\n    if total_min > current_load:\n        free_in_committed = [i for i in committed if i in free]\n        cost_dict = {i: cost for cost, i in avg_cost_free}\n        free_in_committed.sort(key=lambda i: cost_dict[i], reverse=True)\n        \n        for i in free_in_committed:\n            if total_min <= current_load:\n                break\n            committed.remove(i)\n            total_min -= min_p_free[i]\n            total_max -= max_p_free[i]\n    \n    # Compute power bounds for committed units (Step 5)\n    allocated = {}\n    min_p = {}\n    max_p = {}\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min_val = unit['p_min_i']\n        p_max_val = unit['p_max_i']\n        p_up_val = unit['p_up_i']\n        p_down_val = unit['p_down_i']\n        p_start_val = unit['p_start_i']\n        \n        if i in committed:\n            if u_i0 == 1:\n                min_p_i = max(p_min_val, p_i0 - p_down_val)\n                max_p_i = min(p_max_val, p_i0 + p_up_val)\n            else:\n                min_p_i = p_min_val\n                max_p_i = min(p_max_val, p_up_val, p_start_val)\n            allocated[i] = min_p_i\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n        else:\n            allocated[i] = 0.0\n    \n    # Economic dispatch (Step 6)\n    if committed:\n        deficit = current_load - sum(allocated[i] for i in committed)\n        while deficit > 1e-6:  # Tolerance for floating-point\n            min_ic = float('inf')\n            candidate_i = None\n            \n            for i in committed:\n                if allocated[i] >= max_p[i] - 1e-6:\n                    continue\n                ic_val = 2 * units_info[i]['c_i'] * allocated[i] + units_info[i]['b_i']\n                if ic_val < min_ic:\n                    min_ic = ic_val\n                    candidate_i = i\n            \n            if candidate_i is None:\n                break\n            \n            headroom = max_p[candidate_i] - allocated[candidate_i]\n            amount = min(deficit, headroom)\n            allocated[candidate_i] += amount\n            deficit -= amount\n    \n    # Prepare output (Step 7 and 8)\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if i in committed else 0\n        schedules[1, i] = allocated.get(i, 0.0)\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0061537333,
          "gap_price_rate": 0.010430666,
          "fitness": 0.0082921997
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run units that cannot be turned off due to min-up time, shutdown ramp limits, or ramp-down constraints.\n2. Identify must-off units that cannot be turned on due to min-down time constraints.\n3. Sort eligible candidate units by average cost per MW (includes startup cost for off units, excludes for on units).\n4. Commit must-run units and add candidate units in cost-ascending order until capacity meets current load.\n5. For committed units, calculate dispatch bounds based on operational constraints (ramps, startup capacities).\n6. Perform economic dispatch using lambda iteration to allocate load to units within bounds.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    must_run = set()\n    # Identify must-run units\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.add(id(unit))\n            elif unit['p_i_0'] > unit['p_shut_i'] or unit['p_i_0'] > unit['p_down_i']:\n                must_run.add(id(unit))\n    \n    # Helper to check must-off units\n    def is_must_off(unit):\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            return True\n        return False\n    \n    # Build candidate units list\n    candidate_units = []\n    for unit in units_info:\n        uid = id(unit)\n        if uid in must_run:\n            continue\n        if is_must_off(unit):\n            continue\n        candidate_units.append(unit)\n    \n    # Calculate average cost for commitment priority\n    def avg_cost(unit):\n        if unit['u_i_0'] == 1:  # On unit: only fuel cost\n            return (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        else:  # Off unit: fuel cost + startup\n            return (unit['s_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n    \n    # Sort by average cost\n    candidate_units_sorted = sorted(candidate_units, key=avg_cost)\n    \n    # Build final commitment set\n    committed_units = set(must_run)\n    total_capacity = 0.0\n    # Add must-run capacity\n    for unit in units_info:\n        if id(unit) in must_run:\n            if unit['u_i_0'] == 1:\n                total_capacity += unit['p_max_i']\n            else:  # Starting unit has constrained capacity\n                total_capacity += min(unit['p_max_i'], unit['p_start_i'])\n    # Add candidate units until load met\n    for unit in candidate_units_sorted:\n        if total_capacity >= load[0]:\n            break\n        if unit['u_i_0'] == 1:  # Already on\n            added_capacity = unit['p_max_i']\n        else:  # Starting unit\n            added_capacity = min(unit['p_max_i'], unit['p_start_i'])\n        committed_units.add(id(unit))\n        total_capacity += added_capacity\n    \n    # Prepare for economic dispatch\n    committed_list = []\n    bounds = []\n    cost_params = []\n    for unit in units_info:\n        if id(unit) in committed_units:\n            # Calculate dispatch bounds\n            if unit['u_i_0'] == 1:  # Was on\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Was off (starting)\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            committed_list.append(unit)\n            bounds.append((lb, ub))\n            cost_params.append((unit['b_i'], unit['c_i']))\n    \n    if not committed_list:  # No units committed\n        schedules = np.zeros((2, len(units_info)))\n        return schedules\n    \n    # Lambda iteration for economic dispatch\n    low_lam = -10000.0\n    high_lam = 10000.0\n    tol = 0.01\n    n_iters = 100\n    for _ in range(n_iters):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0.0\n        for (b, c), (lb, ub) in zip(cost_params, bounds):\n            # Calculate unconstrained dispatch\n            if c == 0:\n                p = ub if mid_lam >= b else lb\n            else:\n                p = (mid_lam - b) / (2 * c)\n            p = max(lb, min(ub, p))\n            total_power += p\n        \n        if abs(total_power - load[0]) < tol:\n            break\n        if total_power < load[0]:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Calculate final dispatch values\n    dispatch = []\n    for (b, c), (lb, ub) in zip(cost_params, bounds):\n        if c == 0:\n            p = ub if mid_lam >= b else lb\n        else:\n            p = (mid_lam - b) / (2 * c)\n        p = max(lb, min(ub, p))\n        dispatch.append(p)\n    \n    # Map back to original units\n    schedule_u = []\n    schedule_p = []\n    idx = 0\n    for unit in units_info:\n        if id(unit) in committed_units:\n            schedule_u.append(1)\n            schedule_p.append(dispatch[idx])\n            idx += 1\n        else:\n            schedule_u.append(0)\n            schedule_p.append(0.0)\n    \n    schedules = np.array([schedule_u, schedule_p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0089824653,
          "gap_price_rate": 0.011717359,
          "fitness": 0.0103499122
     },
     {
          "name": "hybrid_priority_dispatch",
          "algorithm": "1. Identify must-on and must-off units based on min up/downtime and shutdown constraints.  \n2. Initialize committed set with must-on units. Calculate total min/max power.  \n3. Classify non-must units as free. For free units, compute min/max feasible power and average cost per MW (including startup cost for offline units).  \n4. Add free units to committed set in ascending cost order until total max power >= current load.  \n5. If total min power > load, remove most expensive free units (that can be safely shut down) until total min \u2264 load or infeasible.  \n6. Perform constrained economic dispatch on committed units via lambda iteration:  \n   - Set initial lambda bounds  \n   - Bisect lambda, compute optimal power outputs within ramp constraints  \n   - Adjust until total output meets load  \n7. Set non-committed units to off with 0 output.  \n\n",
          "code": "import numpy as np\n\ndef hybrid_priority_dispatch(units_info, load):\n    current_load = load[0]\n    units = units_info\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    # Identify must-on and must-off units\n    must_on = []\n    must_off = []\n    free_units = []\n    free_info = {}\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:  # Was online\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_units.append(i)\n        else:  # Was offline\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_units.append(i)\n    \n    # Initialize committed set and total power bounds\n    committed = must_on.copy()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Compute bounds for must-on units\n    for i in must_on:\n        unit = units[i]\n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += lb\n        total_max += ub\n    \n    # Compute bounds and costs for free units\n    for i in free_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:  # Online free unit\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_rate = (unit['b_i'] * unit['p_min_i'] + unit['c_i'] * unit['p_min_i']**2) / unit['p_min_i']\n        else:  # Offline free unit\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n            cost_rate = (unit['s_i'] + unit['b_i'] * lb + unit['c_i'] * lb**2) / lb\n        free_info[i] = {'lb': lb, 'ub': ub, 'cost_rate': cost_rate}\n    \n    # Sort free units by cost rate\n    free_sorted = sorted(free_units, key=lambda i: free_info[i]['cost_rate'])\n    \n    # Add free units until meeting load\n    removal_candidates = []\n    for i in free_sorted:\n        info = free_info[i]\n        if total_max < current_load:\n            committed.append(i)\n            removal_candidates.append(i)\n            total_min += info['lb']\n            total_max += info['ub']\n        else:\n            break\n    \n    # Remove expensive units if overcommitted\n    removal_candidates = sorted(removal_candidates, key=lambda i: -free_info[i]['cost_rate'])\n    if total_min > current_load:\n        temp_min, temp_max = total_min, total_max\n        for i in removal_candidates:\n            info = free_info[i]\n            new_min = temp_min - info['lb']\n            new_max = temp_max - info['ub']\n            if new_min <= current_load and new_max >= current_load:\n                if units[i]['u_i_0'] == 1 and units[i]['p_i_0'] > units[i]['p_down_i']:\n                    continue  # Cannot safely shut down\n                committed.remove(i)\n                temp_min, temp_max = new_min, new_max\n                if temp_min <= current_load:\n                    break\n        total_min, total_max = temp_min, temp_max\n    \n    # Calculate feasible bounds for all committed units\n    bounds = []\n    for i in committed:\n        unit = units[i]\n        if i in must_on or unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        bounds.append((lb, ub))\n    \n    # Extract cost coefficients\n    b_vec = np.array([units[i]['b_i'] for i in committed])\n    c_vec = np.array([units[i]['c_i'] for i in committed])\n    lb_arr = np.array([b[0] for b in bounds])\n    ub_arr = np.array([b[1] for b in bounds])\n    \n    # Lambda iteration for economic dispatch\n    lam_low = min(2 * c * lb_arr[i] + b for i, (b, c) in enumerate(zip(b_vec, c_vec)))\n    lam_high = max(2 * c * ub_arr[i] + b for i, (b, c) in enumerate(zip(b_vec, c_vec)))\n    \n    tol = 0.01\n    n_committed = len(committed)\n    p_dispatch = np.zeros(n_committed)\n    \n    for _ in range(100):\n        lam = (lam_low + lam_high) / 2\n        # Calculate power outputs\n        p_dispatch = np.zeros(n_committed)\n        for j in range(n_committed):\n            if c_vec[j] == 0:\n                p_dispatch[j] = lb_arr[j] if lam < b_vec[j] else ub_arr[j]\n            else:\n                p_dispatch[j] = max(lb_arr[j], min((lam - b_vec[j]) / (2 * c_vec[j]), ub_arr[j]))\n        \n        total_dispatch = np.sum(p_dispatch)\n        if abs(total_dispatch - current_load) < tol:\n            break\n        elif total_dispatch < current_load:\n            lam_low = lam\n        else:\n            lam_high = lam\n    \n    # Set output values\n    for i, idx in enumerate(committed):\n        u_out[idx] = 1\n        p_out[idx] = p_dispatch[i]\n    \n    for i in must_off:\n        u_out[i] = 0\n        p_out[i] = 0.0\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0057560584,
          "gap_price_rate": 0.0157988078,
          "fitness": 0.0107774331
     },
     {
          "name": "refined_adaptive_priority_dispatch",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_adaptive_priority_dispatch(units_info, load):\n    current_load = load[0]\n    units = [unit.copy() for unit in units_info]\n    \n    # Step 1: Classify units (forced online, forced offline, non-forced)\n    forced_online = []\n    forced_offline = []\n    non_forced = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_down_i = unit['p_down_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i or p_i0 > p_down_i:\n                forced_online.append(unit)\n            else:\n                non_forced.append(unit)\n        else:\n            if abs(t_i0) < t_off_min_i:  # t_i0 negative for offline\n                forced_offline.append(unit)\n            else:\n                non_forced.append(unit)\n    \n    # Initialize committed_set with forced_online\n    committed_set = forced_online.copy()\n    \n    # Precompute min/max outputs for forced_online units\n    for unit in committed_set:\n        if unit['u_i_0'] == 1:\n            unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            unit['min_p'] = unit['p_min_i']\n            unit['max_p'] = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    # Calculate current capacities\n    total_min_output = sum(unit['min_p'] for unit in committed_set)\n    total_max_capacity = sum(unit['max_p'] for unit in committed_set)\n    \n    # Precompute cost_per_mw for non_forced units\n    for unit in non_forced:\n        if unit['u_i_0'] == 1:\n            cost = (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n        else:\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n        unit['cost_per_mw'] = cost\n    \n    # Sort non_forced by cost_per_mw (ascending)\n    non_forced_sorted = sorted(non_forced, key=lambda x: x['cost_per_mw'])\n    \n    # Step 2: Add non_forced units until capacity meets/exceeds load\n    for unit in non_forced_sorted:\n        if total_max_capacity >= current_load:\n            break\n            \n        # Compute max_p for candidate unit\n        if unit['u_i_0'] == 1:\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            max_p = min(unit['p_max_i'], unit['p_up_i'], unit['p_start_i'])\n        \n        committed_set.append(unit)\n        total_max_capacity += max_p\n        unit['max_p'] = max_p  # Store for adjustment step\n    \n    # Precompute min_p for all units in committed_set\n    for unit in committed_set:\n        if 'min_p' not in unit:\n            if unit['u_i_0'] == 1:\n                unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                unit['min_p'] = unit['p_min_i']\n    \n    # Recompute total_min_output\n    total_min_output = sum(unit['min_p'] for unit in committed_set)\n    \n    # Get non_forced units in committed_set\n    non_forced_in_committed = [unit for unit in committed_set if unit in non_forced]\n    non_forced_in_committed_sorted = sorted(non_forced_in_committed, key=lambda x: x['cost_per_mw'], reverse=True)\n    \n    # Step 3: Adjust set to ensure total_min_output <= load\n    temp_min_output = total_min_output\n    temp_max_capacity = total_max_capacity\n    \n    for unit in non_forced_in_committed_sorted:\n        if temp_min_output <= current_load:\n            break\n            \n        new_max = temp_max_capacity - unit['max_p']\n        new_min = temp_min_output - unit['min_p']\n        \n        # Only remove if capacity still sufficient and min output decreases\n        if new_max >= current_load:\n            committed_set.remove(unit)\n            temp_min_output = new_min\n            temp_max_capacity = new_max\n    \n    # Step 4: Set initial outputs to min_p for committed units\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Get all unit indices for lookup\n    for unit in units:\n        idx = unit['idx'] if 'idx' in unit else units.index(unit)\n        if unit in committed_set:\n            schedules[0, idx] = 1\n            if unit['u_i_0'] == 1:\n                schedules[1, idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                schedules[1, idx] = unit['p_min_i']\n        else:\n            schedules[0, idx] = 0\n            schedules[1, idx] = 0.0\n    \n    # Step 5: Economic dispatch\n    total_current = np.sum(schedules[1])\n    deficit = current_load - total_current\n    \n    if deficit > 1e-5:\n        # Collect active units with headroom\n        active_units = []\n        for i, u in enumerate(units):\n            if schedules[0, i] == 1:\n                # Compute max_p for unit at this point\n                if u['u_i_0'] == 1:\n                    max_p = min(u['p_max_i'], u['p_i_0'] + u['p_up_i'])\n                else:\n                    max_p = min(u['p_max_i'], u['p_up_i'], u['p_start_i'])\n                headroom = max_p - schedules[1, i]\n                if headroom > 1e-5:\n                    active_units.append({\n                        'idx': i,\n                        'headroom': headroom,\n                        'b': u['b_i'],\n                        'c': u['c_i'],\n                        'current': schedules[1, i],\n                        'unit': u\n                    })\n        \n        # Sort by marginal cost (ascending)\n        active_units_sorted = sorted(active_units, key=lambda x: 2*x['c']*x['current'] + x['b'])\n        \n        # Distribute deficit\n        for unit_data in active_units_sorted:\n            if deficit <= 1e-5:\n                break\n            idx = unit_data['idx']\n            delta = min(unit_data['headroom'], deficit)\n            schedules[1, idx] += delta\n            deficit -= delta\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0004959585,
          "gap_price_rate": 0.0253531566,
          "fitness": 0.0129245576
     },
     {
          "name": "dynamic_priority_heuristic",
          "algorithm": "1. Enforce minimum up/down times and shutdown ramp constraints\n2. Calculate priority index for non-forced units: \n   - Active units: marginal cost at p_min_i\n   - Inactive units: marginal cost + amortized startup cost\n3. Commit units by priority order until total capacity \u2265 load\n4. Initialize outputs at feasible minimums considering ramping constraints\n5. Perform economic dispatch:\n   - Increase output for lowest marginal cost units with headroom\n   - Decrease output for highest marginal cost units with footroom\n   - Iterate until load is met within tolerance\n\n",
          "code": "import numpy as np\n\ndef dynamic_priority_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    \n    # Enforce constraints\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on[idx] = True\n        else:\n            if abs(t_i0) < t_off_min:\n                forced_off[idx] = True\n    \n    u = [0] * n_units\n    p = [0] * n_units\n    \n    # Commit forced units\n    for idx in range(n_units):\n        if forced_on[idx]:\n            u[idx] = 1\n        if forced_off[idx]:\n            u[idx] = 0\n    \n    # Priority calculation\n    eligible_units = []\n    for idx in range(n_units):\n        if forced_on[idx] or forced_off[idx]:\n            continue\n        unit = units_info[idx]\n        p_min = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            priority = (unit['b_i'] + 2 * unit['c_i'] * p_min) / p_min\n        else:\n            amortized_startup = unit['s_i'] / (unit['t_on_min_i'] * p_min)\n            priority = (unit['b_i'] + 2 * unit['c_i'] * p_min) / p_min + amortized_startup\n        eligible_units.append((priority, idx))\n    \n    eligible_units.sort(key=lambda x: x[0])\n    \n    # Commit by priority\n    total_max = 0\n    for idx in range(n_units):\n        if u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total_max += min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    for priority, idx in eligible_units:\n        if total_max >= current_load:\n            break\n        u[idx] = 1\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            total_max += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            total_max += min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    # Initialize outputs\n    total_power = 0\n    for idx in range(n_units):\n        if u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                p[idx] = lb\n            else:\n                p[idx] = unit['p_min_i']\n            total_power += p[idx]\n    \n    # Economic dispatch\n    tolerance = 0.1\n    while abs(total_power - current_load) > tolerance:\n        if total_power < current_load:  # Need more power\n            min_mc = float('inf')\n            candidate = -1\n            max_inc = 0\n            for idx in range(n_units):\n                if u[idx] == 0:\n                    continue\n                unit = units_info[idx]\n                mc = 2 * unit['c_i'] * p[idx] + unit['b_i']\n                # Compute headroom\n                if unit['u_i_0'] == 1:\n                    ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                else:\n                    ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n                headroom = ub - p[idx]\n                if headroom > tolerance and mc < min_mc:\n                    min_mc = mc\n                    candidate = idx\n                    max_inc = headroom\n            if candidate == -1:\n                break\n            inc = min(max_inc, current_load - total_power)\n            p[candidate] += inc\n            total_power += inc\n        \n        else:  # Need less power\n            max_mc = -float('inf')\n            candidate = -1\n            max_dec = 0\n            for idx in range(n_units):\n                if u[idx] == 0 or units_info[idx]['u_i_0'] == 0:\n                    continue\n                unit = units_info[idx]\n                mc = 2 * unit['c_i'] * p[idx] + unit['b_i']\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                footroom = p[idx] - lb\n                if footroom > tolerance and mc > max_mc:\n                    max_mc = mc\n                    candidate = idx\n                    max_dec = footroom\n            if candidate == -1:\n                break\n            dec = min(max_dec, total_power - current_load)\n            p[candidate] -= dec\n            total_power -= dec\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.0055517872,
          "gap_price_rate": 0.0215854404,
          "fitness": 0.0135686138
     }
]