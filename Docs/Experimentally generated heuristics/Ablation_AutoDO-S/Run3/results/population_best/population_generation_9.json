{
     "name": "combined_rolling_commitment",
     "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time), and free units.\n2. Compute min_bound and max_bound for forced-on and free units considering ramp limits and startup constraints.\n3. Calculate priority index for free units: amortize startup costs over min(2, min up-time) periods for offline units, then compute (amortized startup cost + production cost at min_bound) / min_bound.\n4. Initialize committed_set with forced-on units. Calculate total_min and total_max.\n5. Add free units to committed_set by ascending priority index until total_max >= current load.\n6. Remove highest-priority (most expensive) free units if total_min > load, ensuring total_max remains >= load.\n7. Recompute bounds for all committed units and determine effective_load = min(total_max, max(total_min, load)).\n8. Perform economic dispatch via lambda iteration for committed units to minimize total cost within individual bounds:\n   a. Separate quadratic and linear cost units\n   b. Use bisection to find optimal lambda\n   c. Adjust outputs via merit-order distribution of residual\n9. Set uncommitted units to offline (u_i=0, p_i=0).\n10. Return commitment states and power outputs.\n\n",
     "code": "import numpy as np\n\ndef combined_rolling_commitment(units_info, load):\n    units = [unit.copy() for unit in units_info]\n    current_load = load[0]\n    \n    forced_on = []\n    forced_off = []\n    free = []\n    \n    for unit in units:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(unit)\n            else:\n                free.append(unit)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free.append(unit)\n    \n    committed = forced_on.copy()\n    \n    def compute_bounds(unit):\n        if unit['u_i_0'] == 1:\n            min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_bound = unit['p_min_i']\n            max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'], unit['p_start_i'])\n        return min_bound, max_bound\n    \n    for unit in forced_on + free:\n        min_b, max_b = compute_bounds(unit)\n        unit['min_bound'] = min_b\n        unit['max_bound'] = max_b\n    \n    total_min = sum(unit['min_bound'] for unit in forced_on)\n    total_max = sum(unit['max_bound'] for unit in forced_on)\n    \n    for unit in free:\n        if unit['min_bound'] <= 0:\n            priority = float('inf')\n        else:\n            amortized_startup = unit['s_i'] / min(2, unit['t_on_min_i'])\n            base_cost = unit['a_i'] + unit['b_i'] * unit['min_bound'] + unit['c_i'] * unit['min_bound'] ** 2\n            priority = (base_cost + amortized_startup) / unit['min_bound'] if unit['u_i_0'] == 0 else base_cost / unit['min_bound']\n        unit['priority'] = priority\n    \n    free_sorted = sorted(free, key=lambda x: x['priority'])\n    free_committed = []\n    \n    for unit in free_sorted:\n        if total_max >= current_load:\n            break\n        committed.append(unit)\n        free_committed.append(unit)\n        total_min += unit['min_bound']\n        total_max += unit['max_bound']\n    \n    free_committed.sort(key=lambda x: x['priority'], reverse=True)\n    i = 0\n    while i < len(free_committed) and total_min > current_load:\n        unit = free_committed[i]\n        if total_max - unit['max_bound'] >= current_load:\n            committed.remove(unit)\n            free_committed.pop(i)\n            total_min -= unit['min_bound']\n            total_max -= unit['max_bound']\n            i = 0\n        else:\n            i += 1\n    \n    if committed:\n        for unit in committed:\n            min_b, max_b = compute_bounds(unit)\n            unit['min_bound'] = min_b\n            unit['max_bound'] = max_b\n        total_min = sum(unit['min_bound'] for unit in committed)\n        total_max = sum(unit['max_bound'] for unit in committed)\n        effective_load = min(total_max, max(total_min, current_load))\n        \n        def calc_power(lambd):\n            total = 0\n            for unit in committed:\n                if unit['c_i'] == 0:\n                    unit['temp_p'] = unit['min_bound'] if lambd < unit['b_i'] else unit['max_bound']\n                else:\n                    p = (lambd - unit['b_i']) / (2 * unit['c_i'])\n                    unit['temp_p'] = max(unit['min_bound'], min(unit['max_bound'], p))\n                total += unit['temp_p']\n            return total\n        \n        min_mc = float('inf')\n        max_mc = -float('inf')\n        for unit in committed:\n            if unit['c_i'] == 0:\n                mc = unit['b_i']\n            else:\n                mc_min = 2 * unit['c_i'] * unit['min_bound'] + unit['b_i']\n                mc_max = 2 * unit['c_i'] * unit['max_bound'] + unit['b_i']\n                mc = (mc_min, mc_max)\n                min_mc = min(min_mc, mc_min)\n                max_mc = max(max_mc, mc_max)\n            if unit['c_i'] == 0:\n                min_mc = min(min_mc, unit['b_i'])\n                max_mc = max(max_mc, unit['b_i'])\n        \n        lambd_low, lambd_high = min_mc, max_mc\n        tol, max_iter = 0.1, 100\n        for _ in range(max_iter):\n            lambd_mid = (lambd_low + lambd_high) / 2\n            total_power = calc_power(lambd_mid)\n            if abs(total_power - effective_load) < tol:\n                break\n            if total_power < effective_load:\n                lambd_low = lambd_mid\n            else:\n                lambd_high = lambd_mid\n        \n        for unit in committed:\n            unit['p_i'] = unit['temp_p']\n            unit['u_i'] = 1\n        total_power = sum(unit['p_i'] for unit in committed)\n        residual = effective_load - total_power\n        \n        if abs(residual) > tol:\n            if residual > 0:\n                adjust_units = [u for u in committed if u['p_i'] < u['max_bound']]\n                if adjust_units:\n                    adjust_units.sort(key=lambda u: (u['b_i'] + 2 * u['c_i'] * u['p_i']) if u['c_i'] != 0 else u['b_i'])\n                    i = 0\n                    while residual > tol and i < len(adjust_units):\n                        unit = adjust_units[i]\n                        inc = min(residual, unit['max_bound'] - unit['p_i'])\n                        unit['p_i'] += inc\n                        residual -= inc\n                        i += 1\n            else:\n                residual = -residual\n                adjust_units = [u for u in committed if u['p_i'] > u['min_bound']]\n                if adjust_units:\n                    adjust_units.sort(key=lambda u: (u['b_i'] + 2 * u['c_i'] * u['p_i']) if u['c_i'] != 0 else u['b_i'], reverse=True)\n                    i = 0\n                    while residual > tol and i < len(adjust_units):\n                        unit = adjust_units[i]\n                        dec = min(residual, unit['p_i'] - unit['min_bound'])\n                        unit['p_i'] -= dec\n                        residual -= dec\n                        i += 1\n    \n    for unit in units:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0.0\n    \n    schedule_arr = np.zeros((2, len(units)))\n    for i, unit in enumerate(units):\n        schedule_arr[0, i] = unit['u_i']\n        schedule_arr[1, i] = unit['p_i']\n    \n    return schedule_arr",
     "from": "crossover",
     "gap_power_rate": 0.0053991636,
     "gap_price_rate": 0.0080400593,
     "fitness": 0.0067196114
}