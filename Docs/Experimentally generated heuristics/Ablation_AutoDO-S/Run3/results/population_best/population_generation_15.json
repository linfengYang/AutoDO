{
     "name": "adaptive_amortized_rolling_commitment",
     "algorithm": "1. Classify units into forced-on (must remain online due to min up-time or shutdown constraints), forced-off (must remain offline due to min down-time constraints), and free units.\n2. Compute feasible power bounds for forced-on and free units considering:\n   - For currently online units: min_output = max(p_min_i, p_i_0 - p_down_i), max_output = min(p_max_i, p_i_0 + p_up_i)\n   - For offline free units: min_output = p_min_i, max_output = min(p_max_i, p_start_i)\n3. Calculate priority index for free units with startup cost amortized over min(2, min_up_time) periods:\n   - Online free: (a_i + b_i * min_output + c_i * min_output\u00b2) / min_output\n   - Offline free: (a_i + b_i * min_output + c_i * min_output\u00b2 + s_i / min(2, min_up_time)) / min_output\n4. Initialize committed_set with forced-on units and accumulate min/max outputs.\n5. Add free units to committed_set in ascending priority order until total_max >= current load.\n6. Remove highest-cost free units if total_min > load while maintaining total_max >= load.\n7. Set effective_load = min(total_max, max(total_min, current_load)).\n8. Perform economic dispatch via lambda iteration:\n   a. Separate quadratic and linear cost units\n   b. Use bisection to find optimal lambda within unit bounds\n   c. Adjust outputs via marginal-cost merit order for residual\n9. Set uncommitted units to offline with zero output.\n10. Return commitment states and power outputs.\n\n",
     "code": "import numpy as np\n\ndef adaptive_amortized_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u_i = np.zeros(n)\n    p_i = np.zeros(n)\n    min_bound = [0] * n\n    max_bound = [0] * n\n    priority_index = [0] * n\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    current_load = load[0]\n    \n    # Classify units and compute feasible bounds\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                forced_on_indices.append(i)\n            else:\n                free_indices.append(i)\n            min_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                free_indices.append(i)\n            min_bound[i] = unit['p_min_i']\n            max_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate priority index for free units\n    for i in free_indices:\n        unit = units_info[i]\n        a = unit['a_i']\n        b_val = unit['b_i']\n        c_val = unit['c_i']\n        if unit['u_i_0'] == 1:\n            cost = a + b_val * min_bound[i] + c_val * min_bound[i] ** 2\n            priority_index[i] = cost / min_bound[i] if min_bound[i] > 0 else float('inf')\n        else:\n            amortized = unit['s_i'] / min(2, unit['t_on_min_i'])\n            cost = a + b_val * min_bound[i] + c_val * min_bound[i] ** 2 + amortized\n            priority_index[i] = cost / min_bound[i] if min_bound[i] > 0 else float('inf')\n    \n    # Build commitment set\n    committed_set = forced_on_indices[:]\n    total_min = sum(min_bound[i] for i in forced_on_indices)\n    total_max = sum(max_bound[i] for i in forced_on_indices)\n    \n    free_sorted = sorted(free_indices, key=lambda i: priority_index[i])\n    new_committed = []\n    \n    for i in free_sorted:\n        if total_max >= current_load:\n            break\n        committed_set.append(i)\n        new_committed.append(i)\n        total_min += min_bound[i]\n        total_max += max_bound[i]\n    \n    # Remove expensive units if needed\n    if total_min > current_load and new_committed:\n        new_committed_sorted = sorted(new_committed, key=lambda i: priority_index[i], reverse=True)\n        for i in new_committed_sorted:\n            test_min = total_min - min_bound[i]\n            test_max = total_max - max_bound[i]\n            if test_max >= current_load:\n                committed_set.remove(i)\n                total_min = test_min\n                total_max = test_max\n                if total_min <= current_load:\n                    break\n    \n    # Set effective load\n    effective_load = min(total_max, max(total_min, current_load))\n    \n    # Economic dispatch preparation\n    n_committed = len(committed_set)\n    a_arr = np.zeros(n_committed)\n    b_arr = np.zeros(n_committed)\n    c_arr = np.zeros(n_committed)\n    lb_arr = np.zeros(n_committed)\n    ub_arr = np.zeros(n_committed)\n    \n    for idx, i in enumerate(committed_set):\n        unit = units_info[i]\n        a_arr[idx] = unit['a_i']\n        b_arr[idx] = unit['b_i']\n        c_arr[idx] = unit['c_i']\n        lb_arr[idx] = min_bound[i]\n        ub_arr[idx] = max_bound[i]\n    \n    # Lambda iteration dispatch\n    p_dispatch = np.zeros(n_committed)\n    tol = 1e-5\n    max_iter = 100\n    lam_low = 0\n    lam_high = 1e6\n    lam_mid = 0\n    \n    if n_committed > 0:\n        for _ in range(max_iter):\n            lam_mid = (lam_low + lam_high) / 2\n            total_p = 0\n            for i in range(n_committed):\n                if c_arr[i] > 0:\n                    p_val = (lam_mid - b_arr[i]) / (2 * c_arr[i])\n                else:\n                    p_val = lb_arr[i] if lam_mid < b_arr[i] else ub_arr[i]\n                p_val = np.clip(p_val, lb_arr[i], ub_arr[i])\n                p_dispatch[i] = p_val\n                total_p += p_val\n            \n            if total_p < effective_load:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n                \n            if abs(lam_high - lam_low) < tol:\n                break\n        \n        # Residual adjustment\n        residual = effective_load - total_p\n        if abs(residual) > tol:\n            if residual > 0:\n                adjustable = []\n                for i in range(n_committed):\n                    if p_dispatch[i] < ub_arr[i]:\n                        mc = b_arr[i] + 2*c_arr[i]*p_dispatch[i] if c_arr[i]>0 else b_arr[i]\n                        adjustable.append((i, mc))\n                adjustable.sort(key=lambda x: x[1])\n                res_remaining = residual\n                for idx, (i, mc) in enumerate(adjustable):\n                    if res_remaining <= 0:\n                        break\n                    headroom = ub_arr[i] - p_dispatch[i]\n                    add = min(headroom, res_remaining / (len(adjustable) - idx))\n                    p_dispatch[i] += add\n                    res_remaining -= add\n            \n            elif residual < 0:\n                res_abs = abs(residual)\n                adjustable = []\n                for i in range(n_committed):\n                    if p_dispatch[i] > lb_arr[i]:\n                        mc = b_arr[i] + 2*c_arr[i]*p_dispatch[i] if c_arr[i]>0 else b_arr[i]\n                        adjustable.append((i, mc))\n                adjustable.sort(key=lambda x: x[1], reverse=True)\n                for idx, (i, mc) in enumerate(adjustable):\n                    if res_abs <= 0:\n                        break\n                    headroom = p_dispatch[i] - lb_arr[i]\n                    reduce = min(headroom, res_abs / (len(adjustable) - idx))\n                    p_dispatch[i] -= reduce\n                    res_abs -= reduce\n    \n    # Final assignments\n    for idx, i in enumerate(committed_set):\n        p_i[i] = p_dispatch[idx]\n        u_i[i] = 1\n    \n    return np.array([u_i, p_i])",
     "from": "crossover",
     "gap_power_rate": 0.0047890014,
     "gap_price_rate": 0.0082519398,
     "fitness": 0.0065204706
}