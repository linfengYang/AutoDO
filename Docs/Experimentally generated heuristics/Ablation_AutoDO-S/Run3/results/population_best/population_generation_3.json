{
     "name": "enhanced_rolling_commitment",
     "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. For free units, split into previously on/off. Compute priority index:\n   - For free units currently on: cost rate at min output (without startup cost)\n   - For free units currently off: amortize startup cost over min(2, min up-time) periods\n3. Form candidate list: forced-on units + free units sorted by priority index.\n4. Build committed set by adding candidates in ascending priority order until total capacity meets/exceeds current load, ensuring total minimum output <= load (remove expensive units if needed).\n5. For units not in committed set, set u_i=0, p_i=0.\n6. For committed units, perform constrained economic dispatch:\n   a. Compute feasible power ranges considering ramp constraints\n   b. Use lambda iteration to determine optimal generation\n   c. Adjust outputs to exactly match load by merit-order adjustment\n7. Return commitment states and power outputs.\n\n",
     "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    priority_index = [0.0] * n_units\n    \n    forced_on_indices = []\n    forced_off_indices = []\n    free_indices = []\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_start = unit['p_start_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min or p_i_0 > unit['p_shut_i']:\n                forced_on_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n            else:\n                free_indices.append(i)\n                min_p_i = max(p_min, p_i_0 - p_down)\n                max_p_i = min(p_max, p_i_0 + p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                cost = b_val * min_p_i + c_val * min_p_i**2\n                priority_index[i] = cost / min_p_i\n        else:\n            if abs(t_i_0) < t_off_min:\n                forced_off_indices.append(i)\n                min_p[i] = 0.0\n                max_p[i] = 0.0\n            else:\n                free_indices.append(i)\n                min_p_i = p_min\n                max_p_i = min(p_max, p_start, p_up)\n                min_p[i] = min_p_i\n                max_p[i] = max_p_i\n                a = unit['a_i']\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                s_val = unit['s_i']\n                periods = min(2, t_on_min)\n                cost = s_val + periods * (a + b_val * min_p_i + c_val * min_p_i**2)\n                priority_index[i] = cost / (min_p_i * periods)\n    \n    candidate_free = [(priority_index[i], i) for i in free_indices]\n    candidate_free.sort(key=lambda x: x[0])\n    committed_set = forced_on_indices.copy()\n    total_min = sum(min_p[i] for i in forced_on_indices)\n    total_max = sum(max_p[i] for i in forced_on_indices)\n    added_free = []\n    \n    for cost_val, idx in candidate_free:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        added_free.append(idx)\n        committed_set.append(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    while total_min > current_load and added_free:\n        idx = added_free.pop()\n        committed_set.remove(idx)\n        total_min -= min_p[idx]\n        total_max -= max_p[idx]\n    \n    for i in range(n_units):\n        if i in committed_set:\n            schedules[0, i] = 1\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0.0\n    \n    if not committed_set:\n        return schedules\n    \n    dispatch_units = []\n    dispatch_min = []\n    dispatch_max = []\n    for i in committed_set:\n        dispatch_units.append(units_info[i])\n        dispatch_min.append(min_p[i])\n        dispatch_max.append(max_p[i])\n    \n    powers = _dispatch(dispatch_units, dispatch_min, dispatch_max, current_load)\n    for j, idx in enumerate(committed_set):\n        schedules[1, idx] = powers[j]\n    \n    return schedules\n\ndef _dispatch(units, min_ps, max_ps, load):\n    n = len(units)\n    if n == 0:\n        return []\n    tol = 0.1\n    iter_max = 1000\n    lb = min(2 * u['c_i'] * min_ps[i] + u['b_i'] for i, u in enumerate(units))\n    ub = max(2 * u['c_i'] * max_ps[i] + u['b_i'] for i, u in enumerate(units))\n    mid = (lb + ub) / 2.0\n    total_gen = 0.0\n    \n    for it in range(iter_max):\n        powers = []\n        total_gen = 0.0\n        for i, u in enumerate(units):\n            c = u['c_i']\n            b = u['b_i']\n            if abs(c) < 1e-6:\n                if mid >= b:\n                    p = max_ps[i]\n                else:\n                    p = min_ps[i]\n            else:\n                p = (mid - b) / (2 * c)\n                p = max(min_ps[i], min(p, max_ps[i]))\n            powers.append(p)\n            total_gen += p\n        \n        if abs(total_gen - load) < tol:\n            break\n        if total_gen < load:\n            lb = mid\n        else:\n            ub = mid\n        mid = (lb + ub) / 2.0\n    \n    gap = load - total_gen\n    if gap > 0:\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] < max_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = max_ps[i] - powers[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0])\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            add = min(gap, headroom)\n            powers[i] += add\n            gap -= add\n    elif gap < 0:\n        gap = -gap\n        candidates = []\n        for i, u in enumerate(units):\n            if powers[i] > min_ps[i]:\n                mc = 2 * u['c_i'] * powers[i] + u['b_i']\n                headroom = powers[i] - min_ps[i]\n                candidates.append((mc, i, headroom))\n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, headroom in candidates:\n            if gap <= 0:\n                break\n            remove = min(gap, headroom)\n            powers[i] -= remove\n            gap -= remove\n    \n    return powers",
     "from": "crossover",
     "gap_power_rate": 0.0051591332,
     "gap_price_rate": 0.0083347383,
     "fitness": 0.0067469358
}