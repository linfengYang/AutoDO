[
     {
          "name": "rolling_commitment_amortized_refined",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp constraints), forced-off (violating min down-time), free-online (online without constraints), and free-offline (offline without constraints).\n2. Compute feasible power bounds considering ramp constraints: online units use [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]; offline units use [p_min_i, min(p_max_i, p_start_i)].\n3. Calculate amortized cost per MW at min power: free-online units use (a_i + b_i * min_p_i + c_i * min_p_i^2) / min_p_i; free-offline units amortize startup cost over min(2, t_on_min_i) periods.\n4. Initialize committed set with forced-on units. Traverse free candidates sorted by amortized cost: add units until total max capacity \u2265 load, skipping if cumulative min power exceeds load.\n5. If total max capacity < load, add skipped candidates in cost order.\n6. Remove highest-cost free units from committed set until cumulative min \u2264 load while maintaining total max capacity \u2265 load.\n7. Perform constrained economic dispatch via bisection-based lambda iteration to minimize production cost.\n8. Apply marginal-cost-based residual adjustment to close any remaining load gap.\n9. Set uncommitted units to offline state (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_amortized_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n            min_p_i = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_p_i = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n        else:\n            if -t_i0 < t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n            min_p_i = unit['p_min_i']\n            max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            \n    committed_set = set(forced_on)\n    total_min = sum(min_p[i] for i in forced_on)\n    total_max = sum(max_p[i] for i in forced_on)\n    \n    candidates = free_online + free_offline\n    cost_dict = {}\n    for i in candidates:\n        if i in free_online:\n            cost_per_MW = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n        else:\n            amort_period = max(1, min(2, units_info[i]['t_on_min_i']))\n            startup_amort = units_info[i]['s_i'] / amort_period\n            cost_per_MW = (units_info[i]['a_i'] + startup_amort + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n        cost_dict[i] = cost_per_MW\n        \n    amortized_cost = [(cost_dict[i], i) for i in candidates]\n    amortized_cost.sort(key=lambda x: x[0])\n    \n    skipped = []\n    for cost_val, idx in amortized_cost:\n        if total_max >= current_load:\n            break\n        if total_min + min_p[idx] > current_load:\n            skipped.append((cost_val, idx))\n            continue\n        committed_set.add(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    uncommitted = [(cost_val, idx) for cost_val, idx in amortized_cost if idx not in committed_set]\n    uncommitted += skipped\n    uncommitted.sort(key=lambda x: x[0])\n    \n    for cost_val, idx in uncommitted:\n        if total_max >= current_load:\n            break\n        committed_set.add(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n        \n    free_committed = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_committed_sorted = sorted(free_committed, key=lambda idx: cost_dict[idx], reverse=True)\n    \n    for idx in free_committed_sorted:\n        if total_min <= current_load:\n            break\n        if total_max - max_p[idx] >= current_load:\n            committed_set.remove(idx)\n            total_min -= min_p[idx]\n            total_max -= max_p[idx]\n    \n    committed_list = list(committed_set)\n    if not committed_list:\n        return np.array([u_i, p_i])\n    \n    # Lambda iteration\n    low_l = 0.0\n    high_l = 0.0\n    for i in committed_list:\n        marginal_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_p[i]\n        marginal_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_p[i]\n        if marginal_min > low_l:\n            low_l = marginal_min\n        if marginal_max > high_l:\n            high_l = marginal_max\n    \n    if high_l == low_l:\n        high_l = low_l + 1.0\n        \n    tol = 1e-5\n    iter_max = 100\n    iter_count = 0\n    total_gen = 0.0\n    \n    while iter_count < iter_max and abs(total_gen - current_load) > tol:\n        mid_l = (low_l + high_l) / 2.0\n        total_gen = 0.0\n        for i in committed_list:\n            if units_info[i]['c_i'] == 0:\n                p_val = max_p[i] if mid_l > units_info[i]['b_i'] else min_p[i]\n            else:\n                p_uncon = (mid_l - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_val = max(min_p[i], min(max_p[i], p_uncon))\n            p_i[i] = p_val\n            total_gen += p_val\n        \n        if total_gen < current_load:\n            low_l = mid_l\n        else:\n            high_l = mid_l\n        iter_count += 1\n    \n    # Residual gap adjustment\n    gap = current_load - total_gen\n    if gap > 0:  # under-generation\n        under_units = []\n        for i in committed_list:\n            headroom = max_p[i] - p_i[i]\n            if headroom > tol:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n                under_units.append((marginal_cost, i, headroom))\n        under_units.sort(key=lambda x: x[0])\n        for mc, i, hr in under_units:\n            if gap <= tol:\n                break\n            allocation = min(gap, hr)\n            p_i[i] += allocation\n            gap -= allocation\n    elif gap < 0:  # over-generation\n        gap_abs = -gap\n        over_units = []\n        for i in committed_list:\n            headroom = p_i[i] - min_p[i]\n            if headroom > tol:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n                over_units.append((marginal_cost, i, headroom))\n        over_units.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, hr in over_units:\n            if gap_abs <= tol:\n                break\n            allocation = min(gap_abs, hr)\n            p_i[i] -= allocation\n            gap_abs -= allocation\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u_i[i] = 1\n        else:\n            u_i[i] = 0\n            p_i[i] = 0.0\n\n    return np.array([u_i, p_i])",
          "from": "mutation",
          "gap_power_rate": 0.0030152788,
          "gap_price_rate": 0.0092961465,
          "fitness": 0.0061557127
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Classify units into forced-on (violating min up-time/shutdown constraints), forced-off (violating min down-time), free-online (online without forced constraints), and free-offline (offline without forced constraints). Forced-on units must remain online; forced-off units cannot be started.\n2. Compute feasible power bounds considering ramp constraints:\n   - Online units: min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - Offline units: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Calculate amortized cost per MW at min_p for free units:\n   - Free-online: (a_i + b_i*min_p + c_i*min_p\u00b2) / min_p\n   - Free-offline: (a_i + s_i/min(2,t_on_min_i) + b_i*min_p + c_i*min_p\u00b2) / min_p\n4. Initialize committed set with forced-on units. Create free candidate list sorted by amortized cost.\n5. Add free candidates in cost-ascending order, skipping if cumulative min_p > load. If cumulative max_p remains insufficient after adding all candidates meeting min constraint, add remaining candidates ignoring min constraint.\n6. If cumulative min_p > load, remove highest-cost free units while maintaining cumulative max_p >= load.\n7. Perform constrained economic dispatch for committed units using lambda iteration with bisection:\n   a. Set initial outputs to min_p\n   b. Use bisection to find optimal lambda\n   c. Clamp outputs to feasible bounds during iterations\n8. Apply marginal-cost-based residual adjustment to eliminate any remaining gap:\n   - Sort units by marginal cost at operating point\n   - For under-generation: increase cheapest units first\n   - For over-generation: decrease most expensive units first\n9. Set uncommitted units to offline state (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_list = np.zeros(n_units, dtype=int)\n    p_list = np.zeros(n_units)\n    \n    # Classify units and compute bounds\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    min_bounds, max_bounds = [0]*n_units, [0]*n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(idx)\n                min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                free_online.append(idx)\n                min_bounds[idx] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_bounds[idx] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                forced_off.append(idx)\n            else:\n                free_offline.append(idx)\n                min_bounds[idx] = unit['p_min_i']\n                max_bounds[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate amortized costs\n    cost_metric = [0]*n_units\n    free_candidates = []\n    \n    for idx in free_online:\n        unit = units_info[idx]\n        min_p = min_bounds[idx]\n        cost_metric[idx] = (unit['a_i'] + unit['b_i']*min_p + unit['c_i']*min_p**2) / min_p\n        free_candidates.append((idx, cost_metric[idx], 0))  # 0 indicates online\n    \n    for idx in free_offline:\n        unit = units_info[idx]\n        min_p = min_bounds[idx]\n        amort_periods = min(2, unit['t_on_min_i'])\n        startup_amortized = unit['s_i'] / amort_periods\n        cost_metric[idx] = (unit['a_i'] + startup_amortized + unit['b_i']*min_p + unit['c_i']*min_p**2) / min_p\n        free_candidates.append((idx, cost_metric[idx], 1))  # 1 indicates offline\n        \n    # Sort free candidates by amortized cost\n    free_candidates.sort(key=lambda x: x[1])\n    \n    # Build committed set\n    committed = set(forced_on)\n    skipped = []\n    total_min = sum(min_bounds[i] for i in committed)\n    total_max = sum(max_bounds[i] for i in committed)\n    \n    # First pass: add without violating min constraint\n    for idx, cost_val, _ in free_candidates:\n        new_min = total_min + min_bounds[idx]\n        new_max = total_max + max_bounds[idx]\n        if new_min <= current_load and new_max >= current_load:\n            committed.add(idx)\n            total_min, total_max = new_min, new_max\n        else:\n            skipped.append((idx, cost_val, _))\n    \n    # Second pass: add skipped if max capacity insufficient\n    for idx, cost_val, _ in skipped:\n        if total_max < current_load:\n            committed.add(idx)\n            total_min += min_bounds[idx]\n            total_max += max_bounds[idx]\n    \n    # Removal pass: remove most expensive if over-committed\n    removable = [i for i in committed if i not in forced_on]\n    removable.sort(key=lambda i: cost_metric[i], reverse=True)\n    \n    for idx in removable:\n        candidate_min = total_min - min_bounds[idx]\n        candidate_max = total_max - max_bounds[idx]\n        if candidate_min <= current_load and candidate_max >= current_load:\n            committed.remove(idx)\n            total_min, total_max = candidate_min, candidate_max\n    \n    # Handle no committed units case\n    if len(committed) == 0:\n        return np.array([u_list, p_list])\n    \n    # Lambda iteration dispatch\n    min_committed = [min_bounds[i] for i in committed]\n    max_committed = [max_bounds[i] for i in committed]\n    b_vals = [units_info[i]['b_i'] for i in committed]\n    c_vals = [units_info[i]['c_i'] for i in committed]\n    p_outputs = min_committed.copy()\n    \n    # Find lambda bounds\n    mc_low, mc_high = float('inf'), float('-inf')\n    for i in range(len(committed)):\n        min_p = min_committed[i]\n        max_p = max_committed[i]\n        mc_low = min(mc_low, b_vals[i] + 2 * c_vals[i] * min_p)\n        mc_high = max(mc_high, b_vals[i] + 2 * c_vals[i] * max_p)\n    \n    lambda_low, lambda_high = mc_low, mc_high\n    if lambda_low == lambda_high:\n        lambda_high += 1.0\n    \n    # Bisection method\n    tol = 1e-4\n    max_iter = 100\n    for _ in range(max_iter):\n        if abs(lambda_high - lambda_low) < tol:\n            break\n            \n        lambda_mid = (lambda_low + lambda_high) / 2\n        total_power = 0\n        for i in range(len(committed)):\n            if c_vals[i] == 0:\n                p_val = max_committed[i] if b_vals[i] < lambda_mid else min_committed[i]\n            else:\n                p_uncon = (lambda_mid - b_vals[i]) / (2 * c_vals[i])\n                p_val = max(min_committed[i], min(max_committed[i], p_uncon))\n            p_outputs[i] = p_val\n            total_power += p_val\n        \n        if total_power < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n    \n    # Distribute residual gap\n    gap = current_load - sum(p_outputs)\n    marginal_costs = []\n    for i in range(len(committed)):\n        if c_vals[i] == 0:\n            marginal_costs.append((i, b_vals[i]))\n        else:\n            marginal_costs.append((i, b_vals[i] + 2 * c_vals[i] * p_outputs[i]))\n    \n    if gap > 0:  # under-generation\n        marginal_costs.sort(key=lambda x: x[1])\n        for i, mc in marginal_costs:\n            headroom = max_committed[i] - p_outputs[i]\n            if headroom > 0:\n                add_val = min(headroom, gap)\n                p_outputs[i] += add_val\n                gap -= add_val\n                if gap <= 0:\n                    break\n    elif gap < 0:  # over-generation\n        marginal_costs.sort(key=lambda x: -x[1])\n        for i, mc in marginal_costs:\n            downtime = p_outputs[i] - min_committed[i]\n            if downtime > 0:\n                reduce_val = min(downtime, -gap)\n                p_outputs[i] -= reduce_val\n                gap += reduce_val\n                if gap >= 0:\n                    break\n    \n    # Assign results to output arrays\n    committed_list = list(committed)\n    for idx, p_val in zip(committed_list, p_outputs):\n        u_list[idx] = 1\n        p_list[idx] = p_val\n    \n    # For forced-off units (ensure offline)\n    for idx in forced_off:\n        u_list[idx] = 0\n        p_list[idx] = 0.0\n        \n    return np.array([u_list, p_list])",
          "from": "crossover",
          "gap_power_rate": 0.0050587522,
          "gap_price_rate": 0.0087413722,
          "fitness": 0.0069000622
     },
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "refined_commit_priority_ramp_aware",
          "algorithm": "1. Classify units into forced-on (units violating min uptime or shutdown ramp constraints), forced-off (units violating min downtime), free-online (currently online not forced-on), free-offline (currently offline not forced-off).\n2. Compute feasible power limits for current period considering ramp constraints: \n   - For forced-on and free-online units: min power = max(p_min_i, p_i_0 - p_down_i), max power = min(p_max_i, p_i_0 + p_up_i)\n   - For free-offline units: min power = p_min_i, max power = min(p_max_i, p_start_i)\n3. Form candidate list combining free-online and free-offline units sorted by amortized cost per MW: \n   - Free-online: (a_i + b_i*p_min + c_i*p_min\u00b2) / p_min\n   - Free-offline: (a_i + s_i + b_i*p_min + c_i*p_min\u00b2) / p_min\n4. Build committed set starting with forced-on units. Add candidates in ascending cost order until cumulative max capacity >= load, skipping any unit that would cause cumulative min power to exceed load.\n5. If cumulative max < load after exhausting candidates, add remaining units without min power constraint.\n6. Perform economic dispatch using lambda iteration to distribute load among committed units, respecting individual power limits.\n7. Set uncommitted units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_commit_priority_ramp_aware(units_info, load):\n    current_load = load[0]\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                forced_on.append(unit)\n            else:\n                free_online.append(unit)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free_offline.append(unit)\n    \n    for unit in forced_on + free_online:\n        unit['p_min_current'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['p_max_current'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p_min = unit['p_min_current']\n        unit['cost_rate'] = (unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n    \n    for unit in free_offline:\n        unit['p_min_current'] = unit['p_min_i']\n        unit['p_max_current'] = min(unit['p_max_i'], unit['p_start_i'])\n        p_min = unit['p_min_current']\n        unit['cost_rate'] = (unit['a_i'] + unit['s_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n    \n    candidates = sorted(free_online + free_offline, key=lambda u: u['cost_rate'])\n    committed = forced_on.copy()\n    total_min = sum(u['p_min_current'] for u in committed)\n    total_max = sum(u['p_max_current'] for u in committed)\n    skipped = []\n    \n    for unit in candidates:\n        if total_max >= current_load:\n            break\n        if total_min + unit['p_min_current'] <= current_load:\n            committed.append(unit)\n            total_min += unit['p_min_current']\n            total_max += unit['p_max_current']\n        else:\n            skipped.append(unit)\n    \n    if total_max < current_load:\n        for unit in skipped:\n            committed.append(unit)\n            total_min += unit['p_min_current']\n            total_max += unit['p_max_current']\n    \n    target = min(max(total_min, current_load), total_max)\n    \n    if committed:\n        low = min(u['b_i'] + 2*u['c_i']*u['p_min_current'] for u in committed)\n        high = max(u['b_i'] + 2*u['c_i']*u['p_max_current'] for u in committed)\n        \n        for _ in range(100):\n            lam = (low + high) / 2\n            total = 0\n            for u in committed:\n                if lam <= u['b_i'] + 2*u['c_i']*u['p_min_current']:\n                    total += u['p_min_current']\n                elif lam >= u['b_i'] + 2*u['c_i']*u['p_max_current']:\n                    total += u['p_max_current']\n                else:\n                    total += (lam - u['b_i']) / (2 * u['c_i'])\n            \n            if abs(total - target) < 1e-5:\n                break\n            if total < target:\n                low = lam\n            else:\n                high = lam\n        \n        for u in committed:\n            if lam <= u['b_i'] + 2*u['c_i']*u['p_min_current']:\n                u['p_i'] = u['p_min_current']\n            elif lam >= u['b_i'] + 2*u['c_i']*u['p_max_current']:\n                u['p_i'] = u['p_max_current']\n            else:\n                u['p_i'] = (lam - u['b_i']) / (2 * u['c_i'])\n    \n    schedules = [[], []]\n    for unit in units_info:\n        if unit in committed:\n            schedules[0].append(1)\n            schedules[1].append(unit.get('p_i', 0.0))\n        else:\n            schedules[0].append(0)\n            schedules[1].append(0.0)\n    \n    return np.array(schedules)",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0087811082,
          "fitness": 0.0071048229
     },
     {
          "name": "combined_priority_commitment_v1",
          "algorithm": null,
          "code": "import numpy as np\n\ndef combined_priority_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -t0 < min_down:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                \n    for i in forced_off:\n        schedules[0, i] = 0\n        schedules[1, i] = 0\n        \n    for i in forced_on + free_online:\n        unit = units_info[i]\n        min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    for i in free_offline:\n        unit = units_info[i]\n        min_p[i] = unit['p_min_i']\n        max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    committed = forced_on.copy()\n    curr_min = sum(min_p[i] for i in forced_on)\n    curr_max = sum(max_p[i] for i in forced_on)\n    \n    free_units = free_online + free_offline\n    metric = {}\n    \n    for i in free_units:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        min_val = min_p[i]\n        eff_min = max(min_val, 1e-5)\n        startup_cost = unit['s_i'] if i in free_offline else 0\n        cost_at_min = a + b * min_val + c * min_val ** 2 + startup_cost\n        metric[i] = cost_at_min / eff_min\n    \n    sorted_free = sorted(free_units, key=lambda i: metric[i])\n    skipped = []\n    \n    for i in sorted_free:\n        if curr_max >= load[0]:\n            break\n        if curr_min + min_p[i] <= load[0]:\n            committed.append(i)\n            curr_min += min_p[i]\n            curr_max += max_p[i]\n        else:\n            skipped.append(i)\n            \n    for i in skipped:\n        if curr_max >= load[0]:\n            break\n        committed.append(i)\n        curr_min += min_p[i]\n        curr_max += max_p[i]\n    \n    if curr_min > load[0]:\n        free_committed = [i for i in committed if i not in forced_on]\n        free_committed.sort(key=lambda i: metric[i], reverse=True)\n        for i in free_committed:\n            new_min = curr_min - min_p[i]\n            new_max = curr_max - max_p[i]\n            if new_max < load[0]:\n                continue\n            committed.remove(i)\n            curr_min = new_min\n            curr_max = new_max\n            if curr_min <= load[0]:\n                break\n    \n    for i in range(n_units):\n        if i not in committed:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    P_total = min(max(load[0], curr_min), curr_max)\n    \n    if committed:\n        if abs(curr_max - curr_min) < 1e-5:\n            for i in committed:\n                schedules[1, i] = min_p[i]\n        else:\n            def compute_total_p(lam):\n                total = 0\n                for i in committed:\n                    unit = units_info[i]\n                    b_val = unit['b_i']\n                    c_val = unit['c_i']\n                    if c_val == 0:\n                        p_val = min_p[i] if lam < b_val else max_p[i]\n                    else:\n                        low_mc = b_val + 2 * c_val * min_p[i]\n                        high_mc = b_val + 2 * c_val * max_p[i]\n                        if lam < low_mc:\n                            p_val = min_p[i]\n                        elif lam > high_mc:\n                            p_val = max_p[i]\n                        else:\n                            p_val = (lam - b_val) / (2 * c_val)\n                    total += p_val\n                return total\n            \n            lambda_low = -1e5\n            lambda_high = 1e5\n            tolerance = 0.01\n            max_iter = 1000\n            iter_count = 0\n            \n            while iter_count < max_iter:\n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_mid = compute_total_p(lambda_mid)\n                if abs(total_mid - P_total) < tolerance:\n                    break\n                if total_mid < P_total:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n                iter_count += 1\n            \n            total_final = 0\n            for i in committed:\n                unit = units_info[i]\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                if c_val == 0:\n                    p_val = min_p[i] if lambda_mid < b_val else max_p[i]\n                else:\n                    low_mc = b_val + 2 * c_val * min_p[i]\n                    high_mc = b_val + 2 * c_val * max_p[i]\n                    if lambda_mid < low_mc:\n                        p_val = min_p[i]\n                    elif lambda_mid > high_mc:\n                        p_val = max_p[i]\n                    else:\n                        p_val = (lambda_mid - b_val) / (2 * c_val)\n                schedules[1, i] = p_val\n                total_final += p_val\n            \n            residual = P_total - total_final\n            if abs(residual) > tolerance:\n                directions = 1 if residual > 0 else -1\n                adjust_units = []\n                for i in committed:\n                    if directions > 0 and schedules[1, i] < max_p[i]:\n                        mc = b_val + 2 * c_val * schedules[1, i] if c_val != 0 else b_val\n                        adjust_units.append((i, mc, 1))\n                    elif directions < 0 and schedules[1, i] > min_p[i]:\n                        mc = b_val + 2 * c_val * schedules[1, i] if c_val != 0 else b_val\n                        adjust_units.append((i, mc, -1))\n                if adjust_units:\n                    adjust_units.sort(key=lambda x: x[1] * x[2])\n                    adj_per_unit = residual / len(adjust_units)\n                    for i, _, _ in adjust_units:\n                        new_p = max(min_p[i], min(max_p[i], schedules[1, i] + adj_per_unit))\n                        schedules[1, i] = new_p\n        \n        for i in committed:\n            schedules[0, i] = 1\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054296182,
          "gap_price_rate": 0.008780955,
          "fitness": 0.0071052866
     },
     {
          "name": "enhanced_adaptive_commitment_v1",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown constraints), forced-off (violating min down-time), free-online (online without constraints), and free-offline (offline without constraints)\n2. Compute feasible power bounds considering ramp constraints:\n   - For online units: min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - For offline units: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Calculate amortized cost per MW at min power for free units with startup costs amortized over min(2, min_up_time)\n4. Build committed set starting with forced-on units\n5. Add free candidates by ascending cost until cumulative max_p \u2265 load, skipping if cumulative min_p > load\n6. If max_p < load after step 5, add skipped candidates without min_p constraint\n7. If min_p > load after step 6, remove highest-cost free units while maintaining max_p \u2265 load\n8. Perform constrained economic dispatch:\n   a. Use lambda iteration with bisection to distribute load\n   b. Clamp outputs to feasible bounds during iterations\n   c. Apply marginal-cost-based residual adjustment to close gaps\n9. Set uncommitted units to off (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_arr = [0] * n_units\n    p_arr = [0] * n_units\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    cost_per_mw = [0] * n_units\n    \n    # Classify units and compute bounds\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    candidate_free = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        t0 = unit['t_i_0']\n        s = unit['s_i']\n        \n        if u_i0 == 1:\n            offline_time = -t0\n            if t0 < t_on_min or p_i0 > p_shut:\n                forced_on.append(i)\n                min_p[i] = max(p_min, p_i0 - p_down)\n                max_p[i] = min(p_max, p_i0 + p_up)\n            else:\n                free_online.append(i)\n                min_p[i] = max(p_min, p_i0 - p_down)\n                max_p[i] = min(p_max, p_i0 + p_up)\n                if min_p[i] > 0:\n                    cost_per_mw[i] = (unit['a_i'] + unit['b_i'] * min_p[i] + \n                                      unit['c_i'] * min_p[i]**2) / min_p[i]\n                candidate_free.append((i, cost_per_mw[i], min_p[i], max_p[i]))\n        else:\n            offline_time = -t0\n            if offline_time < t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                min_p[i] = p_min\n                max_p[i] = min(p_max, unit['p_start_i'])\n                amort = min(2, t_on_min)\n                startup_amortized = s / amort\n                if min_p[i] > 0:\n                    cost_per_mw[i] = (unit['a_i'] + startup_amortized + \n                                      unit['b_i'] * min_p[i] + \n                                      unit['c_i'] * min_p[i]**2) / min_p[i]\n                candidate_free.append((i, cost_per_mw[i], min_p[i], max_p[i]))\n    \n    # Build committed set\n    committed_set = set(forced_on)\n    total_min = sum(min_p[i] for i in forced_on)\n    total_max = sum(max_p[i] for i in forced_on)\n    \n    # Sort candidates by cost\n    candidate_free.sort(key=lambda x: x[1])\n    skipped = []\n    \n    for cand in candidate_free:\n        idx, cost_val, cand_min, cand_max = cand\n        if total_max >= current_load:\n            break\n        if total_min + cand_min <= current_load:\n            committed_set.add(idx)\n            total_min += cand_min\n            total_max += cand_max\n        else:\n            skipped.append(cand)\n    \n    # Handle under-capacity\n    for cand in skipped:\n        idx, cost_val, cand_min, cand_max = cand\n        if total_max >= current_load:\n            break\n        committed_set.add(idx)\n        total_min += cand_min\n        total_max += cand_max\n    \n    # Remove high-cost units if over min_p\n    free_committed = [cand for cand in candidate_free if cand[0] in committed_set]\n    if total_min > current_load:\n        free_committed.sort(key=lambda x: x[1], reverse=True)\n        for cand in free_committed:\n            idx, cost_val, cand_min, cand_max = cand\n            if total_min - cand_min <= current_load:\n                continue\n            if total_max - cand_max < current_load:\n                continue\n            committed_set.remove(idx)\n            total_min -= cand_min\n            total_max -= cand_max\n            if total_min <= current_load:\n                break\n    \n    # Economic dispatch\n    output_p = {}\n    if total_min == current_load:\n        for i in committed_set:\n            output_p[i] = min_p[i]\n    elif total_max == current_load:\n        for i in committed_set:\n            output_p[i] = max_p[i]\n    else:\n        # Lambda iteration setup\n        epsilon = 1e-5\n        max_iter = 100\n        iter_count = 0\n        low = float('inf')\n        high = float('-inf')\n        \n        # Find lambda bounds\n        for i in committed_set:\n            unit = units_info[i]\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            if c_i == 0:\n                mc_low = b_i\n                mc_high = b_i\n            else:\n                mc_low = b_i + 2 * c_i * min_p[i]\n                mc_high = b_i + 2 * c_i * max_p[i]\n            low = min(low, mc_low)\n            high = max(high, mc_high)\n        \n        # Bisection\n        while iter_count < max_iter and abs(high - low) > epsilon:\n            lambda_mid = (low + high) / 2\n            total_gen = 0\n            for i in committed_set:\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                if c_i == 0:\n                    p_val = max_p[i] if lambda_mid >= b_i else min_p[i]\n                else:\n                    p_val = (lambda_mid - b_i) / (2 * c_i)\n                    p_val = max(min_p[i], min(p_val, max_p[i]))\n                total_gen += p_val\n            \n            if total_gen < current_load:\n                low = lambda_mid\n            else:\n                high = lambda_mid\n            iter_count += 1\n        \n        # Apply lambda solution\n        total_gen = 0\n        for i in committed_set:\n            unit = units_info[i]\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            if c_i == 0:\n                p_val = max_p[i] if lambda_mid >= b_i else min_p[i]\n            else:\n                p_val = (lambda_mid - b_i) / (2 * c_i)\n                p_val = max(min_p[i], min(p_val, max_p[i]))\n            output_p[i] = p_val\n            total_gen += p_val\n        \n        # Residual adjustment\n        residual = current_load - total_gen\n        adjust_candidates = []\n        for i in committed_set:\n            p_current = output_p[i]\n            unit = units_info[i]\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            if c_i == 0:\n                marginal_cost = b_i\n            else:\n                marginal_cost = b_i + 2 * c_i * p_current\n            adjust_up = max_p[i] - p_current\n            adjust_down = p_current - min_p[i]\n            adjust_candidates.append((i, marginal_cost, p_current, adjust_up, adjust_down))\n        \n        if residual > 0:\n            adjust_candidates.sort(key=lambda x: x[1])\n            for cand in adjust_candidates:\n                idx, mc, p_cur, up, down = cand\n                if residual <= 0:\n                    break\n                increment = min(up, residual)\n                output_p[idx] += increment\n                residual -= increment\n        else:\n            residual = abs(residual)\n            adjust_candidates.sort(key=lambda x: x[1], reverse=True)\n            for cand in adjust_candidates:\n                idx, mc, p_cur, up, down = cand\n                if residual <= 0:\n                    break\n                decrement = min(down, residual)\n                output_p[idx] -= decrement\n                residual -= decrement\n    \n    # Set outputs\n    for i in committed_set:\n        u_arr[i] = 1\n        p_arr[i] = output_p.get(i, min_p[i])\n    \n    return np.array([u_arr, p_arr])",
          "from": "mutation",
          "gap_power_rate": 0.0054684561,
          "gap_price_rate": 0.0088119113,
          "fitness": 0.0071401837
     },
     {
          "name": "refined_enhanced_adaptive_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_enhanced_adaptive_commitment_v2(units_info, load):\n    total_load = load[0]\n    units = []\n    for idx, unit_dict in enumerate(units_info):\n        unit = unit_dict.copy()\n        unit['index'] = idx\n        units.append(unit)\n    \n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(unit)\n            else:\n                free_online.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free_offline.append(unit)\n    \n    for unit in forced_on + free_online:\n        unit['min_p'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['max_p'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    for unit in free_offline:\n        unit['min_p'] = unit['p_min_i']\n        unit['max_p'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for unit in free_online:\n        cost = unit['a_i'] + unit['b_i'] * unit['min_p'] + unit['c_i'] * unit['min_p']**2\n        unit['amortized_cost'] = cost / unit['min_p']\n    for unit in free_offline:\n        periods = min(2, unit['t_on_min_i'])\n        cost = unit['a_i'] + unit['s_i']/periods + unit['b_i'] * unit['min_p'] + unit['c_i'] * unit['min_p']**2\n        unit['amortized_cost'] = cost / unit['min_p']\n    \n    candidate_list = sorted(free_online + free_offline, key=lambda u: u['amortized_cost'])\n    committed_set = forced_on.copy()\n    cum_min = sum(u['min_p'] for u in forced_on)\n    cum_max = sum(u['max_p'] for u in forced_on)\n    skipped = []\n    \n    for unit in candidate_list:\n        if cum_max >= total_load:\n            skipped.append(unit)\n            continue\n        if cum_min + unit['min_p'] <= total_load:\n            committed_set.append(unit)\n            cum_min += unit['min_p']\n            cum_max += unit['max_p']\n        else:\n            skipped.append(unit)\n    \n    if cum_max < total_load:\n        for unit in skipped:\n            if cum_max >= total_load:\n                break\n            committed_set.append(unit)\n            cum_min += unit['min_p']\n            cum_max += unit['max_p']\n            skipped.remove(unit)\n    \n    free_in_committed = [u for u in committed_set if u in free_online + free_offline]\n    free_in_committed.sort(key=lambda u: u['amortized_cost'], reverse=True)\n    for unit in free_in_committed:\n        if cum_min <= total_load:\n            break\n        new_cum_min = cum_min - unit['min_p']\n        new_cum_max = cum_max - unit['max_p']\n        if new_cum_max >= total_load:\n            committed_set.remove(unit)\n            cum_min, cum_max = new_cum_min, new_cum_max\n    \n    output_u = np.zeros(len(units))\n    output_p = np.zeros(len(units))\n    \n    if cum_min > total_load:\n        for unit in committed_set:\n            idx = unit['index']\n            output_u[idx] = 1\n            output_p[idx] = unit['min_p']\n    elif cum_max < total_load:\n        for unit in committed_set:\n            idx = unit['index']\n            output_u[idx] = 1\n            output_p[idx] = unit['max_p']\n    else:\n        committed_indices = [u['index'] for u in committed_set]\n        min_ps = np.array([u['min_p'] for u in committed_set])\n        max_ps = np.array([u['max_p'] for u in committed_set])\n        p_outputs = min_ps.copy()\n        \n        if abs(np.sum(p_outputs) - total_load) > 1e-3:\n            low_lambda = min(2*u['c_i']*u['min_p'] + u['b_i'] for u in committed_set) - 100\n            high_lambda = max(2*u['c_i']*u['max_p'] + u['b_i'] for u in committed_set) + 100\n            tol = 1e-3\n            for _ in range(100):\n                mid_lambda = (low_lambda + high_lambda) / 2\n                total_p = 0\n                for i, unit in enumerate(committed_set):\n                    if unit['c_i'] == 0:\n                        p = min_ps[i] if mid_lambda < unit['b_i'] else max_ps[i]\n                    else:\n                        p_val = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                        p = np.clip(p_val, min_ps[i], max_ps[i])\n                    p_outputs[i] = p\n                    total_p += p\n                if abs(total_p - total_load) < tol:\n                    break\n                if total_p < total_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            \n            gap = total_load - total_p\n            if gap > 0:\n                margins = [2*u['c_i']*p_outputs[i] + u['b_i'] \n                          for i, u in enumerate(committed_set)]\n                sorted_idx = np.argsort(margins)\n                for idx in sorted_idx:\n                    if gap <= 0:\n                        break\n                    avail = max_ps[idx] - p_outputs[idx]\n                    if avail > 0:\n                        add = min(avail, gap)\n                        p_outputs[idx] += add\n                        gap -= add\n            elif gap < 0:\n                gap = abs(gap)\n                margins = [2*u['c_i']*p_outputs[i] + u['b_i'] \n                          for i, u in enumerate(committed_set)]\n                sorted_idx = np.argsort(margins)[::-1]\n                for idx in sorted_idx:\n                    if gap <= 0:\n                        break\n                    avail = p_outputs[idx] - min_ps[idx]\n                    if avail > 0:\n                        reduce = min(avail, gap)\n                        p_outputs[idx] -= reduce\n                        gap -= reduce\n        \n        for i, unit in enumerate(committed_set):\n            idx = unit['index']\n            output_u[idx] = 1\n            output_p[idx] = p_outputs[i]\n    \n    return np.array([output_u, output_p])",
          "from": "mutation",
          "gap_power_rate": 0.0054684563,
          "gap_price_rate": 0.0088119113,
          "fitness": 0.0071401838
     },
     {
          "name": "enhanced_adaptive_commitment_v2",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown constraints), forced-off (violating min down-time), free-online (online without constraints), and free-offline (offline without constraints). Forced-on units must remain online; forced-off units cannot be started.\n2. Compute feasible power bounds considering ramp constraints:\n   - For online units (forced-on/free-online): min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - For offline free units: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Calculate amortized cost per MW at min_p for free units: \n   - Free-online: (a_i + b_i * min_p + c_i * min_p\u00b2) / min_p\n   - Free-offline: (a_i + s_i / min(2, t_on_min_i) + b_i * min_p + c_i * min_p\u00b2) / min_p\n4. Build candidate list of free units sorted by ascending amortized cost.\n5. Initialize committed set with forced-on units. Add free candidates in cost order while cumulative max_p \u2265 current load or cumulative min_p \u2264 load constraints are maintained, skipping units causing min_p > load.\n6. If cumulative max_p < load, add skipped candidates without min_p constraint.\n7. If cumulative min_p > load, remove highest-cost free units (descending cost order) while maintaining cumulative max_p \u2265 load.\n8. Perform constrained economic dispatch for committed units:\n   a. If cumulative min_p > load: set outputs to min_p (over-generation)\n   b. Else if cumulative max_p < load: set outputs to max_p (under-generation)\n   c. Else: use lambda iteration with bisection to optimize generation, followed by marginal-cost-based residual adjustment to close gaps\n9. Set uncommitted units to offline state (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_adaptive_commitment_v2(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    \n    # Initialize arrays for bounds and cost metrics\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    cost_per_mw = np.full(n_units, np.inf)\n    \n    # Classify units and compute bounds\n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    current_load = load[0]\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                forced_on.append(i)\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                free_online.append(i)\n                min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                forced_off.append(i)\n                min_p[i] = 0\n                max_p[i] = 0\n            else:\n                free_offline.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate cost_per_mw for free units\n    for i in free_online + free_offline:\n        unit = units_info[i]\n        if min_p[i] > 0:\n            base_cost = unit['a_i'] + unit['b_i'] * min_p[i] + unit['c_i'] * min_p[i]**2\n            if i in free_offline:\n                amortization = min(2, unit['t_on_min_i'])\n                base_cost += unit['s_i'] / amortization\n            cost_per_mw[i] = base_cost / min_p[i]\n    \n    # Create sorted candidate list\n    candidate_list = sorted(free_online + free_offline, key=lambda i: cost_per_mw[i])\n    committed_set = set(forced_on)\n    total_min = sum(min_p[i] for i in committed_set)\n    total_max = sum(max_p[i] for i in committed_set)\n    skipped = []\n\n    # Build committed set\n    for i in candidate_list:\n        if total_max >= current_load:\n            break\n        if total_min + min_p[i] <= current_load:\n            committed_set.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n        else:\n            skipped.append(i)\n    \n    # Add skipped units if needed\n    if total_max < current_load:\n        for i in skipped:\n            if total_max >= current_load:\n                break\n            committed_set.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Remove expensive units if min_p exceeds load\n    if total_min > current_load:\n        free_committed = [i for i in committed_set if i in free_online or i in free_offline]\n        free_committed.sort(key=lambda i: cost_per_mw[i], reverse=True)\n        for i in free_committed:\n            if total_min <= current_load:\n                break\n            if total_max - max_p[i] >= current_load:\n                committed_set.remove(i)\n                total_min -= min_p[i]\n                total_max -= max_p[i]\n    \n    # Dispatch for committed units\n    p_output = np.zeros(n_units)\n    committed_list = list(committed_set)\n    \n    if total_min > current_load:\n        for i in committed_set:\n            p_output[i] = min_p[i]\n    elif total_max < current_load:\n        for i in committed_set:\n            p_output[i] = max_p[i]\n    else:\n        minp_list = [min_p[i] for i in committed_list]\n        maxp_list = [max_p[i] for i in committed_list]\n        b_list = [units_info[i]['b_i'] for i in committed_list]\n        c_list = [units_info[i]['c_i'] for i in committed_list]\n        \n        # Set lambda bounds\n        der_min = [b_list[i] + 2 * c_list[i] * minp_list[i] for i in range(len(committed_list))]\n        der_max = [b_list[i] + 2 * c_list[i] * maxp_list[i] for i in range(len(committed_list))]\n        lambda_low = min(der_min)\n        lambda_high = max(der_max)\n        \n        # Lambda iteration\n        n_iter = 100\n        epsilon = 1e-5\n        p_list = np.zeros(len(committed_list))\n        \n        for _ in range(n_iter):\n            lm = (lambda_low + lambda_high) / 2\n            total_power = 0\n            for j in range(len(committed_list)):\n                if c_list[j] != 0:\n                    p_uncon = (lm - b_list[j]) / (2 * c_list[j])\n                    p_list[j] = np.clip(p_uncon, minp_list[j], maxp_list[j])\n                else:\n                    p_list[j] = minp_list[j] if lm < b_list[j] else maxp_list[j]\n                total_power += p_list[j]\n            \n            if abs(total_power - current_load) < epsilon:\n                break\n            if total_power < current_load:\n                lambda_low = lm\n            else:\n                lambda_high = lm\n        \n        # Residual adjustment\n        gap = current_load - total_power\n        if gap > 0:\n            avail_up = maxp_list - p_list\n            marg_cost = [b_list[i] + 2 * c_list[i] * p_list[i] for i in range(len(committed_list))]\n            idxs = sorted(range(len(committed_list)), key=lambda i: marg_cost[i])\n            for i in idxs:\n                if gap <= 0: break\n                add = min(avail_up[i], gap)\n                p_list[i] += add\n                gap -= add\n        elif gap < 0:\n            avail_down = p_list - minp_list\n            marg_cost = [b_list[i] + 2 * c_list[i] * p_list[i] for i in range(len(committed_list))]\n            idxs = sorted(range(len(committed_list)), key=lambda i: marg_cost[i], reverse=True)\n            for i in idxs:\n                if gap >= 0: break\n                reduce = min(avail_down[i], -gap)\n                p_list[i] -= reduce\n                gap += reduce\n        \n        # Assign dispatch values\n        for idx, unit_idx in enumerate(committed_list):\n            p_output[unit_idx] = p_list[idx]\n    \n    # Set schedules\n    for i in committed_set:\n        schedules[0, i] = 1\n        schedules[1, i] = p_output[i]\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054684568,
          "gap_price_rate": 0.0088119119,
          "fitness": 0.0071401843
     },
     {
          "name": "refined_2period_ramp_aware_amortized",
          "algorithm": "1. Classify units into forced-on (violating min uptime/shutdown constraints), forced-off (violating min downtime), free-online (online without forced constraints), and free-offline (offline without forced constraints). Forced-on units must remain online due to operational constraints.\n2. Compute feasible power bounds considering ramp limits:\n   - For forced-on/free-online: min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - For free-offline: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Calculate amortized startup cost over min(2, t_on_min_i) periods for free-offline units to account for short-term commitment costs\n4. Build committed set starting with forced-on units. Add free units in ascending order of (amortized cost per MW at min power), skipping units that make cumulative min output exceed current load\n5. If cumulative max capacity < load, add remaining free units without min power constraint\n6. Remove most expensive free units when cumulative min output > load to ensure feasibility\n7. Perform economic dispatch using lambda iteration with bisection:\n   a) Set initial outputs to min_p for all committed units\n   b) Adjust lambda to balance generation-load difference\n   c) Clamp outputs within feasible bounds during iterations\n   d) Apply iterative adjustment to close any residual gap after convergence\n8. Set uncommitted units to offline state (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef refined_2period_ramp_aware_amortized(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    cost_per_MW = [0.0] * n_units\n    amortized_periods = [2] * n_units\n    \n    # Step 1: Classify units and set operational bounds\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            # Check min uptime and shutdown ramp constraints\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n        else:  # Was offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Check min downtime\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2: Compute amortized costs\n    for i, unit in enumerate(units_info):\n        if forced_on[i] or forced_off[i]:\n            continue\n            \n        p_min_val = min_p[i]\n        if p_min_val <= 0:\n            cost_per_MW[i] = 1e12  # Prevent division by zero\n            continue\n            \n        if unit['u_i_0'] == 1:  # Free-online\n            base_cost = unit['a_i'] + unit['b_i'] * p_min_val + unit['c_i'] * (p_min_val ** 2)\n            cost_per_MW[i] = base_cost / p_min_val\n        else:  # Free-offline\n            amortized_periods[i] = min(2, unit['t_on_min_i'])\n            amortized_startup = unit['s_i'] / amortized_periods[i]\n            base_cost = unit['a_i'] + amortized_startup + unit['b_i'] * p_min_val + unit['c_i'] * (p_min_val ** 2)\n            cost_per_MW[i] = base_cost / p_min_val\n            \n    # Step 3: Build commitment set\n    committed_units = set()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Add forced-on units first\n    for i in range(n_units):\n        if forced_on[i]:\n            committed_units.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Candidate free units sorted by cost\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    free_units_sorted = sorted(free_units, key=lambda i: cost_per_MW[i])\n    \n    # Stage 1: Add without violating min constraint\n    stage1_commits = []\n    temp_min = total_min\n    temp_max = total_max\n    for i in free_units_sorted:\n        if temp_max >= current_load:\n            break\n        if temp_min + min_p[i] <= current_load:\n            stage1_commits.append(i)\n            temp_min += min_p[i]\n            temp_max += max_p[i]\n    \n    committed_units.update(stage1_commits)\n    total_min = temp_min\n    total_max = temp_max\n    \n    # Stage 2: Add remaining if needed without min constraint\n    if total_max < current_load:\n        remaining = [i for i in free_units_sorted if i not in stage1_commits]\n        for i in remaining:\n            if total_max >= current_load:\n                break\n            committed_units.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Step 4: Remove expensive units if overcommitted\n    free_in_committed = [i for i in committed_units if not forced_on[i]]\n    free_in_committed_sorted = sorted(free_in_committed, key=lambda i: cost_per_MW[i], reverse=True)\n    \n    while total_min > current_load and free_in_committed_sorted:\n        i = free_in_committed_sorted.pop(0)\n        committed_units.remove(i)\n        total_min -= min_p[i]\n        total_max -= max_p[i]\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 5: Economic dispatch for committed units\n    if committed_units:\n        # Prepare committed unit parameters\n        indices = list(committed_units)\n        min_p_list = [min_p[i] for i in indices]\n        max_p_list = [max_p[i] for i in indices]\n        a_list = [units_info[i]['a_i'] for i in indices]\n        b_list = [units_info[i]['b_i'] for i in indices]\n        c_list = [units_info[i]['c_i'] for i in indices]\n        n_committed = len(indices)\n        \n        # Initialize outputs at minimum\n        p_vals = min_p_list.copy()\n        total_p = sum(p_vals)\n        \n        # Lambda iteration setup\n        tol = 1e-5\n        max_iter = 1000\n        gap = current_load - total_p\n        \n        # Only dispatch if there's load to allocate\n        if abs(gap) > tol:\n            # Find valid lambda bounds\n            low_bound = float('inf')\n            high_bound = float('-inf')\n            \n            for i in range(n_committed):\n                ic_min = b_list[i] + 2 * c_list[i] * min_p_list[i]\n                ic_max = b_list[i] + 2 * c_list[i] * max_p_list[i]\n                low_bound = min(low_bound, ic_min)\n                high_bound = max(high_bound, ic_max)\n            \n            # Expand bounds for safety\n            low = max(0, low_bound - 100)\n            high = high_bound + 100\n            \n            # Bisection method\n            iter_count = 0\n            while abs(high - low) > tol and iter_count < max_iter:\n                mid = (low + high) / 2\n                total_test = 0.0\n                \n                for i in range(n_committed):\n                    if c_list[i] == 0:  # Linear unit\n                        p_test = max_p_list[i] if mid > b_list[i] else min_p_list[i]\n                    else:\n                        p_test = (mid - b_list[i]) / (2 * c_list[i])\n                        p_test = max(min_p_list[i], min(max_p_list[i], p_test))\n                    total_test += p_test\n                \n                if total_test < current_load:\n                    low = mid\n                else:\n                    high = mid\n                iter_count += 1\n            \n            # Final projection\n            mid = (low + high) / 2\n            total_test = 0.0\n            p_vals = []\n            \n            for i in range(n_committed):\n                if c_list[i] == 0:\n                    p_val = max_p_list[i] if mid > b_list[i] else min_p_list[i]\n                else:\n                    p_val = (mid - b_list[i]) / (2 * c_list[i])\n                    p_val = max(min_p_list[i], min(max_p_list[i], p_val))\n                p_vals.append(p_val)\n                total_test += p_val\n            \n            # Iterative adjustment for residual gap\n            gap = current_load - total_test\n            if abs(gap) > tol:\n                # Calculate marginal costs at current dispatch\n                marginal_costs = []\n                for i in range(n_committed):\n                    marginal_costs.append(b_list[i] + 2 * c_list[i] * p_vals[i])\n                \n                sorted_idx = np.argsort(marginal_costs)\n                if gap > 0:  # Increase generation\n                    for idx in sorted_idx:\n                        room = max_p_list[idx] - p_vals[idx]\n                        if room > 0:\n                            add = min(room, gap)\n                            p_vals[idx] += add\n                            gap -= add\n                        if gap <= 0:\n                            break\n                else:  # Decrease generation\n                    gap_abs = abs(gap)\n                    for idx in sorted_idx[::-1]:\n                        room = p_vals[idx] - min_p_list[idx]\n                        if room > 0:\n                            remove = min(room, gap_abs)\n                            p_vals[idx] -= remove\n                            gap_abs -= remove\n                        if gap_abs <= 0:\n                            break\n            \n            # Assign computed values\n            for i, idx in enumerate(indices):\n                p_out[idx] = p_vals[i]\n                u_out[idx] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054684574,
          "gap_price_rate": 0.0088119122,
          "fitness": 0.0071401848
     },
     {
          "name": "adaptive_rolling_commitment_v3",
          "algorithm": "1. Classify units into forced-on (violating min up-time/shutdown constraints), forced-off (violating min down-time), free-online (online without forced constraints), and free-offline (offline without forced constraints).\n2. Compute feasible power bounds for the current period considering ramp constraints:\n   - Forced-on and free-online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - Free-offline: [p_min_i, min(p_max_i, p_start_i)]\n3. Calculate amortized cost per MW at min power for free units:\n   - Free-online: (a_i + b_i*min_p_i + c_i*min_p_i\u00b2)/min_p_i\n   - Free-offline: (a_i + s_i/min(2,t_on_min_i) + b_i*min_p_i + c_i*min_p_i\u00b2)/min_p_i\n4. Form candidate list of free units sorted by ascending amortized cost.\n5. Build committed set with forced-on units. Add free candidates in cost order while cumulative max power \u2265 current load or cumulative min power \u2264 load constraints are maintained.\n6. If cumulative min power exceeds load, remove highest-cost free units while preserving cumulative max power \u2265 load.\n7. Perform constrained economic dispatch using lambda iteration with bisection:\n   a. Initialize outputs at min bounds, set lambda bounds\n   b. Iterate with bisection to balance generation and load\n   c. Clamp outputs to feasible bounds during iterations\n   d. Distribute any residual gap using marginal cost ordering\n8. Set uncommitted units to offline state (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef adaptive_rolling_commitment_v3(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    \n    # Pre-calculate min and max power bounds considering ramp constraints\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    cost_metric = np.full(num_units, np.inf)\n    amortized = np.zeros(num_units)\n    free_units = []\n    forced_on = []\n    forced_off = []\n    \n    for i, unit in enumerate(units_info):\n        # Compute power bounds based on current state\n        if unit['u_i_0'] == 1:  # Unit was online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            # Check forced-on conditions\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on.append(i)\n            else:\n                free_units.append(i)\n        else:  # Unit was offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            # Check forced-off conditions\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off.append(i)\n            else:\n                free_units.append(i)\n    \n    # Calculate cost metrics for free units\n    for i in free_units:\n        unit = units_info[i]\n        min_output = min_p[i]\n        base_cost = unit['a_i'] + unit['b_i']*min_output + unit['c_i']*min_output**2\n        \n        if units_info[i]['u_i_0'] == 1:  # Free-online\n            cost_metric[i] = base_cost / min_output\n        else:  # Free-offline\n            amort = min(2, unit['t_on_min_i'])\n            amortized_cost = base_cost + unit['s_i'] / amort\n            cost_metric[i] = amortized_cost / min_output\n            amortized[i] = amort\n    \n    # Sort free units by cost metric (ascending)\n    free_units = [i for _, i in sorted(zip(cost_metric[free_units], free_units))]\n    \n    # Build committed set\n    committed = set(forced_on)\n    cum_min = sum(min_p[i] for i in committed)\n    cum_max = sum(max_p[i] for i in committed)\n    \n    # Add free units while respecting constraints\n    temp_committed = []\n    skipped = []\n    for i in free_units:\n        if cum_max >= current_load:\n            break\n        new_cum_min = cum_min + min_p[i]\n        new_cum_max = cum_max + max_p[i]\n        if new_cum_min <= current_load or cum_max < current_load:\n            committed.add(i)\n            temp_committed.append(i)\n            cum_min, cum_max = new_cum_min, new_cum_max\n        else:\n            skipped.append(i)\n    \n    # Add skipped units if still needed\n    for i in skipped:\n        if cum_max >= current_load:\n            break\n        committed.add(i)\n        cum_min += min_p[i]\n        cum_max += max_p[i]\n    \n    # Remove units if cumulative min exceeds load\n    free_in_committed = sorted(\n        [i for i in temp_committed if i in committed], \n        key=lambda i: cost_metric[i], reverse=True\n    )\n    for i in free_in_committed:\n        if cum_min <= current_load:\n            break\n        new_cum_min = cum_min - min_p[i]\n        new_cum_max = cum_max - max_p[i]\n        if new_cum_max >= current_load:\n            committed.discard(i)\n            cum_min, cum_max = new_cum_min, new_cum_max\n    \n    # Dispatch for committed units\n    p_vals = {i: min_p[i] for i in committed}\n    residual = current_load - sum(p_vals.values())\n    \n    # Lambda iteration (bisection)\n    if abs(residual) > 1e-5:\n        # Get marginal cost function for each unit\n        def marginal_cost(i, p_val):\n            return units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_val\n        \n        # Lambda bisection setup\n        lambd_low = 0\n        lambd_high = max(marginal_cost(i, max_p[i]) for i in committed) + 100\n        n_iters = 50\n        tol = 1e-5\n        \n        for _ in range(n_iters):\n            lambd = (lambd_low + lambd_high) / 2\n            total_p = 0\n            for i in committed:\n                if units_info[i]['c_i'] < 1e-10:  # Linear cost\n                    p_val = min_p[i] if lambd < units_info[i]['b_i'] else max_p[i]\n                else:\n                    unclamped = (lambd - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                    p_val = np.clip(unclamped, min_p[i], max_p[i])\n                p_vals[i] = p_val\n                total_p += p_val\n            \n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                lambd_low = lambd\n            else:\n                lambd_high = lambd\n        residual = current_load - sum(p_vals.values())\n    \n    # Residual adjustment\n    if abs(residual) > 1e-5:\n        # Increase generation if residual positive\n        if residual > 0:\n            candidates = []\n            for i in committed:\n                if p_vals[i] < max_p[i]:\n                    marginal = marginal_cost(i, p_vals[i])\n                    candidates.append((marginal, i))\n            candidates.sort(key=lambda x: x[0])\n            for _, i in candidates:\n                if residual <= 0:\n                    break\n                increment = min(max_p[i] - p_vals[i], residual)\n                p_vals[i] += increment\n                residual -= increment\n        \n        # Decrease generation if residual negative\n        else:\n            residual = abs(residual)\n            candidates = []\n            for i in committed:\n                if p_vals[i] > min_p[i]:\n                    marginal = marginal_cost(i, p_vals[i])\n                    candidates.append((marginal, i))\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            for _, i in candidates:\n                if residual <= 0:\n                    break\n                decrement = min(p_vals[i] - min_p[i], residual)\n                p_vals[i] -= decrement\n                residual -= decrement\n    \n    # Set commitment and output values\n    for i, unit in enumerate(units_info):\n        if i in committed:\n            u[i] = 1\n            p[i] = p_vals.get(i, min_p[i])\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0054684582,
          "gap_price_rate": 0.0088119116,
          "fitness": 0.0071401849
     }
]