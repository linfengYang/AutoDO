[
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "refined_commit_priority_ramp_aware",
          "algorithm": "1. Classify units into forced-on (units violating min uptime or shutdown ramp constraints), forced-off (units violating min downtime), free-online (currently online not forced-on), free-offline (currently offline not forced-off).\n2. Compute feasible power limits for current period considering ramp constraints: \n   - For forced-on and free-online units: min power = max(p_min_i, p_i_0 - p_down_i), max power = min(p_max_i, p_i_0 + p_up_i)\n   - For free-offline units: min power = p_min_i, max power = min(p_max_i, p_start_i)\n3. Form candidate list combining free-online and free-offline units sorted by amortized cost per MW: \n   - Free-online: (a_i + b_i*p_min + c_i*p_min\u00b2) / p_min\n   - Free-offline: (a_i + s_i + b_i*p_min + c_i*p_min\u00b2) / p_min\n4. Build committed set starting with forced-on units. Add candidates in ascending cost order until cumulative max capacity >= load, skipping any unit that would cause cumulative min power to exceed load.\n5. If cumulative max < load after exhausting candidates, add remaining units without min power constraint.\n6. Perform economic dispatch using lambda iteration to distribute load among committed units, respecting individual power limits.\n7. Set uncommitted units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_commit_priority_ramp_aware(units_info, load):\n    current_load = load[0]\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                forced_on.append(unit)\n            else:\n                free_online.append(unit)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free_offline.append(unit)\n    \n    for unit in forced_on + free_online:\n        unit['p_min_current'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['p_max_current'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p_min = unit['p_min_current']\n        unit['cost_rate'] = (unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n    \n    for unit in free_offline:\n        unit['p_min_current'] = unit['p_min_i']\n        unit['p_max_current'] = min(unit['p_max_i'], unit['p_start_i'])\n        p_min = unit['p_min_current']\n        unit['cost_rate'] = (unit['a_i'] + unit['s_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n    \n    candidates = sorted(free_online + free_offline, key=lambda u: u['cost_rate'])\n    committed = forced_on.copy()\n    total_min = sum(u['p_min_current'] for u in committed)\n    total_max = sum(u['p_max_current'] for u in committed)\n    skipped = []\n    \n    for unit in candidates:\n        if total_max >= current_load:\n            break\n        if total_min + unit['p_min_current'] <= current_load:\n            committed.append(unit)\n            total_min += unit['p_min_current']\n            total_max += unit['p_max_current']\n        else:\n            skipped.append(unit)\n    \n    if total_max < current_load:\n        for unit in skipped:\n            committed.append(unit)\n            total_min += unit['p_min_current']\n            total_max += unit['p_max_current']\n    \n    target = min(max(total_min, current_load), total_max)\n    \n    if committed:\n        low = min(u['b_i'] + 2*u['c_i']*u['p_min_current'] for u in committed)\n        high = max(u['b_i'] + 2*u['c_i']*u['p_max_current'] for u in committed)\n        \n        for _ in range(100):\n            lam = (low + high) / 2\n            total = 0\n            for u in committed:\n                if lam <= u['b_i'] + 2*u['c_i']*u['p_min_current']:\n                    total += u['p_min_current']\n                elif lam >= u['b_i'] + 2*u['c_i']*u['p_max_current']:\n                    total += u['p_max_current']\n                else:\n                    total += (lam - u['b_i']) / (2 * u['c_i'])\n            \n            if abs(total - target) < 1e-5:\n                break\n            if total < target:\n                low = lam\n            else:\n                high = lam\n        \n        for u in committed:\n            if lam <= u['b_i'] + 2*u['c_i']*u['p_min_current']:\n                u['p_i'] = u['p_min_current']\n            elif lam >= u['b_i'] + 2*u['c_i']*u['p_max_current']:\n                u['p_i'] = u['p_max_current']\n            else:\n                u['p_i'] = (lam - u['b_i']) / (2 * u['c_i'])\n    \n    schedules = [[], []]\n    for unit in units_info:\n        if unit in committed:\n            schedules[0].append(1)\n            schedules[1].append(unit.get('p_i', 0.0))\n        else:\n            schedules[0].append(0)\n            schedules[1].append(0.0)\n    \n    return np.array(schedules)",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0087811082,
          "fitness": 0.0071048229
     },
     {
          "name": "rolling_commitment_2period",
          "algorithm": "1. Classify units into forced-on (violating min uptime/shutdown constraints), forced-off (violating min downtime), free-online (online without forced constraints), and free-offline (offline without forced constraints)\n2. Compute feasible power limits for current period considering ramp constraints:\n   - Forced-on/free-online: min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - Free-offline: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Compute cost metrics for free units with amortized startup cost over min(2, t_on_min_i) periods for free-offline units\n4. Build committed set starting with forced-on units\n5. Add free units in cost-ascending order without exceeding cumulative min output\n6. If needed, add remaining free units ignoring min constraint to prevent under-generation\n7. Perform economic dispatch for committed units using bisection-based lambda iteration\n8. Set uncommitted units to offline state (u_i=0, p_i=0)\n",
          "code": "import numpy as np\n\ndef rolling_commitment_2period(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Step 1: Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < min_up or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < min_down:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Step 2: Compute feasible power bounds\n    min_powers = [0] * n_units\n    max_powers = [0] * n_units\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if i in forced_on or i in free_online:\n            min_powers[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_powers[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_offline:\n            min_powers[i] = unit['p_min_i']\n            max_powers[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # forced_off\n            min_powers[i] = 0\n            max_powers[i] = 0\n    \n    # Step 3: Compute cost metrics and form candidate list\n    candidate_list = []\n    \n    # Free-online cost metric\n    for i in free_online:\n        p_min = min_powers[i]\n        if p_min == 0:\n            cost_metric = float('inf')\n        else:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            cost_metric = (a + b * p_min + c * p_min**2) / p_min\n        candidate_list.append((cost_metric, i))\n    \n    # Free-offline cost metric (2-period amortization)\n    for i in free_offline:\n        p_min = min_powers[i]\n        if p_min == 0:\n            cost_metric = float('inf')\n        else:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            s = units_info[i]['s_i']\n            t_up_min = units_info[i]['t_on_min_i']\n            T = max(1, min(2, t_up_min))\n            amortized_startup = s / T\n            cost_metric = (a + b * p_min + c * p_min**2 + amortized_startup) / p_min\n        candidate_list.append((cost_metric, i))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Step 4-6: Build committed set\n    committed = set(forced_on)\n    total_min = sum(min_powers[i] for i in forced_on)\n    total_max = sum(max_powers[i] for i in forced_on)\n    \n    # First pass: add without violating min constraint\n    for cost, i in candidate_list:\n        if total_max >= current_load:\n            break\n        new_min = total_min + min_powers[i]\n        if new_min <= current_load:\n            committed.add(i)\n            total_min = new_min\n            total_max += max_powers[i]\n    \n    # Second pass: add remaining if still insufficient max capacity\n    remaining = [i for cost, i in candidate_list if i not in committed]\n    for i in remaining:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_powers[i]\n        total_max += max_powers[i]\n    \n    # Step 7: Economic dispatch for committed units\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    dispatch_units = []\n    dispatch_indices = []\n    for i in committed:\n        u_arr[i] = 1\n        dispatch_indices.append(i)\n        dispatch_units.append({\n            'min_p': min_powers[i],\n            'max_p': max_powers[i],\n            'b': units_info[i]['b_i'],\n            'c': units_info[i]['c_i']\n        })\n    \n    if dispatch_units:\n        # Determine target generation\n        target = current_load\n        if total_min > target:\n            target = total_min\n        elif total_max < target:\n            target = total_max\n        \n        # Find lambda bounds\n        marginal_low = []\n        marginal_high = []\n        for u in dispatch_units:\n            if u['c'] == 0:\n                mc = u['b']\n                marginal_low.append(mc)\n                marginal_high.append(mc)\n            else:\n                marginal_low.append(u['b'] + 2 * u['c'] * u['min_p'])\n                marginal_high.append(u['b'] + 2 * u['c'] * u['max_p'])\n        \n        lambda_low = min(marginal_low) if marginal_low else 0\n        lambda_high = max(marginal_high) if marginal_high else 1\n        \n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        powers = [u['min_p'] for u in dispatch_units]\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0\n            new_powers = []\n            \n            for u in dispatch_units:\n                if u['c'] == 0:\n                    if lambda_mid < u['b']:\n                        p = u['min_p']\n                    else:\n                        p = u['max_p']\n                else:\n                    p_ideal = (lambda_mid - u['b']) / (2 * u['c'])\n                    p = max(u['min_p'], min(u['max_p'], p_ideal))\n                new_powers.append(p)\n                total_gen += p\n            \n            if abs(total_gen - target) < tol:\n                powers = new_powers\n                break\n                \n            if total_gen < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Set dispatch results\n        for idx, p in zip(dispatch_indices, powers):\n            p_arr[idx] = p\n    \n    # Step 8: Prepare output\n    schedules = np.vstack((u_arr, p_arr))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.005468458,
          "gap_price_rate": 0.008811912,
          "fitness": 0.007140185
     },
     {
          "name": "rolling_commitment_heuristic_v3",
          "algorithm": "1. Identify must-on units (online units violating minimum up-time or shutdown constraints) and must-off units (offline units violating minimum down-time)  \n2. For must-off units, set status to offline and output to 0  \n3. For other units, compute feasible operating ranges considering ramp constraints:  \n   - Online units: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]  \n   - Offline units: [p_min_i, min(p_max_i, p_start_i)]  \n4. Form priority list of flexible units using amortized cost per MW:  \n   - Online units: (a_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i  \n   - Offline units: (a_i + s_i + b_i*p_min_i + c_i*p_min_i\u00b2) / p_min_i  \n5. Initialize committed set with must-on units  \n6. Add flexible units in priority order until cumulative maximum capacity \u2265 load  \n7. Remove highest-cost flexible units if cumulative minimum output > load  \n8. For committed units:  \n   - Set initial outputs to feasible minimum values  \n   - Perform economic dispatch using lambda iteration to meet load:  \n     * Balance remaining load using marginal cost optimization  \n     * Enforce individual unit constraints during allocation  \n9. Set non-committed units to offline with zero output  \n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic_v3(units_info, load):\n    num_units = len(units_info)\n    current_load = load[0]\n    u_i = np.zeros(num_units)\n    p_i = np.zeros(num_units)\n    \n    # Extract unit attributes to arrays for vectorized operations\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    u0 = np.array([u['u_i_0'] for u in units_info])\n    p0 = np.array([u['p_i_0'] for u in units_info])\n    t0 = np.array([u['t_i_0'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    \n    # Determine unit categories\n    must_on = (u0 == 1) & ((t0 < t_on_min) | (p0 > p_shut))\n    must_off = (u0 == 0) & (-t0 < t_off_min)\n    flexible = ~(must_on | must_off)\n    is_online = (flexible & (u0 == 1))\n    is_offline = (flexible & (u0 == 0))\n    \n    # Initialize operational arrays\n    min_power = np.zeros(num_units)\n    max_power = np.zeros(num_units)\n    \n    # Calculate feasible power ranges\n    min_power[must_on] = np.maximum(p_min[must_on], p0[must_on] - p_down[must_on])\n    max_power[must_on] = np.minimum(p_max[must_on], p0[must_on] + p_up[must_on])\n    min_power[is_online] = np.maximum(p_min[is_online], p0[is_online] - p_down[is_online])\n    max_power[is_online] = np.minimum(p_max[is_online], p0[is_online] + p_up[is_online])\n    min_power[is_offline] = p_min[is_offline]\n    max_power[is_offline] = np.minimum(p_max[is_offline], p_start[is_offline])\n    min_power[must_off] = 0\n    max_power[must_off] = 0\n    \n    # Build priority list for flexible units\n    online_cost = (a[flexible] + b[flexible]*min_power[flexible] + c[flexible]*min_power[flexible]**2)\n    offline_cost = online_cost + s[flexible] * is_offline[flexible]\n    cost_efficiency = np.zeros(num_units)\n    cost_efficiency[flexible] = np.where(u0[flexible] == 1, \n                                        online_cost / min_power[flexible],\n                                        offline_cost / min_power[flexible])\n    priority_order = np.argsort(cost_efficiency)\n    \n    # Commit units\n    committed = must_on.copy()\n    min_total = min_power[must_on].sum()\n    max_total = max_power[must_on].sum()\n    \n    for idx in priority_order:\n        if flexible[idx] and max_total < current_load:\n            committed[idx] = True\n            min_total += min_power[idx]\n            max_total += max_power[idx]\n    \n    # Remove expensive units if minimum output exceeds load\n    while min_total > current_load and np.any(committed & flexible):\n        flexible_committed = np.where(committed & flexible)[0]\n        costs = cost_efficiency[flexible_committed]\n        highest_cost_idx = flexible_committed[np.argmax(costs)]\n        if min_power[highest_cost_idx] > 0:\n            committed[highest_cost_idx] = False\n            min_total -= min_power[highest_cost_idx]\n            max_total -= max_power[highest_cost_idx]\n        else:\n            break\n    \n    # Initialize outputs for committed units\n    committed_indices = np.where(committed)[0]\n    p_i[committed] = min_power[committed]\n    \n    # Economic dispatch using lambda iteration\n    dispatch_min = min_power[committed]\n    dispatch_max = max_power[committed]\n    total_min = dispatch_min.sum()\n    remaining = current_load - total_min\n    \n    if remaining > 0:  # Under-generation case\n        b_dispatch = b[committed]\n        c_dispatch = c[committed]\n        headroom = dispatch_max - dispatch_min\n        total_headroom = headroom.sum()\n        \n        if total_headroom > 1e-6:  # Avoid division by zero\n            # Lambda iteration initialization\n            low_lambda = np.min(b_dispatch + 2*c_dispatch*dispatch_min)\n            high_lambda = np.max(b_dispatch + 2*c_dispatch*dispatch_max)\n            tol = 1e-2\n            \n            # Iterate to find optimal lambda\n            while high_lambda - low_lambda > tol:\n                mid_lambda = (low_lambda + high_lambda) / 2\n                p_temp = np.clip((mid_lambda - b_dispatch) / (2 * c_dispatch), \n                                 dispatch_min, dispatch_max)\n                total_p = np.sum(p_temp)\n                \n                if total_p < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            \n            # Apply final dispatch with selected lambda\n            p_i[committed] = np.clip((mid_lambda - b_dispatch) / (2 * c_dispatch), \n                                     dispatch_min, dispatch_max)\n    \n    u_i[committed] = 1  # Set commitment states\n    schedules = np.vstack((u_i, p_i))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0058659258,
          "gap_price_rate": 0.0087753045,
          "fitness": 0.0073206152
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Preprocess units to determine forced commitment states based on minimum up/down times, shutdown ramp limits, and previous state.\n2. Compute available capacity from initially committed units.\n3. Turn on additional candidate units (not forced off) based on two-period average incremental cost until available capacity meets or exceeds current load.\n4. Turn off non-essential candidate units (those not forced on) based on highest operating cost to minimize total cost.\n5. Perform economic dispatch using bisection method to allocate load to committed units, respecting ramp limits and power bounds.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    current_load = load[0]\n    \n    forced_committed = []\n    candidate_off = []\n    candidate_on = []\n    \n    # Step 1: Determine forced commitment and candidate units\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i_0 == 1:\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                forced_committed.append(idx)\n            else:\n                candidate_off.append(idx)\n        else:\n            if abs(t_i_0) < t_off_min_i:\n                continue\n            else:\n                candidate_on.append(idx)\n    \n    # Helper function to get available capacity\n    def get_available_capacity(unit_indices):\n        total = 0.0\n        for idx in unit_indices:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:\n                total += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total += min(unit['p_max_i'], unit['p_start_i'])\n        return total\n    \n    # Initially committed units (forced on and candidate_off)\n    committed_units = forced_committed + candidate_off\n    total_available = get_available_capacity(committed_units)\n    \n    # Step 2: Turn on candidate units if needed\n    candidate_on_info = []\n    for idx in candidate_on:\n        unit = units_info[idx]\n        s_i = unit['s_i']\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        p_min_i = unit['p_min_i']\n        \n        cost_current = s_i + a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        cost_next = a_i + b_i * p_min_i + c_i * (p_min_i ** 2)\n        total_cost = cost_current + cost_next\n        power_two_periods = 2 * p_min_i\n        aic_per_mw = total_cost / power_two_periods\n        \n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidate_on_info.append((idx, aic_per_mw, avail))\n    \n    candidate_on_info.sort(key=lambda x: x[1])\n    \n    for idx, _, avail in candidate_on_info:\n        if total_available >= current_load:\n            break\n        total_available += avail\n        committed_units.append(idx)\n    \n    # Step 3: Turn off non-essential candidate_off units\n    candidate_off_info = []\n    for idx in candidate_off:\n        if idx not in committed_units:\n            continue\n        unit = units_info[idx]\n        min_power = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        cost = unit['a_i'] + unit['b_i'] * min_power + unit['c_i'] * min_power**2\n        if unit['u_i_0'] == 1:\n            avail = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            avail = min(unit['p_max_i'], unit['p_start_i'])\n        candidate_off_info.append((idx, cost, avail))\n    \n    candidate_off_info.sort(key=lambda x: x[1], reverse=True)\n    \n    new_committed = list(committed_units)\n    total_available_new = total_available\n    for idx, _, avail in candidate_off_info:\n        if (total_available_new - avail) >= current_load:\n            total_available_new -= avail\n            new_committed.remove(idx)\n    committed_units = new_committed\n    \n    # Prepare schedules array\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    for idx in committed_units:\n        schedules[0, idx] = 1\n    \n    # Step 4: Economic Dispatch\n    unit_bounds = []\n    for idx in committed_units:\n        unit = units_info[idx]\n        if unit['u_i_0'] == 1:\n            low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low_bound = unit['p_min_i']\n            high_bound = min(unit['p_max_i'], unit['p_start_i'])\n        unit_bounds.append((idx, low_bound, high_bound))\n    \n    low_total = sum(low for _, low, _ in unit_bounds)\n    high_total = sum(high for _, _, high in unit_bounds)\n    \n    # If load not feasible, use bounds\n    if current_load < low_total or current_load > high_total:\n        for idx, low, high in unit_bounds:\n            if current_load < low_total:\n                schedules[1, idx] = low\n            else:\n                schedules[1, idx] = high\n        return schedules\n    \n    # Dispatch parameters\n    dispatch_list = []\n    min_ic = float('inf')\n    max_ic = -float('inf')\n    \n    for idx, low, high in unit_bounds:\n        unit = units_info[idx]\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        ic_low = b_i + 2 * c_i * low\n        ic_high = b_i + 2 * c_i * high\n        min_ic = min(min_ic, ic_low)\n        max_ic = max(max_ic, ic_high)\n        dispatch_list.append((idx, b_i, c_i, low, high))\n    \n    # Lambda iteration\n    lambda_low = min_ic\n    lambda_high = max_ic\n    p_values = [low for _, _, _, low, _ in dispatch_list]\n    \n    if abs(high_total - low_total) > 1e-6:\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_power = 0.0\n            new_p_values = []\n            for idx, b_i, c_i, low, high in dispatch_list:\n                if c_i == 0:\n                    if lambda_mid < b_i:\n                        p_i = low\n                    else:\n                        p_i = high\n                else:\n                    p_i = (lambda_mid - b_i) / (2 * c_i)\n                    p_i = max(low, min(high, p_i))\n                new_p_values.append(p_i)\n                total_power += p_i\n            \n            if abs(total_power - current_load) < 1e-3:\n                p_values = new_p_values\n                break\n            if total_power < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            p_values = new_p_values\n    \n    # Assign dispatch results\n    for (idx, _, _, _, _), power in zip(dispatch_list, p_values):\n        schedules[1, idx] = power\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.0054685553,
          "gap_price_rate": 0.0092084548,
          "fitness": 0.0073385051
     },
     {
          "name": "adaptive_priority_amortized_v2",
          "algorithm": "**  \n1. Identify forced online/offline units considering min up/down times and shutdown ramp constraints.  \n2. Compute feasible power bounds for online units considering ramp limits, and startup/shutdown limits for offline units.  \n3. Classify free units (non-forced) and compute priority metrics using amortized startup costs over min up-time for offline units.  \n4. Build commitment set iteratively: start with forced online, add free units by priority without exceeding load requirements.  \n5. Adjust commitment set by removing highest-cost free units if cumulative min power exceeds load.  \n6. Allocate load via constrained economic dispatch using merit order and marginal cost optimization.  \n7. Set uncommitted units to off state with zero output.  \n\n**",
          "code": "import numpy as np\n\ndef adaptive_priority_amortized_v2(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    \n    forced_online = []\n    forced_offline = []\n    free_online = []\n    free_offline = []\n    \n    p_min_current = np.zeros(n)\n    p_max_current = np.zeros(n)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                forced_online.append(i)\n                p_min_current[i] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                p_max_current[i] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:\n                free_online.append(i)\n                p_min_current[i] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                p_max_current[i] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        else:\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_offline.append(i)\n                p_min_current[i] = 0\n                p_max_current[i] = 0\n            else:\n                free_offline.append(i)\n                p_min_current[i] = unit['p_min_i']\n                p_max_current[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    cost_metric = np.full(n, np.inf)\n    free_units = free_online + free_offline\n    for i in free_online:\n        unit = units_info[i]\n        if p_min_current[i] > 0:\n            cost_metric[i] = (unit['a_i'] + unit['b_i'] * p_min_current[i] + unit['c_i'] * p_min_current[i]**2) / p_min_current[i]\n    for i in free_offline:\n        unit = units_info[i]\n        if p_min_current[i] > 0:\n            amortized = unit['s_i'] / unit['t_on_min_i']\n            cost_metric[i] = (amortized + unit['a_i'] + unit['b_i'] * p_min_current[i] + unit['c_i'] * p_min_current[i]**2) / p_min_current[i]\n    \n    free_units_sorted = sorted(free_units, key=lambda i: cost_metric[i])\n    candidate_commit = forced_online.copy()\n    comm_free = []\n    total_min = sum(p_min_current[i] for i in forced_online)\n    total_max = sum(p_max_current[i] for i in forced_online)\n    \n    for i in free_units_sorted:\n        if total_max >= current_load and total_min <= current_load:\n            break\n        new_min = total_min + p_min_current[i]\n        new_max = total_max + p_max_current[i]\n        if new_min > current_load and total_max >= current_load:\n            continue\n        comm_free.append(i)\n        total_min = new_min\n        total_max = new_max\n    \n    if total_min > current_load:\n        comm_free.sort(key=lambda i: cost_metric[i], reverse=True)\n        removed = []\n        for i in comm_free:\n            if total_min <= current_load:\n                break\n            new_min = total_min - p_min_current[i]\n            new_max = total_max - p_max_current[i]\n            if new_min <= current_load or new_max < current_load:\n                continue\n            removed.append(i)\n            total_min = new_min\n            total_max = new_max\n        comm_free = [i for i in comm_free if i not in removed]\n    \n    candidate_commit += comm_free\n    p_outputs = {i: p_min_current[i] for i in candidate_commit}\n    total_p = sum(p_outputs.values())\n    deficit = current_load - total_p\n    tolerance = 0.1\n    iterations = 0\n    max_iter = 1000\n    \n    while abs(deficit) > tolerance and iterations < max_iter:\n        iterations += 1\n        if deficit > 0:\n            active_units = [i for i in candidate_commit if p_outputs[i] < p_max_current[i]]\n            if not active_units:\n                break\n            margins = [(2 * units_info[i]['c_i'] * p_outputs[i] + units_info[i]['b_i'], i) for i in active_units]\n            margins.sort(key=lambda x: x[0])\n            _, idx = margins[0]\n            inc = min(deficit, p_max_current[idx] - p_outputs[idx])\n            p_outputs[idx] += inc\n            total_p += inc\n            deficit -= inc\n        else:\n            active_units = [i for i in candidate_commit if p_outputs[i] > p_min_current[i]]\n            if not active_units:\n                break\n            margins = [(2 * units_info[i]['c_i'] * p_outputs[i] + units_info[i]['b_i'], i) for i in active_units]\n            margins.sort(key=lambda x: x[0], reverse=True)\n            _, idx = margins[0]\n            dec = min(-deficit, p_outputs[idx] - p_min_current[idx])\n            p_outputs[idx] -= dec\n            total_p -= dec\n            deficit += dec\n    \n    schedules = np.zeros((2, n))\n    for i in range(n):\n        if i in candidate_commit:\n            schedules[0, i] = 1\n            schedules[1, i] = p_outputs.get(i, p_min_current[i])\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0062167011,
          "gap_price_rate": 0.0105974255,
          "fitness": 0.0084070633
     },
     {
          "name": "rolling_marginal_commitment",
          "algorithm": "1. Identify forced online/offline units using min up/down times and shutdown ramp constraints.  \n2. Initialize committed set with forced online units. Flexible online units can be turned off, flexible offline can be turned on.  \n3. Compute total min/max power from committed and flexible online units, considering ramp constraints.  \n4. If min power exceeds load, turn off most expensive flexible online units based on cost at lower bound until min power \u2264 load.  \n5. If max power is below load, turn on cheapest flexible offline units using two-period amortized startup cost metric until max power \u2265 load, while ensuring total min \u2264 load.  \n6. Perform economic dispatch: set outputs to lower bounds, then allocate remaining load using priority queue ordered by increasing incremental cost.  \n7. Set non-committed units to off with zero output. Return schedule.  \n\n",
          "code": "import numpy as np  \nimport heapq  \n  \ndef rolling_marginal_commitment(units_info, load):  \n    # Identify forced online and offline units  \n    forced_on = []  \n    forced_off = []  \n    for i, unit in enumerate(units_info):  \n        if unit['u_i_0'] == 1:  \n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:  \n                forced_on.append(i)  \n        else:  \n            if abs(unit['t_i_0']) < unit['t_off_min_i']:  \n                forced_off.append(i)  \n                  \n    # Classify flexible units  \n    committed_set = set(forced_on)  \n    flexible_online = []  \n    flexible_offline = []  \n    for i, unit in enumerate(units_info):  \n        if i not in forced_on and i not in forced_off:  \n            if unit['u_i_0'] == 1:  \n                flexible_online.append(i)  \n            else:  \n                flexible_offline.append(i)  \n                  \n    # Compute initial min/max power for online units  \n    total_min = 0.0  \n    total_max = 0.0  \n    bounds = {}  \n    for i in forced_on + flexible_online:  \n        unit = units_info[i]  \n        lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        bounds[i] = (lb, ub)  \n        total_min += lb  \n        total_max += ub  \n      \n    # Handle over-commitment  \n    current_load = load[0]  \n    if total_min > current_load:  \n        # Calculate cost savings at lower bound for flexible online  \n        cost_savings = []  \n        for i in flexible_online:  \n            lb, _ = bounds[i]  \n            unit = units_info[i]  \n            cost = unit['a_i'] + unit['b_i'] * lb + unit['c_i'] * lb**2  \n            cost_savings.append((i, cost))  \n        cost_savings.sort(key=lambda x: x[1], reverse=True)  \n          \n        # Turn off most expensive units  \n        to_remove = []  \n        for i, cost_val in cost_savings:  \n            lb, ub = bounds[i]  \n            if total_min - lb >= current_load:  \n                total_min -= lb  \n                total_max -= ub  \n                to_remove.append(i)  \n                if total_min <= current_load:  \n                    break  \n        for i in to_remove:  \n            flexible_online.remove(i)  \n            committed_set.remove(i)  \n      \n    # Handle under-commitment  \n    if total_max < current_load:  \n        # Calculate two-period amortized startup cost  \n        metrics = []  \n        for i in flexible_offline:  \n            unit = units_info[i]  \n            if unit['p_min_i'] <= 0:  \n                metric = float('inf')  \n            else:  \n                startup_cost = unit['s_i']  \n                min_cost_period = 2 * unit['a_i'] + 2 * unit['b_i'] * unit['p_min_i'] + 2 * unit['c_i'] * unit['p_min_i']**2  \n                metric = (startup_cost + min_cost_period) / (2 * unit['p_min_i'])  \n            metrics.append((i, metric))  \n        metrics.sort(key=lambda x: x[1])  \n          \n        # Turn on cheapest units while ensuring min power \u2264 load  \n        to_add = []  \n        for i, metric_val in metrics:  \n            lb = units_info[i]['p_min_i']  \n            ub = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])  \n            if total_min + lb <= current_load:  \n                total_min += lb  \n                total_max += ub  \n                to_add.append(i)  \n                committed_set.add(i)  \n                if total_max >= current_load:  \n                    break  \n        flexible_online.extend(to_add)  # Track added units  \n      \n    # Economic dispatch  \n    p_output = {}  \n    lb_dispatch = {}  \n    ub_dispatch = {}  \n    for i in committed_set:  \n        unit = units_info[i]  \n        if unit['u_i_0'] == 1:  \n            lb_dispatch[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n            ub_dispatch[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        else:  # Newly turned on  \n            lb_dispatch[i] = unit['p_min_i']  \n            ub_dispatch[i] = min(unit['p_max_i'], unit['p_start_i'])  \n        p_output[i] = lb_dispatch[i]  \n      \n    # Allocate remaining load using priority queue  \n    total_p = sum(p_output.values())  \n    remaining = current_load - total_p  \n    heap = []  \n    for i in committed_set:  \n        if p_output[i] < ub_dispatch[i]:  \n            inc_cost = 2 * units_info[i]['c_i'] * p_output[i] + units_info[i]['b_i']  \n            heapq.heappush(heap, (inc_cost, i, p_output[i]))  \n              \n    while remaining > 1e-8 and heap:  \n        inc_cost, i, cur_p = heapq.heappop(heap)  \n        if p_output[i] != cur_p:  \n            continue  # Skip outdated entry  \n        room = ub_dispatch[i] - cur_p  \n        if room <= 0:  \n            continue  \n        add = min(room, remaining)  \n        p_output[i] += add  \n        remaining -= add  \n        if p_output[i] < ub_dispatch[i]:  # Still room  \n            new_inc = 2 * units_info[i]['c_i'] * p_output[i] + units_info[i]['b_i']  \n            heapq.heappush(heap, (new_inc, i, p_output[i]))  \n      \n    # Build schedule array  \n    n_units = len(units_info)  \n    schedule = np.zeros((2, n_units))  \n    for i in range(n_units):  \n        if i in p_output:  \n            schedule[0, i] = 1  \n            schedule[1, i] = p_output[i]  \n    return schedule  ",
          "from": "crossover",
          "gap_power_rate": 0.0088597705,
          "gap_price_rate": 0.0080680588,
          "fitness": 0.0084639147
     },
     {
          "name": "commit_units_by_marginal_cost",
          "algorithm": "1. Identify must-run units that cannot be turned off due to min-up time, shutdown ramp limits, or ramp-down constraints.\n2. Identify must-off units that cannot be turned on due to min-down time constraints.\n3. Sort eligible candidate units by average cost per MW (includes startup cost for off units, excludes for on units).\n4. Commit must-run units and add candidate units in cost-ascending order until capacity meets current load.\n5. For committed units, calculate dispatch bounds based on operational constraints (ramps, startup capacities).\n6. Perform economic dispatch using lambda iteration to allocate load to units within bounds.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_marginal_cost(units_info, load):\n    must_run = set()\n    # Identify must-run units\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i']:\n                must_run.add(id(unit))\n            elif unit['p_i_0'] > unit['p_shut_i'] or unit['p_i_0'] > unit['p_down_i']:\n                must_run.add(id(unit))\n    \n    # Helper to check must-off units\n    def is_must_off(unit):\n        if unit['u_i_0'] == 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n            return True\n        return False\n    \n    # Build candidate units list\n    candidate_units = []\n    for unit in units_info:\n        uid = id(unit)\n        if uid in must_run:\n            continue\n        if is_must_off(unit):\n            continue\n        candidate_units.append(unit)\n    \n    # Calculate average cost for commitment priority\n    def avg_cost(unit):\n        if unit['u_i_0'] == 1:  # On unit: only fuel cost\n            return (unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n        else:  # Off unit: fuel cost + startup\n            return (unit['s_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2) / unit['p_max_i']\n    \n    # Sort by average cost\n    candidate_units_sorted = sorted(candidate_units, key=avg_cost)\n    \n    # Build final commitment set\n    committed_units = set(must_run)\n    total_capacity = 0.0\n    # Add must-run capacity\n    for unit in units_info:\n        if id(unit) in must_run:\n            if unit['u_i_0'] == 1:\n                total_capacity += unit['p_max_i']\n            else:  # Starting unit has constrained capacity\n                total_capacity += min(unit['p_max_i'], unit['p_start_i'])\n    # Add candidate units until load met\n    for unit in candidate_units_sorted:\n        if total_capacity >= load[0]:\n            break\n        if unit['u_i_0'] == 1:  # Already on\n            added_capacity = unit['p_max_i']\n        else:  # Starting unit\n            added_capacity = min(unit['p_max_i'], unit['p_start_i'])\n        committed_units.add(id(unit))\n        total_capacity += added_capacity\n    \n    # Prepare for economic dispatch\n    committed_list = []\n    bounds = []\n    cost_params = []\n    for unit in units_info:\n        if id(unit) in committed_units:\n            # Calculate dispatch bounds\n            if unit['u_i_0'] == 1:  # Was on\n                lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Was off (starting)\n                lb = unit['p_min_i']\n                ub = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            committed_list.append(unit)\n            bounds.append((lb, ub))\n            cost_params.append((unit['b_i'], unit['c_i']))\n    \n    if not committed_list:  # No units committed\n        schedules = np.zeros((2, len(units_info)))\n        return schedules\n    \n    # Lambda iteration for economic dispatch\n    low_lam = -10000.0\n    high_lam = 10000.0\n    tol = 0.01\n    n_iters = 100\n    for _ in range(n_iters):\n        mid_lam = (low_lam + high_lam) / 2\n        total_power = 0.0\n        for (b, c), (lb, ub) in zip(cost_params, bounds):\n            # Calculate unconstrained dispatch\n            if c == 0:\n                p = ub if mid_lam >= b else lb\n            else:\n                p = (mid_lam - b) / (2 * c)\n            p = max(lb, min(ub, p))\n            total_power += p\n        \n        if abs(total_power - load[0]) < tol:\n            break\n        if total_power < load[0]:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Calculate final dispatch values\n    dispatch = []\n    for (b, c), (lb, ub) in zip(cost_params, bounds):\n        if c == 0:\n            p = ub if mid_lam >= b else lb\n        else:\n            p = (mid_lam - b) / (2 * c)\n        p = max(lb, min(ub, p))\n        dispatch.append(p)\n    \n    # Map back to original units\n    schedule_u = []\n    schedule_p = []\n    idx = 0\n    for unit in units_info:\n        if id(unit) in committed_units:\n            schedule_u.append(1)\n            schedule_p.append(dispatch[idx])\n            idx += 1\n        else:\n            schedule_u.append(0)\n            schedule_p.append(0.0)\n    \n    schedules = np.array([schedule_u, schedule_p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.0089824653,
          "gap_price_rate": 0.011717359,
          "fitness": 0.0103499122
     },
     {
          "name": "adaptive_priority_heuristic",
          "algorithm": "1. Classify units into forced_online (must remain on), forced_offline (must remain off), and free_units (adjustable).\n2. Compute feasible power bounds for all units considering ramp limits and startup/shutdown constraints.\n3. Form priority list for free_units combining marginal cost and amortized startup cost based on unit flexibility.\n4. Build commitment set starting with forced_online, then add free_units in priority order until meeting load requirements.\n5. Adjust commitment set if total minimum output exceeds load by deactivating expensive units.\n6. Perform economic dispatch using iterative merit order allocation to meet load exactly when possible.\n7. Set uncommitted units to off state and zero output.\n",
          "code": "import numpy as np\n\ndef adaptive_priority_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info\n    num_units = len(units)\n    u = np.zeros(num_units, dtype=int)\n    p = np.zeros(num_units)\n    min_p = np.zeros(num_units)\n    max_p = np.zeros(num_units)\n    priorities = np.zeros(num_units)\n    committed = [False] * num_units\n    \n    forced_online = []\n    forced_offline = []\n    free_online = []\n    free_offline = []\n    \n    # Classify units and compute power bounds\n    for i, unit in enumerate(units):\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        u0 = unit['u_i_0']\n        p0 = unit['p_i_0']\n        t0 = unit['t_i_0']\n        pmin = unit['p_min_i']\n        pmax = unit['p_max_i']\n        pup = unit['p_up_i']\n        pdown = unit['p_down_i']\n        pstart = unit['p_start_i']\n        tmin_on = unit['t_on_min_i']\n        tmin_off = unit['t_off_min_i']\n        pshut = unit['p_shut_i']\n        \n        # Determine forced status\n        if u0 == 1:\n            if (t0 < tmin_on) or (p0 > pshut):\n                forced_online.append(i)\n            else:\n                free_online.append(i)\n            min_p[i] = max(pmin, p0 - pdown)\n            max_p[i] = min(pmax, p0 + pup)\n        else:\n            if t0 < 0 and abs(t0) < tmin_off:\n                forced_offline.append(i)\n            else:\n                free_offline.append(i)\n            min_p[i] = 0\n            max_p[i] = 0\n    \n    # Initial commit forced online\n    for i in forced_online:\n        committed[i] = True\n        u[i] = 1\n        \n    # Compute initial min/max sums\n    total_min = sum(min_p[i] for i in forced_online + free_online)\n    total_max = sum(max_p[i] for i in forced_online + free_online)\n    \n    # Adjust flexible online units if overcommitted\n    free_online_sorted = sorted(\n        free_online,\n        key=lambda i: (2 * units[i]['c_i'] * min_p[i] + units[i]['b_i']) / min_p[i],\n        reverse=True\n    )\n    for i in free_online_sorted:\n        candidate_min = total_min - min_p[i]\n        candidate_max = total_max - max_p[i]\n        if candidate_max >= current_load and candidate_min <= current_load:\n            committed[i] = False\n            min_p[i] = 0\n            max_p[i] = 0\n            total_min = candidate_min\n            total_max = candidate_max\n    \n    # Calculate priorities for free offline units\n    for i in free_offline:\n        unit = units[i]\n        s = unit['s_i']\n        pmin = unit['p_min_i']\n        tmin_on = unit['t_on_min_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        priorities[i] = (s / tmin_on + b + 2 * c * pmin) / pmin\n    \n    # Add offline units in priority order\n    free_offline_sorted = sorted(free_offline, key=lambda i: priorities[i])\n    for i in free_offline_sorted:\n        if total_max < current_load:\n            pmin_val = units[i]['p_min_i']\n            pmax_val = min(units[i]['p_max_i'], units[i]['p_start_i'])\n            committed[i] = True\n            u[i] = 1\n            min_p[i] = pmin_val\n            max_p[i] = pmax_val\n            total_min += pmin_val\n            total_max += pmax_val\n    \n    # Finalize commitment set\n    committed_set = []\n    for i in range(num_units):\n        if committed[i]:\n            committed_set.append(i)\n    \n    # Economic dispatch initialization\n    p_out = min_p.copy()\n    residual = current_load - sum(p_out[i] for i in committed_set)\n    \n    # Handle overproduction scenario\n    if residual < -1e-5:\n        for i in committed_set:\n            p[i] = min_p[i]\n        residual = 0\n    \n    # Merit-based allocation\n    while abs(residual) > 1e-5:\n        candidates = [\n            (i, 2 * units[i]['c_i'] * p_out[i] + units[i]['b_i'])\n            for i in committed_set\n            if (residual > 0 and p_out[i] < max_p[i]) or \n               (residual < 0 and p_out[i] > min_p[i])\n        ]\n        \n        if not candidates:\n            break\n            \n        if residual > 0:  # Underproduction\n            i, _ = min(candidates, key=lambda x: x[1])\n            increment = min(residual, max_p[i] - p_out[i])\n            p_out[i] += increment\n            residual -= increment\n        else:  # Overproduction\n            i, _ = max(candidates, key=lambda x: x[1])\n            decrement = min(-residual, p_out[i] - min_p[i])\n            p_out[i] -= decrement\n            residual += decrement\n    \n    # Set outputs and states\n    for i in committed_set:\n        p[i] = p_out[i]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0071774662,
          "gap_price_rate": 0.0148416698,
          "fitness": 0.011009568
     },
     {
          "name": "refined_commit_heuristic",
          "algorithm": "1. Identify must-on units (must remain online due to min up-time or shutdown ramp constraints) and must-off units (must remain offline due to min down-time).\n2. For must-on units, calculate feasible power range accounting for ramp constraints.\n3. For must-off units, set output to 0 and mark as offline.\n4. For remaining free units:\n   - Calculate cost metrics including amortized startup costs for offline units.\n   - Sort free units by cost efficiency (ascending order of cost per MW at minimum output).\n5. Gradually add free units in cost-efficiency order until the cumulative maximum capacity meets or exceeds the current load.\n6. If the cumulative minimum output exceeds the load, remove the least efficient free units first to minimize overcommitment.\n7. For all committed units:\n   - Set initial dispatch to their feasible minimum output.\n   - Allocate any remaining load by increasing output of units with lowest incremental cost while respecting individual unit constraints.\n8. Set non-committed units to offline with zero output.\n\n",
          "code": "import numpy as np\n\ndef refined_commit_heuristic(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u_i_out = [0] * n\n    p_i_out = [0] * n\n    must_on_indices = set()\n    must_off_indices = set()\n    free_indices = set()\n    min_arr = [0] * n\n    max_arr = [0] * n\n    dispatch_min = [0] * n\n    dispatch_max = [0] * n\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on_indices.add(i)\n                min_arr[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                u_i_out[i] = 1\n            else:\n                free_indices.add(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off_indices.add(i)\n                u_i_out[i] = 0\n                p_i_out[i] = 0\n            else:\n                free_indices.add(i)\n    \n    cost_i_arr = [0] * n\n    free_min_arr = [0] * n\n    free_max_arr = [0] * n\n    for i in free_indices:\n        unit = units_info[i]\n        p_min_val = unit['p_min_i']\n        if unit['u_i_0'] == 1:\n            p_min_val = max(p_min_val, unit['p_i_0'] - unit['p_down_i'])\n            free_min_arr[i] = p_min_val\n            free_max_arr[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            cost_i_arr[i] = (unit['a_i'] + unit['b_i'] * p_min_val + unit['c_i'] * p_min_val**2) / p_min_val\n        else:\n            free_min_arr[i] = p_min_val\n            free_max_arr[i] = min(unit['p_max_i'], unit['p_start_i'])\n            cost_i_arr[i] = (unit['s_i'] + unit['a_i'] + unit['b_i'] * p_min_val + unit['c_i'] * p_min_val**2) / p_min_val\n    \n    sorted_free = sorted(free_indices, key=lambda i: cost_i_arr[i])\n    total_min = sum(min_arr[i] for i in must_on_indices)\n    total_max = sum(max_arr[i] for i in must_on_indices)\n    committed_free = []\n    \n    for i in sorted_free:\n        total_min += free_min_arr[i]\n        total_max += free_max_arr[i]\n        committed_free.append(i)\n        if total_max >= current_load:\n            break\n    \n    if total_min > current_load:\n        sorted_desc = sorted(committed_free, key=lambda i: cost_i_arr[i], reverse=True)\n        for i in sorted_desc:\n            new_min = total_min - free_min_arr[i]\n            new_max = total_max - free_max_arr[i]\n            if new_min <= current_load and new_max >= current_load:\n                committed_free.remove(i)\n                total_min, total_max = new_min, new_max\n                if total_min <= current_load:\n                    break\n    \n    for i in free_indices:\n        if i in committed_free:\n            u_i_out[i] = 1\n            dispatch_min[i] = free_min_arr[i]\n            dispatch_max[i] = free_max_arr[i]\n        else:\n            u_i_out[i] = 0\n            p_i_out[i] = 0\n    \n    for i in must_on_indices:\n        dispatch_min[i] = min_arr[i]\n        dispatch_max[i] = max_arr[i]\n    \n    committed_indices = must_on_indices | set(committed_free)\n    current_p = [0] * n\n    for i in committed_indices:\n        current_p[i] = dispatch_min[i]\n    \n    total_p = sum(current_p)\n    residual = current_load - total_p\n    inc_cost = lambda i: 2 * units_info[i]['c_i'] * current_p[i] + units_info[i]['b_i']\n    \n    if residual > 0:\n        active = [i for i in committed_indices if current_p[i] < dispatch_max[i]]\n        while residual > 1e-5 and active:\n            active.sort(key=lambda i: inc_cost(i))\n            i = active[0]\n            max_inc = min(residual, dispatch_max[i] - current_p[i])\n            current_p[i] += max_inc\n            residual -= max_inc\n            if current_p[i] >= dispatch_max[i]:\n                active.remove(i)\n    \n    for i in committed_indices:\n        p_i_out[i] = current_p[i]\n    \n    schedules = np.array([u_i_out, p_i_out])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0069095015,
          "gap_price_rate": 0.0168242625,
          "fitness": 0.011866882
     }
]