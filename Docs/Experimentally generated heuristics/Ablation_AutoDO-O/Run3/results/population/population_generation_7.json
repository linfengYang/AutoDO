[
     {
          "name": "commit_units_by_priority_dispatch",
          "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.005428536,
          "gap_price_rate": 0.0087811077,
          "fitness": 0.0071048218
     },
     {
          "name": "refined_commit_priority_ramp_aware",
          "algorithm": "1. Classify units into forced-on (units violating min uptime or shutdown ramp constraints), forced-off (units violating min downtime), free-online (currently online not forced-on), free-offline (currently offline not forced-off).\n2. Compute feasible power limits for current period considering ramp constraints: \n   - For forced-on and free-online units: min power = max(p_min_i, p_i_0 - p_down_i), max power = min(p_max_i, p_i_0 + p_up_i)\n   - For free-offline units: min power = p_min_i, max power = min(p_max_i, p_start_i)\n3. Form candidate list combining free-online and free-offline units sorted by amortized cost per MW: \n   - Free-online: (a_i + b_i*p_min + c_i*p_min\u00b2) / p_min\n   - Free-offline: (a_i + s_i + b_i*p_min + c_i*p_min\u00b2) / p_min\n4. Build committed set starting with forced-on units. Add candidates in ascending cost order until cumulative max capacity >= load, skipping any unit that would cause cumulative min power to exceed load.\n5. If cumulative max < load after exhausting candidates, add remaining units without min power constraint.\n6. Perform economic dispatch using lambda iteration to distribute load among committed units, respecting individual power limits.\n7. Set uncommitted units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_commit_priority_ramp_aware(units_info, load):\n    current_load = load[0]\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                forced_on.append(unit)\n            else:\n                free_online.append(unit)\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(unit)\n            else:\n                free_offline.append(unit)\n    \n    for unit in forced_on + free_online:\n        unit['p_min_current'] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        unit['p_max_current'] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        p_min = unit['p_min_current']\n        unit['cost_rate'] = (unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n    \n    for unit in free_offline:\n        unit['p_min_current'] = unit['p_min_i']\n        unit['p_max_current'] = min(unit['p_max_i'], unit['p_start_i'])\n        p_min = unit['p_min_current']\n        unit['cost_rate'] = (unit['a_i'] + unit['s_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n    \n    candidates = sorted(free_online + free_offline, key=lambda u: u['cost_rate'])\n    committed = forced_on.copy()\n    total_min = sum(u['p_min_current'] for u in committed)\n    total_max = sum(u['p_max_current'] for u in committed)\n    skipped = []\n    \n    for unit in candidates:\n        if total_max >= current_load:\n            break\n        if total_min + unit['p_min_current'] <= current_load:\n            committed.append(unit)\n            total_min += unit['p_min_current']\n            total_max += unit['p_max_current']\n        else:\n            skipped.append(unit)\n    \n    if total_max < current_load:\n        for unit in skipped:\n            committed.append(unit)\n            total_min += unit['p_min_current']\n            total_max += unit['p_max_current']\n    \n    target = min(max(total_min, current_load), total_max)\n    \n    if committed:\n        low = min(u['b_i'] + 2*u['c_i']*u['p_min_current'] for u in committed)\n        high = max(u['b_i'] + 2*u['c_i']*u['p_max_current'] for u in committed)\n        \n        for _ in range(100):\n            lam = (low + high) / 2\n            total = 0\n            for u in committed:\n                if lam <= u['b_i'] + 2*u['c_i']*u['p_min_current']:\n                    total += u['p_min_current']\n                elif lam >= u['b_i'] + 2*u['c_i']*u['p_max_current']:\n                    total += u['p_max_current']\n                else:\n                    total += (lam - u['b_i']) / (2 * u['c_i'])\n            \n            if abs(total - target) < 1e-5:\n                break\n            if total < target:\n                low = lam\n            else:\n                high = lam\n        \n        for u in committed:\n            if lam <= u['b_i'] + 2*u['c_i']*u['p_min_current']:\n                u['p_i'] = u['p_min_current']\n            elif lam >= u['b_i'] + 2*u['c_i']*u['p_max_current']:\n                u['p_i'] = u['p_max_current']\n            else:\n                u['p_i'] = (lam - u['b_i']) / (2 * u['c_i'])\n    \n    schedules = [[], []]\n    for unit in units_info:\n        if unit in committed:\n            schedules[0].append(1)\n            schedules[1].append(unit.get('p_i', 0.0))\n        else:\n            schedules[0].append(0)\n            schedules[1].append(0.0)\n    \n    return np.array(schedules)",
          "from": "mutation",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0087811082,
          "fitness": 0.0071048229
     },
     {
          "name": "combined_priority_commitment_v1",
          "algorithm": null,
          "code": "import numpy as np\n\ndef combined_priority_commitment_v1(units_info, load):\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    min_p = [0] * n_units\n    max_p = [0] * n_units\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if -t0 < min_down:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n                \n    for i in forced_off:\n        schedules[0, i] = 0\n        schedules[1, i] = 0\n        \n    for i in forced_on + free_online:\n        unit = units_info[i]\n        min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        \n    for i in free_offline:\n        unit = units_info[i]\n        min_p[i] = unit['p_min_i']\n        max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    committed = forced_on.copy()\n    curr_min = sum(min_p[i] for i in forced_on)\n    curr_max = sum(max_p[i] for i in forced_on)\n    \n    free_units = free_online + free_offline\n    metric = {}\n    \n    for i in free_units:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        min_val = min_p[i]\n        eff_min = max(min_val, 1e-5)\n        startup_cost = unit['s_i'] if i in free_offline else 0\n        cost_at_min = a + b * min_val + c * min_val ** 2 + startup_cost\n        metric[i] = cost_at_min / eff_min\n    \n    sorted_free = sorted(free_units, key=lambda i: metric[i])\n    skipped = []\n    \n    for i in sorted_free:\n        if curr_max >= load[0]:\n            break\n        if curr_min + min_p[i] <= load[0]:\n            committed.append(i)\n            curr_min += min_p[i]\n            curr_max += max_p[i]\n        else:\n            skipped.append(i)\n            \n    for i in skipped:\n        if curr_max >= load[0]:\n            break\n        committed.append(i)\n        curr_min += min_p[i]\n        curr_max += max_p[i]\n    \n    if curr_min > load[0]:\n        free_committed = [i for i in committed if i not in forced_on]\n        free_committed.sort(key=lambda i: metric[i], reverse=True)\n        for i in free_committed:\n            new_min = curr_min - min_p[i]\n            new_max = curr_max - max_p[i]\n            if new_max < load[0]:\n                continue\n            committed.remove(i)\n            curr_min = new_min\n            curr_max = new_max\n            if curr_min <= load[0]:\n                break\n    \n    for i in range(n_units):\n        if i not in committed:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    P_total = min(max(load[0], curr_min), curr_max)\n    \n    if committed:\n        if abs(curr_max - curr_min) < 1e-5:\n            for i in committed:\n                schedules[1, i] = min_p[i]\n        else:\n            def compute_total_p(lam):\n                total = 0\n                for i in committed:\n                    unit = units_info[i]\n                    b_val = unit['b_i']\n                    c_val = unit['c_i']\n                    if c_val == 0:\n                        p_val = min_p[i] if lam < b_val else max_p[i]\n                    else:\n                        low_mc = b_val + 2 * c_val * min_p[i]\n                        high_mc = b_val + 2 * c_val * max_p[i]\n                        if lam < low_mc:\n                            p_val = min_p[i]\n                        elif lam > high_mc:\n                            p_val = max_p[i]\n                        else:\n                            p_val = (lam - b_val) / (2 * c_val)\n                    total += p_val\n                return total\n            \n            lambda_low = -1e5\n            lambda_high = 1e5\n            tolerance = 0.01\n            max_iter = 1000\n            iter_count = 0\n            \n            while iter_count < max_iter:\n                lambda_mid = (lambda_low + lambda_high) / 2\n                total_mid = compute_total_p(lambda_mid)\n                if abs(total_mid - P_total) < tolerance:\n                    break\n                if total_mid < P_total:\n                    lambda_low = lambda_mid\n                else:\n                    lambda_high = lambda_mid\n                iter_count += 1\n            \n            total_final = 0\n            for i in committed:\n                unit = units_info[i]\n                b_val = unit['b_i']\n                c_val = unit['c_i']\n                if c_val == 0:\n                    p_val = min_p[i] if lambda_mid < b_val else max_p[i]\n                else:\n                    low_mc = b_val + 2 * c_val * min_p[i]\n                    high_mc = b_val + 2 * c_val * max_p[i]\n                    if lambda_mid < low_mc:\n                        p_val = min_p[i]\n                    elif lambda_mid > high_mc:\n                        p_val = max_p[i]\n                    else:\n                        p_val = (lambda_mid - b_val) / (2 * c_val)\n                schedules[1, i] = p_val\n                total_final += p_val\n            \n            residual = P_total - total_final\n            if abs(residual) > tolerance:\n                directions = 1 if residual > 0 else -1\n                adjust_units = []\n                for i in committed:\n                    if directions > 0 and schedules[1, i] < max_p[i]:\n                        mc = b_val + 2 * c_val * schedules[1, i] if c_val != 0 else b_val\n                        adjust_units.append((i, mc, 1))\n                    elif directions < 0 and schedules[1, i] > min_p[i]:\n                        mc = b_val + 2 * c_val * schedules[1, i] if c_val != 0 else b_val\n                        adjust_units.append((i, mc, -1))\n                if adjust_units:\n                    adjust_units.sort(key=lambda x: x[1] * x[2])\n                    adj_per_unit = residual / len(adjust_units)\n                    for i, _, _ in adjust_units:\n                        new_p = max(min_p[i], min(max_p[i], schedules[1, i] + adj_per_unit))\n                        schedules[1, i] = new_p\n        \n        for i in committed:\n            schedules[0, i] = 1\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054296182,
          "gap_price_rate": 0.008780955,
          "fitness": 0.0071052866
     },
     {
          "name": "refined_2period_ramp_aware_amortized",
          "algorithm": "1. Classify units into forced-on (violating min uptime/shutdown constraints), forced-off (violating min downtime), free-online (online without forced constraints), and free-offline (offline without forced constraints). Forced-on units must remain online due to operational constraints.\n2. Compute feasible power bounds considering ramp limits:\n   - For forced-on/free-online: min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - For free-offline: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Calculate amortized startup cost over min(2, t_on_min_i) periods for free-offline units to account for short-term commitment costs\n4. Build committed set starting with forced-on units. Add free units in ascending order of (amortized cost per MW at min power), skipping units that make cumulative min output exceed current load\n5. If cumulative max capacity < load, add remaining free units without min power constraint\n6. Remove most expensive free units when cumulative min output > load to ensure feasibility\n7. Perform economic dispatch using lambda iteration with bisection:\n   a) Set initial outputs to min_p for all committed units\n   b) Adjust lambda to balance generation-load difference\n   c) Clamp outputs within feasible bounds during iterations\n   d) Apply iterative adjustment to close any residual gap after convergence\n8. Set uncommitted units to offline state (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef refined_2period_ramp_aware_amortized(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize arrays\n    forced_on = [False] * n_units\n    forced_off = [False] * n_units\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    cost_per_MW = [0.0] * n_units\n    amortized_periods = [2] * n_units\n    \n    # Step 1: Classify units and set operational bounds\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # Was online\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            \n            # Check min uptime and shutdown ramp constraints\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                forced_on[i] = True\n        else:  # Was offline\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Check min downtime\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                forced_off[i] = True\n    \n    # Step 2: Compute amortized costs\n    for i, unit in enumerate(units_info):\n        if forced_on[i] or forced_off[i]:\n            continue\n            \n        p_min_val = min_p[i]\n        if p_min_val <= 0:\n            cost_per_MW[i] = 1e12  # Prevent division by zero\n            continue\n            \n        if unit['u_i_0'] == 1:  # Free-online\n            base_cost = unit['a_i'] + unit['b_i'] * p_min_val + unit['c_i'] * (p_min_val ** 2)\n            cost_per_MW[i] = base_cost / p_min_val\n        else:  # Free-offline\n            amortized_periods[i] = min(2, unit['t_on_min_i'])\n            amortized_startup = unit['s_i'] / amortized_periods[i]\n            base_cost = unit['a_i'] + amortized_startup + unit['b_i'] * p_min_val + unit['c_i'] * (p_min_val ** 2)\n            cost_per_MW[i] = base_cost / p_min_val\n            \n    # Step 3: Build commitment set\n    committed_units = set()\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Add forced-on units first\n    for i in range(n_units):\n        if forced_on[i]:\n            committed_units.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Candidate free units sorted by cost\n    free_units = [i for i in range(n_units) if not forced_on[i] and not forced_off[i]]\n    free_units_sorted = sorted(free_units, key=lambda i: cost_per_MW[i])\n    \n    # Stage 1: Add without violating min constraint\n    stage1_commits = []\n    temp_min = total_min\n    temp_max = total_max\n    for i in free_units_sorted:\n        if temp_max >= current_load:\n            break\n        if temp_min + min_p[i] <= current_load:\n            stage1_commits.append(i)\n            temp_min += min_p[i]\n            temp_max += max_p[i]\n    \n    committed_units.update(stage1_commits)\n    total_min = temp_min\n    total_max = temp_max\n    \n    # Stage 2: Add remaining if needed without min constraint\n    if total_max < current_load:\n        remaining = [i for i in free_units_sorted if i not in stage1_commits]\n        for i in remaining:\n            if total_max >= current_load:\n                break\n            committed_units.add(i)\n            total_min += min_p[i]\n            total_max += max_p[i]\n    \n    # Step 4: Remove expensive units if overcommitted\n    free_in_committed = [i for i in committed_units if not forced_on[i]]\n    free_in_committed_sorted = sorted(free_in_committed, key=lambda i: cost_per_MW[i], reverse=True)\n    \n    while total_min > current_load and free_in_committed_sorted:\n        i = free_in_committed_sorted.pop(0)\n        committed_units.remove(i)\n        total_min -= min_p[i]\n        total_max -= max_p[i]\n    \n    # Initialize output arrays\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 5: Economic dispatch for committed units\n    if committed_units:\n        # Prepare committed unit parameters\n        indices = list(committed_units)\n        min_p_list = [min_p[i] for i in indices]\n        max_p_list = [max_p[i] for i in indices]\n        a_list = [units_info[i]['a_i'] for i in indices]\n        b_list = [units_info[i]['b_i'] for i in indices]\n        c_list = [units_info[i]['c_i'] for i in indices]\n        n_committed = len(indices)\n        \n        # Initialize outputs at minimum\n        p_vals = min_p_list.copy()\n        total_p = sum(p_vals)\n        \n        # Lambda iteration setup\n        tol = 1e-5\n        max_iter = 1000\n        gap = current_load - total_p\n        \n        # Only dispatch if there's load to allocate\n        if abs(gap) > tol:\n            # Find valid lambda bounds\n            low_bound = float('inf')\n            high_bound = float('-inf')\n            \n            for i in range(n_committed):\n                ic_min = b_list[i] + 2 * c_list[i] * min_p_list[i]\n                ic_max = b_list[i] + 2 * c_list[i] * max_p_list[i]\n                low_bound = min(low_bound, ic_min)\n                high_bound = max(high_bound, ic_max)\n            \n            # Expand bounds for safety\n            low = max(0, low_bound - 100)\n            high = high_bound + 100\n            \n            # Bisection method\n            iter_count = 0\n            while abs(high - low) > tol and iter_count < max_iter:\n                mid = (low + high) / 2\n                total_test = 0.0\n                \n                for i in range(n_committed):\n                    if c_list[i] == 0:  # Linear unit\n                        p_test = max_p_list[i] if mid > b_list[i] else min_p_list[i]\n                    else:\n                        p_test = (mid - b_list[i]) / (2 * c_list[i])\n                        p_test = max(min_p_list[i], min(max_p_list[i], p_test))\n                    total_test += p_test\n                \n                if total_test < current_load:\n                    low = mid\n                else:\n                    high = mid\n                iter_count += 1\n            \n            # Final projection\n            mid = (low + high) / 2\n            total_test = 0.0\n            p_vals = []\n            \n            for i in range(n_committed):\n                if c_list[i] == 0:\n                    p_val = max_p_list[i] if mid > b_list[i] else min_p_list[i]\n                else:\n                    p_val = (mid - b_list[i]) / (2 * c_list[i])\n                    p_val = max(min_p_list[i], min(max_p_list[i], p_val))\n                p_vals.append(p_val)\n                total_test += p_val\n            \n            # Iterative adjustment for residual gap\n            gap = current_load - total_test\n            if abs(gap) > tol:\n                # Calculate marginal costs at current dispatch\n                marginal_costs = []\n                for i in range(n_committed):\n                    marginal_costs.append(b_list[i] + 2 * c_list[i] * p_vals[i])\n                \n                sorted_idx = np.argsort(marginal_costs)\n                if gap > 0:  # Increase generation\n                    for idx in sorted_idx:\n                        room = max_p_list[idx] - p_vals[idx]\n                        if room > 0:\n                            add = min(room, gap)\n                            p_vals[idx] += add\n                            gap -= add\n                        if gap <= 0:\n                            break\n                else:  # Decrease generation\n                    gap_abs = abs(gap)\n                    for idx in sorted_idx[::-1]:\n                        room = p_vals[idx] - min_p_list[idx]\n                        if room > 0:\n                            remove = min(room, gap_abs)\n                            p_vals[idx] -= remove\n                            gap_abs -= remove\n                        if gap_abs <= 0:\n                            break\n            \n            # Assign computed values\n            for i, idx in enumerate(indices):\n                p_out[idx] = p_vals[i]\n                u_out[idx] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054684574,
          "gap_price_rate": 0.0088119122,
          "fitness": 0.0071401848
     },
     {
          "name": "rolling_commitment_2period",
          "algorithm": "1. Classify units into forced-on (violating min uptime/shutdown constraints), forced-off (violating min downtime), free-online (online without forced constraints), and free-offline (offline without forced constraints)\n2. Compute feasible power limits for current period considering ramp constraints:\n   - Forced-on/free-online: min_p = max(p_min_i, p_i_0 - p_down_i), max_p = min(p_max_i, p_i_0 + p_up_i)\n   - Free-offline: min_p = p_min_i, max_p = min(p_max_i, p_start_i)\n3. Compute cost metrics for free units with amortized startup cost over min(2, t_on_min_i) periods for free-offline units\n4. Build committed set starting with forced-on units\n5. Add free units in cost-ascending order without exceeding cumulative min output\n6. If needed, add remaining free units ignoring min constraint to prevent under-generation\n7. Perform economic dispatch for committed units using bisection-based lambda iteration\n8. Set uncommitted units to offline state (u_i=0, p_i=0)\n",
          "code": "import numpy as np\n\ndef rolling_commitment_2period(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Step 1: Classify units\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < min_up or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < min_down:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n    \n    # Step 2: Compute feasible power bounds\n    min_powers = [0] * n_units\n    max_powers = [0] * n_units\n    \n    for i in range(n_units):\n        unit = units_info[i]\n        if i in forced_on or i in free_online:\n            min_powers[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_powers[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        elif i in free_offline:\n            min_powers[i] = unit['p_min_i']\n            max_powers[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:  # forced_off\n            min_powers[i] = 0\n            max_powers[i] = 0\n    \n    # Step 3: Compute cost metrics and form candidate list\n    candidate_list = []\n    \n    # Free-online cost metric\n    for i in free_online:\n        p_min = min_powers[i]\n        if p_min == 0:\n            cost_metric = float('inf')\n        else:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            cost_metric = (a + b * p_min + c * p_min**2) / p_min\n        candidate_list.append((cost_metric, i))\n    \n    # Free-offline cost metric (2-period amortization)\n    for i in free_offline:\n        p_min = min_powers[i]\n        if p_min == 0:\n            cost_metric = float('inf')\n        else:\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            s = units_info[i]['s_i']\n            t_up_min = units_info[i]['t_on_min_i']\n            T = max(1, min(2, t_up_min))\n            amortized_startup = s / T\n            cost_metric = (a + b * p_min + c * p_min**2 + amortized_startup) / p_min\n        candidate_list.append((cost_metric, i))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Step 4-6: Build committed set\n    committed = set(forced_on)\n    total_min = sum(min_powers[i] for i in forced_on)\n    total_max = sum(max_powers[i] for i in forced_on)\n    \n    # First pass: add without violating min constraint\n    for cost, i in candidate_list:\n        if total_max >= current_load:\n            break\n        new_min = total_min + min_powers[i]\n        if new_min <= current_load:\n            committed.add(i)\n            total_min = new_min\n            total_max += max_powers[i]\n    \n    # Second pass: add remaining if still insufficient max capacity\n    remaining = [i for cost, i in candidate_list if i not in committed]\n    for i in remaining:\n        if total_max >= current_load:\n            break\n        committed.add(i)\n        total_min += min_powers[i]\n        total_max += max_powers[i]\n    \n    # Step 7: Economic dispatch for committed units\n    u_arr = np.zeros(n_units)\n    p_arr = np.zeros(n_units)\n    \n    dispatch_units = []\n    dispatch_indices = []\n    for i in committed:\n        u_arr[i] = 1\n        dispatch_indices.append(i)\n        dispatch_units.append({\n            'min_p': min_powers[i],\n            'max_p': max_powers[i],\n            'b': units_info[i]['b_i'],\n            'c': units_info[i]['c_i']\n        })\n    \n    if dispatch_units:\n        # Determine target generation\n        target = current_load\n        if total_min > target:\n            target = total_min\n        elif total_max < target:\n            target = total_max\n        \n        # Find lambda bounds\n        marginal_low = []\n        marginal_high = []\n        for u in dispatch_units:\n            if u['c'] == 0:\n                mc = u['b']\n                marginal_low.append(mc)\n                marginal_high.append(mc)\n            else:\n                marginal_low.append(u['b'] + 2 * u['c'] * u['min_p'])\n                marginal_high.append(u['b'] + 2 * u['c'] * u['max_p'])\n        \n        lambda_low = min(marginal_low) if marginal_low else 0\n        lambda_high = max(marginal_high) if marginal_high else 1\n        \n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        powers = [u['min_p'] for u in dispatch_units]\n        \n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_gen = 0\n            new_powers = []\n            \n            for u in dispatch_units:\n                if u['c'] == 0:\n                    if lambda_mid < u['b']:\n                        p = u['min_p']\n                    else:\n                        p = u['max_p']\n                else:\n                    p_ideal = (lambda_mid - u['b']) / (2 * u['c'])\n                    p = max(u['min_p'], min(u['max_p'], p_ideal))\n                new_powers.append(p)\n                total_gen += p\n            \n            if abs(total_gen - target) < tol:\n                powers = new_powers\n                break\n                \n            if total_gen < target:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Set dispatch results\n        for idx, p in zip(dispatch_indices, powers):\n            p_arr[idx] = p\n    \n    # Step 8: Prepare output\n    schedules = np.vstack((u_arr, p_arr))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.005468458,
          "gap_price_rate": 0.008811912,
          "fitness": 0.007140185
     },
     {
          "name": "enhanced_rolling_commitment_min_up_2period",
          "algorithm": "1. Classify units into forced-on (violating min up-time/shutdown constraints), forced-off (violating min down-time), free-online (online not forced), and free-offline (offline not forced).\n2. Compute feasible power bounds: for online units, bounds are [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]; for offline units, bounds are [p_min_i, min(p_max_i, p_start_i)].\n3. Calculate cost metric for free units: free-online uses (a_i + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i; free-offline includes startup cost amortized over min(2, t_on_min_i): (a_i + s_i/min(2,t_on_min_i) + b_i*p_min_i + c_i*p_min_i\u00b2)/p_min_i.\n4. Form candidate list of free units sorted by ascending cost metric.\n5. Initialize committed set with forced-on units. Add free candidates in cost order until cumulative max power \u2265 load, skipping units that make cumulative min power > load.\n6. If cumulative max < load after step 5, add skipped candidates in cost order without min power constraint.\n7. If cumulative min > load, remove highest-cost free units from committed set while maintaining cumulative max \u2265 load.\n8. Perform constrained economic dispatch using lambda iteration with bisection to optimize power allocation among committed units.\n9. Adjust for residual gap by prioritizing units with highest ramping capacity near operating limits.\n10. Set uncommitted units to off (u_i=0, p_i=0).\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_min_up_2period(units_info, load):\n    n_units = len(units_info)\n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    cost_metric = np.full(n_units, np.inf)\n\n    current_load = load[0]\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on.append(idx)\n            else:\n                free_online.append(idx)\n            min_p[idx] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_p[idx] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if -t_i0 < unit['t_off_min_i']:\n                forced_off.append(idx)\n                min_p[idx] = max_p[idx] = 0\n            else:\n                free_offline.append(idx)\n                min_p[idx] = unit['p_min_i']\n                max_p[idx] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    free_candidates = []\n    for idx in free_online:\n        unit = units_info[idx]\n        cost_metric[idx] = (unit['a_i'] + unit['b_i'] * min_p[idx] + unit['c_i'] * min_p[idx]**2) / min_p[idx]\n        free_candidates.append((cost_metric[idx], idx))\n        \n    for idx in free_offline:\n        unit = units_info[idx]\n        amort_periods = min(2, unit['t_on_min_i'])\n        amortized_startup = unit['s_i'] / amort_periods\n        cost_metric[idx] = (unit['a_i'] + amortized_startup + unit['b_i'] * min_p[idx] + unit['c_i'] * min_p[idx]**2) / min_p[idx]\n        free_candidates.append((cost_metric[idx], idx))\n    \n    free_candidates.sort(key=lambda x: x[0])\n    committed_set = set(forced_on)\n    total_min = sum(min_p[i] for i in forced_on)\n    total_max = sum(max_p[i] for i in forced_on)\n    skipped_candidates = []\n    \n    for cost_val, idx in free_candidates:\n        if total_max >= current_load:\n            skipped_candidates.append((cost_val, idx))\n            continue\n        if total_min + min_p[idx] <= current_load:\n            committed_set.add(idx)\n            total_min += min_p[idx]\n            total_max += max_p[idx]\n        else:\n            skipped_candidates.append((cost_val, idx))\n    \n    skipped_candidates.sort(key=lambda x: x[0])\n    for cost_val, idx in skipped_candidates:\n        if total_max >= current_load:\n            break\n        committed_set.add(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    if total_min > current_load:\n        free_committed = sorted([i for i in committed_set if i not in forced_on], key=lambda i: cost_metric[i], reverse=True)\n        for idx in free_committed:\n            if total_min <= current_load:\n                break\n            if total_max - max_p[idx] >= current_load:\n                committed_set.remove(idx)\n                total_min -= min_p[idx]\n                total_max -= max_p[idx]\n    \n    committed_list = list(committed_set)\n    n_committed = len(committed_list)\n    if n_committed == 0:\n        u_out = np.zeros(n_units)\n        p_out = np.zeros(n_units)\n        return np.array([u_out, p_out])\n    \n    c_list = np.array([units_info[i]['c_i'] for i in committed_list])\n    b_list = np.array([units_info[i]['b_i'] for i in committed_list])\n    min_p_list = min_p[committed_list]\n    max_p_list = max_p[committed_list]\n    marginal_min = b_list + 2 * c_list * min_p_list\n    marginal_max = b_list + 2 * c_list * max_p_list\n    lambda_low = np.min(marginal_min)\n    lambda_high = np.max(marginal_max)\n    p_dispatch = np.zeros(n_committed)\n    tolerance = 1e-3\n    max_iter = 1000\n    iter_count = 0\n    \n    while iter_count < max_iter and lambda_high - lambda_low > 1e-6:\n        lambda_mid = (lambda_low + lambda_high) / 2.0\n        for j in range(n_committed):\n            if c_list[j] == 0:\n                p_dispatch[j] = min_p_list[j] if lambda_mid < b_list[j] else max_p_list[j]\n            else:\n                p_uncon = (lambda_mid - b_list[j]) / (2 * c_list[j])\n                p_dispatch[j] = np.clip(p_uncon, min_p_list[j], max_p_list[j])\n        total_p = np.sum(p_dispatch)\n        if total_p < current_load:\n            lambda_low = lambda_mid\n        else:\n            lambda_high = lambda_mid\n        iter_count += 1\n    \n    total_p = np.sum(p_dispatch)\n    gap = current_load - total_p\n    \n    if gap > tolerance:\n        ramp_capacity = max_p_list - p_dispatch\n        priority = np.argsort(-ramp_capacity)\n        for idx in priority:\n            add = min(gap, ramp_capacity[idx])\n            p_dispatch[idx] += add\n            gap -= add\n            if gap <= tolerance:\n                break\n    elif gap < -tolerance:\n        gap = -gap\n        ramp_capacity = p_dispatch - min_p_list\n        priority = np.argsort(-ramp_capacity)\n        for idx in priority:\n            sub = min(gap, ramp_capacity[idx])\n            p_dispatch[idx] -= sub\n            gap -= sub\n            if gap <= tolerance:\n                break\n    \n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    for i, idx in enumerate(committed_list):\n        u_out[idx] = 1\n        p_out[idx] = p_dispatch[i]\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0054684908,
          "gap_price_rate": 0.0088119153,
          "fitness": 0.007140203
     },
     {
          "name": "rolling_commitment_amortized_short_term",
          "algorithm": "**  \n1. Classify units into forced-on (violating minimum up-time or shutdown constraints), forced-off (violating minimum down-time), free-online (online without forced constraints), and free-offline (offline without forced constraints).  \n2. Compute feasible power bounds for each unit considering ramp constraints: for online units, bounds are [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]; for offline units, bounds are [p_min_i, min(p_max_i, p_start_i)].  \n3. Calculate amortized cost per MW at min power for free units: free-online units use (a_i + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i; free-offline units include startup cost amortized over min(2, t_on_min_i) periods: (a_i + s_i / amort + b_i * p_min_i + c_i * p_min_i\u00b2) / p_min_i.  \n4. Form a sorted candidate list of free units (ascending amortized cost).  \n5. Initialize committed set with forced-on units. Add free candidates in cost order until cumulative max capacity \u2265 load or all candidates are added.  \n6. If cumulative min power > load, remove highest-cost free units (descending order) while maintaining cumulative max capacity \u2265 load until cumulative min power \u2264 load.  \n7. Dispatch:  \n   - If cumulative min > load: set all to min bounds (over-generation).  \n   - Else if cumulative max < load: set all to max bounds (under-generation).  \n   - Else: perform lambda iteration with bisection to minimize production costs (quadratic terms), then adjust residuals via marginal cost-based allocation.  \n8. Set uncommitted units to off (u_i=0, p_i=0).  \n\n**",
          "code": "import numpy as np\n\ndef rolling_commitment_amortized_short_term(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_out = np.zeros(n_units)\n    p_out = np.zeros(n_units)\n    \n    forced_on, forced_off, free_online, free_offline = [], [], [], []\n    min_bounds = np.zeros(n_units)\n    max_bounds = np.zeros(n_units)\n    cost_per_mw = np.full(n_units, np.inf)\n    \n    for i, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        \n        if u_i_0 == 1:\n            if (t_i_0 < unit['t_on_min_i']) or (p_i_0 > unit['p_shut_i']):\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n            min_bounds[i] = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n            max_bounds[i] = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n        else:\n            if abs(t_i_0) < unit['t_off_min_i']:\n                forced_off.append(i)\n                min_bounds[i] = max_bounds[i] = 0\n            else:\n                free_offline.append(i)\n                min_bounds[i] = unit['p_min_i']\n                max_bounds[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    for i in free_online:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * min_bounds[i] + unit['c_i'] * min_bounds[i]**2\n        cost_per_mw[i] = cost / min_bounds[i]\n    \n    for i in free_offline:\n        unit = units_info[i]\n        amort = min(2, unit['t_on_min_i'])\n        total_cost = unit['a_i'] + unit['s_i'] / amort + unit['b_i'] * min_bounds[i] + unit['c_i'] * min_bounds[i]**2\n        cost_per_mw[i] = total_cost / min_bounds[i]\n    \n    candidate_list = free_online + free_offline\n    candidate_list.sort(key=lambda i: cost_per_mw[i])\n    \n    committed_set = forced_on.copy()\n    min_total = sum(min_bounds[i] for i in forced_on)\n    max_total = sum(max_bounds[i] for i in forced_on)\n    added = []\n    \n    for i in candidate_list:\n        if max_total < current_load:\n            committed_set.append(i)\n            added.append(i)\n            min_total += min_bounds[i]\n            max_total += max_bounds[i]\n        else:\n            break\n    \n    if min_total > current_load:\n        added_sorted = sorted(added, key=lambda i: cost_per_mw[i], reverse=True)\n        for i in added_sorted:\n            if max_total - max_bounds[i] >= current_load:\n                committed_set.remove(i)\n                min_total -= min_bounds[i]\n                max_total -= max_bounds[i]\n                if min_total <= current_load:\n                    break\n    \n    if min_total > current_load:\n        for i in committed_set:\n            p_out[i] = min_bounds[i]\n            u_out[i] = 1\n    elif max_total < current_load:\n        for i in committed_set:\n            p_out[i] = max_bounds[i]\n            u_out[i] = 1\n    else:\n        units_in = [units_info[i] for i in committed_set]\n        min_b = [min_bounds[i] for i in committed_set]\n        max_b = [max_bounds[i] for i in committed_set]\n        b_coeff = [u['b_i'] for u in units_in]\n        c_coeff = [u['c_i'] for u in units_in]\n        \n        lo = min(b_i + 2*c_i*min_b_i if c_i !=0 else b_i for b_i, c_i, min_b_i in zip(b_coeff, c_coeff, min_b))\n        hi = max(b_i + 2*c_i*max_b_i if c_i !=0 else b_i for b_i, c_i, max_b_i in zip(b_coeff, c_coeff, max_b))\n        \n        while hi - lo > 1e-5:\n            mid = (lo + hi) / 2\n            gen, gen_total = [], 0\n            for j in range(len(committed_set)):\n                if c_coeff[j] > 0:\n                    p = (mid - b_coeff[j]) / (2 * c_coeff[j])\n                else:\n                    p = min_b[j] if mid < b_coeff[j] else max_b[j]\n                p_clamp = np.clip(p, min_b[j], max_b[j])\n                gen.append(p_clamp)\n                gen_total += p_clamp\n            if gen_total < current_load:\n                lo = mid\n            else:\n                hi = mid\n        \n        p_lambda = [(mid - b_i) / (2 * c_i) if c_i > 0 else (min_b_i if mid < b_i else max_b_i) \n                    for b_i, c_i, min_b_i, max_b_i in zip(b_coeff, c_coeff, min_b, max_b)]\n        p_temp = np.clip(p_lambda, min_b, max_b)\n        residual = current_load - np.sum(p_temp)\n        tol = 1e-2\n        \n        while abs(residual) > tol:\n            marginal_costs = []\n            for j, p_val in enumerate(p_temp):\n                if c_coeff[j] > 0:\n                    mc = b_coeff[j] + 2 * c_coeff[j] * p_val\n                else:\n                    mc = b_coeff[j]\n                marginal_costs.append(mc)\n            \n            if residual > 0:\n                idx = np.argmin([mc if p_val < max_b[j] else np.inf for j, (mc, p_val) in enumerate(zip(marginal_costs, p_temp))])\n                add = min(residual, max_b[idx] - p_temp[idx])\n                p_temp[idx] += add\n                residual -= add\n            else:\n                idx = np.argmax([mc if p_val > min_b[j] else -np.inf for j, (mc, p_val) in enumerate(zip(marginal_costs, p_temp))])\n                sub = min(abs(residual), p_temp[idx] - min_b[idx])\n                p_temp[idx] -= sub\n                residual += sub\n        \n        for idx, i in enumerate(committed_set):\n            p_out[i] = p_temp[idx]\n            u_out[i] = 1\n    \n    schedules = np.vstack((u_out, p_out))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.005468774,
          "gap_price_rate": 0.0088120119,
          "fitness": 0.0071403929
     },
     {
          "name": "rolling_commitment_amortized_min_up",
          "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown constraints), forced-off (violating min down-time), free-online (online without forced constraints), and free-offline (offline without forced constraints) based on their prior state and physical constraints.\n2. Compute feasible power bounds for each unit considering ramp constraints: for online units, bounds are [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]; for offline units, bounds are [p_min_i, min(p_max_i, p_start_i)].\n3. Calculate amortized cost per MW at min power for free units: free-online units use (a_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i, free-offline units include startup cost amortized over min up-time: (a_i + s_i/t_on_min_i + b_i*p_min_i + c_i*p_min_i**2) / p_min_i.\n4. Form a sorted candidate list of free units (free-online followed by free-offline) by ascending amortized cost.\n5. Initialize the committed set with forced-on units. Add free candidates in cost order until cumulative max capacity \u2265 current load, tracking cumulative min/max power.\n6. If cumulative min power exceeds load, remove the highest-cost free units (in descending order) while maintaining cumulative max capacity \u2265 load.\n7. Perform constrained economic dispatch for committed units using lambda iteration with bisection to minimize generation cost (quadratic production cost) within power bounds, followed by residual adjustment to meet load exactly.\n8. Set uncommitted units to off (u_i=0, p_i=0).\n9. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_amortized_min_up(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    min_p_i_dict = {}\n    max_p_i_dict = {}\n\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n\n    for i in forced_on + free_online:\n        unit = units_info[i]\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_0 = unit['p_i_0']\n        min_p_i_dict[i] = max(p_min, p_0 - p_down)\n        max_p_i_dict[i] = min(p_max, p_0 + p_up)\n    \n    for i in free_offline:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_start = unit['p_start_i']\n        min_p_i_dict[i] = p_min\n        max_p_i_dict[i] = min(p_max, p_start)\n    \n    cost_rate_i_dict = {}\n    for i in free_online:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        p_min = min_p_i_dict[i]\n        cost_rate_i_dict[i] = (a + b * p_min + c * p_min**2) / p_min\n    \n    for i in free_offline:\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        p_min = min_p_i_dict[i]\n        t_on_min = unit['t_on_min_i']\n        amortized_startup = s / t_on_min\n        cost_rate_i_dict[i] = (a + amortized_startup + b * p_min + c * p_min**2) / p_min\n    \n    candidate_free = free_online + free_offline\n    candidate_free_sorted = sorted(candidate_free, key=lambda i: cost_rate_i_dict[i])\n    \n    committed_set = forced_on[:]\n    free_committed = []\n    total_min = sum(min_p_i_dict[i] for i in forced_on)\n    total_max = sum(max_p_i_dict[i] for i in forced_on)\n    \n    for i in candidate_free_sorted:\n        if total_max < current_load:\n            committed_set.append(i)\n            free_committed.append(i)\n            total_min += min_p_i_dict[i]\n            total_max += max_p_i_dict[i]\n        else:\n            break\n    \n    free_committed_sorted_desc = sorted(free_committed, key=lambda i: cost_rate_i_dict[i], reverse=True)\n    for i in free_committed_sorted_desc:\n        if total_min <= current_load:\n            break\n        new_total_max = total_max - max_p_i_dict[i]\n        if new_total_max >= current_load:\n            committed_set.remove(i)\n            free_committed.remove(i)\n            total_min -= min_p_i_dict[i]\n            total_max -= max_p_i_dict[i]\n    \n    if not committed_set:\n        u_list = [0] * n_units\n        p_list = [0.0] * n_units\n        return np.array([u_list, p_list], dtype=np.float64)\n    \n    low_lambda = float('inf')\n    high_lambda = float('-inf')\n    for i in committed_set:\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        min_p = min_p_i_dict[i]\n        max_p = max_p_i_dict[i]\n        if c == 0:\n            low_lambda = min(low_lambda, b)\n            high_lambda = max(high_lambda, b)\n        else:\n            low_lambda = min(low_lambda, b + 2 * c * min_p)\n            high_lambda = max(high_lambda, b + 2 * c * max_p)\n    \n    if low_lambda == high_lambda:\n        low_lambda -= 1.0\n        high_lambda += 1.0\n    \n    p_dispatch = {}\n    for i in committed_set:\n        p_dispatch[i] = min_p_i_dict[i]\n    \n    tol = 1e-5\n    max_iter = 1000\n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_power = 0.0\n        for i in committed_set:\n            unit = units_info[i]\n            b = unit['b_i']\n            c = unit['c_i']\n            min_p = min_p_i_dict[i]\n            max_p = max_p_i_dict[i]\n            if c == 0:\n                p_val = max_p if lambda_mid > b else min_p\n            else:\n                p_uncon = (lambda_mid - b) / (2 * c)\n                p_val = max(min_p, min(p_uncon, max_p))\n            p_dispatch[i] = p_val\n            total_power += p_val\n        \n        if abs(total_power - current_load) < tol:\n            break\n        \n        if total_power < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    residual = current_load - total_power\n    if residual > 0:\n        for i in committed_set:\n            if residual <= 0:\n                break\n            if p_dispatch[i] < max_p_i_dict[i]:\n                margin = max_p_i_dict[i] - p_dispatch[i]\n                add_val = min(margin, residual)\n                p_dispatch[i] += add_val\n                residual -= add_val\n    elif residual < 0:\n        for i in committed_set:\n            if residual >= 0:\n                break\n            if p_dispatch[i] > min_p_i_dict[i]:\n                margin = p_dispatch[i] - min_p_i_dict[i]\n                red_val = min(margin, -residual)\n                p_dispatch[i] -= red_val\n                residual += red_val\n    \n    u_list = [0] * n_units\n    p_list = [0.0] * n_units\n    for i in range(n_units):\n        if i in committed_set:\n            u_list[i] = 1\n            p_list[i] = p_dispatch[i]\n    \n    return np.array([u_list, p_list], dtype=np.float64)",
          "from": "crossover",
          "gap_power_rate": 0.0055425105,
          "gap_price_rate": 0.0089835114,
          "fitness": 0.007263011
     },
     {
          "name": "refined_commit_priority_amortized_min_up",
          "algorithm": "1. Classify units into forced-on (violating min uptime/shutdown ramp constraints), forced-off (violating min downtime), free-online (online without forced constraints), and free-offline (offline without forced constraints).\n2. Compute feasible power bounds considering ramp constraints: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)] for online units; [p_min_i, min(p_max_i, p_start_i)] for offline units.\n3. Amortize startup costs over min_up_time for free-offline units in cost metrics.\n4. Build committed set: start with forced-on, add free units (online then offline) sorted by amortized cost per MW until cumulative max capacity >= load, skipping units that would cause cumulative min output > load.\n5. If cumulative max capacity < load after step 4, add skipped units in cost order without min constraint.\n6. If cumulative min output > load, remove most expensive free units from committed set without causing under-capacity.\n7. Dispatch:\n   - Set output = min_bound if total min output \u2265 load\n   - Set output = max_bound if total max output \u2264 load\n   - Else perform lambda iteration to distribute load optimally within bounds.\n8. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_commit_priority_amortized_min_up(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    forced_on_indices = []\n    forced_off_indices = []\n    free_online_indices = []\n    free_offline_indices = []\n    \n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    cost_per_mw = [0.0] * n_units\n    S_indices = set()\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                forced_on_indices.append(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            else:\n                free_online_indices.append(i)\n                min_p[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n                max_p[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                forced_off_indices.append(i)\n            else:\n                free_offline_indices.append(i)\n                min_p[i] = unit['p_min_i']\n                max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 2: Handle forced-on units\n    for i in forced_on_indices:\n        S_indices.add(i)\n    min_total = sum(min_p[i] for i in forced_on_indices)\n    max_total = sum(max_p[i] for i in forced_on_indices)\n    \n    # Step 3: Compute cost for free units\n    for i in free_online_indices:\n        cost_per_mw[i] = (units_info[i]['a_i'] + \n                          units_info[i]['b_i'] * min_p[i] + \n                          units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n    \n    for i in free_offline_indices:\n        t_on_min = units_info[i]['t_on_min_i']\n        amortized_startup = units_info[i]['s_i'] / t_on_min if t_on_min > 0 else units_info[i]['s_i']\n        cost_per_mw[i] = (units_info[i]['a_i'] + amortized_startup + \n                          units_info[i]['b_i'] * min_p[i] + \n                          units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n    \n    # Combine free units and sort\n    free_indices = free_online_indices + free_offline_indices\n    free_indices_sorted = sorted(free_indices, key=lambda i: cost_per_mw[i])\n    skipped_free = []\n    \n    # Step 4: Add free units without exceeding min constraint\n    for i in free_indices_sorted:\n        if max_total >= current_load:\n            break\n        if min_total + min_p[i] <= current_load:\n            S_indices.add(i)\n            min_total += min_p[i]\n            max_total += max_p[i]\n        else:\n            skipped_free.append(i)\n    \n    # Step 5: Add skipped units if under capacity\n    if max_total < current_load:\n        for i in skipped_free:\n            if max_total >= current_load:\n                break\n            S_indices.add(i)\n            min_total += min_p[i]\n            max_total += max_p[i]\n    \n    # Step 6: Remove expensive units to satisfy min constraint\n    free_in_S = [i for i in S_indices if i in free_indices]\n    free_in_S_sorted = sorted(free_in_S, key=lambda i: cost_per_mw[i], reverse=True)\n    \n    for i in free_in_S_sorted:\n        if min_total <= current_load:\n            break\n        candidate_min = min_total - min_p[i]\n        candidate_max = max_total - max_p[i]\n        if candidate_max >= current_load:\n            S_indices.remove(i)\n            min_total = candidate_min\n            max_total = candidate_max\n    \n    # Initialize output arrays\n    u_arr = [0] * n_units\n    p_arr = [0.0] * n_units\n    \n    # Step 7: Dispatch\n    P_total = min(max(min_total, current_load), max_total)\n    \n    if P_total == min_total:\n        for i in S_indices:\n            u_arr[i] = 1\n            p_arr[i] = min_p[i]\n    elif P_total == max_total:\n        for i in S_indices:\n            u_arr[i] = 1\n            p_arr[i] = max_p[i]\n    else:\n        for i in S_indices:\n            u_arr[i] = 1\n        \n        # Prepare parameters for lambda iteration\n        min_list = [min_p[i] for i in S_indices]\n        max_list = [max_p[i] for i in S_indices]\n        b_list = [units_info[i]['b_i'] for i in S_indices]\n        c_list = [units_info[i]['c_i'] for i in S_indices]\n        idx_list = sorted(S_indices)\n        \n        # Lambda iteration setup\n        lambda_low = -1e10\n        lambda_high = 1e10\n        tol = 1e-5\n        max_iter = 1000\n        total_gen = 0.0\n        p_dispatch = [0.0] * len(S_indices)\n        \n        for iter in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            total_gen = 0.0\n            for j, i in enumerate(idx_list):\n                if c_list[j] != 0.0:\n                    p_val = (lambda_mid - b_list[j]) / (2.0 * c_list[j])\n                else:\n                    p_val = max_list[j] if lambda_mid > b_list[j] else min_list[j]\n                p_val = max(min_list[j], min(max_list[j], p_val))\n                p_dispatch[j] = p_val\n                total_gen += p_val\n            \n            if abs(total_gen - P_total) < tol:\n                break\n            if total_gen < P_total:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Assign dispatch values\n        for j, i in enumerate(idx_list):\n            p_arr[i] = p_dispatch[j]\n    \n    # Format output\n    schedules = np.array([u_arr, p_arr], dtype=float)\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0055425117,
          "gap_price_rate": 0.0089835113,
          "fitness": 0.0072630115
     },
     {
          "name": "adaptive_rolling_commitment_v2",
          "algorithm": null,
          "code": "import numpy as np\n\ndef adaptive_rolling_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n\n    must_on = []\n    must_off = []\n    free_online = []\n    free_offline = []\n    min_p = [0.0] * n_units\n    max_p = [0.0] * n_units\n    cost_per_mw = [float('inf')] * n_units\n\n    # Classify units and compute feasible ranges\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_online.append(i)\n            min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n                continue\n            free_offline.append(i)\n            min_p[i] = unit['p_min_i']\n            max_p[i] = min(unit['p_max_i'], unit['p_start_i'])\n\n    # Set must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0.0\n\n    # Compute cost_per_mw for free units\n    for i in free_online:\n        a, b, c, min_val = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], min_p[i]\n        cost_per_mw[i] = (a + b * min_val + c * min_val**2) / min_val\n    \n    for i in free_offline:\n        a, b, c, s, t_min, min_val = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i'], units_info[i]['s_i'], units_info[i]['t_on_min_i'], min_p[i]\n        amortized_startup = s / max(1, t_min)\n        cost_per_mw[i] = (a + amortized_startup + b * min_val + c * min_val**2) / min_val\n\n    # Build candidate list: free units sorted by cost_per_mw\n    candidates = free_online + free_offline\n    candidates.sort(key=lambda i: cost_per_mw[i])\n\n    committed = must_on[:]  # Start with must-on units\n    cum_min = sum(min_p[i] for i in committed)\n    cum_max = sum(max_p[i] for i in committed)\n\n    # Add candidates until cum_max >= current_load\n    to_remove = []\n    for i in candidates:\n        if cum_max < current_load:\n            committed.append(i)\n            cum_min += min_p[i]\n            cum_max += max_p[i]\n        else:\n            break\n\n    # Remove high-cost units if cum_min > load\n    committed_free = [i for i in committed if i not in must_on]\n    committed_free.sort(key=lambda i: cost_per_mw[i], reverse=True)\n    \n    for i in committed_free:\n        if cum_min > current_load:\n            new_min = cum_min - min_p[i]\n            new_max = cum_max - max_p[i]\n            if new_max >= current_load:  # Check if max still meets load\n                cum_min, cum_max = new_min, new_max\n                committed.remove(i)\n                to_remove.append(i)\n            else:\n                break\n        else:\n            break\n\n    # Set initial dispatch for committed units\n    for i in committed:\n        u[i] = 1\n        p[i] = min_p[i]\n\n    # Economic dispatch for remaining load\n    active_units = [i for i in committed]\n    remaining_load = current_load - cum_min\n    if remaining_load > 1e-6 and active_units:\n        lo_bounds = [min_p[i] for i in active_units]\n        hi_bounds = [max_p[i] for i in active_units]\n        b_coeffs = [units_info[i]['b_i'] for i in active_units]\n        c_coeffs = [units_info[i]['c_i'] for i in active_units]\n        \n        # Find lambda bounds\n        lo_deriv = min(b_i + 2 * c_i * lo for (b_i, c_i, lo) in zip(b_coeffs, c_coeffs, lo_bounds))\n        hi_deriv = max(b_i + 2 * c_i * hi for (b_i, c_i, hi) in zip(b_coeffs, c_coeffs, hi_bounds))\n        tolerance = 1e-5\n        lambda_low = lo_deriv\n        lambda_high = hi_deriv\n        \n        # Bisection\n        while lambda_high - lambda_low > tolerance:\n            lambda_mid = (lambda_low + lambda_high) / 2\n            total_power = 0\n            for idx, i in enumerate(active_units):\n                proposed_p = (lambda_mid - b_coeffs[idx]) / (2 * c_coeffs[idx])\n                p_i = min(hi_bounds[idx], max(lo_bounds[idx], proposed_p))\n                total_power += p_i\n                \n            if total_power < remaining_load + cum_min:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # Set final dispatch\n        for idx, i in enumerate(active_units):\n            proposed_p = (lambda_low - b_coeffs[idx]) / (2 * c_coeffs[idx])\n            p[i] = min(hi_bounds[idx], max(lo_bounds[idx], proposed_p))\n\n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0055428617,
          "gap_price_rate": 0.008983268,
          "fitness": 0.0072630649
     }
]