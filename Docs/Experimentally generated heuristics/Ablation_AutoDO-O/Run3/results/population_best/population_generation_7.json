{
     "name": "commit_units_by_priority_dispatch",
     "algorithm": "1. Classify units into forced-on (min uptime/shutdown constraints), forced-off (min downtime), and free units.\n2. Free units are split into previously on/off. Calculate cost rates per MW at min power for both groups (including startup cost for cold units).\n3. Form candidate list: force-on units plus free units sorted by cost rates.\n4. Build committed set by adding candidates in ascending cost order until capacity can meet load, while ensuring total minimum output <= load.\n5. For units not in the committed set, set u_i=0 and p_i=0.\n6. Perform constrained economic dispatch for committed units to minimize cost while satisfying power limits and ramp constraints:\n   - Use lambda iteration to find optimal generation levels\n   - Adjust outputs to exactly match load if needed\n7. Return commitment states and power outputs for all units.\n\n",
     "code": "import numpy as np\n\ndef commit_units_by_priority_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine force-on and force-off status for each unit\n    force_on = []\n    force_off = []\n    free_units = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Forced on if online and doesn't meet min-up time or exceeds shutdown capacity\n        if u_i0 == 1 and (t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']):\n            force_on.append(i)\n        # Forced off if offline and doesn't meet min-down time\n        elif u_i0 == 0 and abs(t_i0) < unit['t_off_min_i']:\n            force_off.append(i)\n        else:\n            free_units.append(i)\n    \n    # Calculate power ranges for units\n    low_bound = np.zeros(n_units)\n    high_bound = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            low_bound[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            high_bound[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Previously offline\n            low_bound[i] = unit['p_min_i']\n            high_bound[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Classify free units into previously on/off\n    free_on = []\n    free_off = []\n    for i in free_units:\n        if units_info[i]['u_i_0'] == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Calculate cost rate per MW for free units\n    def cost_rate(i, include_startup):\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)\n        if include_startup:\n            cost += unit['s_i']\n        return cost / unit['p_min_i']\n    \n    # Create candidate list sorted by cost rate\n    candidates = []\n    \n    # Free units previously on: no startup cost\n    for i in free_on:\n        if units_info[i]['p_i_0'] <= units_info[i]['p_shut_i']:  # Can be turned off\n            candidates.append((cost_rate(i, False), i))\n    \n    # Free units previously off: include startup cost\n    for i in free_off:\n        candidates.append((cost_rate(i, True), i))\n    \n    # Sort candidates by cost rate (ascending)\n    candidates.sort(key=lambda x: x[0])\n    candidate_ids = [idx for (_, idx) in candidates]\n    \n    # Start with force-on units as must-commit\n    committed_set = set(force_on)\n    total_min = sum(low_bound[i] for i in force_on)\n    total_max = sum(high_bound[i] for i in force_on)\n    \n    # Add free units until capacity meets load\n    for i in candidate_ids:\n        if total_max >= current_load:\n            break\n        new_min = total_min + low_bound[i]\n        if new_min <= current_load:  # Only add if min constraint still satisfied\n            committed_set.add(i)\n            total_min = new_min\n            total_max += high_bound[i]\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u[i] = 1\n        else:\n            u[i] = 0\n            p[i] = 0.0\n    \n    # Prepare for economic dispatch\n    if committed_set:\n        a = []\n        b = []\n        c = []\n        lb = []\n        ub = []\n        idx_map = []\n        \n        for i in committed_set:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            lb.append(low_bound[i])\n            ub.append(high_bound[i])\n            idx_map.append(i)\n        \n        # Economic dispatch parameters\n        a = np.array(a)\n        b = np.array(b)\n        c = np.array(c)\n        lb = np.array(lb)\n        ub = np.array(ub)\n        \n        # Initialize lambda boundaries\n        lambda_low = np.min(2 * c * lb + b)\n        lambda_high = np.max(2 * c * ub + b)\n        epsilon = 1e-5\n        max_iter = 100\n        p_committed = np.zeros(len(committed_set))\n        \n        # Lambda iteration\n        for _ in range(max_iter):\n            lambda_mid = (lambda_low + lambda_high) / 2\n            p_temp = (lambda_mid - b) / (2 * c)\n            p_temp = np.clip(p_temp, lb, ub)\n            total = np.sum(p_temp)\n            \n            if total < current_load:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n            \n            if abs(lambda_high - lambda_low) < epsilon:\n                p_committed = p_temp\n                break\n        \n        # Correct total power if needed\n        total_power = np.sum(p_committed)\n        error = current_load - total_power\n        \n        # Distribute error to units with highest sensitivity\n        while abs(error) > epsilon:\n            candidates = []\n            for j in range(len(committed_set)):\n                if error > 0 and p_committed[j] < ub[j]:\n                    # Under-generation: increase most efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n                elif error < 0 and p_committed[j] > lb[j]:\n                    # Over-generation: decrease least efficient unit\n                    inc_cost = 2 * c[j] * p_committed[j] + b[j]\n                    candidates.append((inc_cost, j))\n            \n            if not candidates:\n                break\n                \n            # Find best candidate for adjustment\n            if error > 0:\n                candidate_idx = min(candidates, key=lambda x: x[0])[1]\n                max_adjust = ub[candidate_idx] - p_committed[candidate_idx]\n                adjust = min(max_adjust, error)\n                p_committed[candidate_idx] += adjust\n            else:\n                candidate_idx = max(candidates, key=lambda x: x[0])[1]\n                max_adjust = p_committed[candidate_idx] - lb[candidate_idx]\n                adjust = min(max_adjust, -error)\n                p_committed[candidate_idx] -= adjust\n            \n            error = current_load - np.sum(p_committed)\n        \n        # Assign committed outputs\n        for j, unit_idx in enumerate(idx_map):\n            p[unit_idx] = p_committed[j]\n    \n    return np.array([u, p])",
     "from": null,
     "gap_power_rate": 0.005428536,
     "gap_price_rate": 0.0087811077,
     "fitness": 0.0071048218
}