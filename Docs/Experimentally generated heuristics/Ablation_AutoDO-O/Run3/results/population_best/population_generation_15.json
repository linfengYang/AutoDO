{
     "name": "rolling_commitment_amortized_refined",
     "algorithm": "1. Classify units into forced-on (violating min up-time or shutdown ramp constraints), forced-off (violating min down-time), free-online (online without constraints), and free-offline (offline without constraints).\n2. Compute feasible power bounds considering ramp constraints: online units use [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]; offline units use [p_min_i, min(p_max_i, p_start_i)].\n3. Calculate amortized cost per MW at min power: free-online units use (a_i + b_i * min_p_i + c_i * min_p_i^2) / min_p_i; free-offline units amortize startup cost over min(2, t_on_min_i) periods.\n4. Initialize committed set with forced-on units. Traverse free candidates sorted by amortized cost: add units until total max capacity \u2265 load, skipping if cumulative min power exceeds load.\n5. If total max capacity < load, add skipped candidates in cost order.\n6. Remove highest-cost free units from committed set until cumulative min \u2264 load while maintaining total max capacity \u2265 load.\n7. Perform constrained economic dispatch via bisection-based lambda iteration to minimize production cost.\n8. Apply marginal-cost-based residual adjustment to close any remaining load gap.\n9. Set uncommitted units to offline state (u_i=0, p_i=0).\n\n",
     "code": "import numpy as np\n\ndef rolling_commitment_amortized_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    \n    forced_on = []\n    forced_off = []\n    free_online = []\n    free_offline = []\n    min_p = np.zeros(n_units)\n    max_p = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut_i = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut_i:\n                forced_on.append(i)\n            else:\n                free_online.append(i)\n            min_p_i = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_p_i = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n        else:\n            if -t_i0 < t_off_min:\n                forced_off.append(i)\n            else:\n                free_offline.append(i)\n            min_p_i = unit['p_min_i']\n            max_p_i = min(unit['p_max_i'], unit['p_start_i'])\n            min_p[i] = min_p_i\n            max_p[i] = max_p_i\n            \n    committed_set = set(forced_on)\n    total_min = sum(min_p[i] for i in forced_on)\n    total_max = sum(max_p[i] for i in forced_on)\n    \n    candidates = free_online + free_offline\n    cost_dict = {}\n    for i in candidates:\n        if i in free_online:\n            cost_per_MW = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n        else:\n            amort_period = max(1, min(2, units_info[i]['t_on_min_i']))\n            startup_amort = units_info[i]['s_i'] / amort_period\n            cost_per_MW = (units_info[i]['a_i'] + startup_amort + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n        cost_dict[i] = cost_per_MW\n        \n    amortized_cost = [(cost_dict[i], i) for i in candidates]\n    amortized_cost.sort(key=lambda x: x[0])\n    \n    skipped = []\n    for cost_val, idx in amortized_cost:\n        if total_max >= current_load:\n            break\n        if total_min + min_p[idx] > current_load:\n            skipped.append((cost_val, idx))\n            continue\n        committed_set.add(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n    \n    uncommitted = [(cost_val, idx) for cost_val, idx in amortized_cost if idx not in committed_set]\n    uncommitted += skipped\n    uncommitted.sort(key=lambda x: x[0])\n    \n    for cost_val, idx in uncommitted:\n        if total_max >= current_load:\n            break\n        committed_set.add(idx)\n        total_min += min_p[idx]\n        total_max += max_p[idx]\n        \n    free_committed = [idx for idx in committed_set if idx in free_online or idx in free_offline]\n    free_committed_sorted = sorted(free_committed, key=lambda idx: cost_dict[idx], reverse=True)\n    \n    for idx in free_committed_sorted:\n        if total_min <= current_load:\n            break\n        if total_max - max_p[idx] >= current_load:\n            committed_set.remove(idx)\n            total_min -= min_p[idx]\n            total_max -= max_p[idx]\n    \n    committed_list = list(committed_set)\n    if not committed_list:\n        return np.array([u_i, p_i])\n    \n    # Lambda iteration\n    low_l = 0.0\n    high_l = 0.0\n    for i in committed_list:\n        marginal_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_p[i]\n        marginal_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_p[i]\n        if marginal_min > low_l:\n            low_l = marginal_min\n        if marginal_max > high_l:\n            high_l = marginal_max\n    \n    if high_l == low_l:\n        high_l = low_l + 1.0\n        \n    tol = 1e-5\n    iter_max = 100\n    iter_count = 0\n    total_gen = 0.0\n    \n    while iter_count < iter_max and abs(total_gen - current_load) > tol:\n        mid_l = (low_l + high_l) / 2.0\n        total_gen = 0.0\n        for i in committed_list:\n            if units_info[i]['c_i'] == 0:\n                p_val = max_p[i] if mid_l > units_info[i]['b_i'] else min_p[i]\n            else:\n                p_uncon = (mid_l - units_info[i]['b_i']) / (2 * units_info[i]['c_i'])\n                p_val = max(min_p[i], min(max_p[i], p_uncon))\n            p_i[i] = p_val\n            total_gen += p_val\n        \n        if total_gen < current_load:\n            low_l = mid_l\n        else:\n            high_l = mid_l\n        iter_count += 1\n    \n    # Residual gap adjustment\n    gap = current_load - total_gen\n    if gap > 0:  # under-generation\n        under_units = []\n        for i in committed_list:\n            headroom = max_p[i] - p_i[i]\n            if headroom > tol:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n                under_units.append((marginal_cost, i, headroom))\n        under_units.sort(key=lambda x: x[0])\n        for mc, i, hr in under_units:\n            if gap <= tol:\n                break\n            allocation = min(gap, hr)\n            p_i[i] += allocation\n            gap -= allocation\n    elif gap < 0:  # over-generation\n        gap_abs = -gap\n        over_units = []\n        for i in committed_list:\n            headroom = p_i[i] - min_p[i]\n            if headroom > tol:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_i[i]\n                over_units.append((marginal_cost, i, headroom))\n        over_units.sort(key=lambda x: x[0], reverse=True)\n        for mc, i, hr in over_units:\n            if gap_abs <= tol:\n                break\n            allocation = min(gap_abs, hr)\n            p_i[i] -= allocation\n            gap_abs -= allocation\n    \n    # Set commitment states\n    for i in range(n_units):\n        if i in committed_set:\n            u_i[i] = 1\n        else:\n            u_i[i] = 0\n            p_i[i] = 0.0\n\n    return np.array([u_i, p_i])",
     "from": "mutation",
     "gap_power_rate": 0.0030152788,
     "gap_price_rate": 0.0092961465,
     "fitness": 0.0061557127
}