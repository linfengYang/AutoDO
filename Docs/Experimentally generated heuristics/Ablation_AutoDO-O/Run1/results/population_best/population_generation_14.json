{
     "name": "enhanced_hybrid_commitment_v4",
     "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize committed units as must-on plus free-on. Compute effective power bounds considering ramp constraints:\n   - For previously online units: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   - For units to be committed: min = p_min_i, max = min(p_max_i, p_start_i, p_up_i)\n3. If total min > load, decommission free-on units with highest operating cost per MW at min output while ensuring feasibility after removal.\n4. If total max < load, commission free-off units with lowest startup-adjusted cost per MW at min output until capacity meets or exceeds load.\n5. Perform iterative post-commission decommissioning: remove free-on units that are costly and whose removal maintains feasibility.\n6. Dispatch load to committed units:\n   - Set all to min if load \u2264 total min\n   - Set all to max if load \u2265 total max\n   - Otherwise perform \u03bb-iteration economic dispatch with bounds clamping\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
     "code": "import numpy as np\n\ndef enhanced_hybrid_commitment_v4(units_info, load):\n    current_load = load[0]\n    committed_units = []\n    uncommitted_units = []\n    \n    # Step 1: Classify units and initialize\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                unit['type'] = 'must-on'\n            else:\n                unit['type'] = 'free-on'\n        else:\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                unit['type'] = 'must-off'\n            else:\n                unit['type'] = 'free-off'\n                \n    # Step 2: Commit must-on and free-on units\n    for unit in units_info:\n        if unit['type'] in ['must-on', 'free-on']:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_i'] = min_i\n            unit['max_i'] = max_i\n            committed_units.append(unit)\n        else:\n            uncommitted_units.append(unit)\n    \n    # Calculate initial total min and max\n    total_min = sum(u['min_i'] for u in committed_units)\n    total_max = sum(u['max_i'] for u in committed_units)\n    \n    # Collect free-on units\n    free_on_units = [u for u in committed_units if u['type'] == 'free-on']\n    \n    # Step 3: Decommission if over-generating\n    while total_min > current_load and free_on_units:\n        # Sort by descending cost per MW (operating cost at min)\n        free_on_units.sort(key=lambda u: (u['a_i'] + u['b_i']*u['min_i'] + u['c_i']*u['min_i']**2) / u['min_i'], reverse=True)\n        removed = False\n        for unit in free_on_units[:]:\n            new_total_min = total_min - unit['min_i']\n            new_total_max = total_max - unit['max_i']\n            if new_total_min <= current_load <= new_total_max:\n                committed_units.remove(unit)\n                free_on_units.remove(unit)\n                total_min = new_total_min\n                total_max = new_total_max\n                removed = True\n                break\n        if not removed:\n            break\n    \n    # Step 4: Commission if under-generating\n    free_off_units = [u for u in uncommitted_units if u['type'] == 'free-off']\n    while total_max < current_load and free_off_units:\n        # Calculate costs for free-off units\n        costs = []\n        for unit in free_off_units:\n            min_i_f = unit['p_min_i']\n            max_i_f = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            unit['min_i_f'] = min_i_f\n            unit['max_i_f'] = max_i_f\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_i_f + unit['c_i']*min_i_f**2) / min_i_f\n            costs.append((cost_per_mw, unit))\n        costs.sort(key=lambda x: x[0])\n        added = False\n        for cost_per_mw, unit in costs:\n            new_total_min = total_min + unit['min_i_f']\n            new_total_max = total_max + unit['max_i_f']\n            committed_units.append(unit)\n            unit['min_i'] = unit['min_i_f']\n            unit['max_i'] = unit['max_i_f']\n            free_off_units.remove(unit)\n            total_min = new_total_min\n            total_max = new_total_max\n            added = True\n            break\n        if not added:\n            break\n    \n    # Step 5: Post-commitment decommissioning\n    free_on_units = [u for u in committed_units if u['type'] == 'free-on']\n    changed = True\n    while changed and free_on_units:\n        changed = False\n        free_on_units.sort(key=lambda u: (u['a_i'] + u['b_i']*u['min_i'] + u['c_i']*u['min_i']**2) / u['min_i'], reverse=True)\n        for unit in free_on_units[:]:\n            new_total_min = total_min - unit['min_i']\n            new_total_max = total_max - unit['max_i']\n            if new_total_min <= current_load <= new_total_max:\n                committed_units.remove(unit)\n                free_on_units.remove(unit)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 6: Dispatch\n    if abs(current_load - total_min) < 1e-5:\n        for unit in committed_units:\n            unit['p_i'] = unit['min_i']\n            unit['u_i'] = 1\n    elif abs(current_load - total_max) < 1e-5:\n        for unit in committed_units:\n            unit['p_i'] = unit['max_i']\n            unit['u_i'] = 1\n    else:\n        # Lambda iteration setup\n        low_lam = 0\n        high_lam = 1e6\n        tolerance = 1e-5\n        p_allocated = np.zeros(len(committed_units))\n        while high_lam - low_lam > tolerance:\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i, unit in enumerate(committed_units):\n                if unit['c_i'] != 0:\n                    p_i = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_i = unit['max_i'] if mid_lam > unit['b_i'] else unit['min_i']\n                p_i = max(unit['min_i'], min(unit['max_i'], p_i))\n                p_allocated[i] = p_i\n                total_p += p_i\n            if total_p < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        for i, unit in enumerate(committed_units):\n            unit['p_i'] = p_allocated[i]\n            unit['u_i'] = 1\n    \n    # Step 7: Set non-committed units\n    for unit in units_info:\n        if unit not in committed_units:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Build output array\n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    schedules = np.array([u_list, p_list])\n    return schedules",
     "from": "crossover",
     "gap_power_rate": 0.0051595866,
     "gap_price_rate": 0.008320781,
     "fitness": 0.0067401838
}