[
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (cannot be turned off), must-off (cannot be turned on), free-on (online and can be turned off), and free-off (offline and can be turned on)\n2. Commit must-run units and calculate their effective min/max outputs based on ramp constraints\n3. If total minimum output exceeds load, decommit free-on units in descending order of min output\n4. If total maximum output is below load, commit additional units from candidate list (free-on + free-off) sorted by cost per MW at minimum output\n5. Dispatch using lambda iteration to meet load exactly within generation limits\n6. For all non-committed units, set status to off and output to zero\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = set()\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        must_run_cond = (\n            u_i0 == 1 and \n            (t_i0 > 0 and t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])\n        )\n        # Must-off conditions\n        must_off_cond = (\n            u_i0 == 0 and \n            abs(t_i0) < unit['t_off_min_i']\n        )\n        \n        if must_run_cond:\n            must_run.append(i)\n            committed.add(i)\n        elif must_off_cond:\n            must_off.append(i)\n        elif u_i0 == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Compute effective min/max for must-run units\n    total_min = 0.0\n    total_max = 0.0\n    must_run_limits = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        # Compute effective limits\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        total_min += eff_min\n        total_max += eff_max\n        must_run_limits.append((i, eff_min, eff_max))\n    \n    # Candidate handling\n    candidate_list = []\n    candidate_indices = []\n    \n    # Free-on candidates\n    for i in free_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        cost_at_min = unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2)\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-on'))\n    \n    # Free-off candidates\n    for i in free_off:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        eff_min = p_min\n        eff_max = min(p_max, unit['p_start_i'])\n        cost_at_min = (unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2) + \n                       unit['s_i'])\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-off'))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Over-commitment handling\n    if total_min > current_load and free_on:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in sorted(\n            candidate_list[:len(free_on)], \n            key=lambda x: units_info[x[1]]['p_min_i'], \n            reverse=True\n        ):\n            if i in free_on:\n                if total_min - eff_min >= current_load:\n                    total_min -= eff_min\n                    total_max -= eff_max\n                else:\n                    break\n    \n    # Under-commitment handling\n    if total_max < current_load and candidate_list:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in candidate_list:\n            if unit_type == 'free-off' and i in free_off:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n            elif unit_type == 'free-on' and i in free_on:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n    \n    # Dispatch preparation\n    dispatch_list = []\n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        if u_i0 == 1:  # Was online\n            eff_min = max(p_min, p_i0 - ramp_down)\n            eff_max = min(p_max, p_i0 + ramp_up)\n        else:  # Was offline (free-off candidate)\n            eff_min = p_min\n            eff_max = min(p_max, unit['p_start_i'])\n        \n        dispatch_list.append((\n            eff_min, eff_max, \n            unit['b_i'], unit['c_i'], i\n        ))\n    \n    # Economic dispatch using lambda iteration\n    if len(dispatch_list) == 0:\n        # Default to zero for all units\n        return schedules\n    \n    # Lambda iteration setup\n    low_lambda = -1e6\n    high_lambda = 1e6\n    tol = 0.1\n    max_iter = 1000\n    p_allocations = np.zeros(len(dispatch_list))\n    \n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_gen = 0.0\n        \n        for idx, (p_min, p_max, b, c, unit_idx) in enumerate(dispatch_list):\n            if c == 0:  # Linear cost\n                if lambda_mid < b:\n                    p = p_min\n                else:\n                    p = p_max\n            else:  # Quadratic cost\n                p_ideal = (lambda_mid - b) / (2 * c)\n                p = max(p_min, min(p_ideal, p_max))\n            \n            p_allocations[idx] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    # Apply allocations to committed units\n    for (p_min, p_max, b, c, unit_idx), p_val in zip(dispatch_list, p_allocations):\n        schedules[0][unit_idx] = 1\n        schedules[1][unit_idx] = p_val\n    \n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.00544046,
          "gap_price_rate": 0.00878014,
          "fitness": 0.0071103
     },
     {
          "name": "enhanced_commitment_dispatch_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Initially commit must-on and free-on units. Compute effective power bounds for these units considering ramp constraints.\n3. If total effective minimum output exceeds load, iteratively decommit highest-cost-per-MW free-on units (prioritizing units with highest (a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) while ensuring remaining units can still meet load.\n4. If total effective maximum output is below load, iteratively commit most cost-effective free-off units (prioritizing units with lowest (s_i + a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) until generation capacity meets or exceeds load.\n5. If load falls between adjusted total minimum and maximum, decommit any expensive free-on units that can be removed while maintaining load feasibility.\n6. Dispatch power to committed units:\n   - If total min > load: set all units to minimum output (over-generation)\n   - If total max < load: set all units to maximum output (under-generation)\n   - Else: perform economic dispatch via lambda iteration to minimize variable costs while satisfying load exactly.\n7. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    \n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            online_constrained = (t_i0 > 0 and t_i0 < t_on_min) or (p_i0 > unit['p_shut_i'])\n            if online_constrained:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            offline_constrained = (t_i0 < 0 and abs(t_i0) < t_off_min)\n            if offline_constrained:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment (must-on + free-on)\n    committed = set(must_on) | set(free_on)\n    for i in committed:\n        u_current[i] = 1\n        unit = units_info[i]\n        prev_power = unit['p_i_0']\n        min_bound[i] = max(unit['p_min_i'], prev_power - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], prev_power + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed)\n    total_max = sum(max_bound[i] for i in committed)\n    \n    # Decommit free-on units if over-generation\n    if total_min > current_load:\n        changed = True\n        while changed and total_min > current_load:\n            changed = False\n            free_on_committed = [i for i in free_on if i in committed]\n            if not free_on_committed:\n                break\n                \n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_max >= current_load:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n                    changed = True\n                    break\n    \n    # Commit free-off units if under-generation\n    if total_min <= current_load and total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed]\n        if free_off_available:\n            costs, min_vals, max_vals = [], [], []\n            for i in free_off_available:\n                unit = units_info[i]\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n                s, a, b, c = unit['s_i'], unit['a_i'], unit['b_i'], unit['c_i']\n                cost = (s + a + b*min_val + c*min_val**2) / min_val\n                costs.append(cost)\n                min_vals.append(min_val)\n                max_vals.append(max_val)\n            \n            idxs_sorted = np.argsort(costs)\n            for idx in idxs_sorted:\n                i = free_off_available[idx]\n                min_val, max_val = min_vals[idx], max_vals[idx]\n                new_min = total_min + min_val\n                new_max = total_max + max_val\n                committed.add(i)\n                u_current[i] = 1\n                min_bound[i], max_bound[i] = min_val, max_val\n                total_min, total_max = new_min, new_max\n                if new_max >= current_load:\n                    break\n    \n    # Final decommitment pass for expensive free-on units\n    if total_min <= current_load <= total_max:\n        free_on_committed = [i for i in free_on if i in committed]\n        if free_on_committed:\n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_min <= current_load <= new_max:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n    \n    # Dispatch power to committed units\n    if committed:\n        if total_min > current_load:\n            for i in committed:\n                p_current[i] = min_bound[i]\n        elif total_max < current_load:\n            for i in committed:\n                p_current[i] = max_bound[i]\n        else:\n            low, high = None, None\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * min_bound[i]\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * max_bound[i]\n                low = marginal_min if low is None else min(low, marginal_min)\n                high = marginal_max if high is None else max(high, marginal_max)\n            \n            if low == high:\n                for i in committed:\n                    p_current[i] = min_bound[i]\n            else:\n                for _ in range(100):\n                    lam = (low + high) / 2\n                    total_power = 0\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] > 0:\n                            p = (lam - unit['b_i']) / (2 * unit['c_i'])\n                            p = max(min_bound[i], min(max_bound[i], p))\n                            total_power += p\n                    \n                    if abs(total_power - current_load) < 1e-5:\n                        break\n                    elif total_power < current_load:\n                        low = lam\n                    else:\n                        high = lam\n                \n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_current[i] = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_current[i] = max(min_bound[i], min(max_bound[i], p_current[i]))\n    \n    return np.array([u_current, p_current])",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "refined_enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (constrained to remain online due to min up-time or shutdown constraints), must-off (constrained to remain offline due to min down-time), free-on (online and can be turned off), free-off (offline and can be turned on).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints (previous online units: min=max(p_min, p_prev-ramp_down), max=min(p_max, p_prev+ramp_up)).\n3. Decommit free-on units: While total effective min > load, find candidate free-on units removable without violating load constraints (remaining total_min \u2264 load and total_max \u2265 load). Decommit candidate with highest cost per MW at min (a_i + b_i\u00b7min + c_i\u00b7min\u00b2)/min.\n4. Commit free-off units: While total effective max < load, commit candidate free-off unit with lowest cost per MW (startup + a_i + b_i\u00b7min + c_i\u00b7min\u00b2)/min, with effective min=p_min, max=min(p_max, p_start).\n5. Post-commitment decommitment: For committed free-on units, iteratively decommit highest cost per MW units if removal maintains total_min \u2264 load and total_max \u2265 load.\n6. Dispatch committed units:\n   - If load \u2264 total_min: set all to min outputs\n   - If load \u2265 total_max: set all to max outputs\n   - Else: perform lambda iteration economic dispatch (binary search for marginal cost)\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_dynamic_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Initialize outputs\n    u_output = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Initialize committed sets and effective bounds\n    committed = set(must_on + free_on)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Compute initial totals\n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Step 3: Decommit free-on units if total_min > load\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_candidates = free_on_committed.copy()\n    while total_min > current_load and free_on_candidates:\n        candidate_list = []\n        for i in free_on_candidates:\n            unit = units_info[i]\n            new_min = total_min - eff_min[i]\n            new_max = total_max - eff_max[i]\n            if new_min <= current_load and new_max >= current_load:\n                cost_at_min = unit['a_i'] + unit['b_i']*eff_min[i] + unit['c_i']*(eff_min[i]**2)\n                cost_per_mw = cost_at_min / eff_min[i]\n                candidate_list.append((i, cost_per_mw))\n        if not candidate_list:\n            break\n        candidate_list.sort(key=lambda x: x[1], reverse=True)\n        best_candidate, _ = candidate_list[0]\n        total_min -= eff_min[best_candidate]\n        total_max -= eff_max[best_candidate]\n        committed.remove(best_candidate)\n        free_on_candidates.remove(best_candidate)\n    \n    # Step 4: Commit free-off units if total_max < load\n    while total_max < current_load and free_off:\n        candidate_list = []\n        for i in free_off:\n            unit = units_info[i]\n            eff_min_i = unit['p_min_i']\n            eff_max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_at_min = unit['s_i'] + unit['a_i'] + unit['b_i']*eff_min_i + unit['c_i']*(eff_min_i**2)\n            cost_per_mw = cost_at_min / eff_min_i\n            candidate_list.append((i, cost_per_mw, eff_min_i, eff_max_i))\n        candidate_list.sort(key=lambda x: x[1])\n        best_candidate = candidate_list[0][0]\n        eff_min[best_candidate] = candidate_list[0][2]\n        eff_max[best_candidate] = candidate_list[0][3]\n        total_min += eff_min[best_candidate]\n        total_max += eff_max[best_candidate]\n        committed.add(best_candidate)\n        free_off.remove(best_candidate)\n    \n    # Step 5: Post-commitment decommitment (expensive free-on units)\n    free_on_committed = [i for i in free_on if i in committed]\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        candidate_list = []\n        for i in free_on_committed:\n            new_min = total_min - eff_min[i]\n            new_max = total_max - eff_max[i]\n            if new_min <= current_load and new_max >= current_load:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i']*eff_min[i] + unit['c_i']*(eff_min[i]**2)\n                cost_per_mw = cost_at_min / eff_min[i]\n                candidate_list.append((i, cost_per_mw))\n        if not candidate_list:\n            break\n        candidate_list.sort(key=lambda x: x[1], reverse=True)\n        best_candidate, _ = candidate_list[0]\n        total_min -= eff_min[best_candidate]\n        total_max -= eff_max[best_candidate]\n        committed.remove(best_candidate)\n        free_on_committed.remove(best_candidate)\n        changed = True\n    \n    # Step 6: Dispatch\n    for i in committed:\n        p_output[i] = eff_min[i]  # Default to min\n        \n    if current_load <= total_min:\n        # Already set to min outputs\n        pass\n    elif current_load >= total_max:\n        for i in committed:\n            p_output[i] = eff_max[i]\n    else:\n        # Lambda iteration economic dispatch\n        lambda_low = min(2 * units_info[i]['c_i'] * eff_min[i] + units_info[i]['b_i'] for i in committed)\n        lambda_high = max(2 * units_info[i]['c_i'] * eff_max[i] + units_info[i]['b_i'] for i in committed)\n        tol, max_iter, iter_count = 0.001, 1000, 0\n        while iter_count < max_iter:\n            mid = (lambda_low + lambda_high) / 2\n            total_p = 0.0\n            for i in committed:\n                unit = units_info[i]\n                p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(eff_min[i], min(p_val, eff_max[i]))\n                p_output[i] = p_val\n                total_p += p_val\n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                lambda_low = mid\n            else:\n                lambda_high = mid\n            iter_count += 1\n            \n    # Step 7: Set non-committed units\n    for i in committed:\n        u_output[i] = 1\n        \n    return np.array([u_output, p_output])",
          "from": "mutation",
          "gap_power_rate": 0.005428635,
          "gap_price_rate": 0.0091401619,
          "fitness": 0.0072843984
     },
     {
          "name": "refined_hybrid_commitment_v2",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup)\n2. Commit must-on and free-on units initially\n3. Calculate effective power limits considering ramp constraints and startup/shutdown limitations\n4. Turn off eligible free-on units with the highest cost per MW if their decommitment doesn't jeopardize system reliability\n5. Commit available free-off units with the most economical cost per MW\n6. Initialize dispatch at prior outputs (clamped within bounds) for units that were online\n7. Perform economic dispatch using lambda iteration for committed units\n8. Set output to 0 for non-committed units\n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v2(units_info, load):\n    # Unpack current load\n    current_load = load[0]\n    \n    # Initialize output arrays\n    u_out = np.zeros(len(units_info))\n    p_out = np.zeros(len(units_info))\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Was online\n            # Determine online constraints\n            min_up_unsatisfied = t0 < unit['t_on_min_i'] and t0 >= 0\n            shutdown_limited = p0 > unit['p_shut_i']\n            if min_up_unsatisfied or shutdown_limited:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Was offline\n            min_down_unsatisfied = abs(t0) < unit['t_off_min_i'] and t0 <= 0\n            if min_down_unsatisfied:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on).union(free_on)\n    pending_free_on = free_on.copy()\n    pending_free_off = free_off.copy()\n    \n    # Calculate effective min/max for each unit\n    eff_min, eff_max = {}, {}\n    for i in range(len(units_info)):\n        unit = units_info[i]\n        p0, u0 = unit['p_i_0'], unit['u_i_0']\n        \n        if u0 == 1:  # Online last period\n            # For units that were online\n            eff_min[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline last period\n            # For units newly started\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit high-cost free-on units\n    total_min, total_max = 0, 0\n    for i in committed:\n        total_min += eff_min.get(i, 0)\n        total_max += eff_max.get(i, 0)\n    \n    # Sort free-on by cost per MW at min output (descending)\n    free_on_candidates = []\n    for i in pending_free_on:\n        unit = units_info[i]\n        cost = (unit['a_i'] + unit['b_i'] * eff_min[i] + \n                unit['c_i'] * eff_min[i] ** 2)\n        unit_cost_per_mw = cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        free_on_candidates.append((unit_cost_per_mw, i))\n    \n    free_on_candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    for _, i in free_on_candidates:\n        if total_min - eff_min[i] < current_load <= total_max - eff_min[i]:\n            committed.remove(i)\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            pending_free_on.remove(i)\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Commit economical free-off units\n    free_off_candidates = []\n    for i in pending_free_off:\n        unit = units_info[i]\n        min_cost = (unit['a_i'] + unit['s_i'] + unit['b_i'] * eff_min[i] + \n                   unit['c_i'] * eff_min[i] ** 2)\n        unit_cost_per_mw = min_cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        free_off_candidates.append((unit_cost_per_mw, i))\n    \n    free_off_candidates.sort(key=lambda x: x[0])\n    \n    for _, i in free_off_candidates:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += eff_min[i]\n            total_max += eff_max[i]\n            pending_free_off.remove(i)\n    \n    # Step 6: Initialize dispatch at prior outputs (clamped within bounds)\n    active_units = []\n    init_dispatch = 0\n    for i in committed:\n        unit = units_info[i]\n        # Clamp prior output to feasible range\n        prev_online = unit['u_i_0'] == 1\n        if prev_online:\n            p_initial = max(eff_min[i], min(eff_max[i], unit['p_i_0']))\n        else:\n            p_initial = eff_min[i]\n        active_units.append((i, eff_min[i], eff_max[i], p_initial))\n        init_dispatch += p_initial\n    \n    # Step 7: Perform economic dispatch via lambda iteration\n    remaining_load = current_load - init_dispatch\n    if abs(remaining_load) < 1e-6:\n        # Initial dispatch perfectly meets load\n        for i, _, _, p_initial in active_units:\n            p_out[i] = p_initial\n            u_out[i] = 1\n    else:\n        # Dispatch only if remaining load is significant\n        min_lambda = 0\n        max_lambda = 10000  # Set high initial value\n        \n        # Find lambda via binary search\n        lambda_val = (min_lambda + max_lambda) / 2\n        tolerance = 0.1\n        iterations = 0\n        \n        while True:\n            iterations += 1\n            total_gen = 0\n            for idx, min_p, max_p, _ in active_units:\n                unit = units_info[idx]\n                # Calculate desired output for current lambda\n                if unit['c_i'] > 0:\n                    desired_p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Linear cost function\n                    desired_p = max_p if lambda_val > unit['b_i'] else min_p\n                \n                # Clamp to physical limits\n                clamped_p = max(min_p, min(max_p, desired_p))\n                total_gen += clamped_p\n                # Store temporary output\n                p_out[idx] = clamped_p\n            \n            error = total_gen - (init_dispatch + remaining_load)\n            \n            if abs(error) < tolerance or iterations > 100:\n                break\n            elif error > 0:  # Generated too much\n                max_lambda = lambda_val\n            else:  # Generated too little\n                min_lambda = lambda_val\n                \n            lambda_val = (min_lambda + max_lambda) / 2\n        \n        # Set final outputs\n        for idx, _, _, _ in active_units:\n            u_out[idx] = 1\n    \n    # Finalize output for non-committed units\n    for i in set(range(len(units_info))) - committed:\n        u_out[i] = 0\n        p_out[i] = 0  # Ensure output is 0\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0004363508,
          "gap_price_rate": 0.0159271483,
          "fitness": 0.0081817495
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    category_list = []\n    for unit in units_info:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                category_list.append('must_on')\n            else:\n                category_list.append('free_on')\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                category_list.append('must_off')\n            else:\n                category_list.append('free_off')\n    \n    u = [1 if cat in ['must_on', 'free_on'] else 0 for cat in category_list]\n    min_p_arr = [0] * n_units\n    max_p_arr = [0] * n_units\n    \n    def compute_bounds(i, committed):\n        unit = units_info[i]\n        if committed:\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p, max_p = 0, 0\n        return min_p, max_p\n\n    for i in range(n_units):\n        min_p_arr[i], max_p_arr[i] = compute_bounds(i, u[i])\n    \n    total_min = sum(min_p_arr)\n    total_max = sum(max_p_arr)\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    free_off_avail = [i for i, cat in enumerate(category_list) if cat == 'free_off' and u[i] == 0]\n    candidate_costs = []\n    for i in free_off_avail:\n        unit = units_info[i]\n        min_p = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        cost_per_MW = total_cost / min_p if min_p > 0 else float('inf')\n        candidate_costs.append((i, cost_per_MW))\n    candidate_costs.sort(key=lambda x: x[1])\n    \n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        if u[i] == 0:\n            u[i] = 1\n            min_p_val, max_p_val = compute_bounds(i, True)\n            min_p_arr[i] = min_p_val\n            max_p_arr[i] = max_p_val\n            total_min += min_p_val\n            total_max += max_p_val\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    p_alloc = [min_p_arr[i] if u[i] == 1 else 0 for i in range(n_units)]\n    remaining = current_load - sum(p_alloc)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    while remaining > 1e-6:\n        candidate = -1\n        min_mc = float('inf')\n        for i in committed_indices:\n            if p_alloc[i] < max_p_arr[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n        if candidate == -1:\n            break\n        delta = min(remaining, max_p_arr[candidate] - p_alloc[candidate])\n        p_alloc[candidate] += delta\n        remaining -= delta\n    \n    return np.array([u, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and eligible for shutdown), and free-off (offline and eligible for startup).\n2. Commit must-on and free-on units initially. Calculate effective power bounds considering ramp constraints: for previously online units, min = max(p_min, p_prev - ramp_down) and max = min(p_max, p_prev + ramp_up); for newly committed units, max = min(p_max, p_start) with min = p_min.\n3. If total maximum capacity < load, commit free-off units sorted by ascending (startup_cost + cost_at_min_output)/min_output until sufficient capacity is achieved.\n4. If total minimum capacity > load, decommit free-on units with highest cost/MW at min output, ensuring remaining maximum capacity \u2265 load.\n5. Dispatch load to committed units:\n   - Set outputs to min if load \u2264 total min\n   - Set outputs to max if load \u2265 total max\n   - Otherwise perform economic dispatch via binary search for marginal cost (lambda) using derivative of cost functions, with outputs clamped to effective bounds.\n6. Set non-committed units to off (0 output).\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed_units = []\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # online previously\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # offline previously\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize committed units and compute bounds\n    committed_units = must_on + free_on\n    min_bounds = {}\n    max_bounds = {}\n    for i in must_on + free_on:\n        unit = units_info[i]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n    \n    # Step 3: Commit additional free-off units if needed\n    total_min = sum(min_bounds[i] for i in committed_units)\n    total_max = sum(max_bounds[i] for i in committed_units)\n    \n    free_off_sorted = sorted(\n        free_off,\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                       units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i']\n    )\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        min_candidate = unit['p_min_i']\n        max_candidate = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_candidate\n        max_bounds[i] = max_candidate\n        committed_units.append(i)\n        total_min += min_candidate\n        total_max += max_candidate\n    \n    # Step 4: Decommit free-on units if over minimum capacity\n    free_on_in_committed = [i for i in committed_units if i in free_on]\n    free_on_in_committed.sort(\n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_bounds[i] + \n                       units_info[i]['c_i'] * min_bounds[i]**2) / min_bounds[i],\n        reverse=True\n    )\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        new_total_max = total_max - max_bounds[i]\n        if new_total_max < current_load:\n            continue\n        committed_units.remove(i)\n        total_min -= min_bounds[i]\n        total_max -= max_bounds[i]\n        if total_min <= current_load:\n            break\n    \n    # Step 5: Dispatch load\n    total_min = sum(min_bounds[i] for i in committed_units)\n    total_max = sum(max_bounds[i] for i in committed_units)\n    \n    for i in committed_units:\n        u_out[i] = 1\n        if current_load <= total_min:\n            p_out[i] = min_bounds[i]\n        elif current_load >= total_max:\n            p_out[i] = max_bounds[i]\n    \n    # Economic dispatch when load between min and max\n    if total_min < current_load < total_max:\n        low_lambda = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_bounds[i] for i in committed_units)\n        high_lambda = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_bounds[i] for i in committed_units)\n        \n        for _ in range(100):  # Binary search for lambda\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_gen = 0\n            for i in committed_units:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    p = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Linear cost\n                    p = max_bounds[i] if mid_lambda >= unit['b_i'] else min_bounds[i]\n                p = max(min_bounds[i], min(max_bounds[i], p))\n                total_gen += p\n                \n            if total_gen < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Final assignment with converged lambda\n        mid_lambda = (low_lambda + high_lambda) / 2\n        for i in committed_units:\n            unit = units_info[i]\n            if unit['c_i'] > 0:\n                p = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n            else:  # Linear cost\n                p = max_bounds[i] if mid_lambda >= unit['b_i'] else min_bounds[i]\n            p_out[i] = max(min_bounds[i], min(max_bounds[i], p))\n    \n    # Return results as 2D numpy array\n    return np.array([u_out, p_out], dtype=float)",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0360463335,
          "fitness": 0.018088006
     },
     {
          "name": "enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints and startup/shutdown limitations.\n3. While total effective min > load and eligible free-on units exist: \n   - Decommit free-on units with largest effective min output (if remaining capacity can still meet load)\n4. While total effective max < load and free-off units exist:\n   - Commit free-off units with lowest average cost per MW (startup cost + min-output cost / min output)\n5. If total min > load: set committed units to effective min\n6. Elif total max < load: set committed units to effective max\n7. Else: perform economic dispatch using lambda iteration:\n   - Initialize outputs at effective min\n   - Binary search for lambda (marginal cost) until generation matches load\n   - For each unit: clamp output to effective min/max using quadratic/linear dispatch logic\n8. Return final commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters to arrays\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    \n    # Classification\n    must_on = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    free_on = np.zeros(n_units, dtype=bool)\n    free_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:  # previously online\n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:  # previously offline\n            if -t_i_0[i] < t_off_min[i]:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    # Initial commitment\n    committed = must_on.copy() | free_on.copy()\n    must_off_mask = must_off.copy()\n    committed[must_off_mask] = False\n    \n    # Effective power limits\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1 and committed[i]:\n            eff_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n            eff_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n        elif free_off[i] or (u_i_0[i] == 0 and committed[i]):\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], p_start[i])\n    \n    # Over-commitment handling\n    total_min = np.sum(eff_min[committed])\n    total_max = np.sum(eff_max[committed])\n    \n    if total_min > current_load:\n        free_on_indices = np.where(free_on & committed)[0]\n        if len(free_on_indices) > 0:\n            # Sort by descending effective min\n            sorted_indices = sorted(free_on_indices, key=lambda i: eff_min[i], reverse=True)\n            for idx in sorted_indices:\n                if total_max - eff_max[idx] >= current_load:\n                    committed[idx] = False\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    if total_min <= current_load:\n                        break\n    \n    # Under-commitment handling\n    if total_max < current_load:\n        free_off_indices = np.where(free_off & ~committed & ~must_off_mask)[0]\n        if len(free_off_indices) > 0:\n            # Calculate cost metric: (startup cost + min-output cost) / min output\n            min_cost = a[free_off_indices] + b[free_off_indices] * eff_min[free_off_indices] + \\\n                       c[free_off_indices] * eff_min[free_off_indices]**2\n            cost_metric = (s[free_off_indices] + min_cost) / eff_min[free_off_indices]\n            sorted_indices = [x for _, x in sorted(zip(cost_metric, free_off_indices), key=lambda pair: pair[0])]\n            for idx in sorted_indices:\n                committed[idx] = True\n                total_min += eff_min[idx]\n                total_max += eff_max[idx]\n                if total_max >= current_load:\n                    break\n    \n    # Update limits for final committed set\n    final_eff_min = eff_min.copy()\n    final_eff_max = eff_max.copy()\n    for i in range(n_units):\n        if committed[i] and u_i_0[i] == 0:  # newly started\n            final_eff_min[i] = p_min[i]\n            final_eff_max[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(final_eff_min[committed])\n    total_max = np.sum(final_eff_max[committed])\n    \n    # Dispatch\n    p_out = np.zeros(n_units)\n    if total_min > current_load:\n        p_out[committed] = final_eff_min[committed]\n    elif total_max < current_load:\n        p_out[committed] = final_eff_max[committed]\n    else:\n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        iter_count = 0\n        lam_low = 0\n        lam_high = np.max(b[committed] + 2 * c[committed] * final_eff_max[committed] * (c[committed] > 0) + \n                         b[committed] * (c[committed] == 0))\n        lam = (lam_low + lam_high) / 2\n        p_committed = final_eff_min[committed].copy()\n        \n        while iter_count < max_iter:\n            # Calculate outputs\n            for idx, i in enumerate(np.where(committed)[0]):\n                if c[i] > 0:\n                    desired = (lam - b[i]) / (2 * c[i])\n                    p_committed[idx] = np.clip(desired, final_eff_min[i], final_eff_max[i])\n                else:\n                    if lam < b[i]:\n                        p_committed[idx] = final_eff_min[i]\n                    else:\n                        p_committed[idx] = final_eff_max[i]\n            \n            total_p = np.sum(p_committed)\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n                \n            lam = (lam_low + lam_high) / 2\n            iter_count += 1\n        \n        p_out[committed] = p_committed\n    \n    u_out = committed.astype(int)\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0001296798,
          "gap_price_rate": 0.0360463335,
          "fitness": 0.0180880066
     },
     {
          "name": "enhanced_min_startup_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (constrained by min up-time/shutdown ramp), must-off (constrained by min down-time), free-on (online and decommittable), free-off (offline and committable).\n2. Commit must-run and free-on units. Calculate effective power limits considering ramp constraints: min = max(p_min, p_prev - ramp_down), max = min(p_max, p_prev + ramp_up).\n3. While over-generation (total min > load) exists and free-on units available: decommit highest cost/MW units without compromising feasibility.\n4. While under-generation (total max < load) exists and free-off units available: commit units with lowest (startup_cost + cost_at_min)/min_output.\n5. For final committed set: set outputs to minimum if load \u2264 total min, to maximum if load \u2265 total max; otherwise perform economic dispatch via lambda iteration.\n6. Set non-committed units to off with zero output.\n\n",
          "code": "import numpy as np\n\ndef enhanced_min_startup_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        shut_ramp = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if (t0 >= 0 and t0 < min_up) or p0 > shut_ramp:\n                must_run.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if t0 <= 0 and abs(t0) < min_down:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = set(must_run + free_on)\n    min_limits = {}\n    max_limits = {}\n    total_min = 0.0\n    total_max = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        min_lim = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_lim = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_limits[i] = min_lim\n        max_limits[i] = max_lim\n        total_min += min_lim\n        total_max += max_lim\n    \n    # Decommit high-cost free-on units for over-generation\n    free_on_remaining = free_on.copy()\n    if free_on_remaining:\n        cost_per_mw = {}\n        for i in free_on_remaining:\n            unit = units_info[i]\n            min_val = min_limits[i]\n            cost_val = unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * (min_val ** 2)\n            cost_per_mw[i] = cost_val / min_val\n        \n        while total_min > current_load and free_on_remaining:\n            free_on_remaining_sorted = sorted(free_on_remaining, key=lambda i: cost_per_mw[i], reverse=True)\n            for candidate in free_on_remaining_sorted:\n                if total_max - max_limits[candidate] >= current_load:\n                    committed.remove(candidate)\n                    free_on_remaining.remove(candidate)\n                    total_min -= min_limits[candidate]\n                    total_max -= max_limits[candidate]\n                    del min_limits[candidate]\n                    del max_limits[candidate]\n                    break\n            else:\n                break\n    \n    # Commit cost-effective free-off units for under-generation\n    free_off_remaining = free_off.copy()\n    if free_off_remaining:\n        cost_per_mw_startup = {}\n        for i in free_off_remaining:\n            unit = units_info[i]\n            min_val = unit['p_min_i']\n            startup_cost = unit['s_i']\n            cost_at_min = unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * (min_val ** 2)\n            cost_per_mw_startup[i] = (startup_cost + cost_at_min) / min_val\n        \n        while total_max < current_load and free_off_remaining:\n            free_off_remaining_sorted = sorted(free_off_remaining, key=lambda i: cost_per_mw_startup[i])\n            candidate = free_off_remaining_sorted[0]\n            min_val = units_info[candidate]['p_min_i']\n            max_val = min(units_info[candidate]['p_max_i'], units_info[candidate]['p_start_i'])\n            min_limits[candidate] = min_val\n            max_limits[candidate] = max_val\n            committed.add(candidate)\n            free_off_remaining.remove(candidate)\n            total_min += min_val\n            total_max += max_val\n    \n    # Recompute total limits considering adjustments\n    total_min = sum(min_limits[i] for i in committed)\n    total_max = sum(max_limits[i] for i in committed)\n    output_vals = np.zeros(num_units)\n    u_state = np.zeros(num_units)\n    \n    if committed:\n        if current_load <= total_min:\n            for i in committed:\n                output_vals[i] = min_limits[i]\n                u_state[i] = 1\n        elif current_load >= total_max:\n            for i in committed:\n                output_vals[i] = max_limits[i]\n                u_state[i] = 1\n        else:\n            low_lambda = 0.0\n            high_lambda = 0.0\n            for i in committed:\n                unit = units_info[i]\n                low_val = unit['b_i'] + 2 * unit['c_i'] * min_limits[i]\n                high_val = unit['b_i'] + 2 * unit['c_i'] * max_limits[i]\n                if low_val < low_lambda or not low_lambda:\n                    low_lambda = low_val\n                if high_val > high_lambda:\n                    high_lambda = high_val\n                    \n            tolerance = 1e-5\n            max_iter = 1000\n            for _ in range(max_iter):\n                mid_lambda = (low_lambda + high_lambda) / 2\n                total_p = 0.0\n                for i in committed:\n                    unit = units_info[i]\n                    p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(min_limits[i], min(p_i, max_limits[i]))\n                    total_p += p_i\n                if abs(total_p - current_load) < tolerance:\n                    break\n                if total_p < current_load:\n                    low_lambda = mid_lambda\n                else:\n                    high_lambda = mid_lambda\n            \n            for i in committed:\n                unit = units_info[i]\n                p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                output_vals[i] = max(min_limits[i], min(p_i, max_limits[i]))\n                u_state[i] = 1\n    \n    schedules = np.vstack((u_state, output_vals))\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001296798,
          "gap_price_rate": 0.0360463337,
          "fitness": 0.0180880068
     }
]