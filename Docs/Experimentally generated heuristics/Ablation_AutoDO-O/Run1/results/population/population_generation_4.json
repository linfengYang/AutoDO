[
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (cannot be turned off), must-off (cannot be turned on), free-on (online and can be turned off), and free-off (offline and can be turned on)\n2. Commit must-run units and calculate their effective min/max outputs based on ramp constraints\n3. If total minimum output exceeds load, decommit free-on units in descending order of min output\n4. If total maximum output is below load, commit additional units from candidate list (free-on + free-off) sorted by cost per MW at minimum output\n5. Dispatch using lambda iteration to meet load exactly within generation limits\n6. For all non-committed units, set status to off and output to zero\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = set()\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        must_run_cond = (\n            u_i0 == 1 and \n            (t_i0 > 0 and t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])\n        )\n        # Must-off conditions\n        must_off_cond = (\n            u_i0 == 0 and \n            abs(t_i0) < unit['t_off_min_i']\n        )\n        \n        if must_run_cond:\n            must_run.append(i)\n            committed.add(i)\n        elif must_off_cond:\n            must_off.append(i)\n        elif u_i0 == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Compute effective min/max for must-run units\n    total_min = 0.0\n    total_max = 0.0\n    must_run_limits = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        # Compute effective limits\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        total_min += eff_min\n        total_max += eff_max\n        must_run_limits.append((i, eff_min, eff_max))\n    \n    # Candidate handling\n    candidate_list = []\n    candidate_indices = []\n    \n    # Free-on candidates\n    for i in free_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        cost_at_min = unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2)\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-on'))\n    \n    # Free-off candidates\n    for i in free_off:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        eff_min = p_min\n        eff_max = min(p_max, unit['p_start_i'])\n        cost_at_min = (unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2) + \n                       unit['s_i'])\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-off'))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Over-commitment handling\n    if total_min > current_load and free_on:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in sorted(\n            candidate_list[:len(free_on)], \n            key=lambda x: units_info[x[1]]['p_min_i'], \n            reverse=True\n        ):\n            if i in free_on:\n                if total_min - eff_min >= current_load:\n                    total_min -= eff_min\n                    total_max -= eff_max\n                else:\n                    break\n    \n    # Under-commitment handling\n    if total_max < current_load and candidate_list:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in candidate_list:\n            if unit_type == 'free-off' and i in free_off:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n            elif unit_type == 'free-on' and i in free_on:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n    \n    # Dispatch preparation\n    dispatch_list = []\n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        if u_i0 == 1:  # Was online\n            eff_min = max(p_min, p_i0 - ramp_down)\n            eff_max = min(p_max, p_i0 + ramp_up)\n        else:  # Was offline (free-off candidate)\n            eff_min = p_min\n            eff_max = min(p_max, unit['p_start_i'])\n        \n        dispatch_list.append((\n            eff_min, eff_max, \n            unit['b_i'], unit['c_i'], i\n        ))\n    \n    # Economic dispatch using lambda iteration\n    if len(dispatch_list) == 0:\n        # Default to zero for all units\n        return schedules\n    \n    # Lambda iteration setup\n    low_lambda = -1e6\n    high_lambda = 1e6\n    tol = 0.1\n    max_iter = 1000\n    p_allocations = np.zeros(len(dispatch_list))\n    \n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_gen = 0.0\n        \n        for idx, (p_min, p_max, b, c, unit_idx) in enumerate(dispatch_list):\n            if c == 0:  # Linear cost\n                if lambda_mid < b:\n                    p = p_min\n                else:\n                    p = p_max\n            else:  # Quadratic cost\n                p_ideal = (lambda_mid - b) / (2 * c)\n                p = max(p_min, min(p_ideal, p_max))\n            \n            p_allocations[idx] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    # Apply allocations to committed units\n    for (p_min, p_max, b, c, unit_idx), p_val in zip(dispatch_list, p_allocations):\n        schedules[0][unit_idx] = 1\n        schedules[1][unit_idx] = p_val\n    \n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.00544046,
          "gap_price_rate": 0.00878014,
          "fitness": 0.0071103
     },
     {
          "name": "enhanced_commitment_dispatch_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Initially commit must-on and free-on units. Compute effective power bounds for these units considering ramp constraints.\n3. If total effective minimum output exceeds load, iteratively decommit highest-cost-per-MW free-on units (prioritizing units with highest (a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) while ensuring remaining units can still meet load.\n4. If total effective maximum output is below load, iteratively commit most cost-effective free-off units (prioritizing units with lowest (s_i + a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) until generation capacity meets or exceeds load.\n5. If load falls between adjusted total minimum and maximum, decommit any expensive free-on units that can be removed while maintaining load feasibility.\n6. Dispatch power to committed units:\n   - If total min > load: set all units to minimum output (over-generation)\n   - If total max < load: set all units to maximum output (under-generation)\n   - Else: perform economic dispatch via lambda iteration to minimize variable costs while satisfying load exactly.\n7. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    \n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            online_constrained = (t_i0 > 0 and t_i0 < t_on_min) or (p_i0 > unit['p_shut_i'])\n            if online_constrained:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            offline_constrained = (t_i0 < 0 and abs(t_i0) < t_off_min)\n            if offline_constrained:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment (must-on + free-on)\n    committed = set(must_on) | set(free_on)\n    for i in committed:\n        u_current[i] = 1\n        unit = units_info[i]\n        prev_power = unit['p_i_0']\n        min_bound[i] = max(unit['p_min_i'], prev_power - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], prev_power + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed)\n    total_max = sum(max_bound[i] for i in committed)\n    \n    # Decommit free-on units if over-generation\n    if total_min > current_load:\n        changed = True\n        while changed and total_min > current_load:\n            changed = False\n            free_on_committed = [i for i in free_on if i in committed]\n            if not free_on_committed:\n                break\n                \n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_max >= current_load:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n                    changed = True\n                    break\n    \n    # Commit free-off units if under-generation\n    if total_min <= current_load and total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed]\n        if free_off_available:\n            costs, min_vals, max_vals = [], [], []\n            for i in free_off_available:\n                unit = units_info[i]\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n                s, a, b, c = unit['s_i'], unit['a_i'], unit['b_i'], unit['c_i']\n                cost = (s + a + b*min_val + c*min_val**2) / min_val\n                costs.append(cost)\n                min_vals.append(min_val)\n                max_vals.append(max_val)\n            \n            idxs_sorted = np.argsort(costs)\n            for idx in idxs_sorted:\n                i = free_off_available[idx]\n                min_val, max_val = min_vals[idx], max_vals[idx]\n                new_min = total_min + min_val\n                new_max = total_max + max_val\n                committed.add(i)\n                u_current[i] = 1\n                min_bound[i], max_bound[i] = min_val, max_val\n                total_min, total_max = new_min, new_max\n                if new_max >= current_load:\n                    break\n    \n    # Final decommitment pass for expensive free-on units\n    if total_min <= current_load <= total_max:\n        free_on_committed = [i for i in free_on if i in committed]\n        if free_on_committed:\n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_min <= current_load <= new_max:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n    \n    # Dispatch power to committed units\n    if committed:\n        if total_min > current_load:\n            for i in committed:\n                p_current[i] = min_bound[i]\n        elif total_max < current_load:\n            for i in committed:\n                p_current[i] = max_bound[i]\n        else:\n            low, high = None, None\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * min_bound[i]\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * max_bound[i]\n                low = marginal_min if low is None else min(low, marginal_min)\n                high = marginal_max if high is None else max(high, marginal_max)\n            \n            if low == high:\n                for i in committed:\n                    p_current[i] = min_bound[i]\n            else:\n                for _ in range(100):\n                    lam = (low + high) / 2\n                    total_power = 0\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] > 0:\n                            p = (lam - unit['b_i']) / (2 * unit['c_i'])\n                            p = max(min_bound[i], min(max_bound[i], p))\n                            total_power += p\n                    \n                    if abs(total_power - current_load) < 1e-5:\n                        break\n                    elif total_power < current_load:\n                        low = lam\n                    else:\n                        high = lam\n                \n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_current[i] = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_current[i] = max(min_bound[i], min(max_bound[i], p_current[i]))\n    \n    return np.array([u_current, p_current])",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "refined_hybrid_commitment_v2",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup)\n2. Commit must-on and free-on units initially\n3. Calculate effective power limits considering ramp constraints and startup/shutdown limitations\n4. Turn off eligible free-on units with the highest cost per MW if their decommitment doesn't jeopardize system reliability\n5. Commit available free-off units with the most economical cost per MW\n6. Initialize dispatch at prior outputs (clamped within bounds) for units that were online\n7. Perform economic dispatch using lambda iteration for committed units\n8. Set output to 0 for non-committed units\n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v2(units_info, load):\n    # Unpack current load\n    current_load = load[0]\n    \n    # Initialize output arrays\n    u_out = np.zeros(len(units_info))\n    p_out = np.zeros(len(units_info))\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Was online\n            # Determine online constraints\n            min_up_unsatisfied = t0 < unit['t_on_min_i'] and t0 >= 0\n            shutdown_limited = p0 > unit['p_shut_i']\n            if min_up_unsatisfied or shutdown_limited:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Was offline\n            min_down_unsatisfied = abs(t0) < unit['t_off_min_i'] and t0 <= 0\n            if min_down_unsatisfied:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on).union(free_on)\n    pending_free_on = free_on.copy()\n    pending_free_off = free_off.copy()\n    \n    # Calculate effective min/max for each unit\n    eff_min, eff_max = {}, {}\n    for i in range(len(units_info)):\n        unit = units_info[i]\n        p0, u0 = unit['p_i_0'], unit['u_i_0']\n        \n        if u0 == 1:  # Online last period\n            # For units that were online\n            eff_min[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline last period\n            # For units newly started\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit high-cost free-on units\n    total_min, total_max = 0, 0\n    for i in committed:\n        total_min += eff_min.get(i, 0)\n        total_max += eff_max.get(i, 0)\n    \n    # Sort free-on by cost per MW at min output (descending)\n    free_on_candidates = []\n    for i in pending_free_on:\n        unit = units_info[i]\n        cost = (unit['a_i'] + unit['b_i'] * eff_min[i] + \n                unit['c_i'] * eff_min[i] ** 2)\n        unit_cost_per_mw = cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        free_on_candidates.append((unit_cost_per_mw, i))\n    \n    free_on_candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    for _, i in free_on_candidates:\n        if total_min - eff_min[i] < current_load <= total_max - eff_min[i]:\n            committed.remove(i)\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            pending_free_on.remove(i)\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Commit economical free-off units\n    free_off_candidates = []\n    for i in pending_free_off:\n        unit = units_info[i]\n        min_cost = (unit['a_i'] + unit['s_i'] + unit['b_i'] * eff_min[i] + \n                   unit['c_i'] * eff_min[i] ** 2)\n        unit_cost_per_mw = min_cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        free_off_candidates.append((unit_cost_per_mw, i))\n    \n    free_off_candidates.sort(key=lambda x: x[0])\n    \n    for _, i in free_off_candidates:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += eff_min[i]\n            total_max += eff_max[i]\n            pending_free_off.remove(i)\n    \n    # Step 6: Initialize dispatch at prior outputs (clamped within bounds)\n    active_units = []\n    init_dispatch = 0\n    for i in committed:\n        unit = units_info[i]\n        # Clamp prior output to feasible range\n        prev_online = unit['u_i_0'] == 1\n        if prev_online:\n            p_initial = max(eff_min[i], min(eff_max[i], unit['p_i_0']))\n        else:\n            p_initial = eff_min[i]\n        active_units.append((i, eff_min[i], eff_max[i], p_initial))\n        init_dispatch += p_initial\n    \n    # Step 7: Perform economic dispatch via lambda iteration\n    remaining_load = current_load - init_dispatch\n    if abs(remaining_load) < 1e-6:\n        # Initial dispatch perfectly meets load\n        for i, _, _, p_initial in active_units:\n            p_out[i] = p_initial\n            u_out[i] = 1\n    else:\n        # Dispatch only if remaining load is significant\n        min_lambda = 0\n        max_lambda = 10000  # Set high initial value\n        \n        # Find lambda via binary search\n        lambda_val = (min_lambda + max_lambda) / 2\n        tolerance = 0.1\n        iterations = 0\n        \n        while True:\n            iterations += 1\n            total_gen = 0\n            for idx, min_p, max_p, _ in active_units:\n                unit = units_info[idx]\n                # Calculate desired output for current lambda\n                if unit['c_i'] > 0:\n                    desired_p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Linear cost function\n                    desired_p = max_p if lambda_val > unit['b_i'] else min_p\n                \n                # Clamp to physical limits\n                clamped_p = max(min_p, min(max_p, desired_p))\n                total_gen += clamped_p\n                # Store temporary output\n                p_out[idx] = clamped_p\n            \n            error = total_gen - (init_dispatch + remaining_load)\n            \n            if abs(error) < tolerance or iterations > 100:\n                break\n            elif error > 0:  # Generated too much\n                max_lambda = lambda_val\n            else:  # Generated too little\n                min_lambda = lambda_val\n                \n            lambda_val = (min_lambda + max_lambda) / 2\n        \n        # Set final outputs\n        for idx, _, _, _ in active_units:\n            u_out[idx] = 1\n    \n    # Finalize output for non-committed units\n    for i in set(range(len(units_info))) - committed:\n        u_out[i] = 0\n        p_out[i] = 0  # Ensure output is 0\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0004363508,
          "gap_price_rate": 0.0159271483,
          "fitness": 0.0081817495
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    category_list = []\n    for unit in units_info:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                category_list.append('must_on')\n            else:\n                category_list.append('free_on')\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                category_list.append('must_off')\n            else:\n                category_list.append('free_off')\n    \n    u = [1 if cat in ['must_on', 'free_on'] else 0 for cat in category_list]\n    min_p_arr = [0] * n_units\n    max_p_arr = [0] * n_units\n    \n    def compute_bounds(i, committed):\n        unit = units_info[i]\n        if committed:\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p, max_p = 0, 0\n        return min_p, max_p\n\n    for i in range(n_units):\n        min_p_arr[i], max_p_arr[i] = compute_bounds(i, u[i])\n    \n    total_min = sum(min_p_arr)\n    total_max = sum(max_p_arr)\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    free_off_avail = [i for i, cat in enumerate(category_list) if cat == 'free_off' and u[i] == 0]\n    candidate_costs = []\n    for i in free_off_avail:\n        unit = units_info[i]\n        min_p = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        cost_per_MW = total_cost / min_p if min_p > 0 else float('inf')\n        candidate_costs.append((i, cost_per_MW))\n    candidate_costs.sort(key=lambda x: x[1])\n    \n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        if u[i] == 0:\n            u[i] = 1\n            min_p_val, max_p_val = compute_bounds(i, True)\n            min_p_arr[i] = min_p_val\n            max_p_arr[i] = max_p_val\n            total_min += min_p_val\n            total_max += max_p_val\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    p_alloc = [min_p_arr[i] if u[i] == 1 else 0 for i in range(n_units)]\n    remaining = current_load - sum(p_alloc)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    while remaining > 1e-6:\n        candidate = -1\n        min_mc = float('inf')\n        for i in committed_indices:\n            if p_alloc[i] < max_p_arr[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n        if candidate == -1:\n            break\n        delta = min(remaining, max_p_arr[candidate] - p_alloc[candidate])\n        p_alloc[candidate] += delta\n        remaining -= delta\n    \n    return np.array([u, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and eligible for shutdown), and free-off (offline and eligible for startup).\n2. Commit must-on and free-on units initially. Calculate effective power bounds considering ramp constraints: for previously online units, min = max(p_min, p_prev - ramp_down) and max = min(p_max, p_prev + ramp_up); for newly committed units, max = min(p_max, p_start) with min = p_min.\n3. If total maximum capacity < load, commit free-off units sorted by ascending (startup_cost + cost_at_min_output)/min_output until sufficient capacity is achieved.\n4. If total minimum capacity > load, decommit free-on units with highest cost/MW at min output, ensuring remaining maximum capacity \u2265 load.\n5. Dispatch load to committed units:\n   - Set outputs to min if load \u2264 total min\n   - Set outputs to max if load \u2265 total max\n   - Otherwise perform economic dispatch via binary search for marginal cost (lambda) using derivative of cost functions, with outputs clamped to effective bounds.\n6. Set non-committed units to off (0 output).\n\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    committed_units = []\n    u_out = [0] * n_units\n    p_out = [0.0] * n_units\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:  # online previously\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # offline previously\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize committed units and compute bounds\n    committed_units = must_on + free_on\n    min_bounds = {}\n    max_bounds = {}\n    for i in must_on + free_on:\n        unit = units_info[i]\n        min_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        min_bounds[i] = min_bound\n        max_bounds[i] = max_bound\n    \n    # Step 3: Commit additional free-off units if needed\n    total_min = sum(min_bounds[i] for i in committed_units)\n    total_max = sum(max_bounds[i] for i in committed_units)\n    \n    free_off_sorted = sorted(\n        free_off,\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                       units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i']\n    )\n    \n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        unit = units_info[i]\n        min_candidate = unit['p_min_i']\n        max_candidate = min(unit['p_max_i'], unit['p_start_i'])\n        min_bounds[i] = min_candidate\n        max_bounds[i] = max_candidate\n        committed_units.append(i)\n        total_min += min_candidate\n        total_max += max_candidate\n    \n    # Step 4: Decommit free-on units if over minimum capacity\n    free_on_in_committed = [i for i in committed_units if i in free_on]\n    free_on_in_committed.sort(\n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * min_bounds[i] + \n                       units_info[i]['c_i'] * min_bounds[i]**2) / min_bounds[i],\n        reverse=True\n    )\n    \n    for i in free_on_in_committed:\n        if total_min <= current_load:\n            break\n        new_total_max = total_max - max_bounds[i]\n        if new_total_max < current_load:\n            continue\n        committed_units.remove(i)\n        total_min -= min_bounds[i]\n        total_max -= max_bounds[i]\n        if total_min <= current_load:\n            break\n    \n    # Step 5: Dispatch load\n    total_min = sum(min_bounds[i] for i in committed_units)\n    total_max = sum(max_bounds[i] for i in committed_units)\n    \n    for i in committed_units:\n        u_out[i] = 1\n        if current_load <= total_min:\n            p_out[i] = min_bounds[i]\n        elif current_load >= total_max:\n            p_out[i] = max_bounds[i]\n    \n    # Economic dispatch when load between min and max\n    if total_min < current_load < total_max:\n        low_lambda = min(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * min_bounds[i] for i in committed_units)\n        high_lambda = max(units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * max_bounds[i] for i in committed_units)\n        \n        for _ in range(100):  # Binary search for lambda\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_gen = 0\n            for i in committed_units:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    p = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Linear cost\n                    p = max_bounds[i] if mid_lambda >= unit['b_i'] else min_bounds[i]\n                p = max(min_bounds[i], min(max_bounds[i], p))\n                total_gen += p\n                \n            if total_gen < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        \n        # Final assignment with converged lambda\n        mid_lambda = (low_lambda + high_lambda) / 2\n        for i in committed_units:\n            unit = units_info[i]\n            if unit['c_i'] > 0:\n                p = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n            else:  # Linear cost\n                p = max_bounds[i] if mid_lambda >= unit['b_i'] else min_bounds[i]\n            p_out[i] = max(min_bounds[i], min(max_bounds[i], p))\n    \n    # Return results as 2D numpy array\n    return np.array([u_out, p_out], dtype=float)",
          "from": "mutation",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0360463335,
          "fitness": 0.018088006
     },
     {
          "name": "enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints and startup/shutdown limitations.\n3. While total effective min > load and eligible free-on units exist: \n   - Decommit free-on units with largest effective min output (if remaining capacity can still meet load)\n4. While total effective max < load and free-off units exist:\n   - Commit free-off units with lowest average cost per MW (startup cost + min-output cost / min output)\n5. If total min > load: set committed units to effective min\n6. Elif total max < load: set committed units to effective max\n7. Else: perform economic dispatch using lambda iteration:\n   - Initialize outputs at effective min\n   - Binary search for lambda (marginal cost) until generation matches load\n   - For each unit: clamp output to effective min/max using quadratic/linear dispatch logic\n8. Return final commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters to arrays\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    \n    # Classification\n    must_on = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    free_on = np.zeros(n_units, dtype=bool)\n    free_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:  # previously online\n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:  # previously offline\n            if -t_i_0[i] < t_off_min[i]:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    # Initial commitment\n    committed = must_on.copy() | free_on.copy()\n    must_off_mask = must_off.copy()\n    committed[must_off_mask] = False\n    \n    # Effective power limits\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1 and committed[i]:\n            eff_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n            eff_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n        elif free_off[i] or (u_i_0[i] == 0 and committed[i]):\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], p_start[i])\n    \n    # Over-commitment handling\n    total_min = np.sum(eff_min[committed])\n    total_max = np.sum(eff_max[committed])\n    \n    if total_min > current_load:\n        free_on_indices = np.where(free_on & committed)[0]\n        if len(free_on_indices) > 0:\n            # Sort by descending effective min\n            sorted_indices = sorted(free_on_indices, key=lambda i: eff_min[i], reverse=True)\n            for idx in sorted_indices:\n                if total_max - eff_max[idx] >= current_load:\n                    committed[idx] = False\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    if total_min <= current_load:\n                        break\n    \n    # Under-commitment handling\n    if total_max < current_load:\n        free_off_indices = np.where(free_off & ~committed & ~must_off_mask)[0]\n        if len(free_off_indices) > 0:\n            # Calculate cost metric: (startup cost + min-output cost) / min output\n            min_cost = a[free_off_indices] + b[free_off_indices] * eff_min[free_off_indices] + \\\n                       c[free_off_indices] * eff_min[free_off_indices]**2\n            cost_metric = (s[free_off_indices] + min_cost) / eff_min[free_off_indices]\n            sorted_indices = [x for _, x in sorted(zip(cost_metric, free_off_indices), key=lambda pair: pair[0])]\n            for idx in sorted_indices:\n                committed[idx] = True\n                total_min += eff_min[idx]\n                total_max += eff_max[idx]\n                if total_max >= current_load:\n                    break\n    \n    # Update limits for final committed set\n    final_eff_min = eff_min.copy()\n    final_eff_max = eff_max.copy()\n    for i in range(n_units):\n        if committed[i] and u_i_0[i] == 0:  # newly started\n            final_eff_min[i] = p_min[i]\n            final_eff_max[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(final_eff_min[committed])\n    total_max = np.sum(final_eff_max[committed])\n    \n    # Dispatch\n    p_out = np.zeros(n_units)\n    if total_min > current_load:\n        p_out[committed] = final_eff_min[committed]\n    elif total_max < current_load:\n        p_out[committed] = final_eff_max[committed]\n    else:\n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        iter_count = 0\n        lam_low = 0\n        lam_high = np.max(b[committed] + 2 * c[committed] * final_eff_max[committed] * (c[committed] > 0) + \n                         b[committed] * (c[committed] == 0))\n        lam = (lam_low + lam_high) / 2\n        p_committed = final_eff_min[committed].copy()\n        \n        while iter_count < max_iter:\n            # Calculate outputs\n            for idx, i in enumerate(np.where(committed)[0]):\n                if c[i] > 0:\n                    desired = (lam - b[i]) / (2 * c[i])\n                    p_committed[idx] = np.clip(desired, final_eff_min[i], final_eff_max[i])\n                else:\n                    if lam < b[i]:\n                        p_committed[idx] = final_eff_min[i]\n                    else:\n                        p_committed[idx] = final_eff_max[i]\n            \n            total_p = np.sum(p_committed)\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n                \n            lam = (lam_low + lam_high) / 2\n            iter_count += 1\n        \n        p_out[committed] = p_committed\n    \n    u_out = committed.astype(int)\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0001296798,
          "gap_price_rate": 0.0360463335,
          "fitness": 0.0180880066
     },
     {
          "name": "dynamic_commitment_with_dispatch",
          "algorithm": "1. Classify units as must-on, must-off, free-on, or free-off based on prior state and constraints. Must-on units include those that haven't satisfied minimum up-time or whose prior output exceeds shutdown ramp capacity. Must-off units are those that haven't satisfied minimum down-time.  \n2. Initially commit must-on and free-on units.  \n3. Calculate effective power limits:  \n   - For previously online units: min = max(p_min, p_prev - ramp_down), max = min(p_max, p_prev + ramp_up)  \n   - For newly started units: min = p_min, max = min(p_max, start_ramp)  \n4. While total min output > load:  \n   - Sort free-on units by descending (cost at min output)/min_output  \n   - Decommit the highest-cost unit that won't reduce total max output below load  \n   - Update total min/max  \n5. While total max output < load:  \n   - Sort free-off units by ascending (startup + cost at min output)/min_output  \n   - Commit the cheapest unit  \n   - Update total min/max  \n6. Dispatch load to committed units:  \n   - Initialize at effective min outputs  \n   - Use lambda iteration to set outputs, clamping to limits:  \n     a. Solve marginal cost (lambda) via binary search  \n     b. Calculate outputs as (lambda - b_i)/(2c_i) clamped to [min_i, max_i]  \n     c. Iterate until generation matches load within tolerance  \n7. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef dynamic_commitment_with_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract parameters into arrays\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    start_ramp = [unit['p_start_i'] for unit in units_info]\n    shut_ramp = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n    startup_cost = [unit['s_i'] for unit in units_info]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Online previously\n            if t_state[i] < min_up[i] or p_prev[i] > shut_ramp[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline previously\n            if -t_state[i] < min_down[i]:  # t_state negative when offline\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on) | set(free_on)\n    decommitted = set(must_off) | set(free_off)\n    \n    # Calculate effective power limits\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1 and i in committed:\n            eff_min[i] = max(p_min[i], p_prev[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_prev[i] + ramp_up[i])\n        elif i in committed:  # Newly started\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], start_ramp[i])\n        else:\n            eff_min[i] = 0\n            eff_max[i] = 0\n    \n    # Adjust commitment\n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Case 1: Over-commitment (total min output > load)\n    if total_min > current_load:\n        # Sort free-on units by descending cost per MW at min output\n        free_on.sort(key=lambda i: (a[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i], \n                      reverse=True)\n        remove_list = []\n        for i in free_on:\n            if i in committed and not (i in must_on):\n                new_total_max = total_max - eff_max[i]\n                if new_total_max >= current_load:\n                    remove_list.append(i)\n                    total_min -= eff_min[i]\n                    total_max = new_total_max\n                    if total_min <= current_load:\n                        break\n        \n        for i in remove_list:\n            committed.remove(i)\n            eff_min[i] = eff_max[i] = 0\n            free_on.remove(i)\n            decommitted.add(i)\n    \n    # Case 2: Under-commitment (total max output < load)\n    if total_max < current_load:\n        # Sort free-off units by ascending average cost per MW (including startup)\n        free_off.sort(key=lambda i: (startup_cost[i] + a[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i])\n        add_list = []\n        for i in free_off:\n            unit_min = p_min[i]\n            unit_max = min(p_max[i], start_ramp[i])\n            new_total_min = total_min + unit_min\n            new_total_max = total_max + unit_max\n            \n            add_list.append(i)\n            committed.add(i)\n            eff_min[i] = unit_min\n            eff_max[i] = unit_max\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= current_load:\n                break\n        \n        for i in add_list:\n            free_off.remove(i)\n            decommitted.discard(i)\n    \n    # Economic dispatch using lambda iteration\n    comm_list = list(committed)\n    n_comm = len(comm_list)\n    p_dispatch = [eff_min[i] for i in range(n_units)]\n    \n    if n_comm > 0:\n        # Set bounds for lambda (marginal cost)\n        low = min(b[i] + 2*c[i]*eff_min[i] for i in comm_list)\n        high = max(b[i] + 2*c[i]*eff_max[i] for i in comm_list)\n        \n        tol = 0.001  # 0.001 MW tolerance\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_gen = 0\n            for i in comm_list:\n                if c[i] > 0:\n                    p_temp = (lam - b[i]) / (2 * c[i])\n                else:  # Linear cost function\n                    p_temp = eff_max[i] if lam > b[i] else eff_min[i]\n                \n                p_temp = max(eff_min[i], min(p_temp, eff_max[i]))\n                total_gen += p_temp\n                p_dispatch[i] = p_temp\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            elif total_gen < current_load:\n                low = lam\n            else:\n                high = lam\n    else:  # No units committed\n        total_gen = 0\n    \n    # Set outputs\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n        p[i] = p_dispatch[i] if i in committed else 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001297944,
          "gap_price_rate": 0.0360463471,
          "fitness": 0.0180880708
     },
     {
          "name": "hybrid_enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online and can be turned off), free-off (offline and can be turned on).\n2. Commit must-on and free-on units initially. For must-on units, enforce minimum output constraints based on ramp limits.\n3. Calculate effective power limits:\n   - Previously online units: min = max(p_min, prev_output - ramp_down), max = min(p_max, prev_output + ramp_up)\n   - Newly started units: min = p_min, max = min(p_max, start_ramp)\n4. While total effective min > current load and free-on units exist:\n   - Identify candidate units removable without causing capacity shortage\n   - Decommit candidate with highest min_output to reduce over-generation\n   - Recalculate effective power limits\n5. While total effective max < current load and free-off units exist:\n   - Identify candidate units for commitment\n   - Commit candidate with lowest cost per MW = (startup_cost + min_output_cost)/min_output\n   - Recalculate effective power limits\n6. Dispatch load to committed units:\n   - If load \u2264 total min: set all units to min outputs\n   - Else if load \u2265 total max: set all units to max outputs\n   - Else: use lambda iteration with clamping to distribute load\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef hybrid_enhanced_dynamic_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Determine unit classifications and initial commitment\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    \n    # Classify units and set initial effective limits\n    for i, unit in enumerate(units_info):\n        a_i = unit['a_i']\n        b_i = unit['b_i']\n        c_i = unit['c_i']\n        u_i_0 = unit['u_i_0']\n        p_i_0 = unit['p_i_0']\n        t_i_0 = unit['t_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        p_start_i = unit['p_start_i']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        # Check must-on conditions\n        if u_i_0 == 1 and (t_i_0 < t_on_min_i or p_i_0 > p_shut_i):\n            must_on.append(i)\n            u[i] = 1\n            effective_min[i] = max(p_min_i, p_i_0 - p_down_i)\n            effective_max[i] = min(p_max_i, p_i_0 + p_up_i)\n        # Check must-off conditions\n        elif u_i_0 == 0 and abs(t_i_0) < t_off_min_i:\n            must_off.append(i)\n            u[i] = 0\n            effective_min[i] = 0\n            effective_max[i] = 0\n        # Classify free-on and free-off\n        else:\n            if u_i_0 == 1:\n                free_on.append(i)\n                u[i] = 1\n                effective_min[i] = max(p_min_i, p_i_0 - p_down_i)\n                effective_max[i] = min(p_max_i, p_i_0 + p_up_i)\n            else:\n                free_off.append(i)\n                u[i] = 0\n                effective_min[i] = 0\n                effective_max[i] = 0\n    \n    # Initial commitment\n    committed = set(must_on + free_on)\n    total_min = sum(effective_min)\n    total_max = sum(effective_max)\n    \n    # Decommit free-on units if over-generation\n    free_on.sort(key=lambda i: effective_min[i], reverse=True)\n    i = 0\n    while total_min > current_load and i < len(free_on):\n        candidate = free_on[i]\n        # Check if decommitting maintains load coverage\n        new_total_max = total_max - effective_max[candidate]\n        if new_total_max >= current_load:\n            u[candidate] = 0\n            committed.discard(candidate)\n            total_min -= effective_min[candidate]\n            total_max -= effective_max[candidate]\n            effective_min[candidate] = 0\n            effective_max[candidate] = 0\n        i += 1\n    \n    # Commit free-off units if under-capacity\n    def cost_per_mw(i):\n        unit = units_info[i]\n        min_out = unit['p_min_i']\n        cost = unit['a_i'] + unit['b_i'] * min_out + unit['c_i'] * min_out**2\n        return (unit['s_i'] + cost) / min_out\n    \n    free_off.sort(key=cost_per_mw)\n    i = 0\n    while total_max < current_load and i < len(free_off):\n        candidate = free_off[i]\n        unit = units_info[candidate]\n        min_out = unit['p_min_i']\n        max_out = min(unit['p_max_i'], unit['p_start_i'])\n        # Commit candidate\n        u[candidate] = 1\n        effective_min[candidate] = min_out\n        effective_max[candidate] = max_out\n        committed.add(candidate)\n        total_min += min_out\n        total_max += max_out\n        i += 1\n    \n    # Dispatch load\n    if total_min >= current_load:\n        # Set all to min output\n        for i in committed:\n            p[i] = effective_min[i]\n    elif total_max <= current_load:\n        # Set all to max output\n        for i in committed:\n            p[i] = effective_max[i]\n    else:\n        # Lambda iteration for economic dispatch\n        low = 0\n        high = 1e6\n        tolerance = 1e-3\n        p_temp = np.copy(effective_min)\n        \n        for _ in range(100):\n            lambda_val = (low + high) / 2\n            total_p = 0\n            for i in committed:\n                unit = units_info[i]\n                b_i = unit['b_i']\n                c_i = unit['c_i']\n                demand_i = max(effective_min[i], min(effective_max[i], (lambda_val - b_i) / (2 * c_i)))\n                p_temp[i] = demand_i\n                total_p += demand_i\n            \n            if abs(total_p - current_load) < tolerance:\n                break\n            elif total_p < current_load:\n                low = lambda_val\n            else:\n                high = lambda_val\n        \n        for i in committed:\n            p[i] = p_temp[i]\n    \n    # Prepare output schedule\n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001298029,
          "gap_price_rate": 0.0360463503,
          "fitness": 0.0180880766
     }
]