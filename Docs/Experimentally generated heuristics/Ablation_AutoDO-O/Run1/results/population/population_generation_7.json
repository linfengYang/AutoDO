[
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (cannot be turned off), must-off (cannot be turned on), free-on (online and can be turned off), and free-off (offline and can be turned on)\n2. Commit must-run units and calculate their effective min/max outputs based on ramp constraints\n3. If total minimum output exceeds load, decommit free-on units in descending order of min output\n4. If total maximum output is below load, commit additional units from candidate list (free-on + free-off) sorted by cost per MW at minimum output\n5. Dispatch using lambda iteration to meet load exactly within generation limits\n6. For all non-committed units, set status to off and output to zero\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = set()\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        must_run_cond = (\n            u_i0 == 1 and \n            (t_i0 > 0 and t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])\n        )\n        # Must-off conditions\n        must_off_cond = (\n            u_i0 == 0 and \n            abs(t_i0) < unit['t_off_min_i']\n        )\n        \n        if must_run_cond:\n            must_run.append(i)\n            committed.add(i)\n        elif must_off_cond:\n            must_off.append(i)\n        elif u_i0 == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Compute effective min/max for must-run units\n    total_min = 0.0\n    total_max = 0.0\n    must_run_limits = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        # Compute effective limits\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        total_min += eff_min\n        total_max += eff_max\n        must_run_limits.append((i, eff_min, eff_max))\n    \n    # Candidate handling\n    candidate_list = []\n    candidate_indices = []\n    \n    # Free-on candidates\n    for i in free_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        cost_at_min = unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2)\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-on'))\n    \n    # Free-off candidates\n    for i in free_off:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        eff_min = p_min\n        eff_max = min(p_max, unit['p_start_i'])\n        cost_at_min = (unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2) + \n                       unit['s_i'])\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-off'))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Over-commitment handling\n    if total_min > current_load and free_on:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in sorted(\n            candidate_list[:len(free_on)], \n            key=lambda x: units_info[x[1]]['p_min_i'], \n            reverse=True\n        ):\n            if i in free_on:\n                if total_min - eff_min >= current_load:\n                    total_min -= eff_min\n                    total_max -= eff_max\n                else:\n                    break\n    \n    # Under-commitment handling\n    if total_max < current_load and candidate_list:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in candidate_list:\n            if unit_type == 'free-off' and i in free_off:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n            elif unit_type == 'free-on' and i in free_on:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n    \n    # Dispatch preparation\n    dispatch_list = []\n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        if u_i0 == 1:  # Was online\n            eff_min = max(p_min, p_i0 - ramp_down)\n            eff_max = min(p_max, p_i0 + ramp_up)\n        else:  # Was offline (free-off candidate)\n            eff_min = p_min\n            eff_max = min(p_max, unit['p_start_i'])\n        \n        dispatch_list.append((\n            eff_min, eff_max, \n            unit['b_i'], unit['c_i'], i\n        ))\n    \n    # Economic dispatch using lambda iteration\n    if len(dispatch_list) == 0:\n        # Default to zero for all units\n        return schedules\n    \n    # Lambda iteration setup\n    low_lambda = -1e6\n    high_lambda = 1e6\n    tol = 0.1\n    max_iter = 1000\n    p_allocations = np.zeros(len(dispatch_list))\n    \n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_gen = 0.0\n        \n        for idx, (p_min, p_max, b, c, unit_idx) in enumerate(dispatch_list):\n            if c == 0:  # Linear cost\n                if lambda_mid < b:\n                    p = p_min\n                else:\n                    p = p_max\n            else:  # Quadratic cost\n                p_ideal = (lambda_mid - b) / (2 * c)\n                p = max(p_min, min(p_ideal, p_max))\n            \n            p_allocations[idx] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    # Apply allocations to committed units\n    for (p_min, p_max, b, c, unit_idx), p_val in zip(dispatch_list, p_allocations):\n        schedules[0][unit_idx] = 1\n        schedules[1][unit_idx] = p_val\n    \n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.00544046,
          "gap_price_rate": 0.00878014,
          "fitness": 0.0071103
     },
     {
          "name": "refined_hybrid_commitment_v3",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v3(units_info, load):\n    load_current = load[0]\n    n = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    committed = [False] * n\n    min_p = [0] * n\n    max_p = [0] * n\n\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n\n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            committed[i] = True\n        else:\n            off_duration = -t_i0\n            if off_duration < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n\n    for i in range(n):\n        if committed[i]:\n            p_i0 = units_info[i]['p_i_0']\n            min_p[i] = max(units_info[i]['p_min_i'], p_i0 - units_info[i]['p_down_i'])\n            max_p[i] = min(units_info[i]['p_max_i'], p_i0 + units_info[i]['p_up_i'])\n        else:\n            min_p[i] = units_info[i]['p_min_i']\n            max_p[i] = units_info[i]['p_max_i']\n\n    total_min = sum(min_p[i] for i in range(n) if committed[i])\n    total_max = sum(max_p[i] for i in range(n) if committed[i])\n\n    # Step 5: Decommit free-on units if over-generated\n    changed = True\n    while changed and total_min > load_current:\n        changed = False\n        best_candidate, best_cost = None, -10**12\n        for i in free_on:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= load_current <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n                if cost_per_mw > best_cost:\n                    best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is not None:\n            committed[best_candidate] = False\n            total_min -= min_p[best_candidate]\n            total_max -= max_p[best_candidate]\n            changed = True\n\n    # Step 6: Commit free-off units if under-generated\n    while total_max < load_current and free_off:\n        best_candidate, best_cost = None, 10**12\n        for i in free_off:\n            min_p0 = units_info[i]['p_min_i']\n            startup_cost = units_info[i]['s_i']\n            cost_per_mw = (startup_cost + units_info[i]['a_i'] + units_info[i]['b_i'] * min_p0 + units_info[i]['c_i'] * min_p0**2) / min_p0\n            if cost_per_mw < best_cost:\n                best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is None:\n            break\n        min_p0 = units_info[best_candidate]['p_min_i']\n        max_p_bound = min(units_info[best_candidate]['p_max_i'], units_info[best_candidate]['p_start_i'])\n        min_p[best_candidate], max_p[best_candidate] = min_p0, max_p_bound\n        committed[best_candidate] = True\n        total_min += min_p0\n        total_max += max_p_bound\n        free_off.remove(best_candidate)\n        if total_max >= load_current:\n            break\n\n    # Step 7: Post-commitment decommitment of expensive free-on units\n    changed = True\n    while changed:\n        changed = False\n        best_candidate, best_cost = None, -10**12\n        for i in free_on:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= load_current <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n                if cost_per_mw > best_cost:\n                    best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is not None:\n            committed[best_candidate] = False\n            total_min -= min_p[best_candidate]\n            total_max -= max_p[best_candidate]\n            changed = True\n\n    # Step 8: Dispatch\n    output_p = [0] * n\n    if load_current <= total_min:\n        for i in range(n):\n            if committed[i]:\n                output_p[i] = min_p[i]\n    elif load_current >= total_max:\n        for i in range(n):\n            if committed[i]:\n                output_p[i] = max_p[i]\n    else:\n        committed_indices = [i for i in range(n) if committed[i]]\n        lo = min(unit['b_i'] + 2 * unit['c_i'] * min_p[i] for i, unit in enumerate(units_info) if committed[i])\n        hi = max(unit['b_i'] + 2 * unit['c_i'] * max_p[i] for i, unit in enumerate(units_info) if committed[i])\n        tol = 0.001\n        while hi - lo > tol:\n            mid = (lo + hi) / 2\n            total_p = 0\n            for i in committed_indices:\n                b, c = units_info[i]['b_i'], units_info[i]['c_i']\n                min_val, max_val = min_p[i], max_p[i]\n                if c == 0:\n                    p_val = min_val if mid < b else max_val\n                else:\n                    p_unbound = (mid - b) / (2 * c)\n                    p_val = max(min_val, min(max_val, p_unbound))\n                total_p += p_val\n            if total_p < load_current:\n                lo = mid\n            else:\n                hi = mid\n        mid = (lo + hi) / 2\n        for i in committed_indices:\n            b, c = units_info[i]['b_i'], units_info[i]['c_i']\n            min_val, max_val = min_p[i], max_p[i]\n            if c == 0:\n                output_p[i] = min_val if mid < b else max_val\n            else:\n                p_unbound = (mid - b) / (2 * c)\n                output_p[i] = max(min_val, min(max_val, p_unbound))\n\n    u_i_list = [1 if committed[i] else 0 for i in range(n)]\n    schedules = np.array([u_i_list, output_p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054548168,
          "gap_price_rate": 0.0091024797,
          "fitness": 0.0072786483
     },
     {
          "name": "enhanced_commitment_dispatch_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Initially commit must-on and free-on units. Compute effective power bounds for these units considering ramp constraints.\n3. If total effective minimum output exceeds load, iteratively decommit highest-cost-per-MW free-on units (prioritizing units with highest (a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) while ensuring remaining units can still meet load.\n4. If total effective maximum output is below load, iteratively commit most cost-effective free-off units (prioritizing units with lowest (s_i + a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) until generation capacity meets or exceeds load.\n5. If load falls between adjusted total minimum and maximum, decommit any expensive free-on units that can be removed while maintaining load feasibility.\n6. Dispatch power to committed units:\n   - If total min > load: set all units to minimum output (over-generation)\n   - If total max < load: set all units to maximum output (under-generation)\n   - Else: perform economic dispatch via lambda iteration to minimize variable costs while satisfying load exactly.\n7. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    \n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            online_constrained = (t_i0 > 0 and t_i0 < t_on_min) or (p_i0 > unit['p_shut_i'])\n            if online_constrained:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            offline_constrained = (t_i0 < 0 and abs(t_i0) < t_off_min)\n            if offline_constrained:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment (must-on + free-on)\n    committed = set(must_on) | set(free_on)\n    for i in committed:\n        u_current[i] = 1\n        unit = units_info[i]\n        prev_power = unit['p_i_0']\n        min_bound[i] = max(unit['p_min_i'], prev_power - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], prev_power + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed)\n    total_max = sum(max_bound[i] for i in committed)\n    \n    # Decommit free-on units if over-generation\n    if total_min > current_load:\n        changed = True\n        while changed and total_min > current_load:\n            changed = False\n            free_on_committed = [i for i in free_on if i in committed]\n            if not free_on_committed:\n                break\n                \n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_max >= current_load:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n                    changed = True\n                    break\n    \n    # Commit free-off units if under-generation\n    if total_min <= current_load and total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed]\n        if free_off_available:\n            costs, min_vals, max_vals = [], [], []\n            for i in free_off_available:\n                unit = units_info[i]\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n                s, a, b, c = unit['s_i'], unit['a_i'], unit['b_i'], unit['c_i']\n                cost = (s + a + b*min_val + c*min_val**2) / min_val\n                costs.append(cost)\n                min_vals.append(min_val)\n                max_vals.append(max_val)\n            \n            idxs_sorted = np.argsort(costs)\n            for idx in idxs_sorted:\n                i = free_off_available[idx]\n                min_val, max_val = min_vals[idx], max_vals[idx]\n                new_min = total_min + min_val\n                new_max = total_max + max_val\n                committed.add(i)\n                u_current[i] = 1\n                min_bound[i], max_bound[i] = min_val, max_val\n                total_min, total_max = new_min, new_max\n                if new_max >= current_load:\n                    break\n    \n    # Final decommitment pass for expensive free-on units\n    if total_min <= current_load <= total_max:\n        free_on_committed = [i for i in free_on if i in committed]\n        if free_on_committed:\n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_min <= current_load <= new_max:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n    \n    # Dispatch power to committed units\n    if committed:\n        if total_min > current_load:\n            for i in committed:\n                p_current[i] = min_bound[i]\n        elif total_max < current_load:\n            for i in committed:\n                p_current[i] = max_bound[i]\n        else:\n            low, high = None, None\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * min_bound[i]\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * max_bound[i]\n                low = marginal_min if low is None else min(low, marginal_min)\n                high = marginal_max if high is None else max(high, marginal_max)\n            \n            if low == high:\n                for i in committed:\n                    p_current[i] = min_bound[i]\n            else:\n                for _ in range(100):\n                    lam = (low + high) / 2\n                    total_power = 0\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] > 0:\n                            p = (lam - unit['b_i']) / (2 * unit['c_i'])\n                            p = max(min_bound[i], min(max_bound[i], p))\n                            total_power += p\n                    \n                    if abs(total_power - current_load) < 1e-5:\n                        break\n                    elif total_power < current_load:\n                        low = lam\n                    else:\n                        high = lam\n                \n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_current[i] = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_current[i] = max(min_bound[i], min(max_bound[i], p_current[i]))\n    \n    return np.array([u_current, p_current])",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "refined_dynamic_hybrid_commitment_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online and decomittable), and free-off (offline and committable)\n2. Initially commit must-on and free-on units, compute effective power bounds considering ramp constraints\n3. Decomission highest cost/MW free-on units if over-generation exists while ensuring feasibility\n4. Commit free-off units with lowest (startup + min-output cost)/min-output if under-generation exists\n5. Post-commitment decomissioning of expensive free-on units that can be safely removed\n6. Dispatch by setting outputs to min/max or via \u03bb-iteration economic dispatch\n7. Set non-committed units to off (0 output)\n\n",
          "code": "import numpy as np\n\ndef refined_dynamic_hybrid_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i0 < t_off_min_i:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = must_on[:] + free_on[:]\n    free_on_committed = free_on[:]\n    \n    total_min = 0\n    total_max = 0\n    for i in committed:\n        unit = units_info[i]\n        min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    current_total_min = total_min\n    current_total_max = total_max\n    \n    # Decommit free-on if over-generation\n    while current_total_min > current_load and free_on_committed:\n        candidates = []\n        for i in free_on_committed:\n            new_total_max = current_total_max - max_eff[i]\n            if new_total_max >= current_load:\n                unit = units_info[i]\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * (min_eff[i]**2)) / min_eff[i]\n                candidates.append((i, cost_per_mw))\n        \n        if not candidates:\n            break\n        \n        i_candidate = max(candidates, key=lambda x: x[1])[0]\n        committed.remove(i_candidate)\n        free_on_committed.remove(i_candidate)\n        current_total_min -= min_eff[i_candidate]\n        current_total_max -= max_eff[i_candidate]\n    \n    # Commit free-off if under-generation\n    while current_total_max < current_load and free_off:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * (min_i**2)) / min_i\n            candidates.append((i, cost_per_mw, min_i, max_i))\n        \n        if not candidates:\n            break\n        \n        i_candidate, _, min_candidate, max_candidate = min(candidates, key=lambda x: x[1])\n        committed.append(i_candidate)\n        free_off.remove(i_candidate)\n        min_eff[i_candidate] = min_candidate\n        max_eff[i_candidate] = max_candidate\n        current_total_min += min_candidate\n        current_total_max += max_candidate\n    \n    # Post-commitment decommitment\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        candidates = []\n        for i in free_on_committed:\n            unit = units_info[i]\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * (min_eff[i]**2)) / min_eff[i]\n            candidates.append((i, cost_per_mw))\n        \n        if not candidates:\n            break\n        \n        candidates_sorted = sorted(candidates, key=lambda x: x[1], reverse=True)\n        for cand in candidates_sorted:\n            i_candidate = cand[0]\n            new_total_min = current_total_min - min_eff[i_candidate]\n            new_total_max = current_total_max - max_eff[i_candidate]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                committed.remove(i_candidate)\n                free_on_committed.remove(i_candidate)\n                current_total_min = new_total_min\n                current_total_max = new_total_max\n                changed = True\n                break\n    \n    # Dispatch\n    p_outputs = [0] * n_units\n    if current_total_min >= current_load:\n        for i in committed:\n            p_outputs[i] = min_eff[i]\n    elif current_total_max <= current_load:\n        for i in committed:\n            p_outputs[i] = max_eff[i]\n    else:\n        bs, cs, mins_arr, maxs_arr, indices = [], [], [], [], []\n        for i in committed:\n            unit = units_info[i]\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n            mins_arr.append(min_eff[i])\n            maxs_arr.append(max_eff[i])\n            indices.append(i)\n        \n        low_lambda = min(b_i + 2*c_i*min_i for b_i, c_i, min_i in zip(bs, cs, mins_arr))\n        high_lambda = max(b_i + 2*c_i*max_i for b_i, c_i, max_i in zip(bs, cs, maxs_arr))\n        \n        p_alloc = [0] * len(committed)\n        tol, max_iter = 1e-6, 1000\n        iter_count = 0\n        \n        while (high_lambda - low_lambda) > tol and iter_count < max_iter:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_p = 0\n            for idx in range(len(committed)):\n                desired = (mid_lambda - bs[idx]) / (2 * cs[idx])\n                p_alloc[idx] = max(mins_arr[idx], min(maxs_arr[idx], desired))\n                total_p += p_alloc[idx]\n            \n            if total_p < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            iter_count += 1\n        \n        for idx, i in enumerate(indices):\n            p_outputs[i] = p_alloc[idx]\n    \n    u_states = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_states, p_outputs])",
          "from": "mutation",
          "gap_power_rate": 0.005428589,
          "gap_price_rate": 0.009140149,
          "fitness": 0.007284369
     },
     {
          "name": "enhanced_rolling_commitment_dispatch_v2",
          "algorithm": "1. Classify units into must-on (constrained online), must-off (constrained offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Commit must-on and free-on units. Compute effective power bounds considering ramp constraints and startup/shutdown limits.\n3. If total effective minimum output exceeds load, iteratively decommit highest variable cost-per-MW free-on units while ensuring remaining units can satisfy load constraints.\n4. If total effective maximum output is below load, iteratively commit lowest (startup cost + min-output cost)/min-output free-off units until generation capacity meets or exceeds load.\n5. After step 4, perform post-commitment decommitment of highest variable cost-per-MW free-on units while maintaining load feasibility.\n6. Dispatch load to committed units: set outputs to minimum if load \u2264 total minimum; set to maximum if load \u2265 total maximum; otherwise perform economic dispatch via lambda iteration.\n7. Set all non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch_v2(units_info, load):\n    n = len(units_info)\n    u_current = [0] * n\n    p_current = [0] * n\n    effective_min = [0] * n\n    effective_max = [0] * n\n    categories = [''] * n\n    \n    current_load = load[0]\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                categories[i] = 'must-on'\n            else:\n                categories[i] = 'free-on'\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                categories[i] = 'must-off'\n            else:\n                categories[i] = 'free-off'\n    \n    # Initialize committed units and total capacities\n    committed = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Step 2: Commit must-on and free-on units, compute effective bounds\n    for i, unit in enumerate(units_info):\n        if categories[i] in ['must-on', 'free-on']:\n            u_current[i] = 1\n            committed.append(i)\n            if unit['u_i_0'] == 1:\n                min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n            effective_min[i] = min_val\n            effective_max[i] = max_val\n            total_min += min_val\n            total_max += max_val\n    \n    # Collect free-on units in committed set\n    free_on_committed = [i for i in committed if categories[i] == 'free-on']\n    \n    # Step 3: Over-generation decommitment\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed if categories[i] == 'free-on' and u_current[i] == 1]\n        if not free_on_committed:\n            break\n        candidates = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + units_info[i]['c_i'] * effective_min[i] ** 2\n            cost_per_mw = cost / effective_min[i]\n            candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for (i, cost_per_mw) in candidates:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u_current[i] = 0\n                committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 4: Under-generation commitment\n    free_off = [i for i in range(n) if categories[i] == 'free-off' and u_current[i] == 0]\n    candidates = []\n    for i in free_off:\n        min_val = units_info[i]['p_min_i']\n        start_cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_val + units_info[i]['c_i'] * min_val ** 2\n        cost_per_mw = start_cost / min_val\n        candidates.append((i, cost_per_mw))\n    candidates.sort(key=lambda x: x[1])\n    \n    for (i, cost_per_mw) in candidates:\n        if total_max >= current_load:\n            break\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        u_current[i] = 1\n        committed.append(i)\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 5: Post-commitment decommitment\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed if categories[i] == 'free-on' and u_current[i] == 1]\n        if not free_on_committed:\n            break\n        candidates = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + units_info[i]['c_i'] * effective_min[i] ** 2\n            cost_per_mw = cost / effective_min[i]\n            candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for (i, cost_per_mw) in candidates:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u_current[i] = 0\n                committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 6: Dispatch\n    if abs(current_load - total_min) < 1e-6:\n        for i in committed:\n            p_current[i] = effective_min[i]\n    elif abs(current_load - total_max) < 1e-6:\n        for i in committed:\n            p_current[i] = effective_max[i]\n    else:\n        low = 0\n        high = 0\n        for i in committed:\n            mc_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_min[i]\n            mc_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_max[i]\n            if mc_min < low:\n                low = mc_min\n            if mc_max > high:\n                high = mc_max\n        \n        if low == 0 and high == 0:\n            low = min(unit['b_i'] for unit in units_info)\n            high = max(unit['b_i'] for unit in units_info)\n        \n        tol = 0.001\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2.0\n            total_p = 0.0\n            for i in committed:\n                c = units_info[i]['c_i']\n                b = units_info[i]['b_i']\n                if c == 0:\n                    if lam >= b:\n                        p = effective_max[i]\n                    else:\n                        p = effective_min[i]\n                else:\n                    p_ideal = (lam - b) / (2 * c)\n                    p = max(effective_min[i], min(effective_max[i], p_ideal))\n                p_current[i] = p\n                total_p += p\n            \n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                low = lam\n            else:\n                high = lam\n    \n    # Step 7: Set non-committed units\n    for i in range(n):\n        if not u_current[i]:\n            p_current[i] = 0.0\n    \n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054286675,
          "gap_price_rate": 0.009140107,
          "fitness": 0.0072843873
     },
     {
          "name": "refined_enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (constrained to remain online due to min up-time or shutdown constraints), must-off (constrained to remain offline due to min down-time), free-on (online and can be turned off), free-off (offline and can be turned on).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints (previous online units: min=max(p_min, p_prev-ramp_down), max=min(p_max, p_prev+ramp_up)).\n3. Decommit free-on units: While total effective min > load, find candidate free-on units removable without violating load constraints (remaining total_min \u2264 load and total_max \u2265 load). Decommit candidate with highest cost per MW at min (a_i + b_i\u00b7min + c_i\u00b7min\u00b2)/min.\n4. Commit free-off units: While total effective max < load, commit candidate free-off unit with lowest cost per MW (startup + a_i + b_i\u00b7min + c_i\u00b7min\u00b2)/min, with effective min=p_min, max=min(p_max, p_start).\n5. Post-commitment decommitment: For committed free-on units, iteratively decommit highest cost per MW units if removal maintains total_min \u2264 load and total_max \u2265 load.\n6. Dispatch committed units:\n   - If load \u2264 total_min: set all to min outputs\n   - If load \u2265 total_max: set all to max outputs\n   - Else: perform lambda iteration economic dispatch (binary search for marginal cost)\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_dynamic_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Initialize outputs\n    u_output = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Initialize committed sets and effective bounds\n    committed = set(must_on + free_on)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Compute initial totals\n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Step 3: Decommit free-on units if total_min > load\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_candidates = free_on_committed.copy()\n    while total_min > current_load and free_on_candidates:\n        candidate_list = []\n        for i in free_on_candidates:\n            unit = units_info[i]\n            new_min = total_min - eff_min[i]\n            new_max = total_max - eff_max[i]\n            if new_min <= current_load and new_max >= current_load:\n                cost_at_min = unit['a_i'] + unit['b_i']*eff_min[i] + unit['c_i']*(eff_min[i]**2)\n                cost_per_mw = cost_at_min / eff_min[i]\n                candidate_list.append((i, cost_per_mw))\n        if not candidate_list:\n            break\n        candidate_list.sort(key=lambda x: x[1], reverse=True)\n        best_candidate, _ = candidate_list[0]\n        total_min -= eff_min[best_candidate]\n        total_max -= eff_max[best_candidate]\n        committed.remove(best_candidate)\n        free_on_candidates.remove(best_candidate)\n    \n    # Step 4: Commit free-off units if total_max < load\n    while total_max < current_load and free_off:\n        candidate_list = []\n        for i in free_off:\n            unit = units_info[i]\n            eff_min_i = unit['p_min_i']\n            eff_max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_at_min = unit['s_i'] + unit['a_i'] + unit['b_i']*eff_min_i + unit['c_i']*(eff_min_i**2)\n            cost_per_mw = cost_at_min / eff_min_i\n            candidate_list.append((i, cost_per_mw, eff_min_i, eff_max_i))\n        candidate_list.sort(key=lambda x: x[1])\n        best_candidate = candidate_list[0][0]\n        eff_min[best_candidate] = candidate_list[0][2]\n        eff_max[best_candidate] = candidate_list[0][3]\n        total_min += eff_min[best_candidate]\n        total_max += eff_max[best_candidate]\n        committed.add(best_candidate)\n        free_off.remove(best_candidate)\n    \n    # Step 5: Post-commitment decommitment (expensive free-on units)\n    free_on_committed = [i for i in free_on if i in committed]\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        candidate_list = []\n        for i in free_on_committed:\n            new_min = total_min - eff_min[i]\n            new_max = total_max - eff_max[i]\n            if new_min <= current_load and new_max >= current_load:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i']*eff_min[i] + unit['c_i']*(eff_min[i]**2)\n                cost_per_mw = cost_at_min / eff_min[i]\n                candidate_list.append((i, cost_per_mw))\n        if not candidate_list:\n            break\n        candidate_list.sort(key=lambda x: x[1], reverse=True)\n        best_candidate, _ = candidate_list[0]\n        total_min -= eff_min[best_candidate]\n        total_max -= eff_max[best_candidate]\n        committed.remove(best_candidate)\n        free_on_committed.remove(best_candidate)\n        changed = True\n    \n    # Step 6: Dispatch\n    for i in committed:\n        p_output[i] = eff_min[i]  # Default to min\n        \n    if current_load <= total_min:\n        # Already set to min outputs\n        pass\n    elif current_load >= total_max:\n        for i in committed:\n            p_output[i] = eff_max[i]\n    else:\n        # Lambda iteration economic dispatch\n        lambda_low = min(2 * units_info[i]['c_i'] * eff_min[i] + units_info[i]['b_i'] for i in committed)\n        lambda_high = max(2 * units_info[i]['c_i'] * eff_max[i] + units_info[i]['b_i'] for i in committed)\n        tol, max_iter, iter_count = 0.001, 1000, 0\n        while iter_count < max_iter:\n            mid = (lambda_low + lambda_high) / 2\n            total_p = 0.0\n            for i in committed:\n                unit = units_info[i]\n                p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(eff_min[i], min(p_val, eff_max[i]))\n                p_output[i] = p_val\n                total_p += p_val\n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                lambda_low = mid\n            else:\n                lambda_high = mid\n            iter_count += 1\n            \n    # Step 7: Set non-committed units\n    for i in committed:\n        u_output[i] = 1\n        \n    return np.array([u_output, p_output])",
          "from": "mutation",
          "gap_power_rate": 0.005428635,
          "gap_price_rate": 0.0091401619,
          "fitness": 0.0072843984
     },
     {
          "name": "dynamic_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize commitment to must-on and free-on units. Compute effective power limits considering ramp constraints.\n3. Decomission highest cost/MW free-on units if over-generation exists while maintaining feasibility.\n4. Commit lowest (startup + min-output cost)/min-output free-off units if under-generation exists.\n5. Conduct post-commitment decomissioning of expensive free-on units if feasible.\n6. Dispatch by setting to min/max bounds or perform \u03bb-iteration economic dispatch with ramp-aware initialization.\n7. Set non-committed units to off (0 output).\n\n",
          "code": "import numpy as np\n\ndef dynamic_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed_units = must_on[:] + free_on[:]\n    min_bound = [0] * num_units\n    max_bound = [0] * num_units\n    \n    for i in committed_units:\n        unit = units_info[i]\n        min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed_units)\n    total_max = sum(max_bound[i] for i in committed_units)\n    \n    candidate_free_on = free_on[:]\n    if total_min > current_load:\n        changed = True\n        while changed and candidate_free_on:\n            changed = False\n            candidates = []\n            for j in candidate_free_on:\n                new_min = total_min - min_bound[j]\n                new_max = total_max - max_bound[j]\n                if new_min <= current_load <= new_max:\n                    cost = (units_info[j]['a_i'] + units_info[j]['b_i'] * min_bound[j] + units_info[j]['c_i'] * min_bound[j]**2) / min_bound[j]\n                    candidates.append((cost, j))\n            if candidates:\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                j_rm = candidates[0][1]\n                committed_units.remove(j_rm)\n                candidate_free_on.remove(j_rm)\n                total_min -= min_bound[j_rm]\n                total_max -= max_bound[j_rm]\n                changed = True\n    \n    if total_max < current_load:\n        candidates = []\n        for j in free_off:\n            unit = units_info[j]\n            min_j = unit['p_min_i']\n            max_j = min(unit['p_max_i'], unit['p_start_i'])\n            if min_j > max_j:\n                continue\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_j + unit['c_i'] * min_j**2) / min_j\n            candidates.append((cost, j, min_j, max_j))\n        candidates.sort(key=lambda x: x[0])\n        for _, j, min_j, max_j in candidates:\n            if total_max >= current_load:\n                break\n            committed_units.append(j)\n            min_bound[j] = min_j\n            max_bound[j] = max_j\n            total_min += min_j\n            total_max += max_j\n    \n    free_on_in_commit = [i for i in committed_units if i in free_on]\n    changed = True\n    while changed and free_on_in_commit:\n        changed = False\n        candidates = []\n        for j in free_on_in_commit:\n            new_min = total_min - min_bound[j]\n            new_max = total_max - max_bound[j]\n            if new_min <= current_load <= new_max:\n                cost = (units_info[j]['a_i'] + units_info[j]['b_i'] * min_bound[j] + units_info[j]['c_i'] * min_bound[j]**2) / min_bound[j]\n                candidates.append((cost, j))\n        if candidates:\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            j_rm = candidates[0][1]\n            committed_units.remove(j_rm)\n            free_on_in_commit.remove(j_rm)\n            total_min -= min_bound[j_rm]\n            total_max -= max_bound[j_rm]\n            changed = True\n    \n    u_arr = np.zeros(num_units)\n    p_arr = np.zeros(num_units)\n    \n    for i in committed_units:\n        u_arr[i] = 1\n    \n    if current_load <= total_min:\n        for i in committed_units:\n            p_arr[i] = min_bound[i]\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_arr[i] = max_bound[i]\n    else:\n        a, b, c, mins, maxs = [], [], [], [], []\n        for i in committed_units:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            mins.append(min_bound[i])\n            maxs.append(max_bound[i])\n        \n        def total_output(lam):\n            total_p = 0.0\n            for idx in range(len(a)):\n                p_val = (lam - b[idx]) / (2 * c[idx]) if c[idx] != 0 else (mins[idx] if lam < b[idx] else maxs[idx])\n                p_val = max(mins[idx], min(maxs[idx], p_val))\n                total_p += p_val\n            return total_p\n        \n        lam_low = min(b_i + 2 * c_i * min_i for (b_i, c_i, min_i) in zip(b, c, mins))\n        lam_high = max(b_i + 2 * c_i * max_i for (b_i, c_i, max_i) in zip(b, c, maxs))\n        \n        tol = 1e-5\n        while lam_high - lam_low > tol:\n            lam_mid = (lam_low + lam_high) / 2\n            if total_output(lam_mid) < current_load:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n        \n        final_lam = (lam_low + lam_high) / 2\n        for idx, i in enumerate(committed_units):\n            if c[idx] == 0:\n                p_arr[i] = mins[idx] if final_lam < b[idx] else maxs[idx]\n            else:\n                p_arr[i] = max(mins[idx], min(maxs[idx], (final_lam - b[idx]) / (2 * c[idx])))\n    \n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.005428761,
          "gap_price_rate": 0.0091401042,
          "fitness": 0.0072844326
     },
     {
          "name": "enhanced_dynamic_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints for units that were online.\n3. While total minimum output > current load and feasible free-on units exist, decommit the free-on unit with the highest cost-per-MW at min-output that maintains capacity >= load.\n4. While total maximum output < current load, commit free-off units with the lowest (startup cost + cost at min-output)/min-output.\n5. Iteratively decommit expensive free-on units if removal maintains feasible capacity (min <= load <= max) and reduces cost.\n6. Dispatch load to committed units:\n   - If load <= total minimum output, set all units to min outputs\n   - If load >= total maximum output, set all units to max outputs\n   - Else perform economic dispatch via lambda iteration respecting effective bounds\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_hybrid_commitment(units_info, load):\n    num_units = len(units_info)\n    u_array = np.zeros(num_units)\n    p_array = np.zeros(num_units)\n    if num_units == 0:\n        return np.vstack((u_array, p_array))\n        \n    current_load = load[0]\n    eff_min = np.zeros(num_units)\n    eff_max = np.zeros(num_units)\n    committed = set()\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            consecutive_on = unit['t_i_0']\n            if consecutive_on < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            consecutive_off = -unit['t_i_0']  # Convert negative to positive\n            if consecutive_off < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    # Initialize commitment\n    committed.update(must_on)\n    committed.update(free_on)\n    \n    # Calculate effective min/max for initially committed units\n    total_min, total_max = 0.0, 0.0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Free-off not yet committed\n            min_val = unit['p_min_i']\n            max_val = unit['p_max_i']\n        eff_min[i] = min_val\n        eff_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 3: Decommit over-committed free-on units\n    free_on_committed = [i for i in free_on if i in committed]\n    while total_min > current_load and free_on_committed:\n        candidate = None\n        best_cost_per_mw = -1\n        for i in free_on_committed:\n            new_total_max = total_max - eff_max[i]\n            if new_total_max >= current_load:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \n                              units_info[i]['c_i'] * (eff_min[i] ** 2)) / eff_min[i]\n                if candidate is None or cost_per_mw > best_cost_per_mw:\n                    candidate = i\n                    best_cost_per_mw = cost_per_mw\n        if candidate is None:\n            break\n        committed.remove(candidate)\n        free_on_committed.remove(candidate)\n        total_min -= eff_min[candidate]\n        total_max -= eff_max[candidate]\n    \n    # Step 4: Commit free-off units if under-committed\n    def free_off_cost(i):\n        unit = units_info[i]\n        min_val = unit['p_min_i']\n        cost_val = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * (min_val ** 2)\n        return cost_val / min_val\n    \n    free_off_sorted = sorted(free_off, key=free_off_cost)\n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        eff_min[i] = min_val\n        eff_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 5: Post-commitment decommissioning\n    free_on_committed = [i for i in free_on if i in committed]\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        free_on_committed_sorted = sorted(\n            free_on_committed,\n            key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \n                          units_info[i]['c_i'] * (eff_min[i] ** 2)) / eff_min[i],\n            reverse=True\n        )\n        for i in free_on_committed_sorted:\n            new_total_min = total_min - eff_min[i]\n            new_total_max = total_max - eff_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                committed.remove(i)\n                free_on_committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Set commitment status\n    for i in committed:\n        u_array[i] = 1\n    \n    # Dispatch\n    if committed:\n        if current_load <= total_min:\n            for i in committed:\n                p_array[i] = eff_min[i]\n        elif current_load >= total_max:\n            for i in committed:\n                p_array[i] = eff_max[i]\n        else:\n            # Lambda iteration for economic dispatch\n            low = float('inf')\n            high = float('-inf')\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * eff_min[i] if unit['c_i'] != 0 else unit['b_i']\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * eff_max[i] if unit['c_i'] != 0 else unit['b_i']\n                low = min(low, marginal_min)\n                high = max(high, marginal_max)\n            \n            tol = 1e-2\n            iter_limit = 100\n            for _ in range(iter_limit):\n                mid = (low + high) / 2\n                total_power = 0\n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        if mid >= unit['b_i']:\n                            p_val = eff_max[i]\n                        else:\n                            p_val = eff_min[i]\n                    else:\n                        p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                        p_val = max(eff_min[i], min(eff_max[i], p_val))\n                    total_power += p_val\n                \n                if abs(total_power - current_load) <= tol:\n                    break\n                if total_power < current_load:\n                    low = mid\n                else:\n                    high = mid\n            # Final dispatch after lambda found\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] == 0:\n                    if mid >= unit['b_i']:\n                        p_array[i] = eff_max[i]\n                    else:\n                        p_array[i] = eff_min[i]\n                else:\n                    p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_array[i] = max(eff_min[i], min(eff_max[i], p_val))\n    \n    return np.vstack((u_array, p_array))",
          "from": "crossover",
          "gap_power_rate": 0.005429695,
          "gap_price_rate": 0.0091404072,
          "fitness": 0.0072850511
     },
     {
          "name": "enhanced_hybrid_dispatch",
          "algorithm": "1. Classify units into must-on (constrained online), must-off (constrained offline), free-on (online and eligible for shutdown), free-off (offline and eligible for startup)\n2. Calculate effective power limits considering ramp constraints and startup/shutdown limitations\n3. Initialize commitment with must-on and free-on units\n4. While total min power > load and removable free-on units exist, decommit highest cost/MW free-on unit\n5. While total max power < load and commitable free-off units exist, commit free-off unit with lowest (startup cost + min-output cost)/min-output\n6. Perform post-commitment decommissioning of high cost/MW free-on units if capacity allows\n7. If load \u2264 total min power: set outputs to min\n   Else if load \u2265 total max power: set outputs to max\n   Else: perform economic dispatch using lambda iteration with residual adjustment\n8. Set non-committed units to off (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_dispatch(units_info, load):\n    n = len(units_info)\n    must_on = [False] * n\n    must_off = [False] * n\n    free_on = [False] * n\n    free_off = [False] * n\n    committed = [False] * n\n    min_i = [0.0] * n\n    max_i = [0.0] * n\n\n    current_load = load[0]\n\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            if t_i0 < 0 and -t_i0 < unit['t_off_min_i']:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n        if must_on[i] or free_on[i]:\n            committed[i] = True\n\n    total_min, total_max = 0.0, 0.0\n    for i, unit in enumerate(units_info):\n        if not committed[i]:\n            min_i[i], max_i[i] = 0.0, 0.0\n            continue\n            \n        p_min_val = unit['p_min_i']\n        p_max_val = unit['p_max_i']\n        if unit['u_i_0'] == 1:\n            min_i[i] = max(p_min_val, unit['p_i_0'] - unit['p_down_i'])\n            max_i[i] = min(p_max_val, unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i[i] = p_min_val\n            max_i[i] = min(p_max_val, unit['p_start_i'])\n            \n        total_min += min_i[i]\n        total_max += max_i[i]\n\n    free_on_indices = [i for i in range(n) if free_on[i] and committed[i]]\n    free_on_sorted = sorted(free_on_indices, \n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*min_i[i] + units_info[i]['c_i']*min_i[i]**2) / min_i[i],\n        reverse=True)\n    \n    removed = set()\n    for i in free_on_sorted:\n        if total_min > current_load and (total_max - max_i[i]) >= current_load:\n            committed[i] = False\n            total_min -= min_i[i]\n            total_max -= max_i[i]\n            removed.add(i)\n\n    free_off_indices = [i for i in range(n) if free_off[i] and not committed[i]]\n    free_off_sorted = sorted(free_off_indices,\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                       units_info[i]['c_i']*units_info[i]['p_min_i']**2) / units_info[i]['p_min_i'])\n    \n    for i in free_off_sorted:\n        if total_max < current_load:\n            min_val = units_info[i]['p_min_i']\n            max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            committed[i] = True\n            min_i[i], max_i[i] = min_val, max_val\n            total_min += min_val\n            total_max += max_val\n            if total_max >= current_load:\n                break\n        else:\n            break\n\n    free_on_remaining = [i for i in range(n) if free_on[i] and committed[i] and i not in removed]\n    free_on_remaining_sorted = sorted(free_on_remaining, \n        key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*min_i[i] + units_info[i]['c_i']*min_i[i]**2) / min_i[i],\n        reverse=True)\n    \n    for i in free_on_remaining_sorted:\n        if (total_max - max_i[i]) >= current_load:\n            committed[i] = False\n            total_min -= min_i[i]\n            total_max -= max_i[i]\n        else:\n            break\n\n    committed_indices = [i for i in range(n) if committed[i]]\n    u_out = [0] * n\n    p_out = [0.0] * n\n    \n    if committed_indices:\n        if current_load <= total_min:\n            for i in committed_indices:\n                u_out[i] = 1\n                p_out[i] = min_i[i]\n        elif current_load >= total_max:\n            for i in committed_indices:\n                u_out[i] = 1\n                p_out[i] = max_i[i]\n        else:\n            low_lam, high_lam = float('inf'), -float('inf')\n            for i in committed_indices:\n                unit = units_info[i]\n                b_i, c_i = unit['b_i'], unit['c_i']\n                min_val, max_val = min_i[i], max_i[i]\n                if c_i > 0:\n                    low_val = b_i + 2*c_i*min_val\n                    high_val = b_i + 2*c_i*max_val\n                else:\n                    low_val = high_val = b_i\n                low_lam = min(low_lam, low_val)\n                high_lam = max(high_lam, high_val)\n            \n            low_lam = max(0, low_lam - 100)\n            high_lam += 100\n            lam = (low_lam + high_lam) / 2.0\n            \n            for _ in range(1000):\n                lam = (low_lam + high_lam) / 2.0\n                total_p = 0.0\n                p_dispatch = {}\n                for i in committed_indices:\n                    unit = units_info[i]\n                    b_i, c_i, min_val, max_val = unit['b_i'], unit['c_i'], min_i[i], max_i[i]\n                    if c_i > 0:\n                        p_val = (lam - b_i) / (2 * c_i)\n                        p_val = max(min_val, min(max_val, p_val))\n                    else:\n                        p_val = min_val if lam < b_i else max_val\n                    total_p += p_val\n                    p_dispatch[i] = p_val\n                    \n                if abs(total_p - current_load) < 1e-3:\n                    break\n                if total_p < current_load:\n                    low_lam = lam\n                else:\n                    high_lam = lam\n            else:\n                total_p = 0.0\n                for i in committed_indices:\n                    unit = units_info[i]\n                    b_i, c_i, min_val, max_val = unit['b_i'], unit['c_i'], min_i[i], max_i[i]\n                    if c_i > 0:\n                        p_val = (lam - b_i) / (2 * c_i)\n                        p_val = max(min_val, min(max_val, p_val))\n                    else:\n                        p_val = min_val if lam < b_i else max_val\n                    p_dispatch[i] = p_val\n                    total_p += p_val\n            \n            residual = current_load - total_p\n            residual_tol = 1e-3\n            adjust_iter = 0\n            while abs(residual) > residual_tol and adjust_iter < 1000:\n                adjust_iter += 1\n                if residual > 0:\n                    candidates = [i for i in committed_indices if p_dispatch[i] < max_i[i]]\n                    if not candidates:\n                        break\n                    def get_mc(i):\n                        unit = units_info[i]\n                        p_val = p_dispatch[i]\n                        return unit['b_i'] + 2*unit['c_i']*p_val if unit['c_i'] > 0 else unit['b_i']\n                    candidates.sort(key=get_mc)\n                    i0 = candidates[0]\n                    delta = min(residual, max_i[i0] - p_dispatch[i0])\n                    p_dispatch[i0] += delta\n                    residual -= delta\n                else:\n                    candidates = [i for i in committed_indices if p_dispatch[i] > min_i[i]]\n                    if not candidates:\n                        break\n                    def get_mc(i):\n                        unit = units_info[i]\n                        p_val = p_dispatch[i]\n                        return unit['b_i'] + 2*unit['c_i']*p_val if unit['c_i'] > 0 else unit['b_i']\n                    candidates.sort(key=get_mc, reverse=True)\n                    i0 = candidates[0]\n                    delta = min(-residual, p_dispatch[i0] - min_i[i0])\n                    p_dispatch[i0] -= delta\n                    residual += delta\n                    \n            for i, p_val in p_dispatch.items():\n                p_out[i] = p_val\n                u_out[i] = 1\n            \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054286538,
          "gap_price_rate": 0.0091599123,
          "fitness": 0.0072942831
     },
     {
          "name": "refined_hybrid_commitment_v2",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup)\n2. Commit must-on and free-on units initially\n3. Calculate effective power limits considering ramp constraints and startup/shutdown limitations\n4. Turn off eligible free-on units with the highest cost per MW if their decommitment doesn't jeopardize system reliability\n5. Commit available free-off units with the most economical cost per MW\n6. Initialize dispatch at prior outputs (clamped within bounds) for units that were online\n7. Perform economic dispatch using lambda iteration for committed units\n8. Set output to 0 for non-committed units\n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v2(units_info, load):\n    # Unpack current load\n    current_load = load[0]\n    \n    # Initialize output arrays\n    u_out = np.zeros(len(units_info))\n    p_out = np.zeros(len(units_info))\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        \n        if u0 == 1:  # Was online\n            # Determine online constraints\n            min_up_unsatisfied = t0 < unit['t_on_min_i'] and t0 >= 0\n            shutdown_limited = p0 > unit['p_shut_i']\n            if min_up_unsatisfied or shutdown_limited:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Was offline\n            min_down_unsatisfied = abs(t0) < unit['t_off_min_i'] and t0 <= 0\n            if min_down_unsatisfied:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on).union(free_on)\n    pending_free_on = free_on.copy()\n    pending_free_off = free_off.copy()\n    \n    # Calculate effective min/max for each unit\n    eff_min, eff_max = {}, {}\n    for i in range(len(units_info)):\n        unit = units_info[i]\n        p0, u0 = unit['p_i_0'], unit['u_i_0']\n        \n        if u0 == 1:  # Online last period\n            # For units that were online\n            eff_min[i] = max(unit['p_min_i'], p0 - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], p0 + unit['p_up_i'])\n        else:  # Offline last period\n            # For units newly started\n            eff_min[i] = unit['p_min_i']\n            eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Decommit high-cost free-on units\n    total_min, total_max = 0, 0\n    for i in committed:\n        total_min += eff_min.get(i, 0)\n        total_max += eff_max.get(i, 0)\n    \n    # Sort free-on by cost per MW at min output (descending)\n    free_on_candidates = []\n    for i in pending_free_on:\n        unit = units_info[i]\n        cost = (unit['a_i'] + unit['b_i'] * eff_min[i] + \n                unit['c_i'] * eff_min[i] ** 2)\n        unit_cost_per_mw = cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        free_on_candidates.append((unit_cost_per_mw, i))\n    \n    free_on_candidates.sort(reverse=True, key=lambda x: x[0])\n    \n    for _, i in free_on_candidates:\n        if total_min - eff_min[i] < current_load <= total_max - eff_min[i]:\n            committed.remove(i)\n            total_min -= eff_min[i]\n            total_max -= eff_max[i]\n            pending_free_on.remove(i)\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Commit economical free-off units\n    free_off_candidates = []\n    for i in pending_free_off:\n        unit = units_info[i]\n        min_cost = (unit['a_i'] + unit['s_i'] + unit['b_i'] * eff_min[i] + \n                   unit['c_i'] * eff_min[i] ** 2)\n        unit_cost_per_mw = min_cost / eff_min[i] if eff_min[i] > 0 else float('inf')\n        free_off_candidates.append((unit_cost_per_mw, i))\n    \n    free_off_candidates.sort(key=lambda x: x[0])\n    \n    for _, i in free_off_candidates:\n        if total_max < current_load:\n            committed.add(i)\n            total_min += eff_min[i]\n            total_max += eff_max[i]\n            pending_free_off.remove(i)\n    \n    # Step 6: Initialize dispatch at prior outputs (clamped within bounds)\n    active_units = []\n    init_dispatch = 0\n    for i in committed:\n        unit = units_info[i]\n        # Clamp prior output to feasible range\n        prev_online = unit['u_i_0'] == 1\n        if prev_online:\n            p_initial = max(eff_min[i], min(eff_max[i], unit['p_i_0']))\n        else:\n            p_initial = eff_min[i]\n        active_units.append((i, eff_min[i], eff_max[i], p_initial))\n        init_dispatch += p_initial\n    \n    # Step 7: Perform economic dispatch via lambda iteration\n    remaining_load = current_load - init_dispatch\n    if abs(remaining_load) < 1e-6:\n        # Initial dispatch perfectly meets load\n        for i, _, _, p_initial in active_units:\n            p_out[i] = p_initial\n            u_out[i] = 1\n    else:\n        # Dispatch only if remaining load is significant\n        min_lambda = 0\n        max_lambda = 10000  # Set high initial value\n        \n        # Find lambda via binary search\n        lambda_val = (min_lambda + max_lambda) / 2\n        tolerance = 0.1\n        iterations = 0\n        \n        while True:\n            iterations += 1\n            total_gen = 0\n            for idx, min_p, max_p, _ in active_units:\n                unit = units_info[idx]\n                # Calculate desired output for current lambda\n                if unit['c_i'] > 0:\n                    desired_p = (lambda_val - unit['b_i']) / (2 * unit['c_i'])\n                else:  # Linear cost function\n                    desired_p = max_p if lambda_val > unit['b_i'] else min_p\n                \n                # Clamp to physical limits\n                clamped_p = max(min_p, min(max_p, desired_p))\n                total_gen += clamped_p\n                # Store temporary output\n                p_out[idx] = clamped_p\n            \n            error = total_gen - (init_dispatch + remaining_load)\n            \n            if abs(error) < tolerance or iterations > 100:\n                break\n            elif error > 0:  # Generated too much\n                max_lambda = lambda_val\n            else:  # Generated too little\n                min_lambda = lambda_val\n                \n            lambda_val = (min_lambda + max_lambda) / 2\n        \n        # Set final outputs\n        for idx, _, _, _ in active_units:\n            u_out[idx] = 1\n    \n    # Finalize output for non-committed units\n    for i in set(range(len(units_info))) - committed:\n        u_out[i] = 0\n        p_out[i] = 0  # Ensure output is 0\n    \n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0004363508,
          "gap_price_rate": 0.0159271483,
          "fitness": 0.0081817495
     }
]