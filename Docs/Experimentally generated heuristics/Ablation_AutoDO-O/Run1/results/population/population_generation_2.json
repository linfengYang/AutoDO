[
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (cannot be turned off), must-off (cannot be turned on), free-on (online and can be turned off), and free-off (offline and can be turned on)\n2. Commit must-run units and calculate their effective min/max outputs based on ramp constraints\n3. If total minimum output exceeds load, decommit free-on units in descending order of min output\n4. If total maximum output is below load, commit additional units from candidate list (free-on + free-off) sorted by cost per MW at minimum output\n5. Dispatch using lambda iteration to meet load exactly within generation limits\n6. For all non-committed units, set status to off and output to zero\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = set()\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        must_run_cond = (\n            u_i0 == 1 and \n            (t_i0 > 0 and t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])\n        )\n        # Must-off conditions\n        must_off_cond = (\n            u_i0 == 0 and \n            abs(t_i0) < unit['t_off_min_i']\n        )\n        \n        if must_run_cond:\n            must_run.append(i)\n            committed.add(i)\n        elif must_off_cond:\n            must_off.append(i)\n        elif u_i0 == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Compute effective min/max for must-run units\n    total_min = 0.0\n    total_max = 0.0\n    must_run_limits = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        # Compute effective limits\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        total_min += eff_min\n        total_max += eff_max\n        must_run_limits.append((i, eff_min, eff_max))\n    \n    # Candidate handling\n    candidate_list = []\n    candidate_indices = []\n    \n    # Free-on candidates\n    for i in free_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        cost_at_min = unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2)\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-on'))\n    \n    # Free-off candidates\n    for i in free_off:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        eff_min = p_min\n        eff_max = min(p_max, unit['p_start_i'])\n        cost_at_min = (unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2) + \n                       unit['s_i'])\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-off'))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Over-commitment handling\n    if total_min > current_load and free_on:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in sorted(\n            candidate_list[:len(free_on)], \n            key=lambda x: units_info[x[1]]['p_min_i'], \n            reverse=True\n        ):\n            if i in free_on:\n                if total_min - eff_min >= current_load:\n                    total_min -= eff_min\n                    total_max -= eff_max\n                else:\n                    break\n    \n    # Under-commitment handling\n    if total_max < current_load and candidate_list:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in candidate_list:\n            if unit_type == 'free-off' and i in free_off:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n            elif unit_type == 'free-on' and i in free_on:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n    \n    # Dispatch preparation\n    dispatch_list = []\n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        if u_i0 == 1:  # Was online\n            eff_min = max(p_min, p_i0 - ramp_down)\n            eff_max = min(p_max, p_i0 + ramp_up)\n        else:  # Was offline (free-off candidate)\n            eff_min = p_min\n            eff_max = min(p_max, unit['p_start_i'])\n        \n        dispatch_list.append((\n            eff_min, eff_max, \n            unit['b_i'], unit['c_i'], i\n        ))\n    \n    # Economic dispatch using lambda iteration\n    if len(dispatch_list) == 0:\n        # Default to zero for all units\n        return schedules\n    \n    # Lambda iteration setup\n    low_lambda = -1e6\n    high_lambda = 1e6\n    tol = 0.1\n    max_iter = 1000\n    p_allocations = np.zeros(len(dispatch_list))\n    \n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_gen = 0.0\n        \n        for idx, (p_min, p_max, b, c, unit_idx) in enumerate(dispatch_list):\n            if c == 0:  # Linear cost\n                if lambda_mid < b:\n                    p = p_min\n                else:\n                    p = p_max\n            else:  # Quadratic cost\n                p_ideal = (lambda_mid - b) / (2 * c)\n                p = max(p_min, min(p_ideal, p_max))\n            \n            p_allocations[idx] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    # Apply allocations to committed units\n    for (p_min, p_max, b, c, unit_idx), p_val in zip(dispatch_list, p_allocations):\n        schedules[0][unit_idx] = 1\n        schedules[1][unit_idx] = p_val\n    \n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.00544046,
          "gap_price_rate": 0.00878014,
          "fitness": 0.0071103
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    category_list = []\n    for unit in units_info:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                category_list.append('must_on')\n            else:\n                category_list.append('free_on')\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                category_list.append('must_off')\n            else:\n                category_list.append('free_off')\n    \n    u = [1 if cat in ['must_on', 'free_on'] else 0 for cat in category_list]\n    min_p_arr = [0] * n_units\n    max_p_arr = [0] * n_units\n    \n    def compute_bounds(i, committed):\n        unit = units_info[i]\n        if committed:\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p, max_p = 0, 0\n        return min_p, max_p\n\n    for i in range(n_units):\n        min_p_arr[i], max_p_arr[i] = compute_bounds(i, u[i])\n    \n    total_min = sum(min_p_arr)\n    total_max = sum(max_p_arr)\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    free_off_avail = [i for i, cat in enumerate(category_list) if cat == 'free_off' and u[i] == 0]\n    candidate_costs = []\n    for i in free_off_avail:\n        unit = units_info[i]\n        min_p = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        cost_per_MW = total_cost / min_p if min_p > 0 else float('inf')\n        candidate_costs.append((i, cost_per_MW))\n    candidate_costs.sort(key=lambda x: x[1])\n    \n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        if u[i] == 0:\n            u[i] = 1\n            min_p_val, max_p_val = compute_bounds(i, True)\n            min_p_arr[i] = min_p_val\n            max_p_arr[i] = max_p_val\n            total_min += min_p_val\n            total_max += max_p_val\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    p_alloc = [min_p_arr[i] if u[i] == 1 else 0 for i in range(n_units)]\n    remaining = current_load - sum(p_alloc)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    while remaining > 1e-6:\n        candidate = -1\n        min_mc = float('inf')\n        for i in committed_indices:\n            if p_alloc[i] < max_p_arr[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n        if candidate == -1:\n            break\n        delta = min(remaining, max_p_arr[candidate] - p_alloc[candidate])\n        p_alloc[candidate] += delta\n        remaining -= delta\n    \n    return np.array([u, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints and startup/shutdown limitations.\n3. While total effective min > load and eligible free-on units exist: \n   - Decommit free-on units with largest effective min output (if remaining capacity can still meet load)\n4. While total effective max < load and free-off units exist:\n   - Commit free-off units with lowest average cost per MW (startup cost + min-output cost / min output)\n5. If total min > load: set committed units to effective min\n6. Elif total max < load: set committed units to effective max\n7. Else: perform economic dispatch using lambda iteration:\n   - Initialize outputs at effective min\n   - Binary search for lambda (marginal cost) until generation matches load\n   - For each unit: clamp output to effective min/max using quadratic/linear dispatch logic\n8. Return final commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters to arrays\n    a = np.array([u['a_i'] for u in units_info])\n    b = np.array([u['b_i'] for u in units_info])\n    c = np.array([u['c_i'] for u in units_info])\n    u_i_0 = np.array([u['u_i_0'] for u in units_info])\n    p_i_0 = np.array([u['p_i_0'] for u in units_info])\n    p_min = np.array([u['p_min_i'] for u in units_info])\n    p_max = np.array([u['p_max_i'] for u in units_info])\n    p_up = np.array([u['p_up_i'] for u in units_info])\n    p_down = np.array([u['p_down_i'] for u in units_info])\n    p_start = np.array([u['p_start_i'] for u in units_info])\n    p_shut = np.array([u['p_shut_i'] for u in units_info])\n    t_on_min = np.array([u['t_on_min_i'] for u in units_info])\n    t_off_min = np.array([u['t_off_min_i'] for u in units_info])\n    s = np.array([u['s_i'] for u in units_info])\n    t_i_0 = np.array([u['t_i_0'] for u in units_info])\n    \n    # Classification\n    must_on = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    free_on = np.zeros(n_units, dtype=bool)\n    free_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1:  # previously online\n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:  # previously offline\n            if -t_i_0[i] < t_off_min[i]:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    # Initial commitment\n    committed = must_on.copy() | free_on.copy()\n    must_off_mask = must_off.copy()\n    committed[must_off_mask] = False\n    \n    # Effective power limits\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_i_0[i] == 1 and committed[i]:\n            eff_min[i] = max(p_min[i], p_i_0[i] - p_down[i])\n            eff_max[i] = min(p_max[i], p_i_0[i] + p_up[i])\n        elif free_off[i] or (u_i_0[i] == 0 and committed[i]):\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], p_start[i])\n    \n    # Over-commitment handling\n    total_min = np.sum(eff_min[committed])\n    total_max = np.sum(eff_max[committed])\n    \n    if total_min > current_load:\n        free_on_indices = np.where(free_on & committed)[0]\n        if len(free_on_indices) > 0:\n            # Sort by descending effective min\n            sorted_indices = sorted(free_on_indices, key=lambda i: eff_min[i], reverse=True)\n            for idx in sorted_indices:\n                if total_max - eff_max[idx] >= current_load:\n                    committed[idx] = False\n                    total_min -= eff_min[idx]\n                    total_max -= eff_max[idx]\n                    if total_min <= current_load:\n                        break\n    \n    # Under-commitment handling\n    if total_max < current_load:\n        free_off_indices = np.where(free_off & ~committed & ~must_off_mask)[0]\n        if len(free_off_indices) > 0:\n            # Calculate cost metric: (startup cost + min-output cost) / min output\n            min_cost = a[free_off_indices] + b[free_off_indices] * eff_min[free_off_indices] + \\\n                       c[free_off_indices] * eff_min[free_off_indices]**2\n            cost_metric = (s[free_off_indices] + min_cost) / eff_min[free_off_indices]\n            sorted_indices = [x for _, x in sorted(zip(cost_metric, free_off_indices), key=lambda pair: pair[0])]\n            for idx in sorted_indices:\n                committed[idx] = True\n                total_min += eff_min[idx]\n                total_max += eff_max[idx]\n                if total_max >= current_load:\n                    break\n    \n    # Update limits for final committed set\n    final_eff_min = eff_min.copy()\n    final_eff_max = eff_max.copy()\n    for i in range(n_units):\n        if committed[i] and u_i_0[i] == 0:  # newly started\n            final_eff_min[i] = p_min[i]\n            final_eff_max[i] = min(p_max[i], p_start[i])\n    \n    total_min = np.sum(final_eff_min[committed])\n    total_max = np.sum(final_eff_max[committed])\n    \n    # Dispatch\n    p_out = np.zeros(n_units)\n    if total_min > current_load:\n        p_out[committed] = final_eff_min[committed]\n    elif total_max < current_load:\n        p_out[committed] = final_eff_max[committed]\n    else:\n        # Lambda iteration\n        tol = 1e-5\n        max_iter = 1000\n        iter_count = 0\n        lam_low = 0\n        lam_high = np.max(b[committed] + 2 * c[committed] * final_eff_max[committed] * (c[committed] > 0) + \n                         b[committed] * (c[committed] == 0))\n        lam = (lam_low + lam_high) / 2\n        p_committed = final_eff_min[committed].copy()\n        \n        while iter_count < max_iter:\n            # Calculate outputs\n            for idx, i in enumerate(np.where(committed)[0]):\n                if c[i] > 0:\n                    desired = (lam - b[i]) / (2 * c[i])\n                    p_committed[idx] = np.clip(desired, final_eff_min[i], final_eff_max[i])\n                else:\n                    if lam < b[i]:\n                        p_committed[idx] = final_eff_min[i]\n                    else:\n                        p_committed[idx] = final_eff_max[i]\n            \n            total_p = np.sum(p_committed)\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n                \n            lam = (lam_low + lam_high) / 2\n            iter_count += 1\n        \n        p_out[committed] = p_committed\n    \n    u_out = committed.astype(int)\n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0001296798,
          "gap_price_rate": 0.0360463335,
          "fitness": 0.0180880066
     },
     {
          "name": "dynamic_commitment_with_dispatch",
          "algorithm": "1. Classify units as must-on, must-off, free-on, or free-off based on prior state and constraints. Must-on units include those that haven't satisfied minimum up-time or whose prior output exceeds shutdown ramp capacity. Must-off units are those that haven't satisfied minimum down-time.  \n2. Initially commit must-on and free-on units.  \n3. Calculate effective power limits:  \n   - For previously online units: min = max(p_min, p_prev - ramp_down), max = min(p_max, p_prev + ramp_up)  \n   - For newly started units: min = p_min, max = min(p_max, start_ramp)  \n4. While total min output > load:  \n   - Sort free-on units by descending (cost at min output)/min_output  \n   - Decommit the highest-cost unit that won't reduce total max output below load  \n   - Update total min/max  \n5. While total max output < load:  \n   - Sort free-off units by ascending (startup + cost at min output)/min_output  \n   - Commit the cheapest unit  \n   - Update total min/max  \n6. Dispatch load to committed units:  \n   - Initialize at effective min outputs  \n   - Use lambda iteration to set outputs, clamping to limits:  \n     a. Solve marginal cost (lambda) via binary search  \n     b. Calculate outputs as (lambda - b_i)/(2c_i) clamped to [min_i, max_i]  \n     c. Iterate until generation matches load within tolerance  \n7. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef dynamic_commitment_with_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract parameters into arrays\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    start_ramp = [unit['p_start_i'] for unit in units_info]\n    shut_ramp = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n    startup_cost = [unit['s_i'] for unit in units_info]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Online previously\n            if t_state[i] < min_up[i] or p_prev[i] > shut_ramp[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline previously\n            if -t_state[i] < min_down[i]:  # t_state negative when offline\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on) | set(free_on)\n    decommitted = set(must_off) | set(free_off)\n    \n    # Calculate effective power limits\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1 and i in committed:\n            eff_min[i] = max(p_min[i], p_prev[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_prev[i] + ramp_up[i])\n        elif i in committed:  # Newly started\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], start_ramp[i])\n        else:\n            eff_min[i] = 0\n            eff_max[i] = 0\n    \n    # Adjust commitment\n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Case 1: Over-commitment (total min output > load)\n    if total_min > current_load:\n        # Sort free-on units by descending cost per MW at min output\n        free_on.sort(key=lambda i: (a[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i], \n                      reverse=True)\n        remove_list = []\n        for i in free_on:\n            if i in committed and not (i in must_on):\n                new_total_max = total_max - eff_max[i]\n                if new_total_max >= current_load:\n                    remove_list.append(i)\n                    total_min -= eff_min[i]\n                    total_max = new_total_max\n                    if total_min <= current_load:\n                        break\n        \n        for i in remove_list:\n            committed.remove(i)\n            eff_min[i] = eff_max[i] = 0\n            free_on.remove(i)\n            decommitted.add(i)\n    \n    # Case 2: Under-commitment (total max output < load)\n    if total_max < current_load:\n        # Sort free-off units by ascending average cost per MW (including startup)\n        free_off.sort(key=lambda i: (startup_cost[i] + a[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i])\n        add_list = []\n        for i in free_off:\n            unit_min = p_min[i]\n            unit_max = min(p_max[i], start_ramp[i])\n            new_total_min = total_min + unit_min\n            new_total_max = total_max + unit_max\n            \n            add_list.append(i)\n            committed.add(i)\n            eff_min[i] = unit_min\n            eff_max[i] = unit_max\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= current_load:\n                break\n        \n        for i in add_list:\n            free_off.remove(i)\n            decommitted.discard(i)\n    \n    # Economic dispatch using lambda iteration\n    comm_list = list(committed)\n    n_comm = len(comm_list)\n    p_dispatch = [eff_min[i] for i in range(n_units)]\n    \n    if n_comm > 0:\n        # Set bounds for lambda (marginal cost)\n        low = min(b[i] + 2*c[i]*eff_min[i] for i in comm_list)\n        high = max(b[i] + 2*c[i]*eff_max[i] for i in comm_list)\n        \n        tol = 0.001  # 0.001 MW tolerance\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_gen = 0\n            for i in comm_list:\n                if c[i] > 0:\n                    p_temp = (lam - b[i]) / (2 * c[i])\n                else:  # Linear cost function\n                    p_temp = eff_max[i] if lam > b[i] else eff_min[i]\n                \n                p_temp = max(eff_min[i], min(p_temp, eff_max[i]))\n                total_gen += p_temp\n                p_dispatch[i] = p_temp\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            elif total_gen < current_load:\n                low = lam\n            else:\n                high = lam\n    else:  # No units committed\n        total_gen = 0\n    \n    # Set outputs\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n        p[i] = p_dispatch[i] if i in committed else 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001297944,
          "gap_price_rate": 0.0360463471,
          "fitness": 0.0180880708
     },
     {
          "name": "refined_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown capacity constraints), must-off (must remain offline due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).\n2. Initially commit must-on and free-on units. Calculate effective min/max outputs considering ramp constraints for currently committed units.\n3. While total effective min output exceeds current load and eligible free-on units exist, turn off the unit with the highest effective min output, ensuring remaining capacity can still meet load.\n4. While total effective max output is below current load and free-off units exist, turn on the most cost-effective unit based on (startup_cost + min_output_cost)/min_output.\n5. For newly committed free-off units, calculate their effective min/max outputs (considering startup ramp limits).\n6. Set outputs of all committed units to their effective min outputs.\n7. Use lambda iteration to distribute remaining load among committed units respecting effective bounds.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef refined_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u_i0 = [unit['u_i_0'] for unit in units_info]\n    t_i0 = [unit['t_i_0'] for unit in units_info]\n    p_i0 = [unit['p_i_0'] for unit in units_info]\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        if u0 == 1:\n            if t_i0[i] < unit['t_on_min_i'] or p_i0[i] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i0[i] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = set(must_on) | set(free_on)\n    effective_min = [0.0] * num_units\n    effective_max = [0.0] * num_units\n    \n    for i in range(num_units):\n        if i in committed:\n            if u_i0[i] == 1:\n                effective_min[i] = max(units_info[i]['p_min_i'], p_i0[i] - units_info[i]['p_down_i'])\n                effective_max[i] = min(units_info[i]['p_max_i'], p_i0[i] + units_info[i]['p_up_i'])\n            else:\n                effective_min[i] = units_info[i]['p_min_i']\n                effective_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(effective_min[i] for i in committed)\n    total_max = sum(effective_max[i] for i in committed)\n    \n    candidate_off = free_on[:]\n    candidate_off.sort(key=lambda i: effective_min[i], reverse=True)\n    for i in candidate_off:\n        if total_min <= current_load:\n            break\n        if total_max - effective_max[i] < current_load:\n            continue\n        committed.remove(i)\n        total_min -= effective_min[i]\n        total_max -= effective_max[i]\n        effective_min[i] = 0\n        effective_max[i] = 0\n    \n    candidate_on = free_off[:]\n    candidate_on.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                                    units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                                    units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / \n                                    units_info[i]['p_min_i'])\n    for i in candidate_on:\n        if total_max >= current_load:\n            break\n        min_i = units_info[i]['p_min_i']\n        max_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        effective_min[i] = min_i\n        effective_max[i] = max_i\n        total_min += min_i\n        total_max += max_i\n    \n    p_out = [0.0] * num_units\n    for i in committed:\n        p_out[i] = effective_min[i]\n    \n    total_alloc = sum(p_out)\n    remaining = current_load - total_alloc\n    dispatch_units = []\n    \n    if remaining > 0 and abs(total_max - total_min) > 1e-6:\n        for i in committed:\n            a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n            p_min = effective_min[i]\n            p_max = effective_max[i]\n            dispatch_units.append((i, b, c, p_min, p_max, p_out[i]))\n        \n        low = min(u[1] for u in dispatch_units)\n        high = max(u[1] + 2*u[2]*u[4] if u[2]>0 else u[1] for u in dispatch_units)\n        tol = 1e-3\n        \n        for _ in range(100):\n            mid = (low + high) / 2.0\n            total_gen = 0.0\n            for i, b, c, p_min, p_max, _ in dispatch_units:\n                if c > 0:\n                    p = min(p_max, max(p_min, (mid - b) / (2*c)))\n                else:\n                    p = p_max if mid > b else p_min\n                total_gen += p\n            if abs(total_gen - current_load) < tol:\n                break\n            if total_gen < current_load:\n                low = mid\n            else:\n                high = mid\n        \n        for idx, (i, b, c, p_min, p_max, _) in enumerate(dispatch_units):\n            if c > 0:\n                p_val = min(p_max, max(p_min, (mid - b) / (2*c)))\n            else:\n                p_val = p_max if mid > b else p_min\n            p_out[i] = p_val\n    \n    u_out = [1 if i in committed else 0 for i in range(num_units)]\n    return np.array([u_out, p_out])",
          "from": "mutation",
          "gap_power_rate": 0.0001297983,
          "gap_price_rate": 0.0360463622,
          "fitness": 0.0180880803
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online and can be turned off with shutdown ramp constraints), and free-off (offline and can be turned on).\n2. Start with must-on and free-on units committed. Calculate effective power bounds for committed units (considering ramp constraints and startup ramp limits for newly committed units).\n3. If total maximum capacity is below the current load, commit free-off units sorted by ascending average cost per MW at minimum output until sufficient capacity is achieved.\n4. If total minimum capacity exceeds the current load, turn off eligible free-on units (prioritized by highest minimum output) while respecting shutdown ramp constraints and load feasibility.\n5. Dispatch load to committed units:\n   - If load \u2265 total maximum capacity, set all units to maximum output.\n   - If load \u2264 total minimum capacity, set all units to minimum output.\n   - Otherwise, perform economic dispatch using lambda iteration to minimize variable costs within effective power bounds.\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed_units = set()\n    must_on, must_off, free_on, free_off = [], [], [], []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        \n        if u_i0 == 1:\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if t_i0 < 0 and -t_i0 < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initially commit must_on and free_on\n    committed_units.update(must_on)\n    committed_units.update(free_on)\n    \n    # Initialize min/max outputs for all units\n    min_outputs = [0.0] * n_units\n    max_outputs = [0.0] * n_units\n    for i in range(n_units):\n        unit = units_info[i]\n        if i in committed_units:\n            if unit['u_i_0'] == 1:\n                min_o = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_o = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_o = unit['p_min_i']\n                max_o = min(unit['p_max_i'], unit['p_start_i'])\n            min_outputs[i] = min_o\n            max_outputs[i] = max_o\n        else:\n            min_outputs[i] = 0.0\n            max_outputs[i] = 0.0\n    \n    total_min = sum(min_outputs[i] for i in committed_units)\n    total_max = sum(max_outputs[i] for i in committed_units)\n    \n    # Commit free-off units if under capacity\n    if total_max < current_load:\n        cost_criterion = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p = unit['p_min_i']\n            cost_val = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * min_p**2) / min_p\n            cost_criterion.append((cost_val, i))\n        cost_criterion.sort(key=lambda x: x[0])\n        \n        for _, idx in cost_criterion:\n            if total_max >= current_load:\n                break\n            unit = units_info[idx]\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n            min_outputs[idx] = min_p\n            max_outputs[idx] = max_p\n            committed_units.add(idx)\n            total_min += min_p\n            total_max += max_p\n    \n    # Turn off free-on units if over capacity and feasible\n    while total_min > current_load:\n        eligible_to_remove = []\n        for i in committed_units:\n            if i in free_on and i not in must_on and units_info[i]['p_i_0'] <= units_info[i]['p_down_i']:\n                eligible_to_remove.append((min_outputs[i], i))\n        \n        if not eligible_to_remove:\n            break\n        eligible_to_remove.sort(key=lambda x: x[0], reverse=True)\n        _, remove_unit = eligible_to_remove[0]\n        \n        # Remove unit and update totals\n        committed_units.remove(remove_unit)\n        total_min -= min_outputs[remove_unit]\n        total_max -= max_outputs[remove_unit]\n        min_outputs[remove_unit] = 0\n        max_outputs[remove_unit] = 0\n        free_on.remove(remove_unit)  # Update free-on list\n    \n    # Prepare outputs array\n    p_outputs = [0.0] * n_units\n    u_outputs = [0] * n_units\n    \n    # Handle dispatch cases\n    active_units = sorted(committed_units)\n    if not active_units:  # No units committed\n        return np.array([u_outputs, p_outputs])\n    \n    if current_load >= total_max:\n        for i in active_units:\n            p_outputs[i] = max_outputs[i]\n            u_outputs[i] = 1\n    elif current_load <= total_min:\n        for i in active_units:\n            p_outputs[i] = min_outputs[i]\n            u_outputs[i] = 1\n    else:\n        min_active = [min_outputs[i] for i in active_units]\n        max_active = [max_outputs[i] for i in active_units]\n        b_active = [units_info[i]['b_i'] for i in active_units]\n        c_active = [units_info[i]['c_i'] for i in active_units]\n        n_active = len(active_units)\n        \n        # Lambda iteration setup\n        lo = min(b_active[i] for i in range(n_active))\n        hi = max(b_active[i] + 2 * c_active[i] * max_active[i] for i in range(n_active))\n        tol = 1e-5\n        iter_count = 0\n        max_iter = 100\n        \n        while hi - lo > tol and iter_count < max_iter:\n            lambda_mid = (lo + hi) / 2\n            total_p = 0.0\n            for i in range(n_active):\n                b = b_active[i]\n                c = c_active[i]\n                if c == 0:  # Linear cost\n                    if lambda_mid < b:\n                        p_i = min_active[i]\n                    else:\n                        p_i = max_active[i]\n                else:\n                    p_unclamped = (lambda_mid - b) / (2 * c)\n                    p_i = max(min_active[i], min(max_active[i], p_unclamped))\n                total_p += p_i\n            \n            if total_p < current_load:\n                lo = lambda_mid\n            else:\n                hi = lambda_mid\n            iter_count += 1\n        \n        # Compute final outputs at converged lambda\n        total_p = 0.0\n        for i in range(n_active):\n            b = b_active[i]\n            c = c_active[i]\n            if c == 0:\n                p_i = max_active[i] if lambda_mid >= b else min_active[i]\n            else:\n                p_i = max(min_active[i], min(max_active[i], (lambda_mid - b) / (2 * c)))\n            idx = active_units[i]\n            p_outputs[idx] = p_i\n            u_outputs[idx] = 1\n    \n    return np.array([u_outputs, p_outputs])",
          "from": "mutation",
          "gap_power_rate": 0.0001301043,
          "gap_price_rate": 0.0360462511,
          "fitness": 0.0180881777
     },
     {
          "name": "enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown ramp constraints), must-off (must remain offline due to min down-time), free-on (online and can be turned off), and free-off (offline and can be turned on).\n2. Commit must-on and free-on units. Compute their effective power bounds considering ramp constraints and startup ramp limits for newly started units.\n3. If the total minimum output exceeds the load, decommit free-on units in descending order of marginal cost per MW at minimum output until the total maximum output remains sufficient to meet the load.\n4. If the total maximum output is below the load, commit free-off units in ascending order of total cost per MW at minimum output, ensuring that adding a unit does not cause the total minimum output to exceed the load.\n5. Dispatch load to committed units:\n   - If the load is below the total minimum output, set all units to their minimum output.\n   - If the load is above the total maximum output, set all units to their maximum output.\n   - Otherwise, use lambda iteration for economic dispatch to meet the load exactly, respecting power bounds.\n6. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_commitment(units_info, load):\n    n = len(units_info)\n    load = load[0]  # current load allocation\n    # Initialize arrays\n    u_outputs = [0] * n\n    p_outputs = [0.0] * n\n    min_p = [0.0] * n\n    max_p = [0.0] * n\n    committed = [False] * n\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if (unit['t_i_0'] < unit['t_on_min_i']) or (unit['p_i_0'] > unit['p_shut_i']):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 2: Initial commitment\n    for i in must_on + free_on:\n        committed[i] = True\n        unit = units_info[i]\n        min_p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_p[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min = sum(min_p[i] for i in range(n) if committed[i])\n    total_max = sum(max_p[i] for i in range(n) if committed[i])\n    \n    # Step 3: Decommit free-on units if over-committed\n    if total_min > load and free_on:\n        # Sort by descending cost per MW at min output\n        def cost_per_mw(i):\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * (min_p[i]**2)\n            return cost / min_p[i] if min_p[i] > 0 else float('inf')\n        \n        free_on_sorted = sorted(free_on, key=cost_per_mw, reverse=True)\n        for i in free_on_sorted:\n            if not committed[i] or total_min <= load:\n                continue\n            if total_max - max_p[i] >= load:\n                committed[i] = False\n                total_min -= min_p[i]\n                total_max -= max_p[i]\n    \n    # Step 4: Commit free-off units if under-committed\n    if total_max < load and free_off:\n        candidate_units = []\n        for i in free_off:\n            unit = units_info[i]\n            min_p_candidate = unit['p_min_i']\n            max_p_candidate = min(unit['p_max_i'], unit['p_start_i'])\n            if min_p_candidate <= max_p_candidate:\n                cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p_candidate + unit['c_i'] * (min_p_candidate**2)\n                cost_per = cost / min_p_candidate if min_p_candidate > 0 else float('inf')\n                candidate_units.append((i, min_p_candidate, max_p_candidate, cost_per))\n        \n        candidate_units.sort(key=lambda x: x[3])\n        for i, min_val, max_val, _ in candidate_units:\n            if committed[i] or total_max >= load:\n                break\n            if total_min + min_val > load:\n                continue\n            committed[i] = True\n            min_p[i] = min_val\n            max_p[i] = max_val\n            total_min += min_val\n            total_max += max_val\n    \n    # Collect committed units and their attributes for dispatch\n    committed_indices = [i for i in range(n) if committed[i]]\n    if not committed_indices:\n        return np.array([u_outputs, p_outputs])\n    \n    # Check bounds and dispatch\n    if load <= total_min:\n        for i in committed_indices:\n            u_outputs[i] = 1\n            p_outputs[i] = min_p[i]\n        return np.array([u_outputs, p_outputs])\n    \n    if load >= total_max:\n        for i in committed_indices:\n            u_outputs[i] = 1\n            p_outputs[i] = max_p[i]\n        return np.array([u_outputs, p_outputs])\n    \n    # Lambda iteration for economic dispatch\n    min_vals = [min_p[i] for i in committed_indices]\n    max_vals = [max_p[i] for i in committed_indices]\n    b_vals = [units_info[i]['b_i'] for i in committed_indices]\n    c_vals = [units_info[i]['c_i'] for i in committed_indices]\n    \n    # Find lambda bounds\n    marg_costs_min = [b + 2*c*min_p for b, c, min_p in zip(b_vals, c_vals, min_vals)]\n    marg_costs_max = [b + 2*c*max_p if c > 0 else b for b, c, max_p in zip(b_vals, c_vals, max_vals)]\n    low = min(marg_costs_min)\n    high = max(marg_costs_max)\n    \n    # Binary search for lambda\n    p_dispatch = min_vals.copy()\n    tol = 0.01  # tolerance for load mismatch (MW)\n    max_iter = 1000\n    iter_count = 0\n    total = sum(p_dispatch)\n    \n    while abs(total - load) > tol and iter_count < max_iter:\n        mid_lambda = (low + high) / 2\n        total = 0.0\n        for j in range(len(committed_indices)):\n            b = b_vals[j]\n            c = c_vals[j]\n            minp = min_vals[j]\n            maxp = max_vals[j]\n            if c > 0:\n                p_val = (mid_lambda - b) / (2 * c)\n                p_val = max(minp, min(maxp, p_val))\n            else:  # linear cost unit\n                p_val = minp if mid_lambda < b else maxp\n            p_dispatch[j] = p_val\n            total += p_val\n        \n        if total < load:\n            low = mid_lambda\n        else:\n            high = mid_lambda\n        iter_count += 1\n    \n    # Assign dispatch results to outputs\n    for idx, i in enumerate(committed_indices):\n        u_outputs[i] = 1\n        p_outputs[i] = p_dispatch[idx]\n    \n    return np.array([u_outputs, p_outputs])",
          "from": "crossover",
          "gap_power_rate": 0.0001308294,
          "gap_price_rate": 0.0360464107,
          "fitness": 0.0180886201
     },
     {
          "name": "enhanced_rolling_commitment_refined",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online and can be turned off), and free-off (offline and can be turned on).\n2. Commit must-on and free-on units initially. Compute their power bounds considering ramp constraints: for previously online units, effective min = max(p_min, p_prev - ramp_down) and effective max = min(p_max, p_prev + ramp_up); for newly started units, effective min = p_min, effective max = min(p_max, start_ramp).\n3. Calculate total effective min and max outputs from committed units. If total max < current load, commit free-off units sorted by ascending average cost per MW at min output [(startup_cost + min_output_cost) / min_output], until total max >= load.\n4. If total min > current load, decommit free-on units (eligible if p_prev <= shutdown_ramp) sorted by descending average cost per MW at min output [(min_output_cost) / min_output], while ensuring remaining total max >= load.\n5. Dispatch using lambda iteration:\n   a. For committed units, set initial output to effective min if load <= total min, or effective max if load >= total max.\n   b. Otherwise, use binary search on lambda to find marginal cost where sum of outputs equals load, calculating outputs as (lambda - b_i)/(2*c_i) clamped to effective bounds (handling linear units at min/max when c_i=0).\n6. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u_vector = np.zeros(n_units)\n    p_vector = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        \n        if u0 == 1:\n            if (t0 < t_on_min) or (p0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t0 < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Step 2: Initial commitment and bounds calculation\n    committed = set(must_on + free_on)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        if i in committed:\n            if unit['u_i_0'] == 1:\n                eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                eff_min[i] = unit['p_min_i']\n                eff_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            eff_min[i] = 0\n            eff_max[i] = 0\n    \n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Step 3: Commit free-off units if under capacity\n    if total_max < current_load:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            p_min = unit['p_min_i']\n            min_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * (p_min ** 2)\n            cost_per_mw = (unit['s_i'] + min_cost) / p_min if p_min > 0 else float('inf')\n            candidates.append((i, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[1])\n        \n        for idx, _ in candidates:\n            if total_max >= current_load:\n                break\n            committed.add(idx)\n            eff_min[idx] = units_info[idx]['p_min_i']\n            eff_max[idx] = min(units_info[idx]['p_max_i'], units_info[idx]['p_start_i'])\n            total_min += eff_min[idx]\n            total_max += eff_max[idx]\n    \n    # Step 4: Decommit free-on units if over-committed\n    if total_min > current_load:\n        candidates = []\n        for i in free_on:\n            if i not in committed:\n                continue\n            unit = units_info[i]\n            if unit['p_i_0'] > unit['p_shut_i']:\n                continue\n            p_min = unit['p_min_i']\n            min_cost = unit['a_i'] + unit['b_i'] * p_min + unit['c_i'] * (p_min ** 2)\n            cost_per_mw = min_cost / p_min if p_min > 0 else float('inf')\n            candidates.append((i, cost_per_mw))\n        \n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for idx, _ in candidates:\n            if total_min <= current_load:\n                break\n            new_total_max = total_max - eff_max[idx]\n            if new_total_max < current_load:\n                continue\n            committed.remove(idx)\n            total_min -= eff_min[idx]\n            total_max = new_total_max\n            eff_min[idx] = 0\n            eff_max[idx] = 0\n    \n    # Step 5: Dispatch power\n    # Case 1: All units at min\n    if current_load <= total_min:\n        for i in committed:\n            p_vector[i] = eff_min[i]\n    \n    # Case 2: All units at max\n    elif current_load >= total_max:\n        for i in committed:\n            p_vector[i] = eff_max[i]\n    \n    # Case 3: Lambda iteration dispatch\n    else:\n        tol_lambda = 0.001\n        tol_power = 0.01\n        \n        low = min(unit['b_i'] + 2 * unit['c_i'] * eff_min[i] \n                 for i, unit in enumerate(units_info) if i in committed)\n        high = max(unit['b_i'] + 2 * unit['c_i'] * eff_max[i] \n                  for i, unit in enumerate(units_info) if i in committed)\n        \n        # Binary search for optimal lambda\n        while high - low > tol_lambda:\n            mid_lambda = (low + high) / 2\n            total_p = 0\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] > 0:\n                    p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(eff_min[i], min(eff_max[i], p_i))\n                    total_p += p_i\n                else:\n                    p_i = eff_max[i] if mid_lambda >= unit['b_i'] else eff_min[i]\n                    total_p += p_i\n            \n            if total_p < current_load:\n                low = mid_lambda\n            else:\n                high = mid_lambda\n        \n        # Compute final outputs with selected lambda\n        lambda_opt = (low + high) / 2\n        for i in committed:\n            unit = units_info[i]\n            if unit['c_i'] > 0:\n                p_i = (lambda_opt - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(eff_min[i], min(eff_max[i], p_i))\n                p_vector[i] = p_i\n            else:\n                p_vector[i] = eff_max[i] if lambda_opt >= unit['b_i'] else eff_min[i]\n    \n    # Set commitment states and return\n    for i in committed:\n        u_vector[i] = 1\n        \n    return np.array([u_vector, p_vector])",
          "from": "mutation",
          "gap_power_rate": 0.0001587082,
          "gap_price_rate": 0.0360554785,
          "fitness": 0.0181070934
     }
]