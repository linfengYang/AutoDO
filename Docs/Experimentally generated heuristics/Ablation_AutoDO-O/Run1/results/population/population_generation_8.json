[
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (cannot be turned off), must-off (cannot be turned on), free-on (online and can be turned off), and free-off (offline and can be turned on)\n2. Commit must-run units and calculate their effective min/max outputs based on ramp constraints\n3. If total minimum output exceeds load, decommit free-on units in descending order of min output\n4. If total maximum output is below load, commit additional units from candidate list (free-on + free-off) sorted by cost per MW at minimum output\n5. Dispatch using lambda iteration to meet load exactly within generation limits\n6. For all non-committed units, set status to off and output to zero\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = set()\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        must_run_cond = (\n            u_i0 == 1 and \n            (t_i0 > 0 and t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])\n        )\n        # Must-off conditions\n        must_off_cond = (\n            u_i0 == 0 and \n            abs(t_i0) < unit['t_off_min_i']\n        )\n        \n        if must_run_cond:\n            must_run.append(i)\n            committed.add(i)\n        elif must_off_cond:\n            must_off.append(i)\n        elif u_i0 == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Compute effective min/max for must-run units\n    total_min = 0.0\n    total_max = 0.0\n    must_run_limits = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        # Compute effective limits\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        total_min += eff_min\n        total_max += eff_max\n        must_run_limits.append((i, eff_min, eff_max))\n    \n    # Candidate handling\n    candidate_list = []\n    candidate_indices = []\n    \n    # Free-on candidates\n    for i in free_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        cost_at_min = unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2)\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-on'))\n    \n    # Free-off candidates\n    for i in free_off:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        eff_min = p_min\n        eff_max = min(p_max, unit['p_start_i'])\n        cost_at_min = (unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2) + \n                       unit['s_i'])\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-off'))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Over-commitment handling\n    if total_min > current_load and free_on:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in sorted(\n            candidate_list[:len(free_on)], \n            key=lambda x: units_info[x[1]]['p_min_i'], \n            reverse=True\n        ):\n            if i in free_on:\n                if total_min - eff_min >= current_load:\n                    total_min -= eff_min\n                    total_max -= eff_max\n                else:\n                    break\n    \n    # Under-commitment handling\n    if total_max < current_load and candidate_list:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in candidate_list:\n            if unit_type == 'free-off' and i in free_off:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n            elif unit_type == 'free-on' and i in free_on:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n    \n    # Dispatch preparation\n    dispatch_list = []\n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        if u_i0 == 1:  # Was online\n            eff_min = max(p_min, p_i0 - ramp_down)\n            eff_max = min(p_max, p_i0 + ramp_up)\n        else:  # Was offline (free-off candidate)\n            eff_min = p_min\n            eff_max = min(p_max, unit['p_start_i'])\n        \n        dispatch_list.append((\n            eff_min, eff_max, \n            unit['b_i'], unit['c_i'], i\n        ))\n    \n    # Economic dispatch using lambda iteration\n    if len(dispatch_list) == 0:\n        # Default to zero for all units\n        return schedules\n    \n    # Lambda iteration setup\n    low_lambda = -1e6\n    high_lambda = 1e6\n    tol = 0.1\n    max_iter = 1000\n    p_allocations = np.zeros(len(dispatch_list))\n    \n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_gen = 0.0\n        \n        for idx, (p_min, p_max, b, c, unit_idx) in enumerate(dispatch_list):\n            if c == 0:  # Linear cost\n                if lambda_mid < b:\n                    p = p_min\n                else:\n                    p = p_max\n            else:  # Quadratic cost\n                p_ideal = (lambda_mid - b) / (2 * c)\n                p = max(p_min, min(p_ideal, p_max))\n            \n            p_allocations[idx] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    # Apply allocations to committed units\n    for (p_min, p_max, b, c, unit_idx), p_val in zip(dispatch_list, p_allocations):\n        schedules[0][unit_idx] = 1\n        schedules[1][unit_idx] = p_val\n    \n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.00544046,
          "gap_price_rate": 0.00878014,
          "fitness": 0.0071103
     },
     {
          "name": "refined_hybrid_commitment_v3",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v3(units_info, load):\n    load_current = load[0]\n    n = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    committed = [False] * n\n    min_p = [0] * n\n    max_p = [0] * n\n\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n\n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            committed[i] = True\n        else:\n            off_duration = -t_i0\n            if off_duration < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n\n    for i in range(n):\n        if committed[i]:\n            p_i0 = units_info[i]['p_i_0']\n            min_p[i] = max(units_info[i]['p_min_i'], p_i0 - units_info[i]['p_down_i'])\n            max_p[i] = min(units_info[i]['p_max_i'], p_i0 + units_info[i]['p_up_i'])\n        else:\n            min_p[i] = units_info[i]['p_min_i']\n            max_p[i] = units_info[i]['p_max_i']\n\n    total_min = sum(min_p[i] for i in range(n) if committed[i])\n    total_max = sum(max_p[i] for i in range(n) if committed[i])\n\n    # Step 5: Decommit free-on units if over-generated\n    changed = True\n    while changed and total_min > load_current:\n        changed = False\n        best_candidate, best_cost = None, -10**12\n        for i in free_on:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= load_current <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n                if cost_per_mw > best_cost:\n                    best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is not None:\n            committed[best_candidate] = False\n            total_min -= min_p[best_candidate]\n            total_max -= max_p[best_candidate]\n            changed = True\n\n    # Step 6: Commit free-off units if under-generated\n    while total_max < load_current and free_off:\n        best_candidate, best_cost = None, 10**12\n        for i in free_off:\n            min_p0 = units_info[i]['p_min_i']\n            startup_cost = units_info[i]['s_i']\n            cost_per_mw = (startup_cost + units_info[i]['a_i'] + units_info[i]['b_i'] * min_p0 + units_info[i]['c_i'] * min_p0**2) / min_p0\n            if cost_per_mw < best_cost:\n                best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is None:\n            break\n        min_p0 = units_info[best_candidate]['p_min_i']\n        max_p_bound = min(units_info[best_candidate]['p_max_i'], units_info[best_candidate]['p_start_i'])\n        min_p[best_candidate], max_p[best_candidate] = min_p0, max_p_bound\n        committed[best_candidate] = True\n        total_min += min_p0\n        total_max += max_p_bound\n        free_off.remove(best_candidate)\n        if total_max >= load_current:\n            break\n\n    # Step 7: Post-commitment decommitment of expensive free-on units\n    changed = True\n    while changed:\n        changed = False\n        best_candidate, best_cost = None, -10**12\n        for i in free_on:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= load_current <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n                if cost_per_mw > best_cost:\n                    best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is not None:\n            committed[best_candidate] = False\n            total_min -= min_p[best_candidate]\n            total_max -= max_p[best_candidate]\n            changed = True\n\n    # Step 8: Dispatch\n    output_p = [0] * n\n    if load_current <= total_min:\n        for i in range(n):\n            if committed[i]:\n                output_p[i] = min_p[i]\n    elif load_current >= total_max:\n        for i in range(n):\n            if committed[i]:\n                output_p[i] = max_p[i]\n    else:\n        committed_indices = [i for i in range(n) if committed[i]]\n        lo = min(unit['b_i'] + 2 * unit['c_i'] * min_p[i] for i, unit in enumerate(units_info) if committed[i])\n        hi = max(unit['b_i'] + 2 * unit['c_i'] * max_p[i] for i, unit in enumerate(units_info) if committed[i])\n        tol = 0.001\n        while hi - lo > tol:\n            mid = (lo + hi) / 2\n            total_p = 0\n            for i in committed_indices:\n                b, c = units_info[i]['b_i'], units_info[i]['c_i']\n                min_val, max_val = min_p[i], max_p[i]\n                if c == 0:\n                    p_val = min_val if mid < b else max_val\n                else:\n                    p_unbound = (mid - b) / (2 * c)\n                    p_val = max(min_val, min(max_val, p_unbound))\n                total_p += p_val\n            if total_p < load_current:\n                lo = mid\n            else:\n                hi = mid\n        mid = (lo + hi) / 2\n        for i in committed_indices:\n            b, c = units_info[i]['b_i'], units_info[i]['c_i']\n            min_val, max_val = min_p[i], max_p[i]\n            if c == 0:\n                output_p[i] = min_val if mid < b else max_val\n            else:\n                p_unbound = (mid - b) / (2 * c)\n                output_p[i] = max(min_val, min(max_val, p_unbound))\n\n    u_i_list = [1 if committed[i] else 0 for i in range(n)]\n    schedules = np.array([u_i_list, output_p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054548168,
          "gap_price_rate": 0.0091024797,
          "fitness": 0.0072786483
     },
     {
          "name": "enhanced_refined_hybrid_commitment_v4",
          "algorithm": "1. Classify units into must-run, must-off, free-on, and free-off based on operational constraints.\n2. Calculate effective power limits considering ramp and startup/shutdown constraints.\n3. Initialize commitment with must-run and free-on units.\n4. Decomission expensive free-on units if system is over-generating (total min > load), ensuring feasibility.\n5. Commit economical free-off units if system is under-generating (total max < load) using (startup + min-output cost)/min-output metric.\n6. Perform secondary decommissioning of free-on units if feasible to reduce costs.\n7. Dispatch using min/max outputs if load is at bounds; otherwise use lambda iteration with gap adjustment.\n8. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_hybrid_commitment_v4(units_info, load):\n    L = load[0]  # current load\n    n_units = len(units_info)\n    \n    # Initialize classification lists\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize commitment\n    committed = set(must_on + free_on)\n    \n    # Calculate effective power limits\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if i in committed:\n            if unit['u_i_0'] == 1:\n                effective_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                effective_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                effective_min[i] = unit['p_min_i']\n                effective_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            effective_min[i] = 0\n            effective_max[i] = 0\n    \n    # Calculate total min/max\n    total_min = np.sum([effective_min[i] for i in committed])\n    total_max = np.sum([effective_max[i] for i in committed])\n    \n    # Decommitment for over-generation\n    if total_min > L:\n        decommission_candidates = free_on.copy()\n        while decommission_candidates and total_min > L:\n            feasible_removals = []\n            for i in decommission_candidates:\n                new_min = total_min - effective_min[i]\n                new_max = total_max - effective_max[i]\n                if new_min <= L <= new_max:\n                    cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + \n                                 units_info[i]['c_i'] * effective_min[i]**2) / effective_min[i]\n                    feasible_removals.append((cost_per_mw, i))\n            \n            if not feasible_removals:\n                break\n                \n            _, candidate = max(feasible_removals)\n            committed.remove(candidate)\n            decommission_candidates.remove(candidate)\n            free_on.remove(candidate)\n            total_min -= effective_min[candidate]\n            total_max -= effective_max[candidate]\n            effective_min[candidate] = 0\n            effective_max[candidate] = 0\n    \n    # Commitment for under-generation\n    if total_max < L:\n        candidate_scores = []\n        for i in free_off:\n            if units_info[i]['p_min_i'] > 0:\n                min_cost = (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                          units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i']\n            else:\n                min_cost = float('inf')\n            candidate_scores.append((min_cost, i))\n        \n        candidate_scores.sort(key=lambda x: x[0])\n        while candidate_scores and total_max < L:\n            cost, candidate = candidate_scores.pop(0)\n            committed.add(candidate)\n            free_off.remove(candidate)\n            new_min = units_info[candidate]['p_min_i']\n            new_max = min(units_info[candidate]['p_max_i'], units_info[candidate]['p_start_i'])\n            effective_min[candidate] = new_min\n            effective_max[candidate] = new_max\n            total_min += new_min\n            total_max += new_max\n    \n    # Post-commitment decommissioning\n    decommission_candidates = free_on.copy()\n    while decommission_candidates:\n        feasible_removals = []\n        for i in decommission_candidates:\n            new_min = total_min - effective_min[i]\n            new_max = total_max - effective_max[i]\n            if new_min <= L <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + \n                             units_info[i]['c_i'] * effective_min[i]**2) / effective_min[i]\n                feasible_removals.append((cost_per_mw, i))\n        \n        if not feasible_removals:\n            break\n            \n        _, candidate = max(feasible_removals)\n        committed.remove(candidate)\n        decommission_candidates.remove(candidate)\n        total_min -= effective_min[candidate]\n        total_max -= effective_max[candidate]\n        effective_min[candidate] = 0\n        effective_max[candidate] = 0\n    \n    # Dispatch\n    p_output = np.zeros(n_units)\n    u_status = np.zeros(n_units)\n    if committed:\n        if L <= total_min:\n            for i in committed:\n                p_output[i] = effective_min[i]\n                u_status[i] = 1\n        elif L >= total_max:\n            for i in committed:\n                p_output[i] = effective_max[i]\n                u_status[i] = 1\n        else:\n            # Identify dispatchable units with non-zero c_i\n            quad_units = []\n            for i in committed:\n                if units_info[i]['c_i'] > 0:\n                    quad_units.append(i)\n                else:\n                    # Initialize linear units to min output\n                    p_output[i] = effective_min[i]\n                    u_status[i] = 1\n            \n            if quad_units:\n                # Set bounds and coefficients for quad units\n                L_i = [effective_min[i] for i in quad_units]\n                U_i = [effective_max[i] for i in quad_units]\n                b_i = [units_info[i]['b_i'] for i in quad_units]\n                c_i = [units_info[i]['c_i'] for i in quad_units]\n                \n                # Calculate residual load after linear units\n                residual_L = L - np.sum(p_output)\n                low_lambda = min(b + 2*c*lb for (b, c, lb) in zip(b_i, c_i, L_i))\n                high_lambda = max(b + 2*c*ub for (b, c, ub) in zip(b_i, c_i, U_i))\n                \n                # Lambda iteration\n                tol = 0.01\n                while (high_lambda - low_lambda) > tol:\n                    mid_lambda = (low_lambda + high_lambda) / 2\n                    total = 0\n                    for idx, i in enumerate(quad_units):\n                        p_val = (mid_lambda - b_i[idx]) / (2 * c_i[idx])\n                        p_val = max(L_i[idx], min(U_i[idx], p_val))\n                        total += p_val\n                    if total < residual_L:\n                        low_lambda = mid_lambda\n                    else:\n                        high_lambda = mid_lambda\n                \n                # Assign quad unit outputs\n                for idx, i in enumerate(quad_units):\n                    p_val = (low_lambda - b_i[idx]) / (2 * c_i[idx])\n                    p_output[i] = max(L_i[idx], min(U_i[idx], p_val))\n                    u_status[i] = 1\n                \n                # Gap distribution\n                total_dispatch = np.sum(p_output)\n                gap = residual_L - total_dispatch\n                if abs(gap) > 1e-5:\n                    if gap > 0:\n                        candidates = [i for i in quad_units if p_output[i] < U_i[quad_units.index(i)]]\n                        candidates.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i])\n                        for i in candidates:\n                            avail = effective_max[i] - p_output[i]\n                            addition = min(avail, gap)\n                            p_output[i] += addition\n                            gap -= addition\n                            if gap <= 0:\n                                break\n                    else:\n                        gap = abs(gap)\n                        candidates = [i for i in quad_units if p_output[i] > L_i[quad_units.index(i)]]\n                        candidates.sort(key=lambda i: -(units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i]))\n                        for i in candidates:\n                            avail = p_output[i] - effective_min[i]\n                            reduction = min(avail, gap)\n                            p_output[i] -= reduction\n                            gap -= reduction\n                            if gap <= 0:\n                                break\n    \n    # Build output array\n    schedules = np.vstack((u_status, p_output))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054284899,
          "gap_price_rate": 0.0091396508,
          "fitness": 0.0072840704
     },
     {
          "name": "enhanced_commitment_dispatch_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Initially commit must-on and free-on units. Compute effective power bounds for these units considering ramp constraints.\n3. If total effective minimum output exceeds load, iteratively decommit highest-cost-per-MW free-on units (prioritizing units with highest (a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) while ensuring remaining units can still meet load.\n4. If total effective maximum output is below load, iteratively commit most cost-effective free-off units (prioritizing units with lowest (s_i + a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) until generation capacity meets or exceeds load.\n5. If load falls between adjusted total minimum and maximum, decommit any expensive free-on units that can be removed while maintaining load feasibility.\n6. Dispatch power to committed units:\n   - If total min > load: set all units to minimum output (over-generation)\n   - If total max < load: set all units to maximum output (under-generation)\n   - Else: perform economic dispatch via lambda iteration to minimize variable costs while satisfying load exactly.\n7. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    \n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            online_constrained = (t_i0 > 0 and t_i0 < t_on_min) or (p_i0 > unit['p_shut_i'])\n            if online_constrained:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            offline_constrained = (t_i0 < 0 and abs(t_i0) < t_off_min)\n            if offline_constrained:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment (must-on + free-on)\n    committed = set(must_on) | set(free_on)\n    for i in committed:\n        u_current[i] = 1\n        unit = units_info[i]\n        prev_power = unit['p_i_0']\n        min_bound[i] = max(unit['p_min_i'], prev_power - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], prev_power + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed)\n    total_max = sum(max_bound[i] for i in committed)\n    \n    # Decommit free-on units if over-generation\n    if total_min > current_load:\n        changed = True\n        while changed and total_min > current_load:\n            changed = False\n            free_on_committed = [i for i in free_on if i in committed]\n            if not free_on_committed:\n                break\n                \n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_max >= current_load:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n                    changed = True\n                    break\n    \n    # Commit free-off units if under-generation\n    if total_min <= current_load and total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed]\n        if free_off_available:\n            costs, min_vals, max_vals = [], [], []\n            for i in free_off_available:\n                unit = units_info[i]\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n                s, a, b, c = unit['s_i'], unit['a_i'], unit['b_i'], unit['c_i']\n                cost = (s + a + b*min_val + c*min_val**2) / min_val\n                costs.append(cost)\n                min_vals.append(min_val)\n                max_vals.append(max_val)\n            \n            idxs_sorted = np.argsort(costs)\n            for idx in idxs_sorted:\n                i = free_off_available[idx]\n                min_val, max_val = min_vals[idx], max_vals[idx]\n                new_min = total_min + min_val\n                new_max = total_max + max_val\n                committed.add(i)\n                u_current[i] = 1\n                min_bound[i], max_bound[i] = min_val, max_val\n                total_min, total_max = new_min, new_max\n                if new_max >= current_load:\n                    break\n    \n    # Final decommitment pass for expensive free-on units\n    if total_min <= current_load <= total_max:\n        free_on_committed = [i for i in free_on if i in committed]\n        if free_on_committed:\n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_min <= current_load <= new_max:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n    \n    # Dispatch power to committed units\n    if committed:\n        if total_min > current_load:\n            for i in committed:\n                p_current[i] = min_bound[i]\n        elif total_max < current_load:\n            for i in committed:\n                p_current[i] = max_bound[i]\n        else:\n            low, high = None, None\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * min_bound[i]\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * max_bound[i]\n                low = marginal_min if low is None else min(low, marginal_min)\n                high = marginal_max if high is None else max(high, marginal_max)\n            \n            if low == high:\n                for i in committed:\n                    p_current[i] = min_bound[i]\n            else:\n                for _ in range(100):\n                    lam = (low + high) / 2\n                    total_power = 0\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] > 0:\n                            p = (lam - unit['b_i']) / (2 * unit['c_i'])\n                            p = max(min_bound[i], min(max_bound[i], p))\n                            total_power += p\n                    \n                    if abs(total_power - current_load) < 1e-5:\n                        break\n                    elif total_power < current_load:\n                        low = lam\n                    else:\n                        high = lam\n                \n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_current[i] = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_current[i] = max(min_bound[i], min(max_bound[i], p_current[i]))\n    \n    return np.array([u_current, p_current])",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "refined_dynamic_hybrid_commitment_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online and decomittable), and free-off (offline and committable)\n2. Initially commit must-on and free-on units, compute effective power bounds considering ramp constraints\n3. Decomission highest cost/MW free-on units if over-generation exists while ensuring feasibility\n4. Commit free-off units with lowest (startup + min-output cost)/min-output if under-generation exists\n5. Post-commitment decomissioning of expensive free-on units that can be safely removed\n6. Dispatch by setting outputs to min/max or via \u03bb-iteration economic dispatch\n7. Set non-committed units to off (0 output)\n\n",
          "code": "import numpy as np\n\ndef refined_dynamic_hybrid_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i0 < t_off_min_i:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = must_on[:] + free_on[:]\n    free_on_committed = free_on[:]\n    \n    total_min = 0\n    total_max = 0\n    for i in committed:\n        unit = units_info[i]\n        min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    current_total_min = total_min\n    current_total_max = total_max\n    \n    # Decommit free-on if over-generation\n    while current_total_min > current_load and free_on_committed:\n        candidates = []\n        for i in free_on_committed:\n            new_total_max = current_total_max - max_eff[i]\n            if new_total_max >= current_load:\n                unit = units_info[i]\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * (min_eff[i]**2)) / min_eff[i]\n                candidates.append((i, cost_per_mw))\n        \n        if not candidates:\n            break\n        \n        i_candidate = max(candidates, key=lambda x: x[1])[0]\n        committed.remove(i_candidate)\n        free_on_committed.remove(i_candidate)\n        current_total_min -= min_eff[i_candidate]\n        current_total_max -= max_eff[i_candidate]\n    \n    # Commit free-off if under-generation\n    while current_total_max < current_load and free_off:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * (min_i**2)) / min_i\n            candidates.append((i, cost_per_mw, min_i, max_i))\n        \n        if not candidates:\n            break\n        \n        i_candidate, _, min_candidate, max_candidate = min(candidates, key=lambda x: x[1])\n        committed.append(i_candidate)\n        free_off.remove(i_candidate)\n        min_eff[i_candidate] = min_candidate\n        max_eff[i_candidate] = max_candidate\n        current_total_min += min_candidate\n        current_total_max += max_candidate\n    \n    # Post-commitment decommitment\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        candidates = []\n        for i in free_on_committed:\n            unit = units_info[i]\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * (min_eff[i]**2)) / min_eff[i]\n            candidates.append((i, cost_per_mw))\n        \n        if not candidates:\n            break\n        \n        candidates_sorted = sorted(candidates, key=lambda x: x[1], reverse=True)\n        for cand in candidates_sorted:\n            i_candidate = cand[0]\n            new_total_min = current_total_min - min_eff[i_candidate]\n            new_total_max = current_total_max - max_eff[i_candidate]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                committed.remove(i_candidate)\n                free_on_committed.remove(i_candidate)\n                current_total_min = new_total_min\n                current_total_max = new_total_max\n                changed = True\n                break\n    \n    # Dispatch\n    p_outputs = [0] * n_units\n    if current_total_min >= current_load:\n        for i in committed:\n            p_outputs[i] = min_eff[i]\n    elif current_total_max <= current_load:\n        for i in committed:\n            p_outputs[i] = max_eff[i]\n    else:\n        bs, cs, mins_arr, maxs_arr, indices = [], [], [], [], []\n        for i in committed:\n            unit = units_info[i]\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n            mins_arr.append(min_eff[i])\n            maxs_arr.append(max_eff[i])\n            indices.append(i)\n        \n        low_lambda = min(b_i + 2*c_i*min_i for b_i, c_i, min_i in zip(bs, cs, mins_arr))\n        high_lambda = max(b_i + 2*c_i*max_i for b_i, c_i, max_i in zip(bs, cs, maxs_arr))\n        \n        p_alloc = [0] * len(committed)\n        tol, max_iter = 1e-6, 1000\n        iter_count = 0\n        \n        while (high_lambda - low_lambda) > tol and iter_count < max_iter:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_p = 0\n            for idx in range(len(committed)):\n                desired = (mid_lambda - bs[idx]) / (2 * cs[idx])\n                p_alloc[idx] = max(mins_arr[idx], min(maxs_arr[idx], desired))\n                total_p += p_alloc[idx]\n            \n            if total_p < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            iter_count += 1\n        \n        for idx, i in enumerate(indices):\n            p_outputs[i] = p_alloc[idx]\n    \n    u_states = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_states, p_outputs])",
          "from": "mutation",
          "gap_power_rate": 0.005428589,
          "gap_price_rate": 0.009140149,
          "fitness": 0.007284369
     },
     {
          "name": "enhanced_rolling_commitment_dispatch_v2",
          "algorithm": "1. Classify units into must-on (constrained online), must-off (constrained offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Commit must-on and free-on units. Compute effective power bounds considering ramp constraints and startup/shutdown limits.\n3. If total effective minimum output exceeds load, iteratively decommit highest variable cost-per-MW free-on units while ensuring remaining units can satisfy load constraints.\n4. If total effective maximum output is below load, iteratively commit lowest (startup cost + min-output cost)/min-output free-off units until generation capacity meets or exceeds load.\n5. After step 4, perform post-commitment decommitment of highest variable cost-per-MW free-on units while maintaining load feasibility.\n6. Dispatch load to committed units: set outputs to minimum if load \u2264 total minimum; set to maximum if load \u2265 total maximum; otherwise perform economic dispatch via lambda iteration.\n7. Set all non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch_v2(units_info, load):\n    n = len(units_info)\n    u_current = [0] * n\n    p_current = [0] * n\n    effective_min = [0] * n\n    effective_max = [0] * n\n    categories = [''] * n\n    \n    current_load = load[0]\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                categories[i] = 'must-on'\n            else:\n                categories[i] = 'free-on'\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                categories[i] = 'must-off'\n            else:\n                categories[i] = 'free-off'\n    \n    # Initialize committed units and total capacities\n    committed = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Step 2: Commit must-on and free-on units, compute effective bounds\n    for i, unit in enumerate(units_info):\n        if categories[i] in ['must-on', 'free-on']:\n            u_current[i] = 1\n            committed.append(i)\n            if unit['u_i_0'] == 1:\n                min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n            effective_min[i] = min_val\n            effective_max[i] = max_val\n            total_min += min_val\n            total_max += max_val\n    \n    # Collect free-on units in committed set\n    free_on_committed = [i for i in committed if categories[i] == 'free-on']\n    \n    # Step 3: Over-generation decommitment\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed if categories[i] == 'free-on' and u_current[i] == 1]\n        if not free_on_committed:\n            break\n        candidates = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + units_info[i]['c_i'] * effective_min[i] ** 2\n            cost_per_mw = cost / effective_min[i]\n            candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for (i, cost_per_mw) in candidates:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u_current[i] = 0\n                committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 4: Under-generation commitment\n    free_off = [i for i in range(n) if categories[i] == 'free-off' and u_current[i] == 0]\n    candidates = []\n    for i in free_off:\n        min_val = units_info[i]['p_min_i']\n        start_cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_val + units_info[i]['c_i'] * min_val ** 2\n        cost_per_mw = start_cost / min_val\n        candidates.append((i, cost_per_mw))\n    candidates.sort(key=lambda x: x[1])\n    \n    for (i, cost_per_mw) in candidates:\n        if total_max >= current_load:\n            break\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        u_current[i] = 1\n        committed.append(i)\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 5: Post-commitment decommitment\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed if categories[i] == 'free-on' and u_current[i] == 1]\n        if not free_on_committed:\n            break\n        candidates = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + units_info[i]['c_i'] * effective_min[i] ** 2\n            cost_per_mw = cost / effective_min[i]\n            candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for (i, cost_per_mw) in candidates:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u_current[i] = 0\n                committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 6: Dispatch\n    if abs(current_load - total_min) < 1e-6:\n        for i in committed:\n            p_current[i] = effective_min[i]\n    elif abs(current_load - total_max) < 1e-6:\n        for i in committed:\n            p_current[i] = effective_max[i]\n    else:\n        low = 0\n        high = 0\n        for i in committed:\n            mc_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_min[i]\n            mc_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_max[i]\n            if mc_min < low:\n                low = mc_min\n            if mc_max > high:\n                high = mc_max\n        \n        if low == 0 and high == 0:\n            low = min(unit['b_i'] for unit in units_info)\n            high = max(unit['b_i'] for unit in units_info)\n        \n        tol = 0.001\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2.0\n            total_p = 0.0\n            for i in committed:\n                c = units_info[i]['c_i']\n                b = units_info[i]['b_i']\n                if c == 0:\n                    if lam >= b:\n                        p = effective_max[i]\n                    else:\n                        p = effective_min[i]\n                else:\n                    p_ideal = (lam - b) / (2 * c)\n                    p = max(effective_min[i], min(effective_max[i], p_ideal))\n                p_current[i] = p\n                total_p += p\n            \n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                low = lam\n            else:\n                high = lam\n    \n    # Step 7: Set non-committed units\n    for i in range(n):\n        if not u_current[i]:\n            p_current[i] = 0.0\n    \n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054286675,
          "gap_price_rate": 0.009140107,
          "fitness": 0.0072843873
     },
     {
          "name": "refined_enhanced_dynamic_commitment",
          "algorithm": "1. Classify units into must-on (constrained to remain online due to min up-time or shutdown constraints), must-off (constrained to remain offline due to min down-time), free-on (online and can be turned off), free-off (offline and can be turned on).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints (previous online units: min=max(p_min, p_prev-ramp_down), max=min(p_max, p_prev+ramp_up)).\n3. Decommit free-on units: While total effective min > load, find candidate free-on units removable without violating load constraints (remaining total_min \u2264 load and total_max \u2265 load). Decommit candidate with highest cost per MW at min (a_i + b_i\u00b7min + c_i\u00b7min\u00b2)/min.\n4. Commit free-off units: While total effective max < load, commit candidate free-off unit with lowest cost per MW (startup + a_i + b_i\u00b7min + c_i\u00b7min\u00b2)/min, with effective min=p_min, max=min(p_max, p_start).\n5. Post-commitment decommitment: For committed free-on units, iteratively decommit highest cost per MW units if removal maintains total_min \u2264 load and total_max \u2265 load.\n6. Dispatch committed units:\n   - If load \u2264 total_min: set all to min outputs\n   - If load \u2265 total_max: set all to max outputs\n   - Else: perform lambda iteration economic dispatch (binary search for marginal cost)\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef refined_enhanced_dynamic_commitment(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    \n    # Initialize outputs\n    u_output = np.zeros(n_units, dtype=int)\n    p_output = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                must_on.append(idx)\n            else:\n                free_on.append(idx)\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                free_off.append(idx)\n    \n    # Initialize committed sets and effective bounds\n    committed = set(must_on + free_on)\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Compute initial totals\n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Step 3: Decommit free-on units if total_min > load\n    free_on_committed = [i for i in free_on if i in committed]\n    free_on_candidates = free_on_committed.copy()\n    while total_min > current_load and free_on_candidates:\n        candidate_list = []\n        for i in free_on_candidates:\n            unit = units_info[i]\n            new_min = total_min - eff_min[i]\n            new_max = total_max - eff_max[i]\n            if new_min <= current_load and new_max >= current_load:\n                cost_at_min = unit['a_i'] + unit['b_i']*eff_min[i] + unit['c_i']*(eff_min[i]**2)\n                cost_per_mw = cost_at_min / eff_min[i]\n                candidate_list.append((i, cost_per_mw))\n        if not candidate_list:\n            break\n        candidate_list.sort(key=lambda x: x[1], reverse=True)\n        best_candidate, _ = candidate_list[0]\n        total_min -= eff_min[best_candidate]\n        total_max -= eff_max[best_candidate]\n        committed.remove(best_candidate)\n        free_on_candidates.remove(best_candidate)\n    \n    # Step 4: Commit free-off units if total_max < load\n    while total_max < current_load and free_off:\n        candidate_list = []\n        for i in free_off:\n            unit = units_info[i]\n            eff_min_i = unit['p_min_i']\n            eff_max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_at_min = unit['s_i'] + unit['a_i'] + unit['b_i']*eff_min_i + unit['c_i']*(eff_min_i**2)\n            cost_per_mw = cost_at_min / eff_min_i\n            candidate_list.append((i, cost_per_mw, eff_min_i, eff_max_i))\n        candidate_list.sort(key=lambda x: x[1])\n        best_candidate = candidate_list[0][0]\n        eff_min[best_candidate] = candidate_list[0][2]\n        eff_max[best_candidate] = candidate_list[0][3]\n        total_min += eff_min[best_candidate]\n        total_max += eff_max[best_candidate]\n        committed.add(best_candidate)\n        free_off.remove(best_candidate)\n    \n    # Step 5: Post-commitment decommitment (expensive free-on units)\n    free_on_committed = [i for i in free_on if i in committed]\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        candidate_list = []\n        for i in free_on_committed:\n            new_min = total_min - eff_min[i]\n            new_max = total_max - eff_max[i]\n            if new_min <= current_load and new_max >= current_load:\n                unit = units_info[i]\n                cost_at_min = unit['a_i'] + unit['b_i']*eff_min[i] + unit['c_i']*(eff_min[i]**2)\n                cost_per_mw = cost_at_min / eff_min[i]\n                candidate_list.append((i, cost_per_mw))\n        if not candidate_list:\n            break\n        candidate_list.sort(key=lambda x: x[1], reverse=True)\n        best_candidate, _ = candidate_list[0]\n        total_min -= eff_min[best_candidate]\n        total_max -= eff_max[best_candidate]\n        committed.remove(best_candidate)\n        free_on_committed.remove(best_candidate)\n        changed = True\n    \n    # Step 6: Dispatch\n    for i in committed:\n        p_output[i] = eff_min[i]  # Default to min\n        \n    if current_load <= total_min:\n        # Already set to min outputs\n        pass\n    elif current_load >= total_max:\n        for i in committed:\n            p_output[i] = eff_max[i]\n    else:\n        # Lambda iteration economic dispatch\n        lambda_low = min(2 * units_info[i]['c_i'] * eff_min[i] + units_info[i]['b_i'] for i in committed)\n        lambda_high = max(2 * units_info[i]['c_i'] * eff_max[i] + units_info[i]['b_i'] for i in committed)\n        tol, max_iter, iter_count = 0.001, 1000, 0\n        while iter_count < max_iter:\n            mid = (lambda_low + lambda_high) / 2\n            total_p = 0.0\n            for i in committed:\n                unit = units_info[i]\n                p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                p_val = max(eff_min[i], min(p_val, eff_max[i]))\n                p_output[i] = p_val\n                total_p += p_val\n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                lambda_low = mid\n            else:\n                lambda_high = mid\n            iter_count += 1\n            \n    # Step 7: Set non-committed units\n    for i in committed:\n        u_output[i] = 1\n        \n    return np.array([u_output, p_output])",
          "from": "mutation",
          "gap_power_rate": 0.005428635,
          "gap_price_rate": 0.0091401619,
          "fitness": 0.0072843984
     },
     {
          "name": "dynamic_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize commitment to must-on and free-on units. Compute effective power limits considering ramp constraints.\n3. Decomission highest cost/MW free-on units if over-generation exists while maintaining feasibility.\n4. Commit lowest (startup + min-output cost)/min-output free-off units if under-generation exists.\n5. Conduct post-commitment decomissioning of expensive free-on units if feasible.\n6. Dispatch by setting to min/max bounds or perform \u03bb-iteration economic dispatch with ramp-aware initialization.\n7. Set non-committed units to off (0 output).\n\n",
          "code": "import numpy as np\n\ndef dynamic_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed_units = must_on[:] + free_on[:]\n    min_bound = [0] * num_units\n    max_bound = [0] * num_units\n    \n    for i in committed_units:\n        unit = units_info[i]\n        min_bound[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed_units)\n    total_max = sum(max_bound[i] for i in committed_units)\n    \n    candidate_free_on = free_on[:]\n    if total_min > current_load:\n        changed = True\n        while changed and candidate_free_on:\n            changed = False\n            candidates = []\n            for j in candidate_free_on:\n                new_min = total_min - min_bound[j]\n                new_max = total_max - max_bound[j]\n                if new_min <= current_load <= new_max:\n                    cost = (units_info[j]['a_i'] + units_info[j]['b_i'] * min_bound[j] + units_info[j]['c_i'] * min_bound[j]**2) / min_bound[j]\n                    candidates.append((cost, j))\n            if candidates:\n                candidates.sort(key=lambda x: x[0], reverse=True)\n                j_rm = candidates[0][1]\n                committed_units.remove(j_rm)\n                candidate_free_on.remove(j_rm)\n                total_min -= min_bound[j_rm]\n                total_max -= max_bound[j_rm]\n                changed = True\n    \n    if total_max < current_load:\n        candidates = []\n        for j in free_off:\n            unit = units_info[j]\n            min_j = unit['p_min_i']\n            max_j = min(unit['p_max_i'], unit['p_start_i'])\n            if min_j > max_j:\n                continue\n            cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_j + unit['c_i'] * min_j**2) / min_j\n            candidates.append((cost, j, min_j, max_j))\n        candidates.sort(key=lambda x: x[0])\n        for _, j, min_j, max_j in candidates:\n            if total_max >= current_load:\n                break\n            committed_units.append(j)\n            min_bound[j] = min_j\n            max_bound[j] = max_j\n            total_min += min_j\n            total_max += max_j\n    \n    free_on_in_commit = [i for i in committed_units if i in free_on]\n    changed = True\n    while changed and free_on_in_commit:\n        changed = False\n        candidates = []\n        for j in free_on_in_commit:\n            new_min = total_min - min_bound[j]\n            new_max = total_max - max_bound[j]\n            if new_min <= current_load <= new_max:\n                cost = (units_info[j]['a_i'] + units_info[j]['b_i'] * min_bound[j] + units_info[j]['c_i'] * min_bound[j]**2) / min_bound[j]\n                candidates.append((cost, j))\n        if candidates:\n            candidates.sort(key=lambda x: x[0], reverse=True)\n            j_rm = candidates[0][1]\n            committed_units.remove(j_rm)\n            free_on_in_commit.remove(j_rm)\n            total_min -= min_bound[j_rm]\n            total_max -= max_bound[j_rm]\n            changed = True\n    \n    u_arr = np.zeros(num_units)\n    p_arr = np.zeros(num_units)\n    \n    for i in committed_units:\n        u_arr[i] = 1\n    \n    if current_load <= total_min:\n        for i in committed_units:\n            p_arr[i] = min_bound[i]\n    elif current_load >= total_max:\n        for i in committed_units:\n            p_arr[i] = max_bound[i]\n    else:\n        a, b, c, mins, maxs = [], [], [], [], []\n        for i in committed_units:\n            unit = units_info[i]\n            a.append(unit['a_i'])\n            b.append(unit['b_i'])\n            c.append(unit['c_i'])\n            mins.append(min_bound[i])\n            maxs.append(max_bound[i])\n        \n        def total_output(lam):\n            total_p = 0.0\n            for idx in range(len(a)):\n                p_val = (lam - b[idx]) / (2 * c[idx]) if c[idx] != 0 else (mins[idx] if lam < b[idx] else maxs[idx])\n                p_val = max(mins[idx], min(maxs[idx], p_val))\n                total_p += p_val\n            return total_p\n        \n        lam_low = min(b_i + 2 * c_i * min_i for (b_i, c_i, min_i) in zip(b, c, mins))\n        lam_high = max(b_i + 2 * c_i * max_i for (b_i, c_i, max_i) in zip(b, c, maxs))\n        \n        tol = 1e-5\n        while lam_high - lam_low > tol:\n            lam_mid = (lam_low + lam_high) / 2\n            if total_output(lam_mid) < current_load:\n                lam_low = lam_mid\n            else:\n                lam_high = lam_mid\n        \n        final_lam = (lam_low + lam_high) / 2\n        for idx, i in enumerate(committed_units):\n            if c[idx] == 0:\n                p_arr[i] = mins[idx] if final_lam < b[idx] else maxs[idx]\n            else:\n                p_arr[i] = max(mins[idx], min(maxs[idx], (final_lam - b[idx]) / (2 * c[idx])))\n    \n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.005428761,
          "gap_price_rate": 0.0091401042,
          "fitness": 0.0072844326
     },
     {
          "name": "enhanced_refined_hybrid_commitment_v1",
          "algorithm": "1. Classify units into must-on (constrained by min up-time/shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), free-off (offline and committable)  \n2. Initialize commitment with must-on and free-on units  \n3. Compute effective power limits considering ramp constraints and startup/shutdown limitations  \n4. While over-generation exists and feasible, decommit highest cost-per-MW free-on units ensuring remaining capacity maintains feasibility  \n5. While under-generation exists, commit most economical free-off units using startup-aware cost metric  \n6. Perform cost-driven post-commitment decommissioning of free-on units while maintaining feasibility  \n7. Dispatch via:  \n   - Min outputs if load \u2264 total min  \n   - Max outputs if load \u2265 total max  \n   - Lambda-iteration economic dispatch otherwise  \n8. Set non-committed units to off  \n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_hybrid_commitment_v1(units_info, load):\n    n = len(units_info)\n    current_load = load[0]\n    \n    # Initialize classification arrays\n    must_on = np.zeros(n, dtype=bool)\n    must_off = np.zeros(n, dtype=bool)\n    free_on = np.zeros(n, dtype=bool)\n    free_off = np.zeros(n, dtype=bool)\n    \n    # Precompute effective limits\n    min_eff = np.zeros(n)\n    max_eff = np.zeros(n)\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            min_eff[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            max_eff[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            if (t_i0 < t_on_min) or (p_i0 > p_shut):\n                must_on[i] = True\n            else:\n                free_on[i] = True\n        else:\n            min_eff[i] = unit['p_min_i']\n            max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n            if -t_i0 < t_off_min:\n                must_off[i] = True\n            else:\n                free_off[i] = True\n                \n    # Initialize commitment and calculate total min/max\n    committed = must_on | free_on\n    total_min = np.sum(min_eff[committed])\n    total_max = np.sum(max_eff[committed])\n    \n    # Phase 1: Decommit free-on units if over-generation\n    free_on_idx = np.where(free_on)[0]\n    if total_min > current_load and free_on_idx.size > 0:\n        # Calculate cost per MW at min_eff\n        cost_per_mw = [\n            (u['a_i'] + u['b_i']*min_eff[i] + u['c_i']*min_eff[i]**2) / min_eff[i] \n            if min_eff[i] > 0 else float('inf')\n            for i, u in enumerate(units_info)\n        ]\n        \n        # Sort free-on units by cost/MW descending\n        high_cost_first = sorted(\n            [(cost_per_mw[i], i) for i in free_on_idx if committed[i]],\n            key=lambda x: x[0], reverse=True\n        )\n        \n        for cost, i in high_cost_first:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_eff[i]\n            new_max = total_max - max_eff[i]\n            if new_min <= current_load <= new_max:\n                committed[i] = False\n                total_min = new_min\n                total_max = new_max\n    \n    # Phase 2: Commit free-off units if under-generation\n    free_off_idx = np.where(free_off)[0]\n    if total_max < current_load and free_off_idx.size > 0:\n        # Calculate startup adjusted cost per MW\n        startup_cost_per_mw = [\n            (u['s_i'] + u['a_i'] + u['b_i']*min_eff[i] + u['c_i']*min_eff[i]**2) / min_eff[i]\n            if min_eff[i] > 0 else float('inf')\n            for i, u in enumerate(units_info)\n        ]\n        \n        # Sort free-off units by startup cost/MW ascending\n        low_cost_first = sorted(\n            [(startup_cost_per_mw[i], i) for i in free_off_idx],\n            key=lambda x: x[0]\n        )\n        \n        for cost, i in low_cost_first:\n            if total_max >= current_load:\n                break\n            if not committed[i]:\n                committed[i] = True\n                total_min += min_eff[i]\n                total_max += max_eff[i]\n    \n    # Phase 3: Post-commitment decommissioning\n    free_on_committed = [i for i in free_on_idx if committed[i]]\n    if free_on_committed:\n        # Calculate cost per MW at min_eff\n        cost_per_mw = [\n            (u['a_i'] + u['b_i']*min_eff[i] + u['c_i']*min_eff[i]**2) / min_eff[i] \n            if min_eff[i] > 0 else float('inf')\n            for i, u in enumerate(units_info)\n        ]\n        \n        # Sort by cost/MW descending\n        high_cost_first = sorted(\n            [(cost_per_mw[i], i) for i in free_on_committed],\n            key=lambda x: x[0], reverse=True\n        )\n        \n        for cost, i in high_cost_first:\n            new_min = total_min - min_eff[i]\n            new_max = total_max - max_eff[i]\n            if new_min <= current_load <= new_max:\n                committed[i] = False\n                total_min = new_min\n                total_max = new_max\n    \n    # Dispatch\n    u_out = np.zeros(n, dtype=int)\n    p_out = np.zeros(n)\n    \n    committed_indices = np.where(committed)[0]\n    if committed_indices.size > 0:\n        comm_min = min_eff[committed_indices]\n        comm_max = max_eff[committed_indices]\n        \n        if current_load <= total_min:\n            p_out[committed_indices] = comm_min\n        elif current_load >= total_max:\n            p_out[committed_indices] = comm_max\n        else:\n            # Lambda iteration for economic dispatch\n            lamb_low = 0\n            lamb_high = 1e6\n            tol = 0.01\n            for _ in range(100):\n                lamb_mid = (lamb_low + lamb_high) / 2\n                total_p = 0\n                for i in committed_indices:\n                    u = units_info[i]\n                    if u['c_i'] > 0:\n                        p_unclamped = (lamb_mid - u['b_i']) / (2 * u['c_i'])\n                        p = max(min_eff[i], min(max_eff[i], p_unclamped))\n                    else:  # Linear cost case\n                        p = max_eff[i] if lamb_mid >= u['b_i'] else min_eff[i]\n                    total_p += p\n                \n                if abs(total_p - current_load) < tol:\n                    break\n                if total_p < current_load:\n                    lamb_low = lamb_mid\n                else:\n                    lamb_high = lamb_mid\n            \n            # Apply final dispatch\n            for i in committed_indices:\n                u = units_info[i]\n                if u['c_i'] > 0:\n                    p_unclamped = (lamb_mid - u['b_i']) / (2 * u['c_i'])\n                    p_out[i] = max(min_eff[i], min(max_eff[i], p_unclamped))\n                else:\n                    p_out[i] = max_eff[i] if lamb_mid >= u['b_i'] else min_eff[i]\n        \n        u_out[committed_indices] = 1\n    \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054296899,
          "gap_price_rate": 0.0091402572,
          "fitness": 0.0072849735
     },
     {
          "name": "enhanced_dynamic_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize commitment to must-on and free-on units. Compute effective min/max power limits considering ramp constraints for units that were online.\n3. While total minimum output > current load and feasible free-on units exist, decommit the free-on unit with the highest cost-per-MW at min-output that maintains capacity >= load.\n4. While total maximum output < current load, commit free-off units with the lowest (startup cost + cost at min-output)/min-output.\n5. Iteratively decommit expensive free-on units if removal maintains feasible capacity (min <= load <= max) and reduces cost.\n6. Dispatch load to committed units:\n   - If load <= total minimum output, set all units to min outputs\n   - If load >= total maximum output, set all units to max outputs\n   - Else perform economic dispatch via lambda iteration respecting effective bounds\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_hybrid_commitment(units_info, load):\n    num_units = len(units_info)\n    u_array = np.zeros(num_units)\n    p_array = np.zeros(num_units)\n    if num_units == 0:\n        return np.vstack((u_array, p_array))\n        \n    current_load = load[0]\n    eff_min = np.zeros(num_units)\n    eff_max = np.zeros(num_units)\n    committed = set()\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            consecutive_on = unit['t_i_0']\n            if consecutive_on < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            consecutive_off = -unit['t_i_0']  # Convert negative to positive\n            if consecutive_off < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n                \n    # Initialize commitment\n    committed.update(must_on)\n    committed.update(free_on)\n    \n    # Calculate effective min/max for initially committed units\n    total_min, total_max = 0.0, 0.0\n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:  # Was online\n            min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:  # Free-off not yet committed\n            min_val = unit['p_min_i']\n            max_val = unit['p_max_i']\n        eff_min[i] = min_val\n        eff_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 3: Decommit over-committed free-on units\n    free_on_committed = [i for i in free_on if i in committed]\n    while total_min > current_load and free_on_committed:\n        candidate = None\n        best_cost_per_mw = -1\n        for i in free_on_committed:\n            new_total_max = total_max - eff_max[i]\n            if new_total_max >= current_load:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \n                              units_info[i]['c_i'] * (eff_min[i] ** 2)) / eff_min[i]\n                if candidate is None or cost_per_mw > best_cost_per_mw:\n                    candidate = i\n                    best_cost_per_mw = cost_per_mw\n        if candidate is None:\n            break\n        committed.remove(candidate)\n        free_on_committed.remove(candidate)\n        total_min -= eff_min[candidate]\n        total_max -= eff_max[candidate]\n    \n    # Step 4: Commit free-off units if under-committed\n    def free_off_cost(i):\n        unit = units_info[i]\n        min_val = unit['p_min_i']\n        cost_val = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_val + unit['c_i'] * (min_val ** 2)\n        return cost_val / min_val\n    \n    free_off_sorted = sorted(free_off, key=free_off_cost)\n    for i in free_off_sorted:\n        if total_max >= current_load:\n            break\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        committed.add(i)\n        eff_min[i] = min_val\n        eff_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 5: Post-commitment decommissioning\n    free_on_committed = [i for i in free_on if i in committed]\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        free_on_committed_sorted = sorted(\n            free_on_committed,\n            key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * eff_min[i] + \n                          units_info[i]['c_i'] * (eff_min[i] ** 2)) / eff_min[i],\n            reverse=True\n        )\n        for i in free_on_committed_sorted:\n            new_total_min = total_min - eff_min[i]\n            new_total_max = total_max - eff_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                committed.remove(i)\n                free_on_committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Set commitment status\n    for i in committed:\n        u_array[i] = 1\n    \n    # Dispatch\n    if committed:\n        if current_load <= total_min:\n            for i in committed:\n                p_array[i] = eff_min[i]\n        elif current_load >= total_max:\n            for i in committed:\n                p_array[i] = eff_max[i]\n        else:\n            # Lambda iteration for economic dispatch\n            low = float('inf')\n            high = float('-inf')\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * eff_min[i] if unit['c_i'] != 0 else unit['b_i']\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * eff_max[i] if unit['c_i'] != 0 else unit['b_i']\n                low = min(low, marginal_min)\n                high = max(high, marginal_max)\n            \n            tol = 1e-2\n            iter_limit = 100\n            for _ in range(iter_limit):\n                mid = (low + high) / 2\n                total_power = 0\n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] == 0:\n                        if mid >= unit['b_i']:\n                            p_val = eff_max[i]\n                        else:\n                            p_val = eff_min[i]\n                    else:\n                        p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                        p_val = max(eff_min[i], min(eff_max[i], p_val))\n                    total_power += p_val\n                \n                if abs(total_power - current_load) <= tol:\n                    break\n                if total_power < current_load:\n                    low = mid\n                else:\n                    high = mid\n            # Final dispatch after lambda found\n            for i in committed:\n                unit = units_info[i]\n                if unit['c_i'] == 0:\n                    if mid >= unit['b_i']:\n                        p_array[i] = eff_max[i]\n                    else:\n                        p_array[i] = eff_min[i]\n                else:\n                    p_val = (mid - unit['b_i']) / (2 * unit['c_i'])\n                    p_array[i] = max(eff_min[i], min(eff_max[i], p_val))\n    \n    return np.vstack((u_array, p_array))",
          "from": "crossover",
          "gap_power_rate": 0.005429695,
          "gap_price_rate": 0.0091404072,
          "fitness": 0.0072850511
     }
]