[
     {
          "name": "enhanced_hybrid_commitment_v4",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize committed units as must-on plus free-on. Compute effective power bounds considering ramp constraints:\n   - For previously online units: min = max(p_min_i, p_i_0 - p_down_i), max = min(p_max_i, p_i_0 + p_up_i)\n   - For units to be committed: min = p_min_i, max = min(p_max_i, p_start_i, p_up_i)\n3. If total min > load, decommission free-on units with highest operating cost per MW at min output while ensuring feasibility after removal.\n4. If total max < load, commission free-off units with lowest startup-adjusted cost per MW at min output until capacity meets or exceeds load.\n5. Perform iterative post-commission decommissioning: remove free-on units that are costly and whose removal maintains feasibility.\n6. Dispatch load to committed units:\n   - Set all to min if load \u2264 total min\n   - Set all to max if load \u2265 total max\n   - Otherwise perform \u03bb-iteration economic dispatch with bounds clamping\n7. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_hybrid_commitment_v4(units_info, load):\n    current_load = load[0]\n    committed_units = []\n    uncommitted_units = []\n    \n    # Step 1: Classify units and initialize\n    for unit in units_info:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                unit['type'] = 'must-on'\n            else:\n                unit['type'] = 'free-on'\n        else:\n            if unit['t_i_0'] < 0 and -unit['t_i_0'] < unit['t_off_min_i']:\n                unit['type'] = 'must-off'\n            else:\n                unit['type'] = 'free-off'\n                \n    # Step 2: Commit must-on and free-on units\n    for unit in units_info:\n        if unit['type'] in ['must-on', 'free-on']:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            unit['min_i'] = min_i\n            unit['max_i'] = max_i\n            committed_units.append(unit)\n        else:\n            uncommitted_units.append(unit)\n    \n    # Calculate initial total min and max\n    total_min = sum(u['min_i'] for u in committed_units)\n    total_max = sum(u['max_i'] for u in committed_units)\n    \n    # Collect free-on units\n    free_on_units = [u for u in committed_units if u['type'] == 'free-on']\n    \n    # Step 3: Decommission if over-generating\n    while total_min > current_load and free_on_units:\n        # Sort by descending cost per MW (operating cost at min)\n        free_on_units.sort(key=lambda u: (u['a_i'] + u['b_i']*u['min_i'] + u['c_i']*u['min_i']**2) / u['min_i'], reverse=True)\n        removed = False\n        for unit in free_on_units[:]:\n            new_total_min = total_min - unit['min_i']\n            new_total_max = total_max - unit['max_i']\n            if new_total_min <= current_load <= new_total_max:\n                committed_units.remove(unit)\n                free_on_units.remove(unit)\n                total_min = new_total_min\n                total_max = new_total_max\n                removed = True\n                break\n        if not removed:\n            break\n    \n    # Step 4: Commission if under-generating\n    free_off_units = [u for u in uncommitted_units if u['type'] == 'free-off']\n    while total_max < current_load and free_off_units:\n        # Calculate costs for free-off units\n        costs = []\n        for unit in free_off_units:\n            min_i_f = unit['p_min_i']\n            max_i_f = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n            unit['min_i_f'] = min_i_f\n            unit['max_i_f'] = max_i_f\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i']*min_i_f + unit['c_i']*min_i_f**2) / min_i_f\n            costs.append((cost_per_mw, unit))\n        costs.sort(key=lambda x: x[0])\n        added = False\n        for cost_per_mw, unit in costs:\n            new_total_min = total_min + unit['min_i_f']\n            new_total_max = total_max + unit['max_i_f']\n            committed_units.append(unit)\n            unit['min_i'] = unit['min_i_f']\n            unit['max_i'] = unit['max_i_f']\n            free_off_units.remove(unit)\n            total_min = new_total_min\n            total_max = new_total_max\n            added = True\n            break\n        if not added:\n            break\n    \n    # Step 5: Post-commitment decommissioning\n    free_on_units = [u for u in committed_units if u['type'] == 'free-on']\n    changed = True\n    while changed and free_on_units:\n        changed = False\n        free_on_units.sort(key=lambda u: (u['a_i'] + u['b_i']*u['min_i'] + u['c_i']*u['min_i']**2) / u['min_i'], reverse=True)\n        for unit in free_on_units[:]:\n            new_total_min = total_min - unit['min_i']\n            new_total_max = total_max - unit['max_i']\n            if new_total_min <= current_load <= new_total_max:\n                committed_units.remove(unit)\n                free_on_units.remove(unit)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 6: Dispatch\n    if abs(current_load - total_min) < 1e-5:\n        for unit in committed_units:\n            unit['p_i'] = unit['min_i']\n            unit['u_i'] = 1\n    elif abs(current_load - total_max) < 1e-5:\n        for unit in committed_units:\n            unit['p_i'] = unit['max_i']\n            unit['u_i'] = 1\n    else:\n        # Lambda iteration setup\n        low_lam = 0\n        high_lam = 1e6\n        tolerance = 1e-5\n        p_allocated = np.zeros(len(committed_units))\n        while high_lam - low_lam > tolerance:\n            mid_lam = (low_lam + high_lam) / 2\n            total_p = 0\n            for i, unit in enumerate(committed_units):\n                if unit['c_i'] != 0:\n                    p_i = (mid_lam - unit['b_i']) / (2 * unit['c_i'])\n                else:\n                    p_i = unit['max_i'] if mid_lam > unit['b_i'] else unit['min_i']\n                p_i = max(unit['min_i'], min(unit['max_i'], p_i))\n                p_allocated[i] = p_i\n                total_p += p_i\n            if total_p < current_load:\n                low_lam = mid_lam\n            else:\n                high_lam = mid_lam\n        for i, unit in enumerate(committed_units):\n            unit['p_i'] = p_allocated[i]\n            unit['u_i'] = 1\n    \n    # Step 7: Set non-committed units\n    for unit in units_info:\n        if unit not in committed_units:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    # Build output array\n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0051595866,
          "gap_price_rate": 0.008320781,
          "fitness": 0.0067401838
     },
     {
          "name": "enhanced_rolling_commitment_dispatch",
          "algorithm": "1. Classify units into must-run (cannot be turned off), must-off (cannot be turned on), free-on (online and can be turned off), and free-off (offline and can be turned on)\n2. Commit must-run units and calculate their effective min/max outputs based on ramp constraints\n3. If total minimum output exceeds load, decommit free-on units in descending order of min output\n4. If total maximum output is below load, commit additional units from candidate list (free-on + free-off) sorted by cost per MW at minimum output\n5. Dispatch using lambda iteration to meet load exactly within generation limits\n6. For all non-committed units, set status to off and output to zero\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    committed = set()\n    must_run = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        # Must-run conditions\n        must_run_cond = (\n            u_i0 == 1 and \n            (t_i0 > 0 and t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i'])\n        )\n        # Must-off conditions\n        must_off_cond = (\n            u_i0 == 0 and \n            abs(t_i0) < unit['t_off_min_i']\n        )\n        \n        if must_run_cond:\n            must_run.append(i)\n            committed.add(i)\n        elif must_off_cond:\n            must_off.append(i)\n        elif u_i0 == 1:\n            free_on.append(i)\n        else:\n            free_off.append(i)\n    \n    # Compute effective min/max for must-run units\n    total_min = 0.0\n    total_max = 0.0\n    must_run_limits = []\n    \n    for i in must_run:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        # Compute effective limits\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        total_min += eff_min\n        total_max += eff_max\n        must_run_limits.append((i, eff_min, eff_max))\n    \n    # Candidate handling\n    candidate_list = []\n    candidate_indices = []\n    \n    # Free-on candidates\n    for i in free_on:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_i0 = unit['p_i_0']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        eff_min = max(p_min, p_i0 - ramp_down)\n        eff_max = min(p_max, p_i0 + ramp_up)\n        cost_at_min = unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2)\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-on'))\n    \n    # Free-off candidates\n    for i in free_off:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        eff_min = p_min\n        eff_max = min(p_max, unit['p_start_i'])\n        cost_at_min = (unit['a_i'] + unit['b_i']*eff_min + unit['c_i']*(eff_min**2) + \n                       unit['s_i'])\n        cost_per_mw = cost_at_min / eff_min if eff_min > 0 else float('inf')\n        candidate_list.append((cost_per_mw, i, eff_min, eff_max, cost_at_min, 'free-off'))\n    \n    candidate_list.sort(key=lambda x: x[0])\n    \n    # Over-commitment handling\n    if total_min > current_load and free_on:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in sorted(\n            candidate_list[:len(free_on)], \n            key=lambda x: units_info[x[1]]['p_min_i'], \n            reverse=True\n        ):\n            if i in free_on:\n                if total_min - eff_min >= current_load:\n                    total_min -= eff_min\n                    total_max -= eff_max\n                else:\n                    break\n    \n    # Under-commitment handling\n    if total_max < current_load and candidate_list:\n        for cost_per_mw, i, eff_min, eff_max, _, unit_type in candidate_list:\n            if unit_type == 'free-off' and i in free_off:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n            elif unit_type == 'free-on' and i in free_on:\n                total_min += eff_min\n                total_max += eff_max\n                committed.add(i)\n                if total_max >= current_load:\n                    break\n    \n    # Dispatch preparation\n    dispatch_list = []\n    for i in committed:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        ramp_up = unit['p_up_i']\n        \n        if u_i0 == 1:  # Was online\n            eff_min = max(p_min, p_i0 - ramp_down)\n            eff_max = min(p_max, p_i0 + ramp_up)\n        else:  # Was offline (free-off candidate)\n            eff_min = p_min\n            eff_max = min(p_max, unit['p_start_i'])\n        \n        dispatch_list.append((\n            eff_min, eff_max, \n            unit['b_i'], unit['c_i'], i\n        ))\n    \n    # Economic dispatch using lambda iteration\n    if len(dispatch_list) == 0:\n        # Default to zero for all units\n        return schedules\n    \n    # Lambda iteration setup\n    low_lambda = -1e6\n    high_lambda = 1e6\n    tol = 0.1\n    max_iter = 1000\n    p_allocations = np.zeros(len(dispatch_list))\n    \n    for _ in range(max_iter):\n        lambda_mid = (low_lambda + high_lambda) / 2.0\n        total_gen = 0.0\n        \n        for idx, (p_min, p_max, b, c, unit_idx) in enumerate(dispatch_list):\n            if c == 0:  # Linear cost\n                if lambda_mid < b:\n                    p = p_min\n                else:\n                    p = p_max\n            else:  # Quadratic cost\n                p_ideal = (lambda_mid - b) / (2 * c)\n                p = max(p_min, min(p_ideal, p_max))\n            \n            p_allocations[idx] = p\n            total_gen += p\n        \n        if abs(total_gen - current_load) < tol:\n            break\n        elif total_gen < current_load:\n            low_lambda = lambda_mid\n        else:\n            high_lambda = lambda_mid\n    \n    # Apply allocations to committed units\n    for (p_min, p_max, b, c, unit_idx), p_val in zip(dispatch_list, p_allocations):\n        schedules[0][unit_idx] = 1\n        schedules[1][unit_idx] = p_val\n    \n    return schedules\n",
          "from": "crossover",
          "gap_power_rate": 0.00544046,
          "gap_price_rate": 0.00878014,
          "fitness": 0.0071103
     },
     {
          "name": "refined_hybrid_commitment_v3",
          "algorithm": null,
          "code": "import numpy as np\n\ndef refined_hybrid_commitment_v3(units_info, load):\n    load_current = load[0]\n    n = len(units_info)\n    must_on, must_off, free_on, free_off = [], [], [], []\n    committed = [False] * n\n    min_p = [0] * n\n    max_p = [0] * n\n\n    for i, unit in enumerate(units_info):\n        u_i0, t_i0, p_i0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']\n        t_on_min, t_off_min = unit['t_on_min_i'], unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n\n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            committed[i] = True\n        else:\n            off_duration = -t_i0\n            if off_duration < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n\n    for i in range(n):\n        if committed[i]:\n            p_i0 = units_info[i]['p_i_0']\n            min_p[i] = max(units_info[i]['p_min_i'], p_i0 - units_info[i]['p_down_i'])\n            max_p[i] = min(units_info[i]['p_max_i'], p_i0 + units_info[i]['p_up_i'])\n        else:\n            min_p[i] = units_info[i]['p_min_i']\n            max_p[i] = units_info[i]['p_max_i']\n\n    total_min = sum(min_p[i] for i in range(n) if committed[i])\n    total_max = sum(max_p[i] for i in range(n) if committed[i])\n\n    # Step 5: Decommit free-on units if over-generated\n    changed = True\n    while changed and total_min > load_current:\n        changed = False\n        best_candidate, best_cost = None, -10**12\n        for i in free_on:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= load_current <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n                if cost_per_mw > best_cost:\n                    best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is not None:\n            committed[best_candidate] = False\n            total_min -= min_p[best_candidate]\n            total_max -= max_p[best_candidate]\n            changed = True\n\n    # Step 6: Commit free-off units if under-generated\n    while total_max < load_current and free_off:\n        best_candidate, best_cost = None, 10**12\n        for i in free_off:\n            min_p0 = units_info[i]['p_min_i']\n            startup_cost = units_info[i]['s_i']\n            cost_per_mw = (startup_cost + units_info[i]['a_i'] + units_info[i]['b_i'] * min_p0 + units_info[i]['c_i'] * min_p0**2) / min_p0\n            if cost_per_mw < best_cost:\n                best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is None:\n            break\n        min_p0 = units_info[best_candidate]['p_min_i']\n        max_p_bound = min(units_info[best_candidate]['p_max_i'], units_info[best_candidate]['p_start_i'])\n        min_p[best_candidate], max_p[best_candidate] = min_p0, max_p_bound\n        committed[best_candidate] = True\n        total_min += min_p0\n        total_max += max_p_bound\n        free_off.remove(best_candidate)\n        if total_max >= load_current:\n            break\n\n    # Step 7: Post-commitment decommitment of expensive free-on units\n    changed = True\n    while changed:\n        changed = False\n        best_candidate, best_cost = None, -10**12\n        for i in free_on:\n            if not committed[i]:\n                continue\n            new_min = total_min - min_p[i]\n            new_max = total_max - max_p[i]\n            if new_min <= load_current <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * min_p[i] + units_info[i]['c_i'] * min_p[i]**2) / min_p[i]\n                if cost_per_mw > best_cost:\n                    best_cost, best_candidate = cost_per_mw, i\n        if best_candidate is not None:\n            committed[best_candidate] = False\n            total_min -= min_p[best_candidate]\n            total_max -= max_p[best_candidate]\n            changed = True\n\n    # Step 8: Dispatch\n    output_p = [0] * n\n    if load_current <= total_min:\n        for i in range(n):\n            if committed[i]:\n                output_p[i] = min_p[i]\n    elif load_current >= total_max:\n        for i in range(n):\n            if committed[i]:\n                output_p[i] = max_p[i]\n    else:\n        committed_indices = [i for i in range(n) if committed[i]]\n        lo = min(unit['b_i'] + 2 * unit['c_i'] * min_p[i] for i, unit in enumerate(units_info) if committed[i])\n        hi = max(unit['b_i'] + 2 * unit['c_i'] * max_p[i] for i, unit in enumerate(units_info) if committed[i])\n        tol = 0.001\n        while hi - lo > tol:\n            mid = (lo + hi) / 2\n            total_p = 0\n            for i in committed_indices:\n                b, c = units_info[i]['b_i'], units_info[i]['c_i']\n                min_val, max_val = min_p[i], max_p[i]\n                if c == 0:\n                    p_val = min_val if mid < b else max_val\n                else:\n                    p_unbound = (mid - b) / (2 * c)\n                    p_val = max(min_val, min(max_val, p_unbound))\n                total_p += p_val\n            if total_p < load_current:\n                lo = mid\n            else:\n                hi = mid\n        mid = (lo + hi) / 2\n        for i in committed_indices:\n            b, c = units_info[i]['b_i'], units_info[i]['c_i']\n            min_val, max_val = min_p[i], max_p[i]\n            if c == 0:\n                output_p[i] = min_val if mid < b else max_val\n            else:\n                p_unbound = (mid - b) / (2 * c)\n                output_p[i] = max(min_val, min(max_val, p_unbound))\n\n    u_i_list = [1 if committed[i] else 0 for i in range(n)]\n    schedules = np.array([u_i_list, output_p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054548168,
          "gap_price_rate": 0.0091024797,
          "fitness": 0.0072786483
     },
     {
          "name": "enhanced_refined_hybrid_commitment_v4",
          "algorithm": "1. Classify units into must-run, must-off, free-on, and free-off based on operational constraints.\n2. Calculate effective power limits considering ramp and startup/shutdown constraints.\n3. Initialize commitment with must-run and free-on units.\n4. Decomission expensive free-on units if system is over-generating (total min > load), ensuring feasibility.\n5. Commit economical free-off units if system is under-generating (total max < load) using (startup + min-output cost)/min-output metric.\n6. Perform secondary decommissioning of free-on units if feasible to reduce costs.\n7. Dispatch using min/max outputs if load is at bounds; otherwise use lambda iteration with gap adjustment.\n8. Set non-committed units to off (u_i=0, p_i=0).\n\n",
          "code": "import numpy as np\n\ndef enhanced_refined_hybrid_commitment_v4(units_info, load):\n    L = load[0]  # current load\n    n_units = len(units_info)\n    \n    # Initialize classification lists\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize commitment\n    committed = set(must_on + free_on)\n    \n    # Calculate effective power limits\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    for i, unit in enumerate(units_info):\n        if i in committed:\n            if unit['u_i_0'] == 1:\n                effective_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                effective_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                effective_min[i] = unit['p_min_i']\n                effective_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            effective_min[i] = 0\n            effective_max[i] = 0\n    \n    # Calculate total min/max\n    total_min = np.sum([effective_min[i] for i in committed])\n    total_max = np.sum([effective_max[i] for i in committed])\n    \n    # Decommitment for over-generation\n    if total_min > L:\n        decommission_candidates = free_on.copy()\n        while decommission_candidates and total_min > L:\n            feasible_removals = []\n            for i in decommission_candidates:\n                new_min = total_min - effective_min[i]\n                new_max = total_max - effective_max[i]\n                if new_min <= L <= new_max:\n                    cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + \n                                 units_info[i]['c_i'] * effective_min[i]**2) / effective_min[i]\n                    feasible_removals.append((cost_per_mw, i))\n            \n            if not feasible_removals:\n                break\n                \n            _, candidate = max(feasible_removals)\n            committed.remove(candidate)\n            decommission_candidates.remove(candidate)\n            free_on.remove(candidate)\n            total_min -= effective_min[candidate]\n            total_max -= effective_max[candidate]\n            effective_min[candidate] = 0\n            effective_max[candidate] = 0\n    \n    # Commitment for under-generation\n    if total_max < L:\n        candidate_scores = []\n        for i in free_off:\n            if units_info[i]['p_min_i'] > 0:\n                min_cost = (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                          units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i']**2) / units_info[i]['p_min_i']\n            else:\n                min_cost = float('inf')\n            candidate_scores.append((min_cost, i))\n        \n        candidate_scores.sort(key=lambda x: x[0])\n        while candidate_scores and total_max < L:\n            cost, candidate = candidate_scores.pop(0)\n            committed.add(candidate)\n            free_off.remove(candidate)\n            new_min = units_info[candidate]['p_min_i']\n            new_max = min(units_info[candidate]['p_max_i'], units_info[candidate]['p_start_i'])\n            effective_min[candidate] = new_min\n            effective_max[candidate] = new_max\n            total_min += new_min\n            total_max += new_max\n    \n    # Post-commitment decommissioning\n    decommission_candidates = free_on.copy()\n    while decommission_candidates:\n        feasible_removals = []\n        for i in decommission_candidates:\n            new_min = total_min - effective_min[i]\n            new_max = total_max - effective_max[i]\n            if new_min <= L <= new_max:\n                cost_per_mw = (units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + \n                             units_info[i]['c_i'] * effective_min[i]**2) / effective_min[i]\n                feasible_removals.append((cost_per_mw, i))\n        \n        if not feasible_removals:\n            break\n            \n        _, candidate = max(feasible_removals)\n        committed.remove(candidate)\n        decommission_candidates.remove(candidate)\n        total_min -= effective_min[candidate]\n        total_max -= effective_max[candidate]\n        effective_min[candidate] = 0\n        effective_max[candidate] = 0\n    \n    # Dispatch\n    p_output = np.zeros(n_units)\n    u_status = np.zeros(n_units)\n    if committed:\n        if L <= total_min:\n            for i in committed:\n                p_output[i] = effective_min[i]\n                u_status[i] = 1\n        elif L >= total_max:\n            for i in committed:\n                p_output[i] = effective_max[i]\n                u_status[i] = 1\n        else:\n            # Identify dispatchable units with non-zero c_i\n            quad_units = []\n            for i in committed:\n                if units_info[i]['c_i'] > 0:\n                    quad_units.append(i)\n                else:\n                    # Initialize linear units to min output\n                    p_output[i] = effective_min[i]\n                    u_status[i] = 1\n            \n            if quad_units:\n                # Set bounds and coefficients for quad units\n                L_i = [effective_min[i] for i in quad_units]\n                U_i = [effective_max[i] for i in quad_units]\n                b_i = [units_info[i]['b_i'] for i in quad_units]\n                c_i = [units_info[i]['c_i'] for i in quad_units]\n                \n                # Calculate residual load after linear units\n                residual_L = L - np.sum(p_output)\n                low_lambda = min(b + 2*c*lb for (b, c, lb) in zip(b_i, c_i, L_i))\n                high_lambda = max(b + 2*c*ub for (b, c, ub) in zip(b_i, c_i, U_i))\n                \n                # Lambda iteration\n                tol = 0.01\n                while (high_lambda - low_lambda) > tol:\n                    mid_lambda = (low_lambda + high_lambda) / 2\n                    total = 0\n                    for idx, i in enumerate(quad_units):\n                        p_val = (mid_lambda - b_i[idx]) / (2 * c_i[idx])\n                        p_val = max(L_i[idx], min(U_i[idx], p_val))\n                        total += p_val\n                    if total < residual_L:\n                        low_lambda = mid_lambda\n                    else:\n                        high_lambda = mid_lambda\n                \n                # Assign quad unit outputs\n                for idx, i in enumerate(quad_units):\n                    p_val = (low_lambda - b_i[idx]) / (2 * c_i[idx])\n                    p_output[i] = max(L_i[idx], min(U_i[idx], p_val))\n                    u_status[i] = 1\n                \n                # Gap distribution\n                total_dispatch = np.sum(p_output)\n                gap = residual_L - total_dispatch\n                if abs(gap) > 1e-5:\n                    if gap > 0:\n                        candidates = [i for i in quad_units if p_output[i] < U_i[quad_units.index(i)]]\n                        candidates.sort(key=lambda i: units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i])\n                        for i in candidates:\n                            avail = effective_max[i] - p_output[i]\n                            addition = min(avail, gap)\n                            p_output[i] += addition\n                            gap -= addition\n                            if gap <= 0:\n                                break\n                    else:\n                        gap = abs(gap)\n                        candidates = [i for i in quad_units if p_output[i] > L_i[quad_units.index(i)]]\n                        candidates.sort(key=lambda i: -(units_info[i]['b_i'] + 2*units_info[i]['c_i']*p_output[i]))\n                        for i in candidates:\n                            avail = p_output[i] - effective_min[i]\n                            reduction = min(avail, gap)\n                            p_output[i] -= reduction\n                            gap -= reduction\n                            if gap <= 0:\n                                break\n    \n    # Build output array\n    schedules = np.vstack((u_status, p_output))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054284899,
          "gap_price_rate": 0.0091396508,
          "fitness": 0.0072840704
     },
     {
          "name": "enhanced_dynamic_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (constrained online by min up-time or shutdown capacity), must-off (constrained offline by min down-time), free-on (online and decomittable), and free-off (offline and committable).\n2. Initialize commitment with must-on and free-on units. Compute effective min/max power outputs considering ramp constraints from current operating point.\n3. If total effective min > load, decommission free-on units with highest cost per MW at min output while ensuring the remaining system can meet load (min \u2264 load \u2264 max).\n4. If total effective max < load, commission free-off units with lowest cost per MW (startup cost + min output cost) until generation capacity meets/exceeds load.\n5. Perform post-commitment decommissioning of initial free-on units if removal maintains load feasibility and reduces cost.\n6. Dispatch power: set units to min if load \u2264 total min; set to max if load \u2265 total max; else use lambda iteration for economic dispatch.\n7. Set non-committed units to off (0 output).\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_hybrid_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Initialize output arrays\n    u_out = np.zeros(n_units, dtype=int)\n    p_out = np.zeros(n_units)\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    free_on_initial = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n                free_on_initial.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize commitment\n    committed_units = set(must_on + free_on)\n    \n    # Compute effective min/max outputs\n    eff_min = [0.0] * n_units\n    eff_max = [0.0] * n_units\n    \n    for i in committed_units:\n        unit = units_info[i]\n        eff_min[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        eff_max[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n    \n    # Compute total min and max\n    total_min = sum(eff_min[i] for i in committed_units)\n    total_max = sum(eff_max[i] for i in committed_units)\n    \n    # Decommit free-on units if over-generating\n    free_on_remaining = set(free_on)\n    free_off_remaining = set(free_off)\n    \n    if total_min > current_load:\n        while True:\n            candidates = [i for i in free_on_remaining if i in committed_units]\n            if not candidates:\n                break\n                \n            def cost_metric(i):\n                a = units_info[i]['a_i']\n                b = units_info[i]['b_i']\n                c = units_info[i]['c_i']\n                return (a + b * eff_min[i] + c * eff_min[i] ** 2) / eff_min[i]\n                \n            sorted_candidates = sorted(candidates, key=cost_metric, reverse=True)\n            found = False\n            \n            for cand in sorted_candidates:\n                new_min = total_min - eff_min[cand]\n                new_max = total_max - eff_max[cand]\n                \n                if new_min <= current_load <= new_max:\n                    committed_units.remove(cand)\n                    free_on_remaining.discard(cand)\n                    total_min = new_min\n                    total_max = new_max\n                    found = True\n                    break\n                    \n            if not found:\n                break\n                \n    # Commit free-off units if under-generating\n    if total_max < current_load:\n        while free_off_remaining and total_max < current_load:\n            def commit_metric(i):\n                unit = units_info[i]\n                p_min = unit['p_min_i']\n                return (unit['s_i'] + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n                \n            sorted_candidates = sorted(free_off_remaining, key=commit_metric)\n            found = False\n            \n            for cand in sorted_candidates:\n                unit = units_info[cand]\n                cand_min = unit['p_min_i']\n                cand_max = min(unit['p_max_i'], unit['p_start_i'])\n                \n                new_min = total_min + cand_min\n                new_max = total_max + cand_max\n                \n                committed_units.add(cand)\n                free_off_remaining.discard(cand)\n                eff_min[cand] = cand_min\n                eff_max[cand] = cand_max\n                total_min = new_min\n                total_max = new_max\n                found = True\n                break\n                \n            if not found:\n                break\n                \n    # Post-commitment decommissioning of initial free-on units\n    candidate_list = [i for i in free_on_initial if i in committed_units]\n    changed = True\n    \n    while changed and candidate_list:\n        changed = False\n        def cost_metric(i):\n            a = units_info[i]['a_i']\n            b = units_info[i]['b_i']\n            c = units_info[i]['c_i']\n            return (a + b * eff_min[i] + c * eff_min[i] ** 2) / eff_min[i]\n            \n        sorted_candidates = sorted(candidate_list, key=cost_metric, reverse=True)\n        found = False\n        \n        for cand in sorted_candidates:\n            new_min = total_min - eff_min[cand]\n            new_max = total_max - eff_max[cand]\n            \n            if new_min <= current_load <= new_max:\n                committed_units.remove(cand)\n                candidate_list.remove(cand)\n                total_min = new_min\n                total_max = new_max\n                changed = True\n                found = True\n                break\n                \n        if not found:\n            break\n            \n    # Dispatch power to committed units\n    if total_min >= current_load:\n        for i in committed_units:\n            p_out[i] = eff_min[i]\n            \n    elif total_max <= current_load:\n        for i in committed_units:\n            p_out[i] = eff_max[i]\n            \n    else:\n        # Lambda iteration for economic dispatch\n        comm_list = list(committed_units)\n        n_comm = len(comm_list)\n        L_arr = [eff_min[i] for i in comm_list]\n        U_arr = [eff_max[i] for i in comm_list]\n        b_arr = [units_info[i]['b_i'] for i in comm_list]\n        c_arr = [units_info[i]['c_i'] for i in comm_list]\n        lambda_min = min(2*c_arr[i]*L_arr[i] + b_arr[i] for i in range(n_comm))\n        lambda_max = max(2*c_arr[i]*U_arr[i] + b_arr[i] for i in range(n_comm))\n        tol = 1e-5\n        \n        while lambda_max - lambda_min > tol:\n            lam = (lambda_min + lambda_max) / 2\n            total_p = 0.0\n            for i in range(n_comm):\n                if c_arr[i] == 0:\n                    if lam < b_arr[i]:\n                        p_val = L_arr[i]\n                    else:\n                        p_val = U_arr[i]\n                else:\n                    p_val = max(L_arr[i], min(U_arr[i], (lam - b_arr[i]) / (2 * c_arr[i])))\n                total_p += p_val\n                \n            if total_p < current_load:\n                lambda_min = lam\n            else:\n                lambda_max = lam\n                \n        # Compute outputs with final lambda\n        total_p = 0.0\n        p_vals = []\n        lam = (lambda_min + lambda_max) / 2\n        for i in range(n_comm):\n            if c_arr[i] == 0:\n                if lam < b_arr[i]:\n                    p_val = L_arr[i]\n                else:\n                    p_val = U_arr[i]\n            else:\n                p_val = max(L_arr[i], min(U_arr[i], (lam - b_arr[i]) / (2 * c_arr[i])))\n            total_p += p_val\n            p_vals.append(p_val)\n            \n        # Allocate residual due to approximations\n        residual = current_load - total_p\n        if abs(residual) > 1e-5:\n            if residual > 0:\n                candidates = [i for i in range(n_comm) if p_vals[i] < U_arr[i] - 1e-5]\n                if candidates:\n                    derivatives = [2*c_arr[i]*p_vals[i] + b_arr[i] for i in candidates]\n                    idx = candidates[np.argmin(derivatives)]\n                    add = min(residual, U_arr[idx] - p_vals[idx])\n                    p_vals[idx] += add\n                    residual -= add\n                    \n                idx = 0\n                while residual > 1e-5 and idx < n_comm:\n                    if p_vals[idx] < U_arr[idx]:\n                        add = min(residual, U_arr[idx] - p_vals[idx])\n                        p_vals[idx] += add\n                        residual -= add\n                    idx += 1\n                    \n            else:\n                residual = -residual\n                candidates = [i for i in range(n_comm) if p_vals[i] > L_arr[i] + 1e-5]\n                if candidates:\n                    derivatives = [2*c_arr[i]*p_vals[i] + b_arr[i] for i in candidates]\n                    idx = candidates[np.argmax(derivatives)]\n                    sub = min(residual, p_vals[idx] - L_arr[idx])\n                    p_vals[idx] -= sub\n                    residual -= sub\n                    \n                idx = 0\n                while residual > 1e-5 and idx < n_comm:\n                    if p_vals[idx] > L_arr[idx]:\n                        sub = min(residual, p_vals[idx] - L_arr[idx])\n                        p_vals[idx] -= sub\n                        residual -= sub\n                    idx += 1\n                    \n        # Assign dispatched values\n        for idx, i in enumerate(comm_list):\n            p_out[i] = p_vals[idx]\n            \n    # Set commitment status and outputs\n    for i in range(n_units):\n        if i in committed_units:\n            u_out[i] = 1\n        else:\n            u_out[i] = 0\n            p_out[i] = 0.0\n            \n    return np.array([u_out, p_out])",
          "from": "crossover",
          "gap_power_rate": 0.0054285364,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843403
     },
     {
          "name": "novel_hybrid_commitment",
          "algorithm": "1. Classify units into must-on (constrained by min up-time or shutdown ramp), must-off (constrained by min down-time), free-on (online and decomittable), free-off (offline and committable).\n2. Initialize commitment with must-on and free-on units. Compute effective power limits considering ramp constraints and startup limitations.\n3. Decomission highest cost-per-MW free-on units if over-generation exists and removal maintains feasibility (new total_min <= load and new total_max >= load).\n4. Commit free-off units with lowest (startup cost + cost at min-output) per MW until generation capacity meets or exceeds load.\n5. Perform post-commitment decomissioning of expensive free-on units that can be safely removed while maintaining feasibility.\n6. Dispatch by setting outputs to min/max if load is at bounds; otherwise perform lambda iteration respecting effective bounds.\n7. Set non-committed units to off.\n\n",
          "code": "import numpy as np\n\ndef novel_hybrid_commitment(units_info, load):\n    # Create a working copy with necessary attributes\n    units = []\n    for idx, unit_dict in enumerate(units_info):\n        unit = {key: unit_dict[key] for key in unit_dict}\n        unit['index'] = idx\n        \n        # Compute effective min and max power limits\n        if unit['u_i_0'] == 1:\n            min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n        unit['min_i'] = min_i\n        unit['max_i'] = max_i\n        unit['u_i'] = 0\n        unit['p_i'] = 0.0\n        units.append(unit)\n\n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for unit in units:\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(unit)\n            else:\n                free_on.append(unit)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(unit)\n            else:\n                free_off.append(unit)\n    \n    # Initialize commitment\n    committed_units = must_on + free_on\n    total_min = sum(unit['min_i'] for unit in committed_units)\n    total_max = sum(unit['max_i'] for unit in committed_units)\n    current_load = load[0]\n    \n    # Decomission free-on units if over-generation\n    changed = True\n    while changed and free_on:\n        changed = False\n        # Calculate cost per MW and sort descending\n        for unit in free_on:\n            min_i = unit['min_i']\n            unit['cost_per_mw'] = (unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i ** 2) / min_i\n        free_on_sorted = sorted(free_on, key=lambda x: x['cost_per_mw'], reverse=True)\n        \n        for candidate in free_on_sorted:\n            new_total_min = total_min - candidate['min_i']\n            new_total_max = total_max - candidate['max_i']\n            if new_total_min <= current_load <= new_total_max:\n                total_min = new_total_min\n                total_max = new_total_max\n                committed_units.remove(candidate)\n                free_on.remove(candidate)\n                changed = True\n                break\n    \n    # Commit free-off units if under-generation\n    if total_max < current_load and free_off:\n        # Calculate cost per MW and sort ascending\n        for unit in free_off:\n            min_i = unit['min_i']\n            unit['cost_per_mw'] = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i ** 2) / min_i\n        free_off_sorted = sorted(free_off, key=lambda x: x['cost_per_mw'])\n        \n        for candidate in free_off_sorted:\n            if total_max < current_load:\n                total_min += candidate['min_i']\n                total_max += candidate['max_i']\n                committed_units.append(candidate)\n                free_off.remove(candidate)\n            else:\n                break\n    \n    # Post-commitment decomissioning\n    free_on_committed = [u for u in committed_units if u in free_on]\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        for unit in free_on_committed:\n            min_i = unit['min_i']\n            unit['cost_per_mw'] = (unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * min_i ** 2) / min_i\n        free_on_committed_sorted = sorted(free_on_committed, key=lambda x: x['cost_per_mw'], reverse=True)\n        \n        for candidate in free_on_committed_sorted:\n            new_total_min = total_min - candidate['min_i']\n            new_total_max = total_max - candidate['max_i']\n            if new_total_min <= current_load <= new_total_max:\n                total_min = new_total_min\n                total_max = new_total_max\n                committed_units.remove(candidate)\n                free_on_committed.remove(candidate)\n                changed = True\n                break\n    \n    # Dispatch power\n    if current_load <= total_min:\n        for unit in committed_units:\n            unit['p_i'] = unit['min_i']\n            unit['u_i'] = 1\n    elif current_load >= total_max:\n        for unit in committed_units:\n            unit['p_i'] = unit['max_i']\n            unit['u_i'] = 1\n    else:\n        # Lambda iteration for economic dispatch\n        lam_low = min(unit['b_i'] + 2 * unit['c_i'] * unit['min_i'] for unit in committed_units)\n        lam_high = max(unit['b_i'] + 2 * unit['c_i'] * unit['max_i'] for unit in committed_units)\n        tol = 1e-6\n        max_iter = 100\n        for _ in range(max_iter):\n            lam = (lam_low + lam_high) / 2\n            total_p = 0\n            for unit in committed_units:\n                if lam < unit['b_i'] + 2 * unit['c_i'] * unit['min_i']:\n                    p_i = unit['min_i']\n                elif lam > unit['b_i'] + 2 * unit['c_i'] * unit['max_i']:\n                    p_i = unit['max_i']\n                else:\n                    p_i = (lam - unit['b_i']) / (2 * unit['c_i'])\n                total_p += p_i\n            \n            if abs(total_p - current_load) < tol:\n                break\n            elif total_p < current_load:\n                lam_low = lam\n            else:\n                lam_high = lam\n        \n        # Assign power based on final lambda\n        for unit in committed_units:\n            if lam < unit['b_i'] + 2 * unit['c_i'] * unit['min_i']:\n                unit['p_i'] = unit['min_i']\n            elif lam > unit['b_i'] + 2 * unit['c_i'] * unit['max_i']:\n                unit['p_i'] = unit['max_i']\n            else:\n                unit['p_i'] = (lam - unit['b_i']) / (2 * unit['c_i'])\n            unit['u_i'] = 1\n    \n    # Prepare output\n    u_list = [0] * len(units_info)\n    p_list = [0.0] * len(units_info)\n    for unit in units:\n        idx = unit['index']\n        u_list[idx] = unit['u_i']\n        p_list[idx] = unit['p_i']\n    \n    schedules = np.array([u_list, p_list])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0054285366,
          "gap_price_rate": 0.0091401443,
          "fitness": 0.0072843404
     },
     {
          "name": "enhanced_commitment_dispatch_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Initially commit must-on and free-on units. Compute effective power bounds for these units considering ramp constraints.\n3. If total effective minimum output exceeds load, iteratively decommit highest-cost-per-MW free-on units (prioritizing units with highest (a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) while ensuring remaining units can still meet load.\n4. If total effective maximum output is below load, iteratively commit most cost-effective free-off units (prioritizing units with lowest (s_i + a_i + b_i*p_min + c_i*p_min\u00b2)/p_min) until generation capacity meets or exceeds load.\n5. If load falls between adjusted total minimum and maximum, decommit any expensive free-on units that can be removed while maintaining load feasibility.\n6. Dispatch power to committed units:\n   - If total min > load: set all units to minimum output (over-generation)\n   - If total max < load: set all units to maximum output (under-generation)\n   - Else: perform economic dispatch via lambda iteration to minimize variable costs while satisfying load exactly.\n7. Set non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_dispatch_v1(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    u_current = np.zeros(n_units, dtype=int)\n    p_current = np.zeros(n_units)\n    \n    must_on, must_off, free_on, free_off = [], [], [], []\n    min_bound = np.zeros(n_units)\n    max_bound = np.zeros(n_units)\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            online_constrained = (t_i0 > 0 and t_i0 < t_on_min) or (p_i0 > unit['p_shut_i'])\n            if online_constrained:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            offline_constrained = (t_i0 < 0 and abs(t_i0) < t_off_min)\n            if offline_constrained:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment (must-on + free-on)\n    committed = set(must_on) | set(free_on)\n    for i in committed:\n        u_current[i] = 1\n        unit = units_info[i]\n        prev_power = unit['p_i_0']\n        min_bound[i] = max(unit['p_min_i'], prev_power - unit['p_down_i'])\n        max_bound[i] = min(unit['p_max_i'], prev_power + unit['p_up_i'])\n    \n    total_min = sum(min_bound[i] for i in committed)\n    total_max = sum(max_bound[i] for i in committed)\n    \n    # Decommit free-on units if over-generation\n    if total_min > current_load:\n        changed = True\n        while changed and total_min > current_load:\n            changed = False\n            free_on_committed = [i for i in free_on if i in committed]\n            if not free_on_committed:\n                break\n                \n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_max >= current_load:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n                    changed = True\n                    break\n    \n    # Commit free-off units if under-generation\n    if total_min <= current_load and total_max < current_load:\n        free_off_available = [i for i in free_off if i not in committed]\n        if free_off_available:\n            costs, min_vals, max_vals = [], [], []\n            for i in free_off_available:\n                unit = units_info[i]\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n                s, a, b, c = unit['s_i'], unit['a_i'], unit['b_i'], unit['c_i']\n                cost = (s + a + b*min_val + c*min_val**2) / min_val\n                costs.append(cost)\n                min_vals.append(min_val)\n                max_vals.append(max_val)\n            \n            idxs_sorted = np.argsort(costs)\n            for idx in idxs_sorted:\n                i = free_off_available[idx]\n                min_val, max_val = min_vals[idx], max_vals[idx]\n                new_min = total_min + min_val\n                new_max = total_max + max_val\n                committed.add(i)\n                u_current[i] = 1\n                min_bound[i], max_bound[i] = min_val, max_val\n                total_min, total_max = new_min, new_max\n                if new_max >= current_load:\n                    break\n    \n    # Final decommitment pass for expensive free-on units\n    if total_min <= current_load <= total_max:\n        free_on_committed = [i for i in free_on if i in committed]\n        if free_on_committed:\n            costs = []\n            for i in free_on_committed:\n                a, b, c = units_info[i]['a_i'], units_info[i]['b_i'], units_info[i]['c_i']\n                cost_min = a + b * min_bound[i] + c * min_bound[i]**2\n                costs.append(cost_min / min_bound[i])\n            \n            idxs_sorted = np.argsort(costs)[::-1]\n            for idx in idxs_sorted:\n                i = free_on_committed[idx]\n                new_min = total_min - min_bound[i]\n                new_max = total_max - max_bound[i]\n                if new_min <= current_load <= new_max:\n                    committed.remove(i)\n                    u_current[i] = 0\n                    total_min, total_max = new_min, new_max\n    \n    # Dispatch power to committed units\n    if committed:\n        if total_min > current_load:\n            for i in committed:\n                p_current[i] = min_bound[i]\n        elif total_max < current_load:\n            for i in committed:\n                p_current[i] = max_bound[i]\n        else:\n            low, high = None, None\n            for i in committed:\n                unit = units_info[i]\n                marginal_min = unit['b_i'] + 2 * unit['c_i'] * min_bound[i]\n                marginal_max = unit['b_i'] + 2 * unit['c_i'] * max_bound[i]\n                low = marginal_min if low is None else min(low, marginal_min)\n                high = marginal_max if high is None else max(high, marginal_max)\n            \n            if low == high:\n                for i in committed:\n                    p_current[i] = min_bound[i]\n            else:\n                for _ in range(100):\n                    lam = (low + high) / 2\n                    total_power = 0\n                    for i in committed:\n                        unit = units_info[i]\n                        if unit['c_i'] > 0:\n                            p = (lam - unit['b_i']) / (2 * unit['c_i'])\n                            p = max(min_bound[i], min(max_bound[i], p))\n                            total_power += p\n                    \n                    if abs(total_power - current_load) < 1e-5:\n                        break\n                    elif total_power < current_load:\n                        low = lam\n                    else:\n                        high = lam\n                \n                for i in committed:\n                    unit = units_info[i]\n                    if unit['c_i'] > 0:\n                        p_current[i] = (lam - unit['b_i']) / (2 * unit['c_i'])\n                        p_current[i] = max(min_bound[i], min(max_bound[i], p_current[i]))\n    \n    return np.array([u_current, p_current])",
          "from": "crossover",
          "gap_power_rate": 0.0054285377,
          "gap_price_rate": 0.0091401442,
          "fitness": 0.0072843409
     },
     {
          "name": "enhanced_dynamic_hybrid_commitment_v2",
          "algorithm": "1. Classify units into must-on (constrained online by min up-time or shutdown capacity), must-off (constrained offline by min down-time), free-on (online and decomittable), and free-off (offline and committable)\n2. Initialize commitment with must-on and free-on units. Compute effective power limits based on ramp constraints and startup/shutdown limitations\n3. If total effective minimum output exceeds load, iteratively decommission free-on units with highest variable cost per MW at minimum output while ensuring feasibility\n4. If total effective maximum output is below load, iteratively commit free-off units with lowest total cost per MW at minimum output (startup + fixed + variable) until capacity meets or exceeds load\n5. Perform iterative post-commitment decommissioning of remaining free-on units by descending cost efficiency, allowing multiple removals per iteration\n6. Dispatch power:\n   - Set outputs to effective minimum if load \u2264 total minimum\n   - Set outputs to effective maximum if load \u2265 total maximum\n   - Use Lambda iteration with bounds clamping for economic dispatch otherwise\n7. Set non-committed units to off (u_i=0, p_i=0)\n\n",
          "code": "import numpy as np\n\ndef enhanced_dynamic_hybrid_commitment_v2(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    committed = [False] * n_units\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        \n        if u_i0 == 1:  # Currently online\n            min_up = unit['t_on_min_i']\n            if t_i0 < min_up or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n            # Compute effective limits for online units\n            effective_min[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            effective_max[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Currently offline\n            min_down = unit['t_off_min_i']\n            if abs(t_i0) < min_down:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n            effective_min[i] = 0\n            effective_max[i] = 0\n\n    # Step 2: Initialize commitment\n    committed = [False] * n_units\n    for i in must_on + free_on:\n        committed[i] = True\n    total_min = sum(effective_min[i] for i in must_on + free_on)\n    total_max = sum(effective_max[i] for i in must_on + free_on)\n    \n    # Identify initial free-on units (for later reference)\n    initial_free_on = set(free_on)\n    \n    # Step 3: Decomission free-on units if over-generation\n    if total_min > current_load:\n        free_on_sorted = sorted(\n            free_on,\n            key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i'],\n            reverse=True\n        )\n        removed = True\n        while removed and total_min > current_load and free_on_sorted:\n            removed = False\n            for i in free_on_sorted[:]:\n                new_min = total_min - effective_min[i]\n                new_max = total_max - effective_max[i]\n                if new_min <= current_load <= new_max:\n                    committed[i] = False\n                    free_on.remove(i)\n                    free_on_sorted.remove(i)\n                    total_min = new_min\n                    total_max = new_max\n                    removed = True\n                    break\n    \n    # Step 4: Commit free-off units if under-generation\n    if total_max < current_load and free_off:\n        free_off_sorted = sorted(\n            free_off,\n            key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                          units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                          units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i']\n        )\n        for i in free_off_sorted:\n            if total_max >= current_load:\n                break\n            min_p = units_info[i]['p_min_i']\n            max_p = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            if total_min + min_p <= current_load:\n                committed[i] = True\n                effective_min[i] = min_p\n                effective_max[i] = max_p\n                total_min += min_p\n                total_max += max_p\n\n    # Step 5: Post-commitment decommissioning\n    remaining_free_on = [i for i in initial_free_on if committed[i]]\n    if remaining_free_on:\n        changed = True\n        while changed and remaining_free_on:\n            changed = False\n            remaining_free_on_sorted = sorted(\n                remaining_free_on,\n                key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                              units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2) / units_info[i]['p_min_i'],\n                reverse=True\n            )\n            for i in remaining_free_on_sorted:\n                new_min = total_min - effective_min[i]\n                new_max = total_max - effective_max[i]\n                if new_min <= current_load <= new_max:\n                    committed[i] = False\n                    remaining_free_on.remove(i)\n                    total_min = new_min\n                    total_max = new_max\n                    changed = True\n                    break\n    \n    # Recompute effective limits for dispatch\n    for i in range(n_units):\n        if committed[i]:\n            if units_info[i]['u_i_0'] == 1:\n                effective_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                effective_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                effective_min[i] = units_info[i]['p_min_i']\n                effective_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = sum(effective_min[i] for i in range(n_units) if committed[i])\n    total_max = sum(effective_max[i] for i in range(n_units) if committed[i])\n    \n    # Initialize outputs\n    p_output = np.zeros(n_units)\n    u_output = np.zeros(n_units)\n\n    # Step 6: Dispatch\n    if total_min <= current_load <= total_max:\n        committed_indices = [i for i in range(n_units) if committed[i]]\n        n_committed = len(committed_indices)\n        if n_committed == 0:\n            # Edge case: no committed units\n            schedules = np.zeros((2, n_units))\n            return schedules\n        \n        # Lambda iteration\n        low_lambda = 0\n        high_lambda = 0\n        for idx in committed_indices:\n            unit = units_info[idx]\n            inc_min = unit['b_i'] + 2 * unit['c_i'] * effective_min[idx]\n            inc_max = unit['b_i'] + 2 * unit['c_i'] * effective_max[idx]\n            if unit['c_i'] == 0:\n                inc_min = unit['b_i']\n                inc_max = unit['b_i']\n            low_lambda = min(low_lambda, inc_min) if low_lambda != 0 else inc_min\n            high_lambda = max(high_lambda, inc_max) if high_lambda != 0 else inc_max\n        \n        low_lambda -= 1\n        high_lambda += 1\n        tol = 1e-5\n        max_iter = 1000\n        \n        for _ in range(max_iter):\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_power = 0\n            for idx in committed_indices:\n                unit = units_info[idx]\n                if unit['c_i'] > 0:\n                    p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                    p_i = max(effective_min[idx], min(effective_max[idx], p_i))\n                else:  # Linear cost\n                    p_i = effective_max[idx] if mid_lambda >= unit['b_i'] else effective_min[idx]\n                total_power += p_i\n            \n            if abs(total_power - current_load) < tol:\n                break\n            \n            if total_power < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n        else:\n            # Fallback: min distribution for quadratic units, max for linear\n            for idx in committed_indices:\n                unit = units_info[idx]\n                if unit['c_i'] > 0:\n                    p_output[idx] = effective_min[idx]\n                else:\n                    p_output[idx] = effective_max[idx]\n            total_min = sum(p_output[i] for i in range(n_units))\n            residual = current_load - total_min\n            # Distribute residual to quadratic units within limits\n            if residual > 0:\n                quad_units = [i for i in committed_indices if units_info[i]['c_i'] > 0]\n                for idx in quad_units:\n                    available = effective_max[idx] - effective_min[idx]\n                    alloc = min(available, residual)\n                    p_output[idx] += alloc\n                    residual -= alloc\n                    if residual <= 0:\n                        break\n        # Set outputs from lambda iteration\n        for idx in committed_indices:\n            unit = units_info[idx]\n            if unit['c_i'] > 0:\n                p_i = (mid_lambda - unit['b_i']) / (2 * unit['c_i'])\n                p_i = max(effective_min[idx], min(effective_max[idx], p_i))\n            else:\n                p_i = effective_max[idx] if mid_lambda >= unit['b_i'] else effective_min[idx]\n            p_output[idx] = p_i\n            \n    else:  # Boundary conditions\n        for i in range(n_units):\n            if committed[i]:\n                if current_load <= total_min:\n                    p_output[i] = effective_min[i]\n                else:  # current_load >= total_max\n                    p_output[i] = effective_max[i]\n    \n    # Set commitment status and zero-outputs\n    for i in range(n_units):\n        u_output[i] = 1 if committed[i] else 0\n        if not committed[i]:\n            p_output[i] = 0\n    \n    return np.vstack([u_output, p_output])",
          "from": "mutation",
          "gap_power_rate": 0.0054285376,
          "gap_price_rate": 0.0091401444,
          "fitness": 0.007284341
     },
     {
          "name": "refined_dynamic_hybrid_commitment_v1",
          "algorithm": "1. Classify units into must-on (constrained to remain online), must-off (constrained to remain offline), free-on (online and decomittable), and free-off (offline and committable)\n2. Initially commit must-on and free-on units, compute effective power bounds considering ramp constraints\n3. Decomission highest cost/MW free-on units if over-generation exists while ensuring feasibility\n4. Commit free-off units with lowest (startup + min-output cost)/min-output if under-generation exists\n5. Post-commitment decomissioning of expensive free-on units that can be safely removed\n6. Dispatch by setting outputs to min/max or via \u03bb-iteration economic dispatch\n7. Set non-committed units to off (0 output)\n\n",
          "code": "import numpy as np\n\ndef refined_dynamic_hybrid_commitment_v1(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    min_eff = [0] * n_units\n    max_eff = [0] * n_units\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut_i = unit['p_shut_i']\n        t_on_min_i = unit['t_on_min_i']\n        t_off_min_i = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min_i or p_i0 > p_shut_i:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i0 < t_off_min_i:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    committed = must_on[:] + free_on[:]\n    free_on_committed = free_on[:]\n    \n    total_min = 0\n    total_max = 0\n    for i in committed:\n        unit = units_info[i]\n        min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        total_min += min_eff[i]\n        total_max += max_eff[i]\n    \n    current_total_min = total_min\n    current_total_max = total_max\n    \n    # Decommit free-on if over-generation\n    while current_total_min > current_load and free_on_committed:\n        candidates = []\n        for i in free_on_committed:\n            new_total_max = current_total_max - max_eff[i]\n            if new_total_max >= current_load:\n                unit = units_info[i]\n                cost_per_mw = (unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * (min_eff[i]**2)) / min_eff[i]\n                candidates.append((i, cost_per_mw))\n        \n        if not candidates:\n            break\n        \n        i_candidate = max(candidates, key=lambda x: x[1])[0]\n        committed.remove(i_candidate)\n        free_on_committed.remove(i_candidate)\n        current_total_min -= min_eff[i_candidate]\n        current_total_max -= max_eff[i_candidate]\n    \n    # Commit free-off if under-generation\n    while current_total_max < current_load and free_off:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            min_i = unit['p_min_i']\n            max_i = min(unit['p_max_i'], unit['p_start_i'])\n            cost_per_mw = (unit['s_i'] + unit['a_i'] + unit['b_i'] * min_i + unit['c_i'] * (min_i**2)) / min_i\n            candidates.append((i, cost_per_mw, min_i, max_i))\n        \n        if not candidates:\n            break\n        \n        i_candidate, _, min_candidate, max_candidate = min(candidates, key=lambda x: x[1])\n        committed.append(i_candidate)\n        free_off.remove(i_candidate)\n        min_eff[i_candidate] = min_candidate\n        max_eff[i_candidate] = max_candidate\n        current_total_min += min_candidate\n        current_total_max += max_candidate\n    \n    # Post-commitment decommitment\n    changed = True\n    while changed and free_on_committed:\n        changed = False\n        candidates = []\n        for i in free_on_committed:\n            unit = units_info[i]\n            cost_per_mw = (unit['a_i'] + unit['b_i'] * min_eff[i] + unit['c_i'] * (min_eff[i]**2)) / min_eff[i]\n            candidates.append((i, cost_per_mw))\n        \n        if not candidates:\n            break\n        \n        candidates_sorted = sorted(candidates, key=lambda x: x[1], reverse=True)\n        for cand in candidates_sorted:\n            i_candidate = cand[0]\n            new_total_min = current_total_min - min_eff[i_candidate]\n            new_total_max = current_total_max - max_eff[i_candidate]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                committed.remove(i_candidate)\n                free_on_committed.remove(i_candidate)\n                current_total_min = new_total_min\n                current_total_max = new_total_max\n                changed = True\n                break\n    \n    # Dispatch\n    p_outputs = [0] * n_units\n    if current_total_min >= current_load:\n        for i in committed:\n            p_outputs[i] = min_eff[i]\n    elif current_total_max <= current_load:\n        for i in committed:\n            p_outputs[i] = max_eff[i]\n    else:\n        bs, cs, mins_arr, maxs_arr, indices = [], [], [], [], []\n        for i in committed:\n            unit = units_info[i]\n            bs.append(unit['b_i'])\n            cs.append(unit['c_i'])\n            mins_arr.append(min_eff[i])\n            maxs_arr.append(max_eff[i])\n            indices.append(i)\n        \n        low_lambda = min(b_i + 2*c_i*min_i for b_i, c_i, min_i in zip(bs, cs, mins_arr))\n        high_lambda = max(b_i + 2*c_i*max_i for b_i, c_i, max_i in zip(bs, cs, maxs_arr))\n        \n        p_alloc = [0] * len(committed)\n        tol, max_iter = 1e-6, 1000\n        iter_count = 0\n        \n        while (high_lambda - low_lambda) > tol and iter_count < max_iter:\n            mid_lambda = (low_lambda + high_lambda) / 2\n            total_p = 0\n            for idx in range(len(committed)):\n                desired = (mid_lambda - bs[idx]) / (2 * cs[idx])\n                p_alloc[idx] = max(mins_arr[idx], min(maxs_arr[idx], desired))\n                total_p += p_alloc[idx]\n            \n            if total_p < current_load:\n                low_lambda = mid_lambda\n            else:\n                high_lambda = mid_lambda\n            iter_count += 1\n        \n        for idx, i in enumerate(indices):\n            p_outputs[i] = p_alloc[idx]\n    \n    u_states = [1 if i in committed else 0 for i in range(n_units)]\n    return np.array([u_states, p_outputs])",
          "from": "mutation",
          "gap_power_rate": 0.005428589,
          "gap_price_rate": 0.009140149,
          "fitness": 0.007284369
     },
     {
          "name": "enhanced_rolling_commitment_dispatch_v2",
          "algorithm": "1. Classify units into must-on (constrained online), must-off (constrained offline), free-on (online units eligible for shutdown), and free-off (offline units eligible for startup) based on current state and constraints.\n2. Commit must-on and free-on units. Compute effective power bounds considering ramp constraints and startup/shutdown limits.\n3. If total effective minimum output exceeds load, iteratively decommit highest variable cost-per-MW free-on units while ensuring remaining units can satisfy load constraints.\n4. If total effective maximum output is below load, iteratively commit lowest (startup cost + min-output cost)/min-output free-off units until generation capacity meets or exceeds load.\n5. After step 4, perform post-commitment decommitment of highest variable cost-per-MW free-on units while maintaining load feasibility.\n6. Dispatch load to committed units: set outputs to minimum if load \u2264 total minimum; set to maximum if load \u2265 total maximum; otherwise perform economic dispatch via lambda iteration.\n7. Set all non-committed units to off (0 output).\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_dispatch_v2(units_info, load):\n    n = len(units_info)\n    u_current = [0] * n\n    p_current = [0] * n\n    effective_min = [0] * n\n    effective_max = [0] * n\n    categories = [''] * n\n    \n    current_load = load[0]\n    \n    # Step 1: Classify units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                categories[i] = 'must-on'\n            else:\n                categories[i] = 'free-on'\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                categories[i] = 'must-off'\n            else:\n                categories[i] = 'free-off'\n    \n    # Initialize committed units and total capacities\n    committed = []\n    total_min = 0.0\n    total_max = 0.0\n    \n    # Step 2: Commit must-on and free-on units, compute effective bounds\n    for i, unit in enumerate(units_info):\n        if categories[i] in ['must-on', 'free-on']:\n            u_current[i] = 1\n            committed.append(i)\n            if unit['u_i_0'] == 1:\n                min_val = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_val = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_val = unit['p_min_i']\n                max_val = min(unit['p_max_i'], unit['p_start_i'])\n            effective_min[i] = min_val\n            effective_max[i] = max_val\n            total_min += min_val\n            total_max += max_val\n    \n    # Collect free-on units in committed set\n    free_on_committed = [i for i in committed if categories[i] == 'free-on']\n    \n    # Step 3: Over-generation decommitment\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed if categories[i] == 'free-on' and u_current[i] == 1]\n        if not free_on_committed:\n            break\n        candidates = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + units_info[i]['c_i'] * effective_min[i] ** 2\n            cost_per_mw = cost / effective_min[i]\n            candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for (i, cost_per_mw) in candidates:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u_current[i] = 0\n                committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 4: Under-generation commitment\n    free_off = [i for i in range(n) if categories[i] == 'free-off' and u_current[i] == 0]\n    candidates = []\n    for i in free_off:\n        min_val = units_info[i]['p_min_i']\n        start_cost = units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * min_val + units_info[i]['c_i'] * min_val ** 2\n        cost_per_mw = start_cost / min_val\n        candidates.append((i, cost_per_mw))\n    candidates.sort(key=lambda x: x[1])\n    \n    for (i, cost_per_mw) in candidates:\n        if total_max >= current_load:\n            break\n        min_val = units_info[i]['p_min_i']\n        max_val = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        u_current[i] = 1\n        committed.append(i)\n        effective_min[i] = min_val\n        effective_max[i] = max_val\n        total_min += min_val\n        total_max += max_val\n    \n    # Step 5: Post-commitment decommitment\n    changed = True\n    while changed:\n        changed = False\n        free_on_committed = [i for i in committed if categories[i] == 'free-on' and u_current[i] == 1]\n        if not free_on_committed:\n            break\n        candidates = []\n        for i in free_on_committed:\n            cost = units_info[i]['a_i'] + units_info[i]['b_i'] * effective_min[i] + units_info[i]['c_i'] * effective_min[i] ** 2\n            cost_per_mw = cost / effective_min[i]\n            candidates.append((i, cost_per_mw))\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        \n        for (i, cost_per_mw) in candidates:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u_current[i] = 0\n                committed.remove(i)\n                total_min = new_total_min\n                total_max = new_total_max\n                changed = True\n                break\n    \n    # Step 6: Dispatch\n    if abs(current_load - total_min) < 1e-6:\n        for i in committed:\n            p_current[i] = effective_min[i]\n    elif abs(current_load - total_max) < 1e-6:\n        for i in committed:\n            p_current[i] = effective_max[i]\n    else:\n        low = 0\n        high = 0\n        for i in committed:\n            mc_min = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_min[i]\n            mc_max = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * effective_max[i]\n            if mc_min < low:\n                low = mc_min\n            if mc_max > high:\n                high = mc_max\n        \n        if low == 0 and high == 0:\n            low = min(unit['b_i'] for unit in units_info)\n            high = max(unit['b_i'] for unit in units_info)\n        \n        tol = 0.001\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2.0\n            total_p = 0.0\n            for i in committed:\n                c = units_info[i]['c_i']\n                b = units_info[i]['b_i']\n                if c == 0:\n                    if lam >= b:\n                        p = effective_max[i]\n                    else:\n                        p = effective_min[i]\n                else:\n                    p_ideal = (lam - b) / (2 * c)\n                    p = max(effective_min[i], min(effective_max[i], p_ideal))\n                p_current[i] = p\n                total_p += p\n            \n            if abs(total_p - current_load) < tol:\n                break\n            if total_p < current_load:\n                low = lam\n            else:\n                high = lam\n    \n    # Step 7: Set non-committed units\n    for i in range(n):\n        if not u_current[i]:\n            p_current[i] = 0.0\n    \n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0054286675,
          "gap_price_rate": 0.009140107,
          "fitness": 0.0072843873
     }
]