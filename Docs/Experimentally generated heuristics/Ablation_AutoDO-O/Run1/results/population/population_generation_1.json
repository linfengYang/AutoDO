[
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Identify must-run units that were online in the previous period and either haven't satisfied minimum up-time or exceeded shutdown capacity.\n2. Compute total minimum and available maximum capacity from must-run units considering ramp constraints.\n3. If total minimum exceeds load, set must-run units to their lower bounds (over-generation).\n4. If load is within must-run capacity, dispatch only must-run units to meet load.\n5. Otherwise, consider candidate units (non-must-run that can be turned on/left on) sorted by cost per MW at minimum output.\n6. Add cheapest candidates until total available capacity meets or exceeds load.\n7. Dispatch all committed units using lambda iteration to minimize cost while respecting ramp and output limits.\n8. Return commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = [0] * n_units\n    p = [0.0] * n_units\n    \n    # Step 1: Identify must-run units\n    must_run = []\n    for idx, unit in enumerate(units_info):\n        u_i_0 = unit['u_i_0']\n        if u_i_0 == 1:  # was online\n            t_i_0 = unit['t_i_0']\n            t_on_min_i = unit['t_on_min_i']\n            p_i_0 = unit['p_i_0']\n            p_shut_i = unit['p_shut_i']\n            if t_i_0 < t_on_min_i or p_i_0 > p_shut_i:\n                must_run.append(idx)\n                u[idx] = 1\n    \n    # Step 2: Compute bounds for must-run units\n    total_min_must = 0.0\n    total_available_max_must = 0.0\n    bounds = {}\n    for idx in must_run:\n        unit = units_info[idx]\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_i_0 = unit['p_i_0']\n        p_up_i = unit['p_up_i']\n        p_down_i = unit['p_down_i']\n        \n        lb_i = max(p_min_i, p_i_0 - p_down_i)\n        ub_i = min(p_max_i, p_i_0 + p_up_i)\n        bounds[idx] = (lb_i, ub_i)\n        total_min_must += lb_i\n        total_available_max_must += ub_i\n    \n    # Step 3: Over-generation case\n    if total_min_must > current_load:\n        for idx in must_run:\n            lb_i, _ = bounds[idx]\n            p[idx] = lb_i\n        return np.array([u, p])\n    \n    # Step 4: Load within must-run capacity\n    if current_load <= total_available_max_must:\n        committed = must_run\n    else:\n        # Step 5: Prepare candidate units\n        candidate_units = []\n        for idx, unit in enumerate(units_info):\n            if idx in must_run:\n                continue\n            u_i_0 = unit['u_i_0']\n            t_i_0 = unit['t_i_0']\n            t_off_min_i = unit['t_off_min_i']\n            a_i = unit['a_i']\n            b_i = unit['b_i']\n            c_i = unit['c_i']\n            s_i = unit['s_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            p_i_0 = unit['p_i_0']\n            p_up_i = unit['p_up_i']\n            p_down_i = unit['p_down_i']\n            p_start_i = unit['p_start_i']\n            \n            # Check if can be committed\n            if u_i_0 == 1:  # Type 2: online but not must-run\n                cost_per_MW = (a_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_i_0 + p_up_i)\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type2'))\n            elif t_i_0 <= -t_off_min_i:  # Type 3: offline and can be turned on\n                cost_per_MW = (a_i + s_i + b_i * p_min_i + c_i * p_min_i**2) / p_min_i\n                available_capacity = min(p_max_i, p_start_i)\n                lb_i = p_min_i\n                candidate_units.append((cost_per_MW, idx, available_capacity, lb_i, 'type3'))\n        \n        # Sort by cost per MW\n        candidate_units.sort(key=lambda x: x[0])\n        committed_candidates = []\n        total_available_max = total_available_max_must\n        \n        # Step 6: Add candidates until capacity meets load\n        for cand in candidate_units:\n            if total_available_max >= current_load:\n                break\n            cost_per_MW, idx, available_capacity, lb_i, unit_type = cand\n            total_available_max += available_capacity\n            committed_candidates.append((idx, lb_i, available_capacity, unit_type))\n            u[idx] = 1  # Commit unit\n        \n        committed = must_run + [idx for (idx, _, _, _) in committed_candidates]\n        # Update bounds for candidate units\n        for cand in committed_candidates:\n            idx, lb_i, available_capacity, unit_type = cand\n            if unit_type == 'type2':\n                unit = units_info[idx]\n                p_i_0 = unit['p_i_0']\n                p_down_i = unit['p_down_i']\n                p_min_i = unit['p_min_i']\n                lb_i = max(p_min_i, p_i_0 - p_down_i)\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # type3\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n            bounds[idx] = (lb_i, ub_i)\n    \n    # Step 7: Dispatch for all committed units\n    lb_list = []\n    ub_list = []\n    b_coeffs = []\n    c_coeffs = []\n    committed_idxs = []\n    total_lb = 0.0\n    total_ub = 0.0\n    \n    for idx in committed:\n        lb_i, ub_i = bounds.get(idx, (0.0, 0.0))\n        if idx not in must_run and u[idx] == 1:\n            unit = units_info[idx]\n            if unit['u_i_0'] == 1:  # Type2\n                p_i_0 = unit['p_i_0']\n                lb_i = max(unit['p_min_i'], p_i_0 - unit['p_down_i'])\n                ub_i = min(unit['p_max_i'], p_i_0 + unit['p_up_i'])\n            else:  # Type3\n                lb_i = unit['p_min_i']\n                ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb_list.append(lb_i)\n        ub_list.append(ub_i)\n        b_coeffs.append(units_info[idx]['b_i'])\n        c_i = units_info[idx]['c_i']\n        if c_i == 0:  # Avoid division by zero\n            c_i = 1e-6\n        c_coeffs.append(c_i)\n        committed_idxs.append(idx)\n        total_lb += lb_i\n        total_ub += ub_i\n    \n    # Handle infeasible dispatch\n    if current_load < total_lb or current_load > total_ub:\n        for idx in committed:\n            if current_load < total_lb:\n                p[idx] = lb_list[committed_idxs.index(idx)]\n            else:\n                p[idx] = ub_list[committed_idxs.index(idx)]\n        return np.array([u, p])\n    \n    # Lambda iteration for economic dispatch\n    low_lam = min(2 * c_i * lb_i + b_i for lb_i, b_i, c_i in zip(lb_list, b_coeffs, c_coeffs))\n    high_lam = max(2 * c_i * ub_i + b_i for ub_i, b_i, c_i in zip(ub_list, b_coeffs, c_coeffs))\n    \n    for _ in range(100):\n        mid_lam = (low_lam + high_lam) / 2\n        total_p = 0.0\n        for i in range(len(committed_idxs)):\n            lb_i = lb_list[i]\n            ub_i = ub_list[i]\n            b_i = b_coeffs[i]\n            c_i = c_coeffs[i]\n            if mid_lam <= 2 * c_i * lb_i + b_i:\n                p_val = lb_i\n            elif mid_lam >= 2 * c_i * ub_i + b_i:\n                p_val = ub_i\n            else:\n                p_val = (mid_lam - b_i) / (2 * c_i)\n            total_p += p_val\n        \n        if abs(total_p - current_load) < 1e-3:\n            break\n        if total_p < current_load:\n            low_lam = mid_lam\n        else:\n            high_lam = mid_lam\n    \n    # Set final power outputs\n    for i, idx in enumerate(committed_idxs):\n        lb_i = lb_list[i]\n        ub_i = ub_list[i]\n        b_i = b_coeffs[i]\n        c_i = c_coeffs[i]\n        if mid_lam <= 2 * c_i * lb_i + b_i:\n            p_val = lb_i\n        elif mid_lam >= 2 * c_i * ub_i + b_i:\n            p_val = ub_i\n        else:\n            p_val = (mid_lam - b_i) / (2 * c_i)\n        p[idx] = p_val\n    \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00461,
          "gap_price_rate": 0.01713,
          "fitness": 0.01087
     },
     {
          "name": "commit_units_by_min_startup_cost_heuristic",
          "algorithm": "1. Classify units into must-on (due to min up-time or shutdown ramp constraints), must-off (due to min down-time), free-on (can be turned off), and free-off (can be turned on).\n2. Start with must-on and free-on units committed. Attempt economic dispatch to meet load.\n3. If dispatch fails, turn on free-off units in priority order (lowest startup cost per MW plus marginal cost at min output) until dispatch succeeds.\n4. If dispatch succeeds with excess capacity at minimum output, attempt to turn off free-on units not needed to meet load to reduce costs.\n5. Perform final economic dispatch and return schedules.\n\n",
          "code": "import numpy as np\n\ndef economic_dispatch(online_units, load):\n    n = len(online_units)\n    lb = []\n    ub = []\n    indices = []\n    for unit in online_units:\n        if unit['u_i_0'] == 1:\n            lb_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb_i = unit['p_min_i']\n            ub_i = min(unit['p_max_i'], unit['p_start_i'])\n        lb.append(lb_i)\n        ub.append(ub_i)\n        indices.append(unit['index'])\n    \n    total_lb = sum(lb)\n    total_ub = sum(ub)\n    \n    if total_lb > load or total_ub < load:\n        return None, None\n    \n    units_dispatch = []\n    for i, unit in enumerate(online_units):\n        mc = unit['b_i'] + 2 * unit['c_i'] * lb[i]\n        units_dispatch.append((mc, lb[i], ub[i], i, unit['index']))\n    \n    units_dispatch.sort(key=lambda x: x[0])\n    \n    p = lb.copy()\n    total = total_lb\n    gap = load - total\n    \n    for i in range(len(units_dispatch)):\n        mc, lb_i, ub_i, idx, unit_idx = units_dispatch[i]\n        add = min(gap, ub_i - lb_i)\n        p[idx] += add\n        gap -= add\n        if gap <= 1e-5:\n            break\n    \n    if gap > 1e-5:\n        return None, None\n    \n    dispatch_dict = {}\n    for i in range(len(online_units)):\n        dispatch_dict[indices[i]] = p[i]\n    \n    total_cost = 0\n    for i, unit in enumerate(online_units):\n        if unit['u_i_0'] == 0:\n            total_cost += unit['s_i']\n        total_cost += unit['a_i'] + unit['b_i'] * p[i] + unit['c_i'] * (p[i] ** 2)\n    \n    return dispatch_dict, total_cost\n\ndef commit_units_by_min_startup_cost_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] < 0 and abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    online_set = must_on + free_on\n    online_units = [{'index': i, **units_info[i]} for i in online_set]\n    dispatch_result, _ = economic_dispatch(online_units, current_load)\n    \n    if dispatch_result is None:\n        candidates = []\n        for i in free_off:\n            unit = units_info[i]\n            key = unit['s_i'] / unit['p_max_i'] + (unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i'])\n            candidates.append((key, i))\n        candidates.sort(key=lambda x: x[0])\n        \n        for key, i in candidates:\n            online_set.append(i)\n            online_units = [{'index': j, **units_info[j]} for j in online_set]\n            dispatch_result, _ = economic_dispatch(online_units, current_load)\n            if dispatch_result is not None:\n                break\n        \n        if dispatch_result is None:\n            dispatch_result = {}\n            for i in online_set:\n                if units_info[i]['u_i_0'] == 1:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n                else:\n                    ub_i = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n                dispatch_result[i] = ub_i\n    \n    else:\n        candidates = []\n        for i in free_on:\n            if i in online_set and i in dispatch_result:\n                if units_info[i]['u_i_0'] == 1:\n                    lb_i = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                else:\n                    lb_i = units_info[i]['p_min_i']\n                if abs(dispatch_result[i] - lb_i) < 1e-5:\n                    saving = units_info[i]['a_i'] + units_info[i]['b_i'] * dispatch_result[i] + units_info[i]['c_i'] * (dispatch_result[i] ** 2)\n                    candidates.append((saving, i))\n        \n        candidates.sort(key=lambda x: x[0], reverse=True)\n        for saving, i in candidates:\n            new_online_set = [j for j in online_set if j != i]\n            new_online_units = [{'index': j, **units_info[j]} for j in new_online_set]\n            new_dispatch, _ = economic_dispatch(new_online_units, current_load)\n            if new_dispatch is not None:\n                online_set = new_online_set\n                dispatch_result = new_dispatch\n                break\n    \n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        if i in online_set and i in dispatch_result:\n            schedules[0, i] = 1\n            schedules[1, i] = dispatch_result[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": null,
          "gap_power_rate": 0.00088,
          "gap_price_rate": 0.0224,
          "fitness": 0.01164
     },
     {
          "name": "rolling_uc_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef rolling_uc_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    category_list = []\n    for unit in units_info:\n        u_i_0 = unit['u_i_0']\n        t_i_0 = unit['t_i_0']\n        p_i_0 = unit['p_i_0']\n        if u_i_0 == 1:\n            if t_i_0 < unit['t_on_min_i'] or p_i_0 > unit['p_shut_i']:\n                category_list.append('must_on')\n            else:\n                category_list.append('free_on')\n        else:\n            if -t_i_0 < unit['t_off_min_i']:\n                category_list.append('must_off')\n            else:\n                category_list.append('free_off')\n    \n    u = [1 if cat in ['must_on', 'free_on'] else 0 for cat in category_list]\n    min_p_arr = [0] * n_units\n    max_p_arr = [0] * n_units\n    \n    def compute_bounds(i, committed):\n        unit = units_info[i]\n        if committed:\n            if unit['u_i_0'] == 1:\n                min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_p = unit['p_min_i']\n                max_p = min(unit['p_max_i'], unit['p_start_i'])\n        else:\n            min_p, max_p = 0, 0\n        return min_p, max_p\n\n    for i in range(n_units):\n        min_p_arr[i], max_p_arr[i] = compute_bounds(i, u[i])\n    \n    total_min = sum(min_p_arr)\n    total_max = sum(max_p_arr)\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    free_off_avail = [i for i, cat in enumerate(category_list) if cat == 'free_off' and u[i] == 0]\n    candidate_costs = []\n    for i in free_off_avail:\n        unit = units_info[i]\n        min_p = unit['p_min_i']\n        total_cost = unit['s_i'] + unit['a_i'] + unit['b_i'] * min_p + unit['c_i'] * (min_p ** 2)\n        cost_per_MW = total_cost / min_p if min_p > 0 else float('inf')\n        candidate_costs.append((i, cost_per_MW))\n    candidate_costs.sort(key=lambda x: x[1])\n    \n    for i, _ in candidate_costs:\n        if total_max >= current_load:\n            break\n        if u[i] == 0:\n            u[i] = 1\n            min_p_val, max_p_val = compute_bounds(i, True)\n            min_p_arr[i] = min_p_val\n            max_p_arr[i] = max_p_val\n            total_min += min_p_val\n            total_max += max_p_val\n    \n    free_on_committed = [i for i, cat in enumerate(category_list) if cat == 'free_on' and u[i] == 1]\n    changed = True\n    while changed and total_min > current_load:\n        changed = False\n        free_on_committed = [i for i in free_on_committed if u[i] == 1]\n        free_on_committed.sort(key=lambda i: min_p_arr[i], reverse=True)\n        for i in free_on_committed:\n            new_total_min = total_min - min_p_arr[i]\n            new_total_max = total_max - max_p_arr[i]\n            if new_total_min <= current_load and new_total_max >= current_load:\n                u[i] = 0\n                total_min = new_total_min\n                total_max = new_total_max\n                min_p_arr[i], max_p_arr[i] = compute_bounds(i, False)\n                changed = True\n                break\n    \n    p_alloc = [min_p_arr[i] if u[i] == 1 else 0 for i in range(n_units)]\n    remaining = current_load - sum(p_alloc)\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    \n    while remaining > 1e-6:\n        candidate = -1\n        min_mc = float('inf')\n        for i in committed_indices:\n            if p_alloc[i] < max_p_arr[i]:\n                mc = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_alloc[i]\n                if mc < min_mc:\n                    min_mc = mc\n                    candidate = i\n        if candidate == -1:\n            break\n        delta = min(remaining, max_p_arr[candidate] - p_alloc[candidate])\n        p_alloc[candidate] += delta\n        remaining -= delta\n    \n    return np.array([u, p_alloc])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "dynamic_commitment_with_dispatch",
          "algorithm": "1. Classify units as must-on, must-off, free-on, or free-off based on prior state and constraints. Must-on units include those that haven't satisfied minimum up-time or whose prior output exceeds shutdown ramp capacity. Must-off units are those that haven't satisfied minimum down-time.  \n2. Initially commit must-on and free-on units.  \n3. Calculate effective power limits:  \n   - For previously online units: min = max(p_min, p_prev - ramp_down), max = min(p_max, p_prev + ramp_up)  \n   - For newly started units: min = p_min, max = min(p_max, start_ramp)  \n4. While total min output > load:  \n   - Sort free-on units by descending (cost at min output)/min_output  \n   - Decommit the highest-cost unit that won't reduce total max output below load  \n   - Update total min/max  \n5. While total max output < load:  \n   - Sort free-off units by ascending (startup + cost at min output)/min_output  \n   - Commit the cheapest unit  \n   - Update total min/max  \n6. Dispatch load to committed units:  \n   - Initialize at effective min outputs  \n   - Use lambda iteration to set outputs, clamping to limits:  \n     a. Solve marginal cost (lambda) via binary search  \n     b. Calculate outputs as (lambda - b_i)/(2c_i) clamped to [min_i, max_i]  \n     c. Iterate until generation matches load within tolerance  \n7. Return commitment states and power outputs.  \n\n",
          "code": "import numpy as np\n\ndef dynamic_commitment_with_dispatch(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units)\n    p = np.zeros(n_units)\n    \n    # Extract parameters into arrays\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    ramp_up = [unit['p_up_i'] for unit in units_info]\n    ramp_down = [unit['p_down_i'] for unit in units_info]\n    start_ramp = [unit['p_start_i'] for unit in units_info]\n    shut_ramp = [unit['p_shut_i'] for unit in units_info]\n    min_up = [unit['t_on_min_i'] for unit in units_info]\n    min_down = [unit['t_off_min_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    t_state = [unit['t_i_0'] for unit in units_info]\n    startup_cost = [unit['s_i'] for unit in units_info]\n    \n    # Classify units\n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:  # Online previously\n            if t_state[i] < min_up[i] or p_prev[i] > shut_ramp[i]:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Offline previously\n            if -t_state[i] < min_down[i]:  # t_state negative when offline\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed = set(must_on) | set(free_on)\n    decommitted = set(must_off) | set(free_off)\n    \n    # Calculate effective power limits\n    eff_min = np.zeros(n_units)\n    eff_max = np.zeros(n_units)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1 and i in committed:\n            eff_min[i] = max(p_min[i], p_prev[i] - ramp_down[i])\n            eff_max[i] = min(p_max[i], p_prev[i] + ramp_up[i])\n        elif i in committed:  # Newly started\n            eff_min[i] = p_min[i]\n            eff_max[i] = min(p_max[i], start_ramp[i])\n        else:\n            eff_min[i] = 0\n            eff_max[i] = 0\n    \n    # Adjust commitment\n    total_min = sum(eff_min[i] for i in committed)\n    total_max = sum(eff_max[i] for i in committed)\n    \n    # Case 1: Over-commitment (total min output > load)\n    if total_min > current_load:\n        # Sort free-on units by descending cost per MW at min output\n        free_on.sort(key=lambda i: (a[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i], \n                      reverse=True)\n        remove_list = []\n        for i in free_on:\n            if i in committed and not (i in must_on):\n                new_total_max = total_max - eff_max[i]\n                if new_total_max >= current_load:\n                    remove_list.append(i)\n                    total_min -= eff_min[i]\n                    total_max = new_total_max\n                    if total_min <= current_load:\n                        break\n        \n        for i in remove_list:\n            committed.remove(i)\n            eff_min[i] = eff_max[i] = 0\n            free_on.remove(i)\n            decommitted.add(i)\n    \n    # Case 2: Under-commitment (total max output < load)\n    if total_max < current_load:\n        # Sort free-off units by ascending average cost per MW (including startup)\n        free_off.sort(key=lambda i: (startup_cost[i] + a[i] + b[i]*p_min[i] + c[i]*p_min[i]**2) / p_min[i])\n        add_list = []\n        for i in free_off:\n            unit_min = p_min[i]\n            unit_max = min(p_max[i], start_ramp[i])\n            new_total_min = total_min + unit_min\n            new_total_max = total_max + unit_max\n            \n            add_list.append(i)\n            committed.add(i)\n            eff_min[i] = unit_min\n            eff_max[i] = unit_max\n            total_min = new_total_min\n            total_max = new_total_max\n            if total_max >= current_load:\n                break\n        \n        for i in add_list:\n            free_off.remove(i)\n            decommitted.discard(i)\n    \n    # Economic dispatch using lambda iteration\n    comm_list = list(committed)\n    n_comm = len(comm_list)\n    p_dispatch = [eff_min[i] for i in range(n_units)]\n    \n    if n_comm > 0:\n        # Set bounds for lambda (marginal cost)\n        low = min(b[i] + 2*c[i]*eff_min[i] for i in comm_list)\n        high = max(b[i] + 2*c[i]*eff_max[i] for i in comm_list)\n        \n        tol = 0.001  # 0.001 MW tolerance\n        max_iter = 1000\n        for _ in range(max_iter):\n            lam = (low + high) / 2\n            total_gen = 0\n            for i in comm_list:\n                if c[i] > 0:\n                    p_temp = (lam - b[i]) / (2 * c[i])\n                else:  # Linear cost function\n                    p_temp = eff_max[i] if lam > b[i] else eff_min[i]\n                \n                p_temp = max(eff_min[i], min(p_temp, eff_max[i]))\n                total_gen += p_temp\n                p_dispatch[i] = p_temp\n            \n            if abs(total_gen - current_load) < tol:\n                break\n            elif total_gen < current_load:\n                low = lam\n            else:\n                high = lam\n    else:  # No units committed\n        total_gen = 0\n    \n    # Set outputs\n    for i in range(n_units):\n        u[i] = 1 if i in committed else 0\n        p[i] = p_dispatch[i] if i in committed else 0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001297944,
          "gap_price_rate": 0.0360463471,
          "fitness": 0.0180880708
     },
     {
          "name": "hybrid_commitment_heuristic",
          "algorithm": "1. Classify units into must-on (prev on & not satisfied min up-time/shutdown capacity), must-off (prev off & not satisfied min down-time), free-on (prev on & free to turn off), free-off (prev off & free to turn on).\n2. Initially commit must-on and free-on units. Calculate effective min/max power for committed units considering ramp constraints. For units turning on, apply startup ramp limits.\n3. If total min output exceeds load, turn off free-on units (prioritized by highest min output) until feasible, ensuring shutdown constraints are met.\n4. If total max output is below load, turn on free-off units (prioritized by cost-effectiveness: (startup_cost + min_output_cost)/min_output) until sufficient capacity is available.\n5. Set outputs of committed units to their effective minimums. Distribute remaining load deficit by increasing outputs of units with lowest marginal cost, respecting ramp limits.\n6. For units turning on, re-adjust outputs to satisfy startup ramp constraints if needed.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef hybrid_commitment_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0']:  # Previously on\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:  # Previously off\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initially commit must_on and free_on units\n    committed = set(must_on + free_on)\n    for i in committed:\n        u[i] = 1\n    \n    # Calculate effective min/max for each committed unit\n    p_min_eff = np.zeros(n_units)\n    p_max_eff = np.zeros(n_units)\n    for i in range(n_units):\n        if i in must_on or i in free_on:\n            p_min_eff[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n            p_max_eff[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n        else:\n            p_min_eff[i] = 0\n            p_max_eff[i] = 0\n    \n    # Calculate total min and max output\n    total_min = sum(p_min_eff[i] for i in committed)\n    total_max = sum(p_max_eff[i] for i in committed)\n    \n    # Step 3: Turn off free_on units if overcommitted\n    free_on.sort(key=lambda i: p_min_eff[i], reverse=True)\n    to_remove = []\n    for i in free_on:\n        if i not in committed or total_min <= current_load:\n            break\n        # Ensure shutdown constraints\n        if units_info[i]['p_i_0'] <= min(units_info[i]['p_down_i'], units_info[i]['p_shut_i']):\n            committed.remove(i)\n            u[i] = 0\n            total_min -= p_min_eff[i]\n            total_max -= p_max_eff[i]\n            to_remove.append(i)\n    free_on = [i for i in free_on if i not in to_remove]\n    \n    # Step 4: Turn on free_off units if undercommitted\n    free_off.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                                units_info[i]['c_i']*units_info[i]['p_min_i']**2) / max(1e-5, units_info[i]['p_min_i']))\n    for i in free_off:\n        if total_max >= current_load:\n            break\n        # Startup constraints\n        candidate_min = units_info[i]['p_min_i']\n        candidate_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'], units_info[i]['p_up_i'])\n        committed.add(i)\n        u[i] = 1\n        p_min_eff[i] = candidate_min\n        p_max_eff[i] = candidate_max\n        total_min += candidate_min\n        total_max += candidate_max\n    \n    # Set outputs to effective minimums\n    for i in committed:\n        p[i] = p_min_eff[i]\n    \n    # Calculate remaining deficit\n    deficit = current_load - total_min\n    if deficit < 0:  # Overcommitment\n        deficit = 0\n    \n    # Create active list for units that can increase output\n    active = [i for i in committed if p[i] < p_max_eff[i]]\n    while deficit > 1e-5 and active:\n        # Find unit with lowest marginal cost\n        i_min = min(active, key=lambda i: 2*units_info[i]['c_i']*p[i] + units_info[i]['b_i'])\n        # Increase output\n        delta = min(deficit, p_max_eff[i_min] - p[i_min])\n        p[i_min] += delta\n        deficit -= delta\n        # Remove from active if no more headroom\n        if p[i_min] >= p_max_eff[i_min] - 1e-5:\n            active.remove(i_min)\n    \n    # Apply startup ramp constraints for newly started units\n    for i in [i for i in free_off if i in committed]:\n        if p[i] > units_info[i]['p_start_i']:\n            p[i] = min(p[i], units_info[i]['p_start_i'])\n    \n    # Ensure must-on units remain within ramp constraints\n    for i in must_on:\n        if u[i]:\n            p[i] = max(p_min_eff[i], min(p_max_eff[i], p[i]))\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0392093598,
          "fitness": 0.0196695191
     },
     {
          "name": "dynamic_rolling_commitment_refined",
          "algorithm": null,
          "code": "import numpy as np\n\ndef dynamic_rolling_commitment_refined(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    schedules = np.zeros((2, n_units))\n    must_on, must_off, free_on, free_off = [], [], [], []\n    committed_indices = set()\n\n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        t_on_min = unit['t_on_min_i']\n        p_shut = unit['p_shut_i']\n        t_off_min = unit['t_off_min_i']\n        \n        if u_i0 == 1:\n            if (t_i0 < t_on_min) or (p_i0 > p_shut):\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -t_i0 < t_off_min:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initial commitment\n    committed_indices = set(must_on) | set(free_on)\n    \n    # Check capacity and adjust commitment\n    base_min, base_max = 0.0, 0.0\n    for i in committed_indices:\n        unit = units_info[i]\n        p_min = unit['p_min_i']\n        p_max = unit['p_max_i']\n        p_down = unit['p_down_i']\n        p_up = unit['p_up_i']\n        p_prev = unit['p_i_0']\n        \n        eff_min = max(p_min, p_prev - p_down)\n        eff_max = min(p_max, p_prev + p_up)\n        base_min += eff_min\n        base_max += eff_max\n    \n    total_max = base_max\n    # Turn on free-off units if needed\n    if total_max < current_load:\n        free_off_sorted = sorted(free_off, key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                           units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                           units_info[i]['c_i']*(units_info[i]['p_min_i']**2)) / max(units_info[i]['p_min_i'], 1e-6))\n        to_add = []\n        for i in free_off_sorted:\n            if total_max >= current_load:\n                break\n            unit = units_info[i]\n            p_start = unit['p_start_i']\n            p_up_i = unit['p_up_i']\n            p_min_i = unit['p_min_i']\n            p_max_i = unit['p_max_i']\n            eff_max_i = min(p_max_i, p_start, p_up_i)\n            to_add.append(i)\n            committed_indices.add(i)\n            base_min += p_min_i\n            total_max += eff_max_i\n    \n    total_min = base_min\n    # Turn off free-on units if needed\n    if total_min > current_load:\n        free_on_set = set(free_on) & committed_indices\n        free_on_list = list(free_on_set)\n        free_on_list.sort(key=lambda i: (units_info[i]['a_i'] + units_info[i]['b_i']*units_info[i]['p_min_i'] + \n                         units_info[i]['c_i']*(units_info[i]['p_min_i']**2)), reverse=True)\n        to_remove = []\n        for i in free_on_list:\n            unit = units_info[i]\n            p_prev = unit['p_i_0']\n            p_min_i = unit['p_min_i']\n            p_down_i = unit['p_down_i']\n            p_up_i = unit['p_up_i']\n            p_max_i = unit['p_max_i']\n            eff_min_i = max(p_min_i, p_prev - p_down_i)\n            eff_max_i = min(p_max_i, p_prev + p_up_i)\n            new_min = total_min - eff_min_i\n            new_max = total_max - eff_max_i\n            if new_min <= current_load and new_max >= current_load:\n                to_remove.append(i)\n                committed_indices.remove(i)\n                total_min = new_min\n                total_max = new_max\n                if total_min <= current_load:\n                    break\n    \n    # Compute effective bounds for dispatch\n    eff_min, eff_max, cost_params = [], [], []\n    for i in committed_indices:\n        unit = units_info[i]\n        u_i0 = unit['u_i_0']\n        p_prev = unit['p_i_0']\n        p_min_i = unit['p_min_i']\n        p_max_i = unit['p_max_i']\n        p_down_i = unit['p_down_i']\n        p_up_i = unit['p_up_i']\n        p_start_i = unit['p_start_i']\n        \n        if u_i0 == 1:\n            e_min = max(p_min_i, p_prev - p_down_i)\n            e_max = min(p_max_i, p_prev + p_up_i)\n        else:\n            e_min = p_min_i\n            e_max = min(p_max_i, p_start_i, p_up_i)\n        \n        eff_min.append(e_min)\n        eff_max.append(e_max)\n        cost_params.append((unit['a_i'], unit['b_i'], unit['c_i']))\n    \n    # Perform economic dispatch\n    if committed_indices:\n        total_min_sum = sum(eff_min)\n        if total_min_sum > current_load:\n            p_out = {i: v for i, v in zip(committed_indices, eff_min)}\n        else:\n            low_bound = min(b + 2*c*e_min for (_,b,c), e_min in zip(cost_params, eff_min))\n            high_bound = max(b + 2*c*e_max for (_,b,c), e_max in zip(cost_params, eff_max))\n            \n            p_out = {}\n            for _ in range(100):\n                lambda_mid = (low_bound + high_bound) / 2\n                total_p = 0\n                p_vals = []\n                for (a,b,c), e_min, e_max in zip(cost_params, eff_min, eff_max):\n                    if c == 0:\n                        p_val = e_max if lambda_mid > b else e_min\n                    else:\n                        p_val = (lambda_mid - b) / (2 * c)\n                        p_val = max(e_min, min(e_max, p_val))\n                    p_vals.append(p_val)\n                    total_p += p_val\n                \n                if abs(total_p - current_load) < 1e-3:\n                    p_out = {i: p for i, p in zip(committed_indices, p_vals)}\n                    break\n                elif total_p < current_load:\n                    low_bound = lambda_mid\n                else:\n                    high_bound = lambda_mid\n            else:\n                p_out = {i: p for i, p in zip(committed_indices, p_vals)}\n    else:\n        p_out = {}\n    \n    # Build output\n    for i in range(n_units):\n        if i in committed_indices:\n            schedules[0, i] = 1\n            schedules[1, i] = p_out[i]\n        else:\n            schedules[0, i] = 0\n            schedules[1, i] = 0\n    \n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0001297978,
          "gap_price_rate": 0.0400293233,
          "fitness": 0.0200795605
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Classify units into must-on (must stay online), must-off (must stay offline), free-on (can be turned off), and free-off (can be turned on) based on current state and constraints.\n2. Start with must-on and free-on units committed. Compute total minimum and maximum capacity considering ramp limits.\n3. If total max < load, commit free-off units in ascending order of (startup_cost/min_output + marginal cost at min_output) until capacity meets/exceeds load.\n4. If total min > load, turn off free-on units (not must-on) in descending order of minimum output (when removing maintains capacity constraints) until min capacity \u2264 load.\n5. Dispatch load: \n   - If load \u2264 total min: set all units to min output\n   - If load \u2265 total max: set all units to max output\n   - Otherwise: initialize at min outputs, distribute remaining load using priority order by increasing marginal cost.\n6. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    current_load = load[0]  # Extract current load from input\n    n_units = len(units_info)\n    \n    # Precompute effective min/max and classify units\n    categories = []  # 'must_on', 'free_on', 'must_off', 'free_off'\n    effective_min = np.zeros(n_units)\n    effective_max = np.zeros(n_units)\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Was online\n            # Compute effective limits\n            effective_min[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            effective_max[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n            \n            # Check constraints for must-on\n            if (t_i0 > 0 and t_i0 < unit['t_on_min_i']) or p_i0 > unit['p_shut_i']:\n                categories.append('must_on')\n            else:\n                categories.append('free_on')\n        else:  # Was offline\n            effective_min[i] = unit['p_min_i']\n            effective_max[i] = min(unit['p_max_i'], unit['p_start_i'])\n            \n            # Check constraints for must-off\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                categories.append('must_off')\n            else:\n                categories.append('free_off')\n    \n    # Build category lists\n    must_on_indices = [i for i, cat in enumerate(categories) if cat == 'must_on']\n    free_on_indices = [i for i, cat in enumerate(categories) if cat == 'free_on']\n    must_off_indices = [i for i, cat in enumerate(categories) if cat == 'must_off']\n    free_off_indices = [i for i, cat in enumerate(categories) if cat == 'free_off']\n    \n    # Initialize commitment\n    committed = set(must_on_indices + free_on_indices)\n    total_min = sum(effective_min[i] for i in committed)\n    total_max = sum(effective_max[i] for i in committed)\n    \n    # Step 3: Add free-off units if capacity insufficient\n    if total_max < current_load:\n        free_off_metrics = []\n        for i in free_off_indices:\n            metric = (units_info[i]['s_i'] / units_info[i]['p_min_i']) + \\\n                     (units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * units_info[i]['p_min_i'])\n            free_off_metrics.append((metric, i))\n        \n        free_off_metrics.sort(key=lambda x: x[0])\n        \n        for metric, i in free_off_metrics:\n            if total_max >= current_load:\n                break\n            committed.add(i)\n            total_min += effective_min[i]\n            total_max += effective_max[i]\n    \n    # Step 4: Remove free-on units if over-committed\n    if total_min > current_load:\n        removable = [i for i in free_on_indices if i in committed]\n        removal_priority = [(effective_min[i], i) for i in removable]\n        removal_priority.sort(key=lambda x: x[0], reverse=True)\n        \n        for _, i in removal_priority:\n            new_total_min = total_min - effective_min[i]\n            new_total_max = total_max - effective_max[i]\n            # Check if removal maintains feasibility\n            if new_total_min <= current_load <= new_total_max:\n                committed.discard(i)\n                total_min = new_total_min\n                total_max = new_total_max\n            if total_min <= current_load:\n                break\n    \n    # Step 5: Dispatch load\n    u_out = [1 if i in committed else 0 for i in range(n_units)]\n    p_out = [0.0] * n_units\n    \n    if current_load <= total_min:\n        for i in committed:\n            p_out[i] = effective_min[i]\n    elif current_load >= total_max:\n        for i in committed:\n            p_out[i] = effective_max[i]\n    else:\n        # Initialize to minimum output\n        for i in committed:\n            p_out[i] = effective_min[i]\n        \n        remaining = current_load - total_min\n        active_units = list(committed)\n        \n        while remaining > 0 and active_units:\n            min_mc = float('inf')\n            candidate = None\n            \n            # Find unit with lowest marginal cost\n            for i in active_units:\n                marginal_cost = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * p_out[i]\n                if marginal_cost < min_mc:\n                    min_mc = marginal_cost\n                    candidate = i\n            \n            if candidate is None:\n                break\n            \n            # Calculate possible increase\n            headroom = effective_max[candidate] - p_out[candidate]\n            if headroom <= 0:\n                active_units.remove(candidate)\n                continue\n            \n            increment = min(remaining, headroom)\n            p_out[candidate] += increment\n            remaining -= increment\n            \n            if p_out[candidate] >= effective_max[candidate]:\n                active_units.remove(candidate)\n    \n    # Build output array\n    schedules = np.array([u_out, p_out])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0410556755,
          "fitness": 0.0205636838
     },
     {
          "name": "refined_commitment_lambda_heuristic",
          "algorithm": "1. Classify units into must-on (must remain on due to min up-time or shutdown constraints), must-off (must remain off due to min down-time), free-on (online units that can be turned off), and free-off (offline units that can be turned on).  \n2. Initially commit must-on and free-on units. Compute effective min and max outputs for these units based on ramp limits and previous states.  \n3. If total effective min exceeds current load, decommit free-on units in descending order of their min output, provided the remaining capacity can still meet the load.  \n4. If total effective max is below current load, commit free-off units in ascending order of average cost per MW at min output until capacity meets or exceeds load.  \n5. For dispatch:  \n   - If total min > load (over-committed), set all committed units to min output.  \n   - If total max < load (under-committed), set all committed units to max output.  \n   - Else, use lambda iteration for economic dispatch to meet load exactly within effective bounds, minimizing variable costs.  \n6. Return commitment states and power outputs for all units.  \n\n",
          "code": "import numpy as np  \n\ndef refined_commitment_lambda_heuristic(units_info, load):  \n    n = len(units_info)  \n    current_load = load[0]  \n    must_on, must_off, free_on, free_off = [], [], [], []  \n    eff_min = np.zeros(n)  \n    eff_max = np.zeros(n)  \n      \n    # Classify units  \n    for i, unit in enumerate(units_info):  \n        u0, t0, p0 = unit['u_i_0'], unit['t_i_0'], unit['p_i_0']  \n        if u0 == 1:  \n            if t0 < unit['t_on_min_i'] or p0 > unit['p_shut_i']:  \n                must_on.append(i)  \n            else:  \n                free_on.append(i)  \n        else:  \n            if -t0 < unit['t_off_min_i']:  \n                must_off.append(i)  \n            else:  \n                free_off.append(i)  \n                  \n    # Initial commitment  \n    committed = must_on + free_on  \n      \n    # Compute effective min/max for committed units (continuous online)  \n    for i in committed:  \n        unit = units_info[i]  \n        eff_min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])  \n        eff_max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])  \n        eff_min[i], eff_max[i] = eff_min_i, eff_max_i  \n          \n    total_min = np.sum(eff_min)  \n    total_max = np.sum(eff_max)  \n      \n    # Over-commitment adjustment  \n    free_on_committed = [i for i in committed if i in free_on]  \n    free_on_committed.sort(key=lambda i: eff_min[i], reverse=True)  \n    i = 0  \n    while i < len(free_on_committed) and total_min > current_load:  \n        candidate = free_on_committed[i]  \n        if total_max - eff_max[candidate] >= current_load:  \n            committed.remove(candidate)  \n            total_min -= eff_min[candidate]  \n            total_max -= eff_max[candidate]  \n            eff_min[candidate] = eff_max[candidate] = 0  \n        i += 1  \n      \n    # Under-commitment adjustment  \n    if total_max < current_load:  \n        def avg_cost(i):  \n            unit = units_info[i]  \n            cost = unit['s_i'] + unit['b_i'] * unit['p_min_i'] + unit['c_i'] * (unit['p_min_i'] ** 2)  \n            return cost / unit['p_min_i'] if unit['p_min_i'] > 0 else float('inf')  \n          \n        free_off.sort(key=avg_cost)  \n        for candidate in free_off:  \n            if total_max >= current_load:  \n                break  \n            unit = units_info[candidate]  \n            min_candidate = unit['p_min_i']  \n            max_candidate = min(unit['p_max_i'], unit['p_start_i'])  \n            committed.append(candidate)  \n            eff_min[candidate], eff_max[candidate] = min_candidate, max_candidate  \n            total_min += min_candidate  \n            total_max += max_candidate  \n      \n    # Dispatch  \n    u_vals = np.zeros(n)  \n    p_vals = np.zeros(n)  \n    for i in committed:  \n        u_vals[i] = 1  \n      \n    if total_min > current_load:  \n        p_vals = eff_min.copy()  \n    elif total_max < current_load:  \n        p_vals = eff_max.copy()  \n    else:  \n        # Lambda iteration  \n        low_lam, high_lam = float('inf'), float('-inf')  \n        for i in committed:  \n            unit = units_info[i]  \n            if unit['c_i'] == 0:  \n                mc_min = mc_max = unit['b_i']  \n            else:  \n                mc_min = unit['b_i'] + 2 * unit['c_i'] * eff_min[i]  \n                mc_max = unit['b_i'] + 2 * unit['c_i'] * eff_max[i]  \n            low_lam = min(low_lam, mc_min)  \n            high_lam = max(high_lam, mc_max)  \n          \n        tol = 1e-3  \n        n_iter = 0  \n        mid_lam = (low_lam + high_lam) / 2.0  \n        while high_lam - low_lam > tol and n_iter < 100:  \n            total_p = 0.0  \n            for i in committed:  \n                unit = units_info[i]  \n                if unit['c_i'] == 0:  \n                    p_val = eff_min[i] if mid_lam < unit['b_i'] else eff_max[i]  \n                else:  \n                    p_desired = (mid_lam - unit['b_i']) / (2 * unit['c_i'])  \n                    p_val = np.clip(p_desired, eff_min[i], eff_max[i])  \n                total_p += p_val  \n              \n            if total_p < current_load:  \n                low_lam = mid_lam  \n            else:  \n                high_lam = mid_lam  \n            mid_lam = (low_lam + high_lam) / 2.0  \n            n_iter += 1  \n          \n        for i in committed:  \n            unit = units_info[i]  \n            if unit['c_i'] == 0:  \n                p_val = eff_min[i] if mid_lam < unit['b_i'] else eff_max[i]  \n            else:  \n                p_desired = (mid_lam - unit['b_i']) / (2 * unit['c_i'])  \n                p_val = np.clip(p_desired, eff_min[i], eff_max[i])  \n            p_vals[i] = p_val  \n      \n    schedules = np.vstack((u_vals, p_vals))  \n    return schedules  ",
          "from": "mutation",
          "gap_power_rate": 9.35434e-05,
          "gap_price_rate": 0.042030065,
          "fitness": 0.0210618042
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Classify units into must-on (must remain online due to min up-time or shutdown constraints), must-off (must remain offline due to min down-time), free-on (online and can be turned off), and free-off (offline and can be turned on).\n2. Commit must-on and free-on units initially. Compute their power bounds considering ramp constraints: for units previously online, bounds depend on previous output and ramp limits; for newly started units, consider startup ramp limits.\n3. If total maximum output from committed units is below current load, commit additional free-off units sorted by the sum of startup cost and minimum production cost (S\u1d62 + a\u1d62 + b\u1d62\u00b7P\u2098\u1d62\u2099\u1d62 + c\u1d62\u00b7P\u2098\u1d62\u2099\u1d62\u00b2) until total maximum capacity meets or exceeds load.\n4. If total minimum output from committed units exceeds current load, attempt to decommit free-on units in descending order of minimum output, respecting shutdown ramp constraints (P\u1d62_\u2080 \u2264 P_shut\u1d62) and ensuring remaining units can meet load.\n5. Perform economic dispatch using lambda iteration to allocate load optimally among committed units:\n   - For each unit, calculate incremental cost (b\u1d62 + 2\u00b7c\u1d62\u00b7p\u1d62)\n   - Use binary search on lambda to equalize incremental costs while respecting power bounds\n   - Handle linear cost units (c\u1d62 = 0) by switching between min and max output\n6. Return commitment states (u\u1d62) and power outputs (p\u1d62) for all units.\n\n",
          "code": "import numpy as np\nimport sys\n\ndef enhanced_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Classify units\n    must_on, must_off, free_on, free_off = [], [], [], []\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']: \n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    # Initialize committed units and bounds\n    committed = must_on + free_on\n    bounds = []\n    for i in committed:\n        unit = units_info[i]\n        low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        bounds.append((low, high))\n    \n    total_min = sum(low for low, _ in bounds)\n    total_max = sum(high for _, high in bounds)\n    \n    # Add free-off units if insufficient capacity\n    if total_max < current_load:\n        cost_free_off = []\n        for i in free_off:\n            unit = units_info[i]\n            cost = (unit['s_i'] + unit['a_i'] + \n                    unit['b_i'] * unit['p_min_i'] + \n                    unit['c_i'] * unit['p_min_i']**2)\n            cost_free_off.append((cost, i))\n        \n        cost_free_off.sort(key=lambda x: x[0])\n        for _, i in cost_free_off:\n            unit = units_info[i]\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n            committed.append(i)\n            bounds.append((low, high))\n            total_min += low\n            total_max += high\n            if total_max >= current_load:\n                break\n    \n    # Remove unnecessary free-on units\n    free_on_in_commit = [i for i in free_on if i in committed]\n    if total_min > current_load and free_on_in_commit:\n        positions = {i: idx for idx, i in enumerate(committed)}\n        free_data = []\n        for i in free_on_in_commit:\n            pos = positions[i]\n            free_data.append((bounds[pos][0], bounds[pos][1], i, pos))\n        \n        free_data.sort(key=lambda x: x[0], reverse=True)\n        for _, _, i, pos in free_data:\n            if units_info[i]['p_i_0'] <= units_info[i]['p_down_i']:\n                new_min = total_min - bounds[pos][0]\n                new_max = total_max - bounds[pos][1]\n                if new_min <= current_load <= new_max:\n                    del committed[pos]\n                    del bounds[pos]\n                    total_min = new_min\n                    total_max = new_max\n                    if total_min <= current_load:\n                        break\n    \n    # Economic dispatch using lambda iteration\n    u_output = [0] * n_units\n    p_output = [0.0] * n_units\n    if committed:\n        low_lam, high_lam = float('inf'), -float('inf')\n        for idx, unit in enumerate(committed):\n            low_b, high_b = bounds[idx]\n            unit_info = units_info[unit]\n            inc_low = unit_info['b_i'] + 2 * unit_info['c_i'] * low_b\n            inc_high = unit_info['b_i'] + 2 * unit_info['c_i'] * high_b\n            low_lam = min(low_lam, inc_low)\n            high_lam = max(high_lam, inc_high)\n        \n        def calc_p_total(lam):\n            total_p = 0\n            p_vals = []\n            for idx, i in enumerate(committed):\n                unit = units_info[i]\n                low_b, high_b = bounds[idx]\n                if unit['c_i'] == 0:\n                    p_val = high_b if lam >= unit['b_i'] else low_b\n                else:\n                    p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(low_b, min(high_b, p_val))\n                p_vals.append(p_val)\n                total_p += p_val\n            return total_p, p_vals\n        \n        # Binary search for lambda\n        for _ in range(100):\n            lam = (low_lam + high_lam) / 2\n            total_p, p_vals = calc_p_total(lam)\n            if abs(total_p - current_load) < 1e-5:\n                break\n            if total_p < current_load:\n                low_lam = lam\n            else:\n                high_lam = lam\n        \n        for idx, i in enumerate(committed):\n            u_output[i] = 1\n            p_output[i] = p_vals[idx]\n    \n    return np.array([u_output, p_output])",
          "from": "mutation",
          "gap_power_rate": 7.16935e-05,
          "gap_price_rate": 0.0462636844,
          "fitness": 0.023167689
     },
     {
          "name": "rolling_commitment_heuristic",
          "algorithm": "1. Classify units into must-on (units that must remain on due to min up-time or shutdown constraints), must-off (units that must remain off due to min down-time), free-on (free units currently on that can be turned off), and free-off (free units currently off that can be turned on).\n2. Initialize commitment: commit must-on and free-on units, decommit must-off and free-off units.\n3. Compute effective min and max outputs considering ramp constraints for committed units.\n4. While total effective min > load and eligible free-on units exist, turn off the eligible unit with the largest effective min output (eligibility requires: previous output <= shutdown ramp and removing unit doesn't cause under-generation).\n5. While total effective max < load and free-off units exist, turn on the free-off unit with lowest startup plus min-output cost.\n6. Dispatch:\n   - If total max output < load: set committed units to max output.\n   - If total min output > load: set committed units to min output.\n   - Else: use lambda iteration for economic dispatch to meet load.\n7. Return commitment states and power outputs.\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_heuristic(units_info, load):\n    load_current = load[0]\n    n = len(units_info)\n    u_commit = [False] * n\n    p_min_eff = [0.0] * n\n    p_max_eff = [0.0] * n\n    \n    must_on = []\n    must_off = []\n    free_on = []\n    free_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                free_on.append(i)\n        else:\n            if unit['t_i_0'] > -unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                free_off.append(i)\n    \n    for i in must_on + free_on:\n        u_commit[i] = True\n        \n    for i in must_on + free_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            p_min_eff[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            p_max_eff[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            p_min_eff[i] = unit['p_min_i']\n            p_max_eff[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    total_min = sum(p_min_eff)\n    total_max = sum(p_max_eff)\n    \n    free_on_remaining = free_on[:]\n    while total_min > load_current and free_on_remaining:\n        candidates = []\n        for i in free_on_remaining:\n            unit = units_info[i]\n            if unit['p_i_0'] <= unit['p_shut_i'] and (total_max - p_max_eff[i]) >= load_current:\n                candidates.append(i)\n                \n        if not candidates:\n            break\n            \n        candidate_to_turn_off = max(candidates, key=lambda i: p_min_eff[i])\n        u_commit[candidate_to_turn_off] = False\n        total_min -= p_min_eff[candidate_to_turn_off]\n        total_max -= p_max_eff[candidate_to_turn_off]\n        p_min_eff[candidate_to_turn_off] = 0.0\n        p_max_eff[candidate_to_turn_off] = 0.0\n        free_on_remaining.remove(candidate_to_turn_off)\n    \n    free_off_remaining = free_off[:]\n    while total_max < load_current and free_off_remaining:\n        candidates = []\n        for i in free_off_remaining:\n            cost_i = (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                     units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n                     units_info[i]['c_i'] * units_info[i]['p_min_i'] ** 2)\n            candidates.append((i, cost_i))\n        \n        if not candidates:\n            break\n            \n        candidate_to_turn_on = min(candidates, key=lambda x: x[1])[0]\n        u_commit[candidate_to_turn_on] = True\n        unit = units_info[candidate_to_turn_on]\n        p_min_here = unit['p_min_i']\n        p_max_here = min(unit['p_max_i'], unit['p_start_i'])\n        p_min_eff[candidate_to_turn_on] = p_min_here\n        p_max_eff[candidate_to_turn_on] = p_max_here\n        total_min += p_min_here\n        total_max += p_max_here\n        free_off_remaining.remove(candidate_to_turn_on)\n    \n    committed_indices = [i for i in range(n) if u_commit[i]]\n    p_output = [0.0] * n\n    \n    if total_max < load_current:\n        for i in committed_indices:\n            p_output[i] = p_max_eff[i]\n    elif total_min > load_current:\n        for i in committed_indices:\n            p_output[i] = p_min_eff[i]\n    else:\n        if not committed_indices:\n            u_output = [0] * n\n            p_output = [0.0] * n\n            return np.array([u_output, p_output])\n            \n        low_lambda = float('inf')\n        high_lambda = -float('inf')\n        \n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                marginal_low = unit['b_i']\n                marginal_high = unit['b_i']\n            else:\n                marginal_low = unit['b_i'] + 2 * unit['c_i'] * p_min_eff[i]\n                marginal_high = unit['b_i'] + 2 * unit['c_i'] * p_max_eff[i]\n                \n            if marginal_low < low_lambda:\n                low_lambda = marginal_low\n            if marginal_high > high_lambda:\n                high_lambda = marginal_high\n        \n        tol = 0.01\n        max_iter = 100\n        lam = (low_lambda + high_lambda) / 2.0\n        \n        for _ in range(max_iter):\n            total_power = 0.0\n            for i in committed_indices:\n                unit = units_info[i]\n                if unit['c_i'] == 0:\n                    if lam < unit['b_i']:\n                        p_val = p_min_eff[i]\n                    else:\n                        p_val = p_max_eff[i]\n                else:\n                    p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                    p_val = max(p_min_eff[i], min(p_max_eff[i], p_val))\n                total_power += p_val\n                \n            if abs(total_power - load_current) < tol:\n                break\n                \n            if total_power < load_current:\n                low_lambda = lam\n            else:\n                high_lambda = lam\n                \n            lam = (low_lambda + high_lambda) / 2.0\n            \n            if high_lambda - low_lambda < tol:\n                break\n        \n        for i in committed_indices:\n            unit = units_info[i]\n            if unit['c_i'] == 0:\n                if lam < unit['b_i']:\n                    p_output[i] = p_min_eff[i]\n                else:\n                    p_output[i] = p_max_eff[i]\n            else:\n                p_val = (lam - unit['b_i']) / (2 * unit['c_i'])\n                p_output[i] = max(p_min_eff[i], min(p_max_eff[i], p_val))\n    \n    u_output = [1 if commit else 0 for commit in u_commit]\n    return np.array([u_output, p_output])",
          "from": "crossover",
          "gap_power_rate": 0.0003005703,
          "gap_price_rate": 0.0460903356,
          "fitness": 0.023195453
     }
]