{
     "name": "rolling_forecast_uc_refined1",
     "algorithm": "1. Identify must-run units (online previously with insufficient min uptime or previous output exceeding shutdown ramp limit) and must-off units (offline previously with insufficient min downtime)\n2. Set must-run units online, must-off units offline; retain previous states for flexible units\n3. Compute feasible output ranges for online units considering ramp constraints and startup limits\n4. Calculate total min/max output capacity of online units\n5. Adjust over-committed units: \n   - Sort non-must-run online units by operating cost at min output (descending)\n   - Turn off units if removal maintains min output \u2264 current load\n6. Adjust under-committed units: \n   - Sort candidate offline units by average cost at min output (including startup)\n   - Turn on units until max output covers current load, maintaining min output \u2264 current load\n7. Recompute feasible output ranges for all online units\n8. Dispatch economically:\n   - Set online units to min output\n   - Allocate residual load to units with smallest incremental cost\n9. Set offline units' output to zero\n\n",
     "code": "import numpy as np\n\ndef rolling_forecast_uc_refined1(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize variables\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Precompute min and max output for each unit based on type\n    min_output = [unit['p_min_i'] for unit in units_info]\n    max_output = [unit['p_max_i'] for unit in units_info]\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_run.append(i)\n        else:  # Previously offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Set commitment states\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Helper function to compute feasible output ranges\n    def get_feasible_range(i, online):\n        unit = units_info[i]\n        if online:\n            if unit['u_i_0'] == 1:  # Was previously online\n                lower_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                upper_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                return (lower_bound, upper_bound)\n            else:  # Newly started\n                upper_bound = min(unit['p_max_i'], unit['p_start_i'])\n                return (unit['p_min_i'], upper_bound)\n        return (0, 0)  # Offline unit\n    \n    # Helper function to calculate operating cost\n    def operating_cost(i, output):\n        unit = units_info[i]\n        return unit['a_i'] + unit['b_i']*output + unit['c_i']*output**2\n    \n    # Helper function to amortized startup cost at min output\n    def amortized_cost(i):\n        unit = units_info[i]\n        min_cost = operating_cost(i, min_output[i])\n        return (min_cost + unit['s_i']) / min_output[i] if min_output[i] > 0 else float('inf')\n    \n    # Helper function for incremental cost\n    def incremental_cost(i, output):\n        unit = units_info[i]\n        return unit['b_i'] + 2 * unit['c_i'] * output\n    \n    # Initialize lists for online units and their ranges\n    online_units = [i for i in range(n_units) if u[i] == 1]\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    # Steps 3 & 4: Compute initial feasible ranges and total capacity\n    for i in online_units:\n        low, high = get_feasible_range(i, True)\n        feasible_min[i] = low\n        feasible_max[i] = high\n    \n    total_min = sum(feasible_min[i] for i in online_units)\n    total_max = sum(feasible_max[i] for i in online_units)\n    \n    # Step 5: Adjust over-committed units\n    non_must_run_online = [i for i in online_units if i not in must_run]\n    non_must_run_online.sort(key=lambda i: operating_cost(i, min_output[i]), reverse=True)\n    \n    for i in non_must_run_online:\n        if total_min - min_output[i] <= current_load:\n            u[i] = 0  # Turn off unit\n            online_units.remove(i)\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n    \n    # Step 6: Adjust under-committed units\n    candidate_offline = [i for i in range(n_units) \n                         if u[i] == 0 and i not in must_off and min_output[i] > 0]\n    candidate_offline.sort(key=amortized_cost)\n    \n    for i in candidate_offline:\n        if total_max >= current_load:\n            break\n        new_min = total_min + min_output[i]\n        if new_min <= current_load:\n            u[i] = 1\n            online_units.append(i)\n            low, high = get_feasible_range(i, True)\n            feasible_min[i] = low\n            feasible_max[i] = high\n            total_min = new_min\n            total_max += min(high, max_output[i])  # Use startup ramp limit\n    \n    # Step 7: Recompute feasible ranges for all online units\n    for i in online_units:\n        low, high = get_feasible_range(i, True)\n        feasible_min[i] = low\n        feasible_max[i] = high\n    \n    # Step 8: Economic dispatch\n    p.fill(0)\n    for i in online_units:\n        p[i] = feasible_min[i]\n    \n    residual = current_load - sum(p)\n    online_idx = sorted(online_units, key=lambda i: incremental_cost(i, p[i]))\n    \n    for i in online_idx:\n        if residual <= 0:\n            break\n        available = feasible_max[i] - p[i]\n        alloc = min(available, residual)\n        p[i] += alloc\n        residual -= alloc\n    \n    # Step 9: Ensure offline units have zero output\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.vstack([u, p])",
     "from": "mutation",
     "gap_power_rate": 0.0061416892,
     "gap_price_rate": 0.0105126155,
     "fitness": 0.0083271523
}