{
     "name": "enhanced_rolling_commitment_v2",
     "algorithm": "1. Identify must-run units (prev. online violating min up-time or shutdown ramp) and must-off units (prev. offline violating min down-time)\n2. Initialize commitment: must-run online, must-off offline, retain others' states\n3. Compute feasible output ranges respecting ramp/startup constraints\n4. Over-commitment adjustment: Turn off expensive non-must-run units if removal maintains min \u2264 current load AND max \u2265 max(current, forecasted)\n5. Two-stage under-commitment: \n   a) For current load: Activate offline units sorted by cost/MW (startup included) until max \u2265 current load\n   b) For next period: Activate additional units (same order) until max \u2265 max(current, forecasted) AND min \u2264 current load\n6. Dispatch economically:\n   a) Set online units to min feasible output\n   b) Allocate residual load via incremental cost order\n7. Ensure offline units output 0\n\n",
     "code": "import numpy as np\nimport math\n\ndef enhanced_rolling_commitment_v2(units_info, load):\n    current_load, forecasted_load = load\n    num_units = len(units_info)\n    \n    # Initialize schedules array\n    schedules = np.zeros((2, num_units))\n    \n    # Extract current and forecasted loads\n    load_current = current_load\n    load_forecast = forecasted_load\n    max_target = max(load_current, load_forecast)\n    \n    # Step 1 & 2: Identify must-run/must-off and initialize states\n    must_run = [False] * num_units\n    must_off = [False] * num_units\n    u_current = [0] * num_units\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        \n        # Must-run conditions\n        if u_i0 == 1 and (t_i0 < t_on_min or p_i0 > p_shut):\n            must_run[i] = True\n            u_current[i] = 1\n        # Must-off conditions\n        elif u_i0 == 0 and abs(t_i0) < t_off_min:\n            must_off[i] = True\n            u_current[i] = 0\n        # Retain previous state for flexible units\n        else:\n            u_current[i] = u_i0\n\n    # Step 3: Compute feasible output ranges\n    def compute_feasible_ranges(u_arr):\n        p_min_feasible = [0] * num_units\n        p_max_feasible = [0] * num_units\n        for i, unit in enumerate(units_info):\n            if u_arr[i] == 0:\n                p_min_feasible[i] = 0\n                p_max_feasible[i] = 0\n            else:\n                u_i0 = unit['u_i_0']\n                p_i0 = unit['p_i_0']\n                p_min = unit['p_min_i']\n                p_max = unit['p_max_i']\n                p_up = unit['p_up_i']\n                p_down = unit['p_down_i']\n                p_start = unit['p_start_i']\n                \n                if u_i0 == 1:  # Was online\n                    p_min_feasible[i] = max(p_min, p_i0 - p_down)\n                    p_max_feasible[i] = min(p_max, p_i0 + p_up)\n                else:  # Just started\n                    p_min_feasible[i] = p_min\n                    p_max_feasible[i] = min(p_max, p_start)\n        return p_min_feasible, p_max_feasible\n\n    # Step 4: Over-commitment adjustment\n    p_min_curr, p_max_curr = compute_feasible_ranges(u_current)\n    total_min = sum(p_min_curr)\n    total_max = sum(p_max_curr)\n    \n    # Find non-must-run online units\n    online_non_must = []\n    for i in range(num_units):\n        if u_current[i] == 1 and not must_run[i]:\n            online_non_must.append(i)\n    \n    # Sort by cost/MW at minimum output (descending)\n    def cost_per_mw_at_min(i):\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        p_min = p_min_curr[i]\n        return (a + b * p_min + c * p_min**2) / p_min if p_min > 0 else math.inf\n        \n    online_non_must.sort(key=cost_per_mw_at_min, reverse=True)\n    \n    # Attempt to turn off expensive non-must-run units\n    for idx in online_non_must:\n        if u_current[idx] != 1:\n            continue\n            \n        test_u = u_current[:]\n        test_u[idx] = 0\n        test_p_min, test_p_max = compute_feasible_ranges(test_u)\n        new_total_min = sum(test_p_min)\n        new_total_max = sum(test_p_max)\n        \n        if (new_total_min <= load_current and \n            new_total_max >= max_target and\n            new_total_min <= new_total_max):\n            u_current[idx] = 0\n            total_min = new_total_min\n            total_max = new_total_max\n            p_min_curr, p_max_curr = test_p_min, test_p_max\n    \n    # Step 5: Under-commitment adjustment\n    offline_non_must = [i for i in range(num_units) \n                        if u_current[i] == 0 and not must_off[i]]\n    \n    # Compute cost/MW for offline units (startup included)\n    def cost_per_mw_with_startup(i):\n        unit = units_info[i]\n        a = unit['a_i']\n        b = unit['b_i']\n        c = unit['c_i']\n        s = unit['s_i']\n        p_min = unit['p_min_i']\n        return (s + a + b * p_min + c * p_min**2) / p_min\n    \n    offline_non_must.sort(key=cost_per_mw_with_startup)\n    \n    # Stage 5a: For current load\n    if total_max < load_current:\n        for idx in offline_non_must[:]:\n            unit = units_info[idx]\n            test_u = u_current[:]\n            test_u[idx] = 1\n            test_p_min, test_p_max = compute_feasible_ranges(test_u)\n            new_total_min = sum(test_p_min)\n            new_total_max = sum(test_p_max)\n            \n            # Only add if capacity improves\n            if new_total_max > total_max:\n                u_current[idx] = 1\n                p_min_curr, p_max_curr = test_p_min, test_p_max\n                total_min = new_total_min\n                total_max = new_total_max\n                offline_non_must.remove(idx)\n                \n            if total_max >= load_current:\n                break\n    \n    # Stage 5b: For next period forecast\n    if total_max < max_target:\n        for idx in offline_non_must[:]:\n            unit = units_info[idx]\n            test_u = u_current[:]\n            test_u[idx] = 1\n            test_p_min, test_p_max = compute_feasible_ranges(test_u)\n            new_total_min = sum(test_p_min)\n            new_total_max = sum(test_p_max)\n            \n            # Only add if capacity improves AND maintains min constraint\n            if (new_total_max > total_max and \n                new_total_min <= load_current and\n                new_total_max >= max_target):\n                u_current[idx] = 1\n                p_min_curr, p_max_curr = test_p_min, test_p_max\n                offline_non_must.remove(idx)\n                total_min = new_total_min\n                total_max = new_total_max\n            \n            if total_max >= max_target:\n                break\n    \n    # Final compute of feasible ranges\n    p_min_curr, p_max_curr = compute_feasible_ranges(u_current)\n    total_min = sum(p_min_curr)\n    \n    # Step 6: Economic Dispatch\n    p_outputs = [0] * num_units\n    residual = load_current - total_min\n    \n    # Initialize outputs to min feasible\n    for i in range(num_units):\n        if u_current[i] == 1:\n            p_outputs[i] = p_min_curr[i]\n    \n    # Function to get incremental cost\n    def incremental_cost(i, p):\n        unit = units_info[i]\n        b = unit['b_i']\n        c = unit['c_i']\n        return b + 2 * c * p\n    \n    # Allocate residual if available\n    if residual > 0:\n        # Find online units that can increase output\n        candidates = []\n        for i in range(num_units):\n            if u_current[i] == 1:\n                headroom = p_max_curr[i] - p_outputs[i]\n                if headroom > 0:\n                    inc_cost = incremental_cost(i, p_outputs[i])\n                    candidates.append((i, inc_cost, headroom))\n        \n        # Sort by incremental cost\n        candidates.sort(key=lambda x: x[1])\n        \n        # Distribute residual\n        for i, (idx, inc_cost, headroom) in enumerate(candidates):\n            alloc = min(residual, headroom)\n            p_outputs[idx] += alloc\n            residual -= alloc\n            if residual <= 0:\n                break\n    \n    # Step 7: Set outputs\n    schedules[0] = np.array(u_current)\n    schedules[1] = np.array(p_outputs)\n    \n    return schedules",
     "from": "mutation",
     "gap_power_rate": 0.0015029653,
     "gap_price_rate": 0.0093687509,
     "fitness": 0.0054358581
}