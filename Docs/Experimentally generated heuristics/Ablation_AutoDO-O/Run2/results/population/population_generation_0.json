[
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n  2. Initialize commitment states for must-run (on), must-off (off), and flexible (maintain current state)\n  3. Adjust commitment for flexible units if needed: turn on additional units by full-load average cost if undercommitted, turn off flexible units by average cost if overcommitted\n  4. Perform constrained economic dispatch using incremental cost sorting to allocate load within ramp and output limits\n  5. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    min_up = [u['t_on_min_i'] for u in units_info]\n    min_down = [u['t_off_min_i'] for u in units_info]\n    startup_cost = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    \n    # Initialize arrays\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    # Classify units\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if abs(t_prev[i]) < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    for i in range(n_units):\n        if must_run[i]:\n            u_current[i] = 1\n        elif must_off[i]:\n            u_current[i] = 0\n        else:\n            u_current[i] = u_prev[i]\n    \n    # Calculate available capacity for committed units\n    min_outputs = [0] * n_units\n    max_outputs = [0] * n_units\n    for i in range(n_units):\n        if u_current[i] == 1:\n            if u_prev[i] == 1:\n                min_outputs[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_outputs[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_outputs[i] = p_min[i]\n                max_outputs[i] = min(p_max[i], p_start[i])\n        else:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    total_min = sum(min_outputs)\n    total_max = sum(max_outputs)\n    \n    # Adjust commitment if needed\n    committed_indices = [i for i in range(n_units) if u_current[i] == 1]\n    flexible_off = [i for i in range(n_units) if not must_run[i] and not must_off[i] and u_current[i] == 0]\n    flexible_on = [i for i in range(n_units) if not must_run[i] and u_current[i] == 1]\n    \n    # Under-commitment case\n    if total_max < current_load:\n        # Sort by full-load average cost including startup\n        costs = []\n        for i in flexible_off:\n            avg_cost = (a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2) + startup_cost[i]) / p_max[i]\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1])\n        \n        for i, _ in costs:\n            if total_max >= current_load:\n                break\n            u_current[i] = 1\n            min_outputs[i] = p_min[i]\n            max_outputs[i] = min(p_max[i], p_start[i])\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            flexible_on.append(i)\n    \n    # Over-commitment case\n    if total_min > current_load:\n        # Sort by average cost at min output\n        costs = []\n        for i in flexible_on:\n            cost_val = a[i] + b[i]*min_outputs[i] + c[i]*(min_outputs[i]**2)\n            avg_cost = cost_val / min_outputs[i] if min_outputs[i] > 0 else float('inf')\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in costs:\n            if total_min <= current_load:\n                break\n            u_current[i] = 0\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    # Economic dispatch\n    committed_idx = [i for i in range(n_units) if u_current[i] == 1]\n    # Set initial output to min\n    for i in committed_idx:\n        p_current[i] = min_outputs[i]\n    \n    remaining_load = current_load - sum(min_outputs)\n    # Calculate incremental costs\n    inc_costs = []\n    for i in committed_idx:\n        inc_cost = b[i] + 2*c[i]*min_outputs[i]\n        inc_costs.append((i, inc_cost))\n    inc_costs.sort(key=lambda x: x[1])\n    \n    # Distribute remaining load\n    for i, _ in inc_costs:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, max_outputs[i] - min_outputs[i])\n        p_current[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Format output\n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.0515,
          "fitness": 0.02584
     },
     {
          "name": "novel_heuristic_commitment",
          "algorithm": "This heuristic first identifies must-on and must-off units based on minimum up/down times and shutdown ramp constraints. Then, it sorts flexible units by average cost at minimum output (including startup cost if applicable) and commits flexible units until total maximum capacity meets the load. Finally, it performs economic dispatch using incremental cost sorting while respecting output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef novel_heuristic_commitment(units_info, load):\n    current_load = load[0]\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_on.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_on:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n        \n    total_min = sum(unit['p_min_i'] for unit in must_on)\n    total_max = sum(unit['p_max_i'] for unit in must_on)\n    \n    def cost_per_mw(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_per_mw)\n    \n    committed = must_on.copy()\n    for unit in flexible:\n        if total_max >= current_load:\n            break\n        unit['u_i'] = 1\n        committed.append(unit)\n        total_max += unit['p_max_i']\n    \n    ranges = []\n    for unit in committed:\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((low, high))\n    \n    total_low = sum(low for low, high in ranges)\n    total_high = sum(high for low, high in ranges)\n    \n    p_values = [low for low, high in ranges]\n    \n    if current_load > total_high:\n        p_values = [high for low, high in ranges]\n    elif current_load < total_low:\n        p_values = [low for low, high in ranges]\n    else:\n        current_total = total_low\n        inc_units = []\n        for i, unit in enumerate(committed):\n            inc_units.append({\n                'idx': i,\n                'p': p_values[i],\n                'low': ranges[i][0],\n                'high': ranges[i][1],\n                'b': unit['b_i'],\n                'c': unit['c_i']\n            })\n        \n        while current_total < current_load:\n            min_inc = float('inf')\n            best_idx = None\n            for u in inc_units:\n                if u['p'] < u['high']:\n                    inc_cost = u['b'] + 2 * u['c'] * u['p']\n                    if inc_cost < min_inc:\n                        min_inc = inc_cost\n                        best_idx = u['idx']\n            if best_idx is None:\n                break\n                \n            u = inc_units[best_idx]\n            max_add = min(u['high'] - u['p'], current_load - current_total)\n            u['p'] += max_add\n            current_total += max_add\n    \n        for u in inc_units:\n            p_values[u['idx']] = u['p']\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = p_values[i]\n    \n    for unit in must_off:\n        unit['p_i'] = 0\n    for unit in flexible:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.02545,
          "gap_price_rate": 0.02724,
          "fitness": 0.02635
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "This heuristic first identifies units that must remain on or off due to physical constraints like minimum up/down times and shutdown ramp limits. It then prioritizes flexible units based on cost-effectiveness, considering both current and forecasted loads. The algorithm ensures load allocation respects all operational constraints while minimizing total cost through a greedy commitment strategy and proportional load dispatch.\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_on = set()\n    must_off = set()\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.add(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.add(i)\n    \n    flexible = set(range(n_units)) - must_on - must_off\n    committed = set(must_on)\n    max_power = 0.0\n    min_power = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_power += max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_power += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_power += unit['p_min_i']\n            max_power += min(unit['p_start_i'], unit['p_max_i'])\n    \n    if max_power < current_load:\n        cost_list = []\n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']\n            cost_per_mw = cost / unit['p_max_i']\n            cost_list.append((cost_per_mw, i))\n        \n        cost_list.sort(key=lambda x: x[0])\n        for _, i in cost_list:\n            if max_power >= current_load:\n                break\n            unit = units_info[i]\n            committed.add(i)\n            if unit['u_i_0'] == 1:\n                max_power += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_power += min(unit['p_start_i'], unit['p_max_i'])\n    \n    schedules_u = [0] * n_units\n    schedules_p = [0] * n_units\n    min_outputs = []\n    max_outputs = []\n    committed_list = list(committed)\n    \n    for i in committed_list:\n        unit = units_info[i]\n        schedules_u[i] = 1\n        if unit['u_i_0'] == 1:\n            min_o = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_o = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_o = unit['p_min_i']\n            max_o = min(unit['p_start_i'], unit['p_max_i'])\n        min_outputs.append(min_o)\n        max_outputs.append(max_o)\n        schedules_p[i] = min_o\n    \n    total_min = sum(min_outputs)\n    remaining_load = current_load - total_min\n    \n    if remaining_load > 0:\n        total_room = sum(max_o - min_o for min_o, max_o in zip(min_outputs, max_outputs))\n        if total_room > 0:\n            for idx, i in enumerate(committed_list):\n                room = max_outputs[idx] - min_outputs[idx]\n                schedules_p[i] += remaining_load * (room / total_room)\n    \n    return np.array([schedules_u, schedules_p])",
          "from": null,
          "gap_power_rate": 0.0,
          "gap_price_rate": 0.06376,
          "fitness": 0.03188
     },
     {
          "name": "commit_units_rolling",
          "algorithm": "1. Identify must-run units based on minimum uptime/downtime and shutdown ramp constraints\n2. Initialize commitment states from previous period\n3. Adjust commitment using priority list based on incremental cost at minimum power\n4. Perform economic dispatch with ramp-constrained capacity limits\n5. Fine-tune commitment to minimize costs while meeting load\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Initialize output arrays\n    u_i = np.zeros(n_units)\n    p_i = np.zeros(n_units)\n    \n    # Step 1: Identify must-run units\n    must_on = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i, unit in enumerate(units):\n        # Must-on conditions\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n        # Must-off conditions\n        if unit['u_i_0'] == 0 and unit['t_i_0'] > -unit['t_off_min_i']:\n            must_off[i] = True\n    \n    # Step 2: Initialize commitment states\n    for i, unit in enumerate(units):\n        if must_on[i]:\n            u_i[i] = 1\n        elif must_off[i]:\n            u_i[i] = 0\n        else:\n            u_i[i] = unit['u_i_0']\n    \n    # Step 3: Priority-based commitment adjustment\n    # Calculate priority based on incremental cost at minimum power\n    priorities = []\n    for i, unit in enumerate(units):\n        if not must_on[i] and not must_off[i]:\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            priorities.append((i, inc_cost))\n    \n    # Sort by incremental cost (ascending)\n    priorities.sort(key=lambda x: x[1])\n    \n    # Adjust commitment until load can be met\n    total_max_capacity = 0\n    for i, unit in enumerate(units):\n        if u_i[i] == 1:\n            if unit['u_i_0'] == 1:\n                total_max_capacity += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                total_max_capacity += min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Commit additional units if needed\n    for idx, _ in priorities:\n        if total_max_capacity < current_load and u_i[idx] == 0:\n            u_i[idx] = 1\n            unit = units[idx]\n            total_max_capacity += min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Step 4: Economic dispatch with ramp constraints\n    committed_indices = [i for i in range(n_units) if u_i[i] == 1]\n    \n    # Calculate feasible generation ranges\n    min_gen = np.zeros(len(committed_indices))\n    max_gen = np.zeros(len(committed_indices))\n    cost_coeffs = []\n    \n    for j, i in enumerate(committed_indices):\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_gen[j] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_gen[j] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_gen[j] = unit['p_min_i']\n            max_gen[j] = min(unit['p_max_i'], unit['p_start_i'])\n        cost_coeffs.append((unit['a_i'], unit['b_i'], unit['c_i']))\n    \n    # Perform dispatch using quadratic programming approximation\n    total_min = sum(min_gen)\n    total_max = sum(max_gen)\n    \n    if total_min <= current_load <= total_max:\n        # Distribute load proportionally within constraints\n        remaining_load = current_load - total_min\n        capacities = max_gen - min_gen\n        total_capacity = sum(capacities)\n        \n        if total_capacity > 0:\n            allocations = min_gen + capacities * (remaining_load / total_capacity)\n        else:\n            allocations = min_gen\n    else:\n        # Handle infeasible cases\n        allocations = np.where(current_load < total_min, min_gen, max_gen)\n    \n    # Assign generation values\n    for j, i in enumerate(committed_indices):\n        p_i[i] = allocations[j]\n    \n    # Step 5: Cost optimization fine-tuning\n    # Calculate current total cost\n    current_cost = 0\n    for i, unit in enumerate(units):\n        if u_i[i] == 1:\n            current_cost += (unit['a_i'] + unit['b_i'] * p_i[i] + \n                           unit['c_i'] * p_i[i] ** 2)\n            if unit['u_i_0'] == 0:\n                current_cost += unit['s_i']\n    \n    # Try switching borderline units\n    for idx, _ in priorities:\n        if must_on[idx] or must_off[idx]:\n            continue\n            \n        test_u = u_i.copy()\n        test_p = p_i.copy()\n        test_u[idx] = 1 - test_u[idx]  # Flip commitment\n        \n        if test_u[idx] == 1:  # If switching on\n            test_p[idx] = min(units[idx]['p_max_i'], units[idx]['p_start_i'])\n        else:\n            test_p[idx] = 0\n            \n        # Check feasibility\n        test_load = sum(test_p)\n        if abs(test_load - current_load) < abs(sum(p_i) - current_load):\n            test_cost = 0\n            for i, unit in enumerate(units):\n                if test_u[i] == 1:\n                    test_cost += (unit['a_i'] + unit['b_i'] * test_p[i] + \n                               unit['c_i'] * test_p[i] ** 2)\n                    if unit['u_i_0'] == 0 and test_u[i] == 1:\n                        test_cost += unit['s_i']\n            \n            if test_cost < current_cost:\n                u_i, p_i = test_u, test_p\n                current_cost = test_cost\n    \n    return np.array([u_i, p_i])",
          "from": null,
          "gap_power_rate": 3e-05,
          "gap_price_rate": 0.06732,
          "fitness": 0.03367
     }
]