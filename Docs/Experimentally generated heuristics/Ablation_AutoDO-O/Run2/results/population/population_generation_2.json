[
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Identify must-run units: Units currently on violating min up-time or shutdown ramp limits.\n2. Identify must-off units: Units currently off violating min down-time.\n3. Commit must-run units (u_i=1) and set must-off units to off (u_i=0).\n4. Compute total min/max capacity from must-run units considering ramp constraints.\n5. Sort flexible units by average cost/MW at min output (including startup if offline).\n6. Commit cheapest flexible units until total feasible capacity covers max(current, forecasted load).\n7. Dispatch by:\n   - Setting committed units to feasible minimum considering ramp limits.\n   - Allocating remaining load by increasing output of units with lowest incremental cost at current output.\n8. Non-committed units remain off with p_i=0.\n9. Return commitment state and output allocation.\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    units = [dict(unit) for unit in units_info]  # Copy input\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Identify must-run and must-off units\n    must_run = [False] * len(units)\n    must_off = [False] * len(units)\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:  # Currently on\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:  # Currently off\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n        unit['u_i'] = 0  # Initialize commitment\n    \n    # Calculate total capacity for must-run units\n    total_min_must_run = 0.0\n    total_max_must_run = 0.0\n    for i, unit in enumerate(units):\n        if must_run[i]:\n            unit['u_i'] = 1  # Commit must-run\n            if unit['u_i_0'] == 1:  # Previously on\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Previously off\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_min_must_run += min_i\n            total_max_must_run += max_i\n    \n    # Candidate flexible units (avg cost at min output)\n    candidate_flex = []\n    for i, unit in enumerate(units):\n        if not must_run[i] and not must_off[i]:\n            p_min = unit['p_min_i']\n            # Startup cost if currently off\n            startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n            avg_cost = (startup_cost + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n            # Current period max output\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            candidate_flex.append((avg_cost, max_i, i))\n    \n    # Commit cheapest flex until capacity >= max(load, forecast)\n    candidate_flex.sort(key=lambda x: x[0])\n    total_capacity = total_max_must_run\n    for _, max_i, idx in candidate_flex:\n        if total_capacity >= max(current_load, forecast_load):\n            break\n        units[idx]['u_i'] = 1  # Commit unit\n        total_capacity += max_i\n    \n    # Initial dispatch: set to min feasible output\n    p = [0.0] * len(units)\n    for i, unit in enumerate(units):\n        if unit['u_i'] == 1:  # Committed\n            if unit['u_i_0'] == 1:  # Was on\n                p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:  # Was off\n                p[i] = unit['p_min_i']\n    \n    # Allocate remaining load incrementally\n    total_p = sum(p)\n    remaining = current_load - total_p\n    committed_indices = [i for i in range(len(units)) if units[i]['u_i'] == 1]\n    \n    while remaining > 1e-6 and committed_indices:\n        # Calculate headroom and incremental costs\n        inc_costs = []\n        headrooms = []\n        indices = []\n        \n        for i in committed_indices:\n            # Calculate current unit constraints\n            if units[i]['u_i_0'] == 1:  # Was on\n                max_i = min(units[i]['p_max_i'], units[i]['p_i_0'] + units[i]['p_up_i'])\n                min_i = max(units[i]['p_min_i'], units[i]['p_i_0'] - units[i]['p_down_i'])\n            else:  # Was off\n                max_i = min(units[i]['p_max_i'], units[i]['p_start_i'])\n                min_i = units[i]['p_min_i']\n            headroom = max(0.0, max_i - p[i])\n            # Skip units with no headroom\n            if headroom < 1e-6:\n                continue\n            inc_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n            inc_costs.append(inc_cost)\n            headrooms.append(headroom)\n            indices.append(i)\n        \n        if not indices:  # No headroom remaining\n            break\n        \n        # Find unit with smallest incremental cost\n        min_cost_idx = np.argmin(inc_costs)\n        i_min = indices[min_cost_idx]\n        \n        # Allocate maximum possible to this unit\n        allocate = min(remaining, headrooms[min_cost_idx])\n        p[i_min] += allocate\n        remaining -= allocate\n    \n    # Update outputs\n    for i in range(len(units)):\n        units[i]['p_i'] = p[i]\n    \n    # Prepare output array\n    u_arr = [int(unit['u_i']) for unit in units]\n    p_arr = [unit['p_i'] for unit in units]\n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.0018740438,
          "gap_price_rate": 0.0185386497,
          "fitness": 0.0102063467
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "novel_heuristic_rolling_commitment",
          "algorithm": "1. Identify must-run and must-off units using min up/down times and shutdown ramp constraints.\n2. Initialize commitment states: set must-run units on, must-off units off, others retain previous state.\n3. Adjust commitment for flexible units: prioritize turning off overcommitted units using shutdown constraints and high-cost units, then activate undercommitted units using startup constraints and low-cost units.\n4. Compute feasible generation ranges (lb, hb) considering ramp limits and startup/shutdown constraints.\n5. Dispatch load through incremental cost-based allocation, respecting generation ranges and ensuring total output matches demand when possible.\n6. Return commitment states and generation outputs.\n\n",
          "code": "import numpy as np\n\ndef novel_heuristic_rolling_commitment(units_info, load):\n    current_load = load[0]\n    n = len(units_info)\n    u = np.zeros(n)\n    lb = np.zeros(n)\n    hb = np.zeros(n)\n    \n    # Determine must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        # Must-run: online and not satisfied min-up time OR above shutdown limit\n        if u_i0 == 1 and ((t_i0 < min_up) or (p_i0 > p_shut)):\n            must_run.append(i)\n        # Must-off: offline and not satisfied min-down time\n        elif u_i0 == 0 and abs(t_i0) < min_down:\n            must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']  # Keep previous state\n            \n    # Compute initial lb/hb for committed units\n    for i in range(n):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:  # Was online\n                lb[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                hb[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:  # Starting up\n                lb[i] = units_info[i]['p_min_i']\n                hb[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n    \n    total_min = np.sum(lb)\n    total_max = np.sum(hb)\n    \n    # Find flexible units: Type A (online but not must-run) and Type B (offline but not must-off)\n    typeA = []\n    typeB = []\n    for i in range(n):\n        if i not in must_run and i not in must_off:\n            if u[i] == 1 and units_info[i]['u_i_0'] <= units_info[i]['p_shut_i']:\n                typeA.append(i)\n            elif u[i] == 0:\n                typeB.append(i)\n    \n    # Handle over-commitment\n    if total_min > current_load:\n        candidates = []\n        for i in typeA:\n            unit = units_info[i]\n            avg_cost = (unit['a_i'] + unit['b_i'] * lb[i] + unit['c_i'] * lb[i]**2) / lb[i]\n            candidates.append((i, avg_cost, lb[i]))\n        candidates.sort(key=lambda x: x[1], reverse=True)  # Highest cost first\n        \n        for i, _, lb_i in candidates:\n            if total_min > current_load:\n                u[i] = 0\n                lb[i] = 0\n                hb[i] = 0\n                total_min -= lb_i\n                total_max -= hb[i]\n            else:\n                break\n    \n    # Recompute total_max if TypeA units were turned off\n    if total_max < current_load:\n        candidates = []\n        for i in typeB:\n            unit = units_info[i]\n            max_output = min(unit['p_max_i'], unit['p_start_i'])\n            avg_cost = (unit['s_i'] + unit['a_i'] + unit['b_i'] * max_output + unit['c_i'] * max_output**2) / max_output\n            candidates.append((i, avg_cost, max_output))\n        candidates.sort(key=lambda x: x[1])  # Lowest cost first\n        \n        for i, _, max_output in candidates:\n            if total_max < current_load:\n                u[i] = 1\n                lb[i] = unit['p_min_i']\n                hb[i] = max_output\n                total_min += lb[i]\n                total_max += max_output\n            else:\n                break\n    \n    # Final lb/hb update for all committed units\n    for i in range(n):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:  # Was online\n                lb[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                hb[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:  # Started this period\n                lb[i] = units_info[i]['p_min_i']\n                hb[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        else:\n            lb[i] = 0\n            hb[i] = 0\n    \n    total_min = np.sum(lb)\n    total_max = np.sum(hb)\n    \n    # Dispatch load\n    p = np.zeros(n)\n    if total_min > current_load:\n        p[:] = lb[:]\n    elif total_max < current_load:\n        p[:] = hb[:]\n    else:\n        # Start from minimum outputs\n        p[:] = lb[:]\n        remaining = current_load - total_min\n        headroom = np.copy(hb) - p\n        \n        # Allocate remaining load based on incremental cost\n        while remaining > 1e-6 and np.max(headroom) > 1e-6:\n            min_inc_cost = float('inf')\n            candidate = -1\n            for i in range(n):\n                if headroom[i] > 1e-6:\n                    inc_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                    if inc_cost < min_inc_cost:\n                        min_inc_cost = inc_cost\n                        candidate = i\n            \n            if candidate == -1:\n                break\n            # Increase candidate's output\n            increment = min(headroom[candidate], remaining)\n            p[candidate] += increment\n            headroom[candidate] -= increment\n            remaining -= increment\n    \n    # Prepare output array\n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0001296784,
          "gap_price_rate": 0.0346418817,
          "fitness": 0.0173857801
     },
     {
          "name": "dynamic_ramp_priority_commitment",
          "algorithm": "1. Identify must-on units if unit was online and hasn't satisfied min uptime or previous output exceeded shutdown ramp limit.\n2. Identify must-off units if unit was offline and hasn't satisfied min downtime.\n3. Set must-on units to online, must-off units to offline, others maintain previous state.\n4. Compute current min/max outputs for online units considering ramp constraints and startup limits.\n5. If load exceeds current capacity, activate flexible offline units by lowest average cost at max output including startup costs.\n6. If load is below minimum generation, keep online units at minimum output due to constraints.\n7. For dispatchable load range:\n   - Start at minimum generation of online units\n   - Allocate remaining load by increasing incremental cost order\n   - Respect individual unit ramp/startup constraints\n8. Return commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef dynamic_ramp_priority_commitment(units_info, load):\n    num_units = len(units_info)\n    u = [0] * num_units\n    p = [0] * num_units\n    must_on = []\n    must_off = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on.append(i)\n        elif unit['u_i_0'] == 0:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    for i in range(num_units):\n        if i in must_on:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n            \n    p_min = [0] * num_units\n    p_max = [0] * num_units\n    online_units = []\n    for i in range(num_units):\n        if u[i] == 1:\n            if units_info[i]['u_i_0'] == 1:\n                p_min[i] = max(units_info[i]['p_min_i'], units_info[i]['p_i_0'] - units_info[i]['p_down_i'])\n                p_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_i_0'] + units_info[i]['p_up_i'])\n            else:\n                p_min[i] = units_info[i]['p_min_i']\n                p_max[i] = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n            online_units.append(i)\n        else:\n            p_min[i] = 0\n            p_max[i] = 0\n\n    total_min = sum(p_min[i] for i in online_units)\n    total_max = sum(p_max[i] for i in online_units)\n    current_load = load[0]\n    \n    candidate_units = [i for i in range(num_units) if u[i] == 0 and i not in must_off]\n    candidate_units.sort(\n        key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + \n                       units_info[i]['b_i']*units_info[i]['p_max_i'] + \n                       units_info[i]['c_i']*units_info[i]['p_max_i']**2) / units_info[i]['p_max_i'])\n    \n    for i in candidate_units:\n        if total_max >= current_load:\n            break\n        u[i] = 1\n        new_min = units_info[i]['p_min_i']\n        new_max = min(units_info[i]['p_max_i'], units_info[i]['p_start_i'])\n        p_min[i] = new_min\n        p_max[i] = new_max\n        online_units.append(i)\n        total_min += new_min\n        total_max += new_max\n    \n    for i in online_units:\n        p[i] = p_min[i]\n    \n    if current_load <= total_min:\n        pass\n    elif current_load > total_max:\n        for i in online_units:\n            p[i] = p_max[i]\n    else:\n        remaining = current_load - total_min\n        allocatable_units = []\n        for i in online_units:\n            headroom = p_max[i] - p_min[i]\n            if headroom > 0:\n                inc_cost = 2 * units_info[i]['c_i'] * p_min[i] + units_info[i]['b_i']\n                allocatable_units.append((i, headroom, inc_cost))\n        allocatable_units.sort(key=lambda x: x[2])\n        \n        for i, headroom, _ in allocatable_units:\n            if remaining <= 0:\n                break\n            alloc = min(remaining, headroom)\n            p[i] += alloc\n            remaining -= alloc\n    \n    for i in range(num_units):\n        if u[i] == 0:\n            p[i] = 0\n            \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.0355884996,
          "fitness": 0.0178300959
     },
     {
          "name": "novel_combined_rolling_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef novel_combined_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    # Initialize arrays for u_i and p_i\n    u_i_arr = np.zeros(n_units, dtype=int)\n    p_i_arr = np.zeros(n_units)\n    \n    # Step 1: Classify units\n    must_run = []      # must be on\n    must_off = []      # must be off\n    flexible_on = []   # currently on and can be turned off\n    flexible_off = []  # currently off and can be turned on\n    feasible_min = [0] * n_units\n    feasible_max = [0] * n_units\n    \n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1:  # currently on\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_run.append(idx)\n            else:\n                flexible_on.append(idx)\n        else:  # currently off\n            if t_i0 < 0 and abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(idx)\n            else:\n                flexible_off.append(idx)\n    \n    # Initialize committed units: must_run and initially flexible_on\n    committed_on = set(must_run)\n    committed_on |= set(flexible_on)\n    \n    # Calculate feasible ranges for must_run and flexible_on units\n    for idx in committed_on:\n        unit = units_info[idx]\n        p_min = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n        p_max = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        feasible_min[idx] = p_min\n        feasible_max[idx] = p_max\n    \n    # Also calculate for must_off and flexible_off if needed later\n    for idx in must_off + flexible_off:\n        feasible_min[idx] = 0.0\n        feasible_max[idx] = 0.0\n    \n    # Step 2: Compute total min and max from committed units\n    total_min = sum(feasible_min[i] for i in committed_on)\n    total_max = sum(feasible_max[i] for i in committed_on)\n    \n    # Step 3: Adjust commitment based on load\n    if current_load > total_max:  # under-committed\n        # Calculate average cost for flexible_off units\n        avg_costs = []\n        for idx in flexible_off:\n            unit = units_info[idx]\n            min_output = unit['p_min_i']\n            avg_cost = (unit['s_i'] + unit['b_i'] * min_output + unit['c_i'] * min_output**2) / min_output\n            avg_costs.append((avg_cost, idx))\n        \n        # Sort by average cost (ascending)\n        avg_costs.sort(key=lambda x: x[0])\n        \n        for cost, idx in avg_costs:\n            if total_max >= current_load:\n                break\n            # Calculate feasible range if turned on\n            unit = units_info[idx]\n            min_on = unit['p_min_i']\n            max_on = min(unit['p_max_i'], unit['p_start_i'])\n            # Update committed and feasible ranges\n            committed_on.add(idx)\n            feasible_min[idx] = min_on\n            feasible_max[idx] = max_on\n            total_min += min_on\n            total_max += max_on\n    \n    elif current_load < total_min:  # over-committed\n        # Calculate average cost for flexible_on units\n        avg_costs = []\n        for idx in flexible_on:\n            unit = units_info[idx]\n            min_output = feasible_min[idx]\n            avg_cost = (unit['b_i'] * min_output + unit['c_i'] * min_output**2) / min_output\n            avg_costs.append((avg_cost, idx))\n        \n        # Sort by average cost (descending)\n        avg_costs.sort(key=lambda x: -x[0])\n        \n        for cost, idx in avg_costs:\n            if total_min <= current_load:\n                break\n            # Remove unit from committed\n            committed_on.discard(idx)\n            total_min -= feasible_min[idx]\n            total_max -= feasible_max[idx]\n    \n    # Step 4: Economic Dispatch\n    p_i_arr = [0.0] * n_units\n    \n    # Set outputs for non-committed units to 0\n    # For committed units, initially set to feasible_min\n    p_min_sum = 0.0\n    for idx in committed_on:\n        p_i_arr[idx] = feasible_min[idx]\n        p_min_sum += feasible_min[idx]\n    \n    remaining_load = current_load - p_min_sum\n    \n    if remaining_load > 0:\n        # Units with headroom: (incremental_cost, idx, headroom)\n        dispatch_list = []\n        for idx in committed_on:\n            headroom = feasible_max[idx] - feasible_min[idx]\n            if headroom > 0:\n                inc_cost = units_info[idx]['b_i'] + 2 * units_info[idx]['c_i'] * feasible_min[idx]\n                dispatch_list.append((inc_cost, idx, headroom))\n        \n        # Sort by incremental cost (ascending)\n        dispatch_list.sort(key=lambda x: x[0])\n        \n        for inc_cost, idx, headroom in dispatch_list:\n            if remaining_load <= 0:\n                break\n            to_allocate = min(headroom, remaining_load)\n            p_i_arr[idx] += to_allocate\n            remaining_load -= to_allocate\n    \n    # Set u_i for committed units to 1, others remain 0\n    for idx in range(n_units):\n        u_i_arr[idx] = 1 if idx in committed_on else 0\n    \n    # Format output as a 2D NumPy array\n    schedules = np.array([u_i_arr, p_i_arr])\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 7.16921e-05,
          "gap_price_rate": 0.041064632,
          "fitness": 0.0205681621
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run, must-off, and flexible based on min up/down times and shutdown ramp constraints\n  2. Initialize commitment states for must-run (on), must-off (off), and flexible (maintain current state)\n  3. Adjust commitment for flexible units if needed: turn on additional units by full-load average cost if undercommitted, turn off flexible units by average cost if overcommitted\n  4. Perform constrained economic dispatch using incremental cost sorting to allocate load within ramp and output limits\n  5. Return commitment states and power outputs for all units\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    # Extract parameters\n    a = [u['a_i'] for u in units_info]\n    b = [u['b_i'] for u in units_info]\n    c = [u['c_i'] for u in units_info]\n    p_min = [u['p_min_i'] for u in units_info]\n    p_max = [u['p_max_i'] for u in units_info]\n    p_up = [u['p_up_i'] for u in units_info]\n    p_down = [u['p_down_i'] for u in units_info]\n    p_start = [u['p_start_i'] for u in units_info]\n    p_shut = [u['p_shut_i'] for u in units_info]\n    min_up = [u['t_on_min_i'] for u in units_info]\n    min_down = [u['t_off_min_i'] for u in units_info]\n    startup_cost = [u['s_i'] for u in units_info]\n    u_prev = [u['u_i_0'] for u in units_info]\n    t_prev = [u['t_i_0'] for u in units_info]\n    p_prev = [u['p_i_0'] for u in units_info]\n    \n    # Initialize arrays\n    u_current = [0] * n_units\n    p_current = [0] * n_units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    \n    # Classify units\n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < min_up[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        else:\n            if abs(t_prev[i]) < min_down[i]:\n                must_off[i] = True\n    \n    # Initialize commitment\n    for i in range(n_units):\n        if must_run[i]:\n            u_current[i] = 1\n        elif must_off[i]:\n            u_current[i] = 0\n        else:\n            u_current[i] = u_prev[i]\n    \n    # Calculate available capacity for committed units\n    min_outputs = [0] * n_units\n    max_outputs = [0] * n_units\n    for i in range(n_units):\n        if u_current[i] == 1:\n            if u_prev[i] == 1:\n                min_outputs[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_outputs[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:\n                min_outputs[i] = p_min[i]\n                max_outputs[i] = min(p_max[i], p_start[i])\n        else:\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    total_min = sum(min_outputs)\n    total_max = sum(max_outputs)\n    \n    # Adjust commitment if needed\n    committed_indices = [i for i in range(n_units) if u_current[i] == 1]\n    flexible_off = [i for i in range(n_units) if not must_run[i] and not must_off[i] and u_current[i] == 0]\n    flexible_on = [i for i in range(n_units) if not must_run[i] and u_current[i] == 1]\n    \n    # Under-commitment case\n    if total_max < current_load:\n        # Sort by full-load average cost including startup\n        costs = []\n        for i in flexible_off:\n            avg_cost = (a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2) + startup_cost[i]) / p_max[i]\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1])\n        \n        for i, _ in costs:\n            if total_max >= current_load:\n                break\n            u_current[i] = 1\n            min_outputs[i] = p_min[i]\n            max_outputs[i] = min(p_max[i], p_start[i])\n            total_min += min_outputs[i]\n            total_max += max_outputs[i]\n            flexible_on.append(i)\n    \n    # Over-commitment case\n    if total_min > current_load:\n        # Sort by average cost at min output\n        costs = []\n        for i in flexible_on:\n            cost_val = a[i] + b[i]*min_outputs[i] + c[i]*(min_outputs[i]**2)\n            avg_cost = cost_val / min_outputs[i] if min_outputs[i] > 0 else float('inf')\n            costs.append((i, avg_cost))\n        costs.sort(key=lambda x: x[1], reverse=True)\n        \n        for i, _ in costs:\n            if total_min <= current_load:\n                break\n            u_current[i] = 0\n            total_min -= min_outputs[i]\n            total_max -= max_outputs[i]\n            min_outputs[i] = 0\n            max_outputs[i] = 0\n    \n    # Economic dispatch\n    committed_idx = [i for i in range(n_units) if u_current[i] == 1]\n    # Set initial output to min\n    for i in committed_idx:\n        p_current[i] = min_outputs[i]\n    \n    remaining_load = current_load - sum(min_outputs)\n    # Calculate incremental costs\n    inc_costs = []\n    for i in committed_idx:\n        inc_cost = b[i] + 2*c[i]*min_outputs[i]\n        inc_costs.append((i, inc_cost))\n    inc_costs.sort(key=lambda x: x[1])\n    \n    # Distribute remaining load\n    for i, _ in inc_costs:\n        if remaining_load <= 0:\n            break\n        allocatable = min(remaining_load, max_outputs[i] - min_outputs[i])\n        p_current[i] += allocatable\n        remaining_load -= allocatable\n    \n    # Format output\n    schedules = np.array([u_current, p_current])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00018,
          "gap_price_rate": 0.0515,
          "fitness": 0.02584
     },
     {
          "name": "novel_heuristic_commitment",
          "algorithm": "This heuristic first identifies must-on and must-off units based on minimum up/down times and shutdown ramp constraints. Then, it sorts flexible units by average cost at minimum output (including startup cost if applicable) and commits flexible units until total maximum capacity meets the load. Finally, it performs economic dispatch using incremental cost sorting while respecting output and ramp constraints.\n",
          "code": "import numpy as np\n\ndef novel_heuristic_commitment(units_info, load):\n    current_load = load[0]\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    for unit in units_info:\n        u0 = unit['u_i_0']\n        t0 = unit['t_i_0']\n        p0 = unit['p_i_0']\n        p_shut = unit['p_shut_i']\n        min_up = unit['t_on_min_i']\n        min_down = unit['t_off_min_i']\n        \n        if u0 == 1:\n            if t0 < min_up or p0 > p_shut:\n                must_on.append(unit)\n            else:\n                flexible.append(unit)\n        else:\n            if abs(t0) < min_down:\n                must_off.append(unit)\n            else:\n                flexible.append(unit)\n    \n    for unit in must_on:\n        unit['u_i'] = 1\n    for unit in must_off:\n        unit['u_i'] = 0\n        \n    total_min = sum(unit['p_min_i'] for unit in must_on)\n    total_max = sum(unit['p_max_i'] for unit in must_on)\n    \n    def cost_per_mw(unit):\n        if unit['u_i_0'] == 0:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2 + unit['s_i']) / unit['p_min_i']\n        else:\n            return (unit['a_i'] + unit['b_i']*unit['p_min_i'] + unit['c_i']*unit['p_min_i']**2) / unit['p_min_i']\n    \n    flexible.sort(key=cost_per_mw)\n    \n    committed = must_on.copy()\n    for unit in flexible:\n        if total_max >= current_load:\n            break\n        unit['u_i'] = 1\n        committed.append(unit)\n        total_max += unit['p_max_i']\n    \n    ranges = []\n    for unit in committed:\n        if unit['u_i_0'] == 1:\n            low = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            high = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            low = unit['p_min_i']\n            high = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((low, high))\n    \n    total_low = sum(low for low, high in ranges)\n    total_high = sum(high for low, high in ranges)\n    \n    p_values = [low for low, high in ranges]\n    \n    if current_load > total_high:\n        p_values = [high for low, high in ranges]\n    elif current_load < total_low:\n        p_values = [low for low, high in ranges]\n    else:\n        current_total = total_low\n        inc_units = []\n        for i, unit in enumerate(committed):\n            inc_units.append({\n                'idx': i,\n                'p': p_values[i],\n                'low': ranges[i][0],\n                'high': ranges[i][1],\n                'b': unit['b_i'],\n                'c': unit['c_i']\n            })\n        \n        while current_total < current_load:\n            min_inc = float('inf')\n            best_idx = None\n            for u in inc_units:\n                if u['p'] < u['high']:\n                    inc_cost = u['b'] + 2 * u['c'] * u['p']\n                    if inc_cost < min_inc:\n                        min_inc = inc_cost\n                        best_idx = u['idx']\n            if best_idx is None:\n                break\n                \n            u = inc_units[best_idx]\n            max_add = min(u['high'] - u['p'], current_load - current_total)\n            u['p'] += max_add\n            current_total += max_add\n    \n        for u in inc_units:\n            p_values[u['idx']] = u['p']\n    \n    for i, unit in enumerate(committed):\n        unit['p_i'] = p_values[i]\n    \n    for unit in must_off:\n        unit['p_i'] = 0\n    for unit in flexible:\n        if unit not in committed:\n            unit['u_i'] = 0\n            unit['p_i'] = 0\n    \n    u_list = [unit['u_i'] for unit in units_info]\n    p_list = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_list, p_list])",
          "from": null,
          "gap_power_rate": 0.02545,
          "gap_price_rate": 0.02724,
          "fitness": 0.02635
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "This heuristic first identifies units that must remain on or off due to physical constraints like minimum up/down times and shutdown ramp limits. It then prioritizes flexible units based on cost-effectiveness, considering both current and forecasted loads. The algorithm ensures load allocation respects all operational constraints while minimizing total cost through a greedy commitment strategy and proportional load dispatch.\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    next_load = load[1]\n    n_units = len(units_info)\n    must_on = set()\n    must_off = set()\n    \n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        t_on_min = unit['t_on_min_i']\n        t_off_min = unit['t_off_min_i']\n        p_shut = unit['p_shut_i']\n        \n        if u_i0 == 1:\n            if t_i0 < t_on_min or p_i0 > p_shut:\n                must_on.add(i)\n        else:\n            if abs(t_i0) < t_off_min:\n                must_off.add(i)\n    \n    flexible = set(range(n_units)) - must_on - must_off\n    committed = set(must_on)\n    max_power = 0.0\n    min_power = 0.0\n    \n    for i in committed:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            min_power += max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_power += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_power += unit['p_min_i']\n            max_power += min(unit['p_start_i'], unit['p_max_i'])\n    \n    if max_power < current_load:\n        cost_list = []\n        for i in flexible:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2\n            else:\n                cost = unit['a_i'] + unit['b_i'] * unit['p_max_i'] + unit['c_i'] * unit['p_max_i']**2 + unit['s_i']\n            cost_per_mw = cost / unit['p_max_i']\n            cost_list.append((cost_per_mw, i))\n        \n        cost_list.sort(key=lambda x: x[0])\n        for _, i in cost_list:\n            if max_power >= current_load:\n                break\n            unit = units_info[i]\n            committed.add(i)\n            if unit['u_i_0'] == 1:\n                max_power += min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_power += min(unit['p_start_i'], unit['p_max_i'])\n    \n    schedules_u = [0] * n_units\n    schedules_p = [0] * n_units\n    min_outputs = []\n    max_outputs = []\n    committed_list = list(committed)\n    \n    for i in committed_list:\n        unit = units_info[i]\n        schedules_u[i] = 1\n        if unit['u_i_0'] == 1:\n            min_o = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_o = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_o = unit['p_min_i']\n            max_o = min(unit['p_start_i'], unit['p_max_i'])\n        min_outputs.append(min_o)\n        max_outputs.append(max_o)\n        schedules_p[i] = min_o\n    \n    total_min = sum(min_outputs)\n    remaining_load = current_load - total_min\n    \n    if remaining_load > 0:\n        total_room = sum(max_o - min_o for min_o, max_o in zip(min_outputs, max_outputs))\n        if total_room > 0:\n            for idx, i in enumerate(committed_list):\n                room = max_outputs[idx] - min_outputs[idx]\n                schedules_p[i] += remaining_load * (room / total_room)\n    \n    return np.array([schedules_u, schedules_p])",
          "from": null,
          "gap_power_rate": 0.0,
          "gap_price_rate": 0.06376,
          "fitness": 0.03188
     }
]