[
     {
          "name": "rolling_forecast_uc_refined1",
          "algorithm": "1. Identify must-run units (online previously with insufficient min uptime or previous output exceeding shutdown ramp limit) and must-off units (offline previously with insufficient min downtime)\n2. Set must-run units online, must-off units offline; retain previous states for flexible units\n3. Compute feasible output ranges for online units considering ramp constraints and startup limits\n4. Calculate total min/max output capacity of online units\n5. Adjust over-committed units: \n   - Sort non-must-run online units by operating cost at min output (descending)\n   - Turn off units if removal maintains min output \u2264 current load\n6. Adjust under-committed units: \n   - Sort candidate offline units by average cost at min output (including startup)\n   - Turn on units until max output covers current load, maintaining min output \u2264 current load\n7. Recompute feasible output ranges for all online units\n8. Dispatch economically:\n   - Set online units to min output\n   - Allocate residual load to units with smallest incremental cost\n9. Set offline units' output to zero\n\n",
          "code": "import numpy as np\n\ndef rolling_forecast_uc_refined1(units_info, load):\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Initialize variables\n    n_units = len(units_info)\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    \n    # Precompute min and max output for each unit based on type\n    min_output = [unit['p_min_i'] for unit in units_info]\n    max_output = [unit['p_max_i'] for unit in units_info]\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if (t_i0 < unit['t_on_min_i']) or (p_i0 > unit['p_shut_i']):\n                must_run.append(i)\n        else:  # Previously offline\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Step 2: Set commitment states\n    for i in range(n_units):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    # Helper function to compute feasible output ranges\n    def get_feasible_range(i, online):\n        unit = units_info[i]\n        if online:\n            if unit['u_i_0'] == 1:  # Was previously online\n                lower_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                upper_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n                return (lower_bound, upper_bound)\n            else:  # Newly started\n                upper_bound = min(unit['p_max_i'], unit['p_start_i'])\n                return (unit['p_min_i'], upper_bound)\n        return (0, 0)  # Offline unit\n    \n    # Helper function to calculate operating cost\n    def operating_cost(i, output):\n        unit = units_info[i]\n        return unit['a_i'] + unit['b_i']*output + unit['c_i']*output**2\n    \n    # Helper function to amortized startup cost at min output\n    def amortized_cost(i):\n        unit = units_info[i]\n        min_cost = operating_cost(i, min_output[i])\n        return (min_cost + unit['s_i']) / min_output[i] if min_output[i] > 0 else float('inf')\n    \n    # Helper function for incremental cost\n    def incremental_cost(i, output):\n        unit = units_info[i]\n        return unit['b_i'] + 2 * unit['c_i'] * output\n    \n    # Initialize lists for online units and their ranges\n    online_units = [i for i in range(n_units) if u[i] == 1]\n    feasible_min = np.zeros(n_units)\n    feasible_max = np.zeros(n_units)\n    \n    # Steps 3 & 4: Compute initial feasible ranges and total capacity\n    for i in online_units:\n        low, high = get_feasible_range(i, True)\n        feasible_min[i] = low\n        feasible_max[i] = high\n    \n    total_min = sum(feasible_min[i] for i in online_units)\n    total_max = sum(feasible_max[i] for i in online_units)\n    \n    # Step 5: Adjust over-committed units\n    non_must_run_online = [i for i in online_units if i not in must_run]\n    non_must_run_online.sort(key=lambda i: operating_cost(i, min_output[i]), reverse=True)\n    \n    for i in non_must_run_online:\n        if total_min - min_output[i] <= current_load:\n            u[i] = 0  # Turn off unit\n            online_units.remove(i)\n            total_min -= feasible_min[i]\n            total_max -= feasible_max[i]\n    \n    # Step 6: Adjust under-committed units\n    candidate_offline = [i for i in range(n_units) \n                         if u[i] == 0 and i not in must_off and min_output[i] > 0]\n    candidate_offline.sort(key=amortized_cost)\n    \n    for i in candidate_offline:\n        if total_max >= current_load:\n            break\n        new_min = total_min + min_output[i]\n        if new_min <= current_load:\n            u[i] = 1\n            online_units.append(i)\n            low, high = get_feasible_range(i, True)\n            feasible_min[i] = low\n            feasible_max[i] = high\n            total_min = new_min\n            total_max += min(high, max_output[i])  # Use startup ramp limit\n    \n    # Step 7: Recompute feasible ranges for all online units\n    for i in online_units:\n        low, high = get_feasible_range(i, True)\n        feasible_min[i] = low\n        feasible_max[i] = high\n    \n    # Step 8: Economic dispatch\n    p.fill(0)\n    for i in online_units:\n        p[i] = feasible_min[i]\n    \n    residual = current_load - sum(p)\n    online_idx = sorted(online_units, key=lambda i: incremental_cost(i, p[i]))\n    \n    for i in online_idx:\n        if residual <= 0:\n            break\n        available = feasible_max[i] - p[i]\n        alloc = min(available, residual)\n        p[i] += alloc\n        residual -= alloc\n    \n    # Step 9: Ensure offline units have zero output\n    for i in range(n_units):\n        if u[i] == 0:\n            p[i] = 0\n    \n    return np.vstack([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0061416892,
          "gap_price_rate": 0.0105126155,
          "fitness": 0.0083271523
     },
     {
          "name": "enhanced_rolling_commitment_v1",
          "algorithm": "1. Identify must-run and must-off units:  \n   - Must-run: Units that were online (u_i_0=1) with insufficient uptime (t_i_0 < t_on_min_i) or previous output exceeds shutdown capacity (p_i_0 > p_shut_i)  \n   - Must-off: Units that were offline (u_i_0=0) with insufficient downtime (|t_i_0| < t_off_min_i)  \n2. Initialize commitment: Set must-run units to on (u_i=1), must-off units to off (u_i=0), retain previous states for others  \n3. Over-commitment adjustment 1: Turn off expensive flexible non-must-run units if minimum output remains \u2264 current load and maximum output remains \u2265 forecasted load  \n4. Under-commitment adjustment for current load: Turn on offline non-must-off units by ascending amortized startup cost until meeting current load  \n5. Under-commitment for next period: Turn on additional units for forecasted load if minimum output remains \u2264 current load  \n6. Over-commitment adjustment 2: Repeat step 3 if needed  \n7. Compute feasible output ranges for online units (respecting ramp limits)  \n8. Perform economic dispatch:  \n   - Initialize online units to minimum feasible output  \n   - Distribute residual load via incremental cost order  \n   - Handle over-generation by leaving at minimum output  \n9. Set offline units to zero output  \n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_commitment_v1(units_info, load):\n    n = len(units_info)\n    current_load, next_load = load[0], load[1]\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = [False] * n\n    must_off = [False] * n\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        if unit['u_i_0'] == 0:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Step 2: Initialize commitment states\n    u = [0] * n\n    for i in range(n):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = units_info[i]['u_i_0']\n    \n    online_units = [i for i in range(n) if u[i] == 1]\n    \n    def get_feasible_range(unit):\n        if unit['u_i_0'] == 1:\n            min_out = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_out = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_out = unit['p_min_i']\n            max_out = min(unit['p_max_i'], unit['p_start_i'])\n        return min_out, max_out\n    \n    min_outputs = [0] * n\n    max_outputs = [0] * n\n    for i in online_units:\n        min_outputs[i], max_outputs[i] = get_feasible_range(units_info[i])\n    \n    total_min_output = sum(min_outputs[i] for i in online_units)\n    total_max_output = sum(max_outputs[i] for i in online_units)\n    \n    # Helper function for over-commitment adjustment\n    def adjust_over_commitment():\n        nonlocal total_min_output, total_max_output, online_units, u\n        candidate_off = [i for i in online_units if not must_run[i]]\n        if not candidate_off:\n            return\n        \n        candidate_off.sort(\n            key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i'] * min_outputs[i] + units_info[i]['c_i'] * min_outputs[i]**2,\n            reverse=True\n        )\n        \n        changed = True\n        while changed and candidate_off:\n            changed = False\n            for i in candidate_off[:]:\n                new_min = total_min_output - min_outputs[i]\n                new_max = total_max_output - max_outputs[i]\n                if new_min <= current_load and new_max >= next_load:\n                    u[i] = 0\n                    online_units.remove(i)\n                    total_min_output = new_min\n                    total_max_output = new_max\n                    candidate_off.remove(i)\n                    changed = True\n                    break\n    \n    # Step 3: Over-commitment adjustment 1\n    adjust_over_commitment()\n    \n    # Step 4: Under-commitment for current load\n    candidate_on = [i for i in range(n) if u[i] == 0 and not must_off[i]]\n    if candidate_on:\n        amortized_costs = [\n            (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_max_i'] + \n             units_info[i]['c_i'] * units_info[i]['p_max_i']**2) / max(units_info[i]['p_max_i'], 1e-6)\n            for i in candidate_on\n        ]\n        candidate_on_sorted = [i for _, i in sorted(zip(amortized_costs, candidate_on))]\n        \n        for i in candidate_on_sorted:\n            if total_max_output >= current_load:\n                break\n            min_out, max_out = get_feasible_range(units_info[i])\n            min_outputs[i] = min_out\n            max_outputs[i] = max_out\n            u[i] = 1\n            online_units.append(i)\n            total_min_output += min_out\n            total_max_output += max_out\n    \n    # Step 5: Under-commitment for next period\n    candidate_on = [i for i in range(n) if u[i] == 0 and not must_off[i]]\n    if candidate_on:\n        amortized_costs = [\n            (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * units_info[i]['p_max_i'] + \n             units_info[i]['c_i'] * units_info[i]['p_max_i']**2) / max(units_info[i]['p_max_i'], 1e-6)\n            for i in candidate_on\n        ]\n        candidate_on_sorted = [i for _, i in sorted(zip(amortized_costs, candidate_on))]\n        \n        for i in candidate_on_sorted:\n            if total_min_output > current_load or total_max_output >= next_load:\n                break\n            min_out, max_out = get_feasible_range(units_info[i])\n            min_outputs[i] = min_out\n            max_outputs[i] = max_out\n            u[i] = 1\n            online_units.append(i)\n            total_min_output += min_out\n            total_max_output += max_out\n    \n    # Step 6: Over-commitment adjustment 2\n    adjust_over_commitment()\n    \n    # Step 7: Recompute feasible ranges\n    for i in online_units:\n        min_outputs[i], max_outputs[i] = get_feasible_range(units_info[i])\n    \n    # Step 8: Economic dispatch\n    p = [0.0] * n\n    total_gen = 0.0\n    for i in online_units:\n        p[i] = min_outputs[i]\n        total_gen += p[i]\n    \n    residual = current_load - total_gen\n    \n    if residual > 0:\n        candidate_up = [i for i in online_units if p[i] < max_outputs[i]]\n        candidate_up.sort(\n            key=lambda i: 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n        )\n        for i in candidate_up:\n            if residual <= 0:\n                break\n            room = max_outputs[i] - p[i]\n            amount = min(residual, room)\n            p[i] += amount\n            residual -= amount\n    \n    # Step 9: Set offline units to zero\n    for i in range(n):\n        if u[i] == 0:\n            p[i] = 0.0\n    \n    return np.array([u, p])",
          "from": "crossover",
          "gap_power_rate": 0.0031123062,
          "gap_price_rate": 0.0137852837,
          "fitness": 0.008448795
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "1. Identify must-run units (previously online violating min up-time or shutdown ramp limits) and must-off units (previously offline violating min down-time)\n2. Initialize commitment: must-run units online, must-off units offline; retain previous states for flexible units\n3. Compute feasible output ranges for online units considering ramp and startup constraints\n4. Over-commitment adjustment: Turn off expensive non-must-run units if removal maintains sufficient capacity for current and forecasted load\n5. Under-commitment adjustment: Turn on offline units sorted by amortized cost if needed to cover max(current load, forecasted load) while maintaining min output constraint\n6. Second over-commitment adjustment to optimize further\n7. Economic dispatch:\n   - Initialize online units to minimum feasible output\n   - Allocate residual load to units with smallest incremental cost\n8. Set offline units to zero output\n",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    n = len(units_info)\n    u = np.zeros(n, dtype=int)\n    min_output = np.zeros(n)\n    max_output = np.zeros(n)\n    must_run = []\n    must_off = []\n    \n    # Identify must-run and must-off units\n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run.append(i)\n        else:\n            if abs(unit['t_i_0']) < unit['t_off_min_i']:\n                must_off.append(i)\n    \n    # Initialize commitment states\n    for i in range(n):\n        if i in must_run:\n            u[i] = 1\n        elif i in must_off:\n            u[i] = 0\n        else:\n            u[i] = unit['u_i_0']\n    \n    # Compute feasible output ranges\n    for i, unit in enumerate(units_info):\n        if u[i] == 1:\n            if unit['u_i_0'] == 1:\n                min_output[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_output[i] = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                min_output[i] = unit['p_min_i']\n                max_output[i] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Calculate total min/max capacity\n    total_min = sum(min_output[i] for i in range(n) if u[i] == 1)\n    total_max = sum(max_output[i] for i in range(n) if u[i] == 1)\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Over-commitment adjustment 1\n    non_must_run = [i for i in range(n) if u[i] == 1 and i not in must_run]\n    non_must_run.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] + units_info[i]['c_i'] * min_output[i]**2, reverse=True)\n    \n    for i in non_must_run:\n        new_total_min = total_min - min_output[i]\n        new_total_max = total_max - max_output[i]\n        if new_total_min <= current_load and new_total_max >= forecast_load:\n            u[i] = 0\n            total_min = new_total_min\n            total_max = new_total_max\n            min_output[i] = 0\n            max_output[i] = 0\n    \n    # Under-commitment adjustment\n    required_capacity = max(current_load, forecast_load)\n    if total_max < required_capacity:\n        candidates = [i for i in range(n) if u[i] == 0 and i not in must_off]\n        min_candidate = np.zeros(n)\n        max_candidate = np.zeros(n)\n        \n        for i in candidates:\n            unit = units_info[i]\n            min_candidate[i] = unit['p_min_i']\n            max_candidate[i] = min(unit['p_max_i'], unit['p_start_i'])\n        \n        candidates.sort(key=lambda i: (units_info[i]['s_i'] + units_info[i]['a_i'] + units_info[i]['b_i'] * max_candidate[i] + units_info[i]['c_i'] * max_candidate[i]**2) / max_candidate[i])\n        \n        for i in candidates:\n            new_total_min = total_min + min_candidate[i]\n            if new_total_min <= current_load:\n                u[i] = 1\n                total_min = new_total_min\n                min_output[i] = min_candidate[i]\n                max_output[i] = max_candidate[i]\n                total_max += max_candidate[i]\n                if total_max >= required_capacity:\n                    break\n    \n    # Over-commitment adjustment 2\n    non_must_run = [i for i in range(n) if u[i] == 1 and i not in must_run]\n    non_must_run.sort(key=lambda i: units_info[i]['a_i'] + units_info[i]['b_i'] * min_output[i] + units_info[i]['c_i'] * min_output[i]**2, reverse=True)\n    \n    for i in non_must_run:\n        new_total_min = total_min - min_output[i]\n        new_total_max = total_max - max_output[i]\n        if new_total_min <= current_load and new_total_max >= forecast_load:\n            u[i] = 0\n            total_min = new_total_min\n            total_max = new_total_max\n            min_output[i] = 0\n            max_output[i] = 0\n    \n    # Economic dispatch\n    p = np.zeros(n)\n    current_output = np.zeros(n)\n    online_indices = [i for i in range(n) if u[i] == 1]\n    \n    for i in online_indices:\n        current_output[i] = min_output[i]\n        p[i] = min_output[i]\n    \n    residual = current_load - sum(p)\n    online_indices = [i for i in online_indices if current_output[i] < max_output[i]]\n    \n    while residual > 0 and online_indices:\n        min_ic = float('inf')\n        candidate = None\n        \n        for i in online_indices:\n            ic = units_info[i]['b_i'] + 2 * units_info[i]['c_i'] * current_output[i]\n            if ic < min_ic:\n                min_ic = ic\n                candidate = i\n        \n        if candidate is None:\n            break\n        \n        max_add = max_output[candidate] - current_output[candidate]\n        add = min(residual, max_add)\n        current_output[candidate] += add\n        p[candidate] = current_output[candidate]\n        residual -= add\n        \n        if current_output[candidate] >= max_output[candidate]:\n            online_indices.remove(candidate)\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0034561774,
          "gap_price_rate": 0.0147240355,
          "fitness": 0.0090901064
     },
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "solve_rolling_uc",
          "algorithm": "1. Identify must-run units (online previously violating min up-time or shutdown ramp limits) and must-off units (offline previously violating min down-time)\n2. Set must-run units online, must-off units offline; retain previous states for others\n3. Compute feasible output ranges considering ramp/startup constraints\n4. Over-commitment adjustment: Turn off non-must-run units if removal maintains min output \u2264 current load and max output \u2265 max(current load, forecasted load)\n5. Under-commitment adjustment for current load: Turn on cheapest offline units until max output \u2265 current load, ensuring min output \u2264 current load\n6. Under-commitment for next period: Turn on additional cheapest offline units until max output \u2265 forecasted load, maintaining min output \u2264 current load\n7. Repeat over-commitment adjustment\n8. Dispatch economically: Set online units to min output; allocate residual load via incremental cost order\n9. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef solve_rolling_uc(units_info, load):\n    current_load = load[0]\n    forecasted_load = load[1]\n    n_units = len(units_info)\n    \n    # Extract unit attributes\n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    u_prev = [unit['u_i_0'] for unit in units_info]\n    t_prev = [unit['t_i_0'] for unit in units_info]\n    p_prev = [unit['p_i_0'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    \n    # Initialize commitments and outputs\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    min_output = np.zeros(n_units)\n    max_output = np.zeros(n_units)\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = np.zeros(n_units, dtype=bool)\n    must_off = np.zeros(n_units, dtype=bool)\n    \n    for i in range(n_units):\n        if u_prev[i] == 1:\n            if t_prev[i] < t_on_min[i] or p_prev[i] > p_shut[i]:\n                must_run[i] = True\n        elif u_prev[i] == 0:\n            if abs(t_prev[i]) < t_off_min[i]:\n                must_off[i] = True\n    \n    # Step 2: Set initial commitment\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n        elif must_off[i]:\n            u[i] = 0\n        else:\n            u[i] = u_prev[i]\n    \n    # Track online units and candidates\n    online = [i for i in range(n_units) if u[i] == 1]\n    offline = [i for i in range(n_units) if u[i] == 0]\n    \n    # Helper function to compute feasible output ranges\n    def compute_feasible_ranges(online_list):\n        min_out = np.zeros(n_units)\n        max_out = np.zeros(n_units)\n        for i in online_list:\n            if u_prev[i] == 1:  # Was previously online\n                min_out[i] = max(p_min[i], p_prev[i] - p_down[i])\n                max_out[i] = min(p_max[i], p_prev[i] + p_up[i])\n            else:  # Started in current period\n                min_out[i] = p_min[i]\n                max_out[i] = min(p_max[i], p_start[i])\n        return min_out, max_out\n    \n    # Step 3: Compute initial feasible ranges\n    min_output, max_output = compute_feasible_ranges(online)\n    total_min = np.sum(min_output[online])\n    total_max = np.sum(max_output[online])\n    \n    # Step 4: Over-commitment adjustment\n    def over_commitment():\n        nonlocal online, offline, total_min, total_max, u, min_output, max_output\n        non_must_run = [i for i in online if not must_run[i]]\n        \n        if not non_must_run:\n            return\n        \n        # Calculate average costs at min output for sorting\n        avg_costs = []\n        for i in non_must_run:\n            cost_val = a[i] + b[i] * min_output[i] + c[i] * min_output[i] ** 2\n            avg_cost = cost_val / min_output[i] if min_output[i] > 0 else float('inf')\n            avg_costs.append((avg_cost, i))\n        \n        avg_costs.sort(reverse=True, key=lambda x: x[0])\n        \n        changed = True\n        while changed:\n            changed = False\n            for _, i in avg_costs:\n                if i not in online: \n                    continue\n                new_min = total_min - min_output[i]\n                new_max = total_max - max_output[i]\n                max_load = max(current_load, forecasted_load)\n                if new_min <= current_load and new_max >= max_load:\n                    # Turn off unit\n                    u[i] = 0\n                    online.remove(i)\n                    offline.append(i)\n                    total_min = new_min\n                    total_max = new_max\n                    changed = True\n                    break\n    \n    over_commitment()\n    \n    # Step 5 & 6: Under-commitment adjustments\n    def under_commitment(target_load):\n        nonlocal online, offline, total_min, total_max, u, min_output, max_output\n        candidates = [i for i in offline if not must_off[i]]\n        \n        if not candidates:\n            return\n        \n        # Calculate amortized startup costs\n        amortized_costs = []\n        for i in candidates:\n            min_i = p_min[i]\n            max_i = min(p_max[i], p_start[i])\n            start_cost = s[i] + a[i] + b[i] * min_i + c[i] * min_i ** 2\n            amortized_cost = start_cost / min_i if min_i > 0 else float('inf')\n            amortized_costs.append((amortized_cost, i, min_i, max_i))\n        \n        amortized_costs.sort(key=lambda x: x[0])\n        \n        changed = True\n        while changed and total_max < target_load:\n            changed = False\n            for cost_val, i, min_i, max_i in amortized_costs:\n                if i not in offline:\n                    continue\n                if total_min + min_i <= current_load:\n                    # Turn on unit\n                    u[i] = 1\n                    offline.remove(i)\n                    online.append(i)\n                    min_output[i] = min_i\n                    max_output[i] = max_i\n                    total_min += min_i\n                    total_max += max_i\n                    changed = True\n                    break\n    \n    # Under-commit for current load\n    under_commitment(current_load)\n    # Under-commit for forecasted load\n    under_commitment(forecasted_load)\n    \n    # Step 7: Repeat over-commitment\n    over_commitment()\n    \n    # Recompute ranges for final online units\n    min_output, max_output = compute_feasible_ranges(online)\n    total_min = np.sum(min_output[online])\n    total_max = np.sum(max_output[online])\n    \n    # Step 8: Economic dispatch\n    residual = current_load - total_min\n    \n    # Allocate residual load via incremental cost\n    inc_costs = []\n    for i in online:\n        inc_cost = b[i] + 2 * c[i] * min_output[i]\n        inc_costs.append((inc_cost, i))\n    \n    inc_costs.sort(key=lambda x: x[0])\n    \n    # Assign min output first\n    for i in online:\n        p[i] = min_output[i]\n    \n    # Allocate residual\n    for ic, i in inc_costs:\n        if residual <= 0:\n            break\n        alloc = min(residual, max_output[i] - min_output[i])\n        p[i] += alloc\n        residual -= alloc\n    \n    # Create schedules array\n    schedules = np.array([u, p])\n    \n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0008007677,
          "gap_price_rate": 0.0192073169,
          "fitness": 0.0100040423
     },
     {
          "name": "enhanced_commitment_simple",
          "algorithm": "1. Identify must-run units (online previously with insufficient min up-time or exceeding shutdown ramp limit) and must-off units (offline previously with insufficient min down-time)\n2. Set must-run units online, must-off units offline; retain previous states for flexible units\n3. Compute feasible generation ranges considering ramp, startup, and shutdown constraints\n4. Adjust over-committed units by turning off expensive flexible units in descending order of cost at min-output (if net min-output remains \u2264 load and net max-output \u2265 load)\n5. Adjust under-committed units by turning on offline flexible units in ascending order of startup-amortized average cost at max-output (if net max-output < load)\n6. Perform incremental cost-based dispatch for online units:\n   - Start at minimum feasible output for all online units\n   - Allocate remaining load to units with smallest incremental cost\n   - Respect individual unit ramp and max/min constraints\n7. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_simple(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    u0 = [unit['u_i_0'] for unit in units_info]\n    t0 = [unit['t_i_0'] for unit in units_info]\n    p0 = [unit['p_i_0'] for unit in units_info]\n    \n    u = [0] * n_units\n    p = [0] * n_units\n    min_output = [0] * n_units\n    max_output = [0] * n_units\n    \n    must_run = []\n    must_off = []\n    flexible = list(range(n_units))\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if t0[i] < t_on_min[i] or p0[i] > p_shut[i]:\n                must_run.append(i)\n        else:\n            if -t0[i] < t_off_min[i]:\n                must_off.append(i)\n    \n    for i in must_run:\n        if i in flexible:\n            flexible.remove(i)\n    for i in must_off:\n        if i in flexible:\n            flexible.remove(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in flexible:\n        u[i] = u0[i]\n    \n    for i in range(n_units):\n        if u[i] == 1:\n            if u0[i] == 1:\n                min_output[i] = max(p_min[i], p0[i] - p_down[i])\n                max_output[i] = min(p_max[i], p0[i] + p_up[i])\n            else:\n                min_output[i] = p_min[i]\n                max_output[i] = min(p_max[i], p_start[i])\n        else:\n            min_output[i] = 0\n            max_output[i] = 0\n    \n    flex_online = [i for i in flexible if u[i] == 1]\n    flex_offline = [i for i in flexible if u[i] == 0]\n    \n    total_min = sum(min_output)\n    total_max = sum(max_output)\n    \n    cost_at_min = [a[i] + b[i]*min_output[i] + c[i]*min_output[i]**2 for i in flex_online]\n    sorted_high_cost = [i for _, i in sorted(zip(cost_at_min, flex_online), reverse=True)]\n    \n    for i in sorted_high_cost:\n        new_total_min = total_min - min_output[i]\n        new_total_max = total_max - max_output[i]\n        if new_total_min <= current_load and new_total_max >= current_load:\n            u[i] = 0\n            flex_online.remove(i)\n            flex_offline.append(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            min_output[i] = max_output[i] = 0\n        if total_min <= current_load:\n            break\n    \n    if total_max < current_load:\n        cand_info = []\n        for i in flex_offline:\n            cand_max = min(p_max[i], p_start[i])\n            total_cost = a[i] + b[i]*cand_max + c[i]*cand_max**2 + s[i]\n            avg_cost = total_cost / cand_max\n            cand_info.append((i, avg_cost, p_min[i], cand_max))\n        cand_info.sort(key=lambda x: x[1])\n        \n        for (i, _, cand_min, cand_max) in cand_info:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            flex_offline.remove(i)\n            flex_online.append(i)\n            min_output[i] = cand_min\n            max_output[i] = cand_max\n            total_min += cand_min\n            total_max += cand_max\n    \n    p = [min_output[i] for i in range(n_units)]\n    residual = current_load - sum(p)\n    \n    if residual > 0:\n        online_units = [i for i in range(n_units) if u[i] == 1]\n        inc_costs = [2*c[i]*p[i] + b[i] for i in online_units]\n        headroom = [max_output[i] - p[i] for i in online_units]\n        \n        while residual > 1e-6 and any(h > 1e-6 for h in headroom):\n            min_inc = float('inf')\n            best_idx = None\n            for idx, i in enumerate(online_units):\n                if headroom[idx] > 1e-6 and inc_costs[idx] < min_inc:\n                    min_inc = inc_costs[idx]\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n            \n            i = online_units[best_idx]\n            add = min(residual, headroom[best_idx])\n            p[i] += add\n            residual -= add\n            headroom[best_idx] -= add\n            inc_costs[best_idx] = 2*c[i]*p[i] + b[i]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0004271986,
          "gap_price_rate": 0.0197235801,
          "fitness": 0.0100753894
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Identify must-run units: Units currently on violating min up-time or shutdown ramp limits.\n2. Identify must-off units: Units currently off violating min down-time.\n3. Commit must-run units (u_i=1) and set must-off units to off (u_i=0).\n4. Compute total min/max capacity from must-run units considering ramp constraints.\n5. Sort flexible units by average cost/MW at min output (including startup if offline).\n6. Commit cheapest flexible units until total feasible capacity covers max(current, forecasted load).\n7. Dispatch by:\n   - Setting committed units to feasible minimum considering ramp limits.\n   - Allocating remaining load by increasing output of units with lowest incremental cost at current output.\n8. Non-committed units remain off with p_i=0.\n9. Return commitment state and output allocation.\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    units = [dict(unit) for unit in units_info]  # Copy input\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Identify must-run and must-off units\n    must_run = [False] * len(units)\n    must_off = [False] * len(units)\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:  # Currently on\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:  # Currently off\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n        unit['u_i'] = 0  # Initialize commitment\n    \n    # Calculate total capacity for must-run units\n    total_min_must_run = 0.0\n    total_max_must_run = 0.0\n    for i, unit in enumerate(units):\n        if must_run[i]:\n            unit['u_i'] = 1  # Commit must-run\n            if unit['u_i_0'] == 1:  # Previously on\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Previously off\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_min_must_run += min_i\n            total_max_must_run += max_i\n    \n    # Candidate flexible units (avg cost at min output)\n    candidate_flex = []\n    for i, unit in enumerate(units):\n        if not must_run[i] and not must_off[i]:\n            p_min = unit['p_min_i']\n            # Startup cost if currently off\n            startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n            avg_cost = (startup_cost + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n            # Current period max output\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            candidate_flex.append((avg_cost, max_i, i))\n    \n    # Commit cheapest flex until capacity >= max(load, forecast)\n    candidate_flex.sort(key=lambda x: x[0])\n    total_capacity = total_max_must_run\n    for _, max_i, idx in candidate_flex:\n        if total_capacity >= max(current_load, forecast_load):\n            break\n        units[idx]['u_i'] = 1  # Commit unit\n        total_capacity += max_i\n    \n    # Initial dispatch: set to min feasible output\n    p = [0.0] * len(units)\n    for i, unit in enumerate(units):\n        if unit['u_i'] == 1:  # Committed\n            if unit['u_i_0'] == 1:  # Was on\n                p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:  # Was off\n                p[i] = unit['p_min_i']\n    \n    # Allocate remaining load incrementally\n    total_p = sum(p)\n    remaining = current_load - total_p\n    committed_indices = [i for i in range(len(units)) if units[i]['u_i'] == 1]\n    \n    while remaining > 1e-6 and committed_indices:\n        # Calculate headroom and incremental costs\n        inc_costs = []\n        headrooms = []\n        indices = []\n        \n        for i in committed_indices:\n            # Calculate current unit constraints\n            if units[i]['u_i_0'] == 1:  # Was on\n                max_i = min(units[i]['p_max_i'], units[i]['p_i_0'] + units[i]['p_up_i'])\n                min_i = max(units[i]['p_min_i'], units[i]['p_i_0'] - units[i]['p_down_i'])\n            else:  # Was off\n                max_i = min(units[i]['p_max_i'], units[i]['p_start_i'])\n                min_i = units[i]['p_min_i']\n            headroom = max(0.0, max_i - p[i])\n            # Skip units with no headroom\n            if headroom < 1e-6:\n                continue\n            inc_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n            inc_costs.append(inc_cost)\n            headrooms.append(headroom)\n            indices.append(i)\n        \n        if not indices:  # No headroom remaining\n            break\n        \n        # Find unit with smallest incremental cost\n        min_cost_idx = np.argmin(inc_costs)\n        i_min = indices[min_cost_idx]\n        \n        # Allocate maximum possible to this unit\n        allocate = min(remaining, headrooms[min_cost_idx])\n        p[i_min] += allocate\n        remaining -= allocate\n    \n    # Update outputs\n    for i in range(len(units)):\n        units[i]['p_i'] = p[i]\n    \n    # Prepare output array\n    u_arr = [int(unit['u_i']) for unit in units]\n    p_arr = [unit['p_i'] for unit in units]\n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.0018740438,
          "gap_price_rate": 0.0185386497,
          "fitness": 0.0102063467
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "enhanced_rolling_forecast_uc_refined",
          "algorithm": "1. Identify must-run units (online previously with insufficient min uptime or previous output exceeding shutdown ramp limit) and must-off units (offline previously with insufficient min downtime)\n2. Set must-run units online, must-off units offline; retain previous states for flexible units\n3. Compute feasible output ranges for online units considering ramp constraints and startup limits\n4. Calculate total min/max output capacity of online units\n5. Adjust over-committed units considering both current and next period loads:\n   - Sort non-must-run online units by average cost at minimum output (descending)\n   - Turn off units only if removal maintains min output \u2264 current load AND max output \u2265 max(current load, forecasted load)\n6. Adjust under-committed units:\n   - Sort candidate offline units by amortized startup cost at min output (including startup cost)\n   - Turn on units until total max output covers max(current load, forecasted load), ensuring cumulative min output \u2264 current load\n7. Recompute feasible output ranges for all online units\n8. Dispatch economically:\n   - Set online units to min feasible output\n   - Allocate residual load to units with smallest incremental cost\n9. Set offline units' output to zero\n\n",
          "code": "import numpy as np\n\ndef enhanced_rolling_forecast_uc_refined(units_info, load):\n    current_load, forecasted_next = load\n    num_units = len(units_info)\n    schedules = np.zeros((2, num_units))\n    \n    # Extract unit data\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    p_min_i = [unit['p_min_i'] for unit in units_info]\n    p_max_i = [unit['p_max_i'] for unit in units_info]\n    p_up_i = [unit['p_up_i'] for unit in units_info]\n    p_down_i = [unit['p_down_i'] for unit in units_info]\n    p_start_i = [unit['p_start_i'] for unit in units_info]\n    t_on_min_i = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min_i = [unit['t_off_min_i'] for unit in units_info]\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    \n    u_i = [0] * num_units\n    p_i = [0] * num_units\n    min_feasible = [0] * num_units\n    max_feasible = [0] * num_units\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for i in range(num_units):\n        if u_i_0[i] == 1 and (t_i_0[i] < t_on_min_i[i] or p_i_0[i] > p_start_i[i]):\n            must_run.append(i)\n        elif u_i_0[i] == 0 and abs(t_i_0[i]) < t_off_min_i[i]:\n            must_off.append(i)\n    \n    # Step 2: Set initial commitment\n    for i in range(num_units):\n        if i in must_run:\n            u_i[i] = 1\n        elif i in must_off:\n            u_i[i] = 0\n        else:\n            u_i[i] = u_i_0[i]\n    \n    # Helper function to calculate feasible ranges\n    def compute_feasible_ranges():\n        for i in range(num_units):\n            if u_i[i] == 1:\n                if u_i_0[i] == 1:  # Was online\n                    min_feasible[i] = max(p_min_i[i], p_i_0[i] - p_down_i[i])\n                    max_feasible[i] = min(p_max_i[i], p_i_0[i] + p_up_i[i])\n                else:  # Started this period\n                    min_feasible[i] = p_min_i[i]\n                    max_feasible[i] = min(p_max_i[i], p_start_i[i])\n            else:\n                min_feasible[i] = 0\n                max_feasible[i] = 0\n    \n    # Step 3: Compute initial feasible ranges\n    compute_feasible_ranges()\n    \n    # Step 4: Calculate total min/max capacity\n    total_min = sum(min_feasible)\n    total_max = sum(max_feasible)\n    \n    # Step 5: Over-commitment adjustment\n    non_must_run_online = [i for i in range(num_units) \n                          if u_i[i] == 1 and i not in must_run]\n    \n    # Calculate average cost at min output for sorting\n    avg_costs = []\n    for i in non_must_run_online:\n        min_cost = a_i[i] + b_i[i]*min_feasible[i] + c_i[i]*(min_feasible[i]**2)\n        avg_costs.append(min_cost / min_feasible[i] if min_feasible[i] > 0 else float('inf'))\n    \n    # Sort descending by average cost\n    non_must_run_online = [x for _, x in sorted(zip(avg_costs, non_must_run_online), reverse=True)]\n    \n    for i in non_must_run_online:\n        new_min = total_min - min_feasible[i]\n        new_max = total_max - max_feasible[i]\n        forecast_max = max(current_load, forecasted_next)\n        \n        if new_min <= current_load and new_max >= forecast_max:\n            u_i[i] = 0\n            min_feasible[i] = 0\n            max_feasible[i] = 0\n            total_min = new_min\n            total_max = new_max\n    \n    # Step 6: Under-commitment adjustment\n    candidate_offline = [i for i in range(num_units) \n                        if u_i[i] == 0 and i not in must_off]\n    \n    # Calculate amortized startup cost metric\n    startup_metrics = []\n    for i in candidate_offline:\n        min_cost = a_i[i] + b_i[i]*p_min_i[i] + c_i[i]*(p_min_i[i]**2)\n        startup_metric = (s_i[i] + min_cost) / p_min_i[i] if p_min_i[i] > 0 else float('inf')\n        startup_metrics.append(startup_metric)\n    \n    # Sort ascending by amortized cost\n    candidate_offline = [x for _, x in sorted(zip(startup_metrics, candidate_offline))]\n    \n    for i in candidate_offline:\n        if total_max < max(current_load, forecasted_next) and total_min + p_min_i[i] <= current_load:\n            u_i[i] = 1\n            min_feasible[i] = p_min_i[i]\n            max_feasible[i] = min(p_max_i[i], p_start_i[i])\n            total_min += min_feasible[i]\n            total_max += max_feasible[i]\n    \n    # Step 7: Recompute feasible ranges after adjustments\n    compute_feasible_ranges()\n    \n    # Step 8: Economic dispatch\n    # Set to min feasible output\n    for i in range(num_units):\n        p_i[i] = min_feasible[i] if u_i[i] == 1 else 0\n    \n    residual = current_load - sum(p_i)\n    \n    # Allocate residual load by incremental cost\n    online_indices = [i for i in range(num_units) if u_i[i] == 1]\n    while residual > 1e-6 and online_indices:\n        # Calculate incremental costs\n        inc_costs = []\n        for i in online_indices:\n            inc_cost = 2*c_i[i]*p_i[i] + b_i[i]\n            inc_costs.append(inc_cost)\n        \n        # Find unit with smallest incremental cost\n        idx_min = np.argmin(inc_costs)\n        unit_idx = online_indices[idx_min]\n        \n        # Calculate max possible increase\n        max_increase = max_feasible[unit_idx] - p_i[unit_idx]\n        increase = min(residual, max_increase)\n        \n        # Update output and residual\n        p_i[unit_idx] += increase\n        residual -= increase\n        \n        # Remove unit if maxed out\n        if abs(p_i[unit_idx] - max_feasible[unit_idx]) < 1e-6:\n            online_indices.pop(idx_min)\n    \n    # Step 9: Set offline units to zero output\n    for i in range(num_units):\n        if u_i[i] == 0:\n            p_i[i] = 0\n    \n    # Prepare output\n    schedules[0, :] = u_i\n    schedules[1, :] = p_i\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0008081062,
          "gap_price_rate": 0.019947771,
          "fitness": 0.0103779386
     }
]