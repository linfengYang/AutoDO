[
     {
          "name": "commit_units_rolling_heuristic",
          "algorithm": "1. Classify units into must-run (due to min up/down times and shutdown ramp limits) and flexible units\n  2. Compute feasible output ranges for must-run units considering ramp constraints\n  3. If current load exceeds must-run capacity, activate flexible units by incremental cost order\n  4. Dispatch load using merit order based on incremental costs within feasible ranges\n  5. Handle over-generation by must-run units when load is below minimum possible output\n\n",
          "code": "import numpy as np\n\ndef commit_units_rolling_heuristic(units_info, load):\n    current_load = load[0]\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    flexible = []\n    \n    # Classify units\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_on.append(i)\n            else:\n                flexible.append(i)\n        else:\n            if abs(t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            else:\n                flexible.append(i)\n    \n    # Calculate feasible ranges for must-on units\n    ranges = []\n    for i in must_on:\n        unit = units_info[i]\n        if unit['u_i_0'] == 1:\n            lb = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        ranges.append((lb, ub))\n    \n    total_min = sum(lb for lb, ub in ranges)\n    total_max = sum(ub for lb, ub in ranges)\n    \n    # Determine flexible units to activate\n    flexible_activated = []\n    if current_load > total_max:\n        # Sort flexible units by incremental cost at min output\n        costs = []\n        for i in flexible:\n            unit = units_info[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * unit['p_min_i']\n            costs.append((inc_cost, i))\n        costs.sort(key=lambda x: x[0])\n        \n        for _, i in costs:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                ub = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                ub = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += ub\n            flexible_activated.append(i)\n            if total_max >= current_load:\n                break\n    \n    # Commit units\n    committed = must_on + flexible_activated\n    for i in committed:\n        u[i] = 1\n    \n    # Initialize outputs to minimum feasible\n    for idx, i in enumerate(committed):\n        unit = units_info[i]\n        if i in must_on:\n            p[i] = ranges[idx][0]\n        else:\n            p[i] = unit['p_min_i']\n    \n    # Dispatch remaining load\n    remaining = current_load - sum(p)\n    if remaining > 0:\n        # Sort by incremental cost\n        inc_costs = []\n        for i in committed:\n            unit = units_info[i]\n            current_p = p[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * current_p\n            if i in must_on:\n                max_add = ranges[must_on.index(i)][1] - current_p\n            else:\n                if unit['u_i_0'] == 1:\n                    max_add = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) - current_p\n                else:\n                    max_add = min(unit['p_max_i'], unit['p_start_i']) - current_p\n            inc_costs.append((inc_cost, i, max_add))\n        \n        inc_costs.sort(key=lambda x: x[0])\n        \n        for _, i, max_add in inc_costs:\n            if remaining <= 0:\n                break\n            add = min(remaining, max_add)\n            p[i] += add\n            remaining -= add\n    \n    # Handle must-off units\n    for i in must_off:\n        u[i] = 0\n        p[i] = 0\n        \n    return np.array([u, p])",
          "from": null,
          "gap_power_rate": 0.00524,
          "gap_price_rate": 0.01303,
          "fitness": 0.00913
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": "1. Determine must-run units based on minimum up/down time and shutdown ramp constraints\n  2. Sort candidate units by average cost at maximum output (including startup costs for offline units)\n  3. Commit units until total maximum capacity meets current load demand\n  4. Perform economic dispatch using incremental cost sorting to allocate load\n  5. Adjust outputs respecting ramp limits and minimum/maximum generation constraints\n\n",
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    must_on = [False] * n_units\n    candidate_units = []\n    \n    for i, unit in enumerate(units_info):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_on[i] = True\n            else:\n                candidate_units.append(i)\n        else:\n            if unit['t_i_0'] <= -unit['t_off_min_i']:\n                candidate_units.append(i)\n    \n    def get_avg_cost(unit, is_off):\n        p_max = unit['p_max_i']\n        cost = unit['a_i'] + unit['b_i']*p_max + unit['c_i']*p_max**2\n        if is_off:\n            cost += unit['s_i']\n        return cost / p_max\n\n    candidate_list = []\n    for i in candidate_units:\n        unit = units_info[i]\n        is_off = (unit['u_i_0'] == 0)\n        avg_cost = get_avg_cost(unit, is_off)\n        candidate_list.append((i, avg_cost))\n    \n    candidate_list.sort(key=lambda x: x[1])\n    committed = must_on[:]\n    total_max = 0\n\n    for i in range(n_units):\n        if must_on[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = unit['p_max_i']\n            total_max += max_i\n\n    for (i, _) in candidate_list:\n        if total_max >= current_load:\n            break\n        if not committed[i]:\n            committed[i] = True\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_max += max_i\n\n    p_outputs = [0] * n_units\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                low_bound = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:\n                low_bound = unit['p_min_i']\n            p_outputs[i] = low_bound\n\n    total_p = sum(p_outputs)\n    units_dispatch = []\n\n    for i in range(n_units):\n        if committed[i]:\n            unit = units_info[i]\n            if unit['u_i_0'] == 1:\n                high_bound = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                high_bound = min(unit['p_max_i'], unit['p_start_i'])\n            units_dispatch.append({\n                'index': i,\n                'b': unit['b_i'],\n                'c': unit['c_i'],\n                'current_p': p_outputs[i],\n                'high_bound': high_bound\n            })\n\n    while total_p < current_load and units_dispatch:\n        for u in units_dispatch:\n            u['ic'] = u['b'] + 2 * u['c'] * u['current_p']\n        \n        units_dispatch.sort(key=lambda x: x['ic'])\n        found = False\n        for u in units_dispatch:\n            if u['current_p'] < u['high_bound']:\n                increase = min(current_load - total_p, u['high_bound'] - u['current_p'])\n                u['current_p'] += increase\n                total_p += increase\n                found = True\n                break\n        if not found:\n            break\n\n    for u in units_dispatch:\n        p_outputs[u['index']] = u['current_p']\n\n    schedules = np.zeros((2, n_units))\n    for i in range(n_units):\n        schedules[0, i] = 1 if committed[i] else 0\n        schedules[1, i] = p_outputs[i]\n\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00558,
          "gap_price_rate": 0.0139,
          "fitness": 0.00974
     },
     {
          "name": "enhanced_commitment_simple",
          "algorithm": "1. Identify must-run units (online previously with insufficient min up-time or exceeding shutdown ramp limit) and must-off units (offline previously with insufficient min down-time)\n2. Set must-run units online, must-off units offline; retain previous states for flexible units\n3. Compute feasible generation ranges considering ramp, startup, and shutdown constraints\n4. Adjust over-committed units by turning off expensive flexible units in descending order of cost at min-output (if net min-output remains \u2264 load and net max-output \u2265 load)\n5. Adjust under-committed units by turning on offline flexible units in ascending order of startup-amortized average cost at max-output (if net max-output < load)\n6. Perform incremental cost-based dispatch for online units:\n   - Start at minimum feasible output for all online units\n   - Allocate remaining load to units with smallest incremental cost\n   - Respect individual unit ramp and max/min constraints\n7. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef enhanced_commitment_simple(units_info, load):\n    current_load = load[0]\n    n_units = len(units_info)\n    \n    a = [unit['a_i'] for unit in units_info]\n    b = [unit['b_i'] for unit in units_info]\n    c = [unit['c_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    s = [unit['s_i'] for unit in units_info]\n    u0 = [unit['u_i_0'] for unit in units_info]\n    t0 = [unit['t_i_0'] for unit in units_info]\n    p0 = [unit['p_i_0'] for unit in units_info]\n    \n    u = [0] * n_units\n    p = [0] * n_units\n    min_output = [0] * n_units\n    max_output = [0] * n_units\n    \n    must_run = []\n    must_off = []\n    flexible = list(range(n_units))\n    \n    for i in range(n_units):\n        if u0[i] == 1:\n            if t0[i] < t_on_min[i] or p0[i] > p_shut[i]:\n                must_run.append(i)\n        else:\n            if -t0[i] < t_off_min[i]:\n                must_off.append(i)\n    \n    for i in must_run:\n        if i in flexible:\n            flexible.remove(i)\n    for i in must_off:\n        if i in flexible:\n            flexible.remove(i)\n    \n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n    for i in flexible:\n        u[i] = u0[i]\n    \n    for i in range(n_units):\n        if u[i] == 1:\n            if u0[i] == 1:\n                min_output[i] = max(p_min[i], p0[i] - p_down[i])\n                max_output[i] = min(p_max[i], p0[i] + p_up[i])\n            else:\n                min_output[i] = p_min[i]\n                max_output[i] = min(p_max[i], p_start[i])\n        else:\n            min_output[i] = 0\n            max_output[i] = 0\n    \n    flex_online = [i for i in flexible if u[i] == 1]\n    flex_offline = [i for i in flexible if u[i] == 0]\n    \n    total_min = sum(min_output)\n    total_max = sum(max_output)\n    \n    cost_at_min = [a[i] + b[i]*min_output[i] + c[i]*min_output[i]**2 for i in flex_online]\n    sorted_high_cost = [i for _, i in sorted(zip(cost_at_min, flex_online), reverse=True)]\n    \n    for i in sorted_high_cost:\n        new_total_min = total_min - min_output[i]\n        new_total_max = total_max - max_output[i]\n        if new_total_min <= current_load and new_total_max >= current_load:\n            u[i] = 0\n            flex_online.remove(i)\n            flex_offline.append(i)\n            total_min = new_total_min\n            total_max = new_total_max\n            min_output[i] = max_output[i] = 0\n        if total_min <= current_load:\n            break\n    \n    if total_max < current_load:\n        cand_info = []\n        for i in flex_offline:\n            cand_max = min(p_max[i], p_start[i])\n            total_cost = a[i] + b[i]*cand_max + c[i]*cand_max**2 + s[i]\n            avg_cost = total_cost / cand_max\n            cand_info.append((i, avg_cost, p_min[i], cand_max))\n        cand_info.sort(key=lambda x: x[1])\n        \n        for (i, _, cand_min, cand_max) in cand_info:\n            if total_max >= current_load:\n                break\n            u[i] = 1\n            flex_offline.remove(i)\n            flex_online.append(i)\n            min_output[i] = cand_min\n            max_output[i] = cand_max\n            total_min += cand_min\n            total_max += cand_max\n    \n    p = [min_output[i] for i in range(n_units)]\n    residual = current_load - sum(p)\n    \n    if residual > 0:\n        online_units = [i for i in range(n_units) if u[i] == 1]\n        inc_costs = [2*c[i]*p[i] + b[i] for i in online_units]\n        headroom = [max_output[i] - p[i] for i in online_units]\n        \n        while residual > 1e-6 and any(h > 1e-6 for h in headroom):\n            min_inc = float('inf')\n            best_idx = None\n            for idx, i in enumerate(online_units):\n                if headroom[idx] > 1e-6 and inc_costs[idx] < min_inc:\n                    min_inc = inc_costs[idx]\n                    best_idx = idx\n            \n            if best_idx is None:\n                break\n            \n            i = online_units[best_idx]\n            add = min(residual, headroom[best_idx])\n            p[i] += add\n            residual -= add\n            headroom[best_idx] -= add\n            inc_costs[best_idx] = 2*c[i]*p[i] + b[i]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.0004271986,
          "gap_price_rate": 0.0197235801,
          "fitness": 0.0100753894
     },
     {
          "name": "rolling_unit_commitment_heuristic",
          "algorithm": "1. Identify must-run units: Units currently on violating min up-time or shutdown ramp limits.\n2. Identify must-off units: Units currently off violating min down-time.\n3. Commit must-run units (u_i=1) and set must-off units to off (u_i=0).\n4. Compute total min/max capacity from must-run units considering ramp constraints.\n5. Sort flexible units by average cost/MW at min output (including startup if offline).\n6. Commit cheapest flexible units until total feasible capacity covers max(current, forecasted load).\n7. Dispatch by:\n   - Setting committed units to feasible minimum considering ramp limits.\n   - Allocating remaining load by increasing output of units with lowest incremental cost at current output.\n8. Non-committed units remain off with p_i=0.\n9. Return commitment state and output allocation.\n\n",
          "code": "import numpy as np\n\ndef rolling_unit_commitment_heuristic(units_info, load):\n    units = [dict(unit) for unit in units_info]  # Copy input\n    current_load = load[0]\n    forecast_load = load[1]\n    \n    # Identify must-run and must-off units\n    must_run = [False] * len(units)\n    must_off = [False] * len(units)\n    \n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:  # Currently on\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:  # Currently off\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n        unit['u_i'] = 0  # Initialize commitment\n    \n    # Calculate total capacity for must-run units\n    total_min_must_run = 0.0\n    total_max_must_run = 0.0\n    for i, unit in enumerate(units):\n        if must_run[i]:\n            unit['u_i'] = 1  # Commit must-run\n            if unit['u_i_0'] == 1:  # Previously on\n                min_i = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:  # Previously off\n                min_i = unit['p_min_i']\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            total_min_must_run += min_i\n            total_max_must_run += max_i\n    \n    # Candidate flexible units (avg cost at min output)\n    candidate_flex = []\n    for i, unit in enumerate(units):\n        if not must_run[i] and not must_off[i]:\n            p_min = unit['p_min_i']\n            # Startup cost if currently off\n            startup_cost = unit['s_i'] * (1 - unit['u_i_0'])\n            avg_cost = (startup_cost + unit['a_i'] + unit['b_i']*p_min + unit['c_i']*p_min**2) / p_min\n            # Current period max output\n            if unit['u_i_0'] == 1:\n                max_i = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n            else:\n                max_i = min(unit['p_max_i'], unit['p_start_i'])\n            candidate_flex.append((avg_cost, max_i, i))\n    \n    # Commit cheapest flex until capacity >= max(load, forecast)\n    candidate_flex.sort(key=lambda x: x[0])\n    total_capacity = total_max_must_run\n    for _, max_i, idx in candidate_flex:\n        if total_capacity >= max(current_load, forecast_load):\n            break\n        units[idx]['u_i'] = 1  # Commit unit\n        total_capacity += max_i\n    \n    # Initial dispatch: set to min feasible output\n    p = [0.0] * len(units)\n    for i, unit in enumerate(units):\n        if unit['u_i'] == 1:  # Committed\n            if unit['u_i_0'] == 1:  # Was on\n                p[i] = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            else:  # Was off\n                p[i] = unit['p_min_i']\n    \n    # Allocate remaining load incrementally\n    total_p = sum(p)\n    remaining = current_load - total_p\n    committed_indices = [i for i in range(len(units)) if units[i]['u_i'] == 1]\n    \n    while remaining > 1e-6 and committed_indices:\n        # Calculate headroom and incremental costs\n        inc_costs = []\n        headrooms = []\n        indices = []\n        \n        for i in committed_indices:\n            # Calculate current unit constraints\n            if units[i]['u_i_0'] == 1:  # Was on\n                max_i = min(units[i]['p_max_i'], units[i]['p_i_0'] + units[i]['p_up_i'])\n                min_i = max(units[i]['p_min_i'], units[i]['p_i_0'] - units[i]['p_down_i'])\n            else:  # Was off\n                max_i = min(units[i]['p_max_i'], units[i]['p_start_i'])\n                min_i = units[i]['p_min_i']\n            headroom = max(0.0, max_i - p[i])\n            # Skip units with no headroom\n            if headroom < 1e-6:\n                continue\n            inc_cost = units[i]['b_i'] + 2 * units[i]['c_i'] * p[i]\n            inc_costs.append(inc_cost)\n            headrooms.append(headroom)\n            indices.append(i)\n        \n        if not indices:  # No headroom remaining\n            break\n        \n        # Find unit with smallest incremental cost\n        min_cost_idx = np.argmin(inc_costs)\n        i_min = indices[min_cost_idx]\n        \n        # Allocate maximum possible to this unit\n        allocate = min(remaining, headrooms[min_cost_idx])\n        p[i_min] += allocate\n        remaining -= allocate\n    \n    # Update outputs\n    for i in range(len(units)):\n        units[i]['p_i'] = p[i]\n    \n    # Prepare output array\n    u_arr = [int(unit['u_i']) for unit in units]\n    p_arr = [unit['p_i'] for unit in units]\n    return np.array([u_arr, p_arr])",
          "from": "crossover",
          "gap_power_rate": 0.0018740438,
          "gap_price_rate": 0.0185386497,
          "fitness": 0.0102063467
     },
     {
          "name": "commit_units_heuristic",
          "algorithm": null,
          "code": "import numpy as np\n\ndef commit_units_heuristic(units_info, load):\n    current_load = load[0]\n    units = units_info.copy()\n    n_units = len(units)\n    \n    # Determine must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i, unit in enumerate(units):\n        if unit['u_i_0'] == 1:\n            if unit['t_i_0'] < unit['t_on_min_i'] or unit['p_i_0'] > unit['p_shut_i']:\n                must_run[i] = True\n        else:\n            if -unit['t_i_0'] < unit['t_off_min_i']:\n                must_off[i] = True\n    \n    # Initialize commitment and output\n    u = [0] * n_units\n    p = [0.0] * n_units\n    online_units = []\n    offline_units = []\n    \n    # Commit must-run units\n    for i in range(n_units):\n        if must_run[i]:\n            u[i] = 1\n            online_units.append(i)\n        elif not must_off[i]:\n            offline_units.append(i)\n    \n    # Calculate current capacity\n    total_min = 0\n    total_max = 0\n    for i in online_units:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i'])\n            max_p = min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i'])\n        else:\n            min_p = unit['p_min_i']\n            max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n    \n    # Commit additional units if needed\n    offline_units_sorted = sorted(offline_units, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2 + units[i]['s_i']\n    ) / units[i]['p_max_i'] if units[i]['u_i_0'] == 0 else (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'])\n    \n    idx = 0\n    while total_max < current_load and idx < len(offline_units_sorted):\n        i = offline_units_sorted[idx]\n        u[i] = 1\n        unit = units[i]\n        min_p = unit['p_min_i']\n        max_p = min(unit['p_max_i'], unit['p_start_i'])\n        total_min += min_p\n        total_max += max_p\n        online_units.append(i)\n        idx += 1\n    \n    # Decommit units if excess capacity\n    online_candidates = [i for i in online_units if not must_run[i]]\n    online_candidates_sorted = sorted(online_candidates, key=lambda i: (\n        units[i]['a_i'] + units[i]['b_i'] * units[i]['p_max_i'] + \n        units[i]['c_i'] * units[i]['p_max_i']**2\n    ) / units[i]['p_max_i'], reverse=True)\n    \n    idx = 0\n    while total_min > current_load and idx < len(online_candidates_sorted):\n        i = online_candidates_sorted[idx]\n        unit = units[i]\n        min_p = max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']) if unit['u_i_0'] == 1 else unit['p_min_i']\n        if total_min - min_p >= current_load:\n            u[i] = 0\n            total_min -= min_p\n            total_max -= min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']) if unit['u_i_0'] == 1 else min(unit['p_max_i'], unit['p_start_i'])\n            online_units.remove(i)\n        idx += 1\n    \n    # Economic dispatch\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    # Calculate min and max for each committed unit\n    min_limits = []\n    max_limits = []\n    for i in committed_indices:\n        unit = units[i]\n        if unit['u_i_0'] == 1:\n            min_limits.append(max(unit['p_min_i'], unit['p_i_0'] - unit['p_down_i']))\n            max_limits.append(min(unit['p_max_i'], unit['p_i_0'] + unit['p_up_i']))\n        else:\n            min_limits.append(unit['p_min_i'])\n            max_limits.append(min(unit['p_max_i'], unit['p_start_i']))\n    \n    total_min = sum(min_limits)\n    total_max = sum(max_limits)\n    \n    if total_min > current_load:\n        # Set to min limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = min_limits[idx]\n    elif total_max < current_load:\n        # Set to max limits\n        for idx, i in enumerate(committed_indices):\n            p[i] = max_limits[idx]\n    else:\n        # Allocate load based on incremental cost\n        allocations = min_limits.copy()\n        remaining_load = current_load - total_min\n        # Create list of units with their incremental cost and capacity left\n        units_dispatch = []\n        for idx, i in enumerate(committed_indices):\n            unit = units[i]\n            inc_cost = unit['b_i'] + 2 * unit['c_i'] * allocations[idx]\n            capacity_left = max_limits[idx] - allocations[idx]\n            units_dispatch.append((inc_cost, capacity_left, idx))\n        \n        while remaining_load > 0:\n            units_dispatch.sort(key=lambda x: x[0])\n            # Find unit with lowest incremental cost\n            for j in range(len(units_dispatch)):\n                inc_cost, capacity_left, idx = units_dispatch[j]\n                if capacity_left > 0:\n                    add_load = min(remaining_load, capacity_left)\n                    allocations[idx] += add_load\n                    remaining_load -= add_load\n                    # Update incremental cost and capacity left\n                    new_inc_cost = units[committed_indices[idx]]['b_i'] + 2 * units[committed_indices[idx]]['c_i'] * allocations[idx]\n                    units_dispatch[j] = (new_inc_cost, capacity_left - add_load, idx)\n                    break\n        for idx, i in enumerate(committed_indices):\n            p[i] = allocations[idx]\n    \n    schedules = np.array([u, p])\n    return schedules",
          "from": null,
          "gap_power_rate": 0.00554,
          "gap_price_rate": 0.0151,
          "fitness": 0.01032
     },
     {
          "name": "rolling_commitment_dynamic_heuristic",
          "algorithm": "1. Identify must-run units if the unit was online and hasn't satisfied minimum uptime or the previous output exceeded shutdown ramp capacity, and must-off units if the unit was offline and hasn't satisfied minimum downtime.\n2. Set must-run units to online and must-off units to offline.\n3. Compute feasible generation ranges for online units considering ramp constraints and startup/shutdown limits.\n4. Sort candidate units by average cost at maximum output, including startup costs for offline units.\n5. Commit flexible units until total maximum capacity meets the maximum of current and forecasted load, ensuring cumulative minimum output doesn't exceed current load.\n6. Perform incremental cost-based economic dispatch respecting output and ramp constraints.\n7. Return final commitment states and power outputs for all units.\n\n",
          "code": "import numpy as np\n\ndef rolling_commitment_dynamic_heuristic(units_info, load):\n    n_units = len(units_info)\n    current_load = load[0]\n    forecasted_load = load[1]\n    u = np.zeros(n_units, dtype=int)\n    p = np.zeros(n_units)\n    lb = np.zeros(n_units)\n    ub = np.zeros(n_units)\n    \n    must_run = []\n    must_off = []\n    \n    # Identify must-run and must-off units, calculate lb and ub\n    for i, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        t_i0 = unit['t_i_0']\n        if u_i0 == 1:\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(i)\n            lb[i] = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            ub[i] = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:\n            if t_i0 < 0 and (-t_i0) < unit['t_off_min_i']:\n                must_off.append(i)\n            lb[i] = unit['p_min_i']\n            ub[i] = min(unit['p_max_i'], unit['p_start_i'], unit['p_up_i'])\n    \n    # Set commitment states for must-run and must-off\n    for i in must_run:\n        u[i] = 1\n    for i in must_off:\n        u[i] = 0\n        lb[i] = 0\n        ub[i] = 0\n    \n    # Initialize capacities\n    total_min = np.sum([lb[i] for i in must_run])\n    total_max = np.sum([ub[i] for i in must_run])\n    flexible = [i for i in range(n_units) if i not in must_run and i not in must_off]\n    \n    # Compute cost per MW for flexible units\n    cost_per_MW = []\n    for i in flexible:\n        unit = units_info[i]\n        cost = unit['a_i'] + unit['b_i'] * ub[i] + unit['c_i'] * (ub[i] ** 2)\n        if unit['u_i_0'] == 0:\n            cost += unit['s_i']\n        if ub[i] > 1e-6:\n            cost_per_MW.append(cost / ub[i])\n        else:\n            cost_per_MW.append(float('inf'))\n    \n    # Sort flexible units by cost_per_MW\n    sorted_flexible = [x for _, x in sorted(zip(cost_per_MW, flexible))]\n    \n    # Commit flexible units\n    target_capacity = max(current_load, forecasted_load)\n    for i in sorted_flexible:\n        if total_max >= target_capacity:\n            break\n        if total_min + lb[i] <= current_load and ub[i] > 1e-6:\n            u[i] = 1\n            total_min += lb[i]\n            total_max += ub[i]\n    \n    # Initialize outputs for committed units\n    committed_indices = [i for i in range(n_units) if u[i] == 1]\n    for i in committed_indices:\n        p[i] = lb[i]\n    \n    # Economic dispatch\n    total_output = sum(p)\n    deficit = current_load - total_output\n    while deficit > 1e-6:\n        min_incr = float('inf')\n        candidate = None\n        for i in committed_indices:\n            if p[i] < ub[i]:\n                incr_cost = 2 * units_info[i]['c_i'] * p[i] + units_info[i]['b_i']\n                if incr_cost < min_incr:\n                    min_incr = incr_cost\n                    candidate = i\n        if candidate is None:\n            break\n        headroom = ub[candidate] - p[candidate]\n        delta = min(deficit, headroom)\n        p[candidate] += delta\n        deficit -= delta\n    \n    schedules = np.vstack((u, p))\n    return schedules",
          "from": "crossover",
          "gap_power_rate": 0.0018478808,
          "gap_price_rate": 0.0196116889,
          "fitness": 0.0107297849
     },
     {
          "name": "rolling_forecast_uc",
          "algorithm": "1. Identify must-run units (units that were online with insufficient min uptime or previous output exceeding shutdown ramp capacity) and must-off units (units offline with insufficient min downtime)  \n2. Set must-run units online, must-off units offline; retain previous states for flexible units  \n3. Compute feasible output ranges for online units considering ramp constraints (previously online) and startup limits (newly started units)  \n4. Calculate total min/max output capacity  \n5. Adjust over-committed units:  \n   - Sort non-must-run online units by operating cost at min output (descending)  \n   - Turn off units if removing them maintains min output \u2264 current load and doesn't reduce max output below next period's forecasted load  \n6. Adjust under-committed units:  \n   - Sort candidate offline units by amortized startup cost at min output  \n   - Turn on units until max output covers max(current load, forecasted load) while maintaining min output \u2264 current load  \n7. Recompute feasible output ranges for all online units  \n8. Dispatch load economically:  \n   - Set all online units to min output  \n   - Allocate residual load to units with smallest incremental cost while respecting output limits  \n9. Set offline units' output to zero  \n10. Return commitment states and power outputs  \n\n",
          "code": "import numpy as np\n\ndef rolling_forecast_uc(units_info, load):\n    # Extract loads\n    current_load = load[0]\n    next_load = load[1]\n    \n    # Identify must-run and must-off units\n    must_run = []\n    must_off = []\n    for unit in units_info:\n        u_i0 = unit['u_i_0']\n        t_i0 = unit['t_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            if t_i0 < unit['t_on_min_i'] or p_i0 > unit['p_shut_i']:\n                must_run.append(unit)\n        else:  # Previously offline\n            if -t_i0 < unit['t_off_min_i']:\n                must_off.append(unit)\n    \n    # Set commitment states\n    for unit in units_info:\n        if unit in must_run:\n            unit['u_i'] = 1\n        elif unit in must_off:\n            unit['u_i'] = 0\n        else:\n            unit['u_i'] = unit['u_i_0']\n    \n    # Compute feasible output ranges and initial capacity\n    online_units = [u for u in units_info if u['u_i'] == 1]\n    for unit in online_units:\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Previously online\n            lb = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            ub = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Newly started\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit['lb'] = lb\n        unit['ub'] = ub\n    \n    total_min = sum(u['lb'] for u in online_units)\n    total_max = sum(u['ub'] for u in online_units)\n    \n    # Over-commitment adjustment\n    flexible_online = [u for u in online_units if u not in must_run and u['u_i_0'] == 1]\n    flexible_online.sort(\n        key=lambda x: (x['a_i'] + x['b_i']*x['lb'] + x['c_i']*x['lb']**2) / x['lb'], \n        reverse=True\n    )\n    \n    for unit in flexible_online[:]:  # Use copy for safe removal\n        candidate_min = total_min - unit['lb']\n        candidate_max = total_max - unit['ub']\n        \n        if candidate_min <= current_load and candidate_max >= next_load:\n            unit['u_i'] = 0\n            total_min = candidate_min\n            total_max = candidate_max\n            online_units.remove(unit)\n            flexible_online.remove(unit)\n    \n    # Under-commitment adjustment\n    target_capacity = max(current_load, next_load)\n    candidate_offline = [u for u in units_info \n                         if u['u_i'] == 0 and u not in must_off]\n    \n    candidate_offline.sort(\n        key=lambda x: (x['s_i'] + x['a_i'] + x['b_i']*x['p_min_i'] + x['c_i']*x['p_min_i']**2) / x['p_min_i']\n    )\n    \n    for unit in candidate_offline:\n        if total_max >= target_capacity:\n            break\n            \n        new_min = total_min + unit['p_min_i']\n        new_max = total_max + min(unit['p_max_i'], unit['p_start_i'])\n        \n        if new_min <= current_load:\n            unit['u_i'] = 1\n            online_units.append(unit)\n            total_min = new_min\n            total_max = new_max\n            \n            # Set bounds for new unit\n            unit['lb'] = unit['p_min_i']\n            unit['ub'] = min(unit['p_max_i'], unit['p_start_i'])\n    \n    # Recompute ranges for all online units\n    for unit in online_units:\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        \n        if u_i0 == 1:  # Continuously online\n            lb = max(unit['p_min_i'], p_i0 - unit['p_down_i'])\n            ub = min(unit['p_max_i'], p_i0 + unit['p_up_i'])\n        else:  # Newly started\n            lb = unit['p_min_i']\n            ub = min(unit['p_max_i'], unit['p_start_i'])\n        \n        unit['lb'] = lb\n        unit['ub'] = ub\n        unit['p_i'] = lb  # Initialize dispatch at min output\n    \n    # Economic dispatch\n    output_sum = sum(u['p_i'] for u in online_units)\n    residual = current_load - output_sum\n    \n    # Dispatch residual load incrementally\n    while residual > 1e-5:\n        candidates = []\n        for unit in online_units:\n            if unit['p_i'] < unit['ub']:\n                inc_cost = 2 * unit['c_i'] * unit['p_i'] + unit['b_i']\n                candidates.append((inc_cost, unit))\n        \n        if not candidates:\n            break\n            \n        # Find unit with minimal incremental cost\n        candidates.sort(key=lambda x: x[0])\n        _, best_unit = candidates[0]\n        \n        # Calculate maximum possible increase\n        max_increase = best_unit['ub'] - best_unit['p_i']\n        increase = min(residual, max_increase)\n        \n        # Update output\n        best_unit['p_i'] += increase\n        residual -= increase\n    \n    # Set offline units to zero output\n    for unit in units_info:\n        if unit['u_i'] == 0:\n            unit['p_i'] = 0.0\n    \n    # Prepare output array\n    u_i = [unit['u_i'] for unit in units_info]\n    p_i = [unit['p_i'] for unit in units_info]\n    \n    return np.array([u_i, p_i])",
          "from": "crossover",
          "gap_power_rate": 0.0008081062,
          "gap_price_rate": 0.0215339745,
          "fitness": 0.0111710403
     },
     {
          "name": "forecast_enhanced_rolling_commitment",
          "algorithm": "1. Identify must-run and must-off units:\n   - Must-run: Units currently online that violate minimum up-time or whose previous output exceeds shutdown ramp capacity\n   - Must-off: Units currently offline that violate minimum down-time\n2. Set commitment states:\n   - Must-run units: u_i=1\n   - Must-off units: u_i=0\n   - Others: retain previous state\n3. Compute feasible generation bounds for online units considering ramp constraints:\n   - For units previously online: [max(p_min_i, p_i_0 - p_down_i), min(p_max_i, p_i_0 + p_up_i)]\n   - For newly started units: [p_min_i, min(p_max_i, p_start_i, p_up_i)]\n4. Calculate total min/max generation capacity\n5. Over-commitment adjustment:\n   - Sort flexible online units by operating cost at min output (descending)\n   - Turn off units that can be decommitted while maintaining next period coverage and without violating current load constraints\n6. Under-commitment adjustment:\n   - Sort candidate offline units by amortized startup cost at min output\n   - Turn on units needed to cover max(current, next period load) without exceeding current load capacity\n7. Economic dispatch:\n   - Initialize outputs at lower bounds\n   - Allocate residual load to units with smallest incremental cost\n   - Respect individual unit ramp constraints and generation limits\n8. Return final commitment states and power outputs\n\n",
          "code": "import numpy as np\n\ndef forecast_enhanced_rolling_commitment(units_info, load):\n    n_units = len(units_info)\n    # Extract attributes\n    u_i_0 = [unit['u_i_0'] for unit in units_info]\n    p_i_0 = [unit['p_i_0'] for unit in units_info]\n    t_i_0 = [unit['t_i_0'] for unit in units_info]\n    t_on_min = [unit['t_on_min_i'] for unit in units_info]\n    t_off_min = [unit['t_off_min_i'] for unit in units_info]\n    p_shut = [unit['p_shut_i'] for unit in units_info]\n    a_i = [unit['a_i'] for unit in units_info]\n    b_i = [unit['b_i'] for unit in units_info]\n    c_i = [unit['c_i'] for unit in units_info]\n    s_i = [unit['s_i'] for unit in units_info]\n    p_min = [unit['p_min_i'] for unit in units_info]\n    p_max = [unit['p_max_i'] for unit in units_info]\n    p_up = [unit['p_up_i'] for unit in units_info]\n    p_down = [unit['p_down_i'] for unit in units_info]\n    p_start = [unit['p_start_i'] for unit in units_info]\n    \n    # Step 1: Identify must-run and must-off units\n    must_run = [False] * n_units\n    must_off = [False] * n_units\n    for i in range(n_units):\n        if u_i_0[i] == 1:  # Was online\n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:\n                must_run[i] = True\n        else:  # Was offline\n            if -t_i_0[i] < t_off_min[i]:  # Using absolute offline time\n                must_off[i] = True\n    \n    # Step 2: Initialize commitment states\n    u_i = [1 if must_run[i] else (0 if must_off[i] else u_i_0[i]) for i in range(n_units)]\n    \n    # Step 3: Compute generation bounds\n    lb = [0] * n_units\n    ub = [0] * n_units\n    for i in range(n_units):\n        if u_i[i] == 1:\n            if u_i_0[i] == 1:  # Was online\n                lb[i] = max(p_min[i], p_i_0[i] - p_down[i])\n                ub[i] = min(p_max[i], p_i_0[i] + p_up[i])\n            else:  # New start\n                lb[i] = p_min[i]\n                ub[i] = min(p_max[i], p_start[i], p_up[i])\n    \n    # Step 4: Compute total capacity\n    total_min_output = sum(lb)\n    total_max_output = sum(ub)\n    target_load = max(load)\n    \n    # Step 5: Over-commitment adjustment\n    online_flex = [i for i in range(n_units) if u_i[i] == 1 and not must_run[i] and not must_off[i]]\n    # Sort by operating cost at min output (descending)\n    operating_cost = [a_i[i] + b_i[i] * lb[i] + c_i[i] * lb[i]**2 for i in online_flex]\n    idx_sorted = [i for _, i in sorted(zip(operating_cost, online_flex), reverse=True)]\n    \n    for i in idx_sorted:\n        new_min = total_min_output - lb[i]\n        new_max = total_max_output - ub[i]\n        if new_max >= target_load and new_min <= load[0]:\n            total_min_output = new_min\n            total_max_output = new_max\n            u_i[i] = 0\n            lb[i] = ub[i] = 0\n    \n    # Step 6: Under-commitment adjustment\n    offline_flex = [i for i in range(n_units) if u_i[i] == 0 and not must_run[i] and not must_off[i]]\n    candidate_info = []\n    for i in offline_flex:\n        lb_cand = p_min[i]\n        ub_cand = min(p_max[i], p_start[i], p_up[i])\n        cost_startup = s_i[i] + a_i[i] + b_i[i] * lb_cand + c_i[i] * lb_cand**2\n        cost_per_mw = cost_startup / lb_cand if lb_cand > 0 else float('inf')\n        candidate_info.append((i, lb_cand, ub_cand, cost_per_mw))\n    \n    candidate_info.sort(key=lambda x: x[3])\n    \n    for i, lb_cand, ub_cand, _ in candidate_info:\n        if total_max_output >= target_load:\n            break\n        if total_min_output + lb_cand <= load[0]:\n            u_i[i] = 1\n            lb[i] = lb_cand\n            ub[i] = ub_cand\n            total_min_output += lb_cand\n            total_max_output += ub_cand\n    \n    # Step 7: Economic dispatch\n    current_output = lb.copy()\n    residual = load[0] - sum(current_output)\n    online_idx = [i for i in range(n_units) if u_i[i] == 1]\n    \n    # Dispatch loop\n    while residual > 1e-6 and online_idx:\n        inc_costs = []\n        available = []\n        for i in online_idx:\n            if current_output[i] < ub[i]:\n                inc = b_i[i] + 2 * c_i[i] * current_output[i]\n                inc_costs.append((inc, i))\n                available.append(ub[i] - current_output[i])\n        \n        if not inc_costs:\n            break\n        \n        # Find unit with lowest incremental cost\n        min_inc = min(inc_costs, key=lambda x: x[0])\n        idx = min_inc[1]\n        # Calculate allocatable amount\n        alloc = min(ub[idx] - current_output[idx], residual)\n        current_output[idx] += alloc\n        residual -= alloc\n    \n    # Format output\n    schedules = np.zeros((2, n_units))\n    schedules[0, :] = u_i\n    schedules[1, :] = current_output\n    return schedules",
          "from": "mutation",
          "gap_power_rate": 0.001942527,
          "gap_price_rate": 0.0207056304,
          "fitness": 0.0113240787
     },
     {
          "name": "refined_rolling_commitment",
          "algorithm": "**  \n1. Identify must-run and must-off units based on min up/down times, shutdown ramp constraints, and ramp constraints\n2. Initialize commitment states: set must-run units on, must-off units off\n3. Activate flexible offline units for current load using startup cost-amortized merit order\n4. If next period's forecasted load exceeds projected capacity, activate additional units for future constraints\n5. Perform economic dispatch via incremental cost while respecting output, ramp, startup, and shutdown constraints\n6. Adjust outputs to match load demand; handle over-generation by minimum output settings  \n\n**",
          "code": "import numpy as np\n\ndef refined_rolling_commitment(units_info, load):\n    current_load, forecast_load = load\n    num_units = len(units_info)\n    u = np.zeros(num_units)\n    p = np.zeros(num_units)\n    must_on = []\n    must_off = []\n    online_units = set()\n    min_feasible = {}\n    max_feasible = {}\n    \n    # Step 1: Classify must-run and must-off units\n    for idx, unit in enumerate(units_info):\n        u_i0 = unit['u_i_0']\n        p_i0 = unit['p_i_0']\n        min_out = unit['p_min_i']\n        max_out = unit['p_max_i']\n        ramp_down = unit['p_down_i']\n        \n        # Must-on: violating min-up time or shutdown ramp constraint\n        if u_i0 == 1:\n            time_on = unit['t_i_0']\n            min_uptime = unit['t_on_min_i']\n            if time_on < min_uptime or p_i0 > unit['p_shut_i']:\n                must_on.append(idx)\n                online_units.add(idx)\n                # Set feasible range for online units\n                min_feasible[idx] = max(min_out, p_i0 - ramp_down)\n                max_feasible[idx] = min(max_out, p_i0 + unit['p_up_i'])\n            else:\n                min_feasible[idx] = max(min_out, p_i0 - ramp_down)\n                max_feasible[idx] = min(max_out, p_i0 + unit['p_up_i'])\n        # Must-off: violating min-down time\n        elif u_i0 == 0:\n            time_off = -unit['t_i_0']\n            min_downtime = unit['t_off_min_i']\n            if time_off < min_downtime:\n                must_off.append(idx)\n                min_feasible[idx] = 0\n                max_feasible[idx] = 0\n            else:\n                min_feasible[idx] = 0\n                max_feasible[idx] = min(max_out, unit['p_start_i'])  # Startup ramp limit\n    \n    # Step 2: Initialize commitment states\n    for idx in must_on:\n        u[idx] = 1\n    for idx in must_off:\n        u[idx] = 0\n        p[idx] = 0\n    \n    # Compute current min/max capacity from must-on units\n    total_min_on = sum(min_feasible[i] for i in must_on)\n    total_max_on = sum(max_feasible[i] for i in must_on)\n    \n    # Step 3: Activate flexible offline units for current load\n    candidate_ids = [\n        i for i in range(num_units)\n        if i not in must_on and i not in must_off and units_info[i]['u_i_0'] == 0\n    ]\n    # Sort by average cost per MW at min output including startup\n    candidate_ids.sort(key=lambda i: (\n        units_info[i]['s_i'] + \n        units_info[i]['a_i'] + \n        units_info[i]['b_i'] * units_info[i]['p_min_i'] + \n        units_info[i]['c_i'] * (units_info[i]['p_min_i'] ** 2)\n    ) / units_info[i]['p_min_i'])\n    \n    activated = []\n    remaining_capacity = current_load - total_max_on\n    if remaining_capacity > 0:\n        for idx in candidate_ids:\n            if remaining_capacity <= 0:\n                break\n            unit = units_info[idx]\n            p_max_start = min(unit['p_max_i'], unit['p_start_i'])\n            u[idx] = 1\n            online_units.add(idx)\n            activated.append(idx)\n            min_feasible[idx] = unit['p_min_i']\n            max_feasible[idx] = p_max_start\n            total_max_on += p_max_start\n            remaining_capacity -= p_max_start\n    \n    # Step 4: Activate additional units for forecasted load\n    projected_max = sum(min_feasible[i] + units_info[i]['p_up_i'] for i in online_units)\n    next_deficit = forecast_load - projected_max\n    if next_deficit > 0:\n        remaining_candidates = [i for i in candidate_ids if i not in activated]\n        for idx in remaining_candidates:\n            if next_deficit <= 0:\n                break\n            unit = units_info[idx]\n            p_next_contrib = min(unit['p_max_i'], unit['p_start_i'] + unit['p_up_i'])\n            u[idx] = 1\n            online_units.add(idx)\n            min_feasible[idx] = unit['p_min_i']\n            max_feasible[idx] = min(unit['p_max_i'], unit['p_start_i'])\n            next_deficit -= p_next_contrib\n    \n    # Step 5: Economic dispatch with incremental cost\n    committed_units = sorted(online_units)\n    # Set to feasible minimum\n    for idx in committed_units:\n        p[idx] = min_feasible[idx]\n    total_output = sum(p)\n    residual = current_load - total_output\n    \n    # Increase outputs if under-generated\n    if residual > 0:\n        incr_costs = []\n        for idx in committed_units:\n            unit = units_info[idx]\n            incr_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n            incr_costs.append((incr_cost, idx, max_feasible[idx] - p[idx]))\n        incr_costs.sort(key=lambda x: x[0])\n        for cost, idx, avail in incr_costs:\n            if residual <= 0:\n                break\n            add = min(residual, avail)\n            p[idx] += add\n            residual -= add\n    \n    # Decrease outputs if over-generated (only for non-must-run units)\n    elif residual < 0:\n        decr_costs = []\n        for idx in committed_units:\n            if idx in must_on:\n                continue\n            unit = units_info[idx]\n            incr_cost = unit['b_i'] + 2 * unit['c_i'] * p[idx]\n            decr_costs.append((incr_cost, idx, p[idx] - min_feasible[idx]))\n        decr_costs.sort(key=lambda x: -x[0])  # Reverse order for decreasing\n        for cost, idx, reduc in decr_costs:\n            if residual >= 0:\n                break\n            reduction = min(-residual, reduc)\n            p[idx] -= reduction\n            residual += reduction\n    \n    return np.array([u, p])",
          "from": "mutation",
          "gap_power_rate": 0.0124488477,
          "gap_price_rate": 0.0172230614,
          "fitness": 0.0148359546
     },
     {
          "name": "enhanced_rolling_commitment",
          "algorithm": "1. Identify must-run units (online with insufficient uptime or output above shutdown ramp capacity) and must-off units (offline with insufficient downtime).  \n2. Set must-run units to on, must-off units to off; flexible units retain prior state.  \n3. Address over-commitment by selectively turning off expensive flexible units to reduce excessive minimum generation capacity while ensuring current and forecasted load coverage.  \n4. Address under-commitment by turning on cheap flexible units to meet current and next period's maximum load demand.  \n5. Compute feasible generation ranges for online units considering ramp/startup/shutdown limits.  \n6. Allocate current load to online units via incremental cost-based dispatch using iterative greedy allocation with step sizes, ensuring minimal residual generation mismatch.  \n7. Return commitment states and generation outputs.  \n\n",
          "code": "import numpy as np  \n\ndef enhanced_rolling_commitment(units_info, load):  \n    current_load = load[0]  \n    forecast_load = load[1]  \n    n_units = len(units_info)  \n      \n    # Extract unit attributes  \n    a = [unit['a_i'] for unit in units_info]  \n    b = [unit['b_i'] for unit in units_info]  \n    c = [unit['c_i'] for unit in units_info]  \n    u_i_0 = [unit['u_i_0'] for unit in units_info]  \n    p_i_0 = [unit['p_i_0'] for unit in units_info]  \n    p_min = [unit['p_min_i'] for unit in units_info]  \n    p_max = [unit['p_max_i'] for unit in units_info]  \n    p_up = [unit['p_up_i'] for unit in units_info]  \n    p_down = [unit['p_down_i'] for unit in units_info]  \n    p_start = [unit['p_start_i'] for unit in units_info]  \n    p_shut = [unit['p_shut_i'] for unit in units_info]  \n    t_on_min = [unit['t_on_min_i'] for unit in units_info]  \n    t_off_min = [unit['t_off_min_i'] for unit in units_info]  \n    s = [unit['s_i'] for unit in units_info]  \n    t_i_0 = [unit['t_i_0'] for unit in units_info]  \n      \n    # Step 1: Identify must-run and must-off units  \n    must_run = []  \n    must_off = []  \n    for i in range(n_units):  \n        if u_i_0[i] == 1:  \n            if t_i_0[i] < t_on_min[i] or p_i_0[i] > p_shut[i]:  \n                must_run.append(i)  \n        else:  \n            if t_i_0[i] <= 0 and abs(t_i_0[i]) < t_off_min[i]:  \n                must_off.append(i)  \n      \n    # Step 2: Initialize commitment states  \n    u_i = u_i_0.copy()  \n    for i in must_run:  \n        u_i[i] = 1  \n    for i in must_off:  \n        u_i[i] = 0  \n      \n    # Step 3: Compute initial feasible ranges  \n    lb = [0] * n_units  \n    hb = [0] * n_units  \n    for i in range(n_units):  \n        if u_i[i] == 1:  \n            if u_i_0[i] == 0:  # Started this period  \n                lb[i] = p_min[i]  \n                hb[i] = min(p_max[i], p_up[i], p_start[i])  \n            else:  \n                lb[i] = max(p_min[i], p_i_0[i] - p_down[i])  \n                hb[i] = min(p_max[i], p_i_0[i] + p_up[i])  \n        else:  \n            lb[i] = hb[i] = 0  \n    total_min = sum(lb)  \n    total_max = sum(hb)  \n      \n    # Step 4: Adjust over-commitment  \n    online_flexible = [  \n        i for i in range(n_units)  \n        if u_i[i] == 1 and i not in must_run and i not in must_off  \n    ]  \n    # Sort by average cost per MW at max output (expensive first)  \n    online_flexible.sort(  \n        key=lambda i: (a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)) / p_max[i],  \n        reverse=True  \n    )  \n    for idx in online_flexible:  \n        new_total_min = total_min - lb[idx]  \n        new_total_max = total_max - hb[idx]  \n        if (new_total_min <= current_load and  \n                new_total_max >= max(current_load, forecast_load)):  \n            u_i[idx] = 0  \n            lb[idx] = hb[idx] = 0  \n            total_min, total_max = new_total_min, new_total_max  \n            if total_min <= current_load:  \n                break  \n                  \n    # Step 5: Adjust under-commitment for current + forecasted load  \n    offline_flexible = [  \n        i for i in range(n_units)  \n        if u_i[i] == 0 and i not in must_run and i not in must_off  \n    ]  \n    # Sort by average cost per MW at max output including startup (cheapest first)  \n    offline_flexible.sort(  \n        key=lambda i: (s[i] + a[i] + b[i]*p_max[i] + c[i]*(p_max[i]**2)) / p_max[i]  \n    )  \n    for idx in offline_flexible:  \n        if total_max >= max(current_load, forecast_load):  \n            break  \n        new_lb = p_min[idx]  \n        new_hb = min(p_max[idx], p_up[idx], p_start[idx])  \n        u_i[idx] = 1  \n        lb[idx] = new_lb  \n        hb[idx] = new_hb  \n        total_min += new_lb  \n        total_max += new_hb  \n      \n    # Step 6: Dispatch current load to online units  \n    p_i = [0.0] * n_units  \n    online_idxs = [i for i in range(n_units) if u_i[i] == 1]  \n    for i in online_idxs:  \n        p_i[i] = lb[i]  \n    deficit = current_load - sum(p_i)  \n      \n    # Iterative greedy dispatch  \n    step_size = 0.1  \n    while deficit > 1e-3:  \n        best_unit = None  \n        min_inc = float('inf')  \n        for i in online_idxs:  \n            if p_i[i] < hb[i]:  \n                inc_cost = b[i] + 2 * c[i] * p_i[i]  \n                if inc_cost < min_inc:  \n                    min_inc = inc_cost  \n                    best_unit = i  \n        if best_unit is None:  \n            break  \n        inc_amount = min(step_size, hb[best_unit] - p_i[best_unit], deficit)  \n        p_i[best_unit] += inc_amount  \n        deficit -= inc_amount  \n    \n    # Return schedules as numpy array  \n    return np.array([u_i, p_i])  ",
          "from": "mutation",
          "gap_power_rate": 0.0001191359,
          "gap_price_rate": 0.0315997051,
          "fitness": 0.0158594205
     }
]